{
  "astropy__astropy-12907": "",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..83f9628 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,6 +1,72 @@\n+\n+def test_rst_with_header_rows():\n+    \"\"\"Round-trip a table with header_rows specified\"\"\"\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct     \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\",\n+    ]\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"wave\"].dtype == np.float64\n+    assert tbl[\"response\"].dtype == np.float32\n+    assert tbl[\"ints\"].dtype == np.int8\n+\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert out.getvalue().splitlines() == lines\n+\n+def test_rst_with_header_rows_name_unit_only():\n+    \"\"\"Test table with header_rows specifying only name and unit\"\"\"\n+    lines = [\n+        \"======= ======== \",\n+        \"   wave response \",\n+        \"     nm       ct \",\n+        \"======= ======== \",\n+        \"  350.0      0.7 \",\n+        \"  950.0      1.2 \",\n+        \"======= ======== \",\n+    ]\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\n+    assert out.getvalue().splitlines() == lines\n+\n+def test_rst_with_header_rows_different_columns():\n+    \"\"\"Test table with different column numbers than header rows\"\"\"\n+    lines = [\n+        \"======= ======== =====\",\n+        \"   wave response extra\",\n+        \"     nm       ct  misc\",\n+        \"======= ======== =====\",\n+        \"  350.0      0.7    x \",\n+        \"  950.0      1.2    y \",\n+        \"======= ======== =====\",\n+    ]\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"extra\"].unit == 'misc'\n+    \n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\n+    assert out.getvalue().splitlines() == lines\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n from io import StringIO\n+import numpy as np\n+import astropy.units as u\n+from astropy.table import QTable\n \n from astropy.io import ascii\n \n",
  "astropy__astropy-14365": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 9b66109..edbb741 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -38,6 +38,83 @@ def test_get_tables_from_qdp_file(tmp_path):\n     assert table0.meta[\"initial_comments\"][0].startswith(\"Swift\")\n     assert table0.meta[\"comments\"][0].startswith(\"WT -- hard data\")\n     table2 = _read_table_qdp(fp.name, names=[\"MJD\", \"Rate\"], table_id=2)\n+\n+def lowercase_header(value):\n+    \"\"\"Make every non-comment line lower case.\"\"\"\n+    lines = []\n+    for line in value.splitlines():\n+        if not line.startswith(\"!\"):\n+            line = line.lower()\n+        lines.append(line)\n+    return \"\\n\".join(lines)\n+\n+@pytest.mark.parametrize(\"lowercase\", [False, True])\n+def test_roundtrip(tmp_path, lowercase):\n+    example_qdp = \"\"\"\n+    ! Swift/XRT hardness ratio of trigger: XXXX, name: BUBU X-2\n+    ! Columns are as labelled\n+    READ TERR 1\n+    READ SERR 2\n+    ! WT -- hard data\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   NO       0.212439\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   0.000000        0.000000\n+    NO NO NO NO NO\n+    ! WT -- soft data\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   0.726155        0.583890\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   2.410935        1.393592\n+    NO NO NO NO NO\n+    ! WT -- hardness ratio\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   -0.292553       -0.374935\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   0.000000        NO\n+    ! Add command, just to raise the warning.\n+    READ TERR 1\n+    ! WT -- whatever\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   -0.292553       -0.374935\n+    NO 1.14467592592593e-05    -1.14467592592593e-05   0.000000        NO\n+    \"\"\"\n+    if lowercase:\n+        example_qdp = lowercase_header(example_qdp)\n+\n+    path = str(tmp_path / \"test.qdp\")\n+    path2 = str(tmp_path / \"test2.qdp\")\n+\n+    with open(path, \"w\") as fp:\n+        print(example_qdp, file=fp)\n+    with pytest.warns(AstropyUserWarning) as record:\n+        table = _read_table_qdp(path, names=[\"MJD\", \"Rate\"], table_id=0)\n+    assert np.any(\n+        [\n+            \"This file contains multiple command blocks\" in r.message.args[0]\n+            for r in record\n+        ]\n+    )\n+\n+    _write_table_qdp(table, path2)\n+\n+    new_table = _read_table_qdp(path2, names=[\"MJD\", \"Rate\"], table_id=0)\n+\n+    for col in new_table.colnames:\n+        is_masked = np.array([np.ma.is_masked(val) for val in new_table[col]])\n+        if np.any(is_masked):\n+            # All NaN values are read as such.\n+            assert np.ma.is_masked(table[col][is_masked])\n+\n+        is_nan = np.array(\n+            [(not np.ma.is_masked(val) and np.isnan(val)) for val in new_table[col]]\n+        )\n+        # All non-NaN values are the same\n+        assert np.allclose(new_table[col][~is_nan], table[col][~is_nan])\n+        if np.any(is_nan):\n+            # All NaN values are read as such.\n+            assert np.isnan(table[col][is_nan])\n+    assert np.allclose(new_table[\"MJD_perr\"], [2.378472e-05, 1.1446759e-05])\n+\n+    for meta_name in [\"initial_comments\", \"comments\"]:\n+        assert meta_name in new_table.meta\n     assert table2.meta[\"initial_comments\"][0].startswith(\"Swift\")\n     assert table2.meta[\"comments\"][0].startswith(\"WT -- hardness\")\n     assert np.isclose(table2[\"MJD_nerr\"][0], -2.37847222222222e-05)\n",
  "astropy__astropy-14995": "diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py\nindex fc27f69..69f0fe5 100644\n--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py\n+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py\n@@ -28,23 +28,28 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n         return False\n \n \n-# Test with Data covers:\n-# scalars, 1D, 2D and 3D\n-# broadcasting between them\n-@pytest.mark.filterwarnings(\"ignore:divide by zero encountered.*\")\n-@pytest.mark.parametrize(\n-    (\"data1\", \"data2\"),\n-    [\n-        (np.array(5), np.array(10)),\n-        (np.array(5), np.arange(10)),\n-        (np.array(5), np.arange(10).reshape(2, 5)),\n-        (np.arange(10), np.ones(10) * 2),\n-        (np.arange(10), np.ones((10, 10)) * 2),\n-        (np.arange(10).reshape(2, 5), np.ones((2, 5)) * 3),\n-        (np.arange(1000).reshape(20, 5, 10), np.ones((20, 5, 10)) * 3),\n-    ],\n-)\n-def test_arithmetics_data(data1, data2):\n+import numpy as np\n+from astropy.nddata import NDDataRef\n+\n+def test_nddataref_mask_propagation():\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+\n+    # Multiply operation where one operand has a mask and the other does not\n+    result_masked_constant = nref_mask.multiply(1., handle_mask=np.bitwise_or).mask\n+    np.testing.assert_equal(result_masked_constant, mask)\n+\n+    result_masked_no_mask = nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask\n+    np.testing.assert_equal(result_masked_no_mask, mask)\n+\n+    other_mask = np.array([[64, 1, 0], [2, 1, 0], [8, 0, 2]])\n+    nref_mask_other = NDDataRef(array, mask=other_mask)\n+    combined_mask = np.bitwise_or(mask, other_mask)\n+    result_combined_mask = nref_mask_other.multiply(nref_mask, handle_mask=np.bitwise_or).mask\n+    np.testing.assert_equal(result_combined_mask, combined_mask)\n     nd1 = NDDataArithmetic(data1)\n     nd2 = NDDataArithmetic(data2)\n \n",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..0fa9c4c 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -265,7 +265,22 @@ class TestTableFunctions(FitsTestCase):\n             (345.0, 345)], names='c1, c2')\n         assert comparerecords(a[1].data, ra1)\n \n-        # Test slicing\n+        # Test D to E Exponent Handling\n+\n+        # Creating a data record with numbers expected to have D exponents\n+        r1 = np.array([11.5, 12.5])\n+        c2 = fits.Column(name='def', format='D', array=r1)\n+        hdu = fits.TableHDU.from_columns([c2])\n+        hdu.writeto(self.temp('d_exponent_test.fits'), overwrite=True)\n+\n+        # Reading back the FITS file to ensure 'D' to 'E' conversion occurs\n+        with open(self.temp('d_exponent_test.fits')) as f:\n+            content = f.read()\n+            assert '1.1500000000000000E+01' in content\n+            assert '1.2500000000000000E+01' in content\n+        \n+        with fits.open(self.temp('d_exponent_test.fits')) as hdul:\n+            assert comparerecords(hdu.data, hdul[1].data)\n         a2 = a[1].data[2:][2:]\n         ra2 = np.rec.array([(345.0, 345)], names='c1, c2')\n \n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..af0ca82 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1103,7 +1103,34 @@ class OverrideSettingsTests(SimpleTestCase):\n         with self.settings(FILE_UPLOAD_PERMISSIONS=0o777):\n             self.assertEqual(default_storage.file_permissions_mode, 0o777)\n \n-    def test_override_file_upload_directory_permissions(self):\n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        Default FILE_UPLOAD_PERMISSIONS setting should be 0o644 when not set.\n+        \"\"\"\n+        self.assertEqual(default_storage.file_permissions_mode, 0o644)\n+\n+    def test_uploaded_file_respects_default_permissions(self):\n+        \"\"\"\n+        Verify uploaded files default to 0o644 permissions when no explicit permissions are set.\n+        \"\"\"\n+        file_path = default_storage.save('test_file.txt', ContentFile('content'))\n+        try:\n+            mode = os.stat(default_storage.path(file_path)).st_mode & 0o777\n+            self.assertEqual(mode, 0o644)\n+        finally:\n+            default_storage.delete(file_path)\n+\n+    def test_uploaded_file_respects_override_permissions(self):\n+        \"\"\"\n+        Verify uploaded files respect overridden FILE_UPLOAD_PERMISSIONS.\n+        \"\"\"\n+        with self.settings(FILE_UPLOAD_PERMISSIONS=0o600):\n+            file_path = default_storage.save('test_file_600.txt', ContentFile('content'))\n+            try:\n+                mode = os.stat(default_storage.path(file_path)).st_mode & 0o777\n+                self.assertEqual(mode, 0o600)\n+            finally:\n+                default_storage.delete(file_path)\n         \"\"\"\n         Overriding the FILE_UPLOAD_DIRECTORY_PERMISSIONS setting should be\n         reflected in the directory_permissions_mode attribute of\n",
  "django__django-10924": "",
  "django__django-11001": "",
  "django__django-11039": "",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..fa99358 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -72,6 +72,23 @@ class TestValidation(SimpleTestCase):\n         with self.assertRaises(exceptions.ValidationError) as cm:\n             field.clean('not a datetime', None)\n         self.assertEqual(cm.exception.code, 'invalid')\n+        self.assertEqual(\n+            cm.exception.message % cm.exception.params,\n+            \"'not a datetime' value has an invalid format. \"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n+        )\n+\n+    def test_invalid_format_message(self):\n+        field = models.DurationField()\n+        invalid_inputs = ['14:00', '1:30:60', '1:2:3:4'] # adding some invalid inputs to test\n+        for input_value in invalid_inputs:\n+            with self.assertRaises(exceptions.ValidationError) as cm:\n+                field.clean(input_value, None)\n+            self.assertEqual(cm.exception.code, 'invalid')\n+            self.assertIn(\n+                \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\",\n+                cm.exception.message % cm.exception.params\n+            )\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n             \"'not a datetime' value has an invalid format. \"\n@@ -84,4 +101,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..f2e1bf8 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -238,6 +238,7 @@ class UsernameValidatorsTests(SimpleTestCase):\n             \"o'connell\", \"\u0639\u0628\u062f \u0627\u0644\",\n             \"zerowidth\\u200Bspace\", \"nonbreaking\\u00A0space\",\n             \"en\\u2013dash\",\n+            'trailingnewline\\n',  # Added to test trailing newline issue\n         ]\n         v = validators.UnicodeUsernameValidator()\n         for valid in valid_usernames:\n@@ -250,7 +251,7 @@ class UsernameValidatorsTests(SimpleTestCase):\n \n     def test_ascii_validator(self):\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n-        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n+        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\", 'trailingnewline\\n']  # Added to test trailing newline issue\n         v = validators.ASCIIUsernameValidator()\n         for valid in valid_usernames:\n             with self.subTest(valid=valid):\n@@ -258,4 +259,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..3a94397 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -356,7 +356,9 @@ class HttpResponseTests(unittest.TestCase):\n         r = HttpResponse()\n         self.assertIsNone(r.get('test'))\n \n-    def test_non_string_content(self):\n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview'))\n+        self.assertEqual(r.content, b'memoryview')\n         # Bug 16494: HttpResponse should behave consistently with non-strings\n         r = HttpResponse(12345)\n         self.assertEqual(r.content, b'12345')\n@@ -365,8 +367,16 @@ class HttpResponseTests(unittest.TestCase):\n         r = HttpResponse()\n         r.content = 12345\n         self.assertEqual(r.content, b'12345')\n+    def test_binary_content_via_property(self):\n+        # Test setting memoryview content via property\n+        r = HttpResponse()\n+        r.content = memoryview(b'some binary data')\n+        self.assertEqual(r.content, b'some binary data')\n \n-    def test_iter_content(self):\n+    def test_memoryview_support_with_pg_compatibility(self):\n+        # Test compatibility with postgres memoryview return type\n+        r = HttpResponse(memoryview(b'postgres data'))\n+        self.assertEqual(r.content, b'postgres data')\n         r = HttpResponse(['abc', 'def', 'ghi'])\n         self.assertEqual(r.content, b'abcdefghi')\n \n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..5807ac3 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,7 +1,9 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n+from django.db.models.deletion import Collector\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n from .models import (\n@@ -464,6 +466,18 @@ class FastDeleteTests(TestCase):\n         # 1 to delete t, 1 to fast-delete t's m_set\n         self.assertNumQueries(2, f.delete)\n \n+    def test_fast_delete_instance_set_pk_none(self):\n+        u = User.objects.create()\n+        # Verify User can be fast-deleted without dependencies\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        \n+        # Deleting the user instance\n+        u.delete()\n+        \n+        # Check if the primary key is set to None\n+        self.assertIsNone(u.pk)\n+\n     def test_fast_delete_qs(self):\n         u1 = User.objects.create()\n         u2 = User.objects.create()\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..9602180 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,9 +1,11 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n from django.contrib.auth.models import Permission, User\n from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n+from django.db import IntegrityError\n \n from .models import Proxy, UserProxy\n \n@@ -140,6 +142,29 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n+    def test_migrate_with_existing_target_permission(self):\n+        \"\"\"\n+        Test the migration does not fail when permissions for proxy models already exist.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='display_proxy',\n+            name='May display proxy information',\n+        )\n+        with captured_stdout() as stdout:\n+            try:\n+                update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+            except IntegrityError as e:\n+                self.fail(f\"IntegrityError occurred: {e}\")\n+            output = stdout.getvalue()\n+            self.assertIn('A problem arose migrating proxy model permissions', output)\n+\n     def test_user_keeps_same_permissions_after_migrating_backward(self):\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..c84330b 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -16,6 +16,7 @@ from unittest import mock, skip, skipIf\n from django.apps.registry import Apps\n from django.test import SimpleTestCase\n from django.test.utils import extend_sys_path\n+import shutil\n from django.utils import autoreload\n from django.utils.autoreload import WatchmanUnavailable\n \n@@ -72,7 +73,24 @@ class TestIterModulesAndFiles(SimpleTestCase):\n \n         self.assertFileFound(filename.absolute())\n \n-    def test_check_errors(self):\n+    def test_manage_py_autoreload(self):\n+        \"\"\"\n+        Test that modifications to the __main__ module (manage.py) are detected by autoreload.\n+        \"\"\"\n+        filename = self.temporary_file('manage.py')\n+        filename.write_text(\n+            \"import os\\n\"\n+            \"def main():\\n\"\n+            \"    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ticket_30479.settings')\\n\"\n+        )\n+\n+        def simulate_runserver():\n+            main_module = sys.modules['__main__']\n+            main_module.__file__ = str(filename)\n+            self.assertFileFound(Path(main_module.__file__))\n+\n+        with extend_sys_path(str(filename.parent)):\n+            simulate_runserver()\n         \"\"\"\n         When a file containing an error is imported in a function wrapped by\n         check_errors(), gen_filenames() returns it.\n",
  "django__django-11583": "",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..1bd2cd3 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -18,6 +18,8 @@ from django.test import RequestFactory, SimpleTestCase, override_settings\n from django.test.utils import LoggingCaptureMixin\n from django.urls import path, reverse\n from django.utils.functional import SimpleLazyObject\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n from django.utils.safestring import mark_safe\n from django.views.debug import (\n     CLEANSED_SUBSTITUTE, CallableSettingWrapper, ExceptionReporter,\n@@ -242,7 +244,31 @@ class DebugViewQueriesAllowedTests(SimpleTestCase):\n     # May need a query to initialize MySQL connection\n     databases = {'default'}\n \n-    def test_handle_db_exception(self):\n+    def test_technical_404_converter_raise_404(self):\n+        \"\"\"\n+        Test that raising Http404 in the to_python method of a path converter\n+        results in a technical 404 response with DEBUG=True.\n+        \"\"\"\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+            response = self.client.get('/path-post/1/')\n+            self.assertContains(response, 'Page not found', status_code=404)\n+\n+    def test_value_error_in_converter(self):\n+        \"\"\"\n+        Test that raising ValueError in the to_python method continues URL resolution\n+        when DEBUG=True.\n+        \"\"\"\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=ValueError):\n+            response = self.client.get('/path-post/1/')\n+            self.assertEqual(response.status_code, 404)\n+\n+    def test_non_raising_converter_wrap_value_error(self):\n+        \"\"\"\n+        Ensure valid conversion that raises no exceptions results in a valid response.\n+        \"\"\"\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=lambda x: x):\n+            response = self.client.get('/path-post/1/')\n+            self.assertEqual(response.status_code, 200)\n         \"\"\"\n         Ensure the debug view works when a database exception is raised by\n         performing an invalid query and passing the exception to the debug view.\n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..fc3c251 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -334,6 +334,75 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_in_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2, choices=[\n+                    ('ABC', 'Value Too Long!'), ('OK', 'Good')\n+                ],\n+            )\n+            group = models.CharField(\n+                max_length=2, choices=[\n+                    ('Nested', [('OK', 'Good'), ('Longer', 'Longer')]),\n+                    ('Grouped', [('Bad', 'Bad')]),\n+                ],\n+            )\n+\n+        for name, choice_max_length in (('field', 3), ('group', 6)):\n+            with self.subTest(name):\n+                field = Model._meta.get_field(name)\n+                self.assertEqual(field.check(), [\n+                    Error(\n+                        \"'max_length' is too small to fit the longest value \"\n+                        \"in 'choices' (%d characters).\" % choice_max_length,\n+                        obj=field,\n+                        id='fields.E009',\n+                    ),\n+                ])\n+\n+    def test_valid_max_length_for_choices(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3, choices=[\n+                    ('AB', 'Valid Choice'), ('OK', 'Good')\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        # No errors should occur if max_length is adequate.\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_for_nested_choices(self):\n+        class Model(models.Model):\n+            group = models.CharField(\n+                max_length=10, choices=[\n+                    ('Nested', [('Short', 'Short'), ('Longer', 'Longer')]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('group')\n+        # No errors for valid max_length\n+        self.assertEqual(field.check(), [])\n+\n+    def test_choice_length_exceeds_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2, choices=[\n+                    ('TOOLONG', 'Too Long Choice'), ('OK', 'Acceptable')\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        # Expect an error due to the length of TOOLONG\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value \"\n+                \"in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n     @unittest.skipUnless(connection.vendor == 'mysql',\n                          \"Test valid only for MySQL\")\n     def test_too_long_char_field_under_mysql(self):\n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..57de831 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -257,12 +257,28 @@ class WriterTests(SimpleTestCase):\n             A = 'a-value'\n             B = 'value-b'\n \n+        class TranslatedStatusEnum(enum.Enum):\n+            GOOD = _('Good')\n+            BAD = _('Bad')\n+\n+        field = models.CharField(\n+            default=TranslatedStatusEnum.GOOD,\n+            choices=[(m.value, m) for m in TranslatedStatusEnum],\n+        )\n+\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.CharField(choices=[\"\n+            \"('Good', migrations.test_writer.TranslatedStatusEnum['GOOD']), \"\n+            \"('Bad', migrations.test_writer.TranslatedStatusEnum['BAD'])], \"\n+            \"default=migrations.test_writer.TranslatedStatusEnum['GOOD'])\"\n+        )\n+\n+        # Existing enum tests\n         class BinaryEnum(enum.Enum):\n             A = b'a-value'\n             B = b'value-b'\n-\n-        class IntEnum(enum.IntEnum):\n-            A = 1\n             B = 2\n \n         self.assertSerializedResultEqual(\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..9a68177 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,5 +1,7 @@\n+\n import unittest\n from datetime import datetime\n+from unittest import mock\n \n from django.test import SimpleTestCase, ignore_warnings\n from django.utils.datastructures import MultiValueDict\n@@ -316,7 +318,23 @@ class HttpDateProcessingTests(unittest.TestCase):\n         parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n-    def test_parsing_rfc850(self):\n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850_with_mock(self, mocked_datetime):\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+        current_year_tests = [\n+            # Assuming the current date is 2021\n+            (datetime(2021, 1, 1), 'Monday, 01-Jan-70 00:00:00 GMT', datetime(1970, 1, 1)),\n+            (datetime(2021, 1, 1), 'Friday, 31-Dec-69 23:59:59 GMT', datetime(2069, 12, 31, 23, 59, 59)),\n+            # Assuming the current date is 2050\n+            (datetime(2050, 6, 15), 'Friday, 01-Jan-00 00:00:00 GMT', datetime(2000, 1, 1)),\n+            (datetime(2050, 6, 15), 'Saturday, 01-Jan-50 00:00:00 GMT', datetime(2050, 1, 1)),\n+        ]\n+        for current_datetime, http_date, expected_date in current_year_tests:\n+            with self.subTest(http_date=http_date):\n+                mocked_datetime.utcnow.return_value = current_datetime\n+                parsed = parse_http_date(http_date)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n         parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..afd5f8e 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -31,6 +31,19 @@ class Vehicle(models.IntegerChoices):\n \n     __empty__ = _('(Unknown)')\n \n+from django.test import SimpleTestCase\n+from django.db import models\n+from django.utils.translation import gettext_lazy as _\n+\n+class MyChoice(models.TextChoices):\n+    FIRST_CHOICE = \"first\", _(\"The first choice, it is\")\n+    SECOND_CHOICE = \"second\", _(\"The second choice, it is\")\n+\n+class Suit(models.IntegerChoices):\n+    DIAMOND = 1, 'Diamond'\n+    SPADE = 2, 'Spade'\n+    HEART = 3, 'Heart'\n+    CLUB = 4, 'Club'\n \n class Gender(models.TextChoices):\n     MALE = 'M'\n@@ -41,7 +54,16 @@ class Gender(models.TextChoices):\n \n \n class ChoicesTests(SimpleTestCase):\n-    def test_integerchoices(self):\n+    def test_enum_str_representation(self):\n+        # Test MyChoice TextChoices\n+        for choice in MyChoice:\n+            with self.subTest(choice=choice):\n+                self.assertEqual(str(choice), choice.value)\n+        \n+        # Test Suit IntegerChoices\n+        for suit in Suit:\n+            with self.subTest(suit=suit):\n+                self.assertEqual(str(suit), str(suit.value))\n         self.assertEqual(Suit.choices, [(1, 'Diamond'), (2, 'Spade'), (3, 'Heart'), (4, 'Club')])\n         self.assertEqual(Suit.labels, ['Diamond', 'Spade', 'Heart', 'Club'])\n         self.assertEqual(Suit.values, [1, 2, 3, 4])\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..1f75bf8 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -168,6 +168,19 @@ class GetFieldDisplayTests(SimpleTestCase):\n         self.assertIsInstance(val, str)\n         self.assertEqual(val, 'translated')\n \n+    def test_overriding_get_field_display(self):\n+        \"\"\"\n+        Test that overriding get_FIELD_display() in Django models works.\n+        \"\"\"\n+        class FooBar(models.Model):\n+            foo_bar = models.IntegerField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                return \"something\"\n+\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), \"something\")\n+\n     def test_iterator_choices(self):\n         \"\"\"\n         get_choices() works with Iterators.\n",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "diff --git a/tests/urlpatterns/path_urls.py b/tests/urlpatterns/path_urls.py\nindex 12487f2..06b81e3 100644\n--- a/tests/urlpatterns/path_urls.py\n+++ b/tests/urlpatterns/path_urls.py\n@@ -14,4 +14,5 @@ urlpatterns = [\n     re_path(r'^regex_optional/(?P<arg1>\\d+)/(?:(?P<arg2>\\d+)/)?', views.empty_view, name='regex_optional'),\n     path('', include('urlpatterns.more_urls')),\n     path('<lang>/<path:url>/', views.empty_view, name='lang-and-path'),\n-]\n+    re_path(r'^module/(?P<format>(html|json|xml))?/?$', views.modules_view, name='modules'),\n+]\n",
  "django__django-12284": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex 7dc81d2..e371d7a 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -1,3 +1,4 @@\n+\n import pickle\n \n from django import forms\n@@ -150,6 +151,26 @@ class ChoicesTests(SimpleTestCase):\n \n class GetFieldDisplayTests(SimpleTestCase):\n \n+    def test_inherited_choices_field_display(self):\n+        \"\"\"\n+        Test get_FIELD_display with inherited choices in a model.\n+        \"\"\"\n+        class Base(models.Model):\n+            foo = models.CharField(max_length=254, choices=[(\"A\", \"Base A\"), (\"B\", \"Base B\")])\n+\n+            class Meta:\n+                abstract = True\n+\n+        class Child(Base):\n+            foo = models.CharField(max_length=254, choices=[(\"A\", \"Child A\"), (\"B\", \"Child B\"), (\"C\", \"Child C\")])\n+\n+        # Instances of Child should return the display values from the Child's choices\n+        self.assertEqual(Child(foo='A').get_foo_display(), 'Child A')\n+        self.assertEqual(Child(foo='B').get_foo_display(), 'Child B')\n+        self.assertEqual(Child(foo='C').get_foo_display(), 'Child C')\n+        # Edge case: value that is not in choices\n+        self.assertEqual(Child(foo='D').get_foo_display(), 'D')\n+\n     def test_choices_and_field_display(self):\n         \"\"\"\n         get_choices() interacts with get_FIELD_display() to return the expected\n",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..550557b 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,9 +1,10 @@\n+\n from django.core.checks import Error\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n     check_setting_languages, check_setting_languages_bidi,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, override_settings\n \n \n class TranslationCheckTests(SimpleTestCase):\n@@ -75,6 +76,24 @@ class TranslationCheckTests(SimpleTestCase):\n                     Error(msg % tag, id='translation.E003'),\n                 ])\n \n+    @override_settings(\n+        USE_I18N=True,\n+        LANGUAGES=[\n+            ('en', 'English'),\n+            ('de', 'German'),\n+            ('es', 'Spanish'),\n+            ('fr', 'French'),\n+        ]\n+    )\n+    def test_valid_sublanguage_with_base_language(self):\n+        tests = [\n+            # Base language available without specific sublanguage.\n+            ('de-at', []),  # de is available, de-at should fall back to de\n+        ]\n+        for tag, expected in tests:\n+            with self.subTest(tag=tag), self.settings(LANGUAGE_CODE=tag):\n+                self.assertEqual(check_language_settings_consistent(None), expected)\n+\n     def test_inconsistent_language_settings(self):\n         msg = (\n             'You have provided a value for the LANGUAGE_CODE setting that is '\n",
  "django__django-12308": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex acbcf33..16d400f 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -169,6 +169,26 @@ class UtilsTests(SimpleTestCase):\n         display_value = display_for_field(None, models.BooleanField(null=True), self.empty_value)\n         expected = '<img src=\"%sadmin/img/icon-unknown.svg\" alt=\"None\" />' % settings.STATIC_URL\n         self.assertHTMLEqual(display_value, expected)\n+from django.db import models   # Importing the models for using JSONField\n+\n+class TestDisplayForField(TestCase):  # Assuming we are in a Django TestCase class\n+    empty_value = '(None)'  # Define empty_value display\n+\n+    def setUp(self):\n+        self.empty_value = '(None)'  # Example of setting up a default empty display value\n+\n+    def test_json_display_for_field_extended(self):  \n+        # Extending the test cases to cover more scenarios.\n+        tests = [\n+            ({\"key1\": \"value1\", \"key2\": [\"list\", \"of\", \"values\"]}, '{\"key1\": \"value1\", \"key2\": [\"list\", \"of\", \"values\"]}'),\n+            (None, self.empty_value),  # None value should return the empty_value_display\n+            ({\"empty\": []}, '{\"empty\": []}'),  # JSON object with an empty list\n+            ({\"number\": 12345, \"boolean\": True}, '{\"number\": 12345, \"boolean\": true}'),  # Includes number and boolean\n+        ]\n+        for value, expected_display_value in tests:\n+            with self.subTest(value=value):\n+                display_value = display_for_field(value, models.JSONField(), self.empty_value)\n+                self.assertEqual(display_value, expected_display_value)\n \n         display_value = display_for_field(None, models.DecimalField(), self.empty_value)\n         self.assertEqual(display_value, self.empty_value)\n",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..b56665a 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from unittest import mock\n \n@@ -5,7 +6,9 @@ from django.db import DEFAULT_DB_ALIAS, connection, connections\n from django.db.backends.base.creation import (\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n-from django.test import SimpleTestCase\n+from ..models import Object, ObjectReference\n+from django.test import SimpleTestCase, TestCase\n+from django.db import transaction, IntegrityError\n \n \n def get_connection_copy():\n@@ -17,8 +20,65 @@ def get_connection_copy():\n     )\n     return test_connection\n \n+class TestDeserializeDbFromString(SimpleTestCase):\n+    databases = {'default'}\n \n-class TestDbSignatureTests(SimpleTestCase):\n+    def test_circular_reference(self):\n+        # deserialize_db_from_string() handles circular references.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj_ref\": 1, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get()\n+        obj_ref = ObjectReference.objects.get()\n+        self.assertEqual(obj.obj_ref, obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n+    \n+    def test_simple_foreign_key_reference(self):\n+        # Test that deserialization handles simple foreign key references properly.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            },\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"related_objects\": []}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get(pk=1)\n+        obj_ref = ObjectReference.objects.get(pk=1)\n+        self.assertEqual(obj_ref.obj, obj)\n+    \n+    def test_integrity_error_on_reference(self):\n+        # Test that deserialization raises an IntegrityError when no transaction is used.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 2}\n+            }\n+        ]\n+        \"\"\"\n+        with self.assertRaises(IntegrityError):\n+            connection.creation.deserialize_db_from_string(data)\n     def test_default_name(self):\n         # A test db name isn't set.\n         prod_name = 'hodor'\n",
  "django__django-12497": "diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 057ec3a..218ffb2 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -128,6 +128,46 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_recursive_relationship_hint_for_m2m(self):\n+        \"\"\"Test that the hint for recursive many-to-many relationships is correct.\"\"\"\n+\n+        class Person(models.Model):\n+            friends = models.ManyToManyField('self', through='Friendship')\n+\n+        class Friendship(models.Model):\n+            from_person = models.ForeignKey(Person, models.CASCADE, related_name='from_person_set')\n+            to_person = models.ForeignKey(Person, models.CASCADE, related_name='to_person_set')\n+\n+        friends_field = Person._meta.get_field('friends')\n+        self.assertEqual(friends_field.check(from_model=Person), [\n+            # Error due to missing through_fields attribute.\n+            Error(\n+                \"The model is used as an intermediary model by 'invalid_models_tests.Person.friends', but it has more than one foreign key from 'Person', which is ambiguous. You must specify which foreign key Django should use via the through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"Friendship\").'\n+                ),\n+                obj=friends_field,\n+                id='fields.E334',\n+            ),\n+        ])\n+\n+    def test_intermediate_model_with_two_fks_to_different_models(self):\n+        \"\"\"Test that when two foreign keys to different models exist, no error is raised.\"\"\"\n+\n+        class User(models.Model):\n+            pass\n+\n+        class Role(models.Model):\n+            users = models.ManyToManyField('User', through='UserRole')\n+\n+        class UserRole(models.Model):\n+            user = models.ForeignKey(User, models.CASCADE)\n+            role = models.ForeignKey(Role, models.CASCADE)\n+\n+        users_field = Role._meta.get_field('users')\n+        self.assertEqual(users_field.check(from_model=Role), [])\n+\n     def test_ambiguous_relationship_model(self):\n \n         class Person(models.Model):\n@@ -159,6 +199,46 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_recursive_relationship_hint_for_m2m(self):\n+        \"\"\"Test that the hint for recursive many-to-many relationships is correct.\"\"\"\n+\n+        class Person(models.Model):\n+            friends = models.ManyToManyField('self', through='Friendship')\n+\n+        class Friendship(models.Model):\n+            from_person = models.ForeignKey(Person, models.CASCADE, related_name='from_person_set')\n+            to_person = models.ForeignKey(Person, models.CASCADE, related_name='to_person_set')\n+\n+        friends_field = Person._meta.get_field('friends')\n+        self.assertEqual(friends_field.check(from_model=Person), [\n+            # Error due to missing through_fields attribute.\n+            Error(\n+                \"The model is used as an intermediary model by 'invalid_models_tests.Person.friends', but it has more than one foreign key from 'Person', which is ambiguous. You must specify which foreign key Django should use via the through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"Friendship\").'\n+                ),\n+                obj=friends_field,\n+                id='fields.E334',\n+            ),\n+        ])\n+\n+    def test_intermediate_model_with_two_fks_to_different_models(self):\n+        \"\"\"Test that when two foreign keys to different models exist, no error is raised.\"\"\"\n+\n+        class User(models.Model):\n+            pass\n+\n+        class Role(models.Model):\n+            users = models.ManyToManyField('User', through='UserRole')\n+\n+        class UserRole(models.Model):\n+            user = models.ForeignKey(User, models.CASCADE)\n+            role = models.ForeignKey(Role, models.CASCADE)\n+\n+        users_field = Role._meta.get_field('users')\n+        self.assertEqual(users_field.check(from_model=Role), [])\n+\n     def test_relationship_model_with_foreign_key_to_wrong_model(self):\n         class WrongModel(models.Model):\n             pass\n",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..72d010f 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1241,6 +1241,41 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleansed_substitute,\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n     def test_cleanse_setting_recurses_in_dictionary(self):\n         reporter_filter = SafeExceptionReporterFilter()\n         initial = {'login': 'cooper', 'password': 'secret'}\n@@ -1249,6 +1284,41 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n     def test_request_meta_filtering(self):\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n@@ -1257,6 +1327,41 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleansed_substitute,\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n     def test_exception_report_uses_meta_filtering(self):\n         response = self.client.get('/raises500/', HTTP_SECRET_HEADER='super_secret')\n         self.assertNotIn(b'super_secret', response.content)\n@@ -1265,6 +1370,41 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             HTTP_SECRET_HEADER='super_secret',\n             HTTP_ACCEPT='application/json',\n         )\n+\n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n         self.assertNotIn(b'super_secret', response.content)\n \n \n",
  "django__django-12708": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 2df48a2..f61b20f 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1759,7 +1759,47 @@ class OperationTests(OperationTestBase):\n         operation = migrations.AlterIndexTogether(\"Pony\", None)\n         self.assertEqual(operation.describe(), \"Alter index_together for Pony (0 constraint(s))\")\n \n-    @skipUnlessDBFeature('supports_table_check_constraints')\n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_alter_index_together_with_unique_together_conflict(self):\n+        app_label = 'test_index_unique_conflict'\n+        table_name = '%s_pony' % app_label\n+\n+        # Setting up the initial project state with both unique_together and index_together\n+        project_state = self.set_up_test_model(\n+            app_label,\n+            unique_together=True,\n+            index_together=[('pink', 'weight')]\n+        )\n+\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+        self.assertIndexExists(table_name, ['pink', 'weight'])\n+\n+        # Attempt to alter index_together removing it while keeping unique_together\n+        new_state = project_state.clone()\n+        remove_index_operation = migrations.AlterIndexTogether('Pony', set())\n+        remove_index_operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            remove_index_operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+\n+        # Reintroduce the index using the new Options.indexes feature\n+        project_state = new_state\n+        new_state = project_state.clone()\n+        add_index_operation = migrations.AlterModelOptions(\n+            name='Pony',\n+            options={\n+                'indexes': [models.Index(fields=['pink', 'weight'], name='pony_pink_weight_idx')]\n+            },\n+        )\n+        add_index_operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            add_index_operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        self.assertIndexExists(table_name, ['pink', 'weight'], index_type=\"idx\")\n     def test_add_constraint(self):\n         project_state = self.set_up_test_model(\"test_addconstraint\")\n         gt_check = models.Q(pink__gt=2)\n",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..137c3d9 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -685,7 +685,39 @@ class FastDeleteTests(TestCase):\n         self.assertNumQueries(2, a.delete)\n         self.assertEqual(User.objects.count(), 0)\n \n-    def test_fast_delete_empty_no_update_can_self_select(self):\n+    def test_zero_delete_with_fk(self):\n+        \"\"\"\n+        Test deleting with foreign keys when zero objects exist. The output should\n+        be consistent with non-foreign key models.\n+        \"\"\"\n+        r = R.objects.create()  # Create one instance with related foreign key models.\n+        h1 = HiddenUser.objects.create(r=r)\n+        \n+        # Delete all to ensure no objects are left to delete.\n+        R.objects.all().delete()\n+        \n+        # Try deleting again with zero objects present.\n+        deleted, deleted_objs = R.objects.all().delete()\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {\n+            R._meta.label: 0,\n+            HiddenUser._meta.label: 0,\n+            HiddenUserProfile._meta.label: 0,\n+            A._meta.label: 0,\n+            MR._meta.label: 0,\n+        })\n+\n+    def test_zero_delete_without_fk(self):\n+        \"\"\"\n+        Test deleting a simple model without foreign keys when zero objects exist.\n+        The result should also be in the format of {model_label: 0}.\n+        \"\"\"\n+        block_count_before = BlockLibrary.objects.count()\n+        BlockLibrary.objects.all().delete()\n+        deleted, deleted_objs = BlockLibrary.objects.all().delete()\n+        self.assertEqual(block_count_before, 0)\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {'my_app.BlockLibrary': 0})\n         \"\"\"\n         #25932 - Fast deleting on backends that don't have the\n         `no_update_can_self_select` feature should work even if the specified\n",
  "django__django-12856": "",
  "django__django-12915": "",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..a2c6e30 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -203,7 +203,18 @@ class TestUtilsText(SimpleTestCase):\n         # interning the result may be useful, e.g. when fed to Path.\n         self.assertEqual(sys.intern(text.slugify('a')), 'a')\n \n-    @ignore_warnings(category=RemovedInDjango40Warning)\n+    def test_slugify_strip_leading_trailing_dashes_underscores(self):\n+        items = [\n+            # given - expected\n+            ('___This is a test ---', 'this-is-a-test'),\n+            ('---Leading dash', 'leading-dash'),\n+            ('Trailing dash---', 'trailing-dash'),\n+            ('__Leading underscore', 'leading-underscore'),\n+            ('Trailing underscore__', 'trailing-underscore'),\n+            ('---Mixed---___', 'mixed'),\n+        ]\n+        for value, output in items:\n+            self.assertEqual(text.slugify(value), output)\n     def test_unescape_entities(self):\n         items = [\n             ('', ''),\n",
  "django__django-13028": "",
  "django__django-13158": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 070e08e..8bd64e7 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -1,3 +1,4 @@\n+\n import operator\n \n from django.db import DatabaseError, NotSupportedError, connection\n@@ -45,6 +46,19 @@ class QuerySetSetOperationTests(TestCase):\n         qs2 = Number.objects.filter(num__lte=4)\n         self.assertNumbersEqual(qs1.difference(qs2), [5], ordered=False)\n \n+    def test_union_none_behavior(self):\n+        qs1 = Number.objects.filter(num__lte=1)  # Should match 0, 1\n+        qs2 = Number.objects.filter(num__gte=8)  # Should match 8, 9\n+        combined_qs = qs1.union(qs2)\n+        # Applying .none() should return an empty queryset.\n+        self.assertSequenceEqual(combined_qs.none(), [])\n+\n+    def test_union_none_with_empty_qs(self):\n+        qs = Number.objects.none()\n+        combined_qs = qs.union(qs)\n+        # Resulting queryset should be empty as both are none.\n+        self.assertSequenceEqual(combined_qs, [])\n+\n     def test_union_distinct(self):\n         qs1 = Number.objects.all()\n         qs2 = Number.objects.all()\n@@ -313,4 +327,4 @@ class QuerySetSetOperationTests(TestCase):\n                         NotSupportedError,\n                         msg % (operation, combinator),\n                     ):\n-                        getattr(getattr(qs, combinator)(qs), operation)()\n+                        getattr(getattr(qs, combinator)(qs), operation)()\n",
  "django__django-13230": "",
  "django__django-13315": "",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 536c423..c631e26 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -7,10 +7,37 @@ from django.core.exceptions import FieldDoesNotExist, FieldError\n from django.db import models\n from django.test import SimpleTestCase\n from django.test.utils import isolate_apps\n+from django.db import models\n+from django.test import SimpleTestCase\n \n \n @isolate_apps('model_inheritance')\n class AbstractInheritanceTests(SimpleTestCase):\n+    def test_abstract_inherited_fields_are_not_equal(self):\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+            class Meta:\n+                abstract = True\n+\n+        class InheritAbstractModel1(AbstractModel):\n+            pass\n+\n+        class InheritAbstractModel2(AbstractModel):\n+            pass\n+\n+        abstract_model_field = AbstractModel._meta.get_field('field')\n+        inherit1_model_field = InheritAbstractModel1._meta.get_field('field')\n+        inherit2_model_field = InheritAbstractModel2._meta.get_field('field')\n+\n+        # Ensure fields from different models are not equal\n+        self.assertNotEqual(inherit1_model_field, inherit2_model_field)\n+\n+        # Ensure their hashes are not equal\n+        self.assertNotEqual(hash(inherit1_model_field), hash(inherit2_model_field))\n+\n+        # Test ordering\n+        self.assertLess(inherit1_model_field, inherit2_model_field)\n+\n     def test_single_parent(self):\n         class AbstractBase(models.Model):\n             name = models.CharField(max_length=30)\n@@ -347,4 +374,4 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('age', models.SmallIntegerField), ('concretemodel2_ptr', models.OneToOneField),\n                 ('name', models.CharField),\n             ]\n-        )\n+        )\n",
  "django__django-13447": "diff --git a/tests/admin_views/test_adminsite.py b/tests/admin_views/test_adminsite.py\nindex 16a02bb..5795393 100644\n--- a/tests/admin_views/test_adminsite.py\n+++ b/tests/admin_views/test_adminsite.py\n@@ -46,6 +46,35 @@ class SiteEachContextTest(TestCase):\n         self.assertEqual(site.each_context(request)['site_url'], '/my-script-name/')\n \n     def test_available_apps(self):\n+        # Ensure the model class is included in the app_list context\n+        ctx = self.ctx\n+        apps = ctx['available_apps']\n+        \n+        # For admin_views.Article\n+        admin_views = apps[0]\n+        article = admin_views['models'][0]\n+        self.assertEqual(article['object_name'], 'Article')\n+        self.assertEqual(article['model'], Article)  # Verify that model class is included\n+        \n+        # For auth.User\n+        auth = apps[1]\n+        user = auth['models'][0]\n+        self.assertEqual(user['model'], User)  # Verify that model class is included\n+\n+    def test_build_app_dict(self):\n+        # Access the _build_app_dict method to verify its functionality\n+        request = self.get_request()\n+        app_dict = self.admin._build_app_dict(request)\n+\n+        # Verify if the app_dict is correctly constructed\n+        self.assertIn('admin_views', app_dict)\n+        self.assertIn('auth', app_dict)\n+        self.assertEqual(app_dict['admin_views']['models'][0]['object_name'], 'Article')\n+        self.assertEqual(app_dict['auth']['models'][0]['object_name'], 'User')\n+        \n+        # Ensure the models in app_dict have the model class object\n+        self.assertEqual(app_dict['admin_views']['models'][0]['model'], Article)\n+        self.assertEqual(app_dict['auth']['models'][0]['model'], User)\n         ctx = self.ctx\n         apps = ctx['available_apps']\n         # we have registered two models from two different apps\n",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..8c2ca82 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,9 +1,13 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n from django.contrib.auth.models import User\n from django.contrib.auth.tokens import PasswordResetTokenGenerator\n from django.test import TestCase\n+\n+from .with_custom_email_field import CustomEmailField\n+from .models import CustomEmailField, IntegerUsernameUser\n from django.test.utils import ignore_warnings\n from django.utils.deprecation import RemovedInDjango40Warning\n \n@@ -37,6 +41,27 @@ class TokenGeneratorTest(TestCase):\n         tk2 = p0.make_token(user_reload)\n         self.assertEqual(tk1, tk2)\n \n+    def test_token_with_different_email(self):\n+        \"\"\"Updating the user email address invalidates the token.\"\"\"\n+        tests = [ \n+            (CustomEmailField, None),\n+            (CustomEmailField, 'test4@example.com'),\n+            (User, 'test4@example.com'),\n+        ]\n+        for model, email in tests:\n+            with self.subTest(model=model.__qualname__, email=email):\n+                user = model.objects.create_user(\n+                    'changeemailuser',\n+                    email=email,\n+                    password='testpw',\n+                )\n+                p0 = PasswordResetTokenGenerator()\n+                tk1 = p0.make_token(user)\n+                self.assertIs(p0.check_token(user, tk1), True)\n+                setattr(user, user.get_email_field_name(), 'test4new@example.com')\n+                user.save()\n+                self.assertIs(p0.check_token(user, tk1), False)\n+\n     def test_timeout(self):\n         \"\"\"The token is valid after n seconds, but no greater.\"\"\"\n         # Uses a mocked version of PasswordResetTokenGenerator so we can change\n",
  "django__django-13590": "",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..029ae8f 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -19,18 +19,26 @@ from django.conf import settings\n from django.core.management import (\n     BaseCommand, CommandError, call_command, color,\n )\n+from unittest import mock\n+from django.core.management import execute_from_command_line\n from django.core.management.commands.loaddata import Command as LoaddataCommand\n from django.core.management.commands.runserver import (\n     Command as RunserverCommand,\n )\n+from unittest import mock\n+from django.core.management import execute_from_command_line\n from django.core.management.commands.testserver import (\n     Command as TestserverCommand,\n )\n+from unittest import mock\n+from django.core.management import execute_from_command_line\n from django.db import ConnectionHandler, connection\n from django.db.migrations.recorder import MigrationRecorder\n from django.test import (\n     LiveServerTestCase, SimpleTestCase, TestCase, override_settings,\n )\n+from unittest import mock\n+from django.core.management import execute_from_command_line\n \n custom_templates_dir = os.path.join(os.path.dirname(__file__), 'custom_templates')\n \n@@ -1867,7 +1875,57 @@ class ArgumentOrder(AdminScriptTestCase):\n         )\n \n \n-@override_settings(ROOT_URLCONF='admin_scripts.urls')\n+class ExecuteFromCommandLine(SimpleTestCase):\n+    def test_program_name_from_argv(self):\n+        \"\"\"\n+        Program name is computed from the execute_from_command_line()'s argv\n+        argument, not sys.argv.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line(['django-admin'] + args)\n+        self.assertIn('usage: django-admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_program_name_change(self):\n+        \"\"\"\n+        Test that changing the program name in argv reflects in the usage output.\n+        \"\"\"\n+        custom_prog_name = 'my-custom-admin'\n+        args = ['help', 'runserver']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line([custom_prog_name] + args)\n+        self.assertIn(f'usage: {custom_prog_name} runserver', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_sys_argv_override(self):\n+        \"\"\"\n+        Test that overriding sys.argv directly does not affect the program name\n+        when argv is provided to execute_from_command_line.\n+        \"\"\"\n+        custom_argv = ['my-admin-tool', 'help']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['another-tool', 'wrong-command']):\n+                execute_from_command_line(custom_argv)\n+        self.assertIn('usage: my-admin-tool help', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_no_argv_provided(self):\n+        \"\"\"\n+        Test that with no argv provided to execute_from_command_line, the\n+        program name defaults correctly.\n+        \"\"\"\n+        sys_argv_backup = list(sys.argv)  # Backup system argv\n+        try:\n+            with captured_stdout() as out, captured_stderr() as err:\n+                sys.argv = [None, 'help']\n+                execute_from_command_line()\n+            self.assertIn('usage: python -m django help', out.getvalue())\n+            self.assertEqual(err.getvalue(), '')\n+        finally:\n+            sys.argv = sys_argv_backup  # Restore original sys.argv\n class StartProject(LiveServerTestCase, AdminScriptTestCase):\n \n     available_apps = [\n",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..fc1deae 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,3 +1,4 @@\n+\n import sys\n import unittest\n from unittest import mock\n@@ -44,9 +45,51 @@ class ShellCommandTestCase(SimpleTestCase):\n         with self.assertRaisesMessage(CommandError, \"Couldn't import bpython interface.\"):\n             call_command('shell', interface='bpython')\n \n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n+\n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n     # [1] Patch select to prevent tests failing when when the test suite is run\n     # in parallel mode. The tests are run in a subprocess and the subprocess's\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 2d83d62..845846d 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -1013,7 +1013,26 @@ class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n         self.assertContains(response, 'Add another Model with both - name')\n         self.assertNotContains(response, '<h2>Model with both - plural name</h2>')\n \n-    def test_both_verbose_names_inline(self):\n+    def test_default_inline_verbose_name_plural(self):\n+        \"\"\"\n+        Test that Inline uses its verbose_name as the source for verbose_name_plural by default.\n+        \"\"\"\n+        class DefaultProfileInline(TabularInline):\n+            model = Profile\n+            verbose_name = 'Profile Entry'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [\n+            DefaultProfileInline,\n+        ]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+        # Inline with only verbose_name should use it to infer verbose_name_plural\n+        self.assertContains(response, '<h2>Profile Entry</h2>')\n+        self.assertContains(response, 'Add another Profile Entry')\n         class NonVerboseProfileInline(TabularInline):\n             model = Profile\n             verbose_name = 'Non-verbose childs - name'\n",
  "django__django-13757": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex f53ff8c..2db02e8 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -595,7 +595,29 @@ class TestQuerying(TestCase):\n             [self.objs[4]],\n         )\n \n-    def test_isnull_key_or_none(self):\n+        # Add test cases to check behavior on SQLite and Oracle where JSON null should not be matched.\n+        # This case checks if the key is missing (and not just having a null value).\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],\n+        )\n+        # For other keys with JSON nulls to reinforce that they behave as expected.\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__b__isnull=True),\n+            self.objs[:3] + self.objs[4:],\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__b__isnull=False),\n+            [self.objs[3]],\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__c__isnull=True),\n+            self.objs[:4] + self.objs[5:],\n+        )\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__c__isnull=False),\n+            [self.objs[4]],\n+        )\n         obj = NullableJSONModel.objects.create(value={'a': None})\n         self.assertSequenceEqual(\n             NullableJSONModel.objects.filter(Q(value__a__isnull=True) | Q(value__a=None)),\n",
  "django__django-13768": "diff --git a/tests/dispatch/tests.py b/tests/dispatch/tests.py\nindex b1feefd..27b7dcf 100644\n--- a/tests/dispatch/tests.py\n+++ b/tests/dispatch/tests.py\n@@ -165,13 +165,29 @@ class DispatcherTests(SimpleTestCase):\n         def fails(val, **kwargs):\n             raise ValueError('this')\n         a_signal.connect(fails)\n-        result = a_signal.send_robust(sender=self, val=\"test\")\n-        err = result[0][1]\n-        self.assertIsInstance(err, ValueError)\n-        self.assertEqual(err.args, ('this',))\n-        self.assertTrue(hasattr(err, '__traceback__'))\n-        self.assertIsInstance(err.__traceback__, TracebackType)\n-        a_signal.disconnect(fails)\n+        try:\n+            with self.assertLogs('django.dispatch', 'ERROR') as cm:\n+                result = a_signal.send_robust(sender=self, val=\"test\")\n+            # Ensure the exception is raised as before\n+            err = result[0][1]\n+            self.assertIsInstance(err, ValueError)\n+            self.assertEqual(err.args, ('this',))\n+            self.assertTrue(hasattr(err, '__traceback__'))\n+            self.assertIsInstance(err.__traceback__, TracebackType)\n+            \n+            # New assertions for logging\n+            self.assertGreater(len(cm.records), 0)  # Check at least one log record exists\n+            log_record = cm.records[0]\n+            self.assertEqual(\n+                log_record.getMessage(),\n+                \"Error calling test_send_robust_fail.<locals>.fails in Signal.send_robust() (this)\"\n+            )\n+            self.assertIsNotNone(log_record.exc_info)\n+            _, exc_value, _ = log_record.exc_info\n+            self.assertIsInstance(exc_value, ValueError)\n+            self.assertEqual(str(exc_value), 'this')\n+        finally:\n+            a_signal.disconnect(fails)\n         self.assertTestIsClean(a_signal)\n \n     def test_disconnection(self):\n",
  "django__django-13925": "",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..652c594 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -297,8 +297,19 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['INVALID CHOICE'], f.clean, '4')\n-\n-        # ModelMultipleChoiceField\n+    def test_modelchoicefield_invalid_choice_error_message(self):\n+        # Setup\n+        f = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            },\n+        )\n+        \n+        # Invalid choice value test\n+        invalid_value = '999'\n+        expected_error = [f'\"{invalid_value}\" is not one of the available choices.']\n+        self.assertFormErrors(expected_error, f.clean, invalid_value)\n         e = {\n             'required': 'REQUIRED',\n             'invalid_choice': '%(value)s IS INVALID CHOICE',\n@@ -307,4 +318,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "diff --git a/tests/many_to_one/models.py b/tests/many_to_one/models.py\nindex 1078928..f15f299 100644\n--- a/tests/many_to_one/models.py\n+++ b/tests/many_to_one/models.py\n@@ -93,6 +93,14 @@ class Record(models.Model):\n     category = models.ForeignKey(Category, models.CASCADE)\n \n \n+class ParentStringPrimaryKey(models.Model):\n+    name = models.CharField(primary_key=True, max_length=15)\n+\n+\n+class ChildStringPrimaryKeyParent(models.Model):\n+    parent = models.ForeignKey(ParentStringPrimaryKey, on_delete=models.CASCADE)\n+\n+\n class Relation(models.Model):\n     left = models.ForeignKey(Record, models.CASCADE, related_name='left_set')\n     right = models.ForeignKey(Record, models.CASCADE, related_name='right_set')\n",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..a2f6d0a 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,9 +1,22 @@\n+\n from django.db.models import F, Q\n from django.test import SimpleTestCase\n+from collections import UserDict\n \n \n class QTests(SimpleTestCase):\n-    def test_combine_and_empty(self):\n+    def test_dict_keys_in_q_object(self):\n+        # Test using dict keys directly in a Q object with | operator\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n+\n+    def test_userdict_keys_in_q_object(self):\n+        # Test using UserDict keys in a Q object\n+        user_dict = UserDict(one=1, two=2)\n+        q = Q(x__in=user_dict.keys())\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n         q = Q(x=1)\n         self.assertEqual(q & Q(), q)\n         self.assertEqual(Q() & q, q)\n",
  "django__django-14017": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 707f339..ad5700e 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -36,6 +36,7 @@ from .models import (\n )\n \n \n+from django.db.models import Q, Exists, OuterRef\n class BasicExpressionsTests(TestCase):\n     @classmethod\n     def setUpTestData(cls):\n@@ -43,6 +44,25 @@ class BasicExpressionsTests(TestCase):\n             name=\"Example Inc.\", num_employees=2300, num_chairs=5,\n             ceo=Employee.objects.create(firstname=\"Joe\", lastname=\"Smith\", salary=10)\n         )\n+        # Test cases to verify the commutative property with Exists() and Q()\n+    def test_commutative_property_of_exists_and_q(self):\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        tests = [\n+            Exists(is_ceo) & Q(),\n+            Q() & Exists(is_ceo),\n+            Exists(is_ceo) | Q(),\n+            Q() | Exists(is_ceo),\n+            Exists(is_poc) & Q(),\n+            Q() & Exists(is_poc),\n+            Exists(is_poc) | Q(),\n+            Q() | Exists(is_poc),\n+        ]\n+        for conditions in tests:\n+            with self.subTest(conditions=conditions):\n+                self.assertIsInstance(conditions, Q)\n         cls.foobar_ltd = Company.objects.create(\n             name=\"Foobar Ltd.\", num_employees=3, num_chairs=4, based_in_eu=True,\n             ceo=Employee.objects.create(firstname=\"Frank\", lastname=\"Meyer\", salary=20)\n@@ -792,6 +812,25 @@ class BasicExpressionsTests(TestCase):\n                 output_field=BooleanField(),\n             ),\n         )\n+        # Test cases to verify the commutative property with Exists() and Q()\n+    def test_commutative_property_of_exists_and_q(self):\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        tests = [\n+            Exists(is_ceo) & Q(),\n+            Q() & Exists(is_ceo),\n+            Exists(is_ceo) | Q(),\n+            Q() | Exists(is_ceo),\n+            Exists(is_poc) & Q(),\n+            Q() & Exists(is_poc),\n+            Exists(is_poc) | Q(),\n+            Q() | Exists(is_poc),\n+        ]\n+        for conditions in tests:\n+            with self.subTest(conditions=conditions):\n+                self.assertIsInstance(conditions, Q)\n         self.assertCountEqual(qs, [self.example_inc.ceo, self.foobar_ltd.ceo, self.max])\n \n     def test_boolean_expression_combined(self):\n@@ -803,6 +842,25 @@ class BasicExpressionsTests(TestCase):\n             Employee.objects.filter(Exists(is_ceo) | Exists(is_poc)),\n             [self.example_inc.ceo, self.foobar_ltd.ceo, self.max],\n         )\n+        # Test cases to verify the commutative property with Exists() and Q()\n+    def test_commutative_property_of_exists_and_q(self):\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        tests = [\n+            Exists(is_ceo) & Q(),\n+            Q() & Exists(is_ceo),\n+            Exists(is_ceo) | Q(),\n+            Q() | Exists(is_ceo),\n+            Exists(is_poc) & Q(),\n+            Q() & Exists(is_poc),\n+            Exists(is_poc) | Q(),\n+            Q() | Exists(is_poc),\n+        ]\n+        for conditions in tests:\n+            with self.subTest(conditions=conditions):\n+                self.assertIsInstance(conditions, Q)\n         self.assertCountEqual(\n             Employee.objects.filter(Exists(is_ceo) & Exists(is_poc)),\n             [self.max],\n",
  "django__django-14155": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 0f968fa..b965775 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1128,7 +1128,27 @@ class ResolverMatchTests(SimpleTestCase):\n                 self.assertEqual(match[1], args)\n                 self.assertEqual(match[2], kwargs)\n \n-    def test_resolver_match_on_request(self):\n+    @override_settings(ROOT_URLCONF='urlpatterns_reverse.urls')\n+    def test_repr_functools_partial(self):\n+        tests = [\n+            ('partial', 'template.html'),\n+            ('partial_nested', 'nested_partial.html'),\n+            ('partial_wrapped', 'template.html'),\n+        ]\n+        for name, template_name in tests:\n+            with self.subTest(name=name):\n+                func = functools.partial(views.empty_view, template_name=template_name)\n+                expected_repr = (\n+                    f\"ResolverMatch(func={func}, args=(), kwargs={{}}, \"\n+                    f\"url_name='{name}', app_names=[], namespaces=[], \"\n+                    f\"route='{name}/')\"\n+                )\n+                actual_repr = repr(resolve(f'/{name}/'))\n+                self.assertEqual(\n+                    actual_repr,\n+                    expected_repr,\n+                    f\"Failed for {name}. Expected {expected_repr}, got {actual_repr}\"\n+                )\n         response = self.client.get('/resolver_match/')\n         resolver_match = response.resolver_match\n         self.assertEqual(resolver_match.url_name, 'test-resolver-match')\n",
  "django__django-14238": "",
  "django__django-14382": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex afeed3e..7cc2bf1 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2197,6 +2197,25 @@ class StartApp(AdminScriptTestCase):\n                     \"make sure the directory is a valid identifier.\" % bad_target\n                 )\n \n+    def test_trailing_slash_in_target_app_directory_name(self):\n+        app_dir = os.path.join(self.test_dir, 'apps', 'app1')\n+        os.makedirs(app_dir)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', 'app1', '')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n+\n+    def test_trailing_slash_in_non_existent_directory(self):\n+        non_existent_dir = os.path.join(self.test_dir, 'nonexistent/')\n+        _, err = self.run_django_admin(['startapp', 'app_name', non_existent_dir])\n+        self.assertOutput(err, \"Destination directory '%s' does not exist, please create it first.\" % os.path.abspath(non_existent_dir))\n+\n+    def test_trailing_slash_with_existing_directory(self):\n+        existing_dir = os.path.join(self.test_dir, 'existing_app/')\n+        os.makedirs(existing_dir)\n+        _, err = self.run_django_admin(['startapp', 'app_name', existing_dir])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(existing_dir, 'apps.py')), True)\n+\n     def test_importable_target_name(self):\n         _, err = self.run_django_admin(['startapp', 'app', 'os'])\n         self.assertOutput(\n",
  "django__django-14411": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 331338c..8fe44e7 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -8,6 +8,8 @@ from django.contrib.auth.forms import (\n     SetPasswordForm, UserChangeForm, UserCreationForm,\n )\n from django.contrib.auth.models import User\n+from django.forms import forms\n+from django.utils.html import format_html\n from django.contrib.auth.signals import user_login_failed\n from django.contrib.sites.models import Site\n from django.core import mail\n@@ -1025,8 +1027,32 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n         self.assertIs(field.disabled, True)\n         self.assertFalse(field.has_changed('aaa', 'bbb'))\n \n+class ReadOnlyPasswordHashWidgetTest(SimpleTestCase):\n+    def test_label(self):\n+        \"\"\"\n+        ReadOnlyPasswordHashWidget's label doesn't have a 'for' attribute\n+        because it doesn't have any labelable elements.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            hash_field = ReadOnlyPasswordHashField()\n+\n+        bound_field = TestForm()['hash_field']\n+        # Ensure the widget's id_for_label is None\n+        self.assertIsNone(bound_field.field.widget.id_for_label('id'))\n+        # Ensure the label tag does not have 'for' attribute\n+        self.assertEqual(bound_field.label_tag(), '<label>Hash field:</label>')\n \n-class AdminPasswordChangeFormTest(TestDataMixin, TestCase):\n+    def test_widget_renders_text(self):\n+        \"\"\"\n+        Verify that the ReadOnlyPasswordHashWidget renders text, not a labelable element.\n+        \"\"\"\n+        widget = ReadOnlyPasswordHashWidget()\n+        # Simulate rendering the widget with a test value\n+        rendered = widget.render(name='password', value='password-hash-value')\n+        # Check that the rendered output is text and contains the hash value\n+        self.assertIn('password-hash-value', rendered)\n+        # It should be wrapped in some structure typical of text display (e.g., <div>, <span>)\n+        self.assertTrue(any(tag in rendered for tag in ['<div', '<span', '<p']))\n \n     @mock.patch('django.contrib.auth.password_validation.password_changed')\n     def test_success(self, password_changed):\n",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..2c18b60 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -655,7 +655,52 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(result.args, value.args)\n         self.assertEqual(result.keywords, value.keywords)\n \n-    def test_serialize_type_none(self):\n+    class MyField(models.TextField):\n+        pass\n+\n+    class MyBaseModel(models.Model):\n+        class Meta:\n+            abstract = True\n+\n+    class MyMixin:\n+        pass\n+\n+    class MyModel(MyMixin, MyBaseModel):\n+        name = MyField(primary_key=True)\n+\n+    class TestMigrationIssue(TestCase):\n+        def test_migration_imports_models(self):\n+            # Setup the test app and models\n+            test_app_config = apps.get_app_config('migrations')\n+            models_file_path = os.path.join(test_app_config.path, 'models.py')\n+            with open(models_file_path, 'w') as models_file:\n+                models_file.write(\"\"\"\n+from django.db import models\n+\n+class MyField(models.TextField):\n+    pass\n+\n+class MyBaseModel(models.Model):\n+    class Meta:\n+        abstract = True\n+\n+class MyMixin:\n+    pass\n+\n+class MyModel(MyMixin, MyBaseModel):\n+    name = MyField(primary_key=True)\n+\"\"\")\n+            # Run makemigrations\n+            out = StringIO()\n+            call_command('makemigrations', 'migrations', stdout=out)\n+\n+            # Check that the migration file has the correct import for models\n+            for migration in os.listdir(os.path.join(test_app_config.path, 'migrations')):\n+                if migration.endswith('.py') and migration != '__init__.py':\n+                    with open(os.path.join(test_app_config.path, 'migrations', migration), 'r') as migration_file:\n+                        migration_content = migration_file.read()\n+                        self.assertIn('from django.db import models', migration_content)\n+                        self.assertIn('bases=(migrations.MyMixin, models.Model)', migration_content)\n         self.assertSerializedEqual(type(None))\n \n     def test_simple_migration(self):\n",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..17a434d 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -337,6 +337,7 @@ class FormsFormsetTestCase(SimpleTestCase):\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['Please submit at most 1 form.'])\n+        self.assertIn('<ul class=\"errorlist nonform\">', str(formset.non_form_errors()))\n \n     def test_formset_validate_min_flag(self):\n         \"\"\"\n@@ -359,6 +360,7 @@ class FormsFormsetTestCase(SimpleTestCase):\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['Please submit at least 3 forms.'])\n+        self.assertIn('<ul class=\"errorlist nonform\">', str(formset.non_form_errors()))\n \n     def test_formset_validate_min_unchanged_forms(self):\n         \"\"\"\n@@ -983,6 +985,7 @@ class FormsFormsetTestCase(SimpleTestCase):\n         formset = FavoriteDrinksFormSet(data, prefix='drinks')\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n+        self.assertIn('<ul class=\"errorlist nonform\">', str(formset.non_form_errors()))\n \n     def test_formset_iteration(self):\n         \"\"\"Formset instances are iterable.\"\"\"\n",
  "django__django-14672": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex d9eaabe..00e165a 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -9,6 +9,10 @@ from .models import (\n     Invitation, Membership, Person, PersonSelfRefM2M, Recipe, RecipeIngredient,\n     Relationship, SymmetricalFriendship,\n )\n+from django.db import models\n+from django.core.checks import Error\n+from django.test import TestCase\n+from .models import Event, Invitation, Person, PersonSelfRefM2M, Group, Membership\n \n \n class M2mThroughTests(TestCase):\n@@ -20,7 +24,30 @@ class M2mThroughTests(TestCase):\n         cls.rock = Group.objects.create(name='Rock')\n         cls.roll = Group.objects.create(name='Roll')\n \n-    def test_retrieve_intermediate_items(self):\n+    def test_fix_m2m_through_fields_list_hashable(self):\n+        class Parent(models.Model):\n+            name = models.CharField(max_length=256)\n+\n+        class ProxyParent(Parent):\n+            class Meta:\n+                proxy = True\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+            many_to_many_field = models.ManyToManyField(\n+                to=Parent,\n+                through=\"ManyToManyModel\",\n+                through_fields=['child', 'parent'],\n+                related_name=\"something\"\n+            )\n+\n+        class ManyToManyModel(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n+            child = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n+            second_child = models.ForeignKey(Child, on_delete=models.CASCADE, null=True, default=None)\n+\n+        # Ensure that no TypeErrors are raised, which indicates that the make_hashable call is correctly applied.\n+        self.assertEqual(Child.check(), [])\n         Membership.objects.create(person=self.jim, group=self.rock)\n         Membership.objects.create(person=self.jane, group=self.rock)\n \n",
  "django__django-14752": "",
  "django__django-14787": "",
  "django__django-14855": "",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..bad75ad 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,9 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n@@ -341,7 +342,15 @@ class ModelChoiceFieldTests(TestCase):\n </div>\"\"\" % (self.c1.pk, self.c2.pk, self.c3.pk),\n         )\n \n-    def test_choices_not_fetched_when_not_rendering(self):\n+    def test_model_choice_iterator_value_is_hashable(self):\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+        test_dict = {value_1: \"Choice 1\", value_2: \"Choice 2\"}\n+        \n+        self.assertEqual(test_dict[value_1], \"Choice 1\")\n+        self.assertEqual(test_dict[value_2], \"Choice 2\")\n+        self.assertNotEqual(hash(value_1), hash(value_2))\n+        self.assertEqual(hash(value_1), hash(ModelChoiceIteratorValue(self.c1.pk, self.c1)))\n         with self.assertNumQueries(1):\n             field = forms.ModelChoiceField(Category.objects.order_by('-name'))\n             self.assertEqual('Entertainment', field.clean(self.c1.pk).name)\n",
  "django__django-14999": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 3e4c6c7..61ef07a 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -793,6 +793,39 @@ class OperationTests(OperationTestBase):\n         self.assertEqual(Rider.objects.count(), 2)\n         self.assertEqual(Pony._meta.get_field('riders').remote_field.through.objects.count(), 2)\n \n+    def test_rename_model_with_db_table_noop(self):\n+        app_label = 'test_rmwdbtn'\n+        project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+            migrations.CreateModel('Rider', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+            ], options={'db_table': 'rider'}),\n+            migrations.CreateModel('Pony', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+            ]),\n+        ])\n+        new_state = project_state.clone()\n+        operation = migrations.RenameModel('Rider', 'Runner')\n+        operation.state_forwards(app_label, new_state)\n+\n+        # Database operations\n+        with connection.schema_editor() as editor:\n+            with self.assertNumQueries(0):  # Expect no queries since it should be a noop\n+                operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        # Reverse operations\n+        with connection.schema_editor() as editor:\n+            with self.assertNumQueries(0):  # Expect no queries since it should be a noop\n+                operation.database_backwards(app_label, editor, new_state, project_state)\n+\n+        # Re-assert the tables exist to ensure the rename was a noop\n+        Rider_model = new_state.apps.get_model(app_label, 'Rider')\n+        self.assertEqual(Rider_model._meta.db_table, 'rider')\n+\n+        Pony_model = new_state.apps.get_model(app_label, 'Pony')\n+        rider_field = Pony_model._meta.get_field('rider')\n+        self.assertEqual(rider_field.remote_field.model, Rider_model)\n+\n     def test_rename_m2m_target_model(self):\n         app_label = \"test_rename_m2m_target_model\"\n         project_state = self.apply_operations(app_label, ProjectState(), operations=[\n",
  "django__django-15061": "diff --git a/tests/forms_tests/field_tests/test_multivaluefield.py b/tests/forms_tests/field_tests/test_multivaluefield.py\nindex 53aee21..f6da94d 100644\n--- a/tests/forms_tests/field_tests/test_multivaluefield.py\n+++ b/tests/forms_tests/field_tests/test_multivaluefield.py\n@@ -154,7 +154,14 @@ class MultiValueFieldTest(SimpleTestCase):\n             \"\"\",\n         )\n \n-    def test_form_as_table_data(self):\n+    def test_id_for_label_in_multivaluefield(self):\n+        form = ComplexFieldForm()\n+        rendered = form.as_table()\n+        # Ensure the <label> elements have the correct 'for' attributes\n+        self.assertIn('<label for=\"id_field1_0\">Field1:</label>', rendered)\n+        self.assertIn('<label for=\"id_field1_1\">Select:</label>', rendered)\n+        self.assertNotIn('for=\"id_field1_0_0\"', rendered)\n+        self.assertNotIn('for=\"id_field1_0_1\"', rendered)\n         form = ComplexFieldForm({\n             'field1_0': 'some text',\n             'field1_1': ['J', 'P'],\n",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..0952a40 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -107,7 +107,17 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n                 with self.assertRaisesMessage(ValidationError, msg):\n                     f.clean(value)\n \n-    def test_urlfield_clean_required(self):\n+    def test_urlfield_clean_valueerror_to_validationerror(self):\n+        f = URLField()\n+        tests = [\n+            '////]@N.AN',\n+            '#@A.bO',\n+        ]\n+        msg = \"'Enter a valid URL.'\"\n+        for value in tests:\n+            with self.subTest(value=value):\n+                with self.assertRaisesMessage(ValidationError, msg):\n+                    f.clean(value)\n         f = URLField()\n         msg = \"'This field is required.'\"\n         with self.assertRaisesMessage(ValidationError, msg):\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..fb3027a 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -6,16 +6,19 @@ from django.db.models import (\n     BooleanField, Case, CharField, Count, DateTimeField, DecimalField, Exists,\n     ExpressionWrapper, F, FloatField, Func, IntegerField, Max, OuterRef, Q,\n     Subquery, Sum, Value, When,\n+    Sum,\n )\n from django.db.models.expressions import RawSQL\n from django.db.models.functions import (\n     Coalesce, ExtractYear, Floor, Length, Lower, Trim,\n+    Sum,\n )\n from django.test import TestCase, skipUnlessDBFeature\n from django.test.utils import register_lookup\n \n from .models import (\n     Author, Book, Company, DepartmentStore, Employee, Publisher, Store, Ticket,\n+    Sum,\n )\n \n \n@@ -216,7 +219,25 @@ class NonAggregateAnnotationTestCase(TestCase):\n         )\n         self.assertIsNone(qs.first().empty)\n \n-    def test_annotate_with_aggregation(self):\n+    def test_full_expression_annotation(self):\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_full_expression_annotation_with_aggregation(self):\n+        qs = Book.objects.filter(isbn='159059725').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in qs], [1])\n+\n+    def test_aggregate_over_full_expression_annotation(self):\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         books = Book.objects.annotate(is_book=Value(1), rating_count=Count('rating'))\n         for book in books:\n             self.assertEqual(book.is_book, 1)\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..a6c1712 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,4 @@\n+\n import json\n import random\n \n@@ -163,6 +164,19 @@ class CookieTests(BaseTests, SimpleTestCase):\n         decoded_messages = json.loads(value, cls=MessageDecoder)\n         self.assertEqual(messages, decoded_messages)\n \n+    def test_extra_tags_preservation(self):\n+        \"\"\"\n+        Check that the `extra_tags` attribute is correctly preserved\n+        when it's an empty string, and it does not incorrectly\n+        become None during the encoding/decoding process.\n+        \"\"\"\n+        storage = self.get_storage()\n+        message = Message(constants.INFO, 'Test message', extra_tags=\"\")\n+        encoded_message = storage._encode(message)\n+        decoded_message = storage._decode(encoded_message)\n+        self.assertEqual(decoded_message.extra_tags, \"\")\n+        self.assertIsNotNone(decoded_message.extra_tags)\n+\n     def test_safedata(self):\n         \"\"\"\n         A message containing SafeData is keeping its safe status when\n",
  "django__django-15388": "",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..17f3e32 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -7,7 +8,7 @@ from django.conf.urls.static import static\n from django.core.exceptions import ImproperlyConfigured\n from django.http import FileResponse, HttpResponseNotModified\n from django.test import SimpleTestCase, override_settings\n-from django.utils.http import http_date\n+from django.utils.http import http_date, parse_http_date_safe\n from django.views.static import was_modified_since\n \n from .. import urls\n@@ -184,7 +185,35 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n-    def test_was_modified_since_fp(self):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"\n+        Test that an empty If-Modified-Since header\n+        is correctly handled without raising an exception.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(\"\", mtime=1))\n+\n+    def test_was_modified_since_no_header(self):\n+        \"\"\"\n+        Test was_modified_since with no If-Modified-Since header\n+        should return True, indicating the resource was modified.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(None, mtime=1))\n+\n+    def test_was_modified_since_invalid_date(self):\n+        \"\"\"\n+        Test was_modified_since with an invalid date\n+        string in the header, which should return True.\n+        \"\"\"\n+        header = \"Invalid Date\"\n+        self.assertTrue(was_modified_since(header, mtime=1))\n+\n+    def test_was_modified_since_future_date(self):\n+        \"\"\"\n+        Test was_modified_since with a future date\n+        to check if it returns False, indicating not modified.\n+        \"\"\"\n+        future_date = http_date(2000000000)  # Arbitrary future timestamp\n+        self.assertFalse(was_modified_since(future_date, mtime=1))\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n         \"\"\"\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..52c5d18 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,3 +1,4 @@\n+\n import os\n from io import StringIO\n from unittest import mock\n@@ -8,6 +9,7 @@ from django.apps import apps\n from django.core import management\n from django.core.checks import Tags\n from django.core.management import BaseCommand, CommandError, find_commands\n+from argparse import ArgumentDefaultsHelpFormatter\n from django.core.management.utils import (\n     find_command,\n     get_random_secret_key,\n@@ -411,6 +413,31 @@ class CommandTests(SimpleTestCase):\n         parser = BaseCommand().create_parser(\"prog_name\", \"subcommand\", epilog=epilog)\n         self.assertEqual(parser.epilog, epilog)\n \n+    def test_custom_formatter_output(self):\n+        \"\"\"Test that the custom formatter output is correctly formatted.\"\"\"\n+        command = BaseCommand()\n+        command.help = '''\n+            Import a contract from tzkt.\n+            Example usage:\n+                ./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\n+        '''\n+        parser = command.create_parser(\"manage.py\", \"tzkt_import\", formatter_class=ArgumentDefaultsHelpFormatter)\n+        output = parser.format_help()\n+        expected_help = '''usage: manage.py tzkt_import [-h] [--api API] [--version]\n+            [-v {0,1,2,3}] [--settings SETTINGS] [--pythonpath PYTHONPATH]\n+            [--traceback] [--no-color] [--force-color] [--skip-checks]\n+            blockchain target\n+\n+    Import a contract from tzkt \n+    Example usage: \n+        ./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\n+\n+positional arguments:\n+  blockchain          Name of the blockchain to import into\n+  target              Id of the contract to import\n+'''\n+        self.assertIn(expected_help.strip(), output)\n+\n     def test_outputwrapper_flush(self):\n         out = StringIO()\n         with mock.patch.object(out, \"flush\") as mocked_flush:\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..e4c0c9e 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,8 +1,11 @@\n+\n import os\n from datetime import datetime\n \n from django.test import SimpleTestCase\n from django.utils.functional import lazystr\n+from django.core.serializers.json import DjangoJSONEncoder\n+import json\n from django.utils.html import (\n     conditional_escape,\n     escape,\n@@ -211,6 +214,42 @@ class TestUtilsHtml(SimpleTestCase):\n             with self.subTest(arg=arg):\n                 self.assertEqual(json_script(arg, \"test_id\"), expected)\n \n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"hello\": \"world\"}'\n+\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"hello\": \"world\"}</script>',\n+        )\n+\n+    def test_json_script_custom_encoder_with_data(self):\n+        class CustomDictEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                # Custom encoding logic for dictionaries\n+                if isinstance(o, dict):\n+                    o = {f\"custom_{k}\": v for k, v in o.items()}\n+                return json.dumps(o)\n+\n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}, encoder=CustomDictEncoder),\n+            '<script type=\"application/json\">{\"custom_key\": \"value\"}</script>',\n+        )\n+\n+    def test_json_script_custom_encoder_with_list(self):\n+        class CustomListEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                # Custom encoding logic for lists\n+                if isinstance(o, list):\n+                    o = [\"custom_\" + str(item) for item in o]\n+                return json.dumps(o)\n+\n+        self.assertHTMLEqual(\n+            json_script([\"a\", \"b\", \"c\"], encoder=CustomListEncoder),\n+            '<script type=\"application/json\">[\"custom_a\", \"custom_b\", \"custom_c\"]</script>',\n+        )\n+\n     def test_json_script_without_id(self):\n         self.assertHTMLEqual(\n             json_script({\"key\": \"value\"}),\n",
  "django__django-15790": "diff --git a/tests/check_framework/test_templates.py b/tests/check_framework/test_templates.py\nindex 72e6cfe..593f482 100644\n--- a/tests/check_framework/test_templates.py\n+++ b/tests/check_framework/test_templates.py\n@@ -142,6 +142,67 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n             [self.error_same_tags],\n         )\n \n+    @override_settings(\n+        INSTALLED_APPS=[\"check_framework.template_test_apps.same_tags_app_1\"]\n+    )\n+    def test_no_duplicate_tags_single_app(self):\n+        \"Test with only one app to ensure no false positives without duplicates\"\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"unique_tags\", \"same_tags_app_1.templatetags.unique_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+\n+    def test_multiple_different_library_names(self):\n+        \"Test with different library names, identical module paths\"\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"diff_name_1\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+                self.get_settings(\n+                    \"diff_name_2\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+        ]\n+    )\n+    def test_conflict_in_libraries_setting(self):\n+        \"Test case for conflict within the libraries setting itself\"\n+        with self.settings(\n+            TEMPLATES=[\n+                {\n+                    \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n+                    \"OPTIONS\": {\n+                        \"libraries\": {\n+                            \"conflict_tags\": \"same_tags_app_1.templatetags.same_tags\",\n+                            \"conflict_tags\": \"same_tags_app_1.templatetags.different_tags\",\n+                        }\n+                    },\n+                }\n+            ]\n+        ):\n+            expected_error = Error(\n+                E003.msg.format(\n+                    \"'conflict_tags'\",\n+                    \"'check_framework.template_test_apps.same_tags_app_1.templatetags.same_tags', \"\n+                    \"'check_framework.template_test_apps.same_tags_app_1.templatetags.different_tags'\",\n+                ),\n+                id=E003.id,\n+            )\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [expected_error]\n+            )\n+\n     def test_template_tags_with_same_library_name(self):\n         with self.settings(\n             TEMPLATES=[\n@@ -206,4 +267,4 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n         ]\n     )\n     def test_template_tags_with_different_name(self):\n-        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..c0c1fb0 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -395,10 +395,23 @@ class ProxyModelTests(TestCase):\n         p = MyPerson.objects.get(pk=100)\n         self.assertEqual(p.name, \"Elvis Presley\")\n \n+    def test_proxy_select_related_only(self):\n+        # Create test data\n+        custom = ProxyCustomModel.objects.create(name=\"Custom Name\")\n+        another = AnotherModel.objects.create(custom=custom)\n+        \n+        # Test the QuerySet with select_related and only on the proxy model\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+        self.assertEqual(qs.get(), another)\n+\n     def test_eq(self):\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n \n+from django.db import models\n+from django.test import TestCase\n+from .models import ProxyCustomModel, AnotherModel, ProxyTrackerUser, Issue\n+\n @override_settings(ROOT_URLCONF=\"proxy_models.urls\")\n class ProxyModelAdminTests(TestCase):\n     @classmethod\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..a536116 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -152,6 +152,10 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         )\n \n     def test_parameters(self):\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"SELECT 1\"]),\n+            ([\"psql\", \"-c\", \"SELECT 1\", \"dbname\"], None),\n+        )\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n             ([\"psql\", \"dbname\", \"--help\"], None),\n@@ -183,4 +187,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "",
  "django__django-16041": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex a34f3d3..c1a42b2 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -186,7 +186,19 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.errors, [{\"votes\": [\"This field is required.\"]}])\n \n-    def test_formset_validation_count(self):\n+    def test_empty_permitted_ignored_empty_form_false(self):\n+        # This test confirms that form_kwargs with empty_permitted=False does not affect empty_form.\n+        ArticleFormSet = modelformset_factory(MyModel, fields=['a_field'])\n+        formset = ArticleFormSet(form_kwargs={\"empty_permitted\": False})\n+        # Verify that the default behavior is maintained for empty_form.empty_permitted\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n+\n+    def test_empty_permitted_ignored_empty_form_true(self):\n+        # This test confirms that form_kwargs with empty_permitted=True does not affect empty_form.\n+        ArticleFormSet = modelformset_factory(MyModel, fields=['a_field'])\n+        formset = ArticleFormSet(form_kwargs={\"empty_permitted\": True})\n+        # Verify that the default behavior is maintained for empty_form.empty_permitted\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n         \"\"\"\n         A formset's ManagementForm is validated once per FormSet.is_valid()\n         call and each form of the formset is cleaned once.\n",
  "django__django-16046": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 41aae41..d4213c1 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -1,3 +1,4 @@\n+\n from decimal import Decimal\n from sys import float_info\n \n@@ -160,7 +161,17 @@ class TestNumberFormat(SimpleTestCase):\n                     nformat(Decimal(value), \".\", decimal_pos), expected_value\n                 )\n \n-    def test_decimal_subclass(self):\n+    def test_empty(self):\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        self.assertEqual(nformat(None, \".\"), \"None\")\n+\n+    def test_none_input(self):\n+        self.assertEqual(nformat(None, \",\"), \"None\")\n+        self.assertEqual(nformat(None, \".\", decimal_pos=2), \"None\")\n+        \n+    def test_empty_string(self):\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        self.assertEqual(nformat(\"\", \",\", decimal_pos=2), \"\")\n         class EuroDecimal(Decimal):\n             \"\"\"\n             Wrapper for Decimal which prefixes each amount with the \u20ac symbol.\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..3f13c1a 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -25,6 +26,8 @@ from django.test import SimpleTestCase, TestCase, override_settings\n from django.utils import translation\n from django.utils.text import capfirst\n from django.utils.translation import gettext as _\n+from django.urls import reverse\n+import urllib.parse\n \n from .models.custom_user import (\n     CustomUser,\n@@ -892,6 +895,26 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # value to render correctly\n         self.assertEqual(form.initial[\"password\"], form[\"password\"].value())\n \n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search(r'<a href=\"(.*?)\">', password_help_text)\n+\n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.username,),\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n     def test_custom_form(self):\n         class CustomUserChangeForm(UserChangeForm):\n             class Meta(UserChangeForm.Meta):\n",
  "django__django-16255": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 1469efd..6a3ad78 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -507,8 +507,42 @@ class HTTPSitemapTests(SitemapTestsBase):\n         self.assertXMLEqual(index_response.content.decode(), expected_content_index)\n         self.assertXMLEqual(sitemap_response.content.decode(), expected_content_sitemap)\n \n+from django.test import TestCase\n+from django.urls import path, reverse\n+from django.contrib.sitemaps import Sitemap\n+from django.contrib.sites.models import Site\n+\n+class CallableLastmodNoItemsSitemap(Sitemap):\n+    location = \"/location/\"\n+\n+    def items(self):\n+        return []\n+\n+    def lastmod(self, obj):\n+        return obj.lastmod\n+\n \n-# RemovedInDjango50Warning\n+class SitemapLastmodTests(TestCase):\n+    @classmethod\n+    def setUpClass(cls):\n+        super().setUpClass()\n+        cls.sitemaps = {\n+            'callable-lastmod-no-items': CallableLastmodNoItemsSitemap,\n+        }\n+\n+    def test_callable_lastmod_no_items(self):\n+        index_url = reverse('django.contrib.sitemaps.views.index', kwargs={'section': 'callable-lastmod-no-items'})\n+        response = self.client.get(index_url)\n+        self.assertNotIn('Last-Modified', response)\n+        expected_content = (\n+            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n+            '<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\\n'\n+            '  <sitemap>\\n'\n+            '    <loc>http://example.com/location/</loc>\\n'\n+            '  </sitemap>\\n'\n+            '</sitemapindex>'\n+        )\n+        self.assertXMLEqual(response.content.decode(), expected_content)\n class DeprecatedTests(SitemapTestsBase):\n     @override_settings(\n         TEMPLATES=[\n",
  "django__django-16379": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 014d28a..151433f 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1,6 +1,8 @@\n+\n # Unit tests for cache framework\n # Uses whatever cache backend is set in the test settings file.\n import copy\n+from unittest import mock\n import io\n import os\n import pickle\n@@ -1755,7 +1757,27 @@ class FileBasedCacheTests(BaseCacheTests, TestCase):\n             with self.assertRaises(OSError):\n                 cache.get(\"foo\")\n \n-    def test_empty_cache_file_considered_expired(self):\n+    def test_has_key_race_handling(self):\n+        self.assertIs(cache.add(\"key\", \"value\"), True)\n+        with mock.patch(\"builtins.open\", side_effect=FileNotFoundError) as mocked_open:\n+            self.assertIs(cache.has_key(\"key\"), False)\n+            mocked_open.assert_called_once()\n+\n+    def test_has_key_race_condition_between_exists_and_open(self):\n+        key = \"race-condition-key\"\n+        value = \"test\"\n+        cache.add(key, value)\n+\n+        def side_effect_open(*args, **kwargs):\n+            # Simulate deletion of the file after it's checked to exist\n+            cache_file = cache._key_to_file(key)\n+            if os.path.exists(cache_file):\n+                os.remove(cache_file)\n+            raise FileNotFoundError\n+\n+        with mock.patch(\"builtins.open\", side_effect=side_effect_open) as mocked_open:\n+            self.assertIs(cache.has_key(key), False)\n+            mocked_open.assert_called_once()\n         cache_file = cache._key_to_file(\"foo\")\n         with open(cache_file, \"wb\") as fh:\n             fh.write(b\"\")\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..b0ccce9 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -10,7 +11,8 @@ from django.urls import reverse\n \n from .admin import ArticleAdmin, site\n from .models import Article, Question\n-from .tests import AdminViewBasicTestCase\n+from django.contrib.auth import get_permission_codename\n+from .tests import AdminViewBasicTestCase, get_perm\n \n \n class AdminTemplateTagsTest(AdminViewBasicTestCase):\n@@ -33,6 +35,40 @@ class AdminTemplateTagsTest(AdminViewBasicTestCase):\n         self.assertIs(template_context[\"extra\"], True)\n         self.assertIs(template_context[\"show_save\"], True)\n \n+    def test_submit_row_save_as_new_add_permission_required(self):\n+        # Create a user with change permission only\n+        change_user = User.objects.create_user(\n+            username=\"change_user\", password=\"secret\", is_staff=True\n+        )\n+        change_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = change_user\n+        admin = UserAdmin(User, site)\n+        admin.save_as = True\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], False)\n+\n+        # Create a user with both add and change permission\n+        add_user = User.objects.create_user(\n+            username=\"add_user\", password=\"secret\", is_staff=True\n+        )\n+        add_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"add\", User._meta)),\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = add_user\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], True)\n+\n     def test_override_show_save_and_add_another(self):\n         request = self.request_factory.get(\n             reverse(\"admin:auth_user_change\", args=[self.superuser.pk]),\n",
  "django__django-16595": "",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..7103a5d 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,11 +1,24 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n \n from ..utils import setup\n \n+from django.utils.html import escape\n \n class JoinTests(SimpleTestCase):\n+    @setup({\"join_autoescape_off\": '{% autoescape off %}{{ a|join:var }}{% endautoescape %}'})\n+    def test_join_autoescape_off(self):\n+        \"\"\"\n+        Test case for verifying that the join filter doesn't escape the joining string\n+        when autoescape is off.\n+        \"\"\"\n+        var_list = [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"]\n+        context = {\"a\": var_list, \"var\": \"<br/>\"}\n+        output = self.engine.render_to_string(\"join_autoescape_off\", context)\n+        expected_result = \"<p>Hello World!</p><br/>beta & me<br/><script>Hi!</script>\"\n+        self.assertEqual(output, expected_result)\n     @setup({\"join01\": '{{ a|join:\", \" }}'})\n     def test_join01(self):\n         output = self.engine.render_to_string(\"join01\", {\"a\": [\"alpha\", \"beta & me\"]})\n@@ -78,4 +91,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..bcbc984 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -597,21 +597,201 @@ class BulkCreateTests(TestCase):\n             ],\n         )\n \n+    def test_update_conflicts_returning_ids(self):\n+        # Insert initial data.\n+        TwoFields.objects.bulk_create([\n+            TwoFields(f1=1, f2=1, name=\"initial1\"),\n+            TwoFields(f1=2, f2=2, name=\"initial2\"),\n+        ])\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Update conflicts and check if IDs are returned.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated1\"),\n+            TwoFields(f1=2, f2=2, name=\"updated2\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n+    def test_update_conflicts_returning_ids_complex(self):\n+        # Check with a more complex model to ensure it handles returning IDs.\n+\n+        # Insert preliminary data.\n+        UpsertConflict.objects.bulk_create([\n+            UpsertConflict(number=1, rank=1, name=\"Name1\"),\n+            UpsertConflict(number=2, rank=2, name=\"Name2\"),\n+        ])\n+        self.assertEqual(UpsertConflict.objects.count(), 2)\n+\n+        # Perform bulk_create with conflicts resolution.\n+        conflicting_objects = [\n+            UpsertConflict(number=1, rank=3, name=\"UpdatedName1\"),\n+            UpsertConflict(number=2, rank=4, name=\"UpdatedName2\"),\n+        ]\n+\n+        results = UpsertConflict.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"number\"],\n+            update_fields=[\"rank\", \"name\"],\n+        )\n+\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.id)\n+\n+        # Assert data match\n+        self.assertCountEqual(\n+            UpsertConflict.objects.values(\"number\", \"rank\", \"name\"),\n+            [\n+                {\"number\": 1, \"rank\": 3, \"name\": \"UpdatedName1\"},\n+                {\"number\": 2, \"rank\": 4, \"name\": \"UpdatedName2\"},\n+            ],\n+        )\n     def test_update_conflicts_two_fields_unique_fields_first(self):\n         self._test_update_conflicts_two_fields([\"f1\"])\n \n+    def test_update_conflicts_returning_ids(self):\n+        # Insert initial data.\n+        TwoFields.objects.bulk_create([\n+            TwoFields(f1=1, f2=1, name=\"initial1\"),\n+            TwoFields(f1=2, f2=2, name=\"initial2\"),\n+        ])\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Update conflicts and check if IDs are returned.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated1\"),\n+            TwoFields(f1=2, f2=2, name=\"updated2\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n+    def test_update_conflicts_returning_ids_complex(self):\n+        # Check with a more complex model to ensure it handles returning IDs.\n+\n+        # Insert preliminary data.\n+        UpsertConflict.objects.bulk_create([\n+            UpsertConflict(number=1, rank=1, name=\"Name1\"),\n+            UpsertConflict(number=2, rank=2, name=\"Name2\"),\n+        ])\n+        self.assertEqual(UpsertConflict.objects.count(), 2)\n+\n+        # Perform bulk_create with conflicts resolution.\n+        conflicting_objects = [\n+            UpsertConflict(number=1, rank=3, name=\"UpdatedName1\"),\n+            UpsertConflict(number=2, rank=4, name=\"UpdatedName2\"),\n+        ]\n+\n+        results = UpsertConflict.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"number\"],\n+            update_fields=[\"rank\", \"name\"],\n+        )\n+\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.id)\n+\n+        # Assert data match\n+        self.assertCountEqual(\n+            UpsertConflict.objects.values(\"number\", \"rank\", \"name\"),\n+            [\n+                {\"number\": 1, \"rank\": 3, \"name\": \"UpdatedName1\"},\n+                {\"number\": 2, \"rank\": 4, \"name\": \"UpdatedName2\"},\n+            ],\n+        )\n     def test_update_conflicts_two_fields_unique_fields_second(self):\n         self._test_update_conflicts_two_fields([\"f2\"])\n \n+    def test_update_conflicts_returning_ids(self):\n+        # Insert initial data.\n+        TwoFields.objects.bulk_create([\n+            TwoFields(f1=1, f2=1, name=\"initial1\"),\n+            TwoFields(f1=2, f2=2, name=\"initial2\"),\n+        ])\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Update conflicts and check if IDs are returned.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated1\"),\n+            TwoFields(f1=2, f2=2, name=\"updated2\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n+    def test_update_conflicts_returning_ids_complex(self):\n+        # Check with a more complex model to ensure it handles returning IDs.\n+\n+        # Insert preliminary data.\n+        UpsertConflict.objects.bulk_create([\n+            UpsertConflict(number=1, rank=1, name=\"Name1\"),\n+            UpsertConflict(number=2, rank=2, name=\"Name2\"),\n+        ])\n+        self.assertEqual(UpsertConflict.objects.count(), 2)\n+\n+        # Perform bulk_create with conflicts resolution.\n+        conflicting_objects = [\n+            UpsertConflict(number=1, rank=3, name=\"UpdatedName1\"),\n+            UpsertConflict(number=2, rank=4, name=\"UpdatedName2\"),\n+        ]\n+\n+        results = UpsertConflict.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"number\"],\n+            update_fields=[\"rank\", \"name\"],\n+        )\n+\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.id)\n+\n+        # Assert data match\n+        self.assertCountEqual(\n+            UpsertConflict.objects.values(\"number\", \"rank\", \"name\"),\n+            [\n+                {\"number\": 1, \"rank\": 3, \"name\": \"UpdatedName1\"},\n+                {\"number\": 2, \"rank\": 4, \"name\": \"UpdatedName2\"},\n+            ],\n+        )\n     def test_update_conflicts_unique_fields_pk(self):\n         TwoFields.objects.bulk_create(\n             [\n@@ -642,9 +822,69 @@ class BulkCreateTests(TestCase):\n             ],\n         )\n \n+    def test_update_conflicts_returning_ids(self):\n+        # Insert initial data.\n+        TwoFields.objects.bulk_create([\n+            TwoFields(f1=1, f2=1, name=\"initial1\"),\n+            TwoFields(f1=2, f2=2, name=\"initial2\"),\n+        ])\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Update conflicts and check if IDs are returned.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated1\"),\n+            TwoFields(f1=2, f2=2, name=\"updated2\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n+    def test_update_conflicts_returning_ids_complex(self):\n+        # Check with a more complex model to ensure it handles returning IDs.\n+\n+        # Insert preliminary data.\n+        UpsertConflict.objects.bulk_create([\n+            UpsertConflict(number=1, rank=1, name=\"Name1\"),\n+            UpsertConflict(number=2, rank=2, name=\"Name2\"),\n+        ])\n+        self.assertEqual(UpsertConflict.objects.count(), 2)\n+\n+        # Perform bulk_create with conflicts resolution.\n+        conflicting_objects = [\n+            UpsertConflict(number=1, rank=3, name=\"UpdatedName1\"),\n+            UpsertConflict(number=2, rank=4, name=\"UpdatedName2\"),\n+        ]\n+\n+        results = UpsertConflict.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"number\"],\n+            update_fields=[\"rank\", \"name\"],\n+        )\n+\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.id)\n+\n+        # Assert data match\n+        self.assertCountEqual(\n+            UpsertConflict.objects.values(\"number\", \"rank\", \"name\"),\n+            [\n+                {\"number\": 1, \"rank\": 3, \"name\": \"UpdatedName1\"},\n+                {\"number\": 2, \"rank\": 4, \"name\": \"UpdatedName2\"},\n+            ],\n+        )\n     def test_update_conflicts_two_fields_unique_fields_both(self):\n         with self.assertRaises((OperationalError, ProgrammingError)):\n             self._test_update_conflicts_two_fields([\"f1\", \"f2\"])\n@@ -710,15 +950,135 @@ class BulkCreateTests(TestCase):\n             ],\n         )\n \n+    def test_update_conflicts_returning_ids(self):\n+        # Insert initial data.\n+        TwoFields.objects.bulk_create([\n+            TwoFields(f1=1, f2=1, name=\"initial1\"),\n+            TwoFields(f1=2, f2=2, name=\"initial2\"),\n+        ])\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Update conflicts and check if IDs are returned.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated1\"),\n+            TwoFields(f1=2, f2=2, name=\"updated2\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n+    def test_update_conflicts_returning_ids_complex(self):\n+        # Check with a more complex model to ensure it handles returning IDs.\n+\n+        # Insert preliminary data.\n+        UpsertConflict.objects.bulk_create([\n+            UpsertConflict(number=1, rank=1, name=\"Name1\"),\n+            UpsertConflict(number=2, rank=2, name=\"Name2\"),\n+        ])\n+        self.assertEqual(UpsertConflict.objects.count(), 2)\n+\n+        # Perform bulk_create with conflicts resolution.\n+        conflicting_objects = [\n+            UpsertConflict(number=1, rank=3, name=\"UpdatedName1\"),\n+            UpsertConflict(number=2, rank=4, name=\"UpdatedName2\"),\n+        ]\n+\n+        results = UpsertConflict.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"number\"],\n+            update_fields=[\"rank\", \"name\"],\n+        )\n+\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.id)\n+\n+        # Assert data match\n+        self.assertCountEqual(\n+            UpsertConflict.objects.values(\"number\", \"rank\", \"name\"),\n+            [\n+                {\"number\": 1, \"rank\": 3, \"name\": \"UpdatedName1\"},\n+                {\"number\": 2, \"rank\": 4, \"name\": \"UpdatedName2\"},\n+            ],\n+        )\n     def test_update_conflicts_unique_two_fields_unique_fields_both(self):\n         self._test_update_conflicts_unique_two_fields([\"iso_two_letter\", \"name\"])\n \n+    def test_update_conflicts_returning_ids(self):\n+        # Insert initial data.\n+        TwoFields.objects.bulk_create([\n+            TwoFields(f1=1, f2=1, name=\"initial1\"),\n+            TwoFields(f1=2, f2=2, name=\"initial2\"),\n+        ])\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Update conflicts and check if IDs are returned.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated1\"),\n+            TwoFields(f1=2, f2=2, name=\"updated2\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n+    def test_update_conflicts_returning_ids_complex(self):\n+        # Check with a more complex model to ensure it handles returning IDs.\n+\n+        # Insert preliminary data.\n+        UpsertConflict.objects.bulk_create([\n+            UpsertConflict(number=1, rank=1, name=\"Name1\"),\n+            UpsertConflict(number=2, rank=2, name=\"Name2\"),\n+        ])\n+        self.assertEqual(UpsertConflict.objects.count(), 2)\n+\n+        # Perform bulk_create with conflicts resolution.\n+        conflicting_objects = [\n+            UpsertConflict(number=1, rank=3, name=\"UpdatedName1\"),\n+            UpsertConflict(number=2, rank=4, name=\"UpdatedName2\"),\n+        ]\n+\n+        results = UpsertConflict.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"number\"],\n+            update_fields=[\"rank\", \"name\"],\n+        )\n+\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.id)\n+\n+        # Assert data match\n+        self.assertCountEqual(\n+            UpsertConflict.objects.values(\"number\", \"rank\", \"name\"),\n+            [\n+                {\"number\": 1, \"rank\": 3, \"name\": \"UpdatedName1\"},\n+                {\"number\": 2, \"rank\": 4, \"name\": \"UpdatedName2\"},\n+            ],\n+        )\n     def test_update_conflicts_unique_two_fields_unique_fields_one(self):\n         with self.assertRaises((OperationalError, ProgrammingError)):\n             self._test_update_conflicts_unique_two_fields([\"iso_two_letter\"])\n@@ -776,9 +1136,69 @@ class BulkCreateTests(TestCase):\n             ],\n         )\n \n+    def test_update_conflicts_returning_ids(self):\n+        # Insert initial data.\n+        TwoFields.objects.bulk_create([\n+            TwoFields(f1=1, f2=1, name=\"initial1\"),\n+            TwoFields(f1=2, f2=2, name=\"initial2\"),\n+        ])\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Update conflicts and check if IDs are returned.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated1\"),\n+            TwoFields(f1=2, f2=2, name=\"updated2\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n+    def test_update_conflicts_returning_ids_complex(self):\n+        # Check with a more complex model to ensure it handles returning IDs.\n+\n+        # Insert preliminary data.\n+        UpsertConflict.objects.bulk_create([\n+            UpsertConflict(number=1, rank=1, name=\"Name1\"),\n+            UpsertConflict(number=2, rank=2, name=\"Name2\"),\n+        ])\n+        self.assertEqual(UpsertConflict.objects.count(), 2)\n+\n+        # Perform bulk_create with conflicts resolution.\n+        conflicting_objects = [\n+            UpsertConflict(number=1, rank=3, name=\"UpdatedName1\"),\n+            UpsertConflict(number=2, rank=4, name=\"UpdatedName2\"),\n+        ]\n+\n+        results = UpsertConflict.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"number\"],\n+            update_fields=[\"rank\", \"name\"],\n+        )\n+\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.id)\n+\n+        # Assert data match\n+        self.assertCountEqual(\n+            UpsertConflict.objects.values(\"number\", \"rank\", \"name\"),\n+            [\n+                {\"number\": 1, \"rank\": 3, \"name\": \"UpdatedName1\"},\n+                {\"number\": 2, \"rank\": 4, \"name\": \"UpdatedName2\"},\n+            ],\n+        )\n     def test_update_conflicts_unique_fields(self):\n         self._test_update_conflicts(unique_fields=[\"number\"])\n \n@@ -787,9 +1207,69 @@ class BulkCreateTests(TestCase):\n     def test_update_conflicts_no_unique_fields(self):\n         self._test_update_conflicts([])\n \n+    def test_update_conflicts_returning_ids(self):\n+        # Insert initial data.\n+        TwoFields.objects.bulk_create([\n+            TwoFields(f1=1, f2=1, name=\"initial1\"),\n+            TwoFields(f1=2, f2=2, name=\"initial2\"),\n+        ])\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Update conflicts and check if IDs are returned.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated1\"),\n+            TwoFields(f1=2, f2=2, name=\"updated2\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n+    def test_update_conflicts_returning_ids_complex(self):\n+        # Check with a more complex model to ensure it handles returning IDs.\n+\n+        # Insert preliminary data.\n+        UpsertConflict.objects.bulk_create([\n+            UpsertConflict(number=1, rank=1, name=\"Name1\"),\n+            UpsertConflict(number=2, rank=2, name=\"Name2\"),\n+        ])\n+        self.assertEqual(UpsertConflict.objects.count(), 2)\n+\n+        # Perform bulk_create with conflicts resolution.\n+        conflicting_objects = [\n+            UpsertConflict(number=1, rank=3, name=\"UpdatedName1\"),\n+            UpsertConflict(number=2, rank=4, name=\"UpdatedName2\"),\n+        ]\n+\n+        results = UpsertConflict.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"number\"],\n+            update_fields=[\"rank\", \"name\"],\n+        )\n+\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.id)\n+\n+        # Assert data match\n+        self.assertCountEqual(\n+            UpsertConflict.objects.values(\"number\", \"rank\", \"name\"),\n+            [\n+                {\"number\": 1, \"rank\": 3, \"name\": \"UpdatedName1\"},\n+                {\"number\": 2, \"rank\": 4, \"name\": \"UpdatedName2\"},\n+            ],\n+        )\n     def test_update_conflicts_unique_fields_update_fields_db_column(self):\n         FieldsWithDbColumns.objects.bulk_create(\n             [\n@@ -816,4 +1296,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..6bf308c 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -468,7 +468,33 @@ class WriterTests(SimpleTestCase):\n                     ),\n                 )\n \n-    def test_serialize_uuid(self):\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class is correctly serialized \n+        as Field.default in a migration.\n+        \"\"\"\n+\n+        class ModelWithNestedClassDefault(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                OPTION_A = \"A\", \"Option A\"\n+                OPTION_B = \"B\", \"Option B\"\n+            \n+                @classmethod\n+                def default(cls):\n+                    return cls.OPTION_A\n+\n+            field = models.CharField(\n+                choices=NestedChoices.choices,\n+                max_length=50,\n+                default=NestedChoices.default,\n+            )\n+\n+        field = ModelWithNestedClassDefault._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.ModelWithNestedClassDefault.NestedChoices.default\",\n+            string\n+        )\n         self.assertSerializedEqual(uuid.uuid1())\n         self.assertSerializedEqual(uuid.uuid4())\n \n@@ -1032,4 +1058,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "matplotlib__matplotlib-22711": "",
  "matplotlib__matplotlib-23299": "diff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 144880c..8dc07c5 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -508,6 +508,33 @@ def test_rcparams_reset_after_fail():\n         assert mpl.rcParams['text.usetex'] is False\n \n \n+def test_get_backend_preserves_figures_rc_context():\n+    import matplotlib.pyplot as plt\n+    from matplotlib import get_backend, rc_context\n+    from matplotlib._pylab_helpers import Gcf\n+    \n+    # Ensure any previous figures are cleared\n+    Gcf.destroy_all()\n+\n+    # Creating a figure within an rc_context\n+    with rc_context():\n+        fig2 = plt.figure()\n+    \n+    # Check the state before calling get_backend\n+    before = f'{id(Gcf)} {Gcf.figs!r}'\n+    \n+    # Call get_backend, which previously caused the bug\n+    get_backend()\n+    \n+    # Check the state after calling get_backend\n+    after = f'{id(Gcf)} {Gcf.figs!r}'\n+\n+    # Assert the state has not changed\n+    assert before == after, \"\\n\" + before + \"\\n\" + after\n+\n+    # Cleanup\n+    plt.close('all')\n+\n @pytest.mark.skipif(sys.platform != \"linux\", reason=\"Linux only\")\n def test_backend_fallback_headless(tmpdir):\n     env = {**os.environ,\n",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..7aff206 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -21,6 +21,15 @@ mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n \n+@check_figures_equal(extensions=[\"png\"])\n+def test_invisible_axes_3d(fig_test, fig_ref):\n+    # Test a 3D subplot and make sure it becomes invisible\n+    ax = fig_test.add_subplot(111, projection='3d')\n+    ax.scatter(1, 1, 1)\n+    ax.set_visible(False)\n+    # Reference should be empty\n+    fig_ref.add_subplot(111)\n+\n def test_aspect_equal_error():\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n",
  "matplotlib__matplotlib-23562": "",
  "matplotlib__matplotlib-23563": "",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..717dbed 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -774,6 +774,43 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n         assert mpl.colors.same_color(text.get_color(), color)\n \n \n+import matplotlib.pyplot as plt\n+import pytest\n+import numpy as np\n+\n+@pytest.mark.parametrize('draggable', (True, False))\n+def test_legend_draggable(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='sample')\n+    leg = ax.legend(draggable=draggable)\n+    assert leg.get_draggable() is draggable\n+\n+def test_legend_creation_without_draggable_keyword():\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='sample')\n+    leg = ax.legend()  # No draggable keyword\n+    assert not leg.get_draggable()  # Default should be False\n+\n+@pytest.mark.parametrize('ncol', (1, 2))\n+def test_legend_with_various_columns(ncol):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='sample')\n+    leg = ax.legend(ncol=ncol, draggable=True)\n+    assert leg.get_draggable() is True\n+    assert leg._ncols == ncol\n+\n+def test_legend_interaction_with_set_draggable():\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='sample')\n+    leg = ax.legend(draggable=False)\n+    assert not leg.get_draggable()\n+    \n+    leg.set_draggable(True)\n+    assert leg.get_draggable()\n+\n+    leg.set_draggable(False)\n+    assert not leg.get_draggable()\n+\n def test_get_set_draggable():\n     legend = plt.legend()\n     assert not legend.get_draggable()\n",
  "matplotlib__matplotlib-23964": "",
  "matplotlib__matplotlib-23987": "",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "",
  "matplotlib__matplotlib-24970": "diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex 2be14fe..4b18dad 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -30,7 +30,21 @@ def test_create_lookup_table(N, result):\n     assert_array_almost_equal(mcolors._create_lookup_table(N, data), result)\n \n \n-def test_resampled():\n+import pytest\n+import numpy as np\n+import matplotlib as mpl\n+from matplotlib.testing.decorators import check_figures_equal\n+from matplotlib.colors import Colormap, Normalize\n+from matplotlib.testing.compare import compare_images\n+import matplotlib.colors as mcolors\n+from matplotlib.testing.noseclasses import KnownFailureTest\n+from numpy.testing import assert_array_equal, assert_array_almost_equal\n+\n+@pytest.mark.parametrize(\"dtype\", [np.uint8, int, np.float16, float, np.int16, np.int32])\n+def test_no_deprecation_warning_for_uint8(dtype):\n+    cm = mpl.colormaps[\"viridis\"]\n+    with pytest.deprecated_call():\n+        assert_array_equal(cm(dtype(0)), cm(0))\n     \"\"\"\n     GitHub issue #6025 pointed to incorrect ListedColormap.resampled;\n     here we test the method for LinearSegmentedColormap as well.\n",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..b53928c 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -89,9 +90,28 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n+def test_draggable_legend_pickle():\n+    import pickletools\n+    \n+    fig, ax = plt.subplots()\n+    ax.plot([0, 1, 2], [0, 1, 4], label='quadratic')\n+    leg = ax.legend(draggable=True)\n \n-@mpl.style.context(\"default\")\n-@check_figures_equal(extensions=[\"png\"])\n+    # Attempt to pickle the figure with a draggable legend\n+    try:\n+        pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+        \n+        # Verify that the pickle stream does not contain references to FigureCanvasAgg\n+        assert \"FigureCanvasAgg\" not in [\n+            arg for op, arg, pos in pickletools.genops(pkl)\n+        ]\n+\n+        # Check if unpickling recovers the figure correctly\n+        loaded_fig = pickle.loads(pkl)\n+        # Further checks on the loaded figure could be added here\n+\n+    except Exception as e:\n+        pytest.fail(f\"Pickling of figure with draggable legend failed: {e}\")\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n     # plotting is done, now test its pickle-ability\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..80611b2 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -90,7 +90,42 @@ def _generate_complete_test_figure(fig_ref):\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n \n-@mpl.style.context(\"default\")\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    \"\"\"\n+    Test pickling a figure after calling align_labels to ensure it does not\n+    cause a TypeError.\n+    \"\"\"\n+    # Create a figure and add subplots\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+\n+    # Plot some data\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Align labels\n+    fig.align_labels()\n+\n+    # Serialize the figure to a byte stream with pickle\n+    pkl = BytesIO()\n+    try:\n+        pickle.dump(fig, pkl, pickle.HIGHEST_PROTOCOL)\n+        # If successful, print a pass message\n+        print(\"Test pickling with aligned labels: PASSED\")\n+    except (pickle.PicklingError, TypeError) as e:\n+        # If there is an error, print a fail message and raise the exception\n+        print(\"Test pickling with aligned labels: FAILED\")\n+        raise e\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25442": "",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\nindex 9aa3203..b46f0ba 100644\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -1,4 +1,5 @@\n \n+\n import numpy as np\n import pandas as pd\n \n@@ -8,9 +9,43 @@ from numpy.testing import assert_array_equal, assert_array_almost_equal\n from seaborn._core.groupby import GroupBy\n from seaborn._stats.regression import PolyFit\n \n+from pandas.testing import assert_frame_equal\n \n class TestPolyFit:\n \n+    def test_missing_data_handling(self, df):\n+        # Prepare a DataFrame with missing data\n+        df_with_nan = df.copy()\n+        df_with_nan.iloc[10:15] = np.nan\n+        \n+        # Define groupby object\n+        groupby = GroupBy([\"group\"])\n+\n+        # Attempt to compute PolyFit on data with NaNs\n+        try:\n+            res_with_nan = PolyFit()(df_with_nan[[\"x\", \"y\"]], groupby, \"x\", {})\n+            success = True\n+        except Exception as e:\n+            print(f\"An error occurred: {e}\")\n+            success = False\n+\n+        # Ensure the test passes only if PolyFit does not raise an error\n+        assert success, \"PolyFit raised an error with missing data\"\n+\n+    def test_missing_data_consistency(self, df):\n+        # This test follows the original test logic but is extended to demonstrate consistency\n+        groupby = GroupBy([\"group\"])\n+        df.iloc[5:10] = np.nan\n+        \n+        # Results from data with NaNs\n+        res_with_nan = PolyFit()(df[[\"x\", \"y\"]], groupby, \"x\", {})\n+        \n+        # Results from data without NaNs\n+        res_dropped = PolyFit()(df[[\"x\", \"y\"]].dropna(), groupby, \"x\", {})\n+        \n+        # Assert the two DataFrames are equal\n+        assert_frame_equal(res_with_nan, res_dropped)\n+\n     @pytest.fixture\n     def df(self, rng):\n \n",
  "mwaskom__seaborn-3190": "",
  "mwaskom__seaborn-3407": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\nindex b2e4a92..5f0c2f0 100644\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -1348,7 +1348,14 @@ class TestPairGrid:\n             ax = g.axes[i, j]\n             assert len(ax.collections) == 0\n \n-    def test_pairplot_reg_hue(self):\n+    def test_pairplot_column_multiindex(self):\n+\n+        # Test pairplot with MultiIndex DataFrame to ensure no KeyError is raised\n+        cols = pd.MultiIndex.from_arrays([[\"A\", \"A\", \"B\", \"B\"], [\"1\", \"2\", \"1\", \"2\"]])\n+        df = pd.DataFrame(self.rs.rand(100, 4), columns=cols)\n+        g = ag.pairplot(df)\n+        assert all(isinstance(x, tuple) for x in g.diag_vars), \"Variables should be tuples for MultiIndex columns\"\n+        assert g.diag_vars == list(cols), \"Expected diag_vars to match the MultiIndex columns\"\n \n         markers = [\"o\", \"s\", \"d\"]\n         g = ag.pairplot(self.df, kind=\"reg\", hue=\"a\", markers=markers)\n",
  "pallets__flask-4992": "diff --git a/tests/test_config.py b/tests/test_config.py\nindex 179b09c..68b2228 100644\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -1,8 +1,10 @@\n+\n import json\n import os\n import textwrap\n-\n+import tomllib\n import pytest\n+import tempfile\n \n import flask\n \n@@ -18,6 +20,34 @@ def common_object_test(app):\n     assert \"TestConfig\" not in app.config\n \n \n+def test_config_from_file_binary_mode_with_toml():\n+    app = flask.Flask(__name__)\n+    config_data = b'TEST_KEY = \"foo\"\\nSECRET_KEY = \"binary_mode\"'\n+    \n+    with tempfile.NamedTemporaryFile(suffix=\".toml\", delete=False) as tmpfile:\n+        tmpfile.write(config_data)\n+        tmpfile.flush()\n+        \n+        app.config.from_file(tmpfile.name, tomllib.load, mode=\"rb\")\n+\n+    assert app.config[\"TEST_KEY\"] == \"foo\"\n+    assert app.secret_key == \"binary_mode\"\n+\n+\n+def test_config_from_file_text_mode_with_toml():\n+    app = flask.Flask(__name__)\n+    config_data = 'TEST_KEY = \"foo\"\\nSECRET_KEY = \"text_mode\"'\n+    \n+    with tempfile.NamedTemporaryFile(suffix=\".toml\", mode=\"w\", delete=False) as tmpfile:\n+        tmpfile.write(config_data)\n+        tmpfile.flush()\n+        \n+        app.config.from_file(tmpfile.name, tomllib.load)\n+\n+    assert app.config[\"TEST_KEY\"] == \"foo\"\n+    assert app.secret_key == \"text_mode\"\n+\n+\n def test_config_from_pyfile():\n     app = flask.Flask(__name__)\n     app.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\n",
  "psf__requests-1963": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 7fdc4a9..a62a7d5 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -110,7 +110,7 @@ class SessionRedirectMixin(object):\n             parsed = urlparse(url)\n             url = parsed.geturl()\n \n-            # Facilitate non-RFC2616-compliant 'location' headers\n+            # Facilitate non-RFC2616-compliant 'Location' headers\n             # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')\n             # Compliant with RFC3986, we percent encode the url.\n             if not urlparse(url).netloc:\n",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..ee95c06 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1635,6 +1635,17 @@ def test_prepared_request_complete_copy():\n     )\n     assert_copy(p, p.copy())\n \n+import pytest\n+from requests import Session\n+from requests.adapters import HTTPAdapter\n+from requests.exceptions import DecodeError as RequestsDecodeError\n+from requests.exceptions import ConnectionError as RequestsConnectionError\n+from urllib3.exceptions import DecodeError as Urllib3DecodeError\n+from urllib3.exceptions import ReadTimeoutError as Urllib3TimeoutError\n+from urllib3.exceptions import TimeoutError as Urllib3TimeoutError\n+from unittest.mock import patch\n+\n+...\n \n def test_prepare_unicode_url():\n     p = PreparedRequest()\n@@ -1654,8 +1665,24 @@ def test_urllib3_retries():\n \n     with pytest.raises(RetryError):\n         s.get(httpbin('status/500'))\n-\n-def test_vendor_aliases():\n+def test_urllib3_decode_error_wrapped():\n+    \"\"\"Test that urllib3 DecodeError is wrapped by requests.exceptions.DecodeError\"\"\"\n+    s = Session()\n+    s.mount('http://', HTTPAdapter())\n+    \n+    with patch('urllib3.response.HTTPResponse.decode', side_effect=Urllib3DecodeError):\n+        with pytest.raises(RequestsDecodeError):\n+            s.get('http://example.com')\n+\n+def test_urllib3_timeout_error_wrapped():\n+    \"\"\"Test that urllib3 TimeoutError is wrapped by requests.exceptions.ConnectionError\"\"\"\n+    s = Session()\n+    adapter = HTTPAdapter(max_retries=0)\n+    s.mount('http://', adapter)\n+\n+    with patch('urllib3.connectionpool.HTTPConnectionPool.urlopen', side_effect=Urllib3TimeoutError):\n+        with pytest.raises(RequestsConnectionError):\n+            s.get('http://example.com')\n     from requests.packages import urllib3\n     from requests.packages import chardet\n \n@@ -1663,4 +1690,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 52d1693..d5db69e 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -973,7 +973,20 @@ class TestRequests:\n         chunks = r.iter_content(decode_unicode=True)\n         assert all(isinstance(chunk, str) for chunk in chunks)\n \n-        # also for streaming\n+        # JSON content test\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'{\"key\": \"value\"}')\n+        r.encoding = 'utf-8'\n+        \n+        # Test iter_content with decode_unicode=True\n+        chunks = r.iter_content(decode_unicode=True)\n+        assert all(isinstance(chunk, str) for chunk in chunks), \"Expected all chunks to be str but got bytes\"\n+\n+        # Test r.text returns the same value as combined iter_content\n+        r._content_consumed = True  # Mark content as consumed for accurate r.text response\n+        r._content = b'{\"key\": \"value\"}'  # Mimic the consumed content\n+        iter_content_text = ''.join(r.iter_content(decode_unicode=True))\n+        assert r.text == iter_content_text, \"Expected iter_content text to be equal to r.text\"\n         r = requests.Response()\n         r.raw = io.BytesIO(b'the content')\n         r.encoding = 'ascii'\n",
  "psf__requests-863": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 0ee4333..e7d963e 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -743,8 +743,49 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n             assert 'foo' in response.text\n             assert 'bar' in response.text\n+    def test_multiple_hooks_execution_order(self):\n+        \"\"\"Test that multiple hooks are called in the order they are registered\"\"\"\n \n-    def test_session_persistent_cookies(self):\n+        # Create mock hooks\n+        def hook1(args):\n+            if 'called_hooks' in args:\n+                args['called_hooks'].append('hook1')\n+            else:\n+                args['called_hooks'] = ['hook1']\n+            return args\n+\n+        def hook2(args):\n+            if 'called_hooks' in args:\n+                args['called_hooks'].append('hook2')\n+            else:\n+                args['called_hooks'] = ['hook2']\n+            return args\n+\n+        # Register hooks\n+        hooks = [hook1, hook2]\n+        \n+        # Create a request with the list of hooks\n+        r = requests.models.Request(hooks={'args': hooks})\n+        \n+        # Manual call simulation to trigger hooks\n+        args = {}\n+        for hook in r.hooks['args']:\n+            args = hook(args)\n+        \n+        # Assert the hooks were called in order\n+        assert args['called_hooks'] == ['hook1', 'hook2']\n+\n+    def test_hook_registration_no_double_wrapping(self):\n+        \"\"\"Test that hooks passed as list are not wrapped in another list\"\"\"\n+\n+        def dummy_hook(args):\n+            return args\n+\n+        hooks = [dummy_hook]\n+        r = requests.models.Request(hooks={'args': hooks})\n+        \n+        # Assert hooks is a list of functions, not a list of lists\n+        assert all(callable(h) for h in r.hooks['args'])\n \n         s = requests.session()\n \n",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..6c4a2a9 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -388,7 +388,7 @@ repr_da = xr.DataArray(\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over %r \" % dim\n+    expected += \", grouped over %r\" % dim\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj[dim])))\n     if dim == \"x\":\n         expected += \"1, 2, 3, 4, 5.\"\n@@ -405,7 +405,7 @@ def test_groupby_repr(obj, dim):\n def test_groupby_repr_datetime(obj):\n     actual = repr(obj.groupby(\"t.month\"))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over 'month' \"\n+    expected += \", grouped over 'month'\"\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj.t.dt.month)))\n     expected += \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.\"\n     assert actual == expected\n",
  "pylint-dev__pylint-5859": "diff --git a/tests/checkers/unittest_misc.py b/tests/checkers/unittest_misc.py\nindex 460d485..d3fb447 100644\n--- a/tests/checkers/unittest_misc.py\n+++ b/tests/checkers/unittest_misc.py\n@@ -78,6 +78,16 @@ class TestFixme(CheckerTestCase):\n         with self.assertNoMessages():\n             self.checker.process_tokens(_tokenize_str(code))\n \n+    @set_config(notes=[\"???\"])\n+    def test_punctuation_codetag(self) -> None:\n+        code = \"\"\"a = 1\n+                # ???\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n+\n     @set_config(notes=[\"CODETAG\"])\n     def test_other_present_codetag(self) -> None:\n         code = \"\"\"a = 1\n@@ -119,4 +129,4 @@ class TestFixme(CheckerTestCase):\n         # Todoist API: Fetch all Tasks\n         \"\"\"\n         with self.assertNoMessages():\n-            self.checker.process_tokens(_tokenize_str(code))\n+            self.checker.process_tokens(_tokenize_str(code))\n",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..ac3e364 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -71,7 +71,14 @@ def test_unknown_option_name(capsys: CaptureFixture) -> None:\n     assert \"E0015: Unrecognized option found: unknown-option=yes\" in output.out\n \n \n-def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n+def test_usage_message_on_unrecognized_option(capsys: CaptureFixture) -> None:\n+    \"\"\"Ensure no traceback is printed for unrecognized options and a usage message is displayed.\"\"\"\n+    with pytest.raises(SystemExit):\n+        Run([\"-Q\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"usage: pylint\" in output.err\n+    assert \"E0015: Unrecognized option found: Q\" in output.out\n+    assert \"Traceback\" not in output.err\n     \"\"\"Check that we correctly raise a message on an unknown short option.\"\"\"\n     with pytest.raises(_UnrecognizedOptionError):\n         Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n",
  "pylint-dev__pylint-7080": "",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..2ad2cca 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -934,6 +934,19 @@ print(submodule1)\n             linter.check([\"submodule2.py\"])\n     assert not linter.stats.by_msg\n \n+def test_same_name_module_in_package(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for checking a package with a module having the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        # Create a package structure with a module of the same name\n+        create_files([\"package/module.py\", \"package/__init__.py\"])\n+        # Write a simple statement in module.py to avoid an empty file\n+        with open(\"package/module.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"print('Hello World')\")\n+        linter.check([\"package\"])\n+    # There should be no linting errors\n+    assert not linter.stats.by_msg\n+\n \n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n@@ -941,4 +954,17 @@ def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n+\n+def test_same_name_module_in_package(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for checking a package with a module having the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        # Create a package structure with a module of the same name\n+        create_files([\"package/module.py\", \"package/__init__.py\"])\n+        # Write a simple statement in module.py to avoid an empty file\n+        with open(\"package/module.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"print('Hello World')\")\n+        linter.check([\"package\"])\n+    # There should be no linting errors\n+    assert not linter.stats.by_msg\n",
  "pylint-dev__pylint-7993": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 6338072..1be2757 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n@@ -113,7 +114,36 @@ def test_template_option_non_existing(linter) -> None:\n     assert out_lines[2] == \"my_mod:2::()\"\n \n \n-def test_deprecation_set_output(recwarn):\n+from _pytest.recwarn import WarningsRecorder\n+\n+def test_template_custom_braces(linter: PyLinter) -> None:\n+    \"\"\"Test using custom braces in the message template.\"\"\"\n+    output = StringIO()\n+    linter.reporter.out = output\n+    linter.config.msg_template = '{{ \"Category\": \"{category}\" }}'\n+    linter.open()\n+    linter.set_current_module(\"my_mod\")\n+\n+    linter.add_message(\"C0301\", line=1, args=(1, 2))\n+    linter.add_message(\"line-too-long\", line=2, end_lineno=2, end_col_offset=4, args=(3, 4))\n+\n+    out_lines = output.getvalue().split(\"\\n\")\n+    assert out_lines[1] == '{ \"Category\": \"convention\" }'\n+    assert out_lines[2] == '{ \"Category\": \"convention\" }'\n+\n+def test_template_invalid_braces(linter: PyLinter, recwarn: WarningsRecorder) -> None:\n+    \"\"\"Test using unsupported format in the message template.\"\"\"\n+    output = StringIO()\n+    linter.reporter.out = output\n+    linter.config.msg_template = '{ \"Unrecognized\": \"{unrecognized}\" }'\n+    linter.open()\n+    linter.set_current_module(\"my_mod\")\n+\n+    linter.add_message(\"C0301\", line=1, args=(1, 2))\n+    out_lines = output.getvalue().split(\"\\n\")\n+\n+    assert \"Don't recognize the argument 'unrecognized'\" in [str(warning.message) for warning in recwarn]\n+    assert out_lines[1] == ' \"Unrecognized\": \"}\"'  # Should not process the unrecognized part\n     \"\"\"TODO remove in 3.0.\"\"\"\n     reporter = BaseReporter()\n     # noinspection PyDeprecation\n",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "",
  "pytest-dev__pytest-5227": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 1ebe9d0..01f354c 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -15,7 +15,7 @@ from _pytest.compat import dummy_context_manager\n from _pytest.config import create_terminal_writer\n from _pytest.pathlib import Path\n \n-DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n+DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n \n \n",
  "pytest-dev__pytest-5495": "diff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex b05f85c..246dd2d 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -301,6 +301,33 @@ def callequal(left, right, verbose=False):\n \n \n class TestAssert_reprcompare:\n+    def test_bytes_assertion(self):\n+        \"\"\"Test assertion message for byte string comparisons.\"\"\"\n+\n+        # Basic comparison where the expected failure should clearly indicate the byte difference.\n+        diff = callequal(b\"\", b\"42\")\n+        assert diff == [\n+            \"b'' == b'42'\",\n+            \"Right contains more items, first extra item: 52\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'42'\",\n+            \"?   ++\",\n+        ]\n+\n+    def test_bytes_assertion_single_char(self):\n+        \"\"\"Test assertion message for byte string comparisons with a single character.\"\"\"\n+\n+        # Single-character comparison with a clearer message indicating the difference.\n+        diff = callequal(b\"\", b\"1\")\n+        assert diff == [\n+            \"b'' == b'1'\",\n+            \"Right contains more items, first extra item: 49\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'1'\",\n+            \"?   +\",\n+        ]\n     def test_different_types(self):\n         assert callequal([0, 1], \"foo\") is None\n \n",
  "pytest-dev__pytest-5692": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3392814..37f0b0d 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1,8 +1,11 @@\n+\n import os\n from xml.dom import minidom\n \n import py\n \n+import platform\n+from datetime import datetime\n import pytest\n from _pytest.junitxml import LogXML\n from _pytest.reports import BaseReport\n@@ -139,7 +142,29 @@ class TestPython:\n         node = dom.find_first_by_tag(\"testsuite\")\n         node.assert_attr(name=\"pytest\", errors=1, failures=2, skipped=1, tests=5)\n \n-    def test_timing_function(self, testdir):\n+    def test_hostname_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+        \"\"\"\n+        )\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        node.assert_attr(hostname=platform.node())\n+\n+    def test_timestamp_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+        \"\"\"\n+        )\n+        start_time = datetime.now()\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        timestamp = datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S\")\n+        assert start_time <= timestamp < datetime.now()\n         testdir.makepyfile(\n             \"\"\"\n             import time, pytest\n",
  "pytest-dev__pytest-7168": "",
  "pytest-dev__pytest-7220": "diff --git a/testing/test_pytester.py b/testing/test_pytester.py\nindex 5ab5242..da1ff21 100644\n--- a/testing/test_pytester.py\n+++ b/testing/test_pytester.py\n@@ -71,6 +71,33 @@ def test_make_hook_recorder(testdir) -> None:\n     pytest.raises(ValueError, recorder.getfailures)\n \n \n+def test_failure_with_changed_cwd(testdir):\n+    \"\"\" \n+    Test failure lines should use absolute paths if cwd has changed since \n+    invocation to ensure the path is correct (#6428).\n+    \"\"\"\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import os\n+        import pytest\n+        \n+        @pytest.fixture\n+        def private_dir():\n+            out_dir = 'ddd'\n+            os.mkdir(out_dir)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+        \n+        def test_show_wrong_path(private_dir):\n+            assert False\n+        \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([str(p) + \":*: AssertionError\", \"*1 failed in *\"])\n+\n+\n def test_parseconfig(testdir) -> None:\n     config1 = testdir.parseconfig()\n     config2 = testdir.parseconfig()\n",
  "pytest-dev__pytest-7373": "diff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 309636c..14838b8 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -41,8 +41,34 @@ class TestMark:\n         with pytest.raises(AttributeError):\n             mark._some_name\n \n+def test_reevaluate_dynamic_expr_with_different_conditions(testdir):\n+    \"\"\"Checks if skipif condition is evaluated properly with differing module-level variables.\"\"\"\n+    py_file1 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr1=\"\"\"\n+        import pytest\n+\n+        skip = True\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_skip():\n+            assert False\n+    \"\"\"\n+    )\n+    py_file2 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr2=\"\"\"\n+        import pytest\n+\n+        skip = False\n \n-def test_marked_class_run_twice(testdir):\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_not_skip():\n+            assert True\n+    \"\"\"\n+    )\n+    file_name1 = os.path.basename(py_file1.strpath)\n+    file_name2 = os.path.basename(py_file2.strpath)\n+    reprec = testdir.inline_run(file_name1, file_name2)\n+    reprec.assertoutcome(passed=1, skipped=1)\n     \"\"\"Test fails file is run twice that contains marked class.\n     See issue#683.\n     \"\"\"\n",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..a8c90ad 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -250,7 +250,25 @@ class TestXFail:\n         assert not hasattr(callreport, \"wasxfail\")\n         assert \"xfail\" in callreport.keywords\n \n-    def test_xfail_not_report_default(self, testdir):\n+    @pytest.mark.parametrize(\n+        \"test_input, expected\",\n+        [\n+            ([\"-rs\"], [\"SKIPPED [1] test_sample.py:3: unconditional skip\", \"*1 skipped*\"]),\n+            ([\"-rs\", \"--runxfail\"], [\"SKIPPED [1] test_sample.py:3: unconditional skip\", \"*1 skipped*\"]),\n+        ],\n+    )\n+    def test_skip_location_reporting(self, testdir, test_input, expected):\n+        \"\"\"Test that skip location is correctly reported with and without --runxfail.\"\"\"\n+        testdir.makepyfile(\n+            test_sample=\"\"\"\n+            import pytest\n+            @pytest.mark.skip\n+            def test_skip_location():\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(*test_input)\n+        result.stdout.fnmatch_lines(expected)\n         p = testdir.makepyfile(\n             test_one=\"\"\"\n             import pytest\n",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..be8f139 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,4 +1,10 @@\n-import sys\n+\n+import pytest\n+from _pytest.pytester import Testdir\n+from _pytest.runner import runtestprotocol\n+from _pytest.skipping import evaluate_skip_marks\n+from _pytest.skipping import evaluate_xfail_marks\n+from _pytest.skipping import pytest_runtest_setup\n \n import pytest\n from _pytest.runner import runtestprotocol\n@@ -154,7 +160,30 @@ class TestEvaluation:\n \n \n class TestXFail:\n-    @pytest.mark.parametrize(\"strict\", [True, False])\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # New test case for dynamic xfail, failing case\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_dynamic_xfail_fail(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"dynamic xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir: Testdir) -> None:\n+        # New test case for dynamic xfail with strict, passing case\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_dynamic_xfail_passed_strict(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"dynamic xfail\", strict=True))\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n     def test_xfail_simple(self, testdir, strict):\n         item = testdir.getitem(\n             \"\"\"\n@@ -463,7 +492,30 @@ class TestXFail:\n         result.stdout.fnmatch_lines([\"*XFAIL*\", \"*unsupported feature*\"])\n         assert result.ret == 0\n \n-    @pytest.mark.parametrize(\"strict\", [True, False])\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # New test case for dynamic xfail, failing case\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_dynamic_xfail_fail(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"dynamic xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir: Testdir) -> None:\n+        # New test case for dynamic xfail with strict, passing case\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_dynamic_xfail_passed_strict(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"dynamic xfail\", strict=True))\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n     def test_strict_xfail(self, testdir, strict):\n         p = testdir.makepyfile(\n             \"\"\"\n@@ -490,7 +542,30 @@ class TestXFail:\n         assert result.ret == (1 if strict else 0)\n         assert testdir.tmpdir.join(\"foo_executed\").isfile()\n \n-    @pytest.mark.parametrize(\"strict\", [True, False])\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # New test case for dynamic xfail, failing case\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_dynamic_xfail_fail(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"dynamic xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir: Testdir) -> None:\n+        # New test case for dynamic xfail with strict, passing case\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_dynamic_xfail_passed_strict(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"dynamic xfail\", strict=True))\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n     def test_strict_xfail_condition(self, testdir, strict):\n         p = testdir.makepyfile(\n             \"\"\"\n@@ -506,7 +581,30 @@ class TestXFail:\n         result.stdout.fnmatch_lines([\"*1 passed*\"])\n         assert result.ret == 0\n \n-    @pytest.mark.parametrize(\"strict\", [True, False])\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # New test case for dynamic xfail, failing case\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_dynamic_xfail_fail(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"dynamic xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir: Testdir) -> None:\n+        # New test case for dynamic xfail with strict, passing case\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_dynamic_xfail_passed_strict(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"dynamic xfail\", strict=True))\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n     def test_xfail_condition_keyword(self, testdir, strict):\n         p = testdir.makepyfile(\n             \"\"\"\n",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..5e6f0bf 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,3 +1,4 @@\n+\n import os\n import stat\n import sys\n@@ -9,6 +10,9 @@ from typing import List\n import attr\n \n import pytest\n+from _pytest.monkeypatch import MonkeyPatch\n+from _pytest.tmpdir import TempPathFactory\n+from pathlib import Path\n from _pytest import pathlib\n from _pytest.config import Config\n from _pytest.pathlib import cleanup_numbered_dir\n",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..17a726b 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -574,7 +574,31 @@ def test_class_weights_cv():\n     assert_array_equal(reg.predict([[-.2, 2]]), np.array([-1]))\n \n \n-def test_ridgecv_store_cv_values():\n+def test_ridge_classifier_cv_store_cv_values():\n+    # Test RidgeClassifierCV's store_cv_values attribute.\n+    rng = np.random.RandomState(42)\n+\n+    x = np.array([[-1.0, -1.0], [-1.0, 0], [-0.8, -1.0], [1.0, 1.0], [1.0, 0.0]])\n+    y = np.array([1, 1, 1, -1, -1])\n+\n+    n_samples = x.shape[0]\n+    alphas = [1e-1, 1e0, 1e1]\n+    n_alphas = len(alphas)\n+\n+    r = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+\n+    # Test single target\n+    n_targets = 1\n+    r.fit(x, y)\n+    assert r.cv_values_.shape == (n_samples, n_targets, n_alphas)\n+\n+    # Test multiple targets\n+    y_multi = np.array([[1, 1, 1, -1, -1],\n+                   [1, -1, 1, -1, 1],\n+                   [-1, -1, 1, -1, -1]]).T\n+    n_targets = y_multi.shape[1]\n+    r.fit(x, y_multi)\n+    assert r.cv_values_.shape == (n_samples, n_targets, n_alphas)\n     # Test _RidgeCV's store_cv_values attribute.\n     rng = rng = np.random.RandomState(42)\n \n",
  "scikit-learn__scikit-learn-11281": "diff --git a/sklearn/mixture/tests/test_bayesian_mixture.py b/sklearn/mixture/tests/test_bayesian_mixture.py\nindex a9d82b7..b7a2a07 100644\n--- a/sklearn/mixture/tests/test_bayesian_mixture.py\n+++ b/sklearn/mixture/tests/test_bayesian_mixture.py\n@@ -12,6 +12,10 @@ from sklearn.mixture.bayesian_mixture import _log_dirichlet_norm\n from sklearn.mixture.bayesian_mixture import _log_wishart_norm\n \n from sklearn.mixture import BayesianGaussianMixture\n+from sklearn.utils.testing import assert_array_equal\n+from sklearn.metrics.cluster import adjusted_rand_score\n+from sklearn.exceptions import NotFittedError, ConvergenceWarning\n+import numpy as np\n \n from sklearn.mixture.tests.test_gaussian_mixture import RandomData\n from sklearn.exceptions import ConvergenceWarning\n",
  "scikit-learn__scikit-learn-12471": "diff --git a/sklearn/preprocessing/tests/test_encoders.py b/sklearn/preprocessing/tests/test_encoders.py\nindex 3f9b211..1a6e53e 100644\n--- a/sklearn/preprocessing/tests/test_encoders.py\n+++ b/sklearn/preprocessing/tests/test_encoders.py\n@@ -273,7 +273,48 @@ def test_one_hot_encoder_no_categorical_features():\n     assert enc.categories_ == []\n \n \n-@pytest.mark.parametrize(\"output_dtype\", [np.int32, np.float32, np.float64])\n+from sklearn.preprocessing import OneHotEncoder\n+import numpy as np\n+import pytest\n+from numpy.testing import assert_array_equal\n+\n+def test_one_hot_encoder_handle_unknown_strings():\n+    X = np.array(['11111111', '22', '333', '4444']).reshape((-1, 1))\n+    X2 = np.array(['55555', '22']).reshape((-1, 1))\n+    # Non Regression test for the issue #12470\n+    # Test the ignore option, when categories are numpy string dtype\n+    # particularly when the known category strings are larger\n+    # than the unknown category strings\n+    oh = OneHotEncoder(handle_unknown='ignore')\n+    oh.fit(X)\n+    X2_passed = X2.copy()\n+    assert_array_equal(\n+        oh.transform(X2_passed).toarray(),\n+        np.array([[0.,  0.,  0.,  0.], [0.,  1.,  0.,  0.]]))\n+    # ensure transformed data was not modified in place\n+    assert_array_equal(X2, X2_passed)\n+\n+def test_one_hot_encoder_ignore_unknowns_varied_lengths():\n+    long_str = 'a' * 500\n+    X_train = np.array([long_str, 'short', 'medium']).reshape((-1, 1))\n+    X_test = np.array(['shorter', 'short']).reshape((-1, 1))\n+    ohe = OneHotEncoder(handle_unknown='ignore')\n+    ohe.fit(X_train)\n+    transformed = ohe.transform(X_test).toarray()\n+    expected = np.array([[0., 0., 0.], [0., 1., 0.]])\n+    assert_array_equal(transformed, expected)\n+\n+@pytest.mark.parametrize(\"unknown_value\", ['unknown', 'u'])\n+def test_one_hot_encoder_ignore_specific_unknowns(unknown_value):\n+    X_train = np.array(['alpha', 'beta', 'gamma']).reshape((-1, 1))\n+    X_test = np.array([unknown_value, 'beta']).reshape((-1, 1))\n+    ohe = OneHotEncoder(handle_unknown='ignore')\n+    ohe.fit(X_train)\n+    transformed = ohe.transform(X_test).toarray()\n+    expected = np.array([[0., 0., 0.], [0., 1., 0.]])\n+    assert_array_equal(transformed, expected)\n+\n+@pytest.mark.parametrize(\"input_dtype\", [np.int32, np.float32, np.float64])\n @pytest.mark.parametrize(\"input_dtype\", [np.int32, np.float32, np.float64])\n def test_one_hot_encoder_dtype(input_dtype, output_dtype):\n     X = np.asarray([[0, 1]], dtype=input_dtype).T\n",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex f8e4d54..e430310 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -598,6 +598,14 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n \n+def test_gaussian_mixture_fit_predict_n_init():\n+    # Check that fit_predict is equivalent to fit.predict, when n_init > 1\n+    X = np.random.RandomState(0).randn(1000, 5)\n+    gm = GaussianMixture(n_components=5, n_init=5, random_state=0)\n+    y_pred1 = gm.fit_predict(X)\n+    y_pred2 = gm.predict(X)\n+    assert_array_equal(y_pred1, y_pred2)\n+\n def test_gaussian_mixture_fit():\n     # recover the ground truth\n     rng = np.random.RandomState(0)\n",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..2c4d2ba 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,10 +1,11 @@\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n \n from sklearn.utils.testing import (assert_array_almost_equal, assert_less,\n                                    assert_equal, assert_not_equal,\n-                                   assert_raises)\n+                                   assert_raises, assert_allclose)\n \n from sklearn.decomposition import PCA, KernelPCA\n from sklearn.datasets import make_circles\n",
  "scikit-learn__scikit-learn-13439": "",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..74dceab 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -7,6 +8,9 @@ Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n # License: BSD 3 clause\n \n import pytest\n+import numpy as np\n+from sklearn.ensemble import IsolationForest\n+from sklearn.utils import check_random_state\n \n import numpy as np\n \n",
  "scikit-learn__scikit-learn-13497": "",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..4122810 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,9 +1,12 @@\n+\n import re\n from pprint import PrettyPrinter\n \n import numpy as np\n \n from sklearn.utils._pprint import _EstimatorPrettyPrinter\n+from sklearn.linear_model import LogisticRegressionCV\n+import numpy as np\n from sklearn.pipeline import make_pipeline\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.feature_selection import SelectKBest, chi2\n@@ -215,7 +218,18 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n     set_config(print_changed_only=False)\n \n \n-def test_pipeline():\n+def test_logistic_regression_cv_repr_with_numpy_array():\n+    # Test LogisticRegressionCV with numpy array when print_changed_only=True\n+    set_config(print_changed_only=True)\n+    \n+    # Instantiate LogisticRegressionCV with numpy array\n+    estimator = LogisticRegressionCV(Cs=np.array([0.1, 1]))\n+    \n+    # Check if repr executes without raising an error\n+    repr_str = repr(estimator)\n+    assert isinstance(repr_str, str)  # Ensure it returns a string representation\n+    \n+    set_config(print_changed_only=False)\n     # Render a pipeline object\n     pipeline = make_pipeline(StandardScaler(), LogisticRegression(C=999))\n     expected = \"\"\"\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..47353d8 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n@@ -19,7 +20,8 @@ from sklearn.datasets import make_multilabel_classification\n from sklearn.svm import SVC\n from sklearn.multiclass import OneVsRestClassifier\n from sklearn.neighbors import KNeighborsClassifier\n-from sklearn.base import BaseEstimator, ClassifierMixin\n+from sklearn.linear_model import LinearRegression\n+from sklearn.ensemble import RandomForestRegressor\n from sklearn.dummy import DummyRegressor\n \n \n@@ -506,4 +508,32 @@ def test_transform():\n     assert_array_almost_equal(\n             eclf3.transform(X).swapaxes(0, 1).reshape((4, 6)),\n             eclf2.transform(X)\n-    )\n+    )\n+\n+\n+@pytest.mark.filterwarnings('ignore: Default solver will be changed')  # Suppress solver warning\n+@pytest.mark.filterwarnings('ignore: Default multi_class will')  # Suppress multi-class warning\n+def test_none_estimator_with_different_weights():\n+    # Preparation of data\n+    X, y = datasets.load_iris(return_X_y=True)\n+    \n+    # Test VotingClassifier\n+    clf = VotingClassifier(\n+        estimators=[('lr', LogisticRegression()), ('rf', RandomForestClassifier(n_estimators=10))]\n+    )\n+    clf.fit(X, y, sample_weight=np.ones(y.shape))\n+    clf.set_params(lr=None)\n+    clf.fit(X, y, sample_weight=np.ones(y.shape))\n+    y_pred_clf = clf.predict(X)\n+    assert y_pred_clf.shape == y.shape\n+\n+    # Test VotingRegressor\n+    X_r, y_r = datasets.load_boston(return_X_y=True)\n+    reg = VotingRegressor(\n+        estimators=[('lr', LinearRegression()), ('rf', RandomForestRegressor(n_estimators=10))]\n+    )\n+    reg.fit(X_r, y_r, sample_weight=np.ones(y_r.shape))\n+    reg.set_params(lr=None)\n+    reg.fit(X_r, y_r, sample_weight=np.ones(y_r.shape))\n+    y_pred_reg = reg.predict(X_r)\n+    assert y_pred_reg.shape == y_r.shape\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "diff --git a/sklearn/neighbors/tests/test_nca.py b/sklearn/neighbors/tests/test_nca.py\nindex 3963eca..884afae 100644\n--- a/sklearn/neighbors/tests/test_nca.py\n+++ b/sklearn/neighbors/tests/test_nca.py\n@@ -511,8 +511,27 @@ def test_expected_transformation_shape():\n     nca.fit(X, y)\n     assert_equal(transformation_storer.transformation.size, X.shape[1]**2)\n \n+@pytest.mark.parametrize('param, value', [\n+    ('tol', 1),  # should be a float\n+    ('n_components', np.int64(5)),  # should be an int\n+])\n+def test_gridsearchcv_param_validation(param, value):\n+    # Test to ensure GridSearchCV does not raise a TypeError for compatible numpy\n+    # integer and float types when checking NCA parameters.\n+    from sklearn.pipeline import Pipeline\n+    from sklearn.model_selection import GridSearchCV\n+    from sklearn.neighbors import KNeighborsClassifier\n+\n+    X = np.random.random_sample((100, 10))\n+    y = np.random.randint(2, size=100)\n \n-def test_convergence_warning():\n+    nca = NeighborhoodComponentsAnalysis()\n+    knn = KNeighborsClassifier()\n+    pipe = Pipeline([('nca', nca), ('knn', knn)])\n+\n+    params = {f'nca__{param}': [value]}\n+    gs = GridSearchCV(estimator=pipe, param_grid=params)\n+    gs.fit(X, y)\n     nca = NeighborhoodComponentsAnalysis(max_iter=2, verbose=1)\n     cls_name = nca.__class__.__name__\n     assert_warns_message(ConvergenceWarning,\n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..9e731aa 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -680,6 +680,35 @@ def test_unicode_kernel():\n                                 random_seed=0)\n \n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for ZeroDivisionError when support_vectors_ is empty\n+    from scipy import sparse\n+    import numpy as np\n+    from sklearn import svm\n+\n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+\n+    assert not model.support_vectors_.data.size, \"support_vectors_ should be empty when no support vectors are found.\"\n+    assert not model.dual_coef_.data.size, \"dual_coef_ should be empty when there are no dual coefficients.\"\n+    \n+    # Test with a different configuration\n+    model = svm.SVR(C=316.227766017, cache_size=200, coef0=0.0, degree=3, epsilon=0.1,\n+                    gamma=1.0, kernel='linear', max_iter=15000,\n+                    shrinking=True, tol=0.001, verbose=False)\n+    # Re-using the same sparse inputs\n+    model.fit(X_train, y_train)\n+\n+    assert not model.support_vectors_.data.size, \"support_vectors_ should be empty when no support vectors are found in the custom configuration.\"\n+    assert not model.dual_coef_.data.size, \"dual_coef_ should be empty in custom configuration when there are no dual coefficients.\"\n+\n+\n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n     sparse_gram = sparse.csr_matrix([[1, 0], [0, 1]])\n",
  "scikit-learn__scikit-learn-14983": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex dd52c66..e841ff4 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -972,6 +972,9 @@ def test_leave_one_p_group_out_error_on_fewer_number_of_groups():\n                          LeavePGroupsOut(n_groups=3).split(X, y, groups))\n \n \n+import pytest\n+from sklearn.model_selection import RepeatedKFold, RepeatedStratifiedKFold\n+\n @ignore_warnings\n def test_repeated_cv_value_errors():\n     # n_repeats is not integer or <= 0\n@@ -980,6 +983,29 @@ def test_repeated_cv_value_errors():\n         assert_raises(ValueError, cv, n_repeats=1.5)\n \n \n+@pytest.mark.parametrize(\n+    \"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold]\n+)\n+def test_repeated_cv_repr(RepeatedCV):\n+    # Verify if __repr__ includes n_splits, n_repeats, and random_state\n+    n_splits, n_repeats = 2, 6\n+    repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats)\n+    expected_repr = (\n+        f\"{repeated_cv.__class__.__name__}(n_repeats=6, n_splits=2, random_state=None)\"\n+    )\n+    assert expected_repr == repr(repeated_cv)\n+\n+@pytest.mark.parametrize(\n+    \"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold]\n+)\n+def test_repeated_cv_repr_defaults(RepeatedCV):\n+    # Verify default representation values\n+    repeated_cv = RepeatedCV()\n+    expected_repr = (\n+        f\"{repeated_cv.__class__.__name__}(n_splits=5, n_repeats=10, random_state=None)\"\n+    )\n+    assert expected_repr == repr(repeated_cv)\n+\n def test_repeated_kfold_determinstic_split():\n     X = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n     random_state = 258173307\n",
  "scikit-learn__scikit-learn-15512": "",
  "scikit-learn__scikit-learn-15535": "",
  "scikit-learn__scikit-learn-25500": "diff --git a/sklearn/tests/test_isotonic.py b/sklearn/tests/test_isotonic.py\nindex 5021282..1a0e378 100644\n--- a/sklearn/tests/test_isotonic.py\n+++ b/sklearn/tests/test_isotonic.py\n@@ -1,5 +1,10 @@\n+\n import warnings\n import numpy as np\n+import pytest\n+from sklearn.calibration import CalibratedClassifierCV\n+from sklearn.linear_model import SGDClassifier\n+from sklearn import set_config\n import pickle\n import copy\n \n@@ -668,7 +673,19 @@ def test_isotonic_regression_sample_weight_not_overwritten():\n \n \n @pytest.mark.parametrize(\"shape\", [\"1d\", \"2d\"])\n-def test_get_feature_names_out(shape):\n+def test_calibrated_classifier_cv_with_isotonic_and_pandas():\n+    \"\"\"Test CalibratedClassifierCV with isotonic regression and transform_output='pandas'.\"\"\"\n+    set_config(transform_output=\"pandas\")\n+    X = np.arange(90).reshape(30, -1)\n+    y = np.arange(30) % 2\n+    model = CalibratedClassifierCV(SGDClassifier(), method='isotonic')\n+    model.fit(X, y)\n+    try:\n+        predictions = model.predict(X)\n+        assert predictions is not None\n+        print(\"CalibratedClassifierCV with isotonic regression and pandas output passed.\")\n+    except Exception as e:\n+        pytest.fail(f\"CalibratedClassifierCV isotonic regression failed with transform_output='pandas': {e}\")\n     \"\"\"Check `get_feature_names_out` for `IsotonicRegression`.\"\"\"\n     X = np.arange(10)\n     if shape == \"2d\":\n",
  "scikit-learn__scikit-learn-25570": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex 23e3b97..2a876fa 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -2121,6 +2121,35 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n     with pytest.raises(AttributeError, match=\"not provide get_feature_names_out\"):\n         ct.get_feature_names_out()\n \n+@pytest.mark.parametrize(\n+    \"empty_selection\",\n+    [[], np.array([False, False, False, False]), [False, False, False, False]],\n+    ids=[\"empty_list\", \"np_bool_array\", \"bool_list\"],\n+)\n+def test_empty_transformer_selection_with_pandas_output(empty_selection):\n+    \"\"\"Test ColumnTransformer with empty transformer selection (no features) and pandas output.\"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+\n+    X = pd.DataFrame(\n+        data=[[1.0, 2.0, 3.0, 4.0], [4, 2, 2, 5]],\n+        columns=[\"a\", \"b\", \"c\", \"d\"]\n+    )\n+    y = np.array([0, 1])\n+    ct = ColumnTransformer(\n+        transformers=[\n+            (\"categorical\", \"passthrough\", empty_selection),\n+            (\"numerical\", Pipeline([\n+                (\"scaler\", StandardScaler()), \n+                (\"imputer\", SimpleImputer(strategy=\"median\"))\n+            ]), [\"a\", \"b\", \"c\"])\n+        ],\n+        remainder='drop'\n+    ).set_output(transform=\"pandas\")\n+\n+    ct.fit(X, y)\n+    X_out = ct.transform(X)\n+    assert_array_equal(X_out.columns, [\"numerical__a\", \"numerical__b\", \"numerical__c\"])\n+\n     # The feature names are prefixed because verbose_feature_names_out=True is default\n     ct.set_output(transform=\"pandas\")\n     X_trans_df0 = ct.fit_transform(X_df)\n@@ -2128,4 +2157,4 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n \n     ct.set_params(verbose_feature_names_out=False)\n     X_trans_df1 = ct.fit_transform(X_df)\n-    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n+    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n",
  "sphinx-doc__sphinx-10325": "diff --git a/tests/test_ext_autodoc_automodule.py b/tests/test_ext_autodoc_automodule.py\nindex 787cd0c..c32e11b 100644\n--- a/tests/test_ext_autodoc_automodule.py\n+++ b/tests/test_ext_autodoc_automodule.py\n@@ -113,6 +113,11 @@ def test_automodule_special_members(app):\n     ]\n \n \n+import sys\n+import pytest\n+from sphinx.pycode import ModuleAnalyzer\n+from . import do_autodoc\n+\n @pytest.mark.sphinx('html', testroot='ext-autodoc',\n                     confoverrides={'autodoc_mock_imports': ['missing_module',\n                                                             'missing_package1',\n@@ -125,4 +130,225 @@ def test_subclass_of_mocked_object(app):\n \n     options = {'members': None}\n     actual = do_autodoc(app, 'module', 'target.need_mocks', options)\n-    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n",
  "sphinx-doc__sphinx-7975": "",
  "sphinx-doc__sphinx-8435": "diff --git a/tests/roots/test-ext-autodoc/target/annotations.py b/tests/roots/test-ext-autodoc/target/annotations.py\nindex 56eb16b..65b6f56 100644\n--- a/tests/roots/test-ext-autodoc/target/annotations.py\n+++ b/tests/roots/test-ext-autodoc/target/annotations.py\n@@ -1,8 +1,21 @@\n+\n from __future__ import annotations\n \n from typing import overload\n \n-myint = int\n+String = str\n+\n+#: Test docstring for module-level variable\n+var: String\n+\n+\n+class MyString:\n+    \"Test class docstring\"\n+\n+    #: Test docstring for class attribute\n+    var: String\n+\n+myint = int  # Preserve this existing variable alias.\n \n \n def sum(x: myint, y: myint) -> myint:\n@@ -22,4 +35,4 @@ def mult(x: float, y: float) -> float:\n \n def mult(x, y):\n     \"\"\"docstring\"\"\"\n-    return x, y\n+    return x, y\n",
  "sphinx-doc__sphinx-8506": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 08bd595..7e83918 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -91,6 +91,35 @@ def test_get_full_qualified_name():\n     assert domain.get_full_qualified_name(node) == 'ls.-l'\n \n \n+from sphinx import nodes\n+from sphinx.testing.util import SphinxTestAppTestCase, with_app\n+from sphinx.util.docutils import new_document\n+from sphinx.domains.std import StandardDomain\n+from docutils.parsers.rst import directives\n+from sphinx.testing.util import assert_node\n+import sphinx.domains\n+import re\n+\n+def test_cmd_option_with_optional_value(app):\n+    text = \".. option:: -j[=N]\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, ([sphinx.domains.Index, \n+                           [sphinx.domains.objtypes.Description, ([sphinx.domains.objtypes.DescriptionSignature, ([sphinx.domains.objtypes.DescriptionName, '-j'],\n+                                                                                                               [sphinx.domains.objtypes.DescriptionAddname, '[=N]'])], \n+                                                                  [sphinx.domains.objtypes.DescriptionContent, ()])]]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('-j', '-j', 'cmdoption', 'index', 'cmdoption-j', 1) in objects\n+\n+def test_cmd_option_starting_with_bracket(app):\n+    text = \".. option:: [enable=]PATTERN\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, ([sphinx.domains.Index, \n+                           [sphinx.domains.objtypes.Description, ([sphinx.domains.objtypes.DescriptionSignature, ([sphinx.domains.objtypes.DescriptionName, '[enable'],\n+                                                                                                               [sphinx.domains.objtypes.DescriptionAddname, '=]PATTERN'])], \n+                                                                  [sphinx.domains.objtypes.DescriptionContent, ()])]]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('[enable', '[enable', 'cmdoption', 'index', 'cmdoption-arg-enable', 1) in objects\n+\n def test_glossary(app):\n     text = (\".. glossary::\\n\"\n             \"\\n\"\n",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..a9c4de7 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -21,6 +21,7 @@ from sphinx.ext.autodoc import ALL, ModuleLevelDocumenter, Options\n from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n from sphinx.testing.util import SphinxTestApp, Struct  # NOQA\n from sphinx.util.docutils import LoggingReporter\n+from .test_ext_autodoc import do_autodoc\n \n try:\n     # Enable pyximport to test cython module\n@@ -29,8 +30,43 @@ try:\n except ImportError:\n     pyximport = None\n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_resolved_empty_all(app):\n+    \"\"\"\n+    Test to ensure that when __all__ is empty, no functions are shown.\n+    This replicates the resolved issue in the autodoc extension.\n+    \"\"\"\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.resolved_empty_all', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.resolved_empty_all',\n+        '',\n+        'docsting of empty_all module.',\n+        '',  # No entries listed after module description.\n+    ]\n+\n \n-def do_autodoc(app, objtype, name, options=None):\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_non_empty_all(app):\n+    \"\"\"\n+    Test to verify behavior when __all__ has elements.\n+    Only the elements within __all__ should be shown.\n+    \"\"\"\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.non_empty_all', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.non_empty_all',\n+        '',\n+        'docstring of non_empty_all module.',\n+        '',\n+        '.. py:function:: foo',\n+        '   :module: target.non_empty_all',\n+        '',\n+        '   docstring',\n+        '',\n+    ]\n     if options is None:\n         options = {}\n     app.env.temp_data.setdefault('docname', 'index')  # set dummy docname\n",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..d262627 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -15,6 +16,7 @@ from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tup\n \n import pytest\n \n+from struct import Struct\n from sphinx.util.typing import restify, stringify\n \n \n@@ -115,7 +117,8 @@ def test_restify_type_ForwardRef():\n     assert restify(ForwardRef(\"myint\")) == \":class:`myint`\"\n \n \n-def test_restify_broken_type_hints():\n+def test_restify_struct_struct():\n+    assert restify(Struct) == \":class:`struct.Struct`\"\n     assert restify(BrokenType) == ':class:`tests.test_util_typing.BrokenType`'\n \n \n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..7788f4d 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1455,10 +1455,32 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n         expected = \"\"\"\\\n :param param1:\n :type param1: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+    def test_other_parameters_formatting(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param1 : int\n+    Description of param1.\n+\n+\"\"\"\n+\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param1** (*int*) -- Description of param1.\n \"\"\"\n         self.assertEqual(expected, actual)\n \n-    def test_multiple_parameters(self):\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters:\n+:param param1: Description of param1.\n+:type param1: int\n+\"\"\"\n+        self.assertEqual(expected, actual)\n         docstring = \"\"\"\\\n Parameters\n ----------\n",
  "sphinx-doc__sphinx-8721": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\nindex d4fba47..671a047 100644\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -48,8 +48,15 @@ def test_viewcode(app, status, warning):\n             '<span>    this is Class1</span>\\n'\n             '<span>    &quot;&quot;&quot;</span></div>\\n') in result\n \n-\n-@pytest.mark.sphinx(testroot='ext-viewcode', tags=['test_linkcode'])\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode')\n+def test_viewcode_epub_default_no_overrides(app, status, warning):\n+    \"\"\"\n+    This test checks the default behavior without any configuration overrides.\n+    The `viewcode_enable_epub` should default to False, ensuring that no\n+    XHTML module pages for source code are generated for EPUB output.\n+    \"\"\"\n+    app.builder.build_all()\n+    assert not (app.outdir / '_modules/spam/mod1.xhtml').exists()\n def test_linkcode(app, status, warning):\n     app.builder.build(['objects'])\n \n",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..5a8a6b0 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -354,8 +354,16 @@ def test_args():\n     # but this is ok because cycles imply that only those listed moved\n     assert Permutation(4, 5) == Permutation([0, 1, 2, 3, 5, 4])\n \n-\n-def test_Cycle():\n+def test_Permutation_non_disjoint_cycles():\n+    # Non-disjoint cycles should be applied in left-to-right order\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n+    assert Permutation([[0, 2], [0, 1]]) == Permutation([0, 2, 1])\n+    assert Permutation([[0, 1], [1, 2]]) == Permutation([1, 2, 0])\n+    assert Permutation([[1, 2], [0, 1]]) == Permutation([1, 0, 2])\n+    assert Permutation([[0, 1, 2], [0, 2]]) == Permutation([0, 1, 2])\n+    # Ensure different order cycles that result in identity permutation\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([])\n+    assert Permutation([[0, 1], [1, 0]]) == Permutation([])\n     assert str(Cycle()) == '()'\n     assert Cycle(Cycle(1,2)) == Cycle(1, 2)\n     assert Cycle(1,2).copy() == Cycle(1,2)\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..89495d4 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -1,3 +1,4 @@\n+\n from sympy import Abs, S, Symbol, I, Rational, PurePoly\n from sympy.matrices import Matrix, SparseMatrix, eye, zeros, ShapeError\n from sympy.utilities.pytest import raises\n@@ -448,6 +449,15 @@ def test_sparse_matrix():\n     assert A.col_list() == [(0, 0, 18), (4, 2, 19), (6, 2, 12), (1, 4, 18), (2, 7, 16), (5, 7, 16), (9, 7, 18), (0, 9, 12), (3, 9, 12)]\n     assert SparseMatrix.eye(2).nnz() == 2\n \n+def test_zdmatrix_stack_operations():\n+    # Test for zero-dimension matrices: hstack and vstack\n+    # Test hstack with zero row and variable columns\n+    sparse_matrices = [SparseMatrix.zeros(0, n) for n in range(4)]\n+    assert SparseMatrix.hstack(*sparse_matrices) == Matrix(0, 6, [])\n+\n+    # Test vstack with zero column and variable rows\n+    sparse_matrices = [SparseMatrix.zeros(n, 0) for n in range(4)]\n+    assert SparseMatrix.vstack(*sparse_matrices) == Matrix(6, 0, [])\n \n def test_transpose():\n     assert SparseMatrix(((1, 2), (3, 4))).transpose() == \\\n",
  "sympy__sympy-13471": "diff --git a/sympy/utilities/tests/test_pickling.py b/sympy/utilities/tests/test_pickling.py\nindex 52dcc20..ca56445 100644\n--- a/sympy/utilities/tests/test_pickling.py\n+++ b/sympy/utilities/tests/test_pickling.py\n@@ -100,7 +100,49 @@ def test_core_symbol():\n         check(c)\n \n \n-def test_core_numbers():\n+import sys\n+import subprocess\n+\n+def test_pickle_float_cross_version():\n+    \"\"\"\n+    Test pickling of SymPy expressions containing floats across Python versions.\n+    This simulates the issue of pickling in Python 2 and unpickling in Python 3.\n+    \"\"\"\n+    # This test requires a system with both Python 2 and Python 3 available.\n+    python2_code = \"\"\"\n+import pickle\n+import sympy\n+x = sympy.symbols(\"x\")\n+expr = x + 1.0\n+print(pickle.dumps(expr, protocol=2))\n+\"\"\"\n+\n+    python3_code = \"\"\"\n+import pickle\n+import sys\n+expr = pickle.loads(sys.stdin.buffer.read())\n+print(expr)\n+\"\"\"\n+\n+    try:\n+        # Run the Python 2 code and capture the pickle output\n+        result = subprocess.run(\n+            ['python2', '-c', python2_code.strip()],\n+            capture_output=True,\n+            check=True\n+        )\n+        # Use the pickle output as input to Python 3 code\n+        result3 = subprocess.run(\n+            ['python3', '-c', python3_code.strip()],\n+            input=result.stdout,\n+            capture_output=True,\n+            check=True\n+        )\n+        # Check if the output is correct\n+        assert result3.stdout.strip() == b'Symbol(\"x\") + 1.0'\n+    except subprocess.CalledProcessError as e:\n+        # If there's an error, print it out to understand what went wrong\n+        print(\"Error with subprocess:\", e)\n     for c in (Integer(2), Rational(2, 3), Float(\"1.2\")):\n         check(c)\n \n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..31928ce 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -267,6 +267,20 @@ def test_coth():\n \n     assert coth(x*I) == -cot(x)*I\n \n+def test_coth_log_tan_issue():\n+    from sympy import Symbol, coth, log, tan\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+    # Original cases that should pass without issue\n+    assert coth(log(tan(2))) == coth(log(-tan(2)))\n+    assert coth(1 + I*pi/2) == tanh(1)\n+    # Additional test cases for reported errors at certain integral values\n+    for val in [2, 3, 5, 6, 8, 9, 11, 12, 13, 15, 18]:\n+        try:\n+            e.subs(x, val)\n+        except NameError as ex:\n+            assert False, f\"NameError occurred for x = {val}: {ex}\"\n+\n     assert coth(k*pi*I) == -cot(k*pi)*I\n     assert coth(17*k*pi*I) == -cot(17*k*pi)*I\n \n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..6c58d94 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -201,7 +201,20 @@ def test_col_insert():\n         l.insert(i, 4)\n         assert flatten(zeros_Shaping(3).col_insert(i, c4).row(0).tolist()) == l\n \n-def test_extract():\n+def test_issue_13643_col_insert():\n+    from sympy import Matrix, eye, ones\n+    M = eye(6)\n+    V = 2 * ones(6, 2)\n+    result = M.col_insert(3, V)\n+    expected = Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    assert result == expected\n     m = ShapingOnlyMatrix(4, 3, lambda i, j: i*3 + j)\n     assert m.extract([0, 1, 3], [0, 1]) == Matrix(3, 2, [0, 1, 3, 4, 9, 10])\n     assert m.extract([0, 3], [0, 0, 2]) == Matrix(2, 3, [0, 0, 2, 9, 9, 11])\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..22488bd 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -616,7 +616,57 @@ def test_latex_Range():\n     assert latex(Range(-2, -oo, -1)) == r'\\left\\{-2, -3, \\ldots, -\\infty\\right\\}'\n \n \n-def test_latex_sequences():\n+import sympy as sp\n+from sympy import latex, oo\n+from sympy.series.sequences import SeqFormula, SeqPer, SeqAdd, SeqMul\n+\n+def test_latex_sequences_correct():\n+    k, m, n = sp.symbols('k m n', integer=True)\n+    \n+    s1 = SeqFormula(n**2, (n, 0, oo))\n+    s2 = SeqPer((1, 2))\n+\n+    latex_str = r'[0, 1, 4, 9, \\ldots]'\n+    assert latex(s1) == latex_str\n+\n+    latex_str = r'[1, 2, 1, 2, \\ldots]'\n+    assert latex(s2) == latex_str\n+\n+    s3 = SeqFormula(n**2, (n, 0, 2))\n+    s4 = SeqPer((1, 2), (0, 2))\n+\n+    latex_str = r'[0, 1, 4]'\n+    assert latex(s3) == latex_str\n+\n+    latex_str = r'[1, 2, 1]'\n+    assert latex(s4) == latex_str\n+\n+    s5 = SeqFormula(n**2, (n, -oo, 0))\n+    s6 = SeqPer((1, 2), (-oo, 0))\n+\n+    latex_str = r'[\\ldots, 9, 4, 1, 0]'\n+    assert latex(s5) == latex_str\n+\n+    latex_str = r'[\\ldots, 2, 1, 2, 1]'\n+    assert latex(s6) == latex_str\n+\n+    latex_str = r'[1, 3, 5, 11, \\ldots]'\n+    assert latex(SeqAdd(s1, s2)) == latex_str\n+\n+    latex_str = r'[1, 3, 5]'\n+    assert latex(SeqAdd(s3, s4)) == latex_str\n+\n+    latex_str = r'[\\ldots, 11, 5, 3, 1]'\n+    assert latex(SeqAdd(s5, s6)) == latex_str\n+\n+    latex_str = r'[0, 2, 4, 18, \\ldots]'\n+    assert latex(SeqMul(s1, s2)) == latex_str\n+\n+    latex_str = r'[0, 2, 4]'\n+    assert latex(SeqMul(s3, s4)) == latex_str\n+\n+    latex_str = r'[\\ldots, 18, 4, 2, 0]'\n+    assert latex(SeqMul(s5, s6)) == latex_str\n     s1 = SeqFormula(a**2, (0, oo))\n     s2 = SeqPer((1, 2))\n \n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..73e6a39 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +7,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n@@ -186,7 +187,21 @@ def test_Domain_preprocess():\n     assert Domain.preprocess('ZZ[x,y]') == ZZ[x, y]\n     assert Domain.preprocess('QQ[x,y]') == QQ[x, y]\n \n-    raises(OptionError, lambda: Domain.preprocess('Z()'))\n+    assert Domain.preprocess('R[x]') == RR[x]\n+    assert Domain.preprocess('C[x]') == CC[x]\n+    assert Domain.preprocess('RR[x]') == RR[x]\n+    assert Domain.preprocess('CC[x]') == CC[x]\n+    assert Domain.preprocess('R[x,y]') == RR[x, y]\n+    assert Domain.preprocess('C[x,y]') == CC[x, y]\n+    assert Domain.preprocess('RR[x,y]') == RR[x, y]\n+    assert Domain.preprocess('CC[x,y]') == CC[x, y]\n+\n+    raises(OptionError, lambda: Domain.preprocess('RR()'))\n+    raises(OptionError, lambda: Domain.preprocess('C()'))\n+\n+    # Test for specific issue with Poly involving 'RR[y,z]'\n+    assert Domain.preprocess('RR[y,z]') == RR[y, z]\n+    assert Domain.preprocess('CC[y,z]') == CC[y, z]\n \n     assert Domain.preprocess('Z(x)') == ZZ.frac_field(x)\n     assert Domain.preprocess('Q(x)') == QQ.frac_field(x)\n",
  "sympy__sympy-14774": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 48a5cf2..4232e6e 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Add, Abs, Chi, Ci, CosineTransform, Dict, Ei, Eq, FallingFactorial,\n     FiniteSet, Float, FourierTransform, Function, IndexedBase, Integral,\n@@ -6,7 +7,7 @@ from sympy import (\n     Lambda, LaplaceTransform, Limit, Matrix, Max, MellinTransform, Min, Mul,\n     Order, Piecewise, Poly, ring, field, ZZ, Pow, Product, Range, Rational,\n     RisingFactorial, rootof, RootSum, S, Shi, Si, SineTransform, Subs,\n-    Sum, Symbol, ImageSet, Tuple, Union, Ynm, Znm, arg, asin, Mod,\n+    Sum, Symbol, ImageSet, Tuple, Union, Ynm, Znm, arg, asin, acsc, asec, Mod,\n     assoc_laguerre, assoc_legendre, beta, binomial, catalan, ceiling, Complement,\n     chebyshevt, chebyshevu, conjugate, cot, coth, diff, dirichlet_eta, euler,\n     exp, expint, factorial, factorial2, floor, gamma, gegenbauer, hermite,\n@@ -298,6 +299,18 @@ def test_latex_functions():\n         r\"\\sin {x^{2}}\"\n \n     assert latex(asin(x)**2) == r\"\\operatorname{asin}^{2}{\\left (x \\right )}\"\n+    assert latex(acsc(x), inv_trig_style=\"full\") == \\\n+        r\"\\operatorname{arccsc}{\\left (x \\right )}\"\n+    assert latex(asec(x), inv_trig_style=\"full\") == \\\n+        r\"\\operatorname{arcsec}{\\left (x \\right )}\"\n+    assert latex(acsc(x)**2, inv_trig_style=\"full\") == \\\n+        r\"\\operatorname{arccsc}^{2}{\\left (x \\right )}\"\n+    assert latex(asec(x)**2, inv_trig_style=\"full\") == \\\n+        r\"\\operatorname{arcsec}^{2}{\\left (x \\right )}\"\n+    assert latex(acsc(x), inv_trig_style=\"power\") == \\\n+        r\"\\csc^{-1}{\\left (x \\right )}\"\n+    assert latex(asec(x), inv_trig_style=\"power\") == \\\n+        r\"\\sec^{-1}{\\left (x \\right )}\"\n     assert latex(asin(x)**2, inv_trig_style=\"full\") == \\\n         r\"\\arcsin^{2}{\\left (x \\right )}\"\n     assert latex(asin(x)**2, inv_trig_style=\"power\") == \\\n",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..e02dc8d 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6110,8 +6110,44 @@ u(\"\"\"\\\n \"\"\")\n     assert upretty((1/y)*e.j) == ucode_str\n \n-\n-def test_MatrixSymbol_printing():\n+from sympy import MatrixSymbol, symbols, pretty\n+\n+n, a = symbols('n a')\n+x = MatrixSymbol('x', n, n)\n+y = MatrixSymbol('y*', n, n)\n+# Additional test cases for verifying issue resolution\n+def test_pretty_MatAdd():\n+    # Original test case from the patch\n+    assert pretty(x + y) == \"x + y*\"\n+    \n+    # Test with negative coefficients\n+    assert pretty(-x + y) == \"-x + y*\"\n+    assert pretty(-a*x - 2*y) == \"-a*x -2*y*\"\n+    \n+    # Test with multiple terms\n+    z = MatrixSymbol('z', n, n)\n+    assert pretty(x + y + z) == \"x + y* + z\"\n+    \n+    # Test with subscripted matrix symbols\n+    y_sub = MatrixSymbol('y_1', n, n)\n+    assert pretty(x + y_sub) == \"x + y_1\"\n+    \n+    # Test with different dimensions\n+    m, k, l = symbols('m k l')\n+    p = MatrixSymbol('p', m, k)\n+    q = MatrixSymbol('q', k, l)\n+    assert pretty(p + q) == \"p + q\"\n+\n+    # Adding test for negative and multiple coefficients\n+    assert pretty(a*x - y - y) == \"a*x - y* - y*\"\n+\n+    # Test special characters in matrix names\n+    a_star = MatrixSymbol('a*', n, n)\n+    assert pretty(x + a_star) == \"x + a*\"\n+\n+    # Test if pretty print includes parenthesis correctly\n+    e = MatrixSymbol('e', n, n)\n+    assert pretty(x - (y + e)) == \"x - (e + y*)\"\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n     B = MatrixSymbol(\"B\", 3, 3)\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..a426ec4 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -728,6 +728,18 @@ def test_dummification():\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 2 * F(t) + 5))\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 4 * F(t) + 5))\n \n+def test_curly_matrix_symbol_issue():\n+    # Test matrix symbol with curly braces in its name\n+    from sympy import MatrixSymbol, lambdify\n+    curlyv = MatrixSymbol(\"{v}\", 2, 1)\n+    \n+    # These should work if the issue is fixed\n+    curlyVectorId = lambdify(curlyv, curlyv)\n+    assert (curlyVectorId([[1], [2]]) == [[1], [2]]).all()\n+\n+    curlyVectorIdDummified = lambdify(curlyv, curlyv, dummify=True)\n+    assert (curlyVectorIdDummified([[3], [4]]) == [[3], [4]]).all()\n+\n def test_python_keywords():\n     # Test for issue 7452. The automatic dummification should ensure use of\n     # Python reserved keywords as symbol names will create valid lambda\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..7eaf694 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..1b945d7 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1717,6 +1717,8 @@ def test_issue_13651():\n     assert latex(expr) == r\"c - \\left(a + b\\right)\"\n \n \n+from sympy import symbols, MatrixSymbol, latex\n+\n def test_latex_UnevaluatedExpr():\n     x = symbols(\"x\")\n     he = UnevaluatedExpr(1/x)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..ffd1def 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, exp, Eq\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -21,7 +22,22 @@ def test_idiff():\n     assert idiff(x + t + y, [y, t], x) == -Derivative(t, x) - 1\n \n \n-def test_intersection():\n+def test_idiff_equation_support():\n+    x = Symbol('x', real=True)\n+    y = Symbol('y', real=True)\n+    f = Function('f')\n+    g = Function('g')\n+\n+    # Test using Eq with idiff\n+    assert idiff(Eq(y*exp(y), x*exp(x)), y, x).simplify() == (x + 1)*exp(x - y)/(y + 1)\n+\n+    # Test using Function instead of symbol\n+    assert idiff(f(x)*exp(f(x)) - x*exp(x), f(x), x).simplify() == (x + 1) * exp(x - f(x))/(f(x) + 1)\n+\n+    # Test with multiple functions\n+    assert idiff(f(x) - y * exp(x), [f(x), y], x).simplify() == (y + Derivative(y, x)) * exp(x)\n+    assert idiff(f(x) - y * exp(x), [y, f(x)], x).simplify() == -y + exp(-x) * Derivative(f(x), x)\n+    assert idiff(f(x) - g(x), [f(x), g(x)], x).simplify() == Derivative(g(x), x)\n     assert intersection(Point(0, 0)) == []\n     raises(TypeError, lambda: intersection(Point(0, 0), 3))\n     assert intersection(\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_codegen.py b/sympy/utilities/tests/test_codegen.py\nindex 6bc2605..969b9bc 100644\n--- a/sympy/utilities/tests/test_codegen.py\n+++ b/sympy/utilities/tests/test_codegen.py\n@@ -581,14 +581,22 @@ def test_ccode_cse():\n         '}\\n'\n     )\n     assert source == expected\n-\n+from sympy.utilities.autowrap import autowrap\n+from sympy import MatrixSymbol\n+import numpy as np\n def test_empty_f_code():\n     code_gen = FCodeGen()\n     source = get_string(code_gen.dump_f95, [])\n     assert source == \"\"\n-\n-\n-def test_empty_f_code_with_header():\n+from sympy.utilities.autowrap import autowrap\n+from sympy import MatrixSymbol\n+import numpy as np\n+\n+def test_cython_autowrap_unused_array_argument():\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0  # expression does not use x\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    assert f(np.array([[1.0], [2.0]])) == 1.0\n     code_gen = FCodeGen()\n     source = get_string(code_gen.dump_f95, [], header=True)\n     assert source[:82] == (\n",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..299fdee 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -342,8 +342,25 @@ def test_intersection():\n     # issue 12178\n     assert Intersection() == S.UniversalSet\n \n-\n-def test_issue_9623():\n+from sympy import symbols, Eq, Piecewise, EmptySet as S_EmptySet\n+from sympy.sets import Intersection, FiniteSet\n+\n+def test_issue_intersection_remove_duplicates():\n+    x = symbols('x')\n+    \n+    # Test for the example given in the issue\n+    assert Intersection({1}, {1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S_EmptySet, True))\n+    assert Intersection({1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S_EmptySet, True))\n+    \n+    # Additional test cases to verify that duplicates are removed\n+    assert Intersection({1, 1, 2}, {1, 1, 3}) == {1}\n+    assert Intersection(FiniteSet(1, 1, 2), FiniteSet(2, 2, 3)) == {2}\n+    assert Intersection({1, 2, 2, 3}, {4, 5, 3, 3}) == {3}\n+\n+    # Case with symbolic and numeric\n+    y = symbols('y')\n+    assert Intersection({1}, {y, 1}, {x, 1}) == Piecewise(({1}, Eq(x, 1) & Eq(y, 1)), (S_EmptySet, True))\n+    assert Intersection({x, y}, {x, 1}, {1, y}) == Piecewise(({x, y}, Eq(x, 1) & Eq(y, x)), (S_EmptySet, True))\n     n = Symbol('n')\n \n     a = S.Reals\n",
  "sympy__sympy-17022": "",
  "sympy__sympy-17139": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex daf5f69..56e9311 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -801,7 +801,29 @@ def test_nc_simplify():\n     # commutative expressions should be returned without an error\n     assert nc_simplify(2*x**2) == 2*x**2\n \n-def test_issue_15965():\n+def test_issue_17137():\n+    from sympy import Symbol, cos, sin, exp, I, simplify\n+\n+    x = Symbol('x')\n+    assert simplify(cos(x)**I) == cos(x)**I\n+    assert simplify(cos(x)**(2 + 3*I)) == cos(x)**(2 + 3*I)\n+\n+    # Additional cases to ensure robustness\n+    assert simplify(sin(x)**I) == sin(x)**I\n+    assert simplify(exp(x)**I) == exp(x)**I\n+\n+    # Check if nested powers with I are handled\n+    assert simplify((cos(x)**I)**2) == cos(x)**(2*I)\n+\n+    # Check a more complex expression\n+    expr = cos(x)**I / sin(x)**I\n+    assert simplify(expr) == (cos(x) / sin(x))**I\n+\n+    # Nested and multiple I powers\n+    complex_expr = (cos(x)**I + sin(x)**I)**(1 + I)\n+    simplified_expr = simplify(complex_expr)  # No error expected during simplification\n+\n+    assert complex_expr != simplified_expr  # In some cases, expression simplification may not change appearant form\n     A = Sum(z*x**y, (x, 1, a))\n     anew = z*Sum(x**y, (x, 1, a))\n     B = Integral(x*y, x)\n@@ -814,4 +836,4 @@ def test_issue_15965():\n def test_issue_7971():\n     z = Integral(x, (x, 1, 1))\n     assert z != 0\n-    assert simplify(z) is S.Zero\n+    assert simplify(z) is S.Zero\n",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..c931862 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,4 +1,5 @@\n-from sympy import I, Rational, Symbol, pi, sqrt, S\n+\n+from sympy import I, Rational, Symbol, pi, sqrt, S, sympify\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n from sympy.matrices import Matrix\n@@ -26,7 +27,14 @@ def test_point():\n     assert p2.y == y2\n     assert (p3 + p4) == p4\n     assert (p2 - p1) == Point(y1 - x1, y2 - x2)\n-    assert p4*5 == Point(5, 5)\n+    # Checking multiplication of Point with a number works in both directions\n+    assert p4 * 5 == Point(5, 5)\n+    assert 5 * p4 == Point(5, 5)\n+\n+    # Additional tests for issue resolution\n+    two = sympify(2.0)\n+    assert point1 + point2 * two == Point(2, 2)\n+    assert point1 + two * point2 == Point(2, 2)  # This was causing an exception and should now pass\n     assert -p2 == Point(-y1, -y2)\n     raises(ValueError, lambda: Point(3, I))\n     raises(ValueError, lambda: Point(2*I, I))\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..2d80d8f 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1894,6 +1894,45 @@ def test_normal():\n     assert e.normal() == e\n \n \n+from sympy import symbols, sympify, Symbol\n+from sympy.core.compatibility import BadSympyObject\n+from sympy.parsing.sympy_parser import parse_expr\n+import pytest\n+\n+def test_non_string_equality():\n+    # Re-adding the original test code\n+    x = symbols('x')\n+    one = sympify(1)\n+    assert (x == 'x') is False\n+    assert (x != 'x') is True\n+    assert (one == '1') is False\n+    assert (one != '1') is True\n+    assert (x + 1 == 'x + 1') is False\n+    assert (x + 1 != 'x + 1') is True\n+\n+    class BadRepr(object):\n+        def __repr__(self):\n+            raise RuntimeError\n+    \n+    assert (x == BadRepr()) is False\n+    assert (x != BadRepr()) is True\n+\n+    # Additional tests for the reported issue\n+\n+    class UnknownObject:\n+        def __repr__(self):\n+            return 'non_existent_attribute'\n+\n+    # Verify that comparing a Symbol with UnknownObject does not attempt eval\n+    with pytest.raises(TypeError):\n+        assert (x == UnknownObject()) is False\n+    with pytest.raises(TypeError):\n+        assert (x != UnknownObject()) is True\n+\n+    # Testing sympify parsing with UnknownObject does not attempt eval\n+    with pytest.raises(AttributeError):\n+        parse_expr(str(UnknownObject()))\n+\n def test_expr():\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n@@ -1902,4 +1941,4 @@ def test_expr():\n def test_ExprBuilder():\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..ad26269 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -547,7 +547,26 @@ def test_diophantine():\n     assert diophantine(x**2 + y**2 +3*x- 5, permute=True) == \\\n         set([(-1, 1), (-4, -1), (1, -1), (1, 1), (-4, 1), (-1, -1), (4, 1), (4, -1)])\n \n-    # issue 18122\n+    # issue 18186: Testing the permute=True behavior and sym order\n+    x, y = symbols('x y', integer=True)\n+\n+    # Original test: verify the general solution set\n+    assert diophantine(y**4 + x**4 - 2**4 - 3**4, syms=(x, y), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    assert diophantine(y**4 + x**4 - 2**4 - 3**4, syms=(y, x), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+\n+    # Additional tests: verify that sym order does not affect the result\n+    expression = n**4 + m**4 - 2**4 - 3**4\n+    assert diophantine(expression, syms=(m, n), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    assert diophantine(expression, syms=(n, m), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+\n+    assert diophantine(x**4 + y**4 - 2**4 - 3**4, syms=(x, y), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    assert diophantine(x**4 + y**4 - 2**4 - 3**4, syms=(y, x), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n     assert check_solutions(x**2-y)\n     assert check_solutions(y**2-x)\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n",
  "sympy__sympy-18532": "diff --git a/sympy/codegen/tests/test_cnodes.py b/sympy/codegen/tests/test_cnodes.py\nindex c30dccd..03dd0ab 100644\n--- a/sympy/codegen/tests/test_cnodes.py\n+++ b/sympy/codegen/tests/test_cnodes.py\n@@ -1,6 +1,7 @@\n+\n from sympy.core.symbol import symbols\n from sympy.printing.ccode import ccode\n-from sympy.codegen.ast import Declaration, Variable, float64, int64\n+from sympy.codegen.ast import Declaration, Variable, float64, int64, String\n from sympy.codegen.cnodes import (\n     alignof, CommaOperator, goto, Label, PreDecrement, PostDecrement, PreIncrement, PostIncrement,\n     sizeof, union, struct\n@@ -66,7 +67,7 @@ def test_sizeof():\n     assert ccode(sz) == 'sizeof(%s)' % typename\n     assert sz.func(*sz.args) == sz\n     assert not sz.is_Atom\n-    assert all(atom == typename for atom in sz.atoms())\n+    assert sz.atoms() == {String('unsigned int'), String('sizeof')}\n \n \n def test_struct():\n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..a1aa5ae 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,16 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_blockdiagmatrix_single_element_conversion():\n+    from sympy import Matrix, BlockDiagMatrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    try:\n+        B = Matrix(D)\n+        assert B == M, \"BlockDiagMatrix with one element should be convertible to a Matrix\"\n+    except TypeError as e:\n+        assert False, f\"Unexpected TypeError: {e}\"\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..d8ec8f9 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n@@ -46,7 +47,19 @@ def test_mul_index():\n     assert result.args[1][1:] == expected.args[1][1:]\n \n \n-def test_pow_index():\n+def test_block_index_issue():\n+    from sympy import MatrixSymbol, symbols, BlockMatrix\n+    n, i = symbols('n i', integer=True)\n+    A = MatrixSymbol('A', 1, 1)\n+    B = MatrixSymbol('B', n, 1)\n+    # Create a vertical block matrix of A and B\n+    C = BlockMatrix([[A], [B]])\n+    # Verify symbolic index gives MatrixElement\n+    assert C[i, 0] == MatrixElement(C, i, 0)\n+    # Verify specific index for element in A\n+    assert C[0, 0] == A[0, 0]\n+    # Verify specific index for element in B\n+    assert C[1, 0] == B[0, 0]\n     Q = MatPow(A, 2)\n     assert Q[0, 0] == A[0, 0]**2 + A[0, 1]*A[1, 0]\n     n = symbols(\"n\")\n",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..bd46c4e 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -296,6 +296,16 @@ def test_sign():\n     assert sign(Symbol('x', real=True, zero=False)).is_nonpositive is None\n \n     x, y = Symbol('x', real=True), Symbol('y')\n+\n+    # Additional test cases to verify rewriting of sign as abs\n+    z = Symbol('z')\n+    fz = Function('fz')\n+    assert sign(z).rewrite(Abs) == Piecewise((0, Eq(z, 0)), (z / Abs(z), True))\n+    assert sign(fz(z)).rewrite(Abs) == Piecewise((0, Eq(fz(z), 0)), (fz(z) / Abs(fz(z)), True))\n+    assert sign(x).rewrite(Abs) == Piecewise((0, Eq(x, 0)), (x / Abs(x), True))\n+    assert sign(-x).rewrite(Abs) == Piecewise((0, Eq(-x, 0)), (-x / Abs(-x), True))\n+    assert sign(z + I).rewrite(Abs) == Piecewise((0, Eq(z + I, 0)), ((z + I) / Abs(z + I), True))\n+    assert sign(z * I).rewrite(Abs) == Piecewise((0, Eq(z * I, 0)), ((z * I) / Abs(z * I), True))\n     assert sign(x).rewrite(Piecewise) == \\\n         Piecewise((1, x > 0), (-1, x < 0), (0, True))\n     assert sign(y).rewrite(Piecewise) == sign(y)\n",
  "sympy__sympy-20154": "",
  "sympy__sympy-20212": "",
  "sympy__sympy-20442": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 6a8906d..54defac 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,10 +1,11 @@\n+\n from sympy import (Abs, Add, Function, Number, Rational, S, Symbol,\n                    diff, exp, integrate, log, sin, sqrt, symbols)\n from sympy.physics.units import (amount_of_substance, convert_to, find_unit,\n                                  volume, kilometer)\n from sympy.physics.units.definitions import (amu, au, centimeter, coulomb,\n     day, foot, grams, hour, inch, kg, km, m, meter, millimeter,\n-    minute, quart, s, second, speed_of_light, bit,\n+    minute, quart, s, second, speed_of_light, bit, joule,\n     byte, kibibyte, mebibyte, gibibyte, tebibyte, pebibyte, exbibyte,\n     kilogram, gravitational_constant)\n \n@@ -46,7 +47,22 @@ def test_convert_to():\n     assert speed_of_light.convert_to(m) == speed_of_light\n \n \n-def test_Quantity_definition():\n+def test_issue_conversion_of_orthogonal_units():\n+    expr = joule * second\n+    # Test with the specific problematic conversion\n+    conv = convert_to(expr, joule)\n+    assert conv == expr\n+\n+    # Additional related tests from the issue:\n+    exact_conversion = convert_to(expr, joule * second)\n+    assert exact_conversion == expr\n+\n+    base_unit_conversion = convert_to(expr, kg * m**2 / s)\n+    assert base_unit_conversion == kg * m**2 / s\n+\n+    # Test conversion to time unit\n+    time_unit_conversion = convert_to(expr, minute)\n+    assert time_unit_conversion == joule * minute / 60\n     q = Quantity(\"s10\", abbrev=\"sabbr\")\n     q.set_global_relative_scale_factor(10, second)\n     u = Quantity(\"u\", abbrev=\"dam\")\n",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..1822225 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -28,6 +28,21 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+from sympy import Symbol\n+from sympy.testing.pytest import raises\n+\n+def test_symbol_dict_absence():\n+    s = Symbol('s')\n+    # Test that Symbol does not have a __dict__, raising AttributeError\n+    assert not hasattr(s, '__dict__')\n+    with raises(AttributeError):\n+        d = s.__dict__\n+\n+def test_symbol_slots():\n+    s = Symbol('s')\n+    # Test that Symbol uses __slots__ to minimize memory usage\n+    assert s.__slots__ == ('name',)\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..189b76c 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,5 +1,6 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n-                   atan, atan2, nan, Symbol, re, im, sign)\n+                   atan, atan2, nan, Symbol, re, im, sign, arg, Abs, Integral, oo, sin, exp)\n from sympy.abc import w, x, y, z\n from sympy.core.relational import Eq, Ne\n from sympy.functions.elementary.piecewise import Piecewise\n@@ -160,6 +161,24 @@ def test_sign():\n     x = Symbol('x', complex=True)\n     assert refine(sign(x), Q.zero(x)) == 0\n \n+def test_arg():\n+    x = Symbol('x', complex=True)\n+    assert refine(arg(x), Q.positive(x)) == 0\n+    assert refine(arg(x), Q.negative(x)) == pi\n+    # New test cases\n+    a = Symbol('a', real=True)\n+    assert refine(arg(a), Q.positive(a)) == 0\n+    assert refine(arg(I*a), Q.positive(a)) == pi/2\n+    assert refine(arg(-I*a), Q.positive(a)) == -pi/2\n+    assert refine(arg(-a), Q.positive(a)) == pi\n+\n+def test_refine_issue():\n+    a = Symbol('a', real=True)\n+    x = Symbol('x')\n+    J = Integral(sin(x)*exp(-a*x), (x, 0, oo))\n+    simplified_J = refine(J.doit(), Q.positive(a))\n+    assert simplified_J == 1 / (a**2 + 1), \"Refine failed for Integral simplification\"\n+\n \n def test_func_args():\n     class MyClass(Expr):\n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..e226b7c 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -7,6 +8,8 @@ from sympy import (\n from sympy.core.basic import _aresame\n from sympy.testing.pytest import XFAIL\n from sympy.abc import a, x, y, z, t\n+from sympy import sinh, exp, symbols, Piecewise, clear_cache, PolynomialError\n+from sympy.testing.pytest import raises\n \n def test_subs():\n     n3 = Rational(3)\n@@ -20,7 +23,28 @@ def test_subs():\n     assert e == Rational(6)\n \n \n-def test_subs_Matrix():\n+def test_issue_polynomial_error_on_subs():\n+    x_r, y_r, z_r = symbols('x_r y_r z_r', real=True)\n+    \n+    # Clear cache and redefine symbols for consistency\n+    clear_cache()\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    \n+    # Test substituting 1 with 1.0 should not raise PolynomialError\n+    try:\n+        expr.subs({1: 1.0})\n+    except PolynomialError:\n+        assert False, \"Unexpected PolynomialError was raised by subs\"\n+\n+    # Additional checks to verify other aspects of the workaround described in the issue\n+    # Check expr with z not being real for further testing\n+    x_nr, y_nr = symbols('x_nr y_nr')\n+    expr_nr = exp(sinh(Piecewise((x_nr, y_nr > x_nr), (y_nr, True)) / z_r))\n+    # Should also work similarly without real constraint, as specified in the issue\n+    try:\n+        expr_nr.subs({1: 1.0})\n+    except PolynomialError:\n+        assert False, \"Unexpected PolynomialError was raised by subs\"\n     z = zeros(2)\n     z1 = ZeroMatrix(2, 2)\n     assert (x*y).subs({x:z, y:0}) in [z, z1]\n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..ef70d23 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,9 +1,11 @@\n+\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n from sympy.core.numbers import pi, zoo, I, AlgebraicNumber\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n+from sympy.core.function import Derivative\n from sympy.integrals.integrals import Integral\n from sympy.matrices import (Matrix, SparseMatrix, ImmutableMatrix,\n     ImmutableSparseMatrix, MatrixSymbol, MatrixKind, MatMul)\n@@ -45,7 +47,12 @@ def test_Matrix_kind():\n         m = cls.zeros(3, 2)\n         assert m.kind is MatrixKind(NumberKind)\n \n-def test_MatMul_kind():\n+def test_Derivative_kind_issue():\n+    A = MatrixSymbol('A', 2, 2)\n+    d = Derivative(A, comm_x)\n+    # Check if the kind for a derivative of a MatrixSymbol with respect to a scalar\n+    # is MatrixKind(NumberKind) which should be the expected behavior\n+    assert d.kind is MatrixKind(NumberKind)\n     M = Matrix([[1,2],[3,4]])\n     assert MatMul(2, M).kind is MatrixKind(NumberKind)\n     assert MatMul(comm_x, M).kind is MatrixKind(NumberKind)\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..1652295 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -131,6 +131,30 @@ def test_monomials():\n     assert set(itermonomials([x, y], [2, 2])) == \\\n             {S.One, y**2, x*y**2, x, x*y, x**2, x**2*y**2, y, x**2*y}\n \n+    # Test cases for issue with itermonomials generating only the highest degree monomials\n+    states = symbols('x1 x2 x3')\n+\n+    # Test when min_degree = max_degree\n+    expected_output = {states[0]**3, states[1]**3, states[2]**3, \n+                       states[0]*states[1]**2, states[1]*states[2]**2, \n+                       states[0]*states[2]**2, states[0]**2*states[1], \n+                       states[1]**2*states[2], states[2]**2*states[0], \n+                       states[0]**2*states[2], states[1]**2*states[0], \n+                       states[2]**2*states[1], states[0]*states[1]*states[2]}\n+    assert set(itermonomials(states, 3, 3)) == expected_output\n+\n+    # Test when min_degree < max_degree\n+    expected_output = {states[0]**3, states[1]**3, states[2]**3, \n+                       states[0]*states[1]**2, states[1]*states[2]**2, \n+                       states[0]*states[2]**2, states[0]**2*states[1], \n+                       states[1]**2*states[2], states[2]**2*states[0], \n+                       states[0]**2*states[2], states[1]**2*states[0], \n+                       states[2]**2*states[1], states[0]*states[1]*states[2],\n+                       S.One, states[0], states[1], states[2], \n+                       states[0]*states[1], states[1]*states[2], states[2]*states[0],\n+                       states[0]**2, states[1]**2, states[2]**2}\n+    assert set(itermonomials(states, 3, 2)) == expected_output\n+    \n     i, j, k = symbols('i j k', commutative=False)\n     assert set(itermonomials([i, j, k], [0, 0, 0])) == {S.One}\n     assert set(itermonomials([i, j, k], [0, 0, 1])) == {1, k}\n",
  "sympy__sympy-22005": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 341f63c..d79eb65 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n@@ -49,6 +50,12 @@ def test_solve_poly_system():\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\n     raises(PolynomialError, lambda: solve_poly_system([1/x], x))\n \n+    # Additional test cases for infinite solutions detection\n+    raises(NotImplementedError, lambda: solve_poly_system([x - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([y - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([x + y - 2, y - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([x*y - 1], (x, y)))\n+\n \n def test_solve_biquadratic():\n     x0, y0, x1, y1, r = symbols('x0 y0 x1 y1 r')\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..46778d0 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n@@ -10,6 +11,7 @@ from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.misc import Undecidable\n from sympy.testing.pytest import raises, warns\n+from sympy.core.parameters import evaluate\n \n \n def test_point():\n@@ -440,7 +442,11 @@ def test_unit():\n     assert Point(1, 1).unit == Point(sqrt(2)/2, sqrt(2)/2)\n \n \n-def test_dot():\n+def test_issue_22684():\n+    # This used to raise an error \"Imaginary coordinates are not permitted.\"\n+    with evaluate(False):\n+        p = Point2D(1, 2)\n+        assert p == Point2D(1, 2)\n     raises(TypeError, lambda: Point(1, 2).dot(Line((0, 0), (1, 1))))\n \n \n",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..e9ba0f0 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -338,6 +338,9 @@ def test_cse_Indexed():\n     assert len(replacements) > 0\n \n \n+from sympy import Matrix, symbols, MatrixSymbol\n+import sympy\n+\n def test_cse_MatrixSymbol():\n     # MatrixSymbols have non-Basic args, so make sure that works\n     A = MatrixSymbol(\"A\", 3, 3)\n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..de518f8 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -38,7 +39,19 @@ def test_array_negative_indices():\n         assert test_array[-1, -1] == 10\n \n \n-def test_issue_18361():\n+def test_create_empty_array():\n+    \"\"\"Test creating an empty Array.\"\"\"\n+    for array_type in array_types:\n+        A = array_type([])\n+        assert isinstance(A, array_type), \"Expected empty array to be of correct type\"\n+        assert A.shape == (0,), \"Expected empty array to have shape (0,)\"\n+        assert list(A) == [], \"Expected empty array to have no elements\"\n+\n+def test_create_empty_matrix():\n+    \"\"\"Test creating an empty Matrix.\"\"\"\n+    M = Matrix([])\n+    assert M.shape == (0, 0), \"Expected empty matrix to have shape (0, 0)\"\n+    assert list(M) == [], \"Expected empty matrix to have no elements\"\n     A = Array([sin(2 * x) - 2 * sin(x) * cos(x)])\n     B = Array([sin(x)**2 + cos(x)**2, 0])\n     C = Array([(x + x**2)/(x*sin(y)**2 + x*cos(y)**2), 2*sin(x)*cos(x)])\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..c813070 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,6 +1175,9 @@ def test_scipy_polys():\n \n \n \n+import inspect\n+from sympy import lambdify\n+\n def test_lambdify_inspect():\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..02dd11e 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -528,7 +528,36 @@ def test_issue_22819():\n     assert Da.scale_factor == 1.66053906660000e-24\n \n \n-def test_issue_20288():\n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units.systems.si import SI\n+    from sympy import exp\n+    from sympy.physics.units import Quantity, Dimension\n+\n+    # Define quantities with dimensions\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+\n+    # Set global relative scale factors\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+\n+    # The expression to be tested\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+\n+    # Assert that the dimension is recognized as dimensionless\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    # Test the problematic expression in the initial bug report\n+    exp_expr = 100 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (101, Dimension(1))\n     from sympy.core.numbers import E\n     from sympy.physics.units import energy\n     u = Quantity('u')\n",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..f1cf05d 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -45,8 +45,18 @@ def test_tensor_product_expand():\n     assert TP(A + B, B + C).expand(tensorproduct=True) == \\\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n-\n-def test_tensor_product_commutator():\n+def test_tensor_product_expand_issue():\n+    # Test to verify the bug is fixed when expanding with scalar factors\n+    assert TP(2*U - V, U + V).expand(tensorproduct=True) == \\\n+        2*TP(U, U) + 2*TP(U, V) - TP(V, U) - TP(V, V)\n+    \n+    # Reusing provided original test cases\n+    assert TP(A - B, B - A).expand(tensorproduct=True) == \\\n+        TP(A, B) - TP(A, A) - TP(B, B) + TP(B, A)\n+    assert TP(2*A + B, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A, A) + 2 * TP(A, B) + TP(B, A) + TP(B, B)\n+    assert TP(2 * A * B + A, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A*B, A) + 2 * TP(A*B, B) + TP(A, A) + TP(A, B)\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n         TP(A*B, C) - TP(B*A, C)\n     assert Comm(TP(A, B), TP(B, C)).doit() == \\\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..20becea 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -562,7 +563,48 @@ def test_issue_24062():\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n \n-def test_prefixed_property():\n+def test_issue_24211():\n+    from sympy.physics.units import Quantity, velocity, acceleration, time, meter, second\n+    from sympy.physics.units.systems.si import SI\n+\n+    V1 = Quantity('V1')\n+    SI.set_quantity_dimension(V1, velocity)\n+    SI.set_quantity_scale_factor(V1, 1 * meter / second)\n+    \n+    A1 = Quantity('A1')\n+    SI.set_quantity_dimension(A1, acceleration)\n+    SI.set_quantity_scale_factor(A1, 1 * meter / second**2)\n+    \n+    T1 = Quantity('T1')\n+    SI.set_quantity_dimension(T1, time)\n+    SI.set_quantity_scale_factor(T1, 1 * second)\n+    \n+    expr = A1 * T1 + V1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr)\n+\n+def test_collect_factor_and_dimension_equivalence():\n+    from sympy.physics.units import Quantity, velocity, acceleration, time, meter, second\n+    from sympy.physics.units.systems.si import SI\n+\n+    # Define quantities with dimensions\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+\n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+\n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+\n+    # Expression to test\n+    expr1 = a1 * t1 + v1\n+    # Ensure no ValueError is raised\n+    factor, dimension = SI._collect_factor_and_dimension(expr1)\n+    assert dimension == units.velocity, \"Expected dimension of velocity\"\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..3f589c2 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,10 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, V\n+from sympy.physics.units.prefixes import milli\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n@@ -28,6 +30,18 @@ def test_prefix_operations():\n     assert dodeca / dodeca == 1\n \n     m = Quantity(\"fake_meter\")\n+    # Test milli prefix with Watts\n+    assert milli * W != 1\n+    assert milli * W == W / 1000\n+\n+    # Test milli prefix with other units (e.g., Volts)\n+    assert milli * V != 1\n+    assert milli * V == V / 1000\n+\n+    # Ensure original test regarding kibi prefix remains valid\n+    m = PREFIXES['m']\n+    k = PREFIXES['k']\n+    assert m * k == S.One\n     SI.set_quantity_dimension(m, S.One)\n     SI.set_quantity_scale_factor(m, S.One)\n \n",
  "django__django-12470": "",
  "django__django-13033": "",
  "django__django-13265": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..d08d45c 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -658,6 +658,38 @@ Java</label></li>\n <input id=\"id_language_1\" name=\"language\" type=\"radio\" value=\"J\" required> Java</label></div>\"\"\"\n         )\n \n+    def test_boundwidget_id_for_label_uses_option_id(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should use the id provided in subwidget data['attrs']['id']\n+        if available.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(attrs={'id': 'custom_id'}),  # custom_id will be used if not None\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_1')\n+\n+    def test_boundwidget_id_for_label_default(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should default to id_<name>_<index> format\n+        when no custom ID is provided in the subwidget.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(),  # No custom ID set\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'prefix_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'prefix_field_1')\n+\n     def test_form_with_iterable_boundfield(self):\n         class BeatleForm(Form):\n             name = ChoiceField(\n@@ -673,6 +705,38 @@ Java</label></li>\n <label><input type=\"radio\" name=\"name\" value=\"george\" required> George</label>\n <label><input type=\"radio\" name=\"name\" value=\"ringo\" required> Ringo</label>\"\"\"\n         )\n+\n+    def test_boundwidget_id_for_label_uses_option_id(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should use the id provided in subwidget data['attrs']['id']\n+        if available.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(attrs={'id': 'custom_id'}),  # custom_id will be used if not None\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_1')\n+\n+    def test_boundwidget_id_for_label_default(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should default to id_<name>_<index> format\n+        when no custom ID is provided in the subwidget.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(),  # No custom ID set\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'prefix_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'prefix_field_1')\n         self.assertHTMLEqual(\n             '\\n'.join('<div>%s</div>' % bf for bf in f['name']),\n             \"\"\"<div><label><input type=\"radio\" name=\"name\" value=\"john\" required> John</label></div>\n@@ -714,6 +778,38 @@ Java</label></li>\n             'value=\"paul\" id=\"id_name_1\" required> Paul</label>'\n         )\n \n+    def test_boundwidget_id_for_label_uses_option_id(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should use the id provided in subwidget data['attrs']['id']\n+        if available.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(attrs={'id': 'custom_id'}),  # custom_id will be used if not None\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_1')\n+\n+    def test_boundwidget_id_for_label_default(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should default to id_<name>_<index> format\n+        when no custom ID is provided in the subwidget.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(),  # No custom ID set\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'prefix_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'prefix_field_1')\n+\n     def test_iterable_boundfield_select(self):\n         class BeatleForm(Form):\n             name = ChoiceField(choices=[('john', 'John'), ('paul', 'Paul'), ('george', 'George'), ('ringo', 'Ringo')])\n@@ -2925,6 +3021,38 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n <input type=\"number\" name=\"age\" id=\"id_age\" required></td></tr>\"\"\"\n         )\n \n+    def test_boundwidget_id_for_label_uses_option_id(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should use the id provided in subwidget data['attrs']['id']\n+        if available.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(attrs={'id': 'custom_id'}),  # custom_id will be used if not None\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_1')\n+\n+    def test_boundwidget_id_for_label_default(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should default to id_<name>_<index> format\n+        when no custom ID is provided in the subwidget.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(),  # No custom ID set\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'prefix_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'prefix_field_1')\n+\n     def test_label_has_required_css_class(self):\n         \"\"\"\n         #17922 - required_css_class is added to the label_tag() of required fields.\n@@ -2940,6 +3068,38 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n             f['field'].label_tag(attrs={'class': 'foo'}),\n             '<label for=\"id_field\" class=\"foo required\">Field:</label>'\n         )\n+\n+    def test_boundwidget_id_for_label_uses_option_id(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should use the id provided in subwidget data['attrs']['id']\n+        if available.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(attrs={'id': 'custom_id'}),  # custom_id will be used if not None\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_1')\n+\n+    def test_boundwidget_id_for_label_default(self):\n+        \"\"\"\n+        BoundWidget.id_for_label should default to id_<name>_<index> format\n+        when no custom ID is provided in the subwidget.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(),  # No custom ID set\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'prefix_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'prefix_field_1')\n         self.assertHTMLEqual(f['field2'].label_tag(), '<label for=\"id_field2\">Field2:</label>')\n \n     def test_label_split_datetime_not_displayed(self):\n",
  "django__django-16400": "",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..76a7b72 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -640,6 +640,12 @@ def test_colorbar_format(fmt):\n             '$\\\\mathdefault{10^{-2}}$')\n \n \n+import pytest\n+from matplotlib.colors import LogNorm\n+import matplotlib.pyplot as plt\n+import numpy as np\n+from matplotlib.colors import Normalize\n+\n def test_colorbar_scale_reset():\n     x, y = np.ogrid[-4:4:31j, -4:4:31j]\n     z = 120000*np.exp(-x**2 - y**2)\n",
  "pydata__xarray-4094": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex a2826fa..3e18bfb 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -3045,6 +3045,14 @@ class TestDataset:\n         d0 = D.isel(x=0)\n         assert_identical(d0, x0)\n \n+    def test_to_stacked_array_single_dim_variable(self):\n+        # single dimension: regression test for GH4049\n+        arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+        data = xr.Dataset({\"a\": arr, \"b\": arr})\n+        stacked = data.to_stacked_array(\"y\", sample_dims=[\"x\"])\n+        unstacked = stacked.to_unstacked_dataset(\"y\")\n+        assert_identical(unstacked, data)\n+\n     def test_to_stacked_array_to_unstacked_dataset_different_dimension(self):\n         # test when variables have different dimensionality\n         a, b = create_test_stacked_array()\n",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..842e8b0 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -259,4 +259,41 @@ def test_set_output_mro():\n     class C(A, B):\n         pass\n \n-    assert C().transform(None) == \"B\"\n+    assert C().transform(None) == \"B\"\n+\n+def test_featureunion_pandas_output_with_groupby():\n+    \"\"\"Test FeatureUnion with pandas transformation output using groupby operation.\"\"\"\n+    import pandas as pd\n+    from sklearn.pipeline import FeatureUnion\n+    from sklearn.base import BaseEstimator, TransformerMixin\n+    from sklearn import set_config\n+    from numpy.testing import assert_array_equal\n+\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+\n+    class MyTransformer(BaseEstimator, TransformerMixin):\n+        def fit(self, X: pd.DataFrame, y: pd.Series | None = None, **kwargs):\n+            return self\n+\n+        def transform(self, X: pd.DataFrame, y: pd.Series | None = None) -> pd.DataFrame:\n+            return X[\"value\"].groupby(X[\"date\"]).sum().to_frame()\n+\n+    # Test with pandas output set\n+    set_config(transform_output=\"pandas\")\n+    union = FeatureUnion([(\"my_transformer\", MyTransformer())])\n+    result = union.fit_transform(data)\n+\n+    expected_index = data[\"date\"].unique()\n+    expected_result = pd.DataFrame({\"my_transformer__value\": [240] * len(expected_index)}, index=expected_index)\n+\n+    assert_array_equal(result.index, expected_result.index)\n+    assert_array_equal(result.values.flatten(), expected_result.values.flatten())\n+\n+    # Test with default output set\n+    set_config(transform_output=\"default\")\n+    result_default = union.fit_transform(data)\n+    \n+    assert result_default.shape == (4, 1)  # 4 unique days\n+    assert_array_equal(result_default.flatten(), [240, 240, 240, 240])  # Sum for each day is 240\n",
  "sphinx-doc__sphinx-8801": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 37d6e17..17e4b35 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -106,6 +106,37 @@ def test_inherited_instance_variable(app):\n     ]\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    # Setup application and directive options\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+    \n+    # Assert that Bar.attr1 is documented\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n def test_decorators(app):\n     actual = do_autodoc(app, 'class', 'target.decorator.Baz')\n     assert list(actual) == [\n@@ -115,6 +146,37 @@ def test_decorators(app):\n         '',\n     ]\n \n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    # Setup application and directive options\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+    \n+    # Assert that Bar.attr1 is documented\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n     actual = do_autodoc(app, 'class', 'target.decorator.Qux')\n     assert list(actual) == [\n         '',\n@@ -132,6 +194,37 @@ def test_decorators(app):\n     ]\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    # Setup application and directive options\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+    \n+    # Assert that Bar.attr1 is documented\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_slots_attribute(app):\n     options = {\"members\": None}\n",
  "sympy__sympy-15346": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex cce4836..c54f779 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     symbols, sin, simplify, cos, trigsimp, rad, tan, exptrigsimp,sinh,\n     cosh, diff, cot, Subs, exp, tanh, exp, S, integrate, I,Matrix,\n@@ -353,7 +354,14 @@ def test_issue_2827_trigsimp_methods():\n     M = Matrix.eye(1)\n     assert all(trigsimp(M, method=m) == M for m in\n         'fu matching groebner old'.split())\n-    # watch for E in exptrigsimp, not only exp()\n+    # Test simplifying trigonometric expressions with rational numbers\n+    r1 = sin(S(1)/50)*sin(S(1)/25) + cos(S(1)/50)*cos(S(1)/25)\n+    r2 = cos(S(1)/50)*cos(S(1)/25) - sin(S(1)/50)*sin(S(1)/25)\n+    assert trigsimp(r1) == cos(S(1)/50 - S(1)/25)\n+    assert trigsimp(r2) == cos(S(1)/50 + S(1)/25)\n+\n+    # Ensure compatibility with acos\n+    assert trigsimp(acos(r1)).simplify() == acos(cos(S(1)/50 - S(1)/25)).simplify()\n     eq = 1/sqrt(E) + E\n     assert exptrigsimp(eq) == eq\n \n",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..f122014 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4816,6 +4816,35 @@ ____  ____     \\n\\\n \u203e\u203e\u203e\u203e  \u203e\u203e\u203e\u203e     \\n\\\n y = 1 x = 0    \\\n \"\"\")\n+    expr = Sum(x, (x, 1, oo)) + 3\n+    ascii_str = \\\n+\"\"\"\\\n+  oo    \\n\\\n+ ___   \\n\\\n+ \\\\  `  \\n\\\n+  \\\\   x\\n\\\n+  /    \\n\\\n+ /__,  \\n\\\n+x = 1  \\n\\\n+      + 3\\\n+\"\"\"\n+    ucode_str = \\\n+u(\"\"\"\\\n+  \u221e    \\n\\\n+ ___   \\n\\\n+ \u2572     \\n\\\n+  \u2572   x\\n\\\n+  \u2571    \\n\\\n+ \u2571     \\n\\\n+ \u203e\u203e\u203e   \\n\\\n+x = 1  \\n\\\n+   + 3\\\n+\"\"\")\n+\n+    assert pretty(expr) == ascii_str\n+    assert upretty(expr) == ucode_str\n+\n+\n     expr = Sum(1/(1 + 1/(\n         1 + 1/k)) + 1, (k, 111, 1 + 1/n), (k, 1/(1 + m), oo)) + 1/(1 + 1/k)\n     ascii_str = \\\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex b2b6202..a1ddbf2 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -704,8 +704,25 @@ def test_uniq():\n     assert list(uniq([2, 3, 2, 4, [2], [1], [2], [3], [1]])) == \\\n         [2, 3, 4, [2], [1], [3]]\n \n+from sympy.utilities.iterables import uniq\n+from sympy.utilities.pytest import raises\n \n-def test_kbins():\n+def test_uniq_modification():\n+    # Original test patch cases\n+    f = [1]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    f = [[1]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Additional test cases\n+    f = list('sympy')\n+    raises(RuntimeError, lambda: [f.pop(0) for i in uniq(f)])  # Popping from the list should trigger error\n+\n+    f = list('abcabcabc')\n+    raises(RuntimeError, lambda: [f.pop() for i in uniq(f)])   # Popping the last element should trigger error\n+\n+    f = [1, 2, 3, 4, 5]\n+    raises(RuntimeError, lambda: [f.clear() for i in uniq(f)])  # Clearing the list should trigger error\n     assert len(list(kbins('1123', 2, ordered=1))) == 24\n     assert len(list(kbins('1123', 2, ordered=11))) == 36\n     assert len(list(kbins('1123', 2, ordered=10))) == 10\n",
  "django__django-11797": "",
  "django__django-15320": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 35f7f03..34ab3a3 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -536,8 +536,17 @@ class BasicExpressionsTests(TestCase):\n             qs.query.annotations['is_ceo'],\n             qs.query.annotations['small_company'],\n         )\n-\n-    def test_in_subquery(self):\n+    def test_subquery_constructed_with_flag(self):\n+        # Test to ensure Subquery sets query.subquery = True\n+        employees = Employee.objects.all()\n+        subquery = Subquery(employees)\n+        # Ensures that the subquery flag is set correctly\n+        self.assertTrue(subquery.query.subquery, msg=\"Subquery did not set the subquery attribute to True.\")\n+        compiler = subquery.query.get_compiler(connection=connection)\n+        sql, _ = subquery.as_sql(compiler, connection)\n+        # Check if the SQL is correctly formed, with (SELECT ... ) format\n+        self.assertIn('(SELECT ', sql)\n+        self.assertTrue(sql.endswith(')'))\n         # This is a contrived test (and you really wouldn't write this query),\n         # but it is a succinct way to test the __in=Subquery() construct.\n         small_companies = Company.objects.filter(num_employees__lt=200).values('pk')\n",
  "django__django-15819": "diff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py\nindex 0ecd041..7178a8c 100644\n--- a/tests/inspectdb/tests.py\n+++ b/tests/inspectdb/tests.py\n@@ -428,7 +428,27 @@ class InspectDBTestCase(TestCase):\n             return_value=[TableInfo(name=\"nonexistent\", type=\"t\")],\n         ):\n             call_command(\"inspectdb\", stdout=out)\n+from django.core.management import call_command\n+from django.test import TransactionTestCase\n+from io import StringIO\n+\n+class InspectDBTests(TransactionTestCase):\n+    available_apps = [\"inspectdb\"]\n+\n+    def test_inspectdb_handles_related_name(self):\n+        \"\"\"Test inspectdb generates related_name to avoid accessor clashes.\"\"\"\n+        out = StringIO()\n+        call_command('inspectdb', 'inspectdb_peoplemoredata', stdout=out)\n         output = out.getvalue()\n+        # Ensure the appropriate related_name is autogenerated to avoid clashes.\n+        self.assertIn(\n+            \"people_unique = models.ForeignKey('InspectdbPeople', models.CASCADE, unique=True, related_name='inspectdbpeoplemoredata_people_unique_set')\",\n+            output\n+        )\n+        self.assertIn(\n+            \"message = models.ForeignKey('InspectdbMessage', models.CASCADE, blank=True, null=True, related_name='inspectdbpeoplemoredata_message_set')\",\n+            output\n+        )\n         self.assertIn(\"# Unable to inspect table 'nonexistent'\", output)\n         # The error message depends on the backend\n         self.assertIn(\"# The error was:\", output)\n",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..1287975 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -152,6 +153,16 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n+    def test_wrong_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation('pool__tournament__pool')\n+                ).select_related('tournament_pool', 'tournament_pool__tournament')\n+            )\n+            # because the tournament is shared, this comparison should now be correct\n+            self.assertEqual(p[0].pool.tournament, p[0].tournament_pool.tournament)\n+\n     def test_reverse_fk_select_related_multiple(self):\n         with self.assertNumQueries(1):\n             ps = list(\n@@ -163,4 +174,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "",
  "mwaskom__seaborn-2848": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 5a5e126..9e1065c 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -1,3 +1,4 @@\n+\n from itertools import product\n import numpy as np\n import matplotlib as mpl\n@@ -10,6 +11,7 @@ from numpy.testing import assert_array_equal\n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n \n+from seaborn import PairGrid\n from seaborn.relational import (\n     _RelationalPlotter,\n     _LinePlotter,\n@@ -1623,7 +1625,25 @@ class TestScatterPlotter(SharedAxesLevelTests, Helpers):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n-    def test_linewidths(self, long_df):\n+    def test_pairgrid_scatterplot_with_hue(self):\n+        import seaborn as sns\n+        import pandas as pd\n+\n+        # Load the iris dataset\n+        iris = sns.load_dataset(\"iris\")\n+        \n+        # Create a PairGrid and map a scatterplot with a categorical hue\n+        g = sns.PairGrid(iris, y_vars=[\"sepal_length\", \"sepal_width\"], x_vars=[\"petal_length\", \"petal_width\"])\n+        \n+        # Map the scatterplot with hue set to the species column\n+        g.map(sns.scatterplot, hue=iris[\"species\"])\n+\n+        # We need to draw the plots and then check there are no errors/assert correct plotting\n+        for ax in g.axes.flat:\n+            if ax is not None:\n+                # We expect to have data classified by species, so check for presence of this in path collections\n+                for path in ax.collections:\n+                    assert len(path.get_offsets()) > 0  # Some data should be plotted without error\n \n         f, ax = plt.subplots()\n \n",
  "pytest-dev__pytest-5413": "diff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 226bfb9..34a346a 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -323,6 +323,9 @@ class TestTraceback_f_g_h:\n         assert entry.frame.code.name == \"g\"\n \n \n+import pytest\n+\n+\n def test_excinfo_exconly():\n     excinfo = pytest.raises(ValueError, h)\n     assert excinfo.exconly().startswith(\"ValueError\")\n@@ -333,7 +336,18 @@ def test_excinfo_exconly():\n     assert msg.endswith(\"world\")\n \n \n-def test_excinfo_repr():\n+def test_raises_context():\n+    # Test case to check the behavior of pytest.raises context variable\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\n+            f\"A\\n\"\n+            f\"B\\n\"\n+            f\"C\"\n+        )\n+    # Compare str(excinfo) and str(excinfo.value)\n+    assert str(excinfo.value) == \"A\\nB\\nC\"\n+    # Ensure str(excinfo) behaves as described in the issue\n+    assert \"<ExceptionInfo LookupError tblen=\" in str(excinfo)\n     excinfo = pytest.raises(ValueError, h)\n     s = repr(excinfo)\n     assert s == \"<ExceptionInfo ValueError tblen=4>\"\n",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..1c9dfd1 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -404,6 +404,14 @@ class TestCustomConftests:\n         testdir.makepyfile(\"def test_x(): pass\")\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+    def test_collect_only_shortcut(self, testdir):\n+        # Create a simple test file\n+        testdir.makepyfile(\"def test_func(): pass\")\n+        # Use the new shortcut and collect tests\n+        result = testdir.runpytest(\"-c\")\n+        result.stdout.fnmatch_lines([\n+            \"*test_func*\"\n+        ])\n \n     def test_pytest_collect_file_from_sister_dir(self, testdir):\n         sub1 = testdir.mkpydir(\"sub1\")\n",
  "sphinx-doc__sphinx-10451": "",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..3edc575 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -65,7 +65,17 @@ def test_ZeroMatrix():\n     with raises(ShapeError):\n         Z**2\n \n-def test_ZeroMatrix_doit():\n+from sympy import Symbol, symbols, Sum\n+from sympy.matrices import MatrixSymbol, Identity\n+\n+def test_identity_matrix_element_sum():\n+    # Test to check if the sum of all elements of an identity matrix is `n`\n+    n = Symbol('n', integer=True, positive=True)\n+    i, j = symbols('i j', integer=True)\n+    In = Identity(n)\n+    \n+    # Assert that the sum of all elements equals `n`\n+    assert Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).doit() == n\n     Znn = ZeroMatrix(Add(n, n, evaluate=False), n)\n     assert isinstance(Znn.rows, Add)\n     assert Znn.doit() == ZeroMatrix(2*n, n)\n",
  "sympy__sympy-20049": "",
  "sympy__sympy-21612": ""
}