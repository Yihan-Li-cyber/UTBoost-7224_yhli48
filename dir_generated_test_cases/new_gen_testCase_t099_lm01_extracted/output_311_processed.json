{
  "astropy__astropy-12907": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 88711b0..a8ff7e0 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -134,8 +134,23 @@ def test_separable(compound_model, result):\n     assert_allclose(is_separable(compound_model), result[0])\n     assert_allclose(separability_matrix(compound_model), result[1])\n \n-\n-def test_custom_model_separable():\n+def test_nested_compound_models_separable():\n+    cm = sh1 & sh2\n+    nested_cm = rot & cm\n+\n+    expected_separability_matrix = np.array([\n+        [True, True, False, False],\n+        [True, True, False, False],\n+        [False, False, True, True],\n+        [False, False, True, True]\n+    ])\n+    \n+    separability_mat = separability_matrix(nested_cm)\n+    assert_allclose(separability_mat, expected_separability_matrix)\n+\n+    is_sep = is_separable(nested_cm)\n+    expected_is_separable = np.array([False, False, True, True])\n+    assert_allclose(is_sep, expected_is_separable, err_msg=\"Nested compound model separability incorrect.\")\n     @custom_model\n     def model_a(x):\n         return x\n",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..90dac3d 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,10 +1,36 @@\n+\n+def test_rst_with_header_rows():\n+    \"\"\"Round-trip a table with header_rows specified\"\"\"\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct     \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\",\n+    ]\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"wave\"].dtype == np.float64\n+    assert tbl[\"response\"].dtype == np.float32\n+    assert tbl[\"ints\"].dtype == np.int8\n+\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert out.getvalue().splitlines() == lines\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n from io import StringIO\n \n from astropy.io import ascii\n-\n-from .common import assert_almost_equal, assert_equal\n+import numpy as np\n+import astropy.units as u\n+from astropy.table import QTable\n+from io import StringIO\n \n \n def assert_equal_splitlines(arg1, arg2):\n",
  "astropy__astropy-14365": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 9b66109..a08853d 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -43,6 +43,65 @@ def test_get_tables_from_qdp_file(tmp_path):\n     assert np.isclose(table2[\"MJD_nerr\"][0], -2.37847222222222e-05)\n \n \n+import pytest\n+from astropy.io.ascii.qdp import _read_table_qdp, _write_table_qdp\n+from astropy.utils.exceptions import AstropyUserWarning\n+\n+def lowercase_header(value):\n+    \"\"\"Make every non-comment line lower case.\"\"\"\n+    lines = []\n+    for line in value.splitlines():\n+        if not line.startswith(\"!\"):\n+            line = line.lower()\n+        lines.append(line)\n+    return \"\\n\".join(lines)\n+\n+@pytest.mark.parametrize(\"lowercase\", [False, True])\n+def test_roundtrip_with_case_variation(tmp_path, lowercase):\n+    example_qdp = \"\"\"\n+    ! Swift/XRT hardness ratio of trigger: XXXX, name: BUBU X-2\n+    ! Columns are as labelled\n+    READ TERR 1\n+    READ SERR 2\n+    ! WT -- hard data\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   NO       0.212439\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   0.000000        0.000000\n+    NO NO NO NO NO\n+    ! WT -- soft data\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   0.726155        0.583890\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   2.410935        1.393592\n+    NO NO NO NO NO\n+    ! WT -- hardness ratio\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   -0.292553       -0.374935\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   0.000000        NO\n+    ! Add command, just to raise the warning.\n+    READ TERR 1\n+    ! WT -- whatever\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   -0.292553       -0.374935\n+    NO 1.14467592592593e-05    -1.14467592592593e-05   0.000000        NO\n+    \"\"\"\n+\n+    if lowercase:\n+        example_qdp = lowercase_header(example_qdp)\n+\n+    path = str(tmp_path / \"test.qdp\")\n+    with open(path, \"w\") as fp:\n+        print(example_qdp, file=fp)\n+\n+    with pytest.warns(AstropyUserWarning) as record:\n+        table = _read_table_qdp(path, names=[\"MJD\", \"Rate\"], table_id=0)\n+    assert np.any(\n+        [\n+            \"This file contains multiple command blocks\" in r.message.args[0]\n+            for r in record\n+        ]\n+    )\n+    assert np.allclose(table[\"MJD_perr\"], [2.378472e-05, 1.1446759e-05])\n+\n def test_roundtrip(tmp_path):\n     example_qdp = \"\"\"\n     ! Swift/XRT hardness ratio of trigger: XXXX, name: BUBU X-2\n",
  "astropy__astropy-14995": "diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py\nindex fc27f69..58d113d 100644\n--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py\n+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py\n@@ -28,7 +28,46 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n         return False\n \n \n-# Test with Data covers:\n+import pytest\n+import numpy as np\n+from astropy.nddata import NDDataRef\n+\n+def test_nddata_bitmask_arithmetic_issue():\n+    # Reproducing the scenario described in the issue\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_masked = NDDataRef(array, mask=mask)\n+\n+    # multiply no mask by constant (no mask * no mask)\n+    assert nref_nomask.multiply(1.0, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply no mask by itself (no mask * no mask)\n+    assert nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply masked by constant (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(1.0, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by itself (mask * mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_masked, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by no mask (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_nomask, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # check bitwise logic still works\n+    other_mask = np.array([[64, 1, 0], [2, 1, 0], [8, 0, 2]])\n+    nref_mask_other = NDDataRef(array, mask=other_mask)\n+    np.testing.assert_equal(\n+        nref_mask_other.multiply(nref_masked, handle_mask=np.bitwise_or).mask,\n+        np.bitwise_or(mask, other_mask),\n+    )\n # scalars, 1D, 2D and 3D\n # broadcasting between them\n @pytest.mark.filterwarnings(\"ignore:divide by zero encountered.*\")\n",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..421f462 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -246,8 +246,17 @@ class TestTableFunctions(FitsTestCase):\n         t[1].data.field('c4')[0] = 1\n         t[1].data._scale_back()\n         assert str(np.rec.recarray.field(t[1].data, 'c4')) == '[84 84]'\n-\n-        # look at data column-wise\n+        # Test for 'D' exponent conversion to 'E' in floating point numbers\n+        r1 = np.array([4.95652173, 7.45678])\n+        c2 = fits.Column(name='def', format='D', array=r1)\n+        hdu = fits.TableHDU.from_columns([c2])\n+        hdu.writeto(self.temp('test_exponent_conversion.fits'), overwrite=True)\n+\n+        # Verify 'D' exponents have been converted to 'E' in the output file\n+        with open(self.temp('test_exponent_conversion.fits'), 'rb') as f:\n+            content = f.read()\n+            assert b'4.95652173E+00' in content or b'4.95652173D+00' in content\n+            assert b'7.45678E+00' in content or b'7.45678D+00' in content\n         assert (t[1].data.field(0) == np.array([1, 2])).all()\n \n         # When there are scaled columns, the raw data are in data._parent\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..ca138b7 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1093,13 +1093,20 @@ class OverrideSettingsTests(SimpleTestCase):\n         with self.settings(MEDIA_URL='/test_value/'):\n             self.assertEqual(default_storage.base_url, '/test_value/')\n \n-    def test_override_file_upload_permissions(self):\n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        Test that FILE_UPLOAD_PERMISSIONS has a default value of 0o644\n+        in django.core.files.storage.default_storage.\n+        \"\"\"\n+        with self.settings(FILE_UPLOAD_PERMISSIONS=None):\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n         \"\"\"\n         Overriding the FILE_UPLOAD_PERMISSIONS setting should be reflected in\n         the file_permissions_mode attribute of\n         django.core.files.storage.default_storage.\n         \"\"\"\n         self.assertIsNone(default_storage.file_permissions_mode)\n+        self.assertEqual(default_storage.file_permissions_mode, 0o644)\n         with self.settings(FILE_UPLOAD_PERMISSIONS=0o777):\n             self.assertEqual(default_storage.file_permissions_mode, 0o777)\n \n",
  "django__django-10924": "",
  "django__django-11001": "",
  "django__django-11039": "",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..c31373f 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -65,8 +65,33 @@ class TestSerialization(SimpleTestCase):\n         self.assertEqual(instance.field, datetime.timedelta(days=1, hours=1))\n \n \n+from django.core import exceptions\n+\n class TestValidation(SimpleTestCase):\n \n+    ...\n+\n+    def test_invalid_format(self):\n+        field = models.DurationField()\n+        # Test various incorrect formats\n+        incorrect_inputs = [\n+            '14:00',  # \"00:14:00\" (14 minutes) but needs seconds\n+            '14',     # Must have seconds\n+            '1:23:45.1234567',  # Too many microseconds\n+            '1:60:00',  # Invalid minute\n+            '24:00:00',  # Not a valid hour (unless as total duration)\n+            '01:2:3'   # Incorrect format\n+        ]\n+        expected_message = \"'%s' value has an invalid format. It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n+        for input_str in incorrect_inputs:\n+            with self.assertRaises(exceptions.ValidationError) as cm:\n+                field.clean(input_str, None)\n+            \n+            self.assertEqual(\n+                cm.exception.message % cm.exception.params,\n+                expected_message % input_str\n+            )\n+\n     def test_invalid_string(self):\n         field = models.DurationField()\n         with self.assertRaises(exceptions.ValidationError) as cm:\n@@ -75,7 +100,7 @@ class TestValidation(SimpleTestCase):\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n             \"'not a datetime' value has an invalid format. \"\n-            \"It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n         )\n \n \n@@ -84,4 +109,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..70dfba4 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -238,6 +238,8 @@ class UsernameValidatorsTests(SimpleTestCase):\n             \"o'connell\", \"\u0639\u0628\u062f \u0627\u0644\",\n             \"zerowidth\\u200Bspace\", \"nonbreaking\\u00A0space\",\n             \"en\\u2013dash\",\n+            'trailingnewline\\n',  # Added testcase for trailing newline\n+            'trailingunicodenewline\\u000A',  # Additional newline character in unicode\n         ]\n         v = validators.UnicodeUsernameValidator()\n         for valid in valid_usernames:\n@@ -250,7 +252,10 @@ class UsernameValidatorsTests(SimpleTestCase):\n \n     def test_ascii_validator(self):\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n-        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n+        invalid_usernames = [\n+            \"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\",\n+            'trailingnewline\\n',  # Added testcase for trailing newline\n+        ]\n         v = validators.ASCIIUsernameValidator()\n         for valid in valid_usernames:\n             with self.subTest(valid=valid):\n@@ -258,4 +263,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..cb817ca 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -366,7 +366,23 @@ class HttpResponseTests(unittest.TestCase):\n         r.content = 12345\n         self.assertEqual(r.content, b'12345')\n \n-    def test_iter_content(self):\n+    def test_memoryview_content(self):\n+        # Test memoryview content directly in HttpResponse\n+        r = HttpResponse(memoryview(b'memoryview'))\n+        self.assertEqual(r.content, b'memoryview')\n+\n+        # Test memoryview content set via the property\n+        r = HttpResponse()\n+        r.content = memoryview(b'memoryview_content_property')\n+        self.assertEqual(r.content, b'memoryview_content_property')\n+\n+        # Test empty memoryview content\n+        r = HttpResponse(memoryview(b''))\n+        self.assertEqual(r.content, b'')\n+\n+        # Test memoryview object of non-bytes type\n+        r = HttpResponse(memoryview(bytearray(b'bytearray_memoryview')))\n+        self.assertEqual(r.content, b'bytearray_memoryview')\n         r = HttpResponse(['abc', 'def', 'ghi'])\n         self.assertEqual(r.content, b'abcdefghi')\n \n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..466a28c 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,6 +1,8 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n+from django.db.models.deletion import Collector\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n@@ -464,7 +466,12 @@ class FastDeleteTests(TestCase):\n         # 1 to delete t, 1 to fast-delete t's m_set\n         self.assertNumQueries(2, f.delete)\n \n-    def test_fast_delete_qs(self):\n+    def test_fast_delete_instance_set_pk_none(self):\n+        u = User.objects.create()\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        u.delete()\n+        self.assertIsNone(u.pk)\n         u1 = User.objects.create()\n         u2 = User.objects.create()\n         self.assertNumQueries(1, User.objects.filter(pk=u1.pk).delete)\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..9429c29 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,3 +1,4 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n@@ -6,6 +7,7 @@ from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n \n from .models import Proxy, UserProxy\n+from django.db.utils import IntegrityError\n \n update_proxy_permissions = import_module('django.contrib.auth.migrations.0011_update_proxy_permissions')\n \n@@ -140,6 +142,32 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n+    def test_migrate_with_existing_target_permission(self):\n+        \"\"\"\n+        Permissions may already exist:\n+\n+        - Old workaround was to manually create permissions for proxy models.\n+        - Model may have been concrete and then converted to proxy.\n+\n+        Verify that the migration does not fail when permissions already exist.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='display_proxys',\n+            name='May display proxys information',\n+        )\n+        try:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+            update_proxy_permissions.revert_proxy_model_permissions(apps, None)\n+        except IntegrityError as e:\n+            self.fail(f\"Migration failed with IntegrityError: {e}\")\n+\n     def test_user_keeps_same_permissions_after_migrating_backward(self):\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..01a942c 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -9,6 +9,7 @@ import time\n import types\n import weakref\n import zipfile\n+import os\n from importlib import import_module\n from pathlib import Path\n from unittest import mock, skip, skipIf\n",
  "django__django-11583": "",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..e8fd1bc 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -18,7 +18,8 @@ from django.test import RequestFactory, SimpleTestCase, override_settings\n from django.test.utils import LoggingCaptureMixin\n from django.urls import path, reverse\n from django.utils.functional import SimpleLazyObject\n-from django.utils.safestring import mark_safe\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n from django.views.debug import (\n     CLEANSED_SUBSTITUTE, CallableSettingWrapper, ExceptionReporter,\n     Path as DebugPath, cleanse_setting, default_urlconf,\n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..e152de6 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -334,8 +334,42 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n-    @unittest.skipUnless(connection.vendor == 'mysql',\n-                         \"Test valid only for MySQL\")\n+    def test_choices_exceeding_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2, choices=[\n+                    ('TOO_LONG', 'Value too long'),\n+                    ('OK', 'Alright')\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in \"\n+                \"'choices' (8 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_nested_choices_exceeding_max_length(self):\n+        class Model(models.Model):\n+            group = models.CharField(\n+                max_length=5, choices=[\n+                    ('Category1', (('OK', 'Fine'), ('TOO_LONG', 'Value too long'))),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('group')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in \"\n+                \"'choices' (8 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n     def test_too_long_char_field_under_mysql(self):\n         from django.db.backends.mysql.validation import DatabaseValidation\n \n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..39d8f42 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -247,7 +247,20 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set())\n         )\n \n-    def test_serialize_lazy_objects(self):\n+    def test_serialize_enum_default_name(self):\n+        class Status(enum.Enum):\n+            GOOD = _('Good')  # 'Good' will be translated\n+            BAD = _('Bad')    # 'Bad' will be translated\n+\n+        field = models.CharField(\n+            default=Status.GOOD, \n+            max_length=128,\n+        )\n+        serialized_field = MigrationWriter().serialize(field)[0]\n+        expected_serialization = (\n+            \"models.CharField(default=tests.migrations.test_writer.Status['GOOD'], max_length=128)\"\n+        )\n+        self.assertEqual(serialized_field, expected_serialization)\n         pattern = re.compile(r'^foo$')\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..78f1444 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,5 +1,6 @@\n+\n import unittest\n-from datetime import datetime\n+from datetime import datetime, timedelta\n \n from django.test import SimpleTestCase, ignore_warnings\n from django.utils.datastructures import MultiValueDict\n@@ -307,7 +308,38 @@ class ETagProcessingTests(unittest.TestCase):\n         self.assertEqual(quote_etag('W/\"etag\"'), 'W/\"etag\"')  # quoted, weak\n \n \n+from unittest import mock\n+\n class HttpDateProcessingTests(unittest.TestCase):\n+\n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850_with_full_coverage(self, mocked_datetime):\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+        \n+        # Define several current times to test the logic.\n+        current_time_2023 = datetime(2023, 1, 1)\n+        current_time_2050 = datetime(2050, 1, 1)\n+        future_time_2073 = datetime(2073, 1, 1)\n+\n+        # Define test scenarios\n+        tests = [\n+            # current year is 2023\n+            (current_time_2023, 'Saturday, 01-Jan-70 00:00:00 GMT', datetime(1970, 1, 1, 0, 0, 0)),\n+            (current_time_2023, 'Sunday, 01-Jan-22 00:00:00 GMT', datetime(2022, 1, 1, 0, 0, 0)),\n+            # shifting the current year to 2050\n+            (current_time_2050, 'Friday, 01-Jan-99 00:00:00 GMT', datetime(1999, 1, 1, 0, 0, 0)),\n+            (current_time_2050, 'Tuesday, 01-Jan-50 00:00:00 GMT', datetime(2050, 1, 1, 0, 0, 0)),\n+            # the year might appear in the future\n+            (future_time_2073, 'Friday, 01-Jan-23 00:00:00 GMT', datetime(2023, 1, 1, 0, 0, 0)),\n+            (future_time_2073, 'Monday, 01-Jan-74 00:00:00 GMT', datetime(1974, 1, 1, 0, 0, 0)),\n+        ]\n+\n+        for current_time, rfc850_date, expected_date in tests:\n+            with self.subTest(rfc850_date=rfc850_date):\n+                mocked_datetime.utcnow.return_value = current_time\n+                parsed = parse_http_date(rfc850_date)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n     def test_http_date(self):\n         t = 1167616461.0\n         self.assertEqual(http_date(t), 'Mon, 01 Jan 2007 01:54:21 GMT')\n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..a6dfa39 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -40,7 +40,30 @@ class Gender(models.TextChoices):\n     __empty__ = '(Undeclared)'\n \n \n-class ChoicesTests(SimpleTestCase):\n+from django.test import TestCase\n+from django.db import models\n+\n+# A simple enum class to demonstrate the enum behavior\n+class ExampleChoices(models.TextChoices):\n+    CHOICE_ONE = 'one', 'Choice One'\n+    CHOICE_TWO = 'two', 'Choice Two'\n+\n+# A simple model to test the enum field behaviors\n+class ExampleModel(models.Model):\n+    choice_field = models.CharField(max_length=10, choices=ExampleChoices.choices)\n+\n+class ChoicesTests(SimpleTestCase, TestCase):\n+    def setUp(self):\n+        self.obj = ExampleModel.objects.create(choice_field=ExampleChoices.CHOICE_ONE)\n+\n+    def test_created_object_field_type(self):\n+        self.assertIsInstance(self.obj.choice_field, str)\n+        self.assertEqual(self.obj.choice_field, 'one')\n+\n+    def test_retrieved_object_field_type(self):\n+        retrieved_obj = ExampleModel.objects.get(pk=self.obj.pk)\n+        self.assertIsInstance(retrieved_obj.choice_field, str)\n+        self.assertEqual(retrieved_obj.choice_field, 'one')\n     def test_integerchoices(self):\n         self.assertEqual(Suit.choices, [(1, 'Diamond'), (2, 'Spade'), (3, 'Heart'), (4, 'Club')])\n         self.assertEqual(Suit.labels, ['Diamond', 'Spade', 'Heart', 'Club'])\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..8eb5242 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -162,7 +162,18 @@ class GetFieldDisplayTests(SimpleTestCase):\n         self.assertEqual(Whiz(c='').get_c_display(), '')        # Empty value\n         self.assertEqual(WhizDelayed(c=0).get_c_display(), 'Other')  # Delayed choices\n \n-    def test_get_FIELD_display_translated(self):\n+    def test_overriding_FIELD_display(self):\n+        \"\"\"\n+        Test that overriding get_FIELD_display() works correctly.\n+        \"\"\"\n+        class FooBar(models.Model):\n+            foo_bar = models.IntegerField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                return 'something'\n+\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), 'something')\n         \"\"\"A translated display value is coerced to str.\"\"\"\n         val = Whiz(c=5).get_c_display()\n         self.assertIsInstance(val, str)\n",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "diff --git a/tests/urlpatterns/tests.py b/tests/urlpatterns/tests.py\nindex 7b8648d..1d3d815 100644\n--- a/tests/urlpatterns/tests.py\n+++ b/tests/urlpatterns/tests.py\n@@ -68,6 +68,23 @@ class SimplifiedURLTests(SimpleTestCase):\n                     r'^regex_optional/(?P<arg1>\\d+)/(?:(?P<arg2>\\d+)/)?',\n                 )\n \n+    def test_re_path_module_format(self):\n+        # Verify handling of optional 'format' in the URL pattern.\n+        for url, expected_kwargs in (\n+            ('/module/', {'format': 'html'}), # Default format when missing\n+            ('/module/html/', {'format': 'html'}),\n+            ('/module/json/', {'format': 'json'}),\n+            ('/module/xml/', {'format': 'xml'}),\n+        ):\n+            with self.subTest(url=url):\n+                match = resolve(url)\n+                self.assertEqual(match.url_name, 'modules')\n+                self.assertEqual(match.kwargs, expected_kwargs)\n+                self.assertEqual(\n+                    match.route,\n+                    r'^module/(?P<format>(html|json|xml))?/?$'\n+                )\n+\n     def test_path_lookup_with_inclusion(self):\n         match = resolve('/included_urls/extra/something/')\n         self.assertEqual(match.url_name, 'inner-extra')\n",
  "django__django-12284": "",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..39d79c6 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,8 +1,10 @@\n+\n from django.core.checks import Error\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n     check_setting_languages, check_setting_languages_bidi,\n )\n+from django.test import override_settings\n from django.test import SimpleTestCase\n \n \n@@ -75,6 +77,30 @@ class TranslationCheckTests(SimpleTestCase):\n                     Error(msg % tag, id='translation.E003'),\n                 ])\n \n+    def test_sublanguage_checks_valid_language_code(self):\n+        \"\"\"Test that no error is raised if a sublanguage falls back to a base language.\"\"\"\n+        with self.settings(\n+            LANGUAGE_CODE='de-at',\n+            LANGUAGES=[\n+                ('de', 'German'),\n+                ('es', 'Spanish'),\n+                ('fr', 'French'),\n+                ('en', 'English')\n+            ]\n+        ):\n+            self.assertEqual(check_language_settings_consistent(None), [])\n+\n+        with self.settings(\n+            LANGUAGE_CODE='pt-BR',\n+            LANGUAGES=[\n+                ('pt', 'Portuguese'),\n+                ('es', 'Spanish'),\n+                ('fr', 'French'),\n+                ('en', 'English')\n+            ]\n+        ):\n+            self.assertEqual(check_language_settings_consistent(None), [])\n+\n     def test_inconsistent_language_settings(self):\n         msg = (\n             'You have provided a value for the LANGUAGE_CODE setting that is '\n",
  "django__django-12308": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex acbcf33..1baf116 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -175,8 +175,22 @@ class UtilsTests(SimpleTestCase):\n \n         display_value = display_for_field(None, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, self.empty_value)\n-\n-    def test_number_formats_display_for_field(self):\n+    def test_json_display_for_field_readonly(self):\n+        tests = [\n+            ({\"foo\": \"bar\"}, '{\"foo\": \"bar\"}'),\n+            ({\"a\": {\"b\": \"c\"}}, '{\"a\": {\"b\": \"c\"}}'),\n+            ([\"a\", \"b\"], '[\"a\", \"b\"]'),\n+            (\"a\", '\"a\"'),\n+            # This is an edge case, displaying a tuple key, which\n+            # is not a valid JSON, hence handled as a string.\n+            ({(\"a\", \"b\"): \"c\"}, '{(\"a\", \"b\"): \"c\"}'),\n+        ]\n+        for value, display_value in tests:\n+            with self.subTest(value=value):\n+                self.assertEqual(\n+                    display_for_field(value, models.JSONField(), self.empty_value),\n+                    display_value,\n+                )\n         display_value = display_for_field(12345.6789, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, '12345.6789')\n \n",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..b751592 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from unittest import mock\n \n@@ -5,7 +6,8 @@ from django.db import DEFAULT_DB_ALIAS, connection, connections\n from django.db.backends.base.creation import (\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, TransactionTestCase\n+from ..models import Object, ObjectReference\n \n \n def get_connection_copy():\n",
  "django__django-12497": "diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 057ec3a..61042b4 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -159,7 +159,33 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n-    def test_relationship_model_with_foreign_key_to_wrong_model(self):\n+    def test_correct_hint_for_recursive_relationship(self):\n+        class Person(models.Model):\n+            pass\n+\n+        class Group(models.Model):\n+            relationships = models.ManyToManyField('self', through='AmbiguousRelationship')\n+\n+        class AmbiguousRelationship(models.Model):\n+            group1 = models.ForeignKey(Group, models.CASCADE, related_name='group1')\n+            group2 = models.ForeignKey(Group, models.CASCADE, related_name='group2')\n+\n+        field = Group._meta.get_field('relationships')\n+        self.assertEqual(field.check(from_model=Group), [\n+            Error(\n+                \"The model is used as an intermediate model by \"\n+                \"'invalid_models_tests.Group.relationships', but it has more than one \"\n+                \"foreign key from 'Group', which is ambiguous. You must \"\n+                \"specify which foreign key Django should use via the \"\n+                \"through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"AmbiguousRelationship\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n         class WrongModel(models.Model):\n             pass\n \n",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..eba1d7b 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1241,6 +1241,40 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleansed_substitute,\n         )\n \n+    def test_cleanse_setting_with_nested_lists(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            'outer': [\n+                {'nested_secret': 'secret_value', 'nested_token': 'token_value'},\n+                [\n+                    {'deeper_nested_secret': 'secret_value'},\n+                    'normal_value',\n+                ],\n+                ('tuple_secret', {'tuple_token': 'token_value'}),\n+                'normal_string'\n+            ],\n+            'another_ordinary_key': 'ordinary_value'\n+        }\n+        cleansed = {\n+            'outer': [\n+                {\n+                    'nested_secret': reporter_filter.cleansed_substitute,\n+                    'nested_token': reporter_filter.cleansed_substitute,\n+                },\n+                [\n+                    {'deeper_nested_secret': reporter_filter.cleansed_substitute},\n+                    'normal_value',\n+                ],\n+                ('tuple_secret', {'tuple_token': reporter_filter.cleansed_substitute}),\n+                'normal_string'\n+            ],\n+            'another_ordinary_key': 'ordinary_value'\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+\n     def test_cleanse_setting_recurses_in_dictionary(self):\n         reporter_filter = SafeExceptionReporterFilter()\n         initial = {'login': 'cooper', 'password': 'secret'}\n@@ -1249,6 +1283,40 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n \n+    def test_cleanse_setting_with_nested_lists(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            'outer': [\n+                {'nested_secret': 'secret_value', 'nested_token': 'token_value'},\n+                [\n+                    {'deeper_nested_secret': 'secret_value'},\n+                    'normal_value',\n+                ],\n+                ('tuple_secret', {'tuple_token': 'token_value'}),\n+                'normal_string'\n+            ],\n+            'another_ordinary_key': 'ordinary_value'\n+        }\n+        cleansed = {\n+            'outer': [\n+                {\n+                    'nested_secret': reporter_filter.cleansed_substitute,\n+                    'nested_token': reporter_filter.cleansed_substitute,\n+                },\n+                [\n+                    {'deeper_nested_secret': reporter_filter.cleansed_substitute},\n+                    'normal_value',\n+                ],\n+                ('tuple_secret', {'tuple_token': reporter_filter.cleansed_substitute}),\n+                'normal_string'\n+            ],\n+            'another_ordinary_key': 'ordinary_value'\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+\n     def test_request_meta_filtering(self):\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n@@ -1257,6 +1325,40 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleansed_substitute,\n         )\n \n+    def test_cleanse_setting_with_nested_lists(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            'outer': [\n+                {'nested_secret': 'secret_value', 'nested_token': 'token_value'},\n+                [\n+                    {'deeper_nested_secret': 'secret_value'},\n+                    'normal_value',\n+                ],\n+                ('tuple_secret', {'tuple_token': 'token_value'}),\n+                'normal_string'\n+            ],\n+            'another_ordinary_key': 'ordinary_value'\n+        }\n+        cleansed = {\n+            'outer': [\n+                {\n+                    'nested_secret': reporter_filter.cleansed_substitute,\n+                    'nested_token': reporter_filter.cleansed_substitute,\n+                },\n+                [\n+                    {'deeper_nested_secret': reporter_filter.cleansed_substitute},\n+                    'normal_value',\n+                ],\n+                ('tuple_secret', {'tuple_token': reporter_filter.cleansed_substitute}),\n+                'normal_string'\n+            ],\n+            'another_ordinary_key': 'ordinary_value'\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+\n     def test_exception_report_uses_meta_filtering(self):\n         response = self.client.get('/raises500/', HTTP_SECRET_HEADER='super_secret')\n         self.assertNotIn(b'super_secret', response.content)\n@@ -1265,6 +1367,40 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             HTTP_SECRET_HEADER='super_secret',\n             HTTP_ACCEPT='application/json',\n         )\n+\n+    def test_cleanse_setting_with_nested_lists(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            'outer': [\n+                {'nested_secret': 'secret_value', 'nested_token': 'token_value'},\n+                [\n+                    {'deeper_nested_secret': 'secret_value'},\n+                    'normal_value',\n+                ],\n+                ('tuple_secret', {'tuple_token': 'token_value'}),\n+                'normal_string'\n+            ],\n+            'another_ordinary_key': 'ordinary_value'\n+        }\n+        cleansed = {\n+            'outer': [\n+                {\n+                    'nested_secret': reporter_filter.cleansed_substitute,\n+                    'nested_token': reporter_filter.cleansed_substitute,\n+                },\n+                [\n+                    {'deeper_nested_secret': reporter_filter.cleansed_substitute},\n+                    'normal_value',\n+                ],\n+                ('tuple_secret', {'tuple_token': reporter_filter.cleansed_substitute}),\n+                'normal_string'\n+            ],\n+            'another_ordinary_key': 'ordinary_value'\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n         self.assertNotIn(b'super_secret', response.content)\n \n \n",
  "django__django-12708": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 2df48a2..503e2a9 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1759,7 +1759,37 @@ class OperationTests(OperationTestBase):\n         operation = migrations.AlterIndexTogether(\"Pony\", None)\n         self.assertEqual(operation.describe(), \"Alter index_together for Pony (0 constraint(s))\")\n \n-    @skipUnlessDBFeature('supports_table_check_constraints')\n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_alter_index_together_with_unique_together(self):\n+        app_label = 'test_alintoremove_wunto_ext'\n+        table_name = '%s_pony' % app_label\n+        \n+        # Set up initial model state\n+        project_state = self.set_up_test_model(app_label, unique_together=True)\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+        \n+        # Add index together\n+        new_state = project_state.clone()\n+        add_index_operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])\n+        add_index_operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            add_index_operation.database_forwards(app_label, editor, project_state, new_state)\n+        \n+        # Assert both unique_together and index_together exist\n+        self.assertIndexExists(table_name, ['pink', 'weight'])\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+        \n+        # Remove index together\n+        project_state = new_state\n+        new_state = project_state.clone()\n+        remove_index_operation = migrations.AlterIndexTogether('Pony', set())\n+        remove_index_operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            remove_index_operation.database_forwards(app_label, editor, project_state, new_state)\n+        \n+        # Assert unique_together still exists, but index_together is removed\n+        self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n     def test_add_constraint(self):\n         project_state = self.set_up_test_model(\"test_addconstraint\")\n         gt_check = models.Q(pink__gt=2)\n",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..c678de1 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -697,7 +697,31 @@ class FastDeleteTests(TestCase):\n                 (0, {'delete.User': 0})\n             )\n \n-    def test_fast_delete_combined_relationships(self):\n+    def test_zero_deletions_consistent_output(self):\n+        \"\"\"\n+        QuerySet.delete() should return a consistent result format when zero\n+        objects are deleted, regardless of whether the model has foreign keys\n+        or not.\n+        \"\"\"\n+        # Test a model with no foreign keys\n+        existed_objs = {\n+            'my_app.SimpleModel': SimpleModel.objects.count(),\n+        }\n+        deleted, deleted_objs = SimpleModel.objects.all().delete()\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {'my_app.SimpleModel': 0})\n+\n+        # Test a model with foreign keys\n+        existed_objs = {\n+            'my_app.ComplexModel': ComplexModel.objects.count(),\n+            'my_app.RelatedModel': RelatedModel.objects.count(),\n+        }\n+        deleted, deleted_objs = ComplexModel.objects.all().delete()\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {\n+            'my_app.ComplexModel': 0,\n+            'my_app.RelatedModel': 0,\n+        })\n         # The cascading fast-delete of SecondReferrer should be combined\n         # in a single DELETE WHERE referrer_id OR unique_field.\n         origin = Origin.objects.create()\n",
  "django__django-12856": "",
  "django__django-12915": "diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex 72f5bd1..385deaa 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -79,6 +79,36 @@ class ASGITest(SimpleTestCase):\n         # Allow response.close() to finish.\n         await communicator.wait()\n \n+    async def test_static_file_not_found(self):\n+        # Test to ensure a proper 404 response when a static file does not exist.\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        scope = self.async_request_factory._base_scope(path='/static/does-not-exist.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 404)\n+\n+    async def test_static_file_headers(self):\n+        # Test that static files are served with the correct headers.\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        file_path = TEST_STATIC_ROOT / 'file.txt'\n+        scope = self.async_request_factory._base_scope(path='/static/file.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        stat = file_path.stat()\n+        expected_headers = {\n+            (b'Content-Length', str(stat.st_size).encode('ascii')),\n+            (b'Content-Type', b'text/plain'),\n+            (b'Content-Disposition', b'inline; filename=\"%s\"' % file_path.name.encode('ascii')),\n+            (b'Last-Modified', http_date(stat.st_mtime).encode('ascii')),\n+        }\n+        result_headers = set(response_start['headers'])\n+        self.assertTrue(expected_headers.issubset(result_headers))\n+\n     async def test_headers(self):\n         application = get_asgi_application()\n         communicator = ApplicationCommunicator(\n",
  "django__django-12983": "",
  "django__django-13028": "",
  "django__django-13158": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 070e08e..d193c8a 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -1,3 +1,4 @@\n+\n import operator\n \n from django.db import DatabaseError, NotSupportedError, connection\n@@ -86,6 +87,40 @@ class QuerySetSetOperationTests(TestCase):\n         reserved_name = qs1.difference(qs2).values_list('name', 'order', 'id').get()\n         self.assertEqual(reserved_name[:2], ('a', 2))\n \n+    def test_form_with_combined_queryset_union(self):\n+        # Test form with ManyToMany field using a combined queryset through union\n+\n+        class Publication(models.Model):\n+            title = models.CharField(max_length=100)\n+\n+        class Article(models.Model):\n+            title = models.CharField(max_length=100)\n+            publications = models.ManyToManyField(Publication, blank=True, null=True)\n+\n+        # Create some publications\n+        Publication.objects.create(title='Publication 1')\n+        Publication.objects.create(title='Publication 2')\n+        Publication.objects.create(title='Publication 3')\n+        Publication.objects.create(title='Publication 4')\n+        Publication.objects.create(title='Publication 5')\n+        Publication.objects.create(title='Publication 6')\n+\n+        class ArticleForm(forms.ModelForm):\n+            publications = forms.ModelMultipleChoiceField(\n+                queryset=Publication.objects.filter(id__lt=2).union(Publication.objects.filter(id__gt=5)),\n+                required=False,\n+            )\n+\n+            class Meta:\n+                model = Article\n+                fields = [\"publications\"]\n+\n+        form = ArticleForm(data={})\n+\n+        self.assertTrue(form.is_valid())\n+        article = form.save()\n+        self.assertEqual(article.publications.count(), 0)\n+\n     def test_union_with_empty_qs(self):\n         qs1 = Number.objects.all()\n         qs2 = Number.objects.none()\n@@ -313,4 +348,4 @@ class QuerySetSetOperationTests(TestCase):\n                         NotSupportedError,\n                         msg % (operation, combinator),\n                     ):\n-                        getattr(getattr(qs, combinator)(qs), operation)()\n+                        getattr(getattr(qs, combinator)(qs), operation)()\n",
  "django__django-13230": "",
  "django__django-13315": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 64b15bf..de01004 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2830,7 +2830,81 @@ class LimitChoicesToTests(TestCase):\n             self.assertEqual(today_callable_dict.call_count, 3)\n \n \n-class FormFieldCallbackTests(SimpleTestCase):\n+from django.db import models\n+from django import forms\n+from django.test import TestCase\n+from .models import Character, StumpJoke\n+\n+class FormFieldDuplicateOptionsTests(TestCase):\n+\n+    def setUp(self):\n+        self.threepwood = Character.objects.create(username=\"Threepwood\", last_action=\"2023-09-01\")\n+        self.marley = Character.objects.create(username=\"Marley\", last_action=\"2023-09-01\")\n+\n+    def test_limit_choices_to_no_duplicates(self):\n+        joke1 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.threepwood,\n+        )\n+        joke2 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.threepwood,\n+        )\n+        joke3 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.marley,\n+        )\n+        StumpJoke.objects.create(funny=False, most_recently_fooled=self.marley)\n+        joke1.has_fooled_today.add(self.marley, self.threepwood)\n+        joke2.has_fooled_today.add(self.marley)\n+        joke3.has_fooled_today.add(self.marley, self.threepwood)\n+\n+        class CharacterDetails(models.Model):\n+            character1 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_fk_1',\n+            )\n+            character2 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to={\n+                    'jokes__funny': True,\n+                    'jokes_today__funny': True,\n+                },\n+                related_name='details_fk_2',\n+            )\n+            character3 = models.ManyToManyField(\n+                Character,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_m2m_1',\n+            )\n+\n+        class CharacterDetailsForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetails\n+                fields = '__all__'\n+\n+        form = CharacterDetailsForm()\n+        self.assertCountEqual(\n+            form.fields['character1'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character2'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character3'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n \n     def test_baseform_with_widgets_in_meta(self):\n         \"\"\"Regression for #13095: Using base forms with widgets defined in Meta should not raise errors.\"\"\"\n",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 536c423..0ae2724 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -8,8 +8,43 @@ from django.db import models\n from django.test import SimpleTestCase\n from django.test.utils import isolate_apps\n \n+import pickle\n+from django.db.models import IntegerField\n+from django.test import TestCase, SimpleTestCase, override_settings\n+class FieldEqualityTests(TestCase):\n+    def test_abstract_inherited_fields_equality(self):\n+        \"\"\"Field instances from different concrete models inheriting from abstract are not equal.\"\"\"\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritAbstractModel1(AbstractModel):\n+            pass\n+\n+        class InheritAbstractModel2(AbstractModel):\n+            pass\n+\n+        abstract_model_field = AbstractModel._meta.get_field('field')\n+        inherit1_model_field = InheritAbstractModel1._meta.get_field('field')\n+        inherit2_model_field = InheritAbstractModel2._meta.get_field('field')\n+\n+        # Assert that fields from different concrete models are not equal\n+        self.assertNotEqual(abstract_model_field, inherit1_model_field)\n+        self.assertNotEqual(abstract_model_field, inherit2_model_field)\n+        self.assertNotEqual(inherit1_model_field, inherit2_model_field)\n+\n+        # Assert that hashing these fields produces different results\n+        self.assertNotEqual(hash(abstract_model_field), hash(inherit1_model_field))\n+        self.assertNotEqual(hash(abstract_model_field), hash(inherit2_model_field))\n+        self.assertNotEqual(hash(inherit1_model_field), hash(inherit2_model_field))\n+\n+        # Assert proper ordering, if __lt__ is implemented\n+        self.assertLess(abstract_model_field.creation_counter, inherit1_model_field.creation_counter)\n+        self.assertLess(abstract_model_field.creation_counter, inherit2_model_field.creation_counter)\n+        self.assertLess(inherit1_model_field.creation_counter, inherit2_model_field.creation_counter)\n \n-@isolate_apps('model_inheritance')\n class AbstractInheritanceTests(SimpleTestCase):\n     def test_single_parent(self):\n         class AbstractBase(models.Model):\n@@ -347,4 +382,4 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('age', models.SmallIntegerField), ('concretemodel2_ptr', models.OneToOneField),\n                 ('name', models.CharField),\n             ]\n-        )\n+        )\n",
  "django__django-13447": "diff --git a/tests/admin_views/test_adminsite.py b/tests/admin_views/test_adminsite.py\nindex 16a02bb..1726654 100644\n--- a/tests/admin_views/test_adminsite.py\n+++ b/tests/admin_views/test_adminsite.py\n@@ -73,6 +73,31 @@ class SiteEachContextTest(TestCase):\n         self.assertIs(user['perms']['delete'], True)\n         self.assertEqual(user['admin_url'], '/test_admin/admin/auth/user/')\n         self.assertEqual(user['add_url'], '/test_admin/admin/auth/user/add/')\n+\n+    def test_app_list_contains_model_class(self):\n+        ctx = self.ctx\n+        apps = ctx['available_apps']\n+        # Verify that the model class is added to the model dictionaries.\n+        \n+        # admin_views.Article\n+        article = apps[0]['models'][0]\n+        self.assertEqual(article['object_name'], 'Article')\n+        self.assertEqual(article['model'], Article)\n+        \n+        # auth.User\n+        user = apps[1]['models'][0]\n+        self.assertEqual(user['object_name'], 'User')\n+        self.assertEqual(user['model'], User)\n+\n+    def test_build_app_dict_is_public(self):\n+        # Checking if _build_app_dict is accessible and works as expected\n+        request = self.factory.get('/')\n+        app_dict = self.site._build_app_dict(request)\n+        self.assertIsInstance(app_dict, dict)\n+        self.assertIn('admin_views', app_dict)\n+        self.assertIn('auth', app_dict)\n+        self.assertIn('models', app_dict['admin_views'])\n+        self.assertGreaterEqual(len(app_dict['admin_views']['models']), 1)\n         self.assertEqual(user['name'], 'Users')\n \n \n",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..e1edcdb 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,8 +1,10 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n from django.contrib.auth.models import User\n from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from .models import CustomEmailField\n from django.test import TestCase\n from django.test.utils import ignore_warnings\n from django.utils.deprecation import RemovedInDjango40Warning\n@@ -37,7 +39,26 @@ class TokenGeneratorTest(TestCase):\n         tk2 = p0.make_token(user_reload)\n         self.assertEqual(tk1, tk2)\n \n-    def test_timeout(self):\n+    def test_token_with_different_email(self):\n+        \"\"\"Updating the user email address invalidates the token.\"\"\"\n+        tests = [\n+            (CustomEmailField, None),\n+            (CustomEmailField, 'test4@example.com'),\n+            (User, 'test4@example.com'),\n+        ]\n+        for model, email in tests:\n+            with self.subTest(model=model.__qualname__, email=email):\n+                user = model.objects.create_user(\n+                    'changeemailuser',\n+                    email=email,\n+                    password='testpw',\n+                )\n+                p0 = PasswordResetTokenGenerator()\n+                tk1 = p0.make_token(user)\n+                self.assertIs(p0.check_token(user, tk1), True)\n+                setattr(user, user.get_email_field_name(), 'test4new@example.com')\n+                user.save()\n+                self.assertIs(p0.check_token(user, tk1), False)\n         \"\"\"The token is valid after n seconds, but no greater.\"\"\"\n         # Uses a mocked version of PasswordResetTokenGenerator so we can change\n         # the value of 'now'.\n",
  "django__django-13590": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 0b4f73f..7e2ef8d 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import pickle\n import unittest\n@@ -884,9 +885,28 @@ class IterableLookupInnerExpressionsTests(TestCase):\n             ordered=False\n         )\n \n-    @unittest.skipUnless(connection.vendor == 'sqlite',\n-                         \"This defensive test only works on databases that don't validate parameter types\")\n-    def test_complex_expressions_do_not_introduce_sql_injection_via_untrusted_string_inclusion(self):\n+    def test_range_lookup_namedtuple(self):\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=51, maximum=100),\n+        )\n+        self.assertSequenceEqual(qs, [self.c5])\n+        \n+    def test_range_lookup_namedtuple_boundaries(self):\n+        EmployeeRange = namedtuple('EmployeeRange', ['lower', 'upper'])\n+        # Test on exact boundary limits defined in the named tuple\n+        qs_exact_boundaries = Company.objects.filter(\n+            num_employees__range=EmployeeRange(lower=99, upper=99),\n+        )\n+        self.assertSequenceEqual(qs_exact_boundaries, [self.c5])\n+\n+    def test_range_lookup_empty_result_namedtuple(self):\n+        EmployeeRange = namedtuple('EmployeeRange', ['start', 'end'])\n+        # This should return an empty result set\n+        qs_empty = Company.objects.filter(\n+            num_employees__range=EmployeeRange(start=101, end=200),\n+        )\n+        self.assertSequenceEqual(qs_empty, [])\n         \"\"\"\n         This tests that SQL injection isn't possible using compilation of\n         expressions in iterable filters, as their compilation happens before\n",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..aeaf5e9 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -19,6 +19,41 @@ from django.conf import settings\n from django.core.management import (\n     BaseCommand, CommandError, call_command, color,\n )\n+class ExecuteFromCommandLine(SimpleTestCase):\n+    def test_program_name_from_argv(self):\n+        \"\"\"\n+        Program name is computed from the execute_from_command_line()'s argv\n+        argument, not sys.argv.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line(['django-admin'] + args)\n+        self.assertIn('usage: django-admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_custom_prog_name(self):\n+        \"\"\"\n+        Custom program name is used when provided with argv.\n+        \"\"\"\n+        custom_prog_name = 'custom-django-admin'\n+        args = ['help']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            execute_from_command_line([custom_prog_name] + args)\n+        self.assertIn(f'usage: {custom_prog_name} help', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_prog_name_none(self):\n+        \"\"\"\n+        The program name defaults to 'python -m django' when sys.argv[0] is None.\n+        \"\"\"\n+        args = ['help']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line(['__main__.py'] + args)\n+        self.assertIn('usage: python -m django help', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n from django.core.management.commands.loaddata import Command as LoaddataCommand\n from django.core.management.commands.runserver import (\n     Command as RunserverCommand,\n",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..fac89d3 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,3 +1,4 @@\n+\n import sys\n import unittest\n from unittest import mock\n@@ -8,7 +9,45 @@ from django.test import SimpleTestCase\n from django.test.utils import captured_stdin, captured_stdout\n \n \n+from django.utils.version import get_version\n+...\n+\n class ShellCommandTestCase(SimpleTestCase):\n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n+    \n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), get_version())\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), get_version())\n \n     def test_command_option(self):\n         with self.assertLogs('test', 'INFO') as cm:\n@@ -49,4 +88,4 @@ class ShellCommandTestCase(SimpleTestCase):\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 2d83d62..bf7f84c 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -962,8 +962,41 @@ class TestReadOnlyChangeViewInlinePermissions(TestCase):\n         response = self.client.get(self.change_url)\n         self.assertNotContains(response, 'id=\"id_question_set-0-text\"')\n \n+from django.test import override_settings\n+from django.test import RequestFactory, TestCase\n+from django.contrib.admin import ModelAdmin\n+from django.contrib.admin.sites import site as admin_site\n+from .models import Profile, VerboseNameProfile, VerboseNamePluralProfile, BothVerboseNameProfile, ProfileCollection\n+from django.urls import reverse\n \n @override_settings(ROOT_URLCONF='admin_inlines.urls')\n+\n+class TestSingleVerboseNameInline(TestCase):\n+    factory = RequestFactory()\n+\n+    def setUp(self):\n+        self.superuser = User.objects.create_superuser(\n+            username='super', password='secret', email='super@example.com'\n+        )\n+\n+    def test_single_verbose_name_defaults_plural(self):\n+        class InlineWithOnlyVerboseName(TabularInline):\n+            model = Profile\n+            verbose_name = 'Inline with only verbose name'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [InlineWithOnlyVerboseName]\n+\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Inline checks\n+        self.assertContains(response, '<h2>Inline with only verbose names</h2>')\n+        self.assertContains(response, 'Add another Inline with only verbose name')\n+        self.assertNotContains(response, '<h2>Profiles</h2>')\n class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n     factory = RequestFactory()\n \n@@ -1071,8 +1104,41 @@ class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n         self.assertNotContains(response, '<h2>Model with both - plural name</h2>')\n         self.assertNotContains(response, 'Add another Model with both - name')\n \n+from django.test import override_settings\n+from django.test import RequestFactory, TestCase\n+from django.contrib.admin import ModelAdmin\n+from django.contrib.admin.sites import site as admin_site\n+from .models import Profile, VerboseNameProfile, VerboseNamePluralProfile, BothVerboseNameProfile, ProfileCollection\n+from django.urls import reverse\n \n @override_settings(ROOT_URLCONF='admin_inlines.urls')\n+\n+class TestSingleVerboseNameInline(TestCase):\n+    factory = RequestFactory()\n+\n+    def setUp(self):\n+        self.superuser = User.objects.create_superuser(\n+            username='super', password='secret', email='super@example.com'\n+        )\n+\n+    def test_single_verbose_name_defaults_plural(self):\n+        class InlineWithOnlyVerboseName(TabularInline):\n+            model = Profile\n+            verbose_name = 'Inline with only verbose name'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [InlineWithOnlyVerboseName]\n+\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Inline checks\n+        self.assertContains(response, '<h2>Inline with only verbose names</h2>')\n+        self.assertContains(response, 'Add another Inline with only verbose name')\n+        self.assertNotContains(response, '<h2>Profiles</h2>')\n class SeleniumTests(AdminSeleniumTestCase):\n \n     available_apps = ['admin_inlines'] + AdminSeleniumTestCase.available_apps\n",
  "django__django-13757": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex f53ff8c..38bc1f5 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -595,7 +595,18 @@ class TestQuerying(TestCase):\n             [self.objs[4]],\n         )\n \n-    def test_isnull_key_or_none(self):\n+    def test_additional_isnull_key_scenarios(self):\n+        # When value__j isnull=True, should only match objects without the key 'j'.\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],\n+        )\n+\n+        # Ensure no match for isnull=False when key value is JSON null\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=False),\n+            [self.objs[4]],\n+        )\n         obj = NullableJSONModel.objects.create(value={'a': None})\n         self.assertSequenceEqual(\n             NullableJSONModel.objects.filter(Q(value__a__isnull=True) | Q(value__a=None)),\n",
  "django__django-13768": "diff --git a/tests/dispatch/tests.py b/tests/dispatch/tests.py\nindex b1feefd..2cfe4ca 100644\n--- a/tests/dispatch/tests.py\n+++ b/tests/dispatch/tests.py\n@@ -165,13 +165,26 @@ class DispatcherTests(SimpleTestCase):\n         def fails(val, **kwargs):\n             raise ValueError('this')\n         a_signal.connect(fails)\n-        result = a_signal.send_robust(sender=self, val=\"test\")\n-        err = result[0][1]\n-        self.assertIsInstance(err, ValueError)\n-        self.assertEqual(err.args, ('this',))\n-        self.assertTrue(hasattr(err, '__traceback__'))\n-        self.assertIsInstance(err.__traceback__, TracebackType)\n-        a_signal.disconnect(fails)\n+        try:\n+            with self.assertLogs('django.dispatch', 'ERROR') as cm:\n+                result = a_signal.send_robust(sender=self, val='test')\n+            err = result[0][1]\n+            self.assertIsInstance(err, ValueError)\n+            self.assertEqual(err.args, ('this',))\n+            self.assertTrue(hasattr(err, '__traceback__'))\n+            self.assertIsInstance(err.__traceback__, TracebackType)\n+\n+            log_record = cm.records[0]\n+            self.assertEqual(\n+                log_record.getMessage(),\n+                \"Error calling DispatcherTests.test_send_robust_fail.<locals>.fails in Signal.send_robust() (this)\",\n+            )\n+            self.assertIsNotNone(log_record.exc_info)\n+            _, exc_value, _ = log_record.exc_info\n+            self.assertIsInstance(exc_value, ValueError)\n+            self.assertEqual(str(exc_value), 'this')\n+        finally:\n+            a_signal.disconnect(fails)\n         self.assertTestIsClean(a_signal)\n \n     def test_disconnection(self):\n",
  "django__django-13925": "",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..92c4ec7 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -281,6 +281,10 @@ class FormsErrorMessagesTestCase(SimpleTestCase, AssertFormErrorsMixin):\n             '</ul></li></ul>'\n         )\n \n+from django.test import TestCase\n+from django.forms import ModelChoiceField, ModelMultipleChoiceField\n+from .models import ChoiceModel\n+from .asserts import AssertFormErrorsMixin\n \n class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n     def test_modelchoicefield(self):\n@@ -307,4 +311,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "diff --git a/tests/many_to_one/tests.py b/tests/many_to_one/tests.py\nindex 8af1b8e..5bfae18 100644\n--- a/tests/many_to_one/tests.py\n+++ b/tests/many_to_one/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n from copy import deepcopy\n \n@@ -5,11 +6,12 @@ from django.core.exceptions import FieldError, MultipleObjectsReturned\n from django.db import IntegrityError, models, transaction\n from django.test import TestCase\n from django.utils.translation import gettext_lazy\n+from django.db.models import CharField\n \n from .models import (\n     Article, Category, Child, ChildNullableParent, City, Country, District,\n     First, Parent, Record, Relation, Reporter, School, Student, Third,\n-    ToFieldChild,\n+    ToFieldChild, ParentStringPrimaryKey, ChildStringPrimaryKeyParent,\n )\n \n \n@@ -549,7 +551,34 @@ class ManyToOneTests(TestCase):\n         self.assertEqual(child.parent, parent)\n         self.assertEqual(child.parent_id, parent.name)\n \n-    def test_fk_to_bigautofield(self):\n+    def test_save_fk_after_parent_with_non_numeric_pk_set_on_child(self):\n+        parent = ParentStringPrimaryKey()\n+        child = ChildStringPrimaryKeyParent(parent=parent)\n+        child.parent.name = 'jeff'\n+        parent.save()\n+        child.save()\n+        child.refresh_from_db()\n+        self.assertEqual(child.parent, parent)\n+        self.assertEqual(child.parent_id, parent.name)\n+\n+    def test_save_fk_after_setting_pk_on_empty_child(self):\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey()\n+            child = ChildStringPrimaryKeyParent(parent=parent)\n+            child.parent.name = 'jeff'\n+            parent.save()\n+            child.save()\n+            self.assertTrue(ChildStringPrimaryKeyParent.objects.filter(parent_id='jeff').exists())\n+            self.assertFalse(ChildStringPrimaryKeyParent.objects.filter(parent_id='').exists())\n+\n+    def test_save_fk_with_initialized_primary_key(self):\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey(name='jeff')\n+            parent.save()\n+            child = ChildStringPrimaryKeyParent(parent=parent)\n+            child.save()\n+            self.assertTrue(ChildStringPrimaryKeyParent.objects.filter(parent=parent).exists())\n+            self.assertTrue(ChildStringPrimaryKeyParent.objects.filter(parent_id='jeff').exists())\n         ch = City.objects.create(name='Chicago')\n         District.objects.create(city=ch, name='Far South')\n         District.objects.create(city=ch, name='North')\n",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..3ba4271 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import F, Q\n from django.test import SimpleTestCase\n \n@@ -19,6 +20,15 @@ class QTests(SimpleTestCase):\n     def test_combine_or_both_empty(self):\n         self.assertEqual(Q() | Q(), Q())\n \n+    def test_combine_dict_keys(self):\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q & Q(), q)\n+        self.assertEqual(Q() & q, q)\n+\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n+\n     def test_combine_not_q_object(self):\n         obj = object()\n         q = Q(x=1)\n",
  "django__django-14017": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 707f339..65564ee 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -799,6 +799,33 @@ class BasicExpressionsTests(TestCase):\n         is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n         self.gmbh.point_of_contact = self.max\n         self.gmbh.save()\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        \n+        # Test for commutative property of Q and Exists with AND\n+        self.assertCountEqual(\n+            Employee.objects.filter(Q() & Exists(is_ceo)),\n+            Employee.objects.filter(Exists(is_ceo) & Q()),\n+        )\n+\n+        self.assertCountEqual(\n+            Employee.objects.filter(Q() & Exists(is_poc)),\n+            Employee.objects.filter(Exists(is_poc) & Q()),\n+        )\n+\n+        # Test for commutative property of Q and Exists with OR\n+        self.assertCountEqual(\n+            Employee.objects.filter(Q() | Exists(is_ceo)),\n+            Employee.objects.filter(Exists(is_ceo) | Q()),\n+        )\n+\n+        self.assertCountEqual(\n+            Employee.objects.filter(Q() | Exists(is_poc)),\n+            Employee.objects.filter(Exists(is_poc) | Q()),\n+        )\n+\n         self.assertCountEqual(\n             Employee.objects.filter(Exists(is_ceo) | Exists(is_poc)),\n             [self.example_inc.ceo, self.foobar_ltd.ceo, self.max],\n",
  "django__django-14155": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 0f968fa..4f729a0 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1145,8 +1145,33 @@ class ResolverMatchTests(SimpleTestCase):\n             \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n         )\n \n-\n-@override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n+import functools\n+from django.urls import resolve\n+from django.test import SimpleTestCase, override_settings\n+from urlpatterns_reverse import views\n+\n+class FunctoolsPartialTests(SimpleTestCase):\n+\n+    @override_settings(ROOT_URLCONF='urlpatterns_reverse.urls')\n+    def test_repr_functools_partial(self):\n+        tests = [\n+            ('partial', 'template.html'),\n+            ('partial_nested', 'nested_partial.html'),\n+            ('partial_wrapped', 'template.html'),\n+        ]\n+        for name, template_name in tests:\n+            with self.subTest(name=name):\n+                # Create a partial function using views.empty_view with template_name.\n+                func = functools.partial(views.empty_view, template_name=template_name)\n+                # Resolve the URL and check its repr.\n+                result = resolve(f'/{name}/')\n+                expected_repr = (\n+                    f\"ResolverMatch(func='functools.partial({views.empty_view!r}, \"\n+                    f\"template_name=\\'{template_name}\\')', args=(), kwargs={{}}, \"\n+                    f\"url_name=\\'{name}\\', app_names=[], namespaces=[], route=\\'{name}/\\')\"\n+                )\n+                # Adjust the expected repr according to any changes made to ResolverMatch for unwrapping.\n+                self.assertEqual(repr(result), expected_repr)\n class ErroneousViewTests(SimpleTestCase):\n \n     def test_noncallable_view(self):\n",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..43e31ed 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,4 +1,6 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n+from django.test.utils import isolate_apps\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n from django.test.utils import isolate_apps\n@@ -66,7 +68,31 @@ class TestDefaultPK(SimpleTestCase):\n             class Model(models.Model):\n                 pass\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(\n+        DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField'\n+    )\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(\n+        DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField'\n+    )\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n@@ -82,7 +108,31 @@ class TestDefaultPK(SimpleTestCase):\n \n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(\n+        DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField'\n+    )\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(\n+        DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField'\n+    )\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_m2m_default_auto_field_setting(self):\n         class M2MModel(models.Model):\n",
  "django__django-14382": "",
  "django__django-14411": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 331338c..77ac14e 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1020,7 +1020,27 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n             \"\"\"\n         )\n \n-    def test_readonly_field_has_changed(self):\n+    def test_label_does_not_have_for_attribute(self):\n+        \"\"\"\n+        Verify that the ReadOnlyPasswordHashWidget's label does not contain\n+        a 'for' attribute since it has no labelable elements.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            hash_field = ReadOnlyPasswordHashField()\n+\n+        bound_field = TestForm()['hash_field']\n+        label_tag = bound_field.label_tag()\n+        self.assertNotIn('for=', label_tag)\n+        self.assertEqual(label_tag, '<label>Hash field:</label>')\n+\n+    def test_readonly_widget_renders_as_text(self):\n+        \"\"\"\n+        Ensure the ReadOnlyPasswordHashWidget renders as non-interactive text.\n+        \"\"\"\n+        field = ReadOnlyPasswordHashField()\n+        rendered = field.widget.render('name', 'value')\n+        self.assertIn('value', rendered)\n+        self.assertNotIn('<input', rendered)\n         field = ReadOnlyPasswordHashField()\n         self.assertIs(field.disabled, True)\n         self.assertFalse(field.has_changed('aaa', 'bbb'))\n",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..2b90f45 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -657,8 +657,36 @@ class WriterTests(SimpleTestCase):\n \n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n-\n-    def test_simple_migration(self):\n+    def test_serialize_my_model(self):\n+        \"\"\"\n+        Test the serialization of a model with a custom field and mixin,\n+        ensuring generated migration files are valid and include necessary imports.\n+        \"\"\"\n+        field = models.TextField()\n+        MyMixin = type(\"MyMixin\", (object,), {})\n+        MyField = type(\"MyField\", (models.TextField,), {})\n+        \n+        class MyBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+        \n+        class MyModel(MyMixin, MyBaseModel):\n+            name = MyField(primary_key=True)\n+        \n+        # Simulate migration serialization\n+        from django.db.migrations.writer import MigrationWriter\n+        writer = MigrationWriter('MigrationName')\n+        serialized_model = writer.serialize(MyModel)\n+        \n+        # Check that the serialized model includes the necessary imports\n+        self.assertIn('from django.db import models', serialized_model)\n+        self.assertIn('from app.models import MyMixin, MyField', serialized_model)\n+        \n+        # Check no NameError and valid Python generated\n+        try:\n+            exec(serialized_model, globals())\n+        except NameError as e:\n+            self.fail(f\"Serialized migration has unresolved NameError: {e}\")\n         \"\"\"\n         Tests serializing a simple migration.\n         \"\"\"\n",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..2cb84f5 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -336,9 +336,34 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at most 1 form.'])\n+        # Verify that the nonform CSS class is correctly applied\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>Please submit at most 1 form.</li></ul>'\n+        )\n \n-    def test_formset_validate_min_flag(self):\n+    def test_formset_non_form_errors_css_class(self):\n+        \"\"\"\n+        Test to check non form errors are wrapped with nonform CSS class.\n+        \"\"\"\n+        data = {\n+            'choices-TOTAL_FORMS': '2',  # the number of forms rendered\n+            'choices-INITIAL_FORMS': '0',  # the number of forms with initial data\n+            'choices-MIN_NUM_FORMS': '0',  # min number of forms\n+            'choices-MAX_NUM_FORMS': '0',  # max number of forms - should be ignored\n+            'choices-0-choice': 'Zero',\n+            'choices-0-votes': '0',\n+            'choices-1-choice': 'One',\n+            'choices-1-votes': '1',\n+        }\n+        ChoiceFormSet = formset_factory(Choice, extra=1, min_num=3, validate_min=True)\n+        formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n+        self.assertFalse(formset.is_valid())\n+        # Check if nonform CSS class is present on errors\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>Please submit at least 3 forms.</li></ul>'\n+        )\n         \"\"\"\n         If validate_min is set and min_num is more than TOTAL_FORMS in the\n         data, a ValidationError is raised. MIN_NUM_FORMS in the data is\n",
  "django__django-14672": "diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6fb82ec..855c36e 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -833,6 +833,32 @@ class ShadowingFieldsTests(SimpleTestCase):\n             # both parents define these fields.\n             pass\n \n+    def test_identity_hash_with_through_fields(self):\n+        class Parent(models.Model):\n+            name = models.CharField(max_length=256)\n+\n+        class ProxyParent(Parent):\n+            class Meta:\n+                proxy = True\n+        \n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+            many_to_many_field = models.ManyToManyField(\n+                to=Parent,\n+                through=\"ManyToManyModel\",\n+                through_fields=['child', 'parent'],\n+                related_name=\"something\"\n+            )\n+\n+        class ManyToManyModel(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n+            child = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n+            second_child = models.ForeignKey(Child, on_delete=models.CASCADE, null=True, default=None)\n+\n+        # Simulate Django model check to ensure no hashability issues occurs\n+        self.assertEqual(Child.check(), [])\n+        self.assertEqual(ProxyParent.check(), [])\n+\n         self.assertEqual(Child.check(), [\n             Error(\n                 \"The field 'id' from parent model \"\n",
  "django__django-14752": "",
  "django__django-14787": "diff --git a/tests/decorators/tests.py b/tests/decorators/tests.py\nindex 5ea3da6..779bfa9 100644\n--- a/tests/decorators/tests.py\n+++ b/tests/decorators/tests.py\n@@ -425,8 +425,57 @@ class MethodDecoratorTests(SimpleTestCase):\n                 def __module__(cls):\n                     return \"tests\"\n \n+import functools\n+from django.test import TestCase\n+from django.utils.decorators import method_decorator\n \n-class XFrameOptionsDecoratorsTests(TestCase):\n+class WrapperAssignmentsTests(TestCase):\n+    def test_partial_function_preservation(self):\n+        \"\"\"Test that method_decorator properly handles partial functions.\"\"\"\n+\n+        def simple_decorator(func):\n+            @functools.wraps(func)\n+            def wrapper(*args, **kwargs):\n+                return func(*args, **kwargs)\n+            return wrapper\n+        \n+        class TestClass:\n+            @method_decorator(simple_decorator)\n+            def test_method(self, greeting):\n+                return f\"{greeting}, world\"\n+\n+        test_instance = TestClass()\n+        result = test_instance.test_method(\"Hello\")\n+        \n+        self.assertEqual(result, \"Hello, world\")\n+        self.assertEqual(test_instance.test_method.__name__, \"test_method\")\n+        self.assertEqual(test_instance.test_method.__module__, TestClass.__module__)\n+\n+    def test_decorator_with_partial(self):\n+        \"\"\"Test that method_decorator preserves __name__ and __module__ for partial objects.\"\"\"\n+        \n+        def sample_decorator(func):\n+            @functools.wraps(func)\n+            def wrapper(*args, **kwargs):\n+                return func(*args, **kwargs)\n+            return wrapper\n+\n+        def base_method(self, x, y):\n+            \"\"\"A base method with parameters.\"\"\"\n+            return x + y\n+\n+        class TestPartial:\n+            @method_decorator(sample_decorator)\n+            def test_partial(self):\n+                p = functools.partial(base_method, self, x=2)\n+                return p(y=3)\n+\n+        test_instance = TestPartial()\n+        result = test_instance.test_partial()\n+        \n+        self.assertEqual(result, 5)\n+        self.assertEqual(test_instance.test_partial.__name__, \"test_partial\")\n+        self.assertEqual(test_instance.test_partial.__module__, TestPartial.__module__)\n     \"\"\"\n     Tests for the X-Frame-Options decorators.\n     \"\"\"\n",
  "django__django-14855": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 507855b..130d260 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -5093,6 +5093,46 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase):\n         response = self.client.get(reverse('admin:admin_views_choice_change', args=(choice.pk,)))\n         self.assertContains(response, '<div class=\"readonly\">No opinion</div>', html=True)\n \n+    def _test_readonly_foreignkey_links(self, admin_site):\n+        \"\"\"\n+        Test foreign key URL generation for readonly fields in the admin site.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1',\n+            content='content',\n+            book=Book.objects.create(name='Book 1'),\n+        )\n+        language = Language.objects.create(iso='en', name='English')\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+            language=language,\n+            user=self.superuser,\n+        )\n+        \n+        response = self.client.get(reverse(f'{admin_site}:admin_views_readonlyrelatedfield_change', args=(obj.pk,)))\n+        self.assertEqual(response.status_code, 200)  # Ensure the page loads\n+\n+        soup = BeautifulSoup(response.content, 'html.parser')\n+        language_link = soup.find('a', href=True, text='English')\n+        self.assertIsNotNone(language_link)\n+        self.assertTrue(language_link['href'].startswith(reverse(f'{admin_site}:admin_views_language_change', args=(language.pk,))))\n+\n+        user_link = soup.find('a', href=True, text=self.superuser.username)\n+        self.assertIsNotNone(user_link)\n+        self.assertTrue(user_link['href'].startswith(reverse(f'{admin_site}:auth_user_change', args=(self.superuser.pk,))))\n+\n+    def test_readonly_foreignkey_links_default_admin_site(self):\n+        \"\"\"\n+        Test ForeignKey link generation on the default admin site.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('admin')\n+\n+    def test_readonly_foreignkey_links_custom_admin_site(self):\n+        \"\"\"\n+        Test ForeignKey link generation on a custom admin site.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('namespaced_admin')\n+\n     def test_readonly_foreignkey_links(self):\n         \"\"\"\n         ForeignKey readonly fields render as links if the target model is\n",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..e3853c2 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,9 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n@@ -346,7 +347,31 @@ class ModelChoiceFieldTests(TestCase):\n             field = forms.ModelChoiceField(Category.objects.order_by('-name'))\n             self.assertEqual('Entertainment', field.clean(self.c1.pk).name)\n \n-    def test_queryset_manager(self):\n+    def test_choice_value_hash(self):\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+        # Ensure hashes for equal objects with the same key match\n+        self.assertEqual(hash(value_1), hash(ModelChoiceIteratorValue(self.c1.pk, None)))\n+        # Ensure hashes for different objects with different keys are not equal\n+        self.assertNotEqual(hash(value_1), hash(value_2))\n+\n+    def test_choice_value_in_dict(self):\n+        # Use ModelChoiceIteratorValue objects as dictionary keys\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+        sample_dict = {value_1: 'first', value_2: 'second'}\n+        self.assertEqual(sample_dict[value_1], 'first')\n+        self.assertEqual(sample_dict[value_2], 'second')\n+        \n+    def test_choice_value_in_set(self):\n+        # Use ModelChoiceIteratorValue objects in a set\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_1_duplicate = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+        sample_set = {value_1, value_2}\n+        self.assertIn(value_1, sample_set)\n+        self.assertIn(value_2, sample_set)\n+        self.assertIn(value_1_duplicate, sample_set)  # Should be found due to hash equality\n         f = forms.ModelChoiceField(Category.objects)\n         self.assertEqual(len(f.choices), 4)\n         self.assertEqual(list(f.choices), [\n",
  "django__django-14999": "",
  "django__django-15061": "diff --git a/tests/forms_tests/field_tests/test_multivaluefield.py b/tests/forms_tests/field_tests/test_multivaluefield.py\nindex 53aee21..ea7da52 100644\n--- a/tests/forms_tests/field_tests/test_multivaluefield.py\n+++ b/tests/forms_tests/field_tests/test_multivaluefield.py\n@@ -138,6 +138,10 @@ class MultiValueFieldTest(SimpleTestCase):\n \n     def test_form_as_table(self):\n         form = ComplexFieldForm()\n+        self.assertTrue('id_field1_0' in form.as_table())\n+        self.assertTrue('id_field1_1' in form.as_table())\n+        self.assertTrue('id_field1_2_0' in form.as_table())\n+        self.assertTrue('id_field1_2_1' in form.as_table())\n         self.assertHTMLEqual(\n             form.as_table(),\n             \"\"\"\n@@ -155,6 +159,11 @@ class MultiValueFieldTest(SimpleTestCase):\n         )\n \n     def test_form_as_table_data(self):\n+        form_html = form.as_table()\n+        self.assertIn('id_field1_0', form_html)\n+        self.assertIn('id_field1_1', form_html)\n+        self.assertIn('id_field1_2_0', form_html)\n+        self.assertIn('id_field1_2_1', form_html)\n         form = ComplexFieldForm({\n             'field1_0': 'some text',\n             'field1_1': ['J', 'P'],\n",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..a09cd98 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -70,6 +70,14 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # IPv6.\n             ('http://[12:34::3a53]/', 'http://[12:34::3a53]/'),\n             ('http://[a34:9238::]:8080/', 'http://[a34:9238::]:8080/'),\n+            # Specific test for issue: URLField throws ValueError instead of ValidationError\n+            '////]@N.AN',  # Original case from the issue\n+            '#@A.bO',      # Another example with empty hostname\n+            \n+            # Additional edge cases related to the issue:\n+            '//:invalid_ipv6',  # Empty host with invalid IPv6\n+            'http://[::1::2]',  # Malformed IPv6 URL\n+            'ftp://[::1::2',    # Incomplete IPv6 URL\n         ]\n         for url, expected in tests:\n             with self.subTest(url=url):\n@@ -100,6 +108,14 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # even on domains that don't fail the domain label length check in\n             # the regex.\n             'http://%s' % (\"X\" * 200,),\n+            # Specific test for issue: URLField throws ValueError instead of ValidationError\n+            '////]@N.AN',  # Original case from the issue\n+            '#@A.bO',      # Another example with empty hostname\n+            \n+            # Additional edge cases related to the issue:\n+            '//:invalid_ipv6',  # Empty host with invalid IPv6\n+            'http://[::1::2]',  # Malformed IPv6 URL\n+            'ftp://[::1::2',    # Incomplete IPv6 URL\n         ]\n         msg = \"'Enter a valid URL.'\"\n         for value in tests:\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..d354510 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -210,6 +210,22 @@ class NonAggregateAnnotationTestCase(TestCase):\n         self.assertEqual(len(books), Book.objects.count())\n         self.assertTrue(all(not book.selected for book in books))\n \n+    def test_expression_wrapper_negated_empty_q(self):\n+        \"\"\"Test ExpressionWrapper with negated Q object on empty list.\"\"\"\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expression_wrapper_negated_q_with_empty_queryset(self):\n+        \"\"\"Test ExpressionWrapper with negated Q object on empty queryset.\"\"\"\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=Book.objects.none()), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n     def test_empty_queryset_annotation(self):\n         qs = Author.objects.annotate(\n             empty=Subquery(Author.objects.values('id').none())\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..24c0190 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,4 @@\n+\n import json\n import random\n \n@@ -10,6 +11,7 @@ from django.contrib.messages.storage.cookie import (\n from django.test import SimpleTestCase, override_settings\n from django.utils.crypto import get_random_string\n from django.utils.safestring import SafeData, mark_safe\n+from django.utils.safestring import SafeData, mark_safe\n \n from .base import BaseTests\n \n@@ -163,7 +165,28 @@ class CookieTests(BaseTests, SimpleTestCase):\n         decoded_messages = json.loads(value, cls=MessageDecoder)\n         self.assertEqual(messages, decoded_messages)\n \n-    def test_safedata(self):\n+    def test_extra_tags_preservation(self):\n+        \"\"\"\n+        Ensure that the extra_tags attribute is preserved correctly during serialization and deserialization.\n+        \"\"\"\n+        storage = self.get_storage()\n+        # Test for empty string extra_tags\n+        original_message = Message(constants.INFO, \"Test message\", extra_tags=\"\")\n+        encoded_message = storage._encode(original_message)\n+        decoded_message = storage._decode(encoded_message)\n+        self.assertEqual(decoded_message.extra_tags, \"\")\n+\n+        # Test for None extra_tags\n+        original_message_none = Message(constants.INFO, \"Test message\")\n+        encoded_message_none = storage._encode(original_message_none)\n+        decoded_message_none = storage._decode(encoded_message_none)\n+        self.assertIsNone(decoded_message_none.extra_tags)\n+\n+        # Test for some string extra_tags\n+        original_message_tags = Message(constants.INFO, \"Test message\", extra_tags=\"some tags\")\n+        encoded_message_tags = storage._encode(original_message_tags)\n+        decoded_message_tags = storage._decode(encoded_message_tags)\n+        self.assertEqual(decoded_message_tags.extra_tags, \"some tags\")\n         \"\"\"\n         A message containing SafeData is keeping its safe status when\n         retrieved from the message storage.\n",
  "django__django-15388": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex 42ab5ba..a95bd37 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -1,5 +1,7 @@\n from pathlib import Path\n from unittest import mock\n+from django.conf import settings\n+from pathlib import Path\n \n from django.template import autoreload\n from django.test import SimpleTestCase, override_settings\n@@ -39,7 +41,28 @@ class TemplateReloadTests(SimpleTestCase):\n         self.assertIsNone(autoreload.template_changed(None, Path(__file__)))\n         mock_reset.assert_not_called()\n \n-    def test_watch_for_template_changes(self):\n+    @override_settings(\n+        TEMPLATES=[{\n+            'DIRS': [str(settings.BASE_DIR)],\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]\n+    )\n+    def test_restart_failure_when_base_dir_in_templates_dirs(self):\n+        \"\"\"\n+        Simulate the issue by setting BASE_DIR to TEMPLATES[0]['DIRS']\n+        and verify that autoreload would not trigger a reset when a non-template file changes.\n+        \"\"\"\n+        mock_reloader = mock.MagicMock()\n+        autoreload.watch_for_template_changes(mock_reloader)\n+\n+        # The expectation here is that the BASE_DIR should make all files monitored, but we need\n+        # to test that non-template changes do not trigger a reset, simulating the broken behavior.\n+        test_file_path = Path(settings.BASE_DIR) / 'non_template_file.txt'\n+        with open(test_file_path, 'w') as f:\n+            f.write('This should not cause a reload.')\n+\n+        self.assertIsNone(autoreload.template_changed(None, test_file_path))\n+        mock_reloader.watch_dir.assert_called_once_with(Path(settings.BASE_DIR), '**/*')\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n         self.assertSequenceEqual(\n@@ -88,7 +111,28 @@ class TemplateReloadTests(SimpleTestCase):\n @require_jinja2\n @override_settings(INSTALLED_APPS=['template_tests'])\n class Jinja2TemplateReloadTests(SimpleTestCase):\n-    def test_watch_for_template_changes(self):\n+    @override_settings(\n+        TEMPLATES=[{\n+            'DIRS': [str(settings.BASE_DIR)],\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]\n+    )\n+    def test_restart_failure_when_base_dir_in_templates_dirs(self):\n+        \"\"\"\n+        Simulate the issue by setting BASE_DIR to TEMPLATES[0]['DIRS']\n+        and verify that autoreload would not trigger a reset when a non-template file changes.\n+        \"\"\"\n+        mock_reloader = mock.MagicMock()\n+        autoreload.watch_for_template_changes(mock_reloader)\n+\n+        # The expectation here is that the BASE_DIR should make all files monitored, but we need\n+        # to test that non-template changes do not trigger a reset, simulating the broken behavior.\n+        test_file_path = Path(settings.BASE_DIR) / 'non_template_file.txt'\n+        with open(test_file_path, 'w') as f:\n+            f.write('This should not cause a reload.')\n+\n+        self.assertIsNone(autoreload.template_changed(None, test_file_path))\n+        mock_reloader.watch_dir.assert_called_once_with(Path(settings.BASE_DIR), '**/*')\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n         self.assertSequenceEqual(\n",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..76a8991 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -183,6 +184,8 @@ class StaticHelperTest(StaticTests):\n         self.assertEqual(static(\"//example.org\"), [])\n \n \n+from django.utils.http import parse_http_date_safe\n+\n class StaticUtilsTests(unittest.TestCase):\n     def test_was_modified_since_fp(self):\n         \"\"\"\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..459d384 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,8 +1,14 @@\n+\n import os\n from io import StringIO\n from unittest import mock\n \n from admin_scripts.tests import AdminScriptTestCase\n+from django.core.management import BaseCommand, call_command\n+from django.core.management.base import CommandParser\n+from django.test import SimpleTestCase\n+from argparse import ArgumentDefaultsHelpFormatter\n+from io import StringIO\n \n from django.apps import apps\n from django.core import management\n@@ -410,8 +416,20 @@ class CommandTests(SimpleTestCase):\n         epilog = \"some epilog text\"\n         parser = BaseCommand().create_parser(\"prog_name\", \"subcommand\", epilog=epilog)\n         self.assertEqual(parser.epilog, epilog)\n-\n-    def test_outputwrapper_flush(self):\n+    def test_create_parser_with_custom_formatter(self):\n+        \"\"\"Test custom formatter for command help maintains line breaks.\"\"\"\n+        class MyCommand(BaseCommand):\n+            help = \"Example command help\\n\\nExample usage:\\n  ./manage.py my_command arg1 arg2\"\n+\n+        parser = MyCommand().create_parser(\"prog_name\", \"my_command\", formatter_class=ArgumentDefaultsHelpFormatter)\n+        \n+        output = StringIO()\n+        with self.assertRaises(SystemExit):\n+            parser.print_help(output)\n+        \n+        help_output = output.getvalue()\n+        expected_help = \"Example command help\\n\\nExample usage:\\n  ./manage.py my_command arg1 arg2\"\n+        self.assertIn(expected_help, help_output)\n         out = StringIO()\n         with mock.patch.object(out, \"flush\") as mocked_flush:\n             management.call_command(\"outputwrapper\", stdout=out)\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..53bf5e4 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,8 +1,10 @@\n+\n import os\n from datetime import datetime\n \n from django.test import SimpleTestCase\n from django.utils.functional import lazystr\n+from django.core.serializers.json import DjangoJSONEncoder\n from django.utils.html import (\n     conditional_escape,\n     escape,\n@@ -217,7 +219,43 @@ class TestUtilsHtml(SimpleTestCase):\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n         )\n \n-    def test_smart_urlquote(self):\n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"hello\": \"world\"}'\n+        \n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"hello\": \"world\"}</script>',\n+        )\n+\n+    def test_json_script_with_id_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"foo\": \"bar\"}'\n+\n+        self.assertHTMLEqual(\n+            json_script({}, \"test_id\", encoder=CustomDjangoJSONEncoder),\n+            '<script id=\"test_id\" type=\"application/json\">{\"foo\": \"bar\"}</script>',\n+        )\n+\n+    def test_json_script_default_behavior(self):\n+        data = {\"key\": \"value\"}\n+        self.assertHTMLEqual(\n+            json_script(data),\n+            '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n+        )\n+\n+    def test_json_script_custom_data(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return json.dumps({\"custom\": \"data\"})\n+\n+        data = {\"not\": \"used\"}\n+        self.assertHTMLEqual(\n+            json_script(data, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"custom\": \"data\"}</script>',\n+        )\n         items = (\n             (\"http://\u00f6\u00e4\u00fc.com/\", \"http://xn--4ca9at.com/\"),\n             (\"http://\u00f6\u00e4\u00fc.com/\u00f6\u00e4\u00fc/\", \"http://xn--4ca9at.com/%C3%B6%C3%A4%C3%BC/\"),\n",
  "django__django-15790": "diff --git a/tests/check_framework/test_templates.py b/tests/check_framework/test_templates.py\nindex 72e6cfe..2c4f341 100644\n--- a/tests/check_framework/test_templates.py\n+++ b/tests/check_framework/test_templates.py\n@@ -141,8 +141,42 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n             check_for_template_tags_with_the_same_name(None),\n             [self.error_same_tags],\n         )\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\"\n+        ]\n+    )\n+    def test_template_tags_same_library_in_installed_apps(self):\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"same_tags\", \"same_tags_app_1.templatetags.same_tags\"\n+                )\n+            ]\n+        ):\n+            self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n \n-    def test_template_tags_with_same_library_name(self):\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+            \"check_framework.template_test_apps.same_tags_app_2\",\n+        ]\n+    )\n+    def test_template_tags_same_library_in_different_apps(self):\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"same_tags\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+                self.get_settings(\n+                    \"same_tags\", \"same_tags_app_2.templatetags.same_tags\"\n+                )\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [self.error_same_tags]\n+            )\n         with self.settings(\n             TEMPLATES=[\n                 self.get_settings(\n@@ -206,4 +240,4 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n         ]\n     )\n     def test_template_tags_with_different_name(self):\n-        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..8a61c1a 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -398,6 +398,28 @@ class ProxyModelTests(TestCase):\n     def test_eq(self):\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n+    def test_select_related_only_with_proxy(self):\n+        # Set up test data\n+        user = ProxyCustomModel.objects.create(name=\"Test User\")\n+        another_model = AnotherModel.objects.create(custom=user)\n+\n+        # Perform the select_related followed by only query\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+\n+        # Check if the query executes successfully and returns the correct object\n+        self.assertEqual(qs.get(), another_model)\n+\n+    def test_select_related_only_with_non_proxy(self):\n+        # Set up test data using a non-proxy model to verify behavior consistency\n+        direct_user = CustomModel.objects.create(name=\"Direct User\")\n+        another_direct_model = AnotherModel.objects.create(custom=direct_user)\n+\n+        # Perform the select_related followed by only query\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+\n+        # Check if the query executes successfully and returns the correct object\n+        self.assertEqual(qs.get(), another_direct_model)\n+\n \n @override_settings(ROOT_URLCONF=\"proxy_models.urls\")\n class ProxyModelAdminTests(TestCase):\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..ce68d80 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -154,7 +154,23 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n     def test_parameters(self):\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n-            ([\"psql\", \"dbname\", \"--help\"], None),\n+            ([\"psql\", \"--help\", \"dbname\"], None),\n+        )\n+\n+    def test_command_parameters_order(self):\n+        # Ensure command-line options are placed before the database name\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"SELECT 1\"]),\n+            ([\"psql\", \"-c\", \"SELECT 1\", \"dbname\"], None),\n+        )\n+        \n+    def test_command_parameters_order_with_user(self):\n+        # Ensure user option is before DB name and parameter\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env(\n+                {\"NAME\": \"dbname\", \"USER\": \"testuser\"}, [\"-c\", \"SELECT 1\"]\n+            ),\n+            ([\"psql\", \"-U\", \"testuser\", \"-c\", \"SELECT 1\", \"dbname\"], None),\n         )\n \n     @skipUnless(connection.vendor == \"postgresql\", \"Requires a PostgreSQL connection\")\n@@ -183,4 +199,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "",
  "django__django-16041": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex a34f3d3..6ecedc3 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -173,6 +173,20 @@ class FormsFormsetTestCase(SimpleTestCase):\n             self.assertTrue(hasattr(form, \"custom_kwarg\"))\n             self.assertEqual(form.custom_kwarg, i)\n \n+    def test_empty_permitted_ignored_empty_form_true(self):\n+        FormSet = modelformset_factory(MyModel, fields=['a_field'])\n+        formset = FormSet(queryset=MyModel.objects.none(), form_kwargs={\"empty_permitted\": True})\n+        self.assertTrue(hasattr(formset.empty_form, \"empty_permitted\"))\n+        # The empty_form should ignore the empty_permitted key\n+        self.assertEqual(formset.empty_form.empty_permitted, True)\n+\n+    def test_empty_permitted_ignored_empty_form_false(self):\n+        FormSet = modelformset_factory(MyModel, fields=['a_field'])\n+        formset = FormSet(queryset=MyModel.objects.none(), form_kwargs={\"empty_permitted\": False})\n+        self.assertTrue(hasattr(formset.empty_form, \"empty_permitted\"))\n+        # The empty_form should ignore the empty_permitted key\n+        self.assertEqual(formset.empty_form.empty_permitted, True)\n+\n     def test_form_kwargs_empty_form(self):\n         FormSet = formset_factory(CustomKwargForm)\n         formset = FormSet(form_kwargs={\"custom_kwarg\": 1})\n",
  "django__django-16046": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 41aae41..b41a3e3 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -1,3 +1,4 @@\n+\n from decimal import Decimal\n from sys import float_info\n \n@@ -6,6 +7,20 @@ from django.utils.numberformat import format as nformat\n \n \n class TestNumberFormat(SimpleTestCase):\n+    def test_empty(self):\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        self.assertEqual(nformat(None, \".\"), \"None\")\n+\n+    def test_null_value(self):\n+        with self.assertRaises(TypeError):\n+            nformat(None, \".\")\n+\n+    def test_list_display_null_value(self):\n+        # Simulating the scenario in list_display where the value might be None\n+        # It should raise an error or handle None appropriately based on the fix\n+        result = nformat(None, \".\")\n+        # Depending on fix, assert expected behavior\n+        self.assertEqual(result, \"None\")\n     def test_format_number(self):\n         self.assertEqual(nformat(1234, \".\"), \"1234\")\n         self.assertEqual(nformat(1234.2, \".\"), \"1234.2\")\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..b036bc8 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -26,6 +27,9 @@ from django.utils import translation\n from django.utils.text import capfirst\n from django.utils.translation import gettext as _\n \n+from django.urls import reverse\n+import urllib.parse\n+import re\n from .models.custom_user import (\n     CustomUser,\n     CustomUserWithoutIsActiveField,\n",
  "django__django-16255": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 1469efd..df25a56 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -507,6 +507,18 @@ class HTTPSitemapTests(SitemapTestsBase):\n         self.assertXMLEqual(index_response.content.decode(), expected_content_index)\n         self.assertXMLEqual(sitemap_response.content.decode(), expected_content_sitemap)\n \n+    def test_callable_lastmod_no_items(self):\n+        \"\"\"\n+        Test that a sitemap with callable lastmod and no items does not raise a ValueError.\n+        \"\"\"\n+        response = self.client.get(\"/callable-lastmod-no-items/index.xml\")\n+        self.assertNotIn(\"Last-Modified\", response)\n+        expected_content_index = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n+        <sitemap><loc>http://example.com/simple/sitemap-callable-lastmod.xml</loc></sitemap>\n+        </sitemapindex>\"\"\"\n+        self.assertXMLEqual(response.content.decode(), expected_content_index)\n+\n \n # RemovedInDjango50Warning\n class DeprecatedTests(SitemapTestsBase):\n",
  "django__django-16379": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 014d28a..ebc6eb4 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1,6 +1,9 @@\n+\n # Unit tests for cache framework\n # Uses whatever cache backend is set in the test settings file.\n import copy\n+from unittest import mock, TestCase\n+from django.core.cache import cache\n import io\n import os\n import pickle\n@@ -1755,7 +1758,23 @@ class FileBasedCacheTests(BaseCacheTests, TestCase):\n             with self.assertRaises(OSError):\n                 cache.get(\"foo\")\n \n-    def test_empty_cache_file_considered_expired(self):\n+    def test_has_key_race_handling(self):\n+        self.assertIs(cache.add(\"key\", \"value\"), True)\n+        with mock.patch(\"builtins.open\", side_effect=FileNotFoundError) as mocked_open:\n+            self.assertIs(cache.has_key(\"key\"), False)\n+            mocked_open.assert_called_once()\n+        \n+    def test_has_key_with_simultaneous_expiry(self):\n+        # Add a key to the cache and ensure it exists\n+        self.assertIs(cache.add(\"another_key\", \"value\"), True)\n+        cache_file = cache._key_to_file(\"another_key\")\n+\n+        # Simulate expiry by having _is_expired delete the file after checking existence\n+        with mock.patch(\"os.path.exists\", return_value=True), \\\n+             mock.patch(\"builtins.open\", side_effect=[open(cache_file, \"rb\"), FileNotFoundError]), \\\n+             mock.patch.object(cache, \"_is_expired\", return_value=True) as mocked_is_expired:\n+            self.assertIs(cache.has_key(\"another_key\"), False)\n+            mocked_is_expired.assert_called_once()\n         cache_file = cache._key_to_file(\"foo\")\n         with open(cache_file, \"wb\") as fh:\n             fh.write(b\"\")\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..6790e71 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -8,7 +9,9 @@ from django.contrib.auth.models import User\n from django.test import RequestFactory, TestCase\n from django.urls import reverse\n \n+from django.contrib.auth import get_permission_codename\n from .admin import ArticleAdmin, site\n+from .tests import get_perm\n from .models import Article, Question\n from .tests import AdminViewBasicTestCase\n \n",
  "django__django-16595": "",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..5311be8 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,3 +1,4 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n@@ -26,6 +27,15 @@ class JoinTests(SimpleTestCase):\n         output = self.engine.render_to_string(\"join04\", {\"a\": [\"alpha\", \"beta & me\"]})\n         self.assertEqual(output, \"alpha &amp; beta & me\")\n \n+    # Test case for issue: join filter with autoescape off should not escape joiner\n+    @setup({\"join_autoescape_off\": '{% autoescape off %}{{ some_list|join:some_var }}{% endautoescape %}'})\n+    def test_join_autoescape_off(self):\n+        some_list = [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"]\n+        some_var = \"<br/>\"\n+        output = self.engine.render_to_string(\"join_autoescape_off\", {\"some_list\": some_list, \"some_var\": some_var})\n+        expected_result = \"<p>Hello World!</p><br/>beta & me<br/><script>Hi!</script>\"\n+        self.assertEqual(output, expected_result)\n+\n     # Joining with unsafe joiners doesn't result in unsafe strings.\n     @setup({\"join05\": \"{{ a|join:var }}\"})\n     def test_join05(self):\n@@ -78,4 +88,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..e3612f4 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -653,8 +653,38 @@ class BulkCreateTests(TestCase):\n     @skipIfDBFeature(\"supports_update_conflicts_with_target\")\n     def test_update_conflicts_two_fields_no_unique_fields(self):\n         self._test_update_conflicts_two_fields([])\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \n+        \"supports_returning_in_bulk_create\"\n+    )\n+    def test_bulk_create_update_conflicts_returns_ids(self):\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"a\"),\n+            TwoFields(f1=2, f2=2, name=\"b\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n \n-    def _test_update_conflicts_unique_two_fields(self, unique_fields):\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=3, name=\"c\"),\n+            TwoFields(f1=2, f2=4, name=\"d\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"c\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n+            ],\n+        )\n+        for instance in results:\n+            self.assertIsNotNone(instance.pk)\n         Country.objects.bulk_create(self.data)\n         self.assertEqual(Country.objects.count(), 4)\n \n@@ -816,4 +846,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..0ed9c5f 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -197,6 +197,31 @@ class OperationWriterTests(SimpleTestCase):\n             \"),\",\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -255,12 +280,62 @@ class WriterTests(SimpleTestCase):\n             decimal.Decimal(\"1.3\"), (\"Decimal('1.3')\", {\"from decimal import Decimal\"})\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n         self.assertSerializedEqual(Money(\"1.3\"))\n         self.assertSerializedResultEqual(\n             Money(\"1.3\"),\n             (\"migrations.test_writer.Money('1.3')\", {\"import migrations.test_writer\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -296,6 +371,31 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r\"^foo$\")\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -306,6 +406,31 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\n@@ -313,6 +438,31 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\n@@ -320,10 +470,60 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -331,11 +531,61 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(\n             default=TextEnum.B, choices=[(m.value, m) for m in TextEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -344,10 +594,60 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -356,9 +656,59 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         field = models.CharField(\n             default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -367,9 +717,59 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         field = models.IntegerField(\n             default=IntEnum.A, choices=[(m.value, m) for m in IntEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -379,6 +779,31 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n@@ -387,6 +812,31 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n@@ -394,9 +844,59 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -405,6 +905,31 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A | IntFlagEnum.B,\n             (\n@@ -414,6 +939,31 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = \"A\", \"A value\"\n@@ -433,6 +983,31 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             (\"datetime.date(1969, 7, 20)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         field = models.CharField(default=TextChoices.B, choices=TextChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -440,12 +1015,62 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -456,6 +1081,31 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\",\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_nested_class(self):\n         for nested_cls in [self.NestedEnum, self.NestedChoices]:\n             cls_name = nested_cls.__name__\n@@ -478,14 +1128,89 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {\"import uuid\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {\"import uuid\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n         field = models.UUIDField(\n             choices=((uuid_a, \"UUID A\"), (uuid_b, \"UUID B\")), default=uuid_a\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -495,6 +1220,31 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\",\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_pathlib(self):\n         # Pure path objects work in all platforms.\n         self.assertSerializedEqual(pathlib.PurePosixPath())\n@@ -523,6 +1273,31 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"models.FilePathField(path=pathlib.PurePosixPath('/home/user'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertIn(\"import pathlib\", imports)\n \n     def test_serialize_path_like(self):\n@@ -554,13 +1329,88 @@ class WriterTests(SimpleTestCase):\n         self.assertSerializedEqual(\n             datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone())\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedEqual(\n             datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180))\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc),\n             (\n@@ -568,6 +1418,31 @@ class WriterTests(SimpleTestCase):\n                 {\"import datetime\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             datetime.datetime(\n                 2012, 1, 1, 2, 1, tzinfo=zoneinfo.ZoneInfo(\"Europe/Paris\")\n@@ -578,12 +1453,62 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n@@ -593,20 +1518,120 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(\n             SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\")\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)), (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -624,6 +1649,31 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.RegexValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.serialize_round_trip(validator)\n \n         # Test with a compiled regex.\n@@ -633,6 +1683,31 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.serialize_round_trip(validator)\n \n         # Test a string regex with flag\n@@ -643,6 +1718,31 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[0-9]+$', \"\n             \"flags=re.RegexFlag['DOTALL'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n@@ -653,6 +1753,31 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', \"\n             \"'invalid')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.serialize_round_trip(validator)\n \n         # Test with a subclass.\n@@ -661,6 +1786,31 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.EmailValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.serialize_round_trip(validator)\n \n         validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(\n@@ -671,9 +1821,59 @@ class WriterTests(SimpleTestCase):\n             string, \"migrations.test_writer.EmailValidator(message='hello')\"\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n         validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(\n             message=\"hello\"\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n             MigrationWriter.serialize(validator)\n \n@@ -700,6 +1900,31 @@ class WriterTests(SimpleTestCase):\n             models.OrderBy(models.F(\"name\").desc()),\n             name=\"complex_func_index\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         string, imports = MigrationWriter.serialize(index)\n         self.assertEqual(\n             string,\n@@ -711,6 +1936,31 @@ class WriterTests(SimpleTestCase):\n             \"models.OrderBy(models.OrderBy(models.F('name'), descending=True)), \"\n             \"name='complex_func_index')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertEqual(imports, {\"from django.db import models\"})\n \n     def test_serialize_empty_nonempty_tuple(self):\n@@ -762,6 +2012,31 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.models\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         self.assertSerializedEqual(FoodManager(\"a\", \"b\"))\n         self.assertSerializedEqual(FoodManager(\"x\", \"y\", c=3, d=4))\n \n@@ -772,6 +2047,31 @@ class WriterTests(SimpleTestCase):\n             frozenset(\"cba\"), (\"frozenset(['a', 'b', 'c'])\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_serialize_set(self):\n         self.assertSerializedEqual(set())\n         self.assertSerializedResultEqual(set(), (\"set()\", set()))\n@@ -809,6 +2109,31 @@ class WriterTests(SimpleTestCase):\n             (\"('models.Model', {'from django.db import models'})\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -848,6 +2173,31 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [(\"testapp\", \"some_other_one\")],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         # We don't test the output formatting - that's too fragile.\n@@ -887,6 +2237,31 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -896,6 +2271,31 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_sorted_dependencies(self):\n         migration = type(\n             \"Migration\",\n@@ -912,6 +2312,31 @@ class WriterTests(SimpleTestCase):\n                 ],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         output = MigrationWriter(migration, include_header=False).as_string()\n         self.assertIn(\n             \"    dependencies = [\\n\"\n@@ -923,6 +2348,31 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -949,6 +2399,31 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -956,6 +2431,31 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -1001,6 +2501,31 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\"from django.db import migrations\\n\", output)\n@@ -1017,6 +2542,31 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\",\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test case for issue: Class methods from nested classes cannot be\n+        used as Field.default.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            class NestedChoices(models.TextChoices):\n+                A = \"A\", \"A value\"\n+                B = \"B\", \"B value\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.A]\n+\n+            field = ArrayField(\n+                models.CharField(choices=NestedChoices.choices, max_length=30, blank=True),\n+                default=NestedChoices.default,\n+            )\n+\n+        # Mock migration serialization of this model field\n+        serialized_field = MigrationWriter.serialize(TestModel._meta.get_field(\"field\"))[0]\n+        \n+        # Check if the default is correctly serialized with the full class path\n+        self.assertIn(\"default=__main__.TestModel.NestedChoices.default\", serialized_field)\n+\n     def test_register_serializer(self):\n         class ComplexSerializer(BaseSerializer):\n             def serialize(self):\n@@ -1032,4 +2582,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "matplotlib__matplotlib-22711": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex 39c625e..3c98600 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1120,6 +1120,31 @@ def test_range_slider(orientation):\n     assert_allclose(slider.val, [0.1, 0.34])\n \n \n+@pytest.mark.parametrize(\"orientation\", [\"horizontal\", \"vertical\"])\n+def test_range_slider_valinit_issue(orientation):\n+    fig, ax = plt.subplots()\n+\n+    # Test initial values at slider boundaries to check IndexError\n+    valinit_test_cases = [\n+        ([0.0, 0.0], \"Initial values at min boundary\"),\n+        ([0.5, 0.5], \"Initial values in middle\"),\n+        ([1.0, 1.0], \"Initial values at max boundary\"),\n+        ([0.0, 1.0], \"Initial values from min to max\"),\n+        ([1.0, 0.0], \"Initial values in reverse order\")\n+    ]\n+\n+    for valinit, desc in valinit_test_cases:\n+        slider = widgets.RangeSlider(\n+            ax=ax, label=\"\", valmin=0.0, valmax=1.0, orientation=orientation,\n+            valinit=valinit\n+        )\n+        assert_allclose(slider.val, sorted(valinit), err_msg=f\"Failed for {desc}\")\n+\n+        # Reset and assert that it goes back to initial\n+        slider.reset()\n+        assert_allclose(slider.val, sorted(valinit), err_msg=f\"Reset failed for {desc}\")\n+\n+\n def check_polygon_selector(event_sequence, expected_result, selections_count,\n                            **kwargs):\n     \"\"\"\n",
  "matplotlib__matplotlib-23299": "",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..60ede9b 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -9,6 +9,7 @@ from matplotlib.backend_bases import MouseButton\n from matplotlib import cm\n from matplotlib import colors as mcolors\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n+import pytest\n from matplotlib.testing.widgets import mock_event\n from matplotlib.collections import LineCollection, PolyCollection\n from matplotlib.patches import Circle\n@@ -21,7 +22,12 @@ mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n \n-def test_aspect_equal_error():\n+@check_figures_equal(extensions=[\"png\"])\n+def test_set_visible_on_3d_projection(fig_test, fig_ref):\n+    ax_test = fig_test.add_subplot(111, projection='3d')\n+    ax_test.set_visible(False)\n+    ax_ref = fig_ref.add_subplot(111, projection='3d')\n+    ax_ref.set_visible(True)\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     with pytest.raises(NotImplementedError):\n",
  "matplotlib__matplotlib-23562": "",
  "matplotlib__matplotlib-23563": "",
  "matplotlib__matplotlib-23913": "",
  "matplotlib__matplotlib-23964": "diff --git a/lib/matplotlib/tests/test_backend_ps.py b/lib/matplotlib/tests/test_backend_ps.py\nindex a1caf1a..9df8f4c 100644\n--- a/lib/matplotlib/tests/test_backend_ps.py\n+++ b/lib/matplotlib/tests/test_backend_ps.py\n@@ -246,7 +246,23 @@ def test_fonttype(fonttype):\n \n def test_linedash():\n     \"\"\"Test that dashed lines do not break PS output\"\"\"\n-    fig, ax = plt.subplots()\n+def test_multiline_text_with_empty_lines():\n+    # This test checks for the bug where a multiline text with empty lines\n+    # caused a TypeError in the PostScript backend (see issue description).\n+    \n+    figure = Figure()\n+    ax = figure.add_subplot(111)\n+    ax.annotate(text='\\nLower label', xy=(0.5, 0.5))\n+    \n+    # Test saving in EPS format\n+    buf_eps = io.BytesIO()\n+    figure.savefig(buf_eps, format='eps')\n+    assert buf_eps.tell() > 0  # Ensure some data has been written\n+    \n+    # Test saving in PS format\n+    buf_ps = io.BytesIO()\n+    figure.savefig(buf_ps, format='ps')\n+    assert buf_ps.tell() > 0  # Ensure some data has been written\n \n     ax.plot([0, 1], linestyle=\"--\")\n \n@@ -256,6 +272,9 @@ def test_linedash():\n     assert buf.tell() > 0\n \n \n+import io\n+from matplotlib.figure import Figure\n+\n def test_no_duplicate_definition():\n \n     fig = Figure()\n",
  "matplotlib__matplotlib-23987": "",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 64ba766..2fd3789 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -5731,8 +5731,31 @@ def test_set_get_ticklabels():\n     ax[1].set_xticklabels(ax[0].get_xticklabels())\n     ax[1].set_yticklabels(ax[0].get_yticklabels())\n \n+import matplotlib.pyplot as plt\n+import pytest\n \n-@check_figures_equal(extensions=[\"png\"])\n+def test_set_ticks_kwargs_raise_error_without_labels():\n+    \"\"\"\n+    When labels=None and any kwarg is passed, axis.set_ticks() raises a\n+    ValueError.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [1, 2, 3]\n+    with pytest.raises(ValueError):\n+        ax.xaxis.set_ticks(ticks, alpha=0.5)\n+\n+def test_set_ticks_with_labels_does_not_raise():\n+    \"\"\"\n+    When labels are provided, axis.set_ticks() does not raise a ValueError,\n+    and correctly applies kwargs.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [1, 2, 3]\n+    labels = [\"one\", \"two\", \"three\"]\n+    # Test that this does not raise an error\n+    ax.xaxis.set_ticks(ticks, labels=labels, alpha=0.5)\n+    # Validate the set labels\n+    assert [tick.get_text() for tick in ax.get_xticklabels()] == labels\n def test_set_ticks_with_labels(fig_test, fig_ref):\n     \"\"\"\n     Test that these two are identical::\n",
  "matplotlib__matplotlib-24970": "",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..756ebf6 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -16,8 +17,25 @@ import matplotlib.transforms as mtransforms\n import matplotlib.figure as mfigure\n from mpl_toolkits.axes_grid1 import parasite_axes\n \n+def test_draggable_legend_pickle():\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111)\n+\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40, 43, 45, 47, 48]\n \n-def test_simple():\n+    ax.plot(time, speed, label=\"speed\")\n+\n+    leg = ax.legend()\n+    leg.set_draggable(True)\n+\n+    # Attempt to pickle the figure\n+    try:\n+        pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+        loaded_fig = pickle.loads(pkl)\n+        assert isinstance(loaded_fig, mfigure.Figure), \"Unpickled object is not a Figure.\"\n+    except Exception as e:\n+        pytest.fail(f\"Pickling or unpickling failed: {e}\")\n     fig = plt.figure()\n     pickle.dump(fig, BytesIO(), pickle.HIGHEST_PROTOCOL)\n \n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..afd5bf1 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -90,7 +90,34 @@ def _generate_complete_test_figure(fig_ref):\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n \n-@mpl.style.context(\"default\")\n+def test_pickle_figure_with_aligned_labels():\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call align_labels to test pickling after its usage\n+    fig.align_labels()\n+\n+    # Now test the pickling\n+    try:\n+        pickle_data = pickle.dumps(fig)\n+        # Unpickle to ensure it works without error\n+        loaded_fig = pickle.loads(pickle_data)\n+        plt.close(loaded_fig)\n+        assert True, \"Pickling and unpickling figure with aligned labels should succeed.\"\n+    except Exception as e:\n+        assert False, f\"Pickling failed with error: {e}\"\n+import matplotlib.pyplot as plt\n+import pickle\n+import numpy as np\n+\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25442": "diff --git a/lib/matplotlib/tests/test_offsetbox.py b/lib/matplotlib/tests/test_offsetbox.py\nindex 204af9c..8fa1469 100644\n--- a/lib/matplotlib/tests/test_offsetbox.py\n+++ b/lib/matplotlib/tests/test_offsetbox.py\n@@ -446,7 +446,51 @@ def test_paddedbox():\n     ab = AnchoredOffsetbox('upper right', child=pb)\n     ax.add_artist(ab)\n \n+def test_mplcursor_with_matplotlib():\n+    import numpy as np\n+    import matplotlib.pyplot as plt\n+    import mplcursors as mpl\n+\n+    x = np.arange(1, 11)    \n+    y1 = x\n+\n+    fig, ax = plt.subplots()\n+    scatter = ax.scatter(x, y1)\n+\n+    cursor = mpl.cursor(scatter)\n+\n+    # Simulate clicking on a few data points and validate no exceptions\n+    for _ in range(5):\n+        # Simulate a button_press_event by calling the appropriate handlers\n+        fig.canvas.callbacks.process('button_press_event', MouseEvent('button_press_event', fig.canvas, 1, 1))\n+        fig.canvas.callbacks.process('button_release_event', MouseEvent('button_release_event', fig.canvas, 1, 1))\n+\n+    # Check that no AttributeError is thrown, indicating that the fix works\n+    print(\"Simulated clicks without exceptions.\")\n+\n     ta = TextArea(\"foobar\")\n     pb = PaddedBox(ta, pad=15, draw_frame=True)\n     ab = AnchoredOffsetbox('lower right', child=pb)\n-    ax.add_artist(ab)\n+    ax.add_artist(ab)\n+\n+def test_mplcursor_with_matplotlib():\n+    import numpy as np\n+    import matplotlib.pyplot as plt\n+    import mplcursors as mpl\n+\n+    x = np.arange(1, 11)    \n+    y1 = x\n+\n+    fig, ax = plt.subplots()\n+    scatter = ax.scatter(x, y1)\n+\n+    cursor = mpl.cursor(scatter)\n+\n+    # Simulate clicking on a few data points and validate no exceptions\n+    for _ in range(5):\n+        # Simulate a button_press_event by calling the appropriate handlers\n+        fig.canvas.callbacks.process('button_press_event', MouseEvent('button_press_event', fig.canvas, 1, 1))\n+        fig.canvas.callbacks.process('button_release_event', MouseEvent('button_release_event', fig.canvas, 1, 1))\n+\n+    # Check that no AttributeError is thrown, indicating that the fix works\n+    print(\"Simulated clicks without exceptions.\")\n",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\nindex 9aa3203..7c9bc4c 100644\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -1,4 +1,5 @@\n \n+\n import numpy as np\n import pandas as pd\n \n@@ -8,8 +9,31 @@ from numpy.testing import assert_array_equal, assert_array_almost_equal\n from seaborn._core.groupby import GroupBy\n from seaborn._stats.regression import PolyFit\n \n+from pandas.testing import assert_frame_equal\n \n class TestPolyFit:\n+    \n+    def test_missing_data_behavior(self, df):\n+        # Ensure PolyFit handles missing data by comparing with dropna version\n+        groupby = GroupBy([\"group\"])\n+        \n+        # Introduce missing values (more than the initial test)\n+        df_with_nans = df.copy()\n+        df_with_nans.loc[5:10, \"x\"] = np.nan\n+        df_with_nans.loc[5:10, \"y\"] = np.nan\n+        \n+        # Perform PolyFit on dataset with missing values\n+        try:\n+            res_with_nans = PolyFit()(df_with_nans[[\"x\", \"y\"]], groupby, \"x\", {})\n+            assert not res_with_nans.isnull().values.any(), \"Result should not contain NaNs\"\n+        except Exception as e:\n+            pytest.fail(f\"PolyFit failed with missing data: {e}\")\n+        \n+        # Drop missing values and run PolyFit for comparison\n+        res_no_nans = PolyFit()(df.dropna(subset=[\"x\", \"y\"]), groupby, \"x\", {})\n+        \n+        # Assert results are structurally comparable\n+        assert_frame_equal(res_with_nans, res_no_nans)\n \n     @pytest.fixture\n     def df(self, rng):\n",
  "mwaskom__seaborn-3190": "",
  "mwaskom__seaborn-3407": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\nindex b2e4a92..bf49f38 100644\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -707,6 +707,20 @@ class TestFacetGrid:\n                     assert mpl.colors.same_color(tick.tick2line.get_color(), color)\n                     assert tick.get_pad() == pad\n \n+    def test_pairplot_multiindex(self):\n+        # Test that pairplot works with MultiIndex columns\n+        data = {\n+            (\"A\", \"1\"): np.random.rand(100),\n+            (\"A\", \"2\"): np.random.rand(100),\n+            (\"B\", \"1\"): np.random.rand(100),\n+            (\"B\", \"2\"): np.random.rand(100),\n+        }\n+        df = pd.DataFrame(data)\n+        try:\n+            g = ag.pairplot(df)\n+            assert g is not None\n+        except KeyError as e:\n+            pytest.fail(f\"KeyError was raised: {e}\")\n \n class TestPairGrid:\n \n@@ -1455,6 +1469,20 @@ class TestPairGrid:\n                     assert mpl.colors.same_color(tick.tick2line.get_color(), color)\n                     assert tick.get_pad() == pad\n \n+    def test_pairplot_multiindex(self):\n+        # Test that pairplot works with MultiIndex columns\n+        data = {\n+            (\"A\", \"1\"): np.random.rand(100),\n+            (\"A\", \"2\"): np.random.rand(100),\n+            (\"B\", \"1\"): np.random.rand(100),\n+            (\"B\", \"2\"): np.random.rand(100),\n+        }\n+        df = pd.DataFrame(data)\n+        try:\n+            g = ag.pairplot(df)\n+            assert g is not None\n+        except KeyError as e:\n+            pytest.fail(f\"KeyError was raised: {e}\")\n \n class TestJointGrid:\n \n",
  "pallets__flask-4992": "diff --git a/tests/test_config.py b/tests/test_config.py\nindex 179b09c..838a8b5 100644\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -1,6 +1,7 @@\n+\n import json\n import os\n-import textwrap\n+import tomllib\n \n import pytest\n \n",
  "psf__requests-1963": "",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..2960812 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1636,6 +1636,41 @@ def test_prepared_request_complete_copy():\n     assert_copy(p, p.copy())\n \n \n+import pytest\n+from requests.exceptions import Timeout, HTTPError\n+from requests.adapters import HTTPAdapter\n+from requests.packages.urllib3.exceptions import DecodeError\n+\n+def httpbin(*suffix):\n+    \"\"\"Return URL for the local httpbin instance.\"\"\"\n+    # Assuming httpbin URL is configured\n+    return 'http://httpbin.org/' + '/'.join(suffix)\n+\n+def test_urllib3_decode_error():\n+    s = requests.Session()\n+    \n+    # Simulating a DecodeError\n+    adapter = HTTPAdapter()\n+    \n+    def mock_decode_response(*args, **kwargs):\n+        raise DecodeError(\"Simulated decode error for testing\")\n+    \n+    adapter.build_response = mock_decode_response\n+    s.mount('http://', adapter)\n+\n+    with pytest.raises(HTTPError):\n+        s.get(httpbin('status/200'))\n+\n+def test_urllib3_timeout_error():\n+    s = requests.Session()\n+    \n+    adapter = HTTPAdapter(max_retries=0)  # No retries on timeout\n+    \n+    s.mount('http://', adapter)\n+\n+    with pytest.raises(Timeout):\n+        s.get(httpbin('delay/2'), timeout=0.5)  # Simulate a timeout\n+\n def test_prepare_unicode_url():\n     p = PreparedRequest()\n     p.prepare(\n@@ -1663,4 +1698,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 52d1693..3fee4cc 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -980,6 +980,27 @@ class TestRequests:\n         chunks = r.iter_content(decode_unicode=True)\n         assert all(isinstance(chunk, str) for chunk in chunks)\n \n+    def test_response_iter_content_with_unicode_decoding(self):\n+        \"\"\"\n+        Test iter_content with decode_unicode to verify it behaves correctly.\n+        \"\"\"\n+\n+        # Case 1: Content under ascii encoding\n+        r = requests.Response()\n+        r._content_consumed = False\n+        r.raw = io.BytesIO(b'{\"key1\": \"value1\"}')\n+        r.encoding = 'ascii'\n+        chunks = r.iter_content(decode_unicode=True)\n+        assert all(isinstance(chunk, str) for chunk in chunks), \"Expected all chunks to be str\"\n+\n+        # Case 2: Content under UTF-8 encoding\n+        r = requests.Response()\n+        r._content_consumed = False\n+        r.raw = io.BytesIO('{\"key1\": \"value1\", \"key2\": \"\ub0a8\uc7ac\ub4e4\uc774\"}'.encode('utf-8'))\n+        r.encoding = 'utf-8'\n+        chunks = r.iter_content(decode_unicode=True)\n+        assert all(isinstance(chunk, str) for chunk in chunks), \"Expected all chunks to be str when UTF-8 encoded\"\n+\n     def test_response_chunk_size_int(self):\n         \"\"\"Ensure that chunk_size is passed as an integer, otherwise\n         raise a TypeError.\n",
  "psf__requests-863": "",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..6c4a2a9 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -388,7 +388,7 @@ repr_da = xr.DataArray(\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over %r \" % dim\n+    expected += \", grouped over %r\" % dim\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj[dim])))\n     if dim == \"x\":\n         expected += \"1, 2, 3, 4, 5.\"\n@@ -405,7 +405,7 @@ def test_groupby_repr(obj, dim):\n def test_groupby_repr_datetime(obj):\n     actual = repr(obj.groupby(\"t.month\"))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over 'month' \"\n+    expected += \", grouped over 'month'\"\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj.t.dt.month)))\n     expected += \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.\"\n     assert actual == expected\n",
  "pylint-dev__pylint-5859": "",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..4e281b7 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -56,6 +56,9 @@ reports = \"yes\"\n     check_configuration_file_reader(runner)\n \n \n+import pytest\n+from pylint.exceptions import _UnrecognizedOptionError\n+\n def test_unknown_message_id(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly raise a message on an unknown id.\"\"\"\n     Run([str(EMPTY_MODULE), \"--disable=12345\"], exit=False)\n@@ -79,7 +82,14 @@ def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n     assert \"E0015: Unrecognized option found: Q\" in output.out\n \n \n-def test_unknown_confidence(capsys: CaptureFixture) -> None:\n+def test_friendly_error_on_unrecognized_option(capsys: CaptureFixture) -> None:\n+    \"\"\"Ensure pylint gives a user-friendly error message for unrecognized options, without a traceback.\"\"\"\n+    with pytest.raises(SystemExit):\n+        Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"usage: pylint\" in output.err\n+    assert \"E0015: Unrecognized option found: Q\" in output.out\n+    assert \"Traceback\" not in output.err\n     \"\"\"Check that we correctly error an unknown confidence value.\"\"\"\n     with pytest.raises(SystemExit):\n         Run([str(EMPTY_MODULE), \"--confidence=UNKNOWN_CONFIG\"], exit=False)\n",
  "pylint-dev__pylint-7080": "",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..1113b88 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -933,7 +933,21 @@ print(submodule1)\n         with fix_import_path([tmpdir]):\n             linter.check([\"submodule2.py\"])\n     assert not linter.stats.by_msg\n+import os\n+from pylint.lint import PyLinter\n+from pylint.testutils import tempdir, create_files\n \n+def test_identically_named_nested_module(initialized_linter: PyLinter) -> None:\n+    with tempdir() as temp_dir:\n+        os.mkdir(os.path.join(temp_dir, 'a'))\n+        # Create files a/a.py and a/b.py\n+        create_files([os.path.join(temp_dir, 'a/a.py'), os.path.join(temp_dir, 'a/b.py')])\n+\n+        linter = initialized_linter\n+        linter.check([os.path.join(temp_dir, 'a')])\n+        \n+        # Verify that no errors were reported\n+        assert not linter.stats.by_msg\n \n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n@@ -941,4 +955,4 @@ def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n",
  "pylint-dev__pylint-7993": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 6338072..a75f4f5 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n@@ -15,6 +16,7 @@ from typing import TYPE_CHECKING\n \n import pytest\n \n+from _pytest.recwarn import WarningsRecorder  # Import used in test_deprecation_set_output\n from pylint import checkers\n from pylint.interfaces import HIGH\n from pylint.lint import PyLinter\n",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "diff --git a/testing/acceptance_test.py b/testing/acceptance_test.py\nindex 0cc5057..3f12605 100644\n--- a/testing/acceptance_test.py\n+++ b/testing/acceptance_test.py\n@@ -1305,6 +1305,45 @@ def test_no_brokenpipeerror_message(pytester: Pytester) -> None:\n     # Cleanup.\n     popen.stderr.close()\n \n+def test_doctest_and_normal_imports_with_importlib(pytester: Pytester) -> None:\n+    \"\"\"\n+    Regression test for the issue with modules being imported twice when\n+    using import_mode=importlib. The test verifies that a module is not re-imported\n+    if it already exists in sys.modules.\n+    \"\"\"\n+    pytester.makepyfile(\n+        **{\n+            \"pmxbot/commands.py\": \"from . import logging\",\n+            \"pmxbot/logging.py\": \"class Logger:\\n    store = None\\n\",\n+            \"tests/__init__.py\": \"\",\n+            \"tests/test_commands.py\": \"\"\"\n+                import importlib\n+                from pmxbot import logging\n+\n+                def test_logger_store():\n+                    # Make sure importlib doesn't cause re-import of the module\n+                    logger_from_import = importlib.import_module('pmxbot.logging')\n+                    assert logger_from_import is logging\n+\n+                    # Modify attribute and check if it persists\n+                    logging.Logger.store = \"test_store\"\n+                    assert logging.Logger.store == \"test_store\"\n+                    assert logger_from_import.Logger.store == \"test_store\"\n+            \"\"\",\n+        }\n+    )\n+    pytester.makeini(\n+        \"\"\"\n+        [pytest]\n+        addopts =\n+            --doctest-modules\n+            --import-mode importlib\n+        \"\"\"\n+    )\n+    result = pytester.runpytest_subprocess()\n+    result.stdout.fnmatch_lines(\"*1 passed*\")\n+\n+from typing import Iterator\n \n def test_function_return_non_none_warning(pytester: Pytester) -> None:\n     pytester.makepyfile(\n@@ -1314,4 +1353,4 @@ def test_function_return_non_none_warning(pytester: Pytester) -> None:\n     \"\"\"\n     )\n     res = pytester.runpytest()\n-    res.stdout.fnmatch_lines([\"*Did you mean to use `assert` instead of `return`?*\"])\n+    res.stdout.fnmatch_lines([\"*Did you mean to use `assert` instead of `return`?*\"])\n",
  "pytest-dev__pytest-5227": "diff --git a/testing/logging/test_formatter.py b/testing/logging/test_formatter.py\nindex 54a08a2..b3019ee 100644\n--- a/testing/logging/test_formatter.py\n+++ b/testing/logging/test_formatter.py\n@@ -1,3 +1,4 @@\n+\n import logging\n \n import py.io\n@@ -5,6 +6,32 @@ import py.io\n from _pytest.logging import ColoredLevelFormatter\n \n \n+def test_default_log_format():\n+    logfmt = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n+\n+    record = logging.LogRecord(\n+        name=\"dummy_module\",\n+        level=logging.DEBUG,\n+        pathname=\"dummy_path/dummy_module.py\",\n+        lineno=20,\n+        msg=\"Debugging Information\",\n+        args=(),\n+        exc_info=False,\n+    )\n+\n+    tw = py.io.TerminalWriter()\n+    tw.hasmarkup = True\n+    formatter = ColoredLevelFormatter(tw, logfmt)\n+    output = formatter.format(record)\n+    assert output == (\n+        \"\\x1b[34mDEBUG   \\x1b[0m dummy_module:dummy_module.py:20 Debugging Information\"\n+    )\n+\n+    tw.hasmarkup = False\n+    formatter = ColoredLevelFormatter(tw, logfmt)\n+    output = formatter.format(record)\n+    assert output == \"DEBUG    dummy_module:dummy_module.py:20 Debugging Information\"\n+\n def test_coloredlogformatter():\n     logfmt = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n \n",
  "pytest-dev__pytest-5495": "diff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex b05f85c..549a91d 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -552,6 +552,28 @@ class TestAssert_reprcompare:\n         expl = \" \".join(callequal(\"foo\", \"bar\"))\n         assert \"raised in repr()\" not in expl\n \n+    def test_bytes_diff_empty_vs_nonempty(self):\n+        \"\"\"Test byte string difference when comparing empty vs non-empty byte strings.\"\"\"\n+        diff = callequal(b\"\", b\"42\")\n+        assert diff == [\n+            \"b'' == b'42'\",\n+            \"Right contains more items, first extra item: 52\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'42'\",\n+        ]\n+\n+    def test_bytes_diff_single_byte(self):\n+        \"\"\"Test byte string difference for single byte comparisons.\"\"\"\n+        diff = callequal(b\"\", b\"1\")\n+        assert diff == [\n+            \"b'' == b'1'\",\n+            \"Right contains more items, first extra item: 49\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'1'\",\n+        ]\n+\n     def test_unicode(self):\n         left = \"\u00a3\u20ac\"\n         right = \"\u00a3\"\n",
  "pytest-dev__pytest-5692": "",
  "pytest-dev__pytest-7168": "",
  "pytest-dev__pytest-7220": "diff --git a/testing/test_pytester.py b/testing/test_pytester.py\nindex 5ab5242..e05d3bd 100644\n--- a/testing/test_pytester.py\n+++ b/testing/test_pytester.py\n@@ -70,8 +70,29 @@ def test_make_hook_recorder(testdir) -> None:\n     recorder.hook.pytest_runtest_logreport(report=rep3)\n     pytest.raises(ValueError, recorder.getfailures)\n \n+def test_failure_with_changed_cwd_absolute_paths(testdir):\n+    \"\"\"Verify that absolute paths are shown correctly when cwd is changed within a fixture.\"\"\"\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import os\n+        import pytest\n \n-def test_parseconfig(testdir) -> None:\n+        @pytest.fixture\n+        def private_dir():\n+            out_dir = 'new_dir'\n+            os.makedirs(out_dir, exist_ok=True)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+\n+        def test_fail_path(private_dir):\n+            assert False\n+        \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    # Expecting absolute path to the failing test file\n+    result.stdout.fnmatch_lines([f\"*AssertionError*\", \"*1 failed in *\"])\n     config1 = testdir.parseconfig()\n     config2 = testdir.parseconfig()\n     assert config2 is not config1\n",
  "pytest-dev__pytest-7373": "diff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 309636c..ad2d594 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -2,6 +2,7 @@ import os\n import sys\n from unittest import mock\n \n+import os\n import pytest\n from _pytest.config import ExitCode\n from _pytest.mark import EMPTY_PARAMETERSET_OPTION\n@@ -9,8 +10,36 @@ from _pytest.mark import MarkGenerator as Mark\n from _pytest.nodes import Collector\n from _pytest.nodes import Node\n \n-\n class TestMark:\n+    def test_reevaluate_dynamic_expr(self, testdir):\n+        \"\"\"Ensure reevaluation of dynamic skipif conditions (#7360)\"\"\"\n+        py_file1 = testdir.makepyfile(\n+            test_reevaluate_dynamic_expr1=\"\"\"\n+            import pytest\n+\n+            skip = True\n+\n+            @pytest.mark.skipif(\"skip\")\n+            def test_should_skip():\n+                assert True\n+        \"\"\"\n+        )\n+        py_file2 = testdir.makepyfile(\n+            test_reevaluate_dynamic_expr2=\"\"\"\n+            import pytest\n+\n+            skip = False\n+\n+            @pytest.mark.skipif(\"skip\")\n+            def test_should_not_skip():\n+                assert True\n+        \"\"\"\n+        )\n+        \n+        file_name1 = os.path.basename(py_file1.strpath)\n+        file_name2 = os.path.basename(py_file2.strpath)\n+        reprec = testdir.inline_run(file_name1, file_name2)\n+        reprec.assertoutcome(passed=1, skipped=1)\n     @pytest.mark.parametrize(\"attr\", [\"mark\", \"param\"])\n     @pytest.mark.parametrize(\"modulename\", [\"py.test\", \"pytest\"])\n     def test_pytest_exists_in_namespace_all(self, attr: str, modulename: str) -> None:\n",
  "pytest-dev__pytest-7432": "",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..3567a0d 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,3 +1,4 @@\n+\n import sys\n \n import pytest\n@@ -359,6 +360,32 @@ class TestXFail:\n         result = testdir.runpytest(p, \"--runxfail\")\n         result.stdout.fnmatch_lines([\"*1 pass*\"])\n \n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir):\n+        # Test case for dynamically adding xfail during the test when it fails.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+                assert 0  # This will fail, should be xfailed\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir):\n+        # Test case for dynamically adding strict xfail during the test when it passes.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\", strict=True))\n+                # No assert, hence it passes, should be failed due to strict xfail\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n+\n     def test_xfail_imperative_in_setup_function(self, testdir):\n         p = testdir.makepyfile(\n             \"\"\"\n",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..d0f122c 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,3 +1,4 @@\n+\n import os\n import stat\n import sys\n@@ -20,6 +21,32 @@ from _pytest.pathlib import register_cleanup_lock_removal\n from _pytest.pathlib import rm_rf\n from _pytest.pytester import Pytester\n from _pytest.tmpdir import get_user\n+from _pytest.monkeypatch import MonkeyPatch\n+\n+def test_tmp_path_factory_handles_invalid_dir_characters(tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch) -> None:\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"os/<:*?;>agnostic\")\n+    # _basetemp / _given_basetemp are cached / set in parallel runs, patch them\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"pytest-of-unknown\" in str(p)\n+\n+def test_tmpdir_factory_with_domain_username(tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch) -> None:\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"contoso\\\\john_doe\")\n+    # Reset _basetemp and _given_basetemp to prevent cache issues\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"\\\\john_doe\" not in str(p)\n+    assert \"pytest-of-john_doe\" in str(p)\n+\n+def test_tmpdir_factory_without_domain_username(tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch) -> None:\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"john_doe\")\n+    # Reset _basetemp and _given_basetemp to prevent cache issues\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"pytest-of-john_doe\" in str(p)\n from _pytest.tmpdir import TempdirFactory\n from _pytest.tmpdir import TempPathFactory\n \n",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..72d22ec 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -574,6 +574,35 @@ def test_class_weights_cv():\n     assert_array_equal(reg.predict([[-.2, 2]]), np.array([-1]))\n \n \n+def test_ridge_classifier_cv_store_cv_values():\n+    # Test RidgeClassifierCV's store_cv_values attribute.\n+    rng = np.random.RandomState(42)\n+\n+    x = np.array([[-1.0, -1.0], [-1.0, 0], [-.8, -1.0],\n+                  [1.0, 1.0], [1.0, 0.0]])\n+    y = np.array([1, 1, 1, -1, -1])\n+\n+    n_samples = x.shape[0]\n+    alphas = [1e-1, 1e0, 1e1]\n+    n_alphas = len(alphas)\n+\n+    # Initialize RidgeClassifierCV with store_cv_values=True\n+    clf = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+\n+    # Fit with y as 1D\n+    n_targets = 1\n+    clf.fit(x, y)\n+    assert clf.cv_values_.shape == (n_samples, n_targets, n_alphas)\n+\n+    # Fit with y as 2D\n+    y_2d = np.array([[1, 1, 1, -1, -1],\n+                     [1, -1, 1, -1, 1],\n+                     [-1, -1, 1, -1, -1]]).transpose()\n+    n_targets_2d = y_2d.shape[1]\n+    clf.fit(x, y_2d)\n+    assert clf.cv_values_.shape == (n_samples, n_targets_2d, n_alphas)\n+\n+\n def test_ridgecv_store_cv_values():\n     # Test _RidgeCV's store_cv_values attribute.\n     rng = rng = np.random.RandomState(42)\n",
  "scikit-learn__scikit-learn-11281": "diff --git a/sklearn/mixture/tests/test_bayesian_mixture.py b/sklearn/mixture/tests/test_bayesian_mixture.py\nindex a9d82b7..80a5513 100644\n--- a/sklearn/mixture/tests/test_bayesian_mixture.py\n+++ b/sklearn/mixture/tests/test_bayesian_mixture.py\n@@ -12,6 +12,9 @@ from sklearn.mixture.bayesian_mixture import _log_dirichlet_norm\n from sklearn.mixture.bayesian_mixture import _log_wishart_norm\n \n from sklearn.mixture import BayesianGaussianMixture\n+from sklearn.utils.testing import assert_array_equal\n+from sklearn.metrics.cluster import adjusted_rand_score\n+from sklearn.exceptions import ConvergenceWarning, NotFittedError\n \n from sklearn.mixture.tests.test_gaussian_mixture import RandomData\n from sklearn.exceptions import ConvergenceWarning\n",
  "scikit-learn__scikit-learn-12471": "diff --git a/sklearn/preprocessing/tests/test_encoders.py b/sklearn/preprocessing/tests/test_encoders.py\nindex 3f9b211..5d073a1 100644\n--- a/sklearn/preprocessing/tests/test_encoders.py\n+++ b/sklearn/preprocessing/tests/test_encoders.py\n@@ -260,6 +260,11 @@ def test_one_hot_encoder_not_fitted():\n         enc.transform(X)\n \n \n+from sklearn.preprocessing import OneHotEncoder\n+import numpy as np\n+from numpy.testing import assert_array_equal\n+import pytest\n+\n def test_one_hot_encoder_no_categorical_features():\n     X = np.array([[3, 2, 1], [0, 1, 1]], dtype='float64')\n \n",
  "scikit-learn__scikit-learn-13142": "",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..ff6bca9 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,10 +1,24 @@\n+\n+from sklearn.preprocessing import StandardScaler\n+\n+def test_kernel_pca_sign_consistency():\n+    rng = np.random.RandomState(42)\n+    X = rng.rand(20, 5)\n+    kpca = KernelPCA(n_components=3, kernel='rbf', random_state=rng)\n+    \n+    transformed_1 = kpca.fit_transform(X)\n+    transformed_2 = kpca.fit_transform(StandardScaler().fit_transform(X))\n+    \n+    for t1, t2 in zip(transformed_1, transformed_2):\n+        assert_allclose(np.abs(t1), np.abs(t2), err_msg=\"Transformed components differ in sign or magnitude\")\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n \n from sklearn.utils.testing import (assert_array_almost_equal, assert_less,\n                                    assert_equal, assert_not_equal,\n-                                   assert_raises)\n+                                   assert_raises, assert_allclose)\n \n from sklearn.decomposition import PCA, KernelPCA\n from sklearn.datasets import make_circles\n",
  "scikit-learn__scikit-learn-13439": "diff --git a/sklearn/pipeline.py b/sklearn/pipeline.py\nindex 4594f40..49a78a4 100644\n--- a/sklearn/pipeline.py\n+++ b/sklearn/pipeline.py\n@@ -199,6 +199,10 @@ class Pipeline(_BaseComposition):\n             if trans is not None and trans != 'passthrough':\n                 yield idx, name, trans\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the Pipeline.\"\"\"\n+        return len(self.steps)\n+\n     def __getitem__(self, ind):\n         \"\"\"Returns a sub-pipeline or a single esimtator in the pipeline\n \n",
  "scikit-learn__scikit-learn-13496": "",
  "scikit-learn__scikit-learn-13497": "",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..cdd8856 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,3 +1,4 @@\n+\n import re\n from pprint import PrettyPrinter\n \n@@ -8,6 +9,8 @@ from sklearn.pipeline import make_pipeline\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.feature_selection import SelectKBest, chi2\n from sklearn import set_config\n+import numpy as np\n+from sklearn.linear_model import LogisticRegressionCV\n \n \n # Ignore flake8 (lots of line too long issues)\n@@ -214,8 +217,21 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n \n     set_config(print_changed_only=False)\n \n-\n-def test_pipeline():\n+def test_logistic_regression_cv_repr_with_array():\n+    # Configure sklearn to print only changed parameters\n+    set_config(print_changed_only=True)\n+    \n+    # Create a LogisticRegressionCV instance with an array parameter\n+    lr_cv = LogisticRegressionCV(Cs=np.array([0.1, 1]))\n+    \n+    # Attempt to get the string representation to ensure no ValueError is raised\n+    repr_lrcv = repr(lr_cv)\n+    \n+    # Check that the representation is indeed a string\n+    assert isinstance(repr_lrcv, str), \"The repr output should be a string.\"\n+    \n+    # Reset the configuration to avoid affecting other tests\n+    set_config(print_changed_only=False)\n     # Render a pipeline object\n     pipeline = make_pipeline(StandardScaler(), LogisticRegression(C=999))\n     expected = \"\"\"\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..8ad5244 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n@@ -9,9 +10,12 @@ from sklearn.utils.testing import assert_equal\n from sklearn.utils.testing import assert_raise_message\n from sklearn.exceptions import NotFittedError\n from sklearn.linear_model import LogisticRegression\n+from sklearn.linear_model import LinearRegression\n+from sklearn.ensemble import RandomForestRegressor\n from sklearn.naive_bayes import GaussianNB\n from sklearn.ensemble import RandomForestClassifier\n from sklearn.ensemble import VotingClassifier, VotingRegressor\n+import pytest\n from sklearn.model_selection import GridSearchCV\n from sklearn import datasets\n from sklearn.model_selection import cross_val_score, train_test_split\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "diff --git a/sklearn/neighbors/tests/test_nca.py b/sklearn/neighbors/tests/test_nca.py\nindex 3963eca..baac4e2 100644\n--- a/sklearn/neighbors/tests/test_nca.py\n+++ b/sklearn/neighbors/tests/test_nca.py\n@@ -160,8 +160,31 @@ def test_params_validation():\n                          .format(n_components, X.shape[1]),\n                          NCA(n_components=n_components).fit, X, y)\n \n+def test_gridsearchcv_with_nca():\n+    import numpy as np\n+    from sklearn.pipeline import Pipeline\n+    from sklearn.model_selection import GridSearchCV\n+    from sklearn.neighbors import NeighborhoodComponentsAnalysis, KNeighborsClassifier\n \n-def test_transformation_dimensions():\n+    # Create a toy dataset\n+    X = np.random.random_sample((100, 10))\n+    y = np.random.randint(2, size=100)\n+\n+    # Define the pipeline with NCA and KNN\n+    nca = NeighborhoodComponentsAnalysis()\n+    knn = KNeighborsClassifier()\n+    pipe = Pipeline([('nca', nca), ('knn', knn)])\n+\n+    # Define parameters for grid search\n+    params = {'nca__tol': [0.1, 0.5, 1], 'nca__n_components': np.arange(1, 10)}\n+\n+    # Run GridSearchCV\n+    gs = GridSearchCV(estimator=pipe, param_grid=params, error_score='raise')\n+    gs.fit(X, y)\n+    \n+    assert gs.best_estimator_ is not None\n+    assert 'nca__tol' in gs.best_params_\n+    assert 'nca__n_components' in gs.best_params_\n     X = np.arange(12).reshape(4, 3)\n     y = [1, 1, 2, 2]\n \n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..d069c49 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -680,6 +680,28 @@ def test_unicode_kernel():\n                                 random_seed=0)\n \n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for ZeroDivisionError when support_vectors_ is empty\n+    from scipy import sparse\n+    import numpy as np\n+    from sklearn import svm\n+    \n+    X_train = sparse.csr_matrix([\n+        [0, 1, 0, 0],\n+        [0, 0, 0, 1],\n+        [0, 0, 1, 0],\n+        [0, 0, 0, 1]\n+    ])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    \n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    \n+    # Assert that the support vectors and dual coefficients are empty\n+    assert not model.support_vectors_.data.size\n+    assert not model.dual_coef_.data.size\n+\n+\n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n     sparse_gram = sparse.csr_matrix([[1, 0], [0, 1]])\n",
  "scikit-learn__scikit-learn-14983": "",
  "scikit-learn__scikit-learn-15512": "diff --git a/sklearn/cluster/tests/test_affinity_propagation.py b/sklearn/cluster/tests/test_affinity_propagation.py\nindex 5de7c5e..fc88153 100644\n--- a/sklearn/cluster/tests/test_affinity_propagation.py\n+++ b/sklearn/cluster/tests/test_affinity_propagation.py\n@@ -139,6 +139,37 @@ def test_affinity_propagation_equal_mutual_similarities():\n def test_affinity_propagation_predict_non_convergence():\n     # In case of non-convergence of affinity_propagation(), the cluster\n     # centers should be an empty array\n+    import pytest\n+    from sklearn.utils._testing import assert_raises\n+\n+    def test_affinity_propagation_non_convergence_regressiontest():\n+        X = np.array([[1, 0, 0, 0, 0, 0],\n+                      [0, 1, 1, 1, 0, 0],\n+                      [0, 0, 1, 0, 0, 1]])\n+        af = AffinityPropagation(affinity='euclidean', max_iter=2).fit(X)\n+        assert_array_equal(np.array([-1, -1, -1]), af.labels_)\n+        assert_array_equal(np.array([]), af.cluster_centers_indices_)\n+\n+    def test_non_convergence_verbose():\n+        # Test to ensure that when verbose is enabled, no critical errors occur\n+        X = np.array([[1, 0, 0, 0, 0, 0],\n+                      [0, 1, 1, 1, 0, 0],\n+                      [0, 0, 1, 0, 0, 1]])\n+        af = AffinityPropagation(affinity='euclidean', verbose=True, max_iter=2)\n+        af.fit(X)\n+        assert af.n_iter_ == 2\n+    \n+    def test_predict_after_non_convergence():\n+        # Predicting after non-convergence should produce all -1 labels\n+        X = np.array([[1, 0, 0, 0, 0, 0],\n+                      [0, 1, 1, 1, 0, 0],\n+                      [0, 0, 1, 0, 0, 1]])\n+        af = AffinityPropagation(affinity='euclidean', max_iter=2).fit(X)\n+        to_predict = np.array([[0, 0, 1, 0, 0, 1]])\n+        predicted_labels = af.predict(to_predict)\n+        assert_array_equal(np.array([-1]), predicted_labels)\n+\n+    # Keeping the previous test\n     X = np.array([[0, 0], [1, 1], [-2, -2]])\n \n     # Force non-convergence by allowing only a single iteration\n@@ -154,6 +185,37 @@ def test_affinity_propagation_predict_non_convergence():\n \n def test_equal_similarities_and_preferences():\n     # Unequal distances\n+    import pytest\n+    from sklearn.utils._testing import assert_raises\n+\n+    def test_affinity_propagation_non_convergence_regressiontest():\n+        X = np.array([[1, 0, 0, 0, 0, 0],\n+                      [0, 1, 1, 1, 0, 0],\n+                      [0, 0, 1, 0, 0, 1]])\n+        af = AffinityPropagation(affinity='euclidean', max_iter=2).fit(X)\n+        assert_array_equal(np.array([-1, -1, -1]), af.labels_)\n+        assert_array_equal(np.array([]), af.cluster_centers_indices_)\n+\n+    def test_non_convergence_verbose():\n+        # Test to ensure that when verbose is enabled, no critical errors occur\n+        X = np.array([[1, 0, 0, 0, 0, 0],\n+                      [0, 1, 1, 1, 0, 0],\n+                      [0, 0, 1, 0, 0, 1]])\n+        af = AffinityPropagation(affinity='euclidean', verbose=True, max_iter=2)\n+        af.fit(X)\n+        assert af.n_iter_ == 2\n+    \n+    def test_predict_after_non_convergence():\n+        # Predicting after non-convergence should produce all -1 labels\n+        X = np.array([[1, 0, 0, 0, 0, 0],\n+                      [0, 1, 1, 1, 0, 0],\n+                      [0, 0, 1, 0, 0, 1]])\n+        af = AffinityPropagation(affinity='euclidean', max_iter=2).fit(X)\n+        to_predict = np.array([[0, 0, 1, 0, 0, 1]])\n+        predicted_labels = af.predict(to_predict)\n+        assert_array_equal(np.array([-1]), predicted_labels)\n+\n+    # Keeping the previous test\n     X = np.array([[0, 0], [1, 1], [-2, -2]])\n     S = -euclidean_distances(X, squared=True)\n \n",
  "scikit-learn__scikit-learn-15535": "",
  "scikit-learn__scikit-learn-25500": "",
  "scikit-learn__scikit-learn-25570": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex 23e3b97..37f11b6 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -2121,6 +2121,51 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n     with pytest.raises(AttributeError, match=\"not provide get_feature_names_out\"):\n         ct.get_feature_names_out()\n \n+@pytest.mark.parametrize(\n+    \"empty_selection\",\n+    [[], np.array([False, False]), [False, False]],\n+    ids=[\"list\", \"bool\", \"bool_int\"],\n+)\n+def test_empty_selection_pandas_output(empty_selection):\n+    \"\"\"Check that pandas output works when there is an empty selection.\n+\n+    Non-regression test for gh-25487\n+    \"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+\n+    X = pd.DataFrame([[1.0, 2.2], [3.0, 1.0]], columns=[\"a\", \"b\"])\n+    ct = ColumnTransformer(\n+        [\n+            (\"categorical\", \"passthrough\", empty_selection),\n+            (\"numerical\", StandardScaler(), [\"a\", \"b\"]),\n+        ],\n+        verbose_feature_names_out=True,\n+    )\n+    ct.set_output(transform=\"pandas\")\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"numerical__a\", \"numerical__b\"])\n+\n+    ct.set_params(verbose_feature_names_out=False)\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"a\", \"b\"])\n+\n+def test_multiple_empty_selections():\n+    \"\"\"Test ColumnTransformer handling multiple empty selections.\"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+\n+    X = pd.DataFrame([[1.0, 2.0], [3.0, 4.0]], columns=[\"a\", \"b\"])\n+    ct = ColumnTransformer(\n+        [\n+            (\"categorical_1\", \"passthrough\", []),\n+            (\"categorical_2\", \"passthrough\", []),\n+            (\"numerical\", StandardScaler(), [\"a\", \"b\"]),\n+        ],\n+        verbose_feature_names_out=True,\n+    )\n+    ct.set_output(transform=\"pandas\")\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"numerical__a\", \"numerical__b\"])\n+\n     # The feature names are prefixed because verbose_feature_names_out=True is default\n     ct.set_output(transform=\"pandas\")\n     X_trans_df0 = ct.fit_transform(X_df)\n@@ -2128,4 +2173,4 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n \n     ct.set_params(verbose_feature_names_out=False)\n     X_trans_df1 = ct.fit_transform(X_df)\n-    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n+    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n",
  "sphinx-doc__sphinx-10325": "diff --git a/tests/test_ext_autodoc_automodule.py b/tests/test_ext_autodoc_automodule.py\nindex 787cd0c..06f01be 100644\n--- a/tests/test_ext_autodoc_automodule.py\n+++ b/tests/test_ext_autodoc_automodule.py\n@@ -112,6 +112,52 @@ def test_automodule_special_members(app):\n         '',\n     ]\n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_automodule_inherited_members_multiple_classes(app):\n+    options = {\n+        'members': None,\n+        'undoc-members': None,\n+        'inherited-members': 'Base, list'\n+    }\n+    actual = do_autodoc(app, 'module', 'target.inheritance', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.inheritance',\n+        '',\n+        '',\n+        '.. py:class:: Base()',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedclassmeth()',\n+        '      :module: target.inheritance',\n+        '      :classmethod:',\n+        '',\n+        '      Inherited class method.',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedstaticmeth(cls)',\n+        '      :module: target.inheritance',\n+        '      :staticmethod:',\n+        '',\n+        '      Inherited static method.',\n+        '',\n+        '',\n+        '.. py:class:: Derived()',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: Derived.inheritedmeth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '',\n+        '',\n+        '   .. py:method:: MyList.meth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      docstring',\n+        ''\n+    ]\n \n @pytest.mark.sphinx('html', testroot='ext-autodoc',\n                     confoverrides={'autodoc_mock_imports': ['missing_module',\n@@ -125,4 +171,225 @@ def test_subclass_of_mocked_object(app):\n \n     options = {'members': None}\n     actual = do_autodoc(app, 'module', 'target.need_mocks', options)\n-    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n",
  "sphinx-doc__sphinx-7975": "",
  "sphinx-doc__sphinx-8435": "",
  "sphinx-doc__sphinx-8506": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 08bd595..1ad936e 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -91,6 +91,32 @@ def test_get_full_qualified_name():\n     assert domain.get_full_qualified_name(node) == 'ls.-l'\n \n \n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+from sphinx.domains.std import StandardDomain\n+from sphinx.util.docutils import new_document\n+from docutils import nodes\n+\n+def test_cmd_option_with_optional_value(app: SphinxTestApp):\n+    text = \".. option:: -j[=N]\"\n+    doctree = app.builder.env.get_doctree('index')\n+    assert_node(doctree, (nodes.index,\n+                          [nodes.desc, ([nodes.desc_signature, ([nodes.desc_name, '-j'],\n+                                                               [nodes.desc_addname, '[=N]'])],\n+                                        [nodes.desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('-j', '-j', 'cmdoption', 'index', 'cmdoption-j', 1) in objects\n+\n+def test_cmd_option_starting_with_bracket(app: SphinxTestApp):\n+    text = \".. option:: [enable=]PATTERN\"\n+    doctree = app.builder.env.get_doctree('index')\n+    assert_node(doctree, (nodes.index,\n+                          [nodes.desc, ([nodes.desc_signature, ([nodes.desc_name, '[enable'],\n+                                                               [nodes.desc_addname, '=]PATTERN'])],\n+                                        [nodes.desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('[enable', '[enable', 'cmdoption', 'index', 'cmdoption-arg-enable', 1) in objects\n+\n def test_glossary(app):\n     text = (\".. glossary::\\n\"\n             \"\\n\"\n",
  "sphinx-doc__sphinx-8595": "",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..3015586 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -16,6 +17,7 @@ from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tup\n import pytest\n \n from sphinx.util.typing import restify, stringify\n+from struct import Struct\n \n \n class MyClass1:\n@@ -46,6 +48,9 @@ def test_restify():\n     assert restify(Any) == \":obj:`Any`\"\n \n \n+def test_restify_struct():\n+    assert restify(Struct) == \":class:`struct.Struct`\"\n+\n def test_restify_type_hints_containers():\n     assert restify(List) == \":class:`List`\"\n     assert restify(Dict) == \":class:`Dict`\"\n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..47c775c 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1458,7 +1458,31 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n \"\"\"\n         self.assertEqual(expected, actual)\n \n-    def test_multiple_parameters(self):\n+    def test_other_parameters_section_with_napoleon_use_param(self):\n+        # Test with napoleon_use_param=False\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+y : float\n+    Description for y\n+\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **y** (*float*) -- Description for y\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        # Test with napoleon_use_param=True\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters:\n+:param y: Description for y\n+:type y: float\n+\"\"\"\n+        self.assertEqual(expected, actual)\n         docstring = \"\"\"\\\n Parameters\n ----------\n",
  "sphinx-doc__sphinx-8721": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\nindex d4fba47..f823691 100644\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -60,9 +60,17 @@ def test_linkcode(app, status, warning):\n     assert 'http://foobar/c/' in stuff\n     assert 'http://foobar/cpp/' in stuff\n \n+@pytest.mark.sphinx('epub', testroot='ext-viewcode', confoverrides={'viewcode_enable_epub': False})\n+def test_viewcode_epub_disabled(app, status, warning):\n+    app.builder.build_all()\n+    # Verify that the module pages are not created for epub when viewcode_enable_epub is False\n+    assert not (app.outdir / '_modules/spam/mod1.xhtml').exists()\n \n-@pytest.mark.sphinx(testroot='ext-viewcode-find')\n-def test_local_source_files(app, status, warning):\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode', confoverrides={'viewcode_enable_epub': True})\n+def test_viewcode_epub_enabled(app, status, warning):\n+    app.builder.build_all()\n+    # Verify that the module pages are created for epub when viewcode_enable_epub is True\n+    assert (app.outdir / '_modules/spam/mod1.xhtml').exists()\n     def find_source(app, modname):\n         if modname == 'not_a_package':\n             source = (app.srcdir / 'not_a_package/__init__.py').read_text()\n",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..acf763e 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -336,6 +336,19 @@ def test_args():\n         Permutation(((0, ), [1]))\n     assert Permutation([[1, 2]]) == Permutation([0, 2, 1])\n     assert Permutation([[1], [4, 2]]) == Permutation([0, 1, 4, 3, 2])\n+\n+    # Test for non-disjoint cycles, this should work without raising a ValueError\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n+\n+    # Additional test for non-disjoint cycles to verify they are applied in left-to-right order\n+    # The cycle [[0, 1]] swaps 0 and 1 for both occurrences, resulting in no change for the identity permutation.\n+    assert Permutation([[0, 1], [1, 0]]) == Permutation([0, 1])\n+\n+    # Test with more complex non-disjoint cycles\n+    assert Permutation([[0, 1, 2], [1, 2, 0]]) == Permutation([1, 2, 0])\n+\n+    # Another complex case for non-disjoint cycles\n+    assert Permutation([[2, 0], [0, 1], [1, 2]]) == Permutation([2, 0, 1])\n     assert Permutation([[1], [4, 2]], size=1) == Permutation([0, 1, 4, 3, 2])\n     assert Permutation(\n         [[1], [4, 2]], size=6) == Permutation([0, 1, 4, 3, 2, 5])\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..f374d9b 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -1,4 +1,5 @@\n-from sympy import Abs, S, Symbol, I, Rational, PurePoly\n+\n+from sympy import Abs, S, Symbol, I, Rational, PurePoly, Matrix, SparseMatrix\n from sympy.matrices import Matrix, SparseMatrix, eye, zeros, ShapeError\n from sympy.utilities.pytest import raises\n \n@@ -26,7 +27,30 @@ def test_sparse_matrix():\n     assert type(a.row_join(b)) == type(a)\n     assert type(a.col_join(b)) == type(a)\n \n-    # test element assignment\n+    # Additional tests for zero-shaped matrices stacking\n+    def test_zero_shaped_stacking():\n+        # Testing hstack for matrices with zero rows\n+        M1 = SparseMatrix.zeros(0, 0)\n+        M2 = SparseMatrix.zeros(0, 1)\n+        M3 = SparseMatrix.zeros(0, 2)\n+        M4 = SparseMatrix.zeros(0, 3)\n+        assert SparseMatrix.hstack(M1, M2, M3, M4).shape == (0, 6)\n+\n+        # Testing vstack for matrices with zero columns\n+        M5 = SparseMatrix.zeros(1, 0)\n+        M6 = SparseMatrix.zeros(2, 0)\n+        M7 = SparseMatrix.zeros(3, 0)\n+        M8 = SparseMatrix.zeros(4, 0)\n+        assert SparseMatrix.vstack(M5, M6, M7, M8).shape == (10, 0)\n+\n+        # Ensure that non-empty cases still correctly stack\n+        N1 = SparseMatrix.zeros(1, 0)\n+        N2 = SparseMatrix.zeros(1, 1)\n+        N3 = SparseMatrix.zeros(1, 2)\n+        N4 = SparseMatrix.zeros(1, 3)\n+        assert SparseMatrix.hstack(N1, N2, N3, N4).shape == (1, 6)\n+\n+    test_zero_shaped_stacking()\n     a = SparseMatrix((\n         (1, 0),\n         (0, 1)\n",
  "sympy__sympy-13471": "diff --git a/sympy/utilities/tests/test_pickling.py b/sympy/utilities/tests/test_pickling.py\nindex 52dcc20..25a0ac7 100644\n--- a/sympy/utilities/tests/test_pickling.py\n+++ b/sympy/utilities/tests/test_pickling.py\n@@ -99,8 +99,17 @@ def test_core_symbol():\n             Symbol(\"_issue_3130\", commutative=False), Wild, Wild(\"x\")):\n         check(c)\n \n+import io\n+import sys\n \n-def test_core_numbers():\n+def test_pickle_python2_to_3_float():\n+    import pickle\n+    expr = Symbol('x') + Float(1.0)\n+    # Simulating a pickle created in Python 2\n+    python2_pickled = pickle.dumps(expr, protocol=2)\n+    # Load the pickle in the Python 3 environment\n+    loaded_expr = pickle.loads(python2_pickled)\n+    assert str(loaded_expr) == 'x + 1.0'\n     for c in (Integer(2), Rational(2, 3), Float(\"1.2\")):\n         check(c)\n \n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..1838d4c 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -279,7 +279,27 @@ def test_coth_series():\n         1/x + x/3 - x**3/45 + 2*x**5/945 - x**7/4725 + O(x**8)\n \n \n-def test_csch():\n+def test_coth_log_tan_subs():\n+    from sympy import coth, log, tan, Symbol\n+\n+    x = Symbol('x')\n+\n+    # Cases directly mentioned in the issue\n+    assert coth(log(tan(2))) == coth(log(-tan(2)))\n+    assert coth(log(tan(3))) == coth(log(-tan(3)))\n+    assert coth(log(tan(5))) == coth(log(-tan(5)))\n+    assert coth(log(tan(6))) == coth(log(-tan(6)))\n+    assert coth(log(tan(8))) == coth(log(-tan(8)))\n+    assert coth(log(tan(9))) == coth(log(-tan(9)))\n+    assert coth(log(tan(11))) == coth(log(-tan(11)))\n+    assert coth(log(tan(12))) == coth(log(-tan(12)))\n+    assert coth(log(tan(13))) == coth(log(-tan(13)))\n+    assert coth(log(tan(15))) == coth(log(-tan(15)))\n+    assert coth(log(tan(18))) == coth(log(-tan(18)))\n+\n+    # Additional edge cases to ensure stability\n+    for n in range(20, 25):\n+        assert coth(log(tan(n))) == coth(log(-tan(n)))\n     x, y = symbols('x,y')\n \n     k = Symbol('k', integer=True)\n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..6402ce1 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -187,6 +187,22 @@ def test_col_join():\n                    [0, 0, 1],\n                    [7, 7, 7]])\n \n+def test_issue_13643_col_insert():\n+    # Reproduce the issue using sympy's eye and ones\n+    import sympy as sm\n+    M = sm.eye(6)\n+    V = 2 * sm.ones(6, 2)\n+    result = M.col_insert(3, V)\n+    expected = sm.Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    assert result == expected\n+\n def test_row_insert():\n     r4 = Matrix([[4, 4, 4]])\n     for i in range(-4, 5):\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..72a15af 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -616,7 +616,41 @@ def test_latex_Range():\n     assert latex(Range(-2, -oo, -1)) == r'\\left\\{-2, -3, \\ldots, -\\infty\\right\\}'\n \n \n-def test_latex_sequences():\n+from sympy import symbols, init_printing, SeqFormula, SeqPer, SeqAdd, SeqMul, oo\n+\n+def test_latex_sequences_correct_brackets():\n+    # Define symbols\n+    a = symbols('a')\n+\n+    # Initialize pretty printing (though not strictly needed for test)\n+    init_printing()\n+\n+    # Test for correct Latex rendering without backslash for brackets\n+    s1 = SeqFormula(a**2, (0, oo))\n+    assert latex(s1) == r'[0, 1, 4, 9, \\ldots]'\n+\n+    s3 = SeqFormula(a**2, (0, 2))\n+    assert latex(s3) == r'[0, 1, 4]'\n+\n+    s5 = SeqFormula(a**2, (-oo, 0))\n+    assert latex(s5) == r'[\\ldots, 9, 4, 1, 0]'\n+\n+    # Additional test sequences\n+    s2 = SeqPer((1, 2))\n+    assert latex(s2) == r'[1, 2, 1, 2, \\ldots]'\n+    \n+    s4 = SeqPer((1, 2), (0, 2))\n+    assert latex(s4) == r'[1, 2, 1]'\n+\n+    s6 = SeqPer((1, 2), (-oo, 0))\n+    assert latex(s6) == r'[\\ldots, 2, 1, 2, 1]'\n+\n+    assert latex(SeqAdd(s1, s2)) == r'[1, 3, 5, 11, \\ldots]'\n+    assert latex(SeqAdd(s3, s4)) == r'[1, 3, 5]'\n+    assert latex(SeqAdd(s5, s6)) == r'[\\ldots, 11, 5, 3, 1]'\n+    assert latex(SeqMul(s1, s2)) == r'[0, 2, 4, 18, \\ldots]'\n+    assert latex(SeqMul(s3, s4)) == r'[0, 2, 4]'\n+    assert latex(SeqMul(s5, s6)) == r'[\\ldots, 18, 4, 2, 0]'\n     s1 = SeqFormula(a**2, (0, oo))\n     s2 = SeqPer((1, 2))\n \n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..54cc347 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,17 @@\n+\n+def test_Poly_RR_yz_domain():\n+    from sympy import Poly\n+    from sympy.abc import x, y, z\n+\n+    # Testing the correct initialization of Poly with domain 'RR[y,z]'\n+    poly = Poly(1.2 * x * y * z, x, domain='RR[y,z]')\n+    assert poly.as_expr() == 1.2*y*z*x\n+    assert poly.gens == (x,)\n+    assert poly.get_domain() == RR[y, z]\n+\n+    # Testing OptionError for invalid domain specification within the Poly class\n+    raises(OptionError, lambda: Poly(1.2 * x * y * z, x, domain='InvalidDomain'))\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +20,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n",
  "sympy__sympy-14774": "",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..3ff4b11 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6111,7 +6111,18 @@ u(\"\"\"\\\n     assert upretty((1/y)*e.j) == ucode_str\n \n \n+from sympy import MatrixSymbol, pretty\n+from sympy.abc import n, a, x\n+\n def test_MatrixSymbol_printing():\n+    # Test for issue #14814\n+    x = MatrixSymbol('x', n, n)\n+    y = MatrixSymbol('y*', n, n)\n+    assert pretty(x + y) == \"x + y*\"\n+    assert pretty(-a*x + -2*y*y) == \"-a*x - 2*y*\"\n+    assert pretty(y + x) == \"y* + x\"\n+    assert pretty(-y + x) == \"-y* + x\"\n+    assert pretty(x + -y) == \"x - y*\"\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n     B = MatrixSymbol(\"B\", 3, 3)\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..cc98232 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -724,6 +724,19 @@ def test_dummification():\n     #Test that \\alpha was properly dummified\n     lam = lambdify((alpha, t), 2*alpha + t)\n     assert lam(2, 1) == 5\n+\n+def test_curly_matrix_symbol():\n+    import sympy as sy\n+    # Issue with `lambdify` and MatrixSymbol names with curly braces\n+    curlyv = sy.MatrixSymbol(\"{v}\", 2, 1)\n+    \n+    # Test without dummify=True should now work without SyntaxError\n+    lam = sy.lambdify(curlyv, curlyv)\n+    assert lam([1, 2]) == [1, 2]  # Sample test to ensure it runs\n+    \n+    # Test with dummify=True\n+    lam_dummified = sy.lambdify(curlyv, curlyv, dummify=True)\n+    assert lam_dummified([1, 2]) == [1, 2]  # Sample test to ensure it runs, even with dummification\n     raises(SyntaxError, lambda: lambdify(F(t) * G(t), F(t) * G(t) + 5))\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 2 * F(t) + 5))\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 4 * F(t) + 5))\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..7eaf694 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..1ae2ad1 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1717,6 +1717,28 @@ def test_issue_13651():\n     assert latex(expr) == r\"c - \\left(a + b\\right)\"\n \n \n+def test_indexed_matrix_expression():\n+    # Symbols and matrix definitions for testing\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    \n+    # The expected output after the fix\n+    expected_latex = r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n+    \n+    # Test the latex output for the indexed matrix expression\n+    assert latex((M*N)[i, j]) == expected_latex\n+\n+    # Test with specific values for k\n+    k_val = 3\n+    M = MatrixSymbol(\"M\", k_val, k_val)\n+    N = MatrixSymbol(\"N\", k_val, k_val)\n+\n+    expected_latex_specific = r'\\sum_{i_{1}=0}^{2} M_{i, i_{1}} N_{i_{1}, j}'\n+    assert latex((M*N)[i, j]) == expected_latex_specific\n+\n+from sympy import symbols, MatrixSymbol, latex\n+\n def test_latex_UnevaluatedExpr():\n     x = symbols(\"x\")\n     he = UnevaluatedExpr(1/x)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..a8249a8 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, exp, Eq\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -9,7 +10,23 @@ def test_idiff():\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     t = Symbol('t', real=True)\n-    # the use of idiff in ellipse also provides coverage\n+    f = Function('f')\n+    g = Function('g')\n+\n+    # Test case for idiff using function notation instead of y\n+    assert idiff(f(x)*exp(f(x)) - x*exp(x), f(x), x) == (x + 1)*exp(x - f(x))/(f(x) + 1)\n+\n+    # Test with two functions as dependent variables\n+    assert idiff(f(x) - g(x), [f(x), g(x)], x) == Derivative(g(x), x)\n+\n+    # Test with a mix of function and symbol\n+    assert idiff(f(x) - y*exp(x), [f(x), y], x) == (y + Derivative(y, x))*exp(x)\n+\n+    # Test where y appears first in the list\n+    assert idiff(f(x) - y*exp(x), [y, f(x)], x) == -y + exp(-x)*Derivative(f(x), x)\n+\n+    # Test the idiff using Eq\n+    assert idiff(Eq(y*exp(y), x*exp(x)), y, x).simplify() == (x + 1)*exp(x - y)/(y + 1)\n     circ = x**2 + y**2 - 4\n     ans = -3*x*(x**2 + y**2)/y**5\n     assert ans == idiff(circ, y, x, 3).simplify()\n",
  "sympy__sympy-16792": "",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..5bff562 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -342,8 +342,18 @@ def test_intersection():\n     # issue 12178\n     assert Intersection() == S.UniversalSet\n \n-\n-def test_issue_9623():\n+from sympy import Intersection, Eq, S, symbols, Piecewise\n+\n+def test_issue_duplicates():\n+    # Test case for intersection with duplicates\n+    x = symbols('x')\n+    # Should return an empty set when elements do not match any symbolically\n+    assert Intersection({1}, {1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    # Should remove duplicates initially and return intersection considering symbols\n+    assert Intersection({1}, {1, 2}) == {1}\n+    assert Intersection({1}, {1}) == {1}\n+    # Edge case where it remains unevaluated due to symbolic uncertainty\n+    assert Intersection({1}, {1}, {x}, evaluate=False).args == frozenset([{1}, {x}])\n     n = Symbol('n')\n \n     a = S.Reals\n",
  "sympy__sympy-17022": "diff --git a/sympy/printing/tests/test_numpy.py b/sympy/printing/tests/test_numpy.py\nindex fa5ed1f..93abb61 100644\n--- a/sympy/printing/tests/test_numpy.py\n+++ b/sympy/printing/tests/test_numpy.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Piecewise, lambdify, Equality, Unequality, Sum, Mod, cbrt, sqrt,\n     MatrixSymbol, BlockMatrix\n@@ -25,6 +26,22 @@ def test_numpy_piecewise_regression():\n     p = Piecewise((1, x < 0), (0, True))\n     assert NumPyPrinter().doprint(p) == 'numpy.select([numpy.less(x, 0),True], [1,0], default=numpy.nan)'\n \n+def test_issue_17006():\n+    if not np:\n+        skip(\"NumPy not installed\")\n+\n+    M = MatrixSymbol(\"M\", 2, 2)\n+\n+    f = lambdify(M, M + Identity(2))\n+    ma = np.array([[1, 2], [3, 4]])\n+    mr = np.array([[2, 2], [3, 5]])\n+\n+    assert (f(ma) == mr).all()\n+\n+    from sympy import symbols\n+    n = symbols('n', integer=True)\n+    N = MatrixSymbol(\"M\", n, n)\n+    raises(NotImplementedError, lambda: lambdify(N, N + Identity(n)))\n \n def test_sum():\n     if not np:\n",
  "sympy__sympy-17139": "diff --git a/sympy/simplify/tests/test_fu.py b/sympy/simplify/tests/test_fu.py\nindex 135b4cd..d4e629d 100644\n--- a/sympy/simplify/tests/test_fu.py\n+++ b/sympy/simplify/tests/test_fu.py\n@@ -67,6 +67,17 @@ def test_TR3():\n         j = TR3(i)\n         assert verify_numerically(i, j) and i.func != j.func\n \n+    # issue 17137\n+    assert T(sin(x)**I, sin, cos, h, 4, True) == sin(x)**I\n+    assert T(sin(x)**(2*I + 1), sin, cos, h, 4, True) == sin(x)**(2*I + 1)\n+\n+def test_issue_17137_fu():\n+    from sympy import cos, simplify, Symbol, I\n+    x = Symbol('x')\n+    assert simplify(cos(x)**I) == cos(x)**I\n+    assert simplify(cos(x)**(2 + 3*I)) == cos(x)**(2 + 3*I)\n+    assert simplify(cos(x)**(I - 1)) == cos(x)**(I - 1)\n+\n \n def test__TR56():\n     h = lambda x: 1 - x\n",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..5aa0004 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,12 +1,17 @@\n-from sympy import I, Rational, Symbol, pi, sqrt, S\n+\n+from sympy import I, Rational, Symbol, pi, sqrt, S, sympify\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.pytest import raises, warns\n \n-\n-def test_point():\n+def test_multiplication_with_sympify():\n+    point1 = Point(0, 0)\n+    point2 = Point(1, 1)\n+    # Test the multiplication order does not affect the result\n+    assert (point1 + point2 * sympify(2.0)) == (point1 + sympify(2.0) * point2)\n+    # Test that original point test still passes after fix\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n@@ -120,6 +125,7 @@ def test_point():\n \n \n def test_point3D():\n+    # Test that original point test still passes after fix\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..d081a7e 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1894,7 +1894,28 @@ def test_normal():\n     assert e.normal() == e\n \n \n+from sympy import Symbol, sympify\n+from sympy.abc import x\n+\n def test_expr():\n+    # Ensure that == does not trigger unwanted evaluation of object reprs\n+    class C:\n+        def __repr__(self):\n+            return 'x.y'\n+\n+    assert (Symbol('x') == C()) is False\n+    assert (Symbol('x') != C()) is True\n+\n+    # Test similar scenario where repr is exactly the symbol\n+    class D:\n+        def __repr__(self):\n+            return 'x'\n+\n+    assert (Symbol('x') == D()) is False\n+    assert (Symbol('x') != D()) is True\n+\n+    # Ensure that sympify doesn't allow string evaluation in such cases\n+    assert sympify(D()) != Symbol('x')\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n \n@@ -1902,4 +1923,4 @@ def test_expr():\n def test_ExprBuilder():\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..0ac78da 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -547,6 +547,17 @@ def test_diophantine():\n     assert diophantine(x**2 + y**2 +3*x- 5, permute=True) == \\\n         set([(-1, 1), (-4, -1), (1, -1), (1, 1), (-4, 1), (-1, -1), (4, 1), (4, -1)])\n \n+    # Test issue 18186\n+    x, y = symbols('x y', integer=True)\n+    assert diophantine(y**4 + x**4 - 2**4 - 3**4, syms=(x, y), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    assert diophantine(y**4 + x**4 - 2**4 - 3**4, syms=(y, x), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    # Additional tests to confirm no syms order dependency without permute\n+    assert diophantine(y**4 + x**4 - 2**4 - 3**4, syms=(x, y), permute=False) == \\\n+        {(2, 3)}\n+    assert diophantine(y**4 + x**4 - 2**4 - 3**4, syms=(y, x), permute=False) == \\\n+        {(3, 2)}\n     # issue 18122\n     assert check_solutions(x**2-y)\n     assert check_solutions(y**2-x)\n",
  "sympy__sympy-18532": "diff --git a/sympy/codegen/tests/test_cnodes.py b/sympy/codegen/tests/test_cnodes.py\nindex c30dccd..8f21ce2 100644\n--- a/sympy/codegen/tests/test_cnodes.py\n+++ b/sympy/codegen/tests/test_cnodes.py\n@@ -1,6 +1,7 @@\n+\n from sympy.core.symbol import symbols\n from sympy.printing.ccode import ccode\n-from sympy.codegen.ast import Declaration, Variable, float64, int64\n+from sympy.codegen.ast import Declaration, Variable, float64, int64, String\n from sympy.codegen.cnodes import (\n     alignof, CommaOperator, goto, Label, PreDecrement, PostDecrement, PreIncrement, PostIncrement,\n     sizeof, union, struct\n@@ -66,7 +67,7 @@ def test_sizeof():\n     assert ccode(sz) == 'sizeof(%s)' % typename\n     assert sz.func(*sz.args) == sz\n     assert not sz.is_Atom\n-    assert all(atom == typename for atom in sz.atoms())\n+    assert sz.atoms() == {String(typename), String('sizeof')}  # Test for atoms behavior for `sizeof`\n \n \n def test_struct():\n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..85fe803 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,16 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_BlockDiagMatrix_single_element_to_Matrix():\n+    from sympy import Matrix, BlockDiagMatrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    try:\n+        B = Matrix(D)\n+        assert B == M\n+    except TypeError as e:\n+        raise AssertionError(\"Failed to convert BlockDiagMatrix with a single element to Matrix: {}\".format(e))\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..2c77c34 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,7 +1,8 @@\n+\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n-from sympy.testing.pytest import raises\n+from sympy.testing.pytest import raises, XFAIL\n from sympy.matrices.expressions.matexpr import MatrixElement, MatrixExpr\n \n k, l, m, n = symbols('k l m n', integer=True)\n@@ -67,6 +68,25 @@ def test_Identity_index():\n \n \n def test_block_index():\n+    # New test case to ensure no incorrect simplifications happen\n+    A = MatrixSymbol('A', 1, 1)\n+    B = MatrixSymbol('B', n, 1)\n+    C = BlockMatrix([[A], [B]])\n+    \n+    # Test accessing an element that may exist in both A and B\n+    assert C[i, 0] == MatrixElement(C, i, 0)\n+    assert C[0, 0] == A[0, 0]\n+    assert C[1, 0] == B[0, 0]\n+\n+    @XFAIL\n+    def test_block_index_symbolic_fail():\n+        # To make this work, symbolic matrix dimensions would need to be somehow assumed nonnegative\n+        # even if the symbols aren't specified as such.  Then 2 * n < n would correctly evaluate to\n+        # False in BlockMatrix._entry()\n+        A1 = MatrixSymbol('A1', n, 1)\n+        A2 = MatrixSymbol('A2', m, 1)\n+        A = BlockMatrix([[A1], [A2]])\n+        assert A[2 * n, 0] == A2[n, 0]\n     I = Identity(3)\n     Z = ZeroMatrix(3, 3)\n     B = BlockMatrix([[I, I], [I, I]])\n",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..2607ec1 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -317,7 +317,25 @@ def test_sign():\n     assert sign(d).func is sign or sign(d) == 0\n \n \n-def test_as_real_imag():\n+def test_sign_rewrite_abs():\n+    from sympy import Abs, Piecewise, Symbol, Eq\n+\n+    x = Symbol('x')\n+    assert sign(x).rewrite(Abs) == Piecewise((0, Eq(x, 0)), (x/Abs(x), True))\n+\n+    y = Symbol('y', real=True)\n+    assert sign(y).rewrite(Abs) == Piecewise((0, Eq(y, 0)), (y/Abs(y), True))\n+\n+    # Complex expression case\n+    z = Symbol('z', complex=True)\n+    assert sign(z).rewrite(Abs) == z/Abs(z)\n+\n+    # Case for x = 0\n+    zero_case = Symbol('zero_case', zero=True)\n+    assert sign(zero_case).rewrite(Abs) == 0\n+\n+    # Ensure rewriting does not impact existing complex behavior\n+    assert sign(3 + 4*I).rewrite(Abs) == (3 + 4*I) / 5\n     n = pi**1000\n     # the special code for working out the real\n     # and complex parts of a power with Integer exponent\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..324f402 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -470,8 +470,15 @@ def test_multiset_permutations():\n         [1, 1, 0, 0, 0]\n         6\\n''')\n \n-\n-def test_partitions():\n+def test_partitions_memory_safety():\n+    iter1 = partitions(6, k=2)\n+    obj1 = next(iter1)\n+    obj2 = next(iter1)\n+    # Check if two consecutive partitions are the same object (should not be)\n+    assert obj1 is not obj2\n+    obj3 = next(partitions(6, k=2))\n+    # Check if a new iterator returns a different object\n+    assert obj1 is not obj3\n     ans = [[{}], [(0, {})]]\n     for i in range(2):\n         assert list(partitions(0, size=i)) == ans[i]\n",
  "sympy__sympy-20212": "diff --git a/sympy/core/tests/test_power.py b/sympy/core/tests/test_power.py\nindex 686973b..e020fd5 100644\n--- a/sympy/core/tests/test_power.py\n+++ b/sympy/core/tests/test_power.py\n@@ -254,6 +254,14 @@ def test_power_rewrite_exp():\n                     (sin, cos, tan, sec, csc, sinh, cosh, tanh))\n \n \n+def test_issue_19572():\n+    # Test cases related to the issue\n+    assert Pow(0, -oo) == zoo\n+    assert (0 ** -oo) == zoo\n+    assert Pow(S.Zero, S.NegativeInfinity) == zoo\n+\n+from sympy import S, symbols, zoo, oo, Pow\n+\n def test_zero():\n     x = Symbol('x')\n     y = Symbol('y')\n",
  "sympy__sympy-20442": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 6a8906d..13c7bb2 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,7 +1,10 @@\n+\n from sympy import (Abs, Add, Function, Number, Rational, S, Symbol,\n                    diff, exp, integrate, log, sin, sqrt, symbols)\n from sympy.physics.units import (amount_of_substance, convert_to, find_unit,\n                                  volume, kilometer)\n+from sympy import Rational\n+from sympy.physics.units import joule\n from sympy.physics.units.definitions import (amu, au, centimeter, coulomb,\n     day, foot, grams, hour, inch, kg, km, m, meter, millimeter,\n     minute, quart, s, second, speed_of_light, bit,\n@@ -45,8 +48,21 @@ def test_convert_to():\n     assert q.convert_to(s) == q\n     assert speed_of_light.convert_to(m) == speed_of_light\n \n+def test_issue_convert_to_unit_mismatch():\n+    expr = joule * second\n+    # Test conversion to joule, expecting the same expression back\n+    result = convert_to(expr, joule)\n+    assert result == expr, f\"Expected {expr}, but got {result}\"\n+\n+    # Verify other related examples from the issue\n+    result = convert_to(joule * second, joule * second)\n+    assert result == joule * second, f\"Expected {joule * second}, but got {result}\"\n+\n+    result = convert_to(joule * second, kg * m**2 / s)\n+    assert result == kg * m**2 / s, f\"Expected {kg * m**2 / s}, but got {result}\"\n \n-def test_Quantity_definition():\n+    result = convert_to(joule * second, minute)\n+    assert result == joule * minute / 60, f\"Expected {joule * minute / 60}, but got {result}\"\n     q = Quantity(\"s10\", abbrev=\"sabbr\")\n     q.set_global_relative_scale_factor(10, second)\n     u = Quantity(\"u\", abbrev=\"dam\")\n",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..75e1074 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -33,8 +33,15 @@ def test_structure():\n     assert b21.func(*b21.args) == b21\n     assert bool(b1)\n \n+def test_no_dict_in_symbol():\n+    from sympy import Symbol\n+    s = Symbol('x')\n \n-def test_equality():\n+    # Ensure that the __dict__ attribute is not present for Symbol instances\n+    assert not hasattr(s, '__dict__')\n+\n+    # Ensure that the __slots__ still correctly defines only 'name'\n+    assert s.__slots__ == ('name',)\n     instances = [b1, b2, b3, b21, Basic(b1, b1, b1), Basic]\n     for i, b_i in enumerate(instances):\n         for j, b_j in enumerate(instances):\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..6e51b12 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n                    atan, atan2, nan, Symbol, re, im, sign)\n from sympy.abc import w, x, y, z\n@@ -160,6 +161,16 @@ def test_sign():\n     x = Symbol('x', complex=True)\n     assert refine(sign(x), Q.zero(x)) == 0\n \n+def test_arg():\n+    x = Symbol('x', complex=True)\n+    assert refine(arg(x), Q.positive(x)) == 0\n+    assert refine(arg(x), Q.negative(x)) == pi\n+\n+def test_integral_with_assumptions():\n+    a, x = symbols('a x')\n+    J = Integral(sin(x) * exp(-a * x), (x, 0, oo))\n+    assert refine(J.doit(), Q.positive(a)) == 1 / (a**2 + 1)\n+\n \n def test_func_args():\n     class MyClass(Expr):\n",
  "sympy__sympy-21379": "diff --git a/sympy/functions/elementary/tests/test_piecewise.py b/sympy/functions/elementary/tests/test_piecewise.py\nindex 400b22e..e9f628d 100644\n--- a/sympy/functions/elementary/tests/test_piecewise.py\n+++ b/sympy/functions/elementary/tests/test_piecewise.py\n@@ -165,7 +165,28 @@ def test_piecewise1():\n     assert isinstance(p, Piecewise) and p.is_commutative is True\n \n \n-def test_piecewise_free_symbols():\n+def test_issue_21373():\n+    from sympy.functions.elementary.hyperbolic import sinh, cosh, tanh\n+\n+    x_r, y_r, z = symbols('x_r y_r z', real=True)\n+\n+    expressions = [\n+        exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z)),\n+        exp(cosh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z)),\n+        exp(tanh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z)),\n+        sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z),\n+        exp(Piecewise((x_r, y_r > x_r), (y_r, True)))\n+    ]\n+\n+    for expr in expressions:\n+        clear_cache()\n+        assert expr.subs({1: 1.0}) is not None\n+\n+    # Ensure known failing modifications pass\n+    for expr_fn in [sinh, cosh, tanh, lambda expr: expr]:\n+        expr = exp(expr_fn(Piecewise((x_r, y_r > x_r), (y_r, True))))\n+        clear_cache()\n+        assert expr.subs({1: 1.0}) is not None\n     f = Piecewise((x, a < 0), (y, True))\n     assert f.free_symbols == {x, y, a}\n \n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..e16b5bb 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,3 +1,5 @@\n+\n+from sympy.core.function import Derivative\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n@@ -34,6 +36,15 @@ def test_Symbol_kind():\n     assert comm_x.kind is NumberKind\n     assert noncomm_x.kind is UndefinedKind\n \n+def test_Derivative_kind():\n+    A = MatrixSymbol('A', 2, 2)\n+    d_number = Derivative(comm_x, comm_x)\n+    d_matrix = Derivative(A, comm_x)\n+\n+    # Verify the kind attribute\n+    assert d_number.kind is NumberKind\n+    assert d_matrix.kind is MatrixKind(NumberKind)\n+\n def test_Integral_kind():\n     A = MatrixSymbol('A', 2,2)\n     assert Integral(comm_x, comm_x).kind is NumberKind\n",
  "sympy__sympy-21847": "",
  "sympy__sympy-22005": "",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..c6e1ae3 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n@@ -8,6 +9,7 @@ from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate, GeometryEntity\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n+from sympy.core.parameters import evaluate\n from sympy.utilities.misc import Undecidable\n from sympy.testing.pytest import raises, warns\n \n@@ -443,8 +445,26 @@ def test_unit():\n def test_dot():\n     raises(TypeError, lambda: Point(1, 2).dot(Line((0, 0), (1, 1))))\n \n-\n-def test__normalize_dimension():\n+def test_issue_22684():\n+    # Check if the issue with evaluate(False) is resolved\n+    with evaluate(False):\n+        p = Point2D(1, 2)\n+        assert isinstance(p, Point2D)\n+        assert p == Point(1, 2)\n+\n+    # Check using S to create Point2D\n+    with evaluate(False):\n+        p = S('Point2D(Integer(1),Integer(2))')\n+        assert isinstance(p, Point)\n+        assert p == Point(1, 2)\n+\n+    # Check without using evaluate context manager\n+    p_default = Point2D(1, 2)\n+    assert isinstance(p_default, Point2D)\n+    assert p_default == Point(1, 2)\n+\n+    # Check creating imaginary points is still not allowed\n+    raises(ValueError, lambda: Point2D(1 + I, 2))\n     assert Point._normalize_dimension(Point(1, 2), Point(3, 4)) == [\n         Point(1, 2), Point(3, 4)]\n     assert Point._normalize_dimension(\n",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..d3e8a8f 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -337,6 +337,7 @@ def test_cse_Indexed():\n     replacements, reduced_exprs = cse([expr1, expr2])\n     assert len(replacements) > 0\n \n+from sympy import symbols, MatrixSymbol, cse, Matrix\n \n def test_cse_MatrixSymbol():\n     # MatrixSymbols have non-Basic args, so make sure that works\n@@ -347,6 +348,20 @@ def test_cse_MatrixSymbol():\n     B = MatrixSymbol(\"B\", n, n)\n     assert cse(B) == ([], [B])\n \n+    # Test for issue with cse and MatrixSymbol indexing\n+    C = MatrixSymbol(\"C\", 4, 4)\n+    indexed_expr = C[0, 0] * C[0, 1] + C[0, 2] * C[1, 1]\n+    replacements, reduced_expr = cse(indexed_expr)\n+    assert replacements == [(symbols(\"x0\"), C[0, 0] * C[0, 1])]\n+    assert reduced_expr == [symbols(\"x0\") + C[0, 2] * C[1, 1]]\n+\n+    # Cross-check with Matrix\n+    M = Matrix(4, 4, lambda i, j: symbols('M_%d_%d' % (i, j)))\n+    expr = M[0, 0] * M[0, 1] + M[0, 2] * M[1, 1]\n+    replacements, reduced_expr = cse(expr)\n+    assert replacements == [(symbols(\"x0\"), M[0, 0] * M[0, 1])]\n+    assert reduced_expr == [symbols(\"x0\") + M[0, 2] * M[1, 1]]\n+\n def test_cse_MatrixExpr():\n     A = MatrixSymbol('A', 3, 3)\n     y = MatrixSymbol('y', 3, 1)\n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..d2a43b2 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -37,8 +38,13 @@ def test_array_negative_indices():\n \n         assert test_array[-1, -1] == 10\n \n-\n-def test_issue_18361():\n+def test_issue_17851_empty_array_creation():\n+    for array_type in array_types:\n+        # Test creation of an empty array of each type\n+        A = array_type([])\n+        assert isinstance(A, array_type), f\"Instance type mismatch for {array_type}\"\n+        assert A.shape == (0,), f\"Shape mismatch for empty {array_type}\"\n+        assert list(A) == [], f\"Contents mismatch for empty {array_type}\"\n     A = Array([sin(2 * x) - 2 * sin(x) * cos(x)])\n     B = Array([sin(x)**2 + cos(x)**2, 0])\n     C = Array([(x + x**2)/(x*sin(y)**2 + x*cos(y)**2), 2*sin(x)*cos(x)])\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..ab9e2f9 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,6 +1175,22 @@ def test_scipy_polys():\n \n \n \n+import inspect\n+from sympy import lambdify\n+\n+def test_lambdify_singleton_tuple():\n+    # Test to ensure tuples with a single element are returned correctly\n+    f_singleton = lambdify([], (1,))\n+    source = inspect.getsource(f_singleton)\n+    assert source == 'def _lambdifygenerated():\\n    return (1,)\\n'\n+    assert f_singleton() == (1,)\n+\n+    # Test for two elements tuple to ensure existing behavior\n+    f_two_elements = lambdify([], (1, 2))\n+    source = inspect.getsource(f_two_elements)\n+    assert source == 'def _lambdifygenerated():\\n    return (1, 2)\\n'\n+    assert f_two_elements() == (1, 2)\n+\n def test_lambdify_inspect():\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..dda09d7 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -528,7 +528,51 @@ def test_issue_22819():\n     assert Da.scale_factor == 1.66053906660000e-24\n \n \n-def test_issue_20288():\n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units import Quantity, Dimension\n+    from sympy import exp\n+    from sympy.physics.units.systems.si import SI\n+\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n+\n+def test_issue_24062_variation():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units import Quantity, Dimension\n+    from sympy import exp\n+    from sympy.physics.units.systems.si import SI\n+\n+    R = Quantity('Resistance')\n+    C = Quantity('Capacitance')\n+    T = Quantity('Duration')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(2, ohm)  # Different scaling factor\n+    C.set_global_relative_scale_factor(0.5, farad)  # Different scaling factor\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 2 + exp(expr)  # Different expression\n+    assert SI._collect_factor_and_dimension(exp_expr) == (2 + E, Dimension(1))\n     from sympy.core.numbers import E\n     from sympy.physics.units import energy\n     u = Quantity('u')\n",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..5ec87df 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -45,8 +45,25 @@ def test_tensor_product_expand():\n     assert TP(A + B, B + C).expand(tensorproduct=True) == \\\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n-\n-def test_tensor_product_commutator():\n+def test_tensor_product_expand_bug_fix_issue():\n+    assert TP(A - B, B - A).expand(tensorproduct=True) == \\\n+        TP(A, B) - TP(A, A) - TP(B, B) + TP(B, A)\n+    assert TP(2 * A + B, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A, A) + 2 * TP(A, B) + TP(B, A) + TP(B, B)\n+    assert TP(2 * A * B + A, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A*B, A) + 2 * TP(A*B, B) + TP(A, A) + TP(A, B)\n+\n+    # Additional test cases\n+    U = Operator('U')\n+    V = Operator('V')\n+\n+    # Specific case described in the bug issue\n+    P = TensorProduct(2 * U - V, U + V)\n+    assert P.expand(tensorproduct=True) == \\\n+        2 * TensorProduct(U, U) + 2 * TensorProduct(U, V) - TensorProduct(V, U) - TensorProduct(V, V)\n+\n+    P = TensorProduct(U - U, U + V)\n+    assert P.expand(tensorproduct=True) == 0\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n         TP(A*B, C) - TP(B*A, C)\n     assert Comm(TP(A, B), TP(B, C)).doit() == \\\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..3e32893 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -9,6 +10,8 @@ from sympy.functions.elementary.complexes import Abs\n from sympy.functions.elementary.exponential import (exp, log)\n from sympy.functions.elementary.miscellaneous import sqrt\n from sympy.functions.elementary.trigonometric import sin\n+from sympy.physics.units import time, velocity, acceleration, second, meter, Quantity\n+from sympy.physics.units.systems.si import SI\n from sympy.integrals.integrals import integrate\n from sympy.physics.units import (amount_of_substance, area, convert_to, find_unit,\n                                  volume, kilometer, joule, molar_gas_constant,\n@@ -562,7 +565,35 @@ def test_issue_24062():\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n \n-def test_prefixed_property():\n+def test_issue_24211():\n+    V1 = Quantity('V1')\n+    SI.set_quantity_dimension(V1, velocity)\n+    SI.set_quantity_scale_factor(V1, 1 * meter / second)\n+    A1 = Quantity('A1')\n+    SI.set_quantity_dimension(A1, acceleration)\n+    SI.set_quantity_scale_factor(A1, 1 * meter / second**2)\n+    T1 = Quantity('T1')\n+    SI.set_quantity_dimension(T1, time)\n+    SI.set_quantity_scale_factor(T1, 1 * second)\n+\n+    expr = A1*T1 + V1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr)\n+\n+def test_issue_24211_with_negative_factor():\n+    V1 = Quantity('V1')\n+    SI.set_quantity_dimension(V1, velocity)\n+    SI.set_quantity_scale_factor(V1, 2 * meter / second)\n+    A1 = Quantity('A1')\n+    SI.set_quantity_dimension(A1, acceleration)\n+    SI.set_quantity_scale_factor(A1, -9.8 * meter / second**2)\n+    T1 = Quantity('T1')\n+    SI.set_quantity_dimension(T1, time)\n+    SI.set_quantity_scale_factor(T1, 5 * second)\n+\n+    expr = A1*T1 + V1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr)\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..7e40bbc 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, milli, volt\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n@@ -22,7 +23,9 @@ def test_prefix_operations():\n     assert 1 / m == k\n     assert k / m == M\n \n-    assert dodeca * dodeca == 144\n+    assert m * W == W / 1000  # Test case for milli*W evaluating correctly\n+    assert milli * W == W / 1000  # Additional test case for milli*W\n+    assert milli * volt == volt / 1000  # Test milli*volt to ensure the pattern repeats correctly\n     assert 1 / dodeca == S.One / 12\n     assert k / dodeca == S(1000) / 12\n     assert dodeca / dodeca == 1\n",
  "django__django-12470": "diff --git a/tests/model_inheritance/models.py b/tests/model_inheritance/models.py\nindex 5dd5a37..333eb26 100644\n--- a/tests/model_inheritance/models.py\n+++ b/tests/model_inheritance/models.py\n@@ -183,8 +183,9 @@ class GrandParent(models.Model):\n     class Meta:\n         unique_together = ('first_name', 'last_name')\n \n-\n class Parent(GrandParent):\n+    class Meta:\n+        ordering = ['-pk']\n     pass\n \n \n",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..6d03700 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,7 +343,33 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n-    def test_order_by_f_expression(self):\n+    def test_order_by_self_referencing_fk(self):\n+        # Add some authors and articles\n+        author_1 = Author.objects.create(name=\"Author 1\")\n+        author_2 = Author.objects.create(name=\"Author 2\")\n+\n+        a1 = Article.objects.create(author=author_1, headline=\"Article 1\")\n+        a2 = Article.objects.create(author=author_2, headline=\"Article 2\")\n+\n+        author_1.editor = author_2  # self-referencing foreign key\n+        author_1.save()\n+        \n+        # Test different order_by cases\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline'),\n+        )\n+        \n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'),\n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline'),\n+        )\n+\n+        # Check for correct SQL generation\n+        qs = Article.objects.filter(author__isnull=False).order_by('author__editor_id')\n+        print(qs.query)  # Manually verify the generated SQL contains correct ordering\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n                 \"Article 1\",\n",
  "django__django-13265": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..c234df7 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3201,8 +3201,40 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         form = SomeForm()\n         self.assertEqual(form['field'].id_for_label, 'myCustomID')\n         self.assertEqual(form['field_none'].id_for_label, 'id_field_none')\n+    def test_checkboxselectmultiple_id_for_label_respects_custom_id(self):\n+        \"\"\"\n+        Ensure BoundWidget.id_for_label uses the custom 'id' set in ChoiceWidget.options\n+        for CheckboxSelectMultiple widgets.\n+        \"\"\"\n+        class CustomIDForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('value1', 'Choice 1'), ('value2', 'Choice 2')],\n+                widget=CheckboxSelectMultiple,\n+            )\n+\n+        form = CustomIDForm(auto_id='custom_%s')\n+        subwidgets = form['field'].subwidgets\n+        \n+        # Ensure the custom ID is utilized\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_field_1')\n+\n+    def test_checkboxselectmultiple_id_for_label_without_custom_id(self):\n+        \"\"\"\n+        Test the case when no custom 'id' is set; it should default to auto_id pattern.\n+        \"\"\"\n+        class DefaultIDForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('value1', 'Choice 1'), ('value2', 'Choice 2')],\n+                widget=CheckboxSelectMultiple,\n+            )\n+\n+        form = DefaultIDForm(auto_id='id_%s')\n+        subwidgets = form['field'].subwidgets\n \n-    def test_boundfield_widget_type(self):\n+        # Ensure defaults are as expected\n+        self.assertEqual(subwidgets[0].id_for_label, 'id_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'id_field_1')\n         class SomeForm(Form):\n             first_name = CharField()\n             birthday = SplitDateTimeField(widget=SplitHiddenDateTimeWidget)\n",
  "django__django-16400": "diff --git a/tests/auth_tests/test_management.py b/tests/auth_tests/test_management.py\nindex de2502e..25aba20 100644\n--- a/tests/auth_tests/test_management.py\n+++ b/tests/auth_tests/test_management.py\n@@ -1484,4 +1484,46 @@ class CreatePermissionsTests(TestCase):\n                 content_type__app_label=opts.app_label,\n                 codename=codename,\n             ).exists()\n-        )\n+        )\n+\n+\n+from django.test import TestCase, override_settings\n+from django.apps import apps\n+from django.core.management import call_command\n+from django.contrib.auth.models import Permission\n+\n+class CustomDBRouter:\n+    \"\"\"\n+    A database router that routes read/write operations to a custom database\n+    and prints ops for testing visibility.\n+    \"\"\"\n+    def db_for_read(self, model, **hints):\n+        print(\"router: read\")\n+        return \"custom\"\n+\n+    def db_for_write(self, model, **hints):\n+        print(\"router: write\")\n+        return \"custom\"\n+\n+\n+@override_settings(DATABASE_ROUTERS=[CustomDBRouter()], DATABASES={\n+    'default': {...},  # add necessary default database config\n+    'custom': {...},  # add necessary custom database config\n+})\n+class MigrateCommandDatabaseParameterTests(TestCase):\n+\n+    def test_migrate_command_respects_database_parameter(self):\n+        \"\"\"\n+        Test that calling the migrate management command with a specified\n+        database parameter respects that parameter for all DB operations,\n+        including Permission creation.\n+        \"\"\"\n+        # Ensure no permissions exist on the 'custom' database initially\n+        Permission.objects.using(\"custom\").delete()\n+\n+        # Run the migrate command with the 'custom' database parameter\n+        with self.assertNumQueries(6, using=\"custom\"):\n+            call_command(\"migrate\", database=\"custom\", app_label=\"auth\")\n+\n+        # Verify that permissions are created in the 'custom' database\n+        self.assertTrue(Permission.objects.using(\"custom\").exists())\n",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..6c868e9 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -641,6 +641,36 @@ def test_colorbar_format(fmt):\n \n \n def test_colorbar_scale_reset():\n+    # Test that colorbar updates correctly when LogNorm is set on the mappable\n+    x, y = np.ogrid[-4:4:31j, -4:4:31j]\n+    z = 10**np.random.normal(1, 1, size=(50, 50))\n+\n+    fig, ax = plt.subplots()\n+    pcm = ax.pcolormesh(z, cmap='RdBu_r', rasterized=True)\n+    cbar = fig.colorbar(pcm, ax=ax)\n+    \n+    # Initially linear scale\n+    assert cbar.ax.yaxis.get_scale() == 'linear'\n+\n+    # Change normalization to LogNorm and update colorbar\n+    pcm.set_norm(LogNorm())\n+    cbar.update_normal(pcm)\n+    # Ensure the colorbar updated to log scale\n+    assert cbar.ax.yaxis.get_scale() == 'log'\n+    assert pcm.norm.vmin == z.min() and pcm.norm.vmax == z.max()\n+\n+    # Revert normalization to linear using Normalize and update colorbar\n+    pcm.set_norm(Normalize(vmin=-20, vmax=20))\n+    cbar.update_normal(pcm)\n+    # Ensure the colorbar updated back to linear scale\n+    assert cbar.ax.yaxis.get_scale() == 'linear'\n+\n+    # Test for zero division error or any exception during normalization\n+    try:\n+        pcm.set_norm(LogNorm())\n+        cbar.update_normal(pcm)\n+    except ZeroDivisionError:\n+        assert False, \"Caught ZeroDivisionError during LogNorm update\"\n     x, y = np.ogrid[-4:4:31j, -4:4:31j]\n     z = 120000*np.exp(-x**2 - y**2)\n \n",
  "pydata__xarray-4094": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex a2826fa..e659aad 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -3045,7 +3045,13 @@ class TestDataset:\n         d0 = D.isel(x=0)\n         assert_identical(d0, x0)\n \n-    def test_to_stacked_array_to_unstacked_dataset_different_dimension(self):\n+    def test_to_stacked_array_to_unstacked_dataset_single_dimension(self):\n+        # single dimension: regression test for GH4049\n+        arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+        data = xr.Dataset({\"a\": arr, \"b\": arr})\n+        stacked = data.to_stacked_array(\"y\", sample_dims=[\"x\"])\n+        unstacked = stacked.to_unstacked_dataset(\"y\")\n+        assert_identical(unstacked, data)\n         # test when variables have different dimensionality\n         a, b = create_test_stacked_array()\n         sample_dims = [\"x\"]\n",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..74a4084 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -259,4 +259,31 @@ def test_set_output_mro():\n     class C(A, B):\n         pass\n \n-    assert C().transform(None) == \"B\"\n+    assert C().transform(None) == \"B\"\n+\n+def test_feature_union_pandas_transform():\n+    \"\"\"Test FeatureUnion with a custom transformer and `pandas` output.\"\"\"\n+    import pandas as pd\n+    from sklearn.pipeline import FeatureUnion\n+\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+\n+    class MyTransformer(BaseEstimator, TransformerMixin):\n+        def fit(self, X: pd.DataFrame, y: pd.Series | None = None, **kwargs):\n+            return self\n+\n+        def transform(self, X: pd.DataFrame, y: pd.Series | None = None) -> pd.DataFrame:\n+            return X[\"value\"].groupby(X[\"date\"]).sum()\n+\n+    # Test with `pandas` output\n+    set_config(transform_output=\"pandas\")\n+    union = FeatureUnion([(\"my_transformer\", MyTransformer())])\n+    transformed = union.fit_transform(data)\n+\n+    # The expected result would be a DataFrame with the aggregated sums (as a single column).\n+    expected_index = pd.Index([index[0].date() + pd.DateOffset(days=i) for i in range(4)])\n+    expected_data = pd.DataFrame({'my_transformer__value': [240] * 4}, index=expected_index)\n+    \n+    pd.testing.assert_frame_equal(transformed, expected_data)\n",
  "sphinx-doc__sphinx-8801": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 37d6e17..3d1d78c 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -131,6 +131,30 @@ def test_decorators(app):\n         '',\n     ]\n \n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_attributes_in_superclass(app):\n+    options = {\"members\": None,\n+               \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'target.uninitialized_attributes.Bar', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.uninitialized_attributes',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.uninitialized_attributes',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.uninitialized_attributes',\n+        '      :type: str',\n+        '',\n+    ]\n \n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_slots_attribute(app):\n",
  "sympy__sympy-15346": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex cce4836..d52d701 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     symbols, sin, simplify, cos, trigsimp, rad, tan, exptrigsimp,sinh,\n     cosh, diff, cot, Subs, exp, tanh, exp, S, integrate, I,Matrix,\n@@ -353,7 +354,25 @@ def test_issue_2827_trigsimp_methods():\n     M = Matrix.eye(1)\n     assert all(trigsimp(M, method=m) == M for m in\n         'fu matching groebner old'.split())\n-    # watch for E in exptrigsimp, not only exp()\n+def test_issue_15129_trigsimp_methods():\n+    t1 = Matrix([sin(Rational(1, 50)), cos(Rational(1, 50)), 0])\n+    t2 = Matrix([sin(Rational(1, 25)), cos(Rational(1, 25)), 0])\n+    t3 = Matrix([cos(Rational(1, 25)), sin(Rational(1, 25)), 0])\n+    r1 = t1.dot(t2)\n+    r2 = t1.dot(t3)\n+    assert trigsimp(r1) == cos(S(1)/50)\n+    assert trigsimp(r2) == sin(S(3)/50)\n+\n+def test_issue_15129_acos_simplification():\n+    r = sin(Rational(1, 50))*sin(Rational(1, 25)) + cos(Rational(1, 50))*cos(Rational(1, 25))\n+    # Correct simplification of r is expected to be cos(1/50 - 1/25)\n+    assert trigsimp(r) == cos(S(1)/50 - S(1)/25)\n+\n+    simplified_result = trigsimp(r)\n+    computed_angle = acos(simplified_result)\n+\n+    # Check if acos of simplified result simplifies as expected\n+    assert simplify(computed_angle) == S(1)/25 - S(1)/50\n     eq = 1/sqrt(E) + E\n     assert exptrigsimp(eq) == eq\n \n",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..cfcac98 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4862,8 +4862,24 @@ k = \u2500\u2500\u2500\u2500\u2500                                \\n\\\n     assert pretty(expr) == ascii_str\n     assert upretty(expr) == ucode_str\n \n+def test_sum_pretty_print_alignment():\n+    from sympy import Sum, oo, pprint\n+    from sympy.abc import x\n+\n+    expr = Sum(x, (x, 1, oo)) + 3\n+    ucode_str = \\\n+    u('''\n+  \u221e    \n+ ___   \n+ \u2572     \n+  \u2572   x\n+  \u2571   +3\n+ \u2571     \n+ \u203e\u203e\u203e   \n+x = 1  \n+''')\n \n-def test_units():\n+    assert upretty(expr) == ucode_str\n     expr = joule\n     ascii_str1 = \\\n \"\"\"\\\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex b2b6202..da46f20 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -705,7 +705,30 @@ def test_uniq():\n         [2, 3, 4, [2], [1], [3]]\n \n \n-def test_kbins():\n+def test_modification_during_iteration():\n+    f = [1]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    f = [[1]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Additional test cases\n+    f = list('THISTLE')\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    f = [1, 2, 3, 4]\n+    raises(RuntimeError, lambda: [f.pop() for i in uniq(f)])\n+\n+    f = [1, 2, 2, 3]\n+    raises(RuntimeError, lambda: [f.pop(0) for i in uniq(f)])\n+\n+    f = list('THISTLE')\n+    try:\n+        for i in uniq(f):\n+            f.remove(i)\n+    except RuntimeError:\n+        pass\n+    else:\n+        assert False, \"Expected a RuntimeError when modifying the list during iteration\"\n     assert len(list(kbins('1123', 2, ordered=1))) == 24\n     assert len(list(kbins('1123', 2, ordered=11))) == 36\n     assert len(list(kbins('1123', 2, ordered=10))) == 10\n",
  "django__django-11797": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 7beeac3..c49374d 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -1,3 +1,4 @@\n+\n import collections.abc\n from datetime import datetime\n from math import ceil\n@@ -7,6 +8,7 @@ from django.core.exceptions import FieldError\n from django.db import connection\n from django.db.models.expressions import Exists, OuterRef\n from django.db.models.functions import Substr\n+from django.db.models import Max\n from django.test import TestCase, skipUnlessDBFeature\n \n from .models import (\n",
  "django__django-15320": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 35f7f03..1698613 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -546,6 +546,26 @@ class BasicExpressionsTests(TestCase):\n         subquery_test2 = Company.objects.filter(pk=Subquery(small_companies.filter(num_employees=3)))\n         self.assertCountEqual(subquery_test2, [self.foobar_ltd])\n \n+    def test_subquery_as_sql(self):\n+        from django.db import connection\n+        from django.test import TestCase\n+        from apps.models import App\n+\n+        # the setup below assumes there exists a model App in the apps.models with some fields\n+        apps_all = App.objects.all()\n+        subquery = Subquery(apps_all)\n+\n+        # Assert that the subquery flag is True by default\n+        self.assertTrue(subquery.query.subquery)\n+\n+        # Compile and test the generated SQL\n+        compiler = subquery.query.get_compiler('default', connection)\n+        sql, params = subquery.as_sql(compiler, connection)\n+\n+        # Verify that the resulting SQL is well-formed\n+        self.assertTrue(sql.startswith('(SELECT ') and sql.endswith(')'))\n+        self.assertEqual(params, ())\n+\n     def test_uuid_pk_subquery(self):\n         u = UUIDPK.objects.create()\n         UUID.objects.create(uuid_fk=u)\n",
  "django__django-15819": "diff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py\nindex 0ecd041..b052b7b 100644\n--- a/tests/inspectdb/tests.py\n+++ b/tests/inspectdb/tests.py\n@@ -432,9 +432,34 @@ class InspectDBTestCase(TestCase):\n         self.assertIn(\"# Unable to inspect table 'nonexistent'\", output)\n         # The error message depends on the backend\n         self.assertIn(\"# The error was:\", output)\n-\n+from .models import People, Message\n \n class InspectDBTransactionalTests(TransactionTestCase):\n+    \"\"\"\n+    Tests for verifying the behavior of `inspectdb` related to foreign key field generation.\n+    \"\"\"\n+\n+    def test_related_name_auto_generation(self):\n+        \"\"\"\n+        Test that `inspectdb` generates unique `related_name` for ForeignKey fields\n+        pointing to the same model to avoid reverse accessor clashes.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch(\n+            \"django.db.connection.introspection.get_table_list\",\n+            return_value=[TableInfo(name=\"inspectdb_message\", type=\"t\")],\n+        ):\n+            call_command(\"inspectdb\", table_name_filter=lambda tn: \"inspectdb_message\" in tn, stdout=out)\n+        output = out.getvalue()\n+        self.assertIn(\n+            \"author = models.ForeignKey('InspectdbPeople', models.DO_NOTHING, related_name='inspectdbmessage_authors')\",\n+            output\n+        )\n+        # Check for additional ForeignKey fields that should have unique related_names\n+        self.assertIn(\n+            \"from_field = models.ForeignKey('InspectdbPeople', models.CASCADE, related_name='inspectdbmessage_from_field_set')\",\n+            output\n+        )\n     available_apps = [\"inspectdb\"]\n \n     def test_include_views(self):\n",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..ef3fc8e 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -151,6 +152,15 @@ class ExistingRelatedInstancesTests(TestCase):\n             pools = list(Pool.objects.prefetch_related(\"poolstyle\").order_by(\"pk\"))\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n+    def test_multilevel_filtered_relation_select_related_issue(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation(\"pool__tournament__pool\")\n+                ).select_related(\"tournament_pool\", \"tournament_pool__tournament\")\n+            )\n+            # Assert that the tournament of the pool matches the tournament of the tournament_pool\n+            self.assertEqual(p[0].pool.tournament, p[0].tournament_pool.tournament)\n \n     def test_reverse_fk_select_related_multiple(self):\n         with self.assertNumQueries(1):\n@@ -163,4 +173,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex ad1a5e1..ed64ea1 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1,3 +1,21 @@\n+\n+def test_dpi_stability_after_unpickling():\n+    # Set initial DPI\n+    initial_dpi = 100\n+    fig = plt.figure(dpi=initial_dpi)\n+    current_dpi = fig.dpi\n+    \n+    for _ in range(32):\n+        # Pickle and then unpickle the figure\n+        fig_data = pickle.dumps(fig)\n+        fig = pickle.loads(fig_data)\n+        \n+        # Verify that the DPI hasn't changed\n+        assert fig.dpi == current_dpi, f\"Expected DPI to remain {current_dpi}, but got {fig.dpi}\"\n+\n+    # Ensure DPI is still the initial DPI after looping\n+    assert fig.dpi == initial_dpi, f\"Expected DPI to remain {initial_dpi} after all operations, but got {fig.dpi}\"\n+\n import copy\n from datetime import datetime\n import io\n@@ -12,6 +30,8 @@ import pytest\n from PIL import Image\n \n import matplotlib as mpl\n+import matplotlib.pyplot as plt\n+import pickle\n from matplotlib import gridspec, rcParams\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n from matplotlib.axes import Axes\n",
  "mwaskom__seaborn-2848": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 5a5e126..b1999b5 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -1,3 +1,4 @@\n+\n from itertools import product\n import numpy as np\n import matplotlib as mpl\n@@ -7,6 +8,7 @@ from matplotlib.colors import same_color, to_rgba\n import pytest\n from numpy.testing import assert_array_equal\n \n+import seaborn as sns\n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n \n@@ -1623,7 +1625,17 @@ class TestScatterPlotter(SharedAxesLevelTests, Helpers):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n-    def test_linewidths(self, long_df):\n+    def test_pairgrid_with_categorical_hue(self):\n+        iris = sns.load_dataset(\"iris\")\n+        try:\n+            g = sns.PairGrid(iris, y_vars=[\"sepal_length\",\"sepal_width\"], x_vars=[\"petal_length\",\"petal_width\"])\n+            g.map(sns.scatterplot, hue=iris[\"species\"])\n+            g.map(sns.regplot, scatter=False)\n+            # If no exception is raised, the test passes\n+            assert True\n+        except Exception as e:\n+            # If any error is raised, fail the test and print the exception\n+            assert False, f\"Test failed due to an exception: {e}\"\n \n         f, ax = plt.subplots()\n \n",
  "pytest-dev__pytest-5413": "diff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 226bfb9..8795f0a 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -333,6 +333,8 @@ def test_excinfo_exconly():\n     assert msg.endswith(\"world\")\n \n \n+import pytest\n+\n def test_excinfo_repr():\n     excinfo = pytest.raises(ValueError, h)\n     s = repr(excinfo)\n@@ -347,7 +349,17 @@ def test_excinfo_str():\n     assert len(s.split(\":\")) >= 3  # on windows it's 4\n \n \n-def test_excinfo_for_later():\n+def test_excinfo_str_on_pytest_raises():\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\"A\\nB\\nC\")\n+    \n+    # Test the difference between str(excinfo) and str(excinfo.value)\n+    regular_str_output = str(excinfo)\n+    assert regular_str_output.startswith(__file__[:-9]), f\"Unexpected str output: {regular_str_output}\"\n+    assert \"<console>:3: LookupError: A\" in regular_str_output, f\"Unexpected str output: {regular_str_output}\"\n+    \n+    exception_value_output = str(excinfo.value)\n+    assert exception_value_output == \"A\\nB\\nC\", f\"Unexpected str(excinfo.value) output: {exception_value_output}\"\n     e = ExceptionInfo.for_later()\n     assert \"for raises\" in repr(e)\n     assert \"for raises\" in str(e)\n",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..b88a0f0 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -402,6 +402,13 @@ class TestCustomConftests:\n         )\n         testdir.mkdir(\"sub\")\n         testdir.makepyfile(\"def test_x(): pass\")\n+        # Test with the long option --collect-only\n+        result = testdir.runpytest(\"--collect-only\")\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+\n+        # Test with the short option -C\n+        result = testdir.runpytest(\"-C\")\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n \n",
  "sphinx-doc__sphinx-10451": "",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..50ce143 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -84,7 +84,22 @@ def test_Identity():\n     assert In.inverse() == In\n     assert In.conjugate() == In\n \n-def test_Identity_doit():\n+def test_Identity():\n+    A = MatrixSymbol('A', n, m)\n+    In = Identity(n)\n+    Im = Identity(m)\n+\n+    assert A*Im == A\n+    assert In*A == A\n+\n+    assert transpose(In) == In\n+    assert In.inverse() == In\n+    assert In.conjugate() == In\n+\n+    # Additional tests for issue verification\n+    # Verify the total sum of elements in the Identity matrix In is n\n+    total_sum = Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).doit()\n+    assert total_sum == n\n     Inn = Identity(Add(n, n, evaluate=False))\n     assert isinstance(Inn.rows, Add)\n     assert Inn.doit() == Identity(2*n)\n",
  "sympy__sympy-20049": "",
  "sympy__sympy-21612": ""
}