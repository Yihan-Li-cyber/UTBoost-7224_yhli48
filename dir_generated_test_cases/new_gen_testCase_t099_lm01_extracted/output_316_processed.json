{
  "astropy__astropy-12907": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 88711b0..aae8700 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -52,7 +52,15 @@ compound_models = {\n     'cm7': (map2 | p2 & sh1,\n             (np.array([False, True]),\n              np.array([[True, False], [False, True]]))\n-            )\n+            ),\n+    # New test case for nested compound models\n+    'cm_nested': (models.Pix2Sky_TAN() & cm,\n+                  (np.array([False, False, True, True]),\n+                   np.array([[True,  True, False, False],\n+                             [True,  True, False, False],\n+                             [False, False, True,  False],\n+                             [False, False, False, True]]))\n+                 )\n }\n \n \n",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..62502ea 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n from io import StringIO\n@@ -5,6 +6,52 @@ from io import StringIO\n from astropy.io import ascii\n \n from .common import assert_almost_equal, assert_equal\n+from io import StringIO\n+from astropy.table import QTable\n+import numpy as np\n+\n+def test_rst_with_header_rows():\n+    \"\"\"Round-trip a table with header_rows specified\"\"\"\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct     \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\",\n+    ]\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"wave\"].dtype == np.float64\n+    assert tbl[\"response\"].dtype == np.float32\n+    assert tbl[\"ints\"].dtype == np.int8\n+\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert out.getvalue().splitlines() == lines\n+\n+def test_write_rst_with_header_rows():\n+    \"\"\"Test writing a QTable with header_rows specified in RST format.\"\"\"\n+    tbl = QTable({\n+        'wave': [350, 950] * u.nm,\n+        'response': [0.7, 1.2] * u.count,\n+    })\n+    expected_output = [\n+        \"===== ========\",\n+        \" wave response\",\n+        \"  nm      ct  \",\n+        \"===== ========\",\n+        \"350.0      0.7\",\n+        \"950.0      1.2\",\n+        \"===== ========\",\n+    ]\n+\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\n+    assert out.getvalue().splitlines() == expected_output\n \n \n def assert_equal_splitlines(arg1, arg2):\n",
  "astropy__astropy-14365": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 9b66109..baa4e54 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -108,8 +108,43 @@ def test_roundtrip(tmp_path):\n     for meta_name in [\"initial_comments\", \"comments\"]:\n         assert meta_name in new_table.meta\n \n+import pytest\n+import numpy as np\n+from astropy.io.ascii.qdp import _read_table_qdp, _write_table_qdp\n+from astropy.utils.exceptions import AstropyUserWarning\n+\n+def lowercase_header(value):\n+    \"\"\"Make every non-comment line lower case.\"\"\"\n+    lines = []\n+    for line in value.splitlines():\n+        if not line.startswith(\"!\"):\n+            line = line.lower()\n+        lines.append(line)\n+    return \"\\n\".join(lines)\n+\n+@pytest.mark.parametrize(\"lowercase\", [False, True])\n+def test_roundtrip_lowercase(tmp_path, lowercase):\n+    example_qdp = \"\"\"\n+    ! Test for lower and upper case QDP commands\n+    READ SERR 1 2\n+    !MJD         Err(1)          Err(2)          Rate        Error\n+    53000.123    0.1             0.1             1.0         0.1\n+    \"\"\"\n+    \n+    if lowercase:\n+        example_qdp = lowercase_header(example_qdp)\n \n-def test_read_example():\n+    path = str(tmp_path / \"test_lowercase.qdp\")\n+    \n+    with open(path, \"w\") as fp:\n+        print(example_qdp, file=fp)\n+        \n+    table = _read_table_qdp(path, names=[\"MJD\", \"Rate\"], table_id=0)\n+    data_row = table[0]\n+    \n+    assert np.isclose(data_row[\"MJD\"], 53000.123)\n+    assert np.isclose(data_row[\"Rate\"], 1.0)\n+    assert np.isclose(data_row[\"Rate_err\"], 0.1)\n     example_qdp = \"\"\"\n         ! Initial comment line 1\n         ! Initial comment line 2\n",
  "astropy__astropy-14995": "diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py\nindex fc27f69..a10777e 100644\n--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py\n+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py\n@@ -28,7 +28,34 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n         return False\n \n \n-# Test with Data covers:\n+import numpy as np\n+from astropy.nddata import NDDataRef\n+import pytest\n+\n+def test_nddata_mask_propagation_issue():\n+    # This test checks the fix for mask propagation issue described in the issue statement.\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+\n+    # Multiply mask by constant (mask * no mask)\n+    result_mask_const = nref_mask.multiply(1.0, handle_mask=np.bitwise_or).mask\n+    np.testing.assert_equal(result_mask_const, mask, err_msg=\"Mask not propagated correctly when multiplied by a constant\")\n+\n+    # Multiply mask by non-masked operand (mask * no mask)\n+    result_mask_nomask = nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask\n+    np.testing.assert_equal(result_mask_nomask, mask, err_msg=\"Mask not propagated correctly when multiplied with non-masked operand\")\n+\n+    # New checks for other mask propagation scenarios\n+    new_mask = np.array([[32, 16, 8], [4, 2, 1], [0, 128, 64]])\n+    nref_newmask = NDDataRef(array, mask=new_mask)\n+\n+    # Multiply nref_mask with nref_newmask and check mask propagation using np.bitwise_or\n+    expected_combined_mask = np.bitwise_or(mask, new_mask)\n+    result_combined_mask = nref_mask.multiply(nref_newmask, handle_mask=np.bitwise_or).mask\n+    np.testing.assert_equal(result_combined_mask, expected_combined_mask, err_msg=\"Combined mask not correctly calculated with bitwise_or\")\n # scalars, 1D, 2D and 3D\n # broadcasting between them\n @pytest.mark.filterwarnings(\"ignore:divide by zero encountered.*\")\n",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..bcb0f3b 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -299,8 +299,25 @@ class TestTableFunctions(FitsTestCase):\n         assert comparerecords(hdu.data, hdul[1].data)\n         hdul.close()\n         a.close()\n-\n-    def test_endianness(self):\n+    \n+    def test_fitsrec_d_exponent_replacement(self):\n+        # Create a column with 'D' format and add some data\n+        r1 = np.array([1.2345678901234567e10, 9.876543210987654e-10])\n+        c2 = fits.Column(name='def', format='D', array=r1)\n+        hdu = fits.TableHDU.from_columns([c2])\n+        \n+        # Write to a temporary FITS file\n+        hdu.writeto(self.temp('test_d_exponent.fits'), overwrite=True)\n+        \n+        # Read the file content directly\n+        with open(self.temp('test_d_exponent.fits')) as f:\n+            content = f.read()\n+            assert '1.2345678901234567D+10' in content\n+            assert '9.8765432109876543D-10' in content\n+\n+        with fits.open(self.temp('test_d_exponent.fits')) as hdul:\n+            # Verify the data was correctly saved and read back\n+            assert comparerecords(hdu.data, hdul[1].data)\n         x = np.ndarray((1,), dtype=object)\n         channelsIn = np.array([3], dtype='uint8')\n         x[0] = channelsIn\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..4d76e64 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1090,6 +1090,14 @@ class OverrideSettingsTests(SimpleTestCase):\n         base_url attribute of django.core.files.storage.default_storage.\n         \"\"\"\n         self.assertEqual(default_storage.base_location, '')\n+\n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        By default, FILE_UPLOAD_PERMISSIONS should be 0o644 if not explicitly set.\n+        \"\"\"\n+        # Ensure FILE_UPLOAD_PERMISSIONS is not set\n+        with self.settings(FILE_UPLOAD_PERMISSIONS=None):\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n         with self.settings(MEDIA_URL='/test_value/'):\n             self.assertEqual(default_storage.base_url, '/test_value/')\n \n",
  "django__django-10924": "",
  "django__django-11001": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 4e3940c..9adef0a 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -376,7 +376,35 @@ class BasicExpressionsTests(TestCase):\n         )\n         self.assertEqual(str(qs.query).count('JOIN'), 2)\n \n-    def test_order_by_exists(self):\n+    def test_order_by_multiline_sql(self):\n+        # This test checks if multiple multiline RawSQL order_by clauses are preserved correctly\n+        raw_order_by = (\n+            RawSQL('''\n+                CASE WHEN status = 'active'\n+                     THEN last_login\n+                     ELSE date_joined END\n+            ''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN is_staff = false\n+                     THEN first_login\n+                     ELSE NULL END\n+            ''', []).asc(),\n+            RawSQL('''\n+                CASE WHEN is_active = true\n+                     THEN last_login\n+                     ELSE date_joined END\n+            ''', []).asc(),\n+        )\n+        \n+        for qs in (\n+            Company.objects.all(),\n+            Company.objects.distinct(),\n+        ):\n+            with self.subTest(qs=qs):\n+                self.assertSequenceEqual(\n+                    qs.order_by(*raw_order_by),\n+                    [self.example_inc, self.gmbh, self.foobar_ltd],  # Update this line with expected queryset ordering\n+                )\n         mary = Employee.objects.create(firstname='Mary', lastname='Mustermann', salary=20)\n         mustermanns_by_seniority = Employee.objects.filter(lastname='Mustermann').order_by(\n             # Order by whether the employee is the CEO of a company\n",
  "django__django-11039": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex dbcbef0..b59a4d2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -513,6 +513,27 @@ class MigrateTests(MigrationTestBase):\n             '[ ]  mutate_state_b.0002_add_field\\n',\n             out.getvalue()\n         )\n+    \n+    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations'})\n+    def test_sqlmigrate_respects_non_transactional_ddl(self):\n+        \"\"\"\n+        Transaction commands aren't shown for databases that don't support\n+        transactional DDL, regardless of migration.atomic setting.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command('sqlmigrate', 'migrations', '0001', stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        \n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries, \"Transaction start found in SQL for non-transactional DDL\")\n+        \n+        end_transaction_sql = connection.ops.end_transaction_sql()\n+        if end_transaction_sql:\n+            self.assertNotIn(end_transaction_sql.lower(), queries, \"Transaction end found in SQL for non-transactional DDL\")\n \n     @override_settings(INSTALLED_APPS=['migrations.migrations_test_apps.unmigrated_app'])\n     def test_showmigrations_plan_app_label_no_migrations(self):\n",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..04d52f4 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -72,10 +72,13 @@ class TestValidation(SimpleTestCase):\n         with self.assertRaises(exceptions.ValidationError) as cm:\n             field.clean('not a datetime', None)\n         self.assertEqual(cm.exception.code, 'invalid')\n+        expected_message = (\n+            \"'not a datetime' value has an invalid format. \"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n+        )\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n-            \"'not a datetime' value has an invalid format. \"\n-            \"It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            expected_message\n         )\n \n \n@@ -84,4 +87,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..e683609 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -248,7 +248,24 @@ class UsernameValidatorsTests(SimpleTestCase):\n                 with self.assertRaises(ValidationError):\n                     v(invalid)\n \n-    def test_ascii_validator(self):\n+    def test_unexpected_trailing_newline(self):\n+        \"\"\"\n+        Test that usernames with trailing newlines are considered invalid.\n+        \"\"\"\n+        invalid_usernames_with_newlines = [\n+            'username_with_newline\\n',\n+            'another_one\\r\\n',\n+            'newline_only_in_end\\n\\n',\n+        ]\n+        unicode_validator = validators.UnicodeUsernameValidator()\n+        ascii_validator = validators.ASCIIUsernameValidator()\n+        \n+        for invalid in invalid_usernames_with_newlines:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    unicode_validator(invalid)\n+                with self.assertRaises(ValidationError):\n+                    ascii_validator(invalid)\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n         invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n         v = validators.ASCIIUsernameValidator()\n@@ -258,4 +275,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..2475e9d 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -356,6 +356,16 @@ class HttpResponseTests(unittest.TestCase):\n         r = HttpResponse()\n         self.assertIsNone(r.get('test'))\n \n+    def test_memoryview_content(self):\n+        # Test memoryview assigned during initialization\n+        r = HttpResponse(memoryview(b'My Content'))\n+        self.assertEqual(r.content, b'My Content')\n+\n+        # Test memoryview assigned via property\n+        r = HttpResponse()\n+        r.content = memoryview(b'Another Content')\n+        self.assertEqual(r.content, b'Another Content')\n+\n     def test_non_string_content(self):\n         # Bug 16494: HttpResponse should behave consistently with non-strings\n         r = HttpResponse(12345)\n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..ca6e5a3 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,6 +1,8 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n+from django.db.models.deletion import Collector\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..928938e 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,9 +1,11 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n from django.contrib.auth.models import Permission, User\n from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n+from django.test.utils import captured_stdout\n \n from .models import Proxy, UserProxy\n \n@@ -140,7 +142,45 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n-    def test_user_keeps_same_permissions_after_migrating_backward(self):\n+    def test_migrate_with_existing_target_permission(self):\n+        \"\"\"\n+        Permissions may already exist:\n+\n+        - Old workaround was to manually create permissions for proxy models.\n+        - Model may have been concrete and then converted to proxy.\n+\n+        Output a reminder to audit relevant permissions.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        # Assume 'add_proxy' permission already exists (mimic existing state)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='display_proxys',\n+            name='May display proxys information',\n+        )\n+        with captured_stdout() as stdout:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        self.assertIn('A problem arose migrating proxy model permissions', stdout.getvalue())\n+\n+    def test_migrate_duplicate_permission_issue(self):\n+        \"\"\"\n+        Test handling of duplicate key value constraint during migration\n+        to ensure errors are caught and reported.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        # Create duplicate permission to simulate the issue\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        with self.assertRaises(django.db.utils.IntegrityError):\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n         user.user_permissions.add(self.custom_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..34fd76b 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -10,6 +10,7 @@ import types\n import weakref\n import zipfile\n from importlib import import_module\n+import sys\n from pathlib import Path\n from unittest import mock, skip, skipIf\n \n@@ -72,6 +73,10 @@ class TestIterModulesAndFiles(SimpleTestCase):\n \n         self.assertFileFound(filename.absolute())\n \n+    def test_main_module_is_resolved(self):\n+        main_module = sys.modules['__main__']\n+        self.assertFileFound(Path(main_module.__file__))\n+\n     def test_check_errors(self):\n         \"\"\"\n         When a file containing an error is imported in a function wrapped by\n",
  "django__django-11583": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 99e5edd..153fc27 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -141,6 +141,47 @@ class TestIterModulesAndFiles(SimpleTestCase):\n         self.assertEqual(autoreload.iter_modules_and_files((fake_main,), frozenset()), frozenset())\n \n \n+class TestEmbeddedNullByteHandling(SimpleTestCase):\n+    def test_path_with_embedded_null_bytes(self):\n+        # Existing test; ensures it stays\n+        for path in (\n+            'embedded_null_byte\\x00.py',\n+            'di\\x00rectory/embedded_null_byte.py',\n+        ):\n+            with self.subTest(path=path):\n+                self.assertEqual(\n+                    autoreload.iter_modules_and_files((), frozenset([path])),\n+                    frozenset(),\n+                )\n+\n+    def test_valid_paths(self):\n+        # Test with valid paths that should not result in errors\n+        valid_paths = [\n+            'normal_file.py',\n+            'directory/normal_file.py'\n+        ]\n+        for path in valid_paths:\n+            with self.subTest(path=path):\n+                # Should return the path resolved\n+                resolved = Path(path).resolve().absolute()\n+                self.assertIn(\n+                    resolved,\n+                    autoreload.iter_modules_and_files([], frozenset([path]))\n+                )\n+\n+    def test_file_not_found_handling(self):\n+        # Test that FileNotFoundError is gracefully handled\n+        missing_files = [\n+            'missing_file.py',\n+            '/missing/directory/missing_file.py'\n+        ]\n+        for path in missing_files:\n+            with self.subTest(path=path):\n+                self.assertEqual(\n+                    autoreload.iter_modules_and_files([], frozenset([path])),\n+                    frozenset()\n+                )\n+\n class TestCommonRoots(SimpleTestCase):\n     def test_common_roots(self):\n         paths = (\n",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..adec1be 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -11,6 +11,8 @@ from unittest import mock\n \n from django.core import mail\n from django.core.files.uploadedfile import SimpleUploadedFile\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n from django.db import DatabaseError, connection\n from django.shortcuts import render\n from django.template import TemplateDoesNotExist\n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..0804d2d 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -80,6 +80,59 @@ class BinaryFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n \n @isolate_apps('invalid_models_tests')\n class CharFieldTests(SimpleTestCase):\n@@ -111,6 +164,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_negative_max_length(self):\n         class Model(models.Model):\n             field = models.CharField(max_length=-1)\n@@ -124,6 +230,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_bad_max_length_value(self):\n         class Model(models.Model):\n             field = models.CharField(max_length=\"bad\")\n@@ -137,6 +296,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_str_max_length_value(self):\n         class Model(models.Model):\n             field = models.CharField(max_length='20')\n@@ -150,6 +362,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_str_max_length_type(self):\n         class Model(models.Model):\n             field = models.CharField(max_length=True)\n@@ -163,6 +428,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_non_iterable_choices(self):\n         class Model(models.Model):\n             field = models.CharField(max_length=10, choices='bad')\n@@ -176,6 +494,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_non_iterable_choices_two_letters(self):\n         \"\"\"Two letters isn't a valid choice pair.\"\"\"\n         class Model(models.Model):\n@@ -191,6 +562,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_iterable_of_iterable_choices(self):\n         class ThingItem:\n             def __init__(self, value, display):\n@@ -272,6 +696,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_choices_named_group_bad_structure(self):\n         class Model(models.Model):\n             field = models.CharField(\n@@ -293,6 +770,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_choices_named_group_lazy(self):\n         class Model(models.Model):\n             field = models.CharField(\n@@ -317,6 +847,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_bad_validators(self):\n         class Model(models.Model):\n             field = models.CharField(max_length=10, validators=[True])\n@@ -334,6 +917,59 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('LONG', 'Too Long Value'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (4 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_grouped_choices_too_long_for_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [\n+                        ('OK', 'Alright'),\n+                        ('LONGEST', 'Definitely Too Long'),\n+                    ]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_with_adequate_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=6,\n+                choices=[\n+                    ('LONG', 'Still Adequate'),\n+                    ('OK', 'Alright'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     @unittest.skipUnless(connection.vendor == 'mysql',\n                          \"Test valid only for MySQL\")\n     def test_too_long_char_field_under_mysql(self):\n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..b3ef064 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -246,8 +246,21 @@ class WriterTests(SimpleTestCase):\n             [list, tuple, dict, set, frozenset],\n             (\"[list, tuple, dict, set, frozenset]\", set())\n         )\n+    def test_enum_translation_issue(self):\n+        class TranslatedEnum(enum.Enum):\n+            GOOD = _('Good')\n+            BAD = _('Bad')\n \n-    def test_serialize_lazy_objects(self):\n+        field = models.CharField(\n+            default=TranslatedEnum.GOOD,\n+            choices=[(tag.name, tag.value) for tag in TranslatedEnum],\n+            max_length=128\n+        )\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.CharField(choices=[('GOOD', _('Good')), ('BAD', _('Bad'))], default=TranslatedEnum['GOOD'], max_length=128)\"\n+        )\n         pattern = re.compile(r'^foo$')\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..ba7303b 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,3 +1,4 @@\n+\n import unittest\n from datetime import datetime\n \n@@ -316,9 +317,31 @@ class HttpDateProcessingTests(unittest.TestCase):\n         parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n-    def test_parsing_rfc850(self):\n-        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n-        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850(self, mocked_datetime):\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+        utcnow_1 = datetime(2019, 11, 6, 8, 49, 37)\n+        utcnow_2 = datetime(2020, 11, 6, 8, 49, 37)\n+        utcnow_3 = datetime(2048, 11, 6, 8, 49, 37)\n+        tests = (\n+            (utcnow_1, 'Tuesday, 31-Dec-69 08:49:37 GMT', datetime(2069, 12, 31, 8, 49, 37)),\n+            (utcnow_1, 'Tuesday, 10-Nov-70 08:49:37 GMT', datetime(1970, 11, 10, 8, 49, 37)),\n+            (utcnow_1, 'Sunday, 06-Nov-94 08:49:37 GMT', datetime(1994, 11, 6, 8, 49, 37)),\n+            (utcnow_2, 'Wednesday, 31-Dec-70 08:49:37 GMT', datetime(2070, 12, 31, 8, 49, 37)),\n+            (utcnow_2, 'Friday, 31-Dec-71 08:49:37 GMT', datetime(1971, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Sunday, 31-Dec-00 08:49:37 GMT', datetime(2000, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Friday, 31-Dec-99 08:49:37 GMT', datetime(1999, 12, 31, 8, 49, 37)),\n+            # Additional boundary checks for year interpretation\n+            (utcnow_1, 'Friday, 31-Dec-49 23:59:59 GMT', datetime(2049, 12, 31, 23, 59, 59)), # +50 years\n+            (utcnow_1, 'Saturday, 01-Jan-50 00:00:00 GMT', datetime(1950, 1, 1, 0, 0, 0)), # -50 years\n+            (utcnow_1, 'Monday, 01-Jan-51 00:00:00 GMT', datetime(1951, 1, 1, 0, 0, 0)), # -50 years\n+        )\n+        for utcnow, rfc850str, expected_date in tests:\n+            with self.subTest(rfc850str=rfc850str):\n+                mocked_datetime.utcnow.return_value = utcnow\n+                parsed = parse_http_date(rfc850str)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n \n     def test_parsing_asctime(self):\n         parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..72fa7ef 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -40,6 +40,31 @@ class Gender(models.TextChoices):\n     __empty__ = '(Undeclared)'\n \n \n+from django.test import SimpleTestCase\n+from django.utils.translation import gettext_lazy as _\n+from django.db import models\n+\n+class MyChoice(models.TextChoices):\n+    FIRST_CHOICE = \"first\", _(\"The first choice, it is\")\n+    SECOND_CHOICE = \"second\", _(\"The second choice, it is\")\n+\n+class MyObject(models.Model):\n+    my_str_value = models.CharField(max_length=10, choices=MyChoice.choices)\n+\n+class EnumTest(TestCase):\n+    def setUp(self):\n+        self.my_object = MyObject.objects.create(my_str_value=MyChoice.FIRST_CHOICE)\n+\n+    def test_created_object_is_str(self):\n+        my_object = self.my_object\n+        self.assertIsInstance(my_object.my_str_value, str)\n+        self.assertEqual(str(my_object.my_str_value), \"first\")\n+\n+    def test_retrieved_object_is_str(self):\n+        my_object = MyObject.objects.last()\n+        self.assertIsInstance(my_object.my_str_value, str)\n+        self.assertEqual(str(my_object.my_str_value), \"first\")\n+\n class ChoicesTests(SimpleTestCase):\n     def test_integerchoices(self):\n         self.assertEqual(Suit.choices, [(1, 'Diamond'), (2, 'Spade'), (3, 'Heart'), (4, 'Club')])\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..9eda76a 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -150,7 +150,18 @@ class ChoicesTests(SimpleTestCase):\n \n class GetFieldDisplayTests(SimpleTestCase):\n \n-    def test_choices_and_field_display(self):\n+    def test_overriding_field_display(self):\n+        \"\"\"\n+        Test that get_FIELD_display() can be overridden in a Django model.\n+        \"\"\"\n+        class FooBar(models.Model):\n+            foo_bar = models.CharField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                return \"something\"\n+\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), \"something\")\n         \"\"\"\n         get_choices() interacts with get_FIELD_display() to return the expected\n         values.\n",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "diff --git a/tests/urlpatterns/path_urls.py b/tests/urlpatterns/path_urls.py\nindex 12487f2..e8ef46f 100644\n--- a/tests/urlpatterns/path_urls.py\n+++ b/tests/urlpatterns/path_urls.py\n@@ -12,6 +12,7 @@ urlpatterns = [\n     path('included_urls/', include('urlpatterns.included_urls')),\n     re_path(r'^regex/(?P<pk>[0-9]+)/$', views.empty_view, name='regex'),\n     re_path(r'^regex_optional/(?P<arg1>\\d+)/(?:(?P<arg2>\\d+)/)?', views.empty_view, name='regex_optional'),\n+    re_path(r'^module/(?P<format>(html|json|xml))?/?$', views.modules, name='modules'),\n     path('', include('urlpatterns.more_urls')),\n     path('<lang>/<path:url>/', views.empty_view, name='lang-and-path'),\n-]\n+]\n",
  "django__django-12284": "",
  "django__django-12286": "",
  "django__django-12308": "",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..5648bc9 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from unittest import mock\n \n@@ -6,6 +7,7 @@ from django.db.backends.base.creation import (\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n from django.test import SimpleTestCase\n+from ..models import Object, ObjectReference\n \n \n def get_connection_copy():\n",
  "django__django-12497": "diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 057ec3a..7254c5b 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -128,6 +128,38 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_ambiguous_relationship_model_with_incorrect_hint(self):\n+        \"\"\"\n+        Test that an AmbiguousRelationship with more than two ForeignKeys without through_fields\n+        correctly raises an error with the updated hint message.\n+        \"\"\"\n+\n+        class Person(models.Model):\n+            pass\n+\n+        class Group(models.Model):\n+            field = models.ManyToManyField('Person', through='AmbiguousRelationship')\n+\n+        class AmbiguousRelationship(models.Model):\n+            person = models.ForeignKey(Person, models.CASCADE)\n+            first_group = models.ForeignKey(Group, models.CASCADE, related_name='first')\n+            second_group = models.ForeignKey(Group, models.CASCADE, related_name='second')\n+\n+        field = Group._meta.get_field('field')\n+        self.assertEqual(field.check(from_model=Group), [\n+            Error(\n+                \"The model is used as an intermediate model by 'invalid_model_tests.Group.field', \"\n+                \"but it has more than one foreign key from 'Group', which is ambiguous. You must \"\n+                \"specify which foreign key Django should use via the through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"AmbiguousRelationship\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n+\n     def test_ambiguous_relationship_model(self):\n \n         class Person(models.Model):\n",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..b43f398 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1249,7 +1249,77 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n \n-    def test_request_meta_filtering(self):\n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n+    def test_cleanse_setting_nested_iterables(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            'outer_list': [\n+                {\n+                    'nested_dict': {\n+                        'username': 'user',\n+                        'password': 'secret',\n+                    }\n+                },\n+                [\n+                    {'api_key': 'abc123'},\n+                    {'token': 'def456'}\n+                ]\n+            ],\n+            'message': 'not sensitive'\n+        }\n+        expected = {\n+            'outer_list': [\n+                {\n+                    'nested_dict': {\n+                        'username': 'user',\n+                        'password': reporter_filter.cleansed_substitute,\n+                    }\n+                },\n+                [\n+                    {'api_key': reporter_filter.cleansed_substitute},\n+                    {'token': reporter_filter.cleansed_substitute}\n+                ]\n+            ],\n+            'message': 'not sensitive'\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            expected\n+        )\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n         self.assertEqual(\n",
  "django__django-12708": "diff --git a/tests/migrations/test_base.py b/tests/migrations/test_base.py\nindex d6e6fdb..fc3c06d 100644\n--- a/tests/migrations/test_base.py\n+++ b/tests/migrations/test_base.py\n@@ -54,6 +54,16 @@ class MigrationTestBase(TransactionTestCase):\n \n     def assertColumnNotNull(self, table, column, using='default'):\n         self.assertFalse(self._get_column_allows_null(table, column, using))\n+    def assertUniqueConstraintExists(self, table, columns, value=True, using='default'):\n+        with connections[using].cursor() as cursor:\n+            constraints = connections[using].introspection.get_constraints(cursor, table).values()\n+            self.assertEqual(\n+                value,\n+                any(c['unique'] for c in constraints if c['columns'] == list(columns)),\n+            )\n+\n+    def assertUniqueConstraintNotExists(self, table, columns):\n+        return self.assertUniqueConstraintExists(table, columns, False)\n \n     def assertIndexExists(self, table, columns, value=True, using='default', index_type=None):\n         with connections[using].cursor() as cursor:\n",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..b6393cb 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -685,7 +685,21 @@ class FastDeleteTests(TestCase):\n         self.assertNumQueries(2, a.delete)\n         self.assertEqual(User.objects.count(), 0)\n \n-    def test_fast_delete_empty_no_update_can_self_select(self):\n+    def test_delete_zero_objects_with_foreign_keys(self):\n+        \"\"\"\n+        Test delete() return value with zero objects, ensuring consistency for models with foreign keys.\n+        \"\"\"\n+        FileAccess.objects.create()  # Create and delete to clear any dependency objects.\n+        deletion_result = FileAccess.objects.all().delete()\n+        self.assertEqual(deletion_result, (0, {'delete.FileAccess': 0}))\n+\n+    def test_delete_zero_objects_without_foreign_keys(self):\n+        \"\"\"\n+        Test delete() return value with zero objects, ensuring consistency for models without foreign keys.\n+        \"\"\"\n+        BlockLibrary.objects.create()  # Create and delete to clear any dependency objects.\n+        deletion_result = BlockLibrary.objects.all().delete()\n+        self.assertEqual(deletion_result, (0, {'my_app.BlockLibrary': 0}))\n         \"\"\"\n         #25932 - Fast deleting on backends that don't have the\n         `no_update_can_self_select` feature should work even if the specified\n",
  "django__django-12856": "",
  "django__django-12915": "diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex 72f5bd1..a5c90c0 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -79,6 +79,19 @@ class ASGITest(SimpleTestCase):\n         # Allow response.close() to finish.\n         await communicator.wait()\n \n+    async def test_get_async_response(self):\n+        request = self.async_request_factory.get('/static/test/file.txt')\n+        handler = ASGIStaticFilesHandler(ASGIHandler())\n+        response = await handler.get_response_async(request)\n+        response.close()\n+        self.assertEqual(response.status_code, 200)\n+\n+    async def test_get_async_response_not_found(self):\n+        request = self.async_request_factory.get('/static/test/not-found.txt')\n+        handler = ASGIStaticFilesHandler(ASGIHandler())\n+        response = await handler.get_response_async(request)\n+        self.assertEqual(response.status_code, 404)\n+\n     async def test_headers(self):\n         application = get_asgi_application()\n         communicator = ApplicationCommunicator(\n",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..45911a6 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -197,6 +197,19 @@ class TestUtilsText(SimpleTestCase):\n             ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True),\n             ('\u4f60\u597d', '\u4f60\u597d', True),\n             ('\u0130stanbul', 'istanbul', True),\n+            # Original issue examples\n+            (' multiple---dash and  space ', 'multiple-dash-and-space', False),\n+            ('\\t whitespace-in-value \\n', 'whitespace-in-value', False),\n+            ('underscore_in-value', 'underscore-in-value', False),\n+            ('__strip__underscore-value___', 'strip-underscore-value', False),\n+            ('--strip-dash-value---', 'strip-dash-value', False),\n+            ('__strip-mixed-value---', 'strip-mixed-value', False),\n+            ('_ -strip-mixed-value _-', 'strip-mixed-value', False),\n+            # New test cases to verify the fix\n+            ('___This is a test ---', 'this-is-a-test', False),\n+            ('---Leading and trailing---', 'leading-and-trailing', False),\n+            ('_underscores-and-dashes_', 'underscores-and-dashes', False),\n+            ('-_-Mixed-_-_', 'mixed', False),\n         )\n         for value, output, is_unicode in items:\n             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n",
  "django__django-13028": "",
  "django__django-13158": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 070e08e..f10d24f 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -1,3 +1,4 @@\n+\n import operator\n \n from django.db import DatabaseError, NotSupportedError, connection\n@@ -86,6 +87,17 @@ class QuerySetSetOperationTests(TestCase):\n         reserved_name = qs1.difference(qs2).values_list('name', 'order', 'id').get()\n         self.assertEqual(reserved_name[:2], ('a', 2))\n \n+    def test_union_none(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.filter(num__gte=8)\n+        qs3 = qs1.union(qs2)\n+        \n+        # Applying .none() should return an empty queryset\n+        self.assertSequenceEqual(qs3.none(), [])\n+\n+        # Ensure that the union works correctly without .none()\n+        self.assertNumbersEqual(qs3, [0, 1, 8, 9], ordered=False)\n+\n     def test_union_with_empty_qs(self):\n         qs1 = Number.objects.all()\n         qs2 = Number.objects.none()\n@@ -313,4 +325,4 @@ class QuerySetSetOperationTests(TestCase):\n                         NotSupportedError,\n                         msg % (operation, combinator),\n                     ):\n-                        getattr(getattr(qs, combinator)(qs), operation)()\n+                        getattr(getattr(qs, combinator)(qs), operation)()\n",
  "django__django-13230": "",
  "django__django-13315": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 64b15bf..2fcf625 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2819,6 +2819,50 @@ class LimitChoicesToTests(TestCase):\n         fields = fields_for_model(StumpJoke, ['has_fooled_today'])\n         self.assertSequenceEqual(fields['has_fooled_today'].queryset, [self.threepwood])\n \n+    @isolate_apps('model_forms')\n+    def test_limit_choices_to_no_duplicates_custom(self):\n+        # Creating additional test case to ensure no duplicate choices due to complex limit_choices_to.\n+        marley2 = Character.objects.create(username=\"Marley2\", last_action=timezone.now())\n+        joke4 = StumpJoke.objects.create(funny=True, most_recently_fooled=marley2)\n+        joke5 = StumpJoke.objects.create(funny=True, most_recently_fooled=self.threepwood)\n+\n+        joke4.has_fooled_today.add(self.marley, self.threepwood)\n+        joke5.has_fooled_today.add(marley2, self.marley)\n+\n+        class CharacterDetailsExtra(models.Model):\n+            character1 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+            )\n+            character2 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to={\n+                    'jokes__funny': True,\n+                    'jokes_today__funny': True,\n+                },\n+            )\n+\n+        class CharacterDetailsExtraForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetailsExtra\n+                fields = '__all__'\n+\n+        form = CharacterDetailsExtraForm()\n+        self.assertCountEqual(\n+            form.fields['character1'].queryset,\n+            [self.marley, self.threepwood, marley2],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character2'].queryset,\n+            [self.marley, self.threepwood, marley2],\n+        )\n+        self.assertSequenceEqual(fields['has_fooled_today'].queryset, [self.threepwood])\n+\n     def test_callable_called_each_time_form_is_instantiated(self):\n         field = StumpJokeForm.base_fields['most_recently_fooled']\n         with mock.patch.object(field, 'limit_choices_to') as today_callable_dict:\n",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 536c423..89c954a 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -9,8 +9,34 @@ from django.test import SimpleTestCase\n from django.test.utils import isolate_apps\n \n \n+from django.db import models\n+from django.test.utils import isolate_apps\n @isolate_apps('model_inheritance')\n-class AbstractInheritanceTests(SimpleTestCase):\n+class FieldEqualityTests(SimpleTestCase):\n+    def test_inherited_field_inequality_from_different_models(self):\n+        class AbstractModel(models.Model):\n+            myfield = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class FirstModel(AbstractModel):\n+            pass\n+\n+        class SecondModel(AbstractModel):\n+            pass\n+\n+        first_field = FirstModel._meta.get_field('myfield')\n+        second_field = SecondModel._meta.get_field('myfield')\n+\n+        # They should not be equal as they belong to different models.\n+        self.assertNotEqual(first_field, second_field)\n+\n+        # Their hashes should also be different.\n+        self.assertNotEqual(hash(first_field), hash(second_field))\n+\n+        # Test ordering\n+        self.assertLess(first_field, second_field) or self.assertGreater(first_field, second_field)\n     def test_single_parent(self):\n         class AbstractBase(models.Model):\n             name = models.CharField(max_length=30)\n@@ -347,4 +373,4 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('age', models.SmallIntegerField), ('concretemodel2_ptr', models.OneToOneField),\n                 ('name', models.CharField),\n             ]\n-        )\n+        )\n",
  "django__django-13447": "diff --git a/tests/admin_views/test_adminsite.py b/tests/admin_views/test_adminsite.py\nindex 16a02bb..2d629d8 100644\n--- a/tests/admin_views/test_adminsite.py\n+++ b/tests/admin_views/test_adminsite.py\n@@ -45,7 +45,24 @@ class SiteEachContextTest(TestCase):\n         request.user = self.u1\n         self.assertEqual(site.each_context(request)['site_url'], '/my-script-name/')\n \n-    def test_available_apps(self):\n+    def test_model_class_in_app_list(self):\n+        ctx = self.ctx\n+        apps = ctx['available_apps']\n+\n+        # Test for models in admin_views\n+        admin_views = apps[0]\n+        article = admin_views['models'][0]\n+        self.assertEqual(article['object_name'], 'Article')\n+        # Verify if the 'model' is present and correct in 'admin_views'\n+        from .models import Article  # Assuming the Article model is defined in models.py of the same app\n+        self.assertEqual(article['model'], Article)\n+\n+        # Test for models in auth\n+        auth = apps[1]\n+        user = auth['models'][0]\n+        self.assertEqual(user['object_name'], 'User')\n+        from django.contrib.auth.models import User  # Importing Django's User model\n+        self.assertEqual(user['model'], User)\n         ctx = self.ctx\n         apps = ctx['available_apps']\n         # we have registered two models from two different apps\n",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..e34fce9 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,7 +1,10 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n from django.contrib.auth.models import User\n+from .with_custom_email_field import CustomEmailField\n+from .models import CustomEmailField, IntegerUsernameUser\n from django.contrib.auth.tokens import PasswordResetTokenGenerator\n from django.test import TestCase\n from django.test.utils import ignore_warnings\n",
  "django__django-13590": "",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..03b571f 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -19,18 +19,159 @@ from django.conf import settings\n from django.core.management import (\n     BaseCommand, CommandError, call_command, color,\n )\n+from django.core.management import execute_from_command_line\n+\n+class ManagementUtilityTests(SimpleTestCase):\n+    def test_prog_name_from_argv_with_script_name(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly uses argv[0] when it is a script name.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['my_script.py'] + args):\n+                execute_from_command_line(['my_custom_admin'] + args)\n+        self.assertIn('usage: my_custom_admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_prog_name_from_empty_argv(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly handles empty argv[0].\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [''] + args):\n+                execute_from_command_line(['another_admin'] + args)\n+        self.assertIn('usage: another_admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+        \n+    def test_prog_name_unrelated_sys_argv(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly handles an unrelated sys.argv[0].\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['unrelated_script'] + args):\n+                execute_from_command_line(['django-manager'] + args)\n+        self.assertIn('usage: django-manager shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n from django.core.management.commands.loaddata import Command as LoaddataCommand\n from django.core.management.commands.runserver import (\n     Command as RunserverCommand,\n )\n+from django.core.management import execute_from_command_line\n+\n+class ManagementUtilityTests(SimpleTestCase):\n+    def test_prog_name_from_argv_with_script_name(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly uses argv[0] when it is a script name.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['my_script.py'] + args):\n+                execute_from_command_line(['my_custom_admin'] + args)\n+        self.assertIn('usage: my_custom_admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_prog_name_from_empty_argv(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly handles empty argv[0].\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [''] + args):\n+                execute_from_command_line(['another_admin'] + args)\n+        self.assertIn('usage: another_admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+        \n+    def test_prog_name_unrelated_sys_argv(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly handles an unrelated sys.argv[0].\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['unrelated_script'] + args):\n+                execute_from_command_line(['django-manager'] + args)\n+        self.assertIn('usage: django-manager shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n from django.core.management.commands.testserver import (\n     Command as TestserverCommand,\n )\n+from django.core.management import execute_from_command_line\n+\n+class ManagementUtilityTests(SimpleTestCase):\n+    def test_prog_name_from_argv_with_script_name(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly uses argv[0] when it is a script name.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['my_script.py'] + args):\n+                execute_from_command_line(['my_custom_admin'] + args)\n+        self.assertIn('usage: my_custom_admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_prog_name_from_empty_argv(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly handles empty argv[0].\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [''] + args):\n+                execute_from_command_line(['another_admin'] + args)\n+        self.assertIn('usage: another_admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+        \n+    def test_prog_name_unrelated_sys_argv(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly handles an unrelated sys.argv[0].\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['unrelated_script'] + args):\n+                execute_from_command_line(['django-manager'] + args)\n+        self.assertIn('usage: django-manager shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n from django.db import ConnectionHandler, connection\n from django.db.migrations.recorder import MigrationRecorder\n+from unittest import mock\n from django.test import (\n     LiveServerTestCase, SimpleTestCase, TestCase, override_settings,\n )\n+from django.core.management import execute_from_command_line\n+\n+class ManagementUtilityTests(SimpleTestCase):\n+    def test_prog_name_from_argv_with_script_name(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly uses argv[0] when it is a script name.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['my_script.py'] + args):\n+                execute_from_command_line(['my_custom_admin'] + args)\n+        self.assertIn('usage: my_custom_admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_prog_name_from_empty_argv(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly handles empty argv[0].\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [''] + args):\n+                execute_from_command_line(['another_admin'] + args)\n+        self.assertIn('usage: another_admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+        \n+    def test_prog_name_unrelated_sys_argv(self):\n+        \"\"\"\n+        Test if execute_from_command_line correctly handles an unrelated sys.argv[0].\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['unrelated_script'] + args):\n+                execute_from_command_line(['django-manager'] + args)\n+        self.assertIn('usage: django-manager shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n \n custom_templates_dir = os.path.join(os.path.dirname(__file__), 'custom_templates')\n \n",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..beab941 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,3 +1,4 @@\n+\n import sys\n import unittest\n from unittest import mock\n@@ -44,9 +45,45 @@ class ShellCommandTestCase(SimpleTestCase):\n         with self.assertRaisesMessage(CommandError, \"Couldn't import bpython interface.\"):\n             call_command('shell', interface='bpython')\n \n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n+\n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n     # [1] Patch select to prevent tests failing when when the test suite is run\n     # in parallel mode. The tests are run in a subprocess and the subprocess's\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "",
  "django__django-13757": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex f53ff8c..39a81cd 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -594,8 +594,24 @@ class TestQuerying(TestCase):\n             NullableJSONModel.objects.filter(value__j__isnull=False),\n             [self.objs[4]],\n         )\n+        # Test that key__isnull=True works correctly for JSON fields.\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],\n+        )\n+    def test_key_transform_isnull_false(self):\n+        # key__isnull=False should return objects that have the key, even if its value is None.\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=False),\n+            [self.objs[4]],\n+        )\n \n-    def test_isnull_key_or_none(self):\n+    def test_key_transform_isnull_true_specific(self):\n+        # Ensure key__isnull=True does not match JSON null values for SQLite and Oracle.\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],\n+        )\n         obj = NullableJSONModel.objects.create(value={'a': None})\n         self.assertSequenceEqual(\n             NullableJSONModel.objects.filter(Q(value__a__isnull=True) | Q(value__a=None)),\n",
  "django__django-13768": "",
  "django__django-13925": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 6424d89..c04f24e 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -402,6 +402,15 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n \n         self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n \n+    def test_explicit_inherited_pk(self):\n+        class Parent(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class Child(Parent):\n+            pass\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n     def test_explicit_pk(self):\n         class Model(models.Model):\n             id = models.BigAutoField(primary_key=True)\n@@ -409,9 +418,18 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n         self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n \n     @isolate_apps('check_framework.apps.CheckPKConfig', kwarg_name='apps')\n+    def test_explicit_inherited_parent_link(self):\n+        class Parent(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class Child(Parent):\n+            parent_ptr = models.OneToOneField(Parent, models.CASCADE, parent_link=True)\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n     def test_app_default_auto_field(self, apps):\n         class ModelWithPkViaAppConfig(models.Model):\n             class Meta:\n                 app_label = 'check_framework.apps.CheckPKConfig'\n \n-        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..c69098d 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -298,6 +298,19 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['INVALID CHOICE'], f.clean, '4')\n \n+        # Test for ModelChoiceField with invalid choice displaying the invalid value\n+        f_invalid = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            }\n+        )\n+        self.assertFormErrors(\n+            ['\"4\" is not one of the available choices.'],\n+            f_invalid.clean,\n+            '4'\n+        )\n+\n         # ModelMultipleChoiceField\n         e = {\n             'required': 'REQUIRED',\n@@ -307,4 +320,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "",
  "django__django-14016": "",
  "django__django-14017": "",
  "django__django-14155": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 0f968fa..355ad85 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1146,6 +1146,9 @@ class ResolverMatchTests(SimpleTestCase):\n         )\n \n \n+import functools\n+from . import views  # Assuming views is a module in the same package\n+\n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n class ErroneousViewTests(SimpleTestCase):\n \n",
  "django__django-14238": "",
  "django__django-14382": "",
  "django__django-14411": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 331338c..bee645f 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1020,7 +1020,16 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n             \"\"\"\n         )\n \n-    def test_readonly_field_has_changed(self):\n+    def test_readonly_password_hash_widget_label(self):\n+        \"\"\"\n+        Ensure ReadOnlyPasswordHashWidget label does not contain a 'for' attribute.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            hash_field = ReadOnlyPasswordHashField()\n+\n+        bound_field = TestForm()['hash_field']\n+        self.assertEqual(bound_field.field.widget.id_for_label('id'), None)\n+        self.assertEqual(bound_field.label_tag(), '<label>Hash field:</label>')\n         field = ReadOnlyPasswordHashField()\n         self.assertIs(field.disabled, True)\n         self.assertFalse(field.has_changed('aaa', 'bbb'))\n",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..023aa32 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -658,10 +658,44 @@ class WriterTests(SimpleTestCase):\n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n \n-    def test_simple_migration(self):\n+    def test_serialization_includes_models_import(self):\n         \"\"\"\n-        Tests serializing a simple migration.\n+        Test that generated migrations include the necessary import for `models`.\n         \"\"\"\n+        class MyMixin:\n+            pass\n+\n+        class MyModel(models.Model):\n+            name = models.TextField(primary_key=True)\n+\n+            class Meta:\n+                abstract = False\n+        \n+        fields = {\n+            'name': app.models.MyField(primary_key=True, serialize=False),\n+        }\n+\n+        options = {\n+            'abstract': False,\n+        }\n+\n+        # Create a CreateModel operation to simulate migration creation\n+        operation = migrations.CreateModel(\n+            name='MyModel',\n+            fields=fields,\n+            options=options,\n+            bases=(MyMixin, models.Model),\n+        )\n+\n+        # Serialize the operation to check the output\n+        writer = MigrationWriter(operation)\n+        serialized = writer.serialize()\n+\n+        # Assert that 'from django.db import models' is present in the serialization\n+        self.assertIn('from django.db import models', serialized)\n+        \n+        # Assert that used models are referred correctly\n+        self.assertIn('(MyMixin, models.Model)', serialized)\n         fields = {\n             'charfield': models.DateTimeField(default=datetime.datetime.now),\n             'datetimefield': models.DateTimeField(default=datetime.datetime.now),\n",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..7a28cf4 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -336,7 +336,10 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at most 1 form.'])\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>Please submit at most 1 form.</li></ul>'\n+        )\n \n     def test_formset_validate_min_flag(self):\n         \"\"\"\n@@ -358,7 +361,10 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, min_num=3, validate_min=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at least 3 forms.'])\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>Please submit at least 3 forms.</li></ul>'\n+        )\n \n     def test_formset_validate_min_unchanged_forms(self):\n         \"\"\"\n@@ -982,7 +988,10 @@ class FormsFormsetTestCase(SimpleTestCase):\n         }\n         formset = FavoriteDrinksFormSet(data, prefix='drinks')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>You may only specify a drink once.</li></ul>'\n+        )\n \n     def test_formset_iteration(self):\n         \"\"\"Formset instances are iterable.\"\"\"\n",
  "django__django-14672": "diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 6fb82ec..cfc08d0 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -821,7 +821,40 @@ class ShadowingFieldsTests(SimpleTestCase):\n             )\n         ])\n \n-    def test_multiinheritance_clash(self):\n+    def test_m2m_through_fields_hashable_with_proxy(self):\n+        class Parent(models.Model):\n+            name = models.CharField(max_length=256)\n+\n+        class ProxyParent(Parent):\n+            class Meta:\n+                proxy = True\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+            many_to_many_field = models.ManyToManyField(\n+                to=Parent,\n+                through=\"ManyToManyModel\",\n+                through_fields=['child', 'parent'],\n+                related_name=\"something\"\n+            )\n+\n+        class ManyToManyModel(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n+            child = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n+        \n+        through_fields = ProxyParent._meta.get_field('child').remote_field.through_fields\n+        self.assertIsInstance(through_fields, list)\n+        self.assertEqual(through_fields, ['child', 'parent'])\n+\n+        # Validate that hashing does not throw an error\n+        try:\n+            obj = ProxyParent._meta.get_field('child').remote_field\n+            hash(obj)\n+            hash_success = True\n+        except TypeError:\n+            hash_success = False\n+\n+        self.assertTrue(hash_success)\n         class Mother(models.Model):\n             clash = models.IntegerField()\n \n",
  "django__django-14752": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex 7ef6d86..9de9f0c 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -294,7 +294,51 @@ class AutocompleteJsonViewTests(AdminViewBasicTestCase):\n         })\n \n \n-@override_settings(ROOT_URLCONF='admin_views.urls')\n+import json\n+import datetime\n+from django.urls import path, reverse\n+from django.test import TestCase, RequestFactory\n+from django.contrib.auth.models import User\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+from admin_views.models import Question\n+from django.http import JsonResponse\n+...\n+\n+class AutocompleteJsonSerializeResultView(AutocompleteJsonView):\n+    def serialize_result(self, obj, to_field_name):\n+        return {\n+            **super().serialize_result(obj, to_field_name),\n+            'posted': str(obj.posted),\n+        }\n+\n+class AutocompleteJsonViewTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superuser = User.objects.create_superuser(\n+            username='super', password='secret', email='super@example.com',\n+        )\n+        cls.factory = RequestFactory()\n+        cls.url = reverse('admin:autocomplete')\n+        cls.opts = {'app_label': 'admin_views', 'model_name': 'question', 'field_name': 'question'}\n+        cls.as_view_args = {'admin_site': AdminSite()}\n+\n+    def test_serialize_result(self):\n+        Question.objects.create(question='Question 1', posted=datetime.date(2021, 8, 9))\n+        Question.objects.create(question='Question 2', posted=datetime.date(2021, 8, 7))\n+        \n+        request = self.factory.get(self.url, {'term': 'question', **self.opts})\n+        request.user = self.superuser\n+\n+        response = AutocompleteJsonSerializeResultView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [\n+                {'id': str(q.pk), 'text': q.question, 'posted': str(q.posted)}\n+                for q in Question.objects.order_by('-posted')\n+            ],\n+            'pagination': {'more': False},\n+        })\n class SeleniumTests(AdminSeleniumTestCase):\n     available_apps = ['admin_views'] + AdminSeleniumTestCase.available_apps\n \n",
  "django__django-14787": "diff --git a/tests/decorators/tests.py b/tests/decorators/tests.py\nindex 5ea3da6..ed7b8a6 100644\n--- a/tests/decorators/tests.py\n+++ b/tests/decorators/tests.py\n@@ -425,8 +425,40 @@ class MethodDecoratorTests(SimpleTestCase):\n                 def __module__(cls):\n                     return \"tests\"\n \n+    def test_wrapper_assignments_for_partial_with_method_decorator(self):\n+        \"\"\"Check if method_decorator handles functools.partial correctly.\"\"\"\n+\n+        from functools import partial\n+        from django.utils.decorators import method_decorator\n+        from functools import wraps\n+\n+        captured_name = None\n+        captured_module = None\n+\n+        def logger(func):\n+            @wraps(func)\n+            def inner(*args, **kwargs):\n+                nonlocal captured_name, captured_module\n+                captured_name = getattr(func, '__name__', None)\n+                captured_module = getattr(func, '__module__', None)\n+                try:\n+                    result = func(*args, **kwargs)\n+                except Exception as e:\n+                    result = str(e)\n+                # simulate logging\n+                print(f\"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}\")\n+                return result\n+            return inner\n \n-class XFrameOptionsDecoratorsTests(TestCase):\n+        class Test:\n+            @method_decorator(logger)\n+            def hello_world(self):\n+                return \"hello\"\n+\n+        # Now we test if the attributes were preserved\n+        Test().hello_world()\n+        self.assertEqual(captured_name, 'hello_world')\n+        self.assertEqual(captured_module, __name__)\n     \"\"\"\n     Tests for the X-Frame-Options decorators.\n     \"\"\"\n",
  "django__django-14855": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 507855b..e406ce3 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -5094,6 +5094,44 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase):\n         self.assertContains(response, '<div class=\"readonly\">No opinion</div>', html=True)\n \n     def test_readonly_foreignkey_links(self):\n+        \"\"\"\n+        Test ForeignKey readonly fields in the default admin site to ensure \n+        they generate the correct URL.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1',\n+            content='content',\n+            book=Book.objects.create(name='Book 1'),\n+        )\n+        language = Language.objects.create(iso='_40', name='Test')\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+            language=language,\n+            user=self.superuser,\n+        )\n+        response = self.client.get(reverse('admin:admin_views_readonlyrelatedfield_change', args=(obj.pk,)))\n+        self.assertContains(response, f'/admin/auth/user/{self.superuser.pk}/change/')\n+        self.assertContains(response, f'/admin/admin_views/language/{language.pk}/change/')\n+        \n+    def test_readonly_foreignkey_links_custom_admin_site(self):\n+        \"\"\"\n+        ForeignKey readonly fields render as links when viewed in a custom\n+        admin site.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter Custom 1',\n+            content='content custom',\n+            book=Book.objects.create(name='Book Custom 1'),\n+        )\n+        language = Language.objects.create(iso='en', name='English')\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+            language=language,\n+            user=self.superuser,\n+        )\n+        response = self.client.get(reverse('namespaced_admin:admin_views_readonlyrelatedfield_change', args=(obj.pk,)))\n+        self.assertContains(response, f'/custom-admin/auth/user/{self.superuser.pk}/change/')\n+        self.assertContains(response, f'/custom-admin/admin_views/language/{language.pk}/change/')\n         \"\"\"\n         ForeignKey readonly fields render as links if the target model is\n         registered in admin.\n",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..350b8cc 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,10 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n+import json\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n",
  "django__django-14999": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 3e4c6c7..0133b2a 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -792,6 +792,32 @@ class OperationTests(OperationTestBase):\n         self.assertEqual(Pony.objects.count(), 2)\n         self.assertEqual(Rider.objects.count(), 2)\n         self.assertEqual(Pony._meta.get_field('riders').remote_field.through.objects.count(), 2)\n+    def test_rename_model_with_db_table_noop_extended(self):\n+        app_label = 'test_rmwdbtn_extended'\n+        project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+            migrations.CreateModel('Rider', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+            ], options={'db_table': 'rider_extended'}),\n+            migrations.CreateModel('Pony', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+            ]),\n+        ])\n+        \n+        # Clone the state to simulate before and after the operation\n+        new_state = project_state.clone()\n+        operation = migrations.RenameModel('Rider', 'Runner')  # Rename should be a no-op\n+        \n+        # Ensure no state change occurs\n+        operation.state_forwards(app_label, new_state)\n+        self.assertEqual(project_state, new_state, \"State should not be changed by no-op rename\")\n+\n+        with connection.schema_editor() as editor:\n+            # No queries should be executed\n+            with self.assertNumQueries(0):\n+                operation.database_forwards(app_label, editor, project_state, new_state)\n+            with self.assertNumQueries(0):\n+                operation.database_backwards(app_label, editor, new_state, project_state)\n \n     def test_rename_m2m_target_model(self):\n         app_label = \"test_rename_m2m_target_model\"\n",
  "django__django-15061": "diff --git a/tests/forms_tests/field_tests/test_multivaluefield.py b/tests/forms_tests/field_tests/test_multivaluefield.py\nindex 53aee21..4349605 100644\n--- a/tests/forms_tests/field_tests/test_multivaluefield.py\n+++ b/tests/forms_tests/field_tests/test_multivaluefield.py\n@@ -153,8 +153,12 @@ class MultiValueFieldTest(SimpleTestCase):\n             <input type=\"text\" name=\"field1_2_1\" id=\"id_field1_2_1\" required></td></tr>\n             \"\"\",\n         )\n-\n-    def test_form_as_table_data(self):\n+    def test_multivaluefield_label_for(self):\n+        form = ComplexFieldForm()\n+        form_html = form.as_table()\n+        # We expect labels not to have indices in 'for' attributes for MultiWidget\n+        self.assertIn('<label for=\"id_field1_0\">Field1:</label>', form_html)\n+        self.assertNotIn('<label for=\"id_field1\">Field1:</label>', form_html)\n         form = ComplexFieldForm({\n             'field1_0': 'some text',\n             'field1_1': ['J', 'P'],\n",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..02b4831 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -90,6 +90,9 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             'http://inv-.alid-.com',\n             'http://inv-.-alid.com',\n             '[a',\n+            # URLField should raise ValidationError, not ValueError, for invalid URLs.\n+            '////]@N.AN',\n+            '#@A.bO',\n             'http://[a',\n             # Non-string.\n             23,\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..ed16bbe 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -197,6 +197,26 @@ class NonAggregateAnnotationTestCase(TestCase):\n         combined = int(test.pages + test.rating)\n         self.assertEqual(b.combined, combined)\n \n+    def test_full_expression_annotation(self):\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_full_expression_annotation_with_aggregation(self):\n+        qs = Book.objects.filter(isbn='159059725').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in qs], [1])\n+\n+    def test_aggregate_over_full_expression_annotation(self):\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_empty_expression_annotation(self):\n         books = Book.objects.annotate(\n             selected=ExpressionWrapper(Q(pk__in=[]), output_field=BooleanField())\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..9b89db6 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,4 @@\n+\n import json\n import random\n \n@@ -163,7 +164,31 @@ class CookieTests(BaseTests, SimpleTestCase):\n         decoded_messages = json.loads(value, cls=MessageDecoder)\n         self.assertEqual(messages, decoded_messages)\n \n-    def test_safedata(self):\n+    def test_extra_tags_preservation(self):\n+        \"\"\"\n+        A message's extra_tags attribute should be correctly preserved when\n+        encoded and then decoded.\n+        \"\"\"\n+        storage = self.get_storage()\n+\n+        # Test with empty string extra_tags\n+        original_message = Message(constants.DEBUG, \"Test message\", extra_tags=\"\")\n+        encoded_message = storage._encode(original_message)\n+        decoded_message = storage._decode(encoded_message)\n+        self.assertEqual(decoded_message.extra_tags, \"\")\n+\n+        # Test with None extra_tags\n+        original_message = Message(constants.DEBUG, \"Test message\", extra_tags=None)\n+        encoded_message = storage._encode(original_message)\n+        decoded_message = storage._decode(encoded_message)\n+        self.assertIsNone(decoded_message.extra_tags)\n+\n+        # Test with non-empty string extra_tags\n+        extra_tags = \"some tags\"\n+        original_message = Message(constants.DEBUG, \"Test message\", extra_tags=extra_tags)\n+        encoded_message = storage._encode(original_message)\n+        decoded_message = storage._decode(encoded_message)\n+        self.assertEqual(decoded_message.extra_tags, extra_tags)\n         \"\"\"\n         A message containing SafeData is keeping its safe status when\n         retrieved from the message storage.\n",
  "django__django-15388": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex 42ab5ba..92108d7 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -2,6 +2,8 @@ from pathlib import Path\n from unittest import mock\n \n from django.template import autoreload\n+from django.conf import settings\n+from django.utils.autoreload import restart_with_reloader\n from django.test import SimpleTestCase, override_settings\n from django.test.utils import require_jinja2\n \n@@ -39,6 +41,19 @@ class TemplateReloadTests(SimpleTestCase):\n         self.assertIsNone(autoreload.template_changed(None, Path(__file__)))\n         mock_reset.assert_not_called()\n \n+    @mock.patch('django.utils.autoreload.restart_with_reloader')\n+    @override_settings(\n+        TEMPLATES=[{\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+            'DIRS': [BASE_DIR],  # Simulating the condition from the issue\n+        }]\n+    )\n+    def test_dev_server_restarts_with_base_dir_in_template_dirs(self, mock_restart):\n+        mock_restart.return_value = None\n+        # Simulate a file save that should trigger a restart\n+        autoreload.file_changed.send(sender=self.__class__, file_path=Path(__file__))\n+        mock_restart.assert_called_once()\n+\n     def test_watch_for_template_changes(self):\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n@@ -88,6 +103,19 @@ class TemplateReloadTests(SimpleTestCase):\n @require_jinja2\n @override_settings(INSTALLED_APPS=['template_tests'])\n class Jinja2TemplateReloadTests(SimpleTestCase):\n+    @mock.patch('django.utils.autoreload.restart_with_reloader')\n+    @override_settings(\n+        TEMPLATES=[{\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+            'DIRS': [BASE_DIR],  # Simulating the condition from the issue\n+        }]\n+    )\n+    def test_dev_server_restarts_with_base_dir_in_template_dirs(self, mock_restart):\n+        mock_restart.return_value = None\n+        # Simulate a file save that should trigger a restart\n+        autoreload.file_changed.send(sender=self.__class__, file_path=Path(__file__))\n+        mock_restart.assert_called_once()\n+\n     def test_watch_for_template_changes(self):\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..55a2a46 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -184,7 +185,32 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n-    def test_was_modified_since_fp(self):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"\n+        An empty string for If-Modified-Since should not raise an exception\n+        and should be treated as 'not modified'.\n+        \"\"\"\n+        mtime = 1343416141.107817\n+        header = \"\"\n+        self.assertTrue(was_modified_since(header, mtime))\n+\n+    def test_was_modified_since_none_string(self):\n+        \"\"\"\n+        A None value for If-Modified-Since should not raise an exception\n+        and should be treated as 'not modified'.\n+        \"\"\"\n+        mtime = 1343416141.107817\n+        header = None\n+        self.assertTrue(was_modified_since(header, mtime))\n+\n+    def test_was_modified_since_unparseable_string(self):\n+        \"\"\"\n+        An unparseable string for If-Modified-Since should not raise an exception\n+        and should be treated as 'not modified'.\n+        \"\"\"\n+        mtime = 1343416141.107817\n+        header = \"not-a-date\"\n+        self.assertTrue(was_modified_since(header, mtime))\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n         \"\"\"\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..a964916 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,5 +1,7 @@\n+\n import os\n from io import StringIO\n+from argparse import ArgumentDefaultsHelpFormatter\n from unittest import mock\n \n from admin_scripts.tests import AdminScriptTestCase\n@@ -411,6 +413,33 @@ class CommandTests(SimpleTestCase):\n         parser = BaseCommand().create_parser(\"prog_name\", \"subcommand\", epilog=epilog)\n         self.assertEqual(parser.epilog, epilog)\n \n+    def test_create_parser_help_output(self):\n+        \"\"\"\n+        Test if the help output is correctly formatted with line breaks in help text.\n+        \"\"\"\n+        class TestCommand(BaseCommand):\n+            help = (\n+                \"Import a contract from tzkt.\\n\"\n+                \"Example usage:\\n\"\n+                \"./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\"\n+            )\n+\n+        epilog = None\n+        command = TestCommand()\n+        parser = command.create_parser(\"manage.py\", \"tzkt_import\", epilog=epilog, formatter_class=ArgumentDefaultsHelpFormatter)\n+\n+        with mock.patch('sys.stdout', new_callable=StringIO) as mock_stdout:\n+            parser.print_help(mock_stdout)\n+\n+        output = mock_stdout.getvalue()\n+        \n+        expected_help_part = (\n+            \"Import a contract from tzkt.\\n\"\n+            \"Example usage:\\n\"\n+            \"  ./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\"\n+        )\n+        self.assertIn(expected_help_part, output)\n+\n     def test_outputwrapper_flush(self):\n         out = StringIO()\n         with mock.patch.object(out, \"flush\") as mocked_flush:\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..27be092 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,8 +1,10 @@\n+\n import os\n from datetime import datetime\n \n from django.test import SimpleTestCase\n from django.utils.functional import lazystr\n+from django.core.serializers.json import DjangoJSONEncoder\n from django.utils.html import (\n     conditional_escape,\n     escape,\n@@ -217,7 +219,31 @@ class TestUtilsHtml(SimpleTestCase):\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n         )\n \n-    def test_smart_urlquote(self):\n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"hello\": \"world\"}'\n+        \n+        # Original test with custom encoder\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"hello\": \"world\"}</script>',\n+        )\n+\n+    def test_json_script_default_encoder(self):\n+        # Default behavior with no custom encoder, should use DjangoJSONEncoder\n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}),\n+            '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n+        )\n+\n+    def test_json_script_complex_data(self):\n+        # Ensure json_script works with more complex data using default encoder\n+        data = {\"key\": [\"value1\", 2, {\"nested\": \"dict\"}]}\n+        self.assertHTMLEqual(\n+            json_script(data),\n+            '<script type=\"application/json\">{\"key\": [\"value1\", 2, {\"nested\": \"dict\"}]}</script>',\n+        )\n         items = (\n             (\"http://\u00f6\u00e4\u00fc.com/\", \"http://xn--4ca9at.com/\"),\n             (\"http://\u00f6\u00e4\u00fc.com/\u00f6\u00e4\u00fc/\", \"http://xn--4ca9at.com/%C3%B6%C3%A4%C3%BC/\"),\n",
  "django__django-15790": "",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..2b68d6f 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -398,9 +398,15 @@ class ProxyModelTests(TestCase):\n     def test_eq(self):\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n-\n-@override_settings(ROOT_URLCONF=\"proxy_models.urls\")\n-class ProxyModelAdminTests(TestCase):\n+from django.test import TestCase, override_settings\n+from .models import ProxyCustomModel, AnotherModel\n+\n+class ProxyModelIssueTests(TestCase):\n+    def test_select_related_only_on_proxy(self):\n+        custom_model = ProxyCustomModel.objects.create(name=\"Test\")\n+        another_model = AnotherModel.objects.create(custom=custom_model)\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+        self.assertEqual(qs.get().custom.name, custom_model.name)\n     @classmethod\n     def setUpTestData(cls):\n         cls.superuser = AuthUser.objects.create(is_superuser=True, is_staff=True)\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..a536116 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -152,6 +152,10 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         )\n \n     def test_parameters(self):\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"SELECT 1\"]),\n+            ([\"psql\", \"-c\", \"SELECT 1\", \"dbname\"], None),\n+        )\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n             ([\"psql\", \"dbname\", \"--help\"], None),\n@@ -183,4 +187,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 44ea946..d0dd403 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1901,6 +1901,28 @@ class AllValidTests(SimpleTestCase):\n class DeprecationTests(SimpleTestCase):\n     def test_warning(self):\n         from django.forms.utils import DEFAULT_TEMPLATE_DEPRECATION_MSG\n+        from django.test import SimpleTestCase\n+        from django.forms import formset_factory\n+        from django.forms import BaseFormSet\n+        from django.forms.renderers import get_default_renderer\n+        from django.utils.lru_cache import lru_cache as isolate_lru_cache\n+        from django.core.exceptions import RemovedInDjango50Warning\n+\n+        class FormsetDeprecationTests(SimpleTestCase):\n+            def test_no_management_form_warning(self):\n+                \"\"\"\n+                Management forms should not raise a deprecation warning for the default template.\n+                \"\"\"\n+                with isolate_lru_cache(get_default_renderer), self.settings(\n+                    FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n+                ):\n+                    ChoiceFormSet = formset_factory(Choice, formset=BaseFormSet)\n+                    formset = ChoiceFormSet()\n+                    with self.assertRaises(AssertionError):  # No warning should be raised\n+                        with self.assertRaisesMessage(\n+                            RemovedInDjango50Warning, DEFAULT_TEMPLATE_DEPRECATION_MSG\n+                        ):\n+                            str(formset.management_form)\n \n         with isolate_lru_cache(get_default_renderer), self.settings(\n             FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n@@ -1909,4 +1931,4 @@ class DeprecationTests(SimpleTestCase):\n         ):\n             ChoiceFormSet = formset_factory(Choice)\n             formset = ChoiceFormSet()\n-            str(formset)\n+            str(formset)\n",
  "django__django-16041": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex a34f3d3..e5420cc 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -178,8 +178,17 @@ class FormsFormsetTestCase(SimpleTestCase):\n         formset = FormSet(form_kwargs={\"custom_kwarg\": 1})\n         self.assertTrue(hasattr(formset.empty_form, \"custom_kwarg\"))\n         self.assertEqual(formset.empty_form.custom_kwarg, 1)\n+    def test_empty_permitted_ignored_empty_form_with_empty_permitted_true(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        formset = FormSet(form_kwargs={\"empty_permitted\": True})\n+        # Since empty_form should ignore empty_permitted, it should be True by default\n+        self.assertTrue(formset.empty_form.empty_permitted)\n \n-    def test_formset_validation(self):\n+    def test_empty_permitted_ignored_empty_form_with_empty_permitted_false(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        formset = FormSet(form_kwargs={\"empty_permitted\": False})\n+        # Since empty_form should ignore empty_permitted, it should be True by default\n+        self.assertTrue(formset.empty_form.empty_permitted)\n         # FormSet instances can also have an error attribute if validation failed for\n         # any of the forms.\n         formset = self.make_choiceformset([(\"Calexico\", \"\")])\n",
  "django__django-16046": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 41aae41..f61cd02 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -1,3 +1,4 @@\n+\n from decimal import Decimal\n from sys import float_info\n \n@@ -160,7 +161,25 @@ class TestNumberFormat(SimpleTestCase):\n                     nformat(Decimal(value), \".\", decimal_pos), expected_value\n                 )\n \n-    def test_decimal_subclass(self):\n+    def test_empty(self):\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        self.assertEqual(nformat(None, \".\"), \"None\")\n+\n+    def test_non_string_none(self):\n+        # Test with None value, expected to not raise an IndexError and return \"None\"\n+        try:\n+            result = nformat(None, \".\")\n+            self.assertEqual(result, \"None\")\n+        except Exception as e:\n+            self.fail(f\"nformat(None, '.') raised an exception: {e}\")\n+\n+    def test_empty_with_int_zero(self):\n+        # Test with integer 0, expected to return \"0\"\n+        self.assertEqual(nformat(0, \".\"), \"0\")\n+\n+    def test_empty_with_float_zero(self):\n+        # Test with float 0.0, expected to return \"0.0\"\n+        self.assertEqual(nformat(0.0, \".\"), \"0.0\")\n         class EuroDecimal(Decimal):\n             \"\"\"\n             Wrapper for Decimal which prefixes each amount with the \u20ac symbol.\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..8d9ad0d 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -24,7 +25,8 @@ from django.forms.fields import CharField, Field, IntegerField\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.utils import translation\n from django.utils.text import capfirst\n-from django.utils.translation import gettext as _\n+from django.urls import reverse\n+import urllib.parse\n \n from .models.custom_user import (\n     CustomUser,\n@@ -884,6 +886,26 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # original hashed password contains $\n         self.assertIn(\"$\", form.cleaned_data[\"password\"])\n \n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search('<a href=\"(.*?)\">', password_help_text)\n+\n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.username,),\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n     def test_bug_19349_bound_password_field(self):\n         user = User.objects.get(username=\"testclient\")\n         form = UserChangeForm(data={}, instance=user)\n",
  "django__django-16255": "",
  "django__django-16379": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 014d28a..d73c84f 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1,3 +1,4 @@\n+\n # Unit tests for cache framework\n # Uses whatever cache backend is set in the test settings file.\n import copy\n@@ -8,6 +9,9 @@ import re\n import shutil\n import sys\n import tempfile\n+from unittest import mock\n+from django.core.cache import cache\n+import threading\n import threading\n import time\n import unittest\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..38fa47c 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -10,7 +11,8 @@ from django.urls import reverse\n \n from .admin import ArticleAdmin, site\n from .models import Article, Question\n-from .tests import AdminViewBasicTestCase\n+from django.contrib.auth import get_permission_codename\n+from .tests import AdminViewBasicTestCase, get_perm\n \n \n class AdminTemplateTagsTest(AdminViewBasicTestCase):\n@@ -33,6 +35,40 @@ class AdminTemplateTagsTest(AdminViewBasicTestCase):\n         self.assertIs(template_context[\"extra\"], True)\n         self.assertIs(template_context[\"show_save\"], True)\n \n+    def test_submit_row_save_as_new_add_permission_required(self):\n+        # Test with user having only change permission\n+        change_user = User.objects.create_user(\n+            username=\"change_user\", password=\"secret\", is_staff=True\n+        )\n+        change_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = change_user\n+        admin = UserAdmin(User, site)\n+        admin.save_as = True\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], False)\n+\n+        # Test with user having both add and change permissions\n+        add_user = User.objects.create_user(\n+            username=\"add_user\", password=\"secret\", is_staff=True\n+        )\n+        add_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"add\", User._meta)),\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = add_user\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], True)\n+\n     def test_override_show_save_and_add_another(self):\n         request = self.request_factory.get(\n             reverse(\"admin:auth_user_change\", args=[self.superuser.pk]),\n",
  "django__django-16595": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 3979e76..1089dc9 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -236,7 +236,31 @@ class OptimizerTests(SimpleTestCase):\n             ],\n         )\n \n-    def test_alter_alter_table_model(self):\n+    def _test_alter_alter_field(self, alter_foo, alter_bar):\n+        \"\"\"\n+        Two AlterField operations on the same field should collapse into the second.\n+        \"\"\"\n+        self.assertOptimizesTo(\n+            [\n+                alter_foo,\n+                alter_bar,\n+            ],\n+            [\n+                alter_bar,\n+            ],\n+        )\n+\n+    def test_alter_alter_field_help_text(self):\n+        self._test_alter_alter_field(\n+            operations.fields.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True)),\n+            operations.fields.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True, help_text=\"help\")),\n+        )\n+\n+    def test_alter_alter_field_with_default(self):\n+        self._test_alter_alter_field(\n+            operations.fields.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True, help_text=\"help\")),\n+            operations.fields.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True, help_text=\"help\", default=None)),\n+        )\n         self._test_alter_alter_model(\n             migrations.AlterModelTable(\"Foo\", \"a\"),\n             migrations.AlterModelTable(\"Foo\", \"b\"),\n",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..46c70f4 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,11 +1,23 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n \n from ..utils import setup\n \n+from django.template.defaultfilters import escape\n \n class JoinTests(SimpleTestCase):\n+    @setup({\"join_autoescape_off\": '{% autoescape off %}{{ a|join:var }}{% endautoescape %}'})\n+    def test_join_autoescape_off_with_unsafe_joiner(self):\n+        some_list = [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"]\n+        some_var = \"<br/>\"\n+        output = self.engine.render_to_string(\n+            \"join_autoescape_off\", {\"a\": some_list, \"var\": some_var}\n+        )\n+        # Since autoescaping is off, none of the parts should be escaped.\n+        expected_result = \"<p>Hello World!</p><br/>beta & me<br/><script>Hi!</script>\"\n+        self.assertEqual(output, expected_result)\n     @setup({\"join01\": '{{ a|join:\", \" }}'})\n     def test_join01(self):\n         output = self.engine.render_to_string(\"join01\", {\"a\": [\"alpha\", \"beta & me\"]})\n@@ -78,4 +90,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..16d895b 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -602,6 +602,68 @@ class BulkCreateTests(TestCase):\n     )\n     def test_update_conflicts_two_fields_unique_fields_first(self):\n         self._test_update_conflicts_two_fields([\"f1\"])\n+        \n+    @skipUnlessDBFeature(\"supports_update_conflicts\")\n+    def test_bulk_create_return_ids_update_conflicts(self):\n+        # Test for TwoFields Model\n+        new_objects = [\n+            TwoFields(f1=3, f2=3, name=\"e\"),\n+            TwoFields(f1=4, f2=4, name=\"f\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            new_objects,\n+            update_conflicts=True,\n+            update_fields=[\"name\"],\n+            unique_fields=[\"f1\"],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        # Test for Country Model\n+        new_countries = [\n+            Country(name=\"Norway\", iso_two_letter=\"NO\"),\n+            Country(name=\"Sweden\", iso_two_letter=\"SE\"),\n+        ]\n+        results = Country.objects.bulk_create(\n+            new_countries,\n+            update_conflicts=True,\n+            update_fields=[\"description\"],\n+            unique_fields=[\"iso_two_letter\"],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        # Test for UpsertConflict Model\n+        new_conflicts = [\n+            UpsertConflict(number=5, rank=5, name=\"Charlie\"),\n+            UpsertConflict(number=6, rank=6, name=\"Dave\"),\n+        ]\n+        results = UpsertConflict.objects.bulk_create(\n+            new_conflicts,\n+            update_conflicts=True,\n+            update_fields=[\"name\", \"rank\"],\n+            unique_fields=[\"number\"],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        # Test for FieldsWithDbColumns Model\n+        new_fields = [\n+            FieldsWithDbColumns(rank=3, name=\"x\"),\n+            FieldsWithDbColumns(rank=4, name=\"y\"),\n+        ]\n+        results = FieldsWithDbColumns.objects.bulk_create(\n+            new_fields,\n+            update_conflicts=True,\n+            update_fields=[\"name\"],\n+            unique_fields=[\"rank\"],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -816,4 +878,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..18ea76e 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -197,6 +197,28 @@ class OperationWriterTests(SimpleTestCase):\n             \"),\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -255,12 +277,56 @@ class WriterTests(SimpleTestCase):\n             decimal.Decimal(\"1.3\"), (\"Decimal('1.3')\", {\"from decimal import Decimal\"})\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n         self.assertSerializedEqual(Money(\"1.3\"))\n         self.assertSerializedResultEqual(\n             Money(\"1.3\"),\n             (\"migrations.test_writer.Money('1.3')\", {\"import migrations.test_writer\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -296,6 +362,28 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r\"^foo$\")\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -306,6 +394,28 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\n@@ -313,6 +423,28 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\n@@ -320,10 +452,54 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -331,11 +507,55 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(\n             default=TextEnum.B, choices=[(m.value, m) for m in TextEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -344,10 +564,54 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -356,9 +620,53 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         field = models.CharField(\n             default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -367,9 +675,53 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         field = models.IntegerField(\n             default=IntEnum.A, choices=[(m.value, m) for m in IntEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -379,6 +731,28 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n@@ -387,6 +761,28 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n@@ -394,9 +790,53 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -405,6 +845,28 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A | IntFlagEnum.B,\n             (\n@@ -414,6 +876,28 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = \"A\", \"A value\"\n@@ -433,6 +917,28 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             (\"datetime.date(1969, 7, 20)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         field = models.CharField(default=TextChoices.B, choices=TextChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -440,12 +946,56 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -456,6 +1006,28 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_nested_class(self):\n         for nested_cls in [self.NestedEnum, self.NestedChoices]:\n             cls_name = nested_cls.__name__\n@@ -478,14 +1050,80 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {\"import uuid\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {\"import uuid\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n         field = models.UUIDField(\n             choices=((uuid_a, \"UUID A\"), (uuid_b, \"UUID B\")), default=uuid_a\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -495,6 +1133,28 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_pathlib(self):\n         # Pure path objects work in all platforms.\n         self.assertSerializedEqual(pathlib.PurePosixPath())\n@@ -523,6 +1183,28 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"models.FilePathField(path=pathlib.PurePosixPath('/home/user'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertIn(\"import pathlib\", imports)\n \n     def test_serialize_path_like(self):\n@@ -554,13 +1236,79 @@ class WriterTests(SimpleTestCase):\n         self.assertSerializedEqual(\n             datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone())\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedEqual(\n             datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180))\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc),\n             (\n@@ -568,6 +1316,28 @@ class WriterTests(SimpleTestCase):\n                 {\"import datetime\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             datetime.datetime(\n                 2012, 1, 1, 2, 1, tzinfo=zoneinfo.ZoneInfo(\"Europe/Paris\")\n@@ -578,12 +1348,56 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n@@ -593,20 +1407,108 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(\n             SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\")\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedResultEqual(\n             SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)), (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -624,6 +1526,28 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.RegexValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.serialize_round_trip(validator)\n \n         # Test with a compiled regex.\n@@ -633,6 +1557,28 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.serialize_round_trip(validator)\n \n         # Test a string regex with flag\n@@ -643,6 +1589,28 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[0-9]+$', \"\n             \"flags=re.RegexFlag['DOTALL'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n@@ -653,6 +1621,28 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', \"\n             \"'invalid')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.serialize_round_trip(validator)\n \n         # Test with a subclass.\n@@ -661,6 +1651,28 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.EmailValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.serialize_round_trip(validator)\n \n         validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(\n@@ -671,9 +1683,53 @@ class WriterTests(SimpleTestCase):\n             string, \"migrations.test_writer.EmailValidator(message='hello')\"\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n         validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(\n             message=\"hello\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n             MigrationWriter.serialize(validator)\n \n@@ -700,6 +1756,28 @@ class WriterTests(SimpleTestCase):\n             models.OrderBy(models.F(\"name\").desc()),\n             name=\"complex_func_index\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         string, imports = MigrationWriter.serialize(index)\n         self.assertEqual(\n             string,\n@@ -711,6 +1789,28 @@ class WriterTests(SimpleTestCase):\n             \"models.OrderBy(models.OrderBy(models.F('name'), descending=True)), \"\n             \"name='complex_func_index')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertEqual(imports, {\"from django.db import models\"})\n \n     def test_serialize_empty_nonempty_tuple(self):\n@@ -762,6 +1862,28 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.models\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         self.assertSerializedEqual(FoodManager(\"a\", \"b\"))\n         self.assertSerializedEqual(FoodManager(\"x\", \"y\", c=3, d=4))\n \n@@ -772,6 +1894,28 @@ class WriterTests(SimpleTestCase):\n             frozenset(\"cba\"), (\"frozenset(['a', 'b', 'c'])\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_serialize_set(self):\n         self.assertSerializedEqual(set())\n         self.assertSerializedResultEqual(set(), (\"set()\", set()))\n@@ -809,6 +1953,28 @@ class WriterTests(SimpleTestCase):\n             (\"('models.Model', {'from django.db import models'})\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -848,6 +2014,28 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [(\"testapp\", \"some_other_one\")],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         # We don't test the output formatting - that's too fragile.\n@@ -887,6 +2075,28 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -896,6 +2106,28 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_sorted_dependencies(self):\n         migration = type(\n             \"Migration\",\n@@ -912,6 +2144,28 @@ class WriterTests(SimpleTestCase):\n                 ],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         output = MigrationWriter(migration, include_header=False).as_string()\n         self.assertIn(\n             \"    dependencies = [\\n\"\n@@ -923,6 +2177,28 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -949,6 +2225,28 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -956,6 +2254,28 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -1001,6 +2321,28 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\"from django.db import migrations\\n\", output)\n@@ -1017,6 +2359,28 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+        \n+        # Simulate migration serialization\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"appname.models.Profile.Capability.default\", string)\n+        self.assertNotIn(\"appname.models.Capability.default\", string)\n+\n     def test_register_serializer(self):\n         class ComplexSerializer(BaseSerializer):\n             def serialize(self):\n@@ -1032,4 +2396,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "matplotlib__matplotlib-22711": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex 39c625e..57acd2f 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1078,6 +1078,11 @@ def test_slider_horizontal_vertical():\n     assert_allclose(box.bounds, [.25, 0, .5, 10/24])\n \n \n+import numpy as np\n+from matplotlib import widgets\n+from matplotlib.testing.decorators import check_figures_equal\n+from numpy.testing import assert_allclose\n+\n def test_slider_reset():\n     fig, ax = plt.subplots()\n     slider = widgets.Slider(ax=ax, label='', valmin=0, valmax=1, valinit=.5)\n@@ -1120,6 +1125,28 @@ def test_range_slider(orientation):\n     assert_allclose(slider.val, [0.1, 0.34])\n \n \n+@pytest.mark.parametrize(\"orientation\", [\"horizontal\", \"vertical\"])\n+def test_range_slider_initial_val(orientation):\n+    if orientation == \"vertical\":\n+        value_index = lambda handle: handle.get_ydata()[0]\n+    else:\n+        value_index = lambda handle: handle.get_xdata()[0]\n+\n+    fig, ax = plt.subplots()\n+    init_val = [0.0, 0.0]\n+    slider = widgets.RangeSlider(\n+        ax=ax, label=\"Test Slider\", valmin=-5, valmax=5, orientation=orientation,\n+        valinit=init_val\n+    )\n+\n+    # Check initial handle positions\n+    slider_values = [value_index(handle) for handle in slider._handles]\n+    assert_allclose(slider_values, init_val)\n+\n+    # Update value and ensure the slider reacts correctly\n+    slider.set_val(init_val)\n+    assert_allclose(slider.val, init_val)\n+\n def check_polygon_selector(event_sequence, expected_result, selections_count,\n                            **kwargs):\n     \"\"\"\n",
  "matplotlib__matplotlib-23299": "diff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 144880c..58ccacc 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -507,8 +507,28 @@ def test_rcparams_reset_after_fail():\n                 pass\n         assert mpl.rcParams['text.usetex'] is False\n \n-\n-@pytest.mark.skipif(sys.platform != \"linux\", reason=\"Linux only\")\n+import matplotlib.pyplot as plt\n+from matplotlib import rc_context\n+\n+def test_get_backend_rc_context_does_not_clear_figures():\n+    # Set up a figure with rc_context\n+    with rc_context():\n+        fig1 = plt.figure()\n+\n+    # Capture initial state of Gcf.figs\n+    before_backend_call = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+    \n+    # Call get_backend, which previously would clear figs if the first fig was under rc_context\n+    plt.get_backend()\n+    \n+    # Capture state after get_backend call\n+    after_backend_call = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+\n+    # Assert that the figures managed by Gcf remain unchanged\n+    assert before_backend_call == after_backend_call, '\\n' + before_backend_call + '\\n' + after_backend_call\n+\n+    # Cleanup\n+    plt.close(fig1)\n def test_backend_fallback_headless(tmpdir):\n     env = {**os.environ,\n            \"DISPLAY\": \"\", \"WAYLAND_DISPLAY\": \"\",\n",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..b6348cf 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -21,7 +21,14 @@ mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n \n-def test_aspect_equal_error():\n+@check_figures_equal(extensions=[\"png\"])\n+def test_invisible_3d_axes(fig_test, fig_ref):\n+    # Test to ensure that an axis with 'projection=3d' can be invisible\n+    ax_test = fig_test.add_subplot(111, projection='3d')\n+    ax_test.set_visible(False)  # Make the 3D axis invisible\n+\n+    # The reference image will just be a blank canvas\n+    fig_ref.add_subplot(111)\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     with pytest.raises(NotImplementedError):\n",
  "matplotlib__matplotlib-23562": "",
  "matplotlib__matplotlib-23563": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex a51a857..d144a40 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -1785,9 +1785,58 @@ def test_text_3d(fig_test, fig_ref):\n     ax.add_artist(t3d)\n     assert t3d.get_position_3d() == (0.5, 0.5, 1)\n \n+import numpy as np\n+import matplotlib.pyplot as plt\n+from mpl_toolkits.mplot3d import Axes3D\n \n-@check_figures_equal(extensions=[\"png\"])\n-def test_pathpatch_3d(fig_test, fig_ref):\n+def test_line3d_attribute_error():\n+    # Initial valid inputs\n+    x_s_0 = np.array([0])\n+    x_e_0 = np.array([1])\n+    y_s_0 = np.array([0])\n+    y_e_0 = np.array([1])\n+    z_s_0 = np.array([0])\n+    z_e_0 = np.array([1])\n+\n+    fig = plt.figure()\n+    ax = fig.add_subplot(projection='3d')\n+    ax.plot([int(x_s_0[0]), int(x_e_0[0])],\n+            [int(y_s_0[0]), int(y_e_0[0])],\n+            [int(z_s_0[0]), int(z_e_0[0])], 'r-')\n+    plt.show()  # Initial plotting\n+\n+    # Change inputs to arrays such that dimensions vary\n+    x_s_0 = np.array([[0]])\n+    x_e_0 = np.array([[1]])\n+    y_s_0 = np.array([[0]])\n+    y_e_0 = np.array([[1]])\n+    z_s_0 = np.array([[0]])\n+    z_e_0 = np.array([[1]])\n+\n+    fig = plt.figure()\n+    ax = fig.add_subplot(projection='3d')\n+    try:\n+        ax.plot([x_s_0[0][0], x_e_0[0][0]],\n+                [y_s_0[0][0], y_e_0[0][0]],\n+                [z_s_0[0][0], z_e_0[0][0]], 'r-')\n+        plt.show()  # Plotting with new input form\n+    except Exception as e:\n+        assert False, f\"Test failed due to unexpected error: {e}\"\n+\n+    # Transition back to integer inputs\n+    x_s_0 = np.array([0])\n+    x_e_0 = np.array([1])\n+    y_s_0 = np.array([0])\n+    y_e_0 = np.array([1])\n+    z_s_0 = np.array([0])\n+    z_e_0 = np.array([1])\n+    \n+    fig = plt.figure()\n+    ax = fig.add_subplot(projection='3d')\n+    ax.plot([int(x_s_0[0]), int(x_e_0[0])],\n+            [int(y_s_0[0]), int(y_e_0[0])],\n+            [int(z_s_0[0]), int(z_e_0[0])], 'r-')\n+    plt.show()  # Final plotting, expected to succeed\n     ax = fig_ref.add_subplot(projection=\"3d\")\n     path = Path.unit_rectangle()\n     patch = PathPatch(path)\n",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..14bc884 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -774,7 +774,15 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n         assert mpl.colors.same_color(text.get_color(), color)\n \n \n-def test_get_set_draggable():\n+import matplotlib.pyplot as plt\n+import pytest\n+\n+@pytest.mark.parametrize('draggable', (True, False))\n+def test_legend_creation_with_draggable(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='shabnams')\n+    leg = ax.legend(draggable=draggable)\n+    assert leg.get_draggable() is draggable\n     legend = plt.legend()\n     assert not legend.get_draggable()\n     legend.set_draggable(True)\n",
  "matplotlib__matplotlib-23964": "",
  "matplotlib__matplotlib-23987": "diff --git a/lib/matplotlib/tests/test_constrainedlayout.py b/lib/matplotlib/tests/test_constrainedlayout.py\nindex 41fdfa1..74dd08c 100644\n--- a/lib/matplotlib/tests/test_constrainedlayout.py\n+++ b/lib/matplotlib/tests/test_constrainedlayout.py\n@@ -655,4 +655,32 @@ def test_compressed1():\n     np.testing.assert_allclose(pos.y1, 0.8537, atol=1e-3)\n     pos = axs[1, 2].get_position()\n     np.testing.assert_allclose(pos.x1, 0.8618, atol=1e-3)\n-    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n+    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n+\n+@pytest.mark.parametrize(\"constrained_layout\", [False])\n+def test_no_user_warning_with_constrained_layout_false(constrained_layout):\n+    import matplotlib.pyplot as plt\n+    import numpy as np\n+    import warnings\n+\n+    # Create data for plotting\n+    a = np.linspace(0, 2 * np.pi, 100)\n+    b = np.sin(a)\n+    c = np.cos(a)\n+\n+    # Set up plot with constrained_layout=False\n+    fig, ax = plt.subplots(1, 2, figsize=(8, 2), constrained_layout=constrained_layout)\n+    ax[0].plot(a, b)\n+    ax[1].plot(a, c)\n+\n+    # Capture warnings\n+    with warnings.catch_warnings(record=True) as w:\n+        warnings.simplefilter(\"always\")\n+        plt.subplots_adjust(wspace=0)\n+\n+        # Assert that no warnings of the specific type are triggered\n+        assert not any(\n+            issubclass(warning.category, UserWarning) and \n+            \"a layout engine that is incompatible with subplots_adjust\" in str(warning.message)\n+            for warning in w\n+        )\n",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 64ba766..8ce2467 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -5731,8 +5731,43 @@ def test_set_get_ticklabels():\n     ax[1].set_xticklabels(ax[0].get_xticklabels())\n     ax[1].set_yticklabels(ax[0].get_yticklabels())\n \n+import pytest\n+import matplotlib.pyplot as plt\n \n-@check_figures_equal(extensions=[\"png\"])\n+def test_set_ticks_kwargs_raise_error_without_labels():\n+    \"\"\"\n+    When labels=None and any kwarg is passed, axis.set_ticks() raises a\n+    ValueError.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [1, 2, 3]\n+    # This should raise a ValueError because 'alpha' is not valid when labels are None\n+    with pytest.raises(ValueError):\n+        ax.xaxis.set_ticks(ticks, alpha=0.5)\n+\n+def test_set_ticks_kwargs_with_labels():\n+    \"\"\"\n+    When labels are provided, valid kwargs should not raise an error.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [0, 1, 2]\n+    labels = ['a', 'b', 'c']\n+    # These are valid kwargs for text properties\n+    try:\n+        ax.xaxis.set_ticks(ticks, labels=labels, fontweight='bold')\n+    except ValueError:\n+        pytest.fail(\"Unexpected ValueError with valid kwargs and labels\")\n+\n+def test_set_ticks_invalid_kwargs():\n+    \"\"\"\n+    Test set_ticks with an invalid kwarg alongside labels to ensure it raises an error.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [0, 1]\n+    labels = [\"x\", \"y\"]\n+    # 'invalid_kwarg' is not a valid Text property\n+    with pytest.raises(TypeError):\n+        ax.xaxis.set_ticks(ticks, labels=labels, invalid_kwarg='value')\n def test_set_ticks_with_labels(fig_test, fig_ref):\n     \"\"\"\n     Test that these two are identical::\n",
  "matplotlib__matplotlib-24970": "",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..0ed3446 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -90,7 +91,27 @@ def _generate_complete_test_figure(fig_ref):\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n \n-@mpl.style.context(\"default\")\n+\n+def test_pickle_draggable_legend():\n+    import pickletools\n+\n+    fig, ax = plt.subplots()\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40, 43, 45, 47, 48]\n+\n+    ax.plot(time, speed, label=\"speed\")\n+    leg = ax.legend()\n+    leg.set_draggable(True)  # This line is crucial as per the issue\n+\n+    # Attempt to pickle the figure\n+    pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+\n+    # Check if 'FigureCanvasAgg' is not in the pickle stream\n+    assert \"FigureCanvasAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+\n+    # Load the figure to validate pickling was successful\n+    loaded_fig = pickle.loads(pkl)\n+    assert loaded_fig is not None  # Check that loading the object returns a valid object\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..b269a66 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -89,6 +89,35 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+@mpl.style.context(\"default\")\n+@check_figures_equal(extensions=[\"png\"])\n+def test_align_labels_pickle():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    fig.align_labels()\n+    \n+    # Attempt to pickle the figure\n+    try:\n+        pkl = BytesIO()\n+        pickle.dump(fig, pkl, pickle.HIGHEST_PROTOCOL)\n+        loaded = pickle.loads(pkl.getbuffer())\n+        loaded.canvas.draw()\n+    except TypeError as e:\n+        raise AssertionError(f\"Pickling failed with error: {e}\")\n+    \n+    # Clean up figure\n+    plt.close(loaded)\n \n @mpl.style.context(\"default\")\n @check_figures_equal(extensions=[\"png\"])\n",
  "matplotlib__matplotlib-25442": "diff --git a/lib/matplotlib/tests/test_offsetbox.py b/lib/matplotlib/tests/test_offsetbox.py\nindex 204af9c..29b5127 100644\n--- a/lib/matplotlib/tests/test_offsetbox.py\n+++ b/lib/matplotlib/tests/test_offsetbox.py\n@@ -441,7 +441,23 @@ def test_paddedbox():\n     ab = AnchoredOffsetbox('upper left', child=pb)\n     ax.add_artist(ab)\n \n-    ta = TextArea(\"bar\")\n+import numpy as np\n+import matplotlib.pyplot as plt\n+import mplcursors\n+\n+def test_mplcursor_attribute_error():\n+    x = np.arange(1, 11)\n+    y1 = x\n+    fig, ax = plt.subplots()\n+    ax.scatter(x, y1)\n+    mplcursors.cursor(ax)\n+\n+    # Simulate click events on the plot to confirm no AttributeError\n+    # Prior to the fix, this would raise an AttributeError after several clicks\n+    for i in range(5):\n+        ax.figure.canvas.mpl_connect('button_press_event', lambda event: ax.annotate(\"clicked\", (event.xdata, event.ydata)))\n+\n+    plt.close(fig)\n     pb = PaddedBox(ta, pad=10, patch_attrs={'facecolor': 'b'})\n     ab = AnchoredOffsetbox('upper right', child=pb)\n     ax.add_artist(ab)\n@@ -449,4 +465,4 @@ def test_paddedbox():\n     ta = TextArea(\"foobar\")\n     pb = PaddedBox(ta, pad=15, draw_frame=True)\n     ab = AnchoredOffsetbox('lower right', child=pb)\n-    ax.add_artist(ab)\n+    ax.add_artist(ab)\n",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\nindex 9aa3203..9c47397 100644\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -1,4 +1,5 @@\n \n+\n import numpy as np\n import pandas as pd\n \n@@ -8,9 +9,33 @@ from numpy.testing import assert_array_equal, assert_array_almost_equal\n from seaborn._core.groupby import GroupBy\n from seaborn._stats.regression import PolyFit\n \n+from pandas.testing import assert_frame_equal\n \n class TestPolyFit:\n \n+    def test_polyfit_with_missing_data(self, rng):\n+        \"\"\"Test PolyFit can handle missing data correctly.\"\"\"\n+        df = pd.DataFrame({\n+            \"x\": rng.standard_normal(20),\n+            \"y\": rng.standard_normal(20),\n+            \"group\": rng.choice([\"a\", \"b\"], 20)\n+        })\n+\n+        # Introduce NaN values in different locations\n+        df.loc[5, \"x\"] = np.nan\n+        df.loc[10:15, \"y\"] = np.nan\n+\n+        groupby = GroupBy([\"group\"])\n+\n+        # Result with NaNs present\n+        res_with_nan = PolyFit()(df, groupby, \"x\", {})\n+\n+        # Result with NaNs dropped\n+        res_dropna = PolyFit()(df.dropna(), groupby, \"x\", {})\n+\n+        # Make sure results are the same\n+        assert_frame_equal(res_with_nan, res_dropna)\n+\n     @pytest.fixture\n     def df(self, rng):\n \n",
  "mwaskom__seaborn-3190": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\nindex 72a27ec..f7edb19 100644\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -82,6 +82,18 @@ class TestContinuous:\n \n         s = Continuous(norm=(3, 7))._setup(x, IntervalProperty())\n         assert_array_equal(s(x), [-.5, 0, 1.5])\n+    \n+    def test_color_mapping_with_boolean_data(self):\n+        # This test checks whether using boolean values as color data works without error\n+        x = pd.Series([True, False, True, False])\n+        \n+        # Here we simply run the function to see if it executes without errors\n+        try:\n+            so.Plot([\"a\", \"b\", \"c\", \"d\"], [1, 2, 3, 4], color=x).add(so.Bar())\n+            color_applied = True\n+        except Exception as e:\n+            color_applied = False\n+        assert color_applied, \"Color mapping failed with boolean data\"\n \n     def test_interval_with_range_norm_and_transform(self, x):\n \n",
  "mwaskom__seaborn-3407": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\nindex b2e4a92..8448e5c 100644\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -1314,6 +1314,16 @@ class TestPairGrid:\n         for ax in g.diag_axes:\n             assert len(ax.collections) == n\n \n+    def test_pairplot_column_multiindex(self):\n+\n+        # Create a MultiIndex DataFrame suitable for testing\n+        cols = pd.MultiIndex.from_tuples([(\"A\", \"1\"), (\"A\", \"2\"), (\"B\", \"1\"), (\"B\", \"2\")])\n+        df = pd.DataFrame(self.rs.rand(100, 4), columns=cols)\n+\n+        # Call pairplot and check if it handles the MultiIndex correctly without errors\n+        g = ag.pairplot(df)\n+        assert g.diag_vars == list(cols)\n+\n     def test_pairplot_reg(self):\n \n         vars = [\"x\", \"y\", \"z\"]\n",
  "pallets__flask-4992": "diff --git a/tests/test_config.py b/tests/test_config.py\nindex 179b09c..92a14e3 100644\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -1,5 +1,7 @@\n+\n import json\n import os\n+import tomllib\n import textwrap\n \n import pytest\n@@ -17,8 +19,14 @@ def common_object_test(app):\n     assert app.config[\"TEST_KEY\"] == \"foo\"\n     assert \"TestConfig\" not in app.config\n \n-\n-def test_config_from_pyfile():\n+def test_config_from_file_binary_toml():\n+    tomllib = pytest.importorskip(\"tomllib\", reason=\"tomllib added in 3.11\")\n+    app = flask.Flask(__name__)\n+    current_dir = os.path.dirname(os.path.abspath(__file__))\n+    app.config.from_file(\n+        os.path.join(current_dir, \"static\", \"config.toml\"), tomllib.load, mode=\"b\"\n+    )\n+    common_object_test(app)\n     app = flask.Flask(__name__)\n     app.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\n     common_object_test(app)\n",
  "psf__requests-1963": "",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..337cd1a 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1655,7 +1655,30 @@ def test_urllib3_retries():\n     with pytest.raises(RetryError):\n         s.get(httpbin('status/500'))\n \n-def test_vendor_aliases():\n+def test_urllib3_exceptions_are_wrapped():\n+    import requests\n+    import requests.packages.urllib3.exceptions as urllib3_exceptions\n+    from requests.adapters import HTTPAdapter\n+\n+    # DecodeError\n+    s1 = requests.Session()\n+    s1.mount('http://', HTTPAdapter())\n+    \n+    try:\n+        # Simulating DecodeError (this is typically a decoding issue, so might need a similar indirect way to simulate)\n+        raise urllib3_exceptions.DecodeError(\"Error decoding response\")\n+    except Exception as e:\n+        assert isinstance(e, requests.exceptions.RequestException)\n+    \n+    # TimeoutError\n+    s2 = requests.Session()\n+    s2.mount('http://', HTTPAdapter())\n+    \n+    try:\n+        # Simulating a timeout occurring inside urllib3\n+        raise urllib3_exceptions.TimeoutError(\"Timeout occurred\")\n+    except Exception as e:\n+        assert isinstance(e, requests.exceptions.RequestException)\n     from requests.packages import urllib3\n     from requests.packages import chardet\n \n@@ -1663,4 +1686,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "",
  "psf__requests-863": "",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..6c4a2a9 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -388,7 +388,7 @@ repr_da = xr.DataArray(\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over %r \" % dim\n+    expected += \", grouped over %r\" % dim\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj[dim])))\n     if dim == \"x\":\n         expected += \"1, 2, 3, 4, 5.\"\n@@ -405,7 +405,7 @@ def test_groupby_repr(obj, dim):\n def test_groupby_repr_datetime(obj):\n     actual = repr(obj.groupby(\"t.month\"))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over 'month' \"\n+    expected += \", grouped over 'month'\"\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj.t.dt.month)))\n     expected += \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.\"\n     assert actual == expected\n",
  "pylint-dev__pylint-5859": "diff --git a/tests/checkers/unittest_misc.py b/tests/checkers/unittest_misc.py\nindex 460d485..0ce47c9 100644\n--- a/tests/checkers/unittest_misc.py\n+++ b/tests/checkers/unittest_misc.py\n@@ -106,6 +106,16 @@ class TestFixme(CheckerTestCase):\n         ):\n             self.checker.process_tokens(_tokenize_str(code))\n \n+    @set_config(notes=[\"???\"])\n+    def test_punctuation_only_codetag(self) -> None:\n+        code = \"\"\"a = 1\n+                # ???\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n+\n     def test_dont_trigger_on_todoist(self) -> None:\n         code = \"\"\"\n         # Todoist API: What is this task about?\n@@ -119,4 +129,4 @@ class TestFixme(CheckerTestCase):\n         # Todoist API: Fetch all Tasks\n         \"\"\"\n         with self.assertNoMessages():\n-            self.checker.process_tokens(_tokenize_str(code))\n+            self.checker.process_tokens(_tokenize_str(code))\n",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..efb8fca 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -56,10 +56,14 @@ reports = \"yes\"\n     check_configuration_file_reader(runner)\n \n \n+import pytest\n+\n def test_unknown_message_id(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly raise a message on an unknown id.\"\"\"\n     Run([str(EMPTY_MODULE), \"--disable=12345\"], exit=False)\n-    output = capsys.readouterr()\n+    assert \"usage: pylint\" in output.err\n+    assert \"Unrecognized option\" in output.err\n+    assert \"Traceback\" not in output.err\n     assert \"Command line:1:0: E0012: Bad option value for --disable.\" in output.out\n \n \n@@ -67,7 +71,9 @@ def test_unknown_option_name(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly raise a message on an unknown option.\"\"\"\n     with pytest.raises(_UnrecognizedOptionError):\n         Run([str(EMPTY_MODULE), \"--unknown-option=yes\"], exit=False)\n-    output = capsys.readouterr()\n+    assert \"usage: pylint\" in output.err\n+    assert \"Unrecognized option\" in output.err\n+    assert \"Traceback\" not in output.err\n     assert \"E0015: Unrecognized option found: unknown-option=yes\" in output.out\n \n \n@@ -75,7 +81,9 @@ def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly raise a message on an unknown short option.\"\"\"\n     with pytest.raises(_UnrecognizedOptionError):\n         Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n-    output = capsys.readouterr()\n+    assert \"usage: pylint\" in output.err\n+    assert \"Unrecognized option\" in output.err\n+    assert \"Traceback\" not in output.err\n     assert \"E0015: Unrecognized option found: Q\" in output.out\n \n \n@@ -83,7 +91,9 @@ def test_unknown_confidence(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly error an unknown confidence value.\"\"\"\n     with pytest.raises(SystemExit):\n         Run([str(EMPTY_MODULE), \"--confidence=UNKNOWN_CONFIG\"], exit=False)\n-    output = capsys.readouterr()\n+    assert \"usage: pylint\" in output.err\n+    assert \"Unrecognized option\" in output.err\n+    assert \"Traceback\" not in output.err\n     assert \"argument --confidence: UNKNOWN_CONFIG should be in\" in output.err\n \n \n",
  "pylint-dev__pylint-7080": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex fa7078d..6821b53 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1330,6 +1330,27 @@ class TestRunTC:\n                     code=0,\n                 )\n \n+    def test_ignore_paths_with_recursive_option(self):\n+        \"\"\"Tests that --ignore-paths is respected when --recursive=y is used.\"\"\"\n+        with _test_sys_path():\n+            # Modify sys.path to prevent pytest interference\n+            sys.path = [\n+                path\n+                for path in sys.path\n+                if not os.path.basename(path) == \"regrtest_data\"\n+            ]\n+            with _test_cwd():\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n+                # Check if src/gen paths are being ignored\n+                self._runtest(\n+                    [\n+                        \".\",\n+                        \"--recursive=y\",\n+                        \"--ignore-paths=^ignored_subdirectory/.*\",\n+                    ],\n+                    code=0,\n+                )\n+\n     def test_regression_recursive_current_dir(self):\n         with _test_sys_path():\n             # pytest is including directory HERE/regrtest_data to sys.path which causes\n",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..3c744c8 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -934,6 +934,30 @@ print(submodule1)\n             linter.check([\"submodule2.py\"])\n     assert not linter.stats.by_msg\n \n+def test_identically_named_module_structure(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test for identical module names in a directory structure.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        linter.check([\"a\"])\n+    # There should be no errors related to missing __init__.py\n+    assert \"parse-error\" not in linter.stats.by_msg\n+\n+def test_import_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test importing a module from a package with an identically named module.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\n+            \"a/a.py\",\n+            \"a/b.py\",\n+            \"r.py\"\n+        ])\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"from a import b\")\n+        linter.check([\"r\", \"a\"])\n+    # Ensure no import errors regarding module 'b'\n+    assert \"no-name-in-module\" not in linter.stats.by_msg\n+\n \n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n@@ -941,4 +965,28 @@ def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n+\n+def test_identically_named_module_structure(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test for identical module names in a directory structure.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        linter.check([\"a\"])\n+    # There should be no errors related to missing __init__.py\n+    assert \"parse-error\" not in linter.stats.by_msg\n+\n+def test_import_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test importing a module from a package with an identically named module.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\n+            \"a/a.py\",\n+            \"a/b.py\",\n+            \"r.py\"\n+        ])\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"from a import b\")\n+        linter.check([\"r\", \"a\"])\n+    # Ensure no import errors regarding module 'b'\n+    assert \"no-name-in-module\" not in linter.stats.by_msg\n",
  "pylint-dev__pylint-7993": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 6338072..fdbd401 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n@@ -9,6 +10,7 @@ from __future__ import annotations\n import sys\n import warnings\n from contextlib import redirect_stdout\n+from _pytest.recwarn import WarningsRecorder\n from io import StringIO\n from json import dumps\n from typing import TYPE_CHECKING\n@@ -113,7 +115,30 @@ def test_template_option_non_existing(linter) -> None:\n     assert out_lines[2] == \"my_mod:2::()\"\n \n \n-def test_deprecation_set_output(recwarn):\n+def test_custom_msg_template_with_curly_braces(linter: PyLinter) -> None:\n+    \"\"\"Test using custom braces in the message template.\"\"\"\n+    output = StringIO()\n+    linter.reporter.out = output\n+    linter.config.msg_template = '{{ \"Category\": \"{category}\" }}'\n+    \n+    linter.open()\n+    linter.set_current_module(\"my_mod\")\n+    linter.add_message(\"C0301\", line=1, args=(1, 2))\n+    linter.add_message(\"line-too-long\", line=2, end_lineno=2, end_col_offset=4, args=(3, 4))\n+\n+    out_lines = output.getvalue().split(\"\\n\")\n+    assert out_lines[1] == '{ \"Category\": \"convention\" }'\n+    assert out_lines[2] == '{ \"Category\": \"convention\" }'\n+\n+def test_invalid_msg_template_argument(linter: PyLinter, recwarn: WarningsRecorder) -> None:\n+    \"\"\"Test with an unrecognized message template argument.\"\"\"\n+    linter.config.msg_template = \"Invalid template: {invalid}\"\n+    linter.open()\n+    linter.set_current_module(\"my_mod\")\n+    linter.add_message(\"C0301\", line=1, args=(1, 2))\n+\n+    warning = recwarn.pop()\n+    assert \"Don't recognize the argument 'invalid'\" in str(warning.message)\n     \"\"\"TODO remove in 3.0.\"\"\"\n     reporter = BaseReporter()\n     # noinspection PyDeprecation\n",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "diff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\nindex 9989033..49fce51 100644\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -288,7 +288,16 @@ class TestImportPath:\n         fn.write_text(\"def foo(x): return 40 + x\", encoding=\"utf-8\")\n         return fn\n \n-    def test_importmode_importlib(self, simple_module: Path, tmp_path: Path) -> None:\n+    def test_re_import_module(self, tmp_path: Path) -> None:\n+        \"\"\"Ensure re-importing with importlib doesn't create duplicate module entries.\"\"\"\n+        (tmp_path / \"pmxbot\").mkdir()\n+        (tmp_path / \"pmxbot\" / \"logging.py\").touch()\n+        \n+        module1 = import_path(tmp_path / \"pmxbot\" / \"logging.py\", mode=\"importlib\", root=tmp_path)\n+        module2 = import_path(tmp_path / \"pmxbot\" / \"logging.py\", mode=\"importlib\", root=tmp_path)\n+\n+        assert module1 is module2\n+        assert sys.modules[\"pmxbot.logging\"] is module1\n         \"\"\"`importlib` mode does not change sys.path.\"\"\"\n         module = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n         assert module.foo(2) == 42  # type: ignore[attr-defined]\n",
  "pytest-dev__pytest-5227": "diff --git a/testing/logging/test_formatter.py b/testing/logging/test_formatter.py\nindex 54a08a2..fe5de51 100644\n--- a/testing/logging/test_formatter.py\n+++ b/testing/logging/test_formatter.py\n@@ -1,3 +1,4 @@\n+\n import logging\n \n import py.io\n@@ -18,6 +19,37 @@ def test_coloredlogformatter():\n         exc_info=False,\n     )\n \n+    # Test case for the improved log format\n+    logfmt_new = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n+\n+    record_new = logging.LogRecord(\n+        name=\"test_module\",\n+        level=logging.DEBUG,\n+        pathname=\"path/to/test_module.py\",\n+        lineno=20,\n+        msg=\"New format Test Message\",\n+        args=(),\n+        exc_info=False,\n+    )\n+\n+    expected_output_with_markup_new = (\n+        \"\\x1b[32mDEBUG   \\x1b[0m test_module:test_module.py:20 New format Test Message\"\n+    )\n+    expected_output_without_markup_new = (\n+        \"DEBUG    test_module:test_module.py:20 New format Test Message\"\n+    )\n+\n+    tw_new = py.io.TerminalWriter()\n+    tw_new.hasmarkup = True\n+    formatter_new = ColoredLevelFormatter(tw_new, logfmt_new)\n+    output_new = formatter_new.format(record_new)\n+    assert output_new == expected_output_with_markup_new\n+\n+    tw_new.hasmarkup = False\n+    formatter_new = ColoredLevelFormatter(tw_new, logfmt_new)\n+    output_new = formatter_new.format(record_new)\n+    assert output_new == expected_output_without_markup_new\n+\n     class ColorConfig(object):\n         class option(object):\n             pass\n@@ -30,6 +62,37 @@ def test_coloredlogformatter():\n         \"dummypath                   10 \\x1b[32mINFO    \\x1b[0m Test Message\"\n     )\n \n+    # Test case for the improved log format\n+    logfmt_new = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n+\n+    record_new = logging.LogRecord(\n+        name=\"test_module\",\n+        level=logging.DEBUG,\n+        pathname=\"path/to/test_module.py\",\n+        lineno=20,\n+        msg=\"New format Test Message\",\n+        args=(),\n+        exc_info=False,\n+    )\n+\n+    expected_output_with_markup_new = (\n+        \"\\x1b[32mDEBUG   \\x1b[0m test_module:test_module.py:20 New format Test Message\"\n+    )\n+    expected_output_without_markup_new = (\n+        \"DEBUG    test_module:test_module.py:20 New format Test Message\"\n+    )\n+\n+    tw_new = py.io.TerminalWriter()\n+    tw_new.hasmarkup = True\n+    formatter_new = ColoredLevelFormatter(tw_new, logfmt_new)\n+    output_new = formatter_new.format(record_new)\n+    assert output_new == expected_output_with_markup_new\n+\n+    tw_new.hasmarkup = False\n+    formatter_new = ColoredLevelFormatter(tw_new, logfmt_new)\n+    output_new = formatter_new.format(record_new)\n+    assert output_new == expected_output_without_markup_new\n+\n     tw.hasmarkup = False\n     formatter = ColoredLevelFormatter(tw, logfmt)\n     output = formatter.format(record)\n",
  "pytest-dev__pytest-5495": "diff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex b05f85c..169bf06 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -304,6 +304,59 @@ class TestAssert_reprcompare:\n     def test_different_types(self):\n         assert callequal([0, 1], \"foo\") is None\n \n+    def test_bytes_diff_equal_empty(self):\n+        \"\"\"Check bytes diff with both sides empty.\"\"\"\n+        diff = callequal(b\"\", b\"\")\n+        assert diff is None\n+\n+    def test_bytes_diff_actual_extra(self):\n+        \"\"\"Check assertion with actual (right) having extra bytes.\"\"\"\n+        diff = callequal(b\"\", b\"42\")\n+        assert diff == [\n+            \"b'' == b'42'\",\n+            \"Right contains more items, first extra item: 52\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'42'\",\n+            \"?   ++\",\n+        ]\n+\n+    def test_bytes_diff_expected_extra(self):\n+        \"\"\"Check assertion with expected (left) having extra bytes.\"\"\"\n+        diff = callequal(b\"42\", b\"\")\n+        assert diff == [\n+            \"b'42' == b''\",\n+            \"Left contains more items, first extra item: 52\",\n+            \"Full diff:\",\n+            \"- b'42'\",\n+            \"?   --\",\n+            \"+ b''\",\n+        ]\n+\n+    def test_bytes_diff_verbose(self):\n+        \"\"\"Check verbose diff handling for bytes.\"\"\"\n+        diff = callequal(b\"\", b\"42\", verbose=True)\n+        assert diff == [\n+            \"b'' == b'42'\",\n+            \"Right contains more items, first extra item: 52\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'42'\",\n+            \"?   ++\",\n+        ]\n+\n+    def test_bytes_single_char_diff(self):\n+        \"\"\"Check single character differences in byte strings.\"\"\"\n+        diff = callequal(b\"\", b\"1\")\n+        assert diff == [\n+            \"b'' == b'1'\",\n+            \"Right contains more items, first extra item: 49\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'1'\",\n+            \"?   +\",\n+        ]\n+\n     def test_summary(self):\n         summary = callequal([0, 1], [0, 2])[0]\n         assert len(summary) < 65\n",
  "pytest-dev__pytest-5692": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3392814..6e0efa7 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1,3 +1,4 @@\n+\n import os\n from xml.dom import minidom\n \n@@ -157,6 +158,32 @@ class TestPython:\n         val = tnode[\"time\"]\n         assert round(float(val), 2) >= 0.03\n \n+    def test_hostname_in_xml(self, testdir):\n+        import platform\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+            \"\"\"\n+        )\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        node.assert_attr(hostname=platform.node())\n+\n+    def test_timestamp_in_xml(self, testdir):\n+        import datetime\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+            \"\"\"\n+        )\n+        start_time = datetime.datetime.now()\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        timestamp = datetime.datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S.%f\")\n+        assert start_time <= timestamp < datetime.datetime.now()\n+\n     @pytest.mark.parametrize(\"duration_report\", [\"call\", \"total\"])\n     def test_junit_duration_report(self, testdir, monkeypatch, duration_report):\n \n",
  "pytest-dev__pytest-7168": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 38e0b6b..9c31f5e 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -143,6 +143,30 @@ def test_repr_on_newstyle():\n \n     assert saferepr(Function())\n \n+def test_broken_getattribute():\n+    \"\"\"saferepr() can create proper representations of classes with\n+    broken __getattribute__ (#7145)\n+    \"\"\"\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError\n+\n+        def __repr__(self):\n+            raise RuntimeError\n+\n+    assert saferepr(SomeClass()).startswith(\n+        \"<[RuntimeError() raised in repr()] SomeClass object at 0x\"\n+    )\n+\n+def test_exception_in_repr():\n+    \"\"\"Test to ensure saferepr() handles exceptions in __repr__ gracefully.\"\"\"\n+    class SomeOtherClass:\n+        def __repr__(self):\n+            raise ValueError(\"Some error in repr\")\n+\n+    result = saferepr(SomeOtherClass())\n+    assert result.startswith(\"<[ValueError('Some error in repr') raised in repr()] SomeOtherClass object at 0x\")\n+\n \n def test_unicode():\n     val = \"\u00a3\u20ac\"\n@@ -153,4 +177,4 @@ def test_unicode():\n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n-    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n",
  "pytest-dev__pytest-7220": "diff --git a/testing/test_pytester.py b/testing/test_pytester.py\nindex 5ab5242..49b640f 100644\n--- a/testing/test_pytester.py\n+++ b/testing/test_pytester.py\n@@ -89,6 +89,32 @@ def test_testdir_runs_with_plugin(testdir) -> None:\n     result.assert_outcomes(passed=1)\n \n \n+def test_failure_with_changed_cwd(testdir):\n+    \"\"\"\n+    Test failure lines should use absolute paths if cwd has changed since\n+    invocation, so the path is correct (#6428).\n+    \"\"\"\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import os\n+        import pytest\n+\n+        @pytest.fixture\n+        def private_dir():\n+            out_dir = 'ddd'\n+            os.mkdir(out_dir)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+\n+        def test_show_wrong_path(private_dir):\n+            assert False\n+        \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([str(p) + \":*: AssertionError\", \"*1 failed in *\"])\n+\n def test_testdir_with_doctest(testdir):\n     \"\"\"Check that testdir can be used within doctests.\n \n",
  "pytest-dev__pytest-7373": "diff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 309636c..882f3e1 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -41,6 +41,35 @@ class TestMark:\n         with pytest.raises(AttributeError):\n             mark._some_name\n \n+def test_reevaluate_dynamic_expr(self, testdir):\n+    \"\"\"#7360\"\"\"\n+    py_file1 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr1=\"\"\"\n+        import pytest\n+\n+        skip = True\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_skip():\n+            assert True\n+    \"\"\",\n+    )\n+    py_file2 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr2=\"\"\"\n+        import pytest\n+\n+        skip = False\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_not_skip():\n+            assert True\n+    \"\"\",\n+    )\n+\n+    file_name1 = os.path.basename(py_file1.strpath)\n+    file_name2 = os.path.basename(py_file2.strpath)\n+    reprec = testdir.inline_run(file_name1, file_name2)\n+    reprec.assertoutcome(passed=1, skipped=1) \n \n def test_marked_class_run_twice(testdir):\n     \"\"\"Test fails file is run twice that contains marked class.\n",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..27a371e 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -152,6 +152,33 @@ class TestEvaluation:\n         assert skipped\n         assert skipped.reason == \"condition: config._hackxyz\"\n \n+import pytest\n+\n+class TestSkipping:\n+    @pytest.mark.parametrize(\n+        \"test_input,expected\",\n+        [\n+            (\n+                [\"-rs\"],\n+                [\"SKIPPED [1] test_sample.py:2: unconditional skip\", \"*1 skipped*\"],\n+            ),\n+            (\n+                [\"-rs\", \"--runxfail\"],\n+                [\"SKIPPED [1] test_sample.py:2: unconditional skip\", \"*1 skipped*\"],\n+            ),\n+        ],\n+    )\n+    def test_skip_location_reporting(self, testdir, test_input, expected):\n+        testdir.makepyfile(\n+            test_sample=\"\"\"\n+            import pytest\n+            @pytest.mark.skip\n+            def test_skip_location() -> None:\n+                assert 0\n+        \"\"\"\n+        )\n+        result = testdir.runpytest(*test_input)\n+        result.stdout.fnmatch_lines(expected)\n \n class TestXFail:\n     @pytest.mark.parametrize(\"strict\", [True, False])\n",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..50d8293 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,3 +1,4 @@\n+\n import sys\n \n import pytest\n@@ -315,6 +316,21 @@ class TestXFail:\n             ]\n         )\n \n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir):\n+        # Test for addressing pytest issue regarding dynamic xfail markers\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                # Dynamically mark this test as expected to fail\n+                request.node.add_marker(pytest.mark.xfail(reason=\"expected failure\"))\n+                # Intentionally fail the test\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p, \"-rx\")\n+        result.assert_outcomes(xfailed=1)\n+\n     def test_xfail_not_run_no_setup_run(self, testdir):\n         p = testdir.makepyfile(\n             test_one=\"\"\"\n",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..9e5c770 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,3 +1,4 @@\n+\n import os\n import stat\n import sys\n@@ -20,6 +21,26 @@ from _pytest.pathlib import register_cleanup_lock_removal\n from _pytest.pathlib import rm_rf\n from _pytest.pytester import Pytester\n from _pytest.tmpdir import get_user\n+from _pytest.monkeypatch import MonkeyPatch\n+\n+def test_tmp_path_factory_handles_various_invalid_usernames(tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch) -> None:\n+    # Invalid characters in Windows\n+    invalid_usernames = [\n+        \"os/<:*?;>agnostic\",\n+        \"domain\\\\user\",\n+        \"user|name\",\n+        \"user\\\"name\",\n+        \"user<name\",\n+        \"user>name\",\n+    ]\n+\n+    for invalid_username in invalid_usernames:\n+        monkeypatch.setattr(\"getpass.getuser\", lambda: invalid_username)\n+        # _basetemp / _given_basetemp are cached / set in parallel runs, patch them\n+        monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+        monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+        p = tmp_path_factory.getbasetemp()\n+        assert \"pytest-of-unknown\" in str(p), f\"Failed for username: {invalid_username}\"\n from _pytest.tmpdir import TempdirFactory\n from _pytest.tmpdir import TempPathFactory\n \n",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..1c796ce 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -574,6 +574,36 @@ def test_class_weights_cv():\n     assert_array_equal(reg.predict([[-.2, 2]]), np.array([-1]))\n \n \n+def test_ridge_classifier_cv_store_cv_values():\n+    # Test RidgeClassifierCV's store_cv_values attribute.\n+    rng = np.random.RandomState(42)\n+\n+    x = np.array([[-1.0, -1.0], [-1.0, 0], [-.8, -1.0], [1.0, 1.0], [1.0, 0.0]])\n+    y = np.array([1, 1, 1, -1, -1])\n+    n_samples = x.shape[0]\n+    alphas = [1e-1, 1e0, 1e1]\n+    n_alphas = len(alphas)\n+    n_targets = 1\n+\n+    r = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+    r.fit(x, y)\n+    assert r.cv_values_.shape == (n_samples, n_targets, n_alphas)\n+\n+    y_2d = np.array([\n+        [1, 1, 1, -1, -1],\n+        [1, -1, 1, -1, 1],\n+        [-1, -1, 1, -1, -1]\n+    ]).transpose()  # shape (5, 3)\n+    n_targets_2d = y_2d.shape[1]\n+\n+    r.fit(x, y_2d)\n+    assert r.cv_values_.shape == (n_samples, n_targets_2d, n_alphas)\n+\n+    # Test invalid parameter combination raises an error\n+    with pytest.raises(ValueError, match=\"cv!=None and store_cv_values=True are incompatible\"):\n+        RidgeClassifierCV(alphas=alphas, store_cv_values=True, cv=5).fit(x, y)\n+\n+\n def test_ridgecv_store_cv_values():\n     # Test _RidgeCV's store_cv_values attribute.\n     rng = rng = np.random.RandomState(42)\n",
  "scikit-learn__scikit-learn-11281": "",
  "scikit-learn__scikit-learn-12471": "",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex f8e4d54..9d2bc8b 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -597,8 +597,19 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_array_equal(Y_pred1, Y_pred2)\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n+from sklearn.mixture import GaussianMixture\n+from sklearn.utils._testing import assert_array_equal\n+import numpy as np\n \n-def test_gaussian_mixture_fit():\n+def test_gaussian_mixture_fit_predict_n_init():\n+    # Test for GaussianMixture where n_init > 1\n+    # This tests specifically if `fit_predict` gives the same result as `fit().predict()` with n_init set.\n+    rng = np.random.RandomState(42)\n+    X = rng.randn(1000, 5)\n+    gm = GaussianMixture(n_components=5, n_init=5, random_state=42)\n+    y_pred_fit_predict = gm.fit_predict(X)\n+    y_pred_predict = gm.predict(X)\n+    assert_array_equal(y_pred_fit_predict, y_pred_predict)\n     # recover the ground truth\n     rng = np.random.RandomState(0)\n     rand_data = RandomData(rng)\n",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..4bc2b54 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,3 +1,4 @@\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n@@ -70,8 +71,17 @@ def test_kernel_pca_consistent_transform():\n     transformed2 = kpca.transform(X_copy)\n     assert_array_almost_equal(transformed1, transformed2)\n \n-\n-def test_kernel_pca_sparse():\n+def test_kernel_pca_sign_consistency():\n+    \"\"\"Test that KernelPCA outputs are consistent irrespective of sign flips.\"\"\"\n+    rng = np.random.RandomState(0)\n+    X = rng.rand(10, 10)\n+\n+    kpca = KernelPCA(n_components=7, kernel='rbf', random_state=rng)\n+    transformed_X1 = kpca.fit_transform(X)\n+    transformed_X2 = kpca.fit_transform(X)\n+    \n+    # Assert that the absolute values are close, ignoring potential sign flips\n+    assert_allclose(np.abs(transformed_X1), np.abs(transformed_X2))\n     rng = np.random.RandomState(0)\n     X_fit = sp.csr_matrix(rng.random_sample((5, 4)))\n     X_pred = sp.csr_matrix(rng.random_sample((2, 4)))\n",
  "scikit-learn__scikit-learn-13439": "",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..900d0c7 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -7,6 +8,9 @@ Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n # License: BSD 3 clause\n \n import pytest\n+from sklearn.ensemble import IsolationForest\n+from sklearn.utils import check_random_state\n+from sklearn.exceptions import NotFittedError\n \n import numpy as np\n \n@@ -297,6 +301,39 @@ def test_score_samples():\n \n @pytest.mark.filterwarnings('ignore:default contamination')\n @pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n+def test_isolation_forest_warm_start_param():\n+    \"\"\"Test warm_start parameter integration in IsolationForest init.\"\"\"\n+    rng = check_random_state(42)\n+    X = rng.randn(50, 2)\n+\n+    # Create IsolationForest with warm_start enabled\n+    clf = IsolationForest(n_estimators=10, max_samples=10, random_state=rng, warm_start=True)\n+    assert hasattr(clf, 'warm_start')\n+    assert clf.warm_start is True\n+\n+    # Check behavior changing n_estimators\n+    clf.fit(X)\n+    assert len(clf.estimators_) == 10\n+\n+    clf.set_params(n_estimators=15)\n+    clf.fit(X)\n+    assert len(clf.estimators_) == 15\n+\n+def test_isolation_forest_warm_start_false():\n+    \"\"\"Test behavior when warm_start is set to False.\"\"\"\n+    rng = check_random_state(42)\n+    X = rng.randn(50, 2)\n+\n+    clf = IsolationForest(n_estimators=10, max_samples=10, random_state=rng, warm_start=False)\n+    clf.fit(X)\n+    assert len(clf.estimators_) == 10\n+\n+    tree_1 = clf.estimators_[0]\n+    clf.set_params(n_estimators=20)\n+    clf.fit(X)\n+    assert len(clf.estimators_) == 20\n+    assert clf.estimators_[0] is not tree_1\n+@pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n def test_deprecation():\n     X = [[0.0], [1.0]]\n     clf = IsolationForest()\n",
  "scikit-learn__scikit-learn-13497": "",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..26b8593 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,5 +1,8 @@\n+\n import re\n from pprint import PrettyPrinter\n+from sklearn.linear_model import LogisticRegressionCV\n+import sklearn\n \n import numpy as np\n \n@@ -214,8 +217,13 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n \n     set_config(print_changed_only=False)\n \n-\n-def test_pipeline():\n+def test_logistic_regression_cv_array_param():\n+    # make sure array parameters don't throw error (see #13583)\n+    sklearn.set_config(print_changed_only=True)\n+    lr_cv = LogisticRegressionCV(Cs=np.array([0.1, 1]))\n+    repr_output = repr(lr_cv)\n+    assert \"Cs=array([0.1, 1.0])\" in repr_output\n+    sklearn.set_config(print_changed_only=False)\n     # Render a pipeline object\n     pipeline = make_pipeline(StandardScaler(), LogisticRegression(C=999))\n     expected = \"\"\"\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..03e0cc7 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n@@ -8,9 +9,10 @@ from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_equal\n from sklearn.utils.testing import assert_raise_message\n from sklearn.exceptions import NotFittedError\n-from sklearn.linear_model import LogisticRegression\n+from sklearn.linear_model import LogisticRegression, LinearRegression\n from sklearn.naive_bayes import GaussianNB\n-from sklearn.ensemble import RandomForestClassifier\n+from sklearn.ensemble import RandomForestRegressor\n+from sklearn.ensemble import RandomForestClassifier, VotingClassifier, VotingRegressor\n from sklearn.ensemble import VotingClassifier, VotingRegressor\n from sklearn.model_selection import GridSearchCV\n from sklearn import datasets\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "diff --git a/sklearn/neighbors/tests/test_nca.py b/sklearn/neighbors/tests/test_nca.py\nindex 3963eca..3229e95 100644\n--- a/sklearn/neighbors/tests/test_nca.py\n+++ b/sklearn/neighbors/tests/test_nca.py\n@@ -161,7 +161,26 @@ def test_params_validation():\n                          NCA(n_components=n_components).fit, X, y)\n \n \n-def test_transformation_dimensions():\n+def test_grid_search_with_np_types():\n+    import numpy as np\n+    from sklearn.pipeline import Pipeline\n+    from sklearn.model_selection import GridSearchCV\n+    from sklearn.neighbors import KNeighborsClassifier\n+\n+    X = np.random.random_sample((100, 10))\n+    y = np.random.randint(2, size=100)\n+\n+    nca = NeighborhoodComponentsAnalysis()\n+    knn = KNeighborsClassifier()\n+\n+    pipe = Pipeline([('nca', nca), ('knn', knn)])\n+    params = {\n+        'nca__tol': [0.1, 0.5, 1.0],  # Make sure 1.0 is tested as a float\n+        'nca__n_components': [np.int64(n) for n in np.arange(1, 10)]  # np.int64 instances\n+    }\n+\n+    gs = GridSearchCV(estimator=pipe, param_grid=params, error_score='raise')\n+    gs.fit(X, y)\n     X = np.arange(12).reshape(4, 3)\n     y = [1, 1, 2, 2]\n \n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..2f3e88b 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -680,6 +680,31 @@ def test_unicode_kernel():\n                                 random_seed=0)\n \n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for ZeroDivisionError in _sparse_fit.\n+    from scipy import sparse\n+    import numpy as np\n+    from sklearn import svm\n+\n+    # Training data that leads to empty support_vectors_ when using sparse input\n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+\n+    # Check if support_vectors_ and dual_coef_ are empty\n+    assert not model.support_vectors_.data.size, \"Support vectors data should be empty\"\n+    assert not model.dual_coef_.data.size, \"Dual coefficients data should be empty\"\n+\n+    # Check there is no division by zero error and model is fit with correct shapes\n+    assert model.dual_coef_.shape[0] == 1, \"Dual coef should have the correct number of rows\"\n+    assert model.dual_coef_.shape[1] == len(y_train), \"Dual coef should match the number of training samples\"\n+\n+\n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n     sparse_gram = sparse.csr_matrix([[1, 0], [0, 1]])\n",
  "scikit-learn__scikit-learn-14983": "",
  "scikit-learn__scikit-learn-15512": "",
  "scikit-learn__scikit-learn-15535": "diff --git a/sklearn/metrics/cluster/tests/test_common.py b/sklearn/metrics/cluster/tests/test_common.py\nindex 9991cff..108a78c 100644\n--- a/sklearn/metrics/cluster/tests/test_common.py\n+++ b/sklearn/metrics/cluster/tests/test_common.py\n@@ -166,6 +166,13 @@ def test_format_invariance(metric_name):\n         yield y + 1, 'strictly positive ints'\n \n     if metric_name in SUPERVISED_METRICS:\n+        # Test for regression in input validation with object dtype\n+        y_true_object = np.random.choice(['a', 'b'], size=20).astype(object)\n+        y_pred_object = np.random.choice(['a', 'b'], size=20).astype(object)\n+        try:\n+            metric(y_true_object, y_pred_object)\n+        except ValueError as e:\n+            assert False, f\"Unexpected ValueError for object dtype: {e}\"\n         metric = SUPERVISED_METRICS[metric_name]\n         score_1 = metric(y_true, y_pred)\n         y_true_gen = generate_formats(y_true)\n",
  "scikit-learn__scikit-learn-25500": "diff --git a/sklearn/tests/test_isotonic.py b/sklearn/tests/test_isotonic.py\nindex 5021282..a860aac 100644\n--- a/sklearn/tests/test_isotonic.py\n+++ b/sklearn/tests/test_isotonic.py\n@@ -1,4 +1,10 @@\n+\n import warnings\n+import pytest\n+from sklearn import set_config\n+from sklearn.calibration import CalibratedClassifierCV\n+from sklearn.linear_model import SGDClassifier\n+import pandas as pd\n import numpy as np\n import pickle\n import copy\n@@ -668,7 +674,21 @@ def test_isotonic_regression_sample_weight_not_overwritten():\n \n \n @pytest.mark.parametrize(\"shape\", [\"1d\", \"2d\"])\n-def test_get_feature_names_out(shape):\n+\n+def test_calibrated_classifier_cv_with_config():\n+    \"\"\"Test CalibratedClassifierCV with isotonic regression under set_config(transform_output='pandas').\"\"\"\n+    np.random.seed(0)\n+    X, y = np.arange(90).reshape(30, 3), np.arange(30) % 2\n+    set_config(transform_output=\"pandas\")\n+    \n+    model = CalibratedClassifierCV(SGDClassifier(), method='isotonic')\n+    try:\n+        model.fit(X, y)\n+        predictions = model.predict(X)\n+        assert predictions is not None\n+        print(\"Test passed: CalibratedClassifierCV works with transform_output='pandas'.\")\n+    except Exception as e:\n+        print(f\"Test failed: raised an exception {e}\")\n     \"\"\"Check `get_feature_names_out` for `IsotonicRegression`.\"\"\"\n     X = np.arange(10)\n     if shape == \"2d\":\n",
  "scikit-learn__scikit-learn-25570": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex 23e3b97..dc46226 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -2128,4 +2128,32 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n \n     ct.set_params(verbose_feature_names_out=False)\n     X_trans_df1 = ct.fit_transform(X_df)\n-    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n+    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n+\n+@pytest.mark.parametrize(\n+    \"empty_selection\",\n+    [[], np.array([False, False]), [False, False]],\n+    ids=[\"list\", \"bool\", \"bool_int\"],\n+)\n+def test_empty_selection_pandas_output(empty_selection):\n+    \"\"\"Check that pandas output works when there is an empty selection.\n+\n+    Non-regression test for gh-25487\n+    \"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+\n+    X = pd.DataFrame([[1.0, 2.2], [3.0, 1.0]], columns=[\"a\", \"b\"])\n+    ct = ColumnTransformer(\n+        [\n+            (\"categorical\", \"passthrough\", empty_selection),\n+            (\"numerical\", StandardScaler(), [\"a\", \"b\"]),\n+        ],\n+        verbose_feature_names_out=True,\n+    )\n+    ct.set_output(transform=\"pandas\")\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"numerical__a\", \"numerical__b\"])\n+\n+    ct.set_params(verbose_feature_names_out=False)\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"a\", \"b\"])\n",
  "sphinx-doc__sphinx-10325": "",
  "sphinx-doc__sphinx-7975": "",
  "sphinx-doc__sphinx-8435": "",
  "sphinx-doc__sphinx-8506": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 08bd595..7d45de1 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -91,6 +91,11 @@ def test_get_full_qualified_name():\n     assert domain.get_full_qualified_name(node) == 'ls.-l'\n \n \n+import restructuredtext\n+from sphinx.testing.util import assert_node\n+from sphinx.domains.std import StandardDomain\n+from docutils import nodes\n+\n def test_glossary(app):\n     text = (\".. glossary::\\n\"\n             \"\\n\"\n",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..3daa3ac 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -22,6 +22,9 @@ from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_op\n from sphinx.testing.util import SphinxTestApp, Struct  # NOQA\n from sphinx.util.docutils import LoggingReporter\n \n+import pytest\n+from .test_ext_autodoc import do_autodoc\n+\n try:\n     # Enable pyximport to test cython module\n     import pyximport\n@@ -29,8 +32,33 @@ try:\n except ImportError:\n     pyximport = None\n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_autodoc_empty_all_behavior(app):\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'example', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: example',\n+        '',\n+        'docsting of empty_all module.',\n+        '',\n+    ]\n \n-def do_autodoc(app, objtype, name, options=None):\n+    # Add additional check for __all__ with non-empty\n+    options = {'members': True}\n+    actual_with_non_empty_all = do_autodoc(app, 'module', 'example_with_non_empty_all', options)\n+    assert list(actual_with_non_empty_all) == [\n+        '',\n+        '.. py:module:: example_with_non_empty_all',\n+        '',\n+        'docstring of example_with_non_empty_all module.',\n+        '',\n+        '.. py:function:: foo',\n+        '   :module: example_with_non_empty_all',\n+        '',\n+        '   docstring',\n+        '',\n+    ]\n     if options is None:\n         options = {}\n     app.env.temp_data.setdefault('docname', 'index')  # set dummy docname\n",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..8ddad6f 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -15,6 +16,7 @@ from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tup\n \n import pytest\n \n+from struct import Struct\n from sphinx.util.typing import restify, stringify\n \n \n@@ -44,6 +46,7 @@ def test_restify():\n     assert restify(None) == \":obj:`None`\"\n     assert restify(Integral) == \":class:`numbers.Integral`\"\n     assert restify(Any) == \":obj:`Any`\"\n+    assert restify(Struct) == \":class:`struct.Struct`\"\n \n \n def test_restify_type_hints_containers():\n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..13566a0 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1426,6 +1426,37 @@ class NumpyDocstringTest(BaseDocstringTest):\n         \"\"\")\n \n         config = Config(napoleon_preprocess_types=False, napoleon_use_param=False)\n+\n+    def test_other_parameters_with_use_param_false(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+    Description of param2.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param2** (:class:`MyClass <name.space.MyClass>` instance)\n+    Description of param2.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_other_parameters_with_use_param_true(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+    Description of param2.\n+\"\"\"\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param param2:\n+:type param2: :class:`MyClass <name.space.MyClass>` instance\n+    Description of param2.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n         actual = str(NumpyDocstring(docstring, config))\n         expected = dedent(\"\"\"\n         Single line summary\n",
  "sphinx-doc__sphinx-8721": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\nindex d4fba47..ee99801 100644\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -49,7 +49,13 @@ def test_viewcode(app, status, warning):\n             '<span>    &quot;&quot;&quot;</span></div>\\n') in result\n \n \n-@pytest.mark.sphinx(testroot='ext-viewcode', tags=['test_linkcode'])\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode', confoverrides={'viewcode_enable_epub': False})\n+def test_viewcode_epub_override_disabled(app, status, warning):\n+    app.builder.build_all()\n+    \n+    # When viewcode_enable_epub is False, ensure module pages are not created\n+    assert not (app.outdir / '_modules').exists()\n+    assert not (app.outdir / '_modules/spam/mod1.xhtml').exists()\n def test_linkcode(app, status, warning):\n     app.builder.build(['objects'])\n \n@@ -60,8 +66,15 @@ def test_linkcode(app, status, warning):\n     assert 'http://foobar/c/' in stuff\n     assert 'http://foobar/cpp/' in stuff\n \n+@pytest.mark.sphinx('epub', testroot='ext-viewcode')\n+def test_viewcode_epub_disabled(app, status, warning):\n+    app.builder.build_all()\n+\n+    # Ensure that the _modules folder and its contents do not exist\n+    assert not (app.outdir / '_modules').exists()\n \n-@pytest.mark.sphinx(testroot='ext-viewcode-find')\n+    # Specific check for a file that should not be generated\n+    assert not (app.outdir / '_modules/spam/mod1.xhtml').exists()\n def test_local_source_files(app, status, warning):\n     def find_source(app, modname):\n         if modname == 'not_a_package':\n",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..09f601c 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -322,6 +322,17 @@ def test_mul():\n         assert h == h2\n \n \n+def test_permutation_non_disjoint_cycles():\n+    # Test case for non-disjoint cycles, should construct the identity permutation\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n+    # Test case for non-disjoint cycles, should result in a valid permutation\n+    assert Permutation([[0, 1], [1, 2]]) == Permutation([0, 2, 1])\n+    # Another test case for non-disjoint cycles with overlap\n+    assert Permutation([[0, 2], [2, 3], [3, 4]]) == Permutation([2, 3, 4, 0, 1])\n+    # A more complex non-disjoint cycle test to ensure all combinations are handled\n+    assert Permutation([[1, 2], [2, 3], [3, 4], [0, 1]]) == Permutation([1, 3, 4, 0, 2])\n+\n+\n def test_args():\n     p = Permutation([(0, 3, 1, 2), (4, 5)])\n     assert p._cyclic_form is None\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..2a894bc 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -1,3 +1,4 @@\n+\n from sympy import Abs, S, Symbol, I, Rational, PurePoly\n from sympy.matrices import Matrix, SparseMatrix, eye, zeros, ShapeError\n from sympy.utilities.pytest import raises\n@@ -448,6 +449,43 @@ def test_sparse_matrix():\n     assert A.col_list() == [(0, 0, 18), (4, 2, 19), (6, 2, 12), (1, 4, 18), (2, 7, 16), (5, 7, 16), (9, 7, 18), (0, 9, 12), (3, 9, 12)]\n     assert SparseMatrix.eye(2).nnz() == 2\n \n+    # Additional test cases for verifying hstack and vstack behavior\n+    # Testing hstack with 0-row matrices with different column lengths\n+    sparse_matrices_zero_rows = [SparseMatrix.zeros(0, n) for n in range(4)]\n+    output = SparseMatrix.hstack(*sparse_matrices_zero_rows)\n+    assert output.shape == (0, 6)\n+\n+    # Testing vstack with 0-column matrices with different row lengths\n+    sparse_matrices_zero_cols = [SparseMatrix.zeros(n, 0) for n in range(4)]\n+    output = SparseMatrix.vstack(*sparse_matrices_zero_cols)\n+    assert output.shape == (6, 0)\n+\n+    # Testing hstack with various configurations of zero dimensions\n+    M1 = SparseMatrix.zeros(0, 0)\n+    M2 = SparseMatrix.zeros(0, 1)\n+    M3 = SparseMatrix.zeros(0, 2)\n+    M4 = SparseMatrix.zeros(0, 3)\n+    output = SparseMatrix.hstack(M1, M2, M3, M4)\n+    assert output.shape == (0, 6)\n+\n+    M1 = SparseMatrix.zeros(1, 0)\n+    M2 = SparseMatrix.zeros(1, 1)\n+    M3 = SparseMatrix.zeros(1, 2)\n+    M4 = SparseMatrix.zeros(1, 3)\n+    output = SparseMatrix.hstack(M1, M2, M3, M4)\n+    assert output.shape == (1, 6)\n+\n+    # Testing vstack with various configurations of zero dimensions\n+    M1 = SparseMatrix.zeros(0, 1)\n+    M2 = SparseMatrix.zeros(1, 1)\n+    output = SparseMatrix.vstack(M1, M2)\n+    assert output.shape == (1, 1)\n+\n+    M1 = SparseMatrix.zeros(2, 0)\n+    M2 = SparseMatrix.zeros(3, 0)\n+    output = SparseMatrix.vstack(M1, M2)\n+    assert output.shape == (5, 0)\n+\n \n def test_transpose():\n     assert SparseMatrix(((1, 2), (3, 4))).transpose() == \\\n",
  "sympy__sympy-13471": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\nindex 0a3b6ce..59d1c77 100644\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -581,9 +581,16 @@ def test_Float_issue_2107():\n     assert S.Zero + b - b == 0\n     assert S.Zero + b + (-b) == 0\n \n-\n-def test_Infinity():\n-    assert oo != 1\n+def test_pickle_float_representation():\n+    # Test direct Float creation from tuple using 'L' suffixed integers\n+    a = Float((0, '1L', 0, 1))\n+    b = Float((0, '1', 0, 1))\n+    assert a == b\n+    \n+    # Ensure other float containing expressions pickle compatibly between Python versions\n+    x = symbols('x')\n+    e = x + Float((0, '10', 0, 1))  # represents x + 1.0\n+    assert pickle.loads(pickle.dumps(e, protocol=2)) == e\n     assert 1*oo == oo\n     assert 1 != oo\n     assert oo != -oo\n",
  "sympy__sympy-13480": "",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..33c037c 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -201,7 +201,21 @@ def test_col_insert():\n         l.insert(i, 4)\n         assert flatten(zeros_Shaping(3).col_insert(i, c4).row(0).tolist()) == l\n \n-def test_extract():\n+def test_issue_13643_col_insert():\n+    from sympy import Matrix, eye, ones\n+    # Testing the insertion of a column matrix at position 3\n+    M = eye(6)\n+    V = 2 * ones(6, 2)\n+    result = M.col_insert(3, V)\n+    expected = Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    assert result == expected\n     m = ShapingOnlyMatrix(4, 3, lambda i, j: i*3 + j)\n     assert m.extract([0, 1, 3], [0, 1]) == Matrix(3, 2, [0, 1, 3, 4, 9, 10])\n     assert m.extract([0, 3], [0, 0, 2]) == Matrix(2, 3, [0, 0, 2, 9, 9, 11])\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..49e3f71 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -616,14 +616,19 @@ def test_latex_Range():\n     assert latex(Range(-2, -oo, -1)) == r'\\left\\{-2, -3, \\ldots, -\\infty\\right\\}'\n \n \n+from sympy import SeqFormula, SeqPer, SeqAdd, SeqMul, symbols, latex, oo\n+\n def test_latex_sequences():\n+    a = symbols('a')\n+\n     s1 = SeqFormula(a**2, (0, oo))\n     s2 = SeqPer((1, 2))\n \n-    latex_str = r'\\left\\[0, 1, 4, 9, \\ldots\\right\\]'\n+    # Test the rendering without backslashes escaping the brackets\n+    latex_str = r'[0, 1, 4, 9, \\ldots]'\n     assert latex(s1) == latex_str\n \n-    latex_str = r'\\left\\[1, 2, 1, 2, \\ldots\\right\\]'\n+    latex_str = r'[1, 2, 1, 2, \\ldots]'\n     assert latex(s2) == latex_str\n \n     s3 = SeqFormula(a**2, (0, 2))\n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..c96cd4b 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,22 @@\n+\n+def test_Domain_preprocess_with_RR_CC():\n+    assert Domain.preprocess('R[x]') == RR[x]\n+    assert Domain.preprocess('C[x]') == CC[x]\n+    assert Domain.preprocess('RR[x]') == RR[x]\n+    assert Domain.preprocess('CC[x]') == CC[x]\n+    assert Domain.preprocess('R[x,y]') == RR[x, y]\n+    assert Domain.preprocess('C[x,y]') == CC[x, y]\n+    assert Domain.preprocess('RR[x,y]') == RR[x, y]\n+    assert Domain.preprocess('CC[x,y]') == CC[x, y]\n+\n+def test_Poly_with_RR_domain():\n+    from sympy import Poly\n+    from sympy.abc import x, y, z\n+\n+    poly_RR = Poly(1.2*x*y*z, x, domain=RR[y,z])\n+    assert poly_RR.rep.domain == RR[y,z]\n+    assert poly_RR.gens == (x,)\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +25,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n",
  "sympy__sympy-14774": "",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..cf1205e 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6110,8 +6110,29 @@ u(\"\"\"\\\n \"\"\")\n     assert upretty((1/y)*e.j) == ucode_str\n \n+from sympy import MatrixSymbol, pretty, symbols\n \n-def test_MatrixSymbol_printing():\n+n = symbols('n', integer=True)\n+\n+def test_issue_14814():\n+    # Test cases for issue #14814\n+    x = MatrixSymbol('x', n, n)\n+    y = MatrixSymbol('y*', n, n)\n+\n+    # Test addition of MatrixSymbols with special characters\n+    assert pretty(x + y) == \"x + y*\"\n+\n+    # Additional tests to ensure proper handling of expressions\n+    a = symbols('a', integer=True)\n+    assert pretty(-a*x + -2*y*y) == \"-a*x - 2*y**y*\"\n+\n+    # Test nested MatAdd operations\n+    z = MatrixSymbol('z', n, n)\n+    assert pretty(x + y + z) == \"x + y* + z\"\n+\n+    # Test for a matrix with negative symbol names\n+    negative_y = MatrixSymbol('-y', n, n)\n+    assert pretty(x + negative_y) == \"x - y\"\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n     B = MatrixSymbol(\"B\", 3, 3)\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..c91dc7f 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -728,6 +728,20 @@ def test_dummification():\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 2 * F(t) + 5))\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 4 * F(t) + 5))\n \n+def test_curly_matrix_symbol():\n+    # Test based on issue description\n+    curlyv = sy.MatrixSymbol(\"{v}\", 2, 1)\n+\n+    # Without dummify, check the SyntaxError is raised if the issue is unresolved\n+    raises(SyntaxError, lambda: lambdify(curlyv, curlyv))\n+\n+    # Also test with dummify=True\n+    raises(SyntaxError, lambda: lambdify(curlyv, curlyv, dummify=True))\n+\n+import sympy as sy\n+from sympy import lambdify\n+from sympy.testing.pytest import raises\n+\n def test_python_keywords():\n     # Test for issue 7452. The automatic dummification should ensure use of\n     # Python reserved keywords as symbol names will create valid lambda\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..38380ad 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n@@ -23,6 +24,16 @@ def test_Rational():\n     assert mcode(x + Rational(3, 7)) == \"x + 3/7\"\n     assert mcode(Rational(3, 7)*x) == \"(3/7)*x\"\n \n+def test_Max():\n+    # Original test case\n+    assert mcode(Max(x, y, z) * Min(y, z)) == \"Max[x, y, z]*Min[y, z]\"\n+    \n+    # New test cases for the issue\n+    assert mcode(Max(x, 2)) == \"Max[x, 2]\"\n+    assert mcode(Max(2, x)) == \"Max[2, x]\"\n+    assert mcode(Max(0, x, pi)) == \"Max[0, x, Pi]\"\n+    assert mcode(Max(x, y + 2)) == \"Max[x, y + 2]\"\n+\n \n def test_Function():\n     assert mcode(f(x, y, z)) == \"f[x, y, z]\"\n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..707fbfb 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1717,6 +1717,15 @@ def test_issue_13651():\n     assert latex(expr) == r\"c - \\left(a + b\\right)\"\n \n \n+from sympy import symbols, MatrixSymbol, latex\n+\n+def test_indexed_matrix_expression_latex():\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    # Test the LaTeX output is correct and compilable after the fix.\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n+\n def test_latex_UnevaluatedExpr():\n     x = symbols(\"x\")\n     he = UnevaluatedExpr(1/x)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..8a72312 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, exp, Eq\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -9,7 +10,20 @@ def test_idiff():\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     t = Symbol('t', real=True)\n-    # the use of idiff in ellipse also provides coverage\n+    # Additional test cases for the issue with idiff\n+    f = Function('f')\n+    g = Function('g')\n+    \n+    # Test case for Eq() syntax issue described\n+    assert idiff(Eq(y*exp(y), x*exp(x)), y, x).simplify() == ((x + 1)*exp(x - y)/(y + 1)).simplify()\n+\n+    # Added test cases for f(x) notation issue\n+    assert idiff(f(x)*exp(f(x)) - x*exp(x), f(x), x).simplify() == ((x + 1) * exp(x - f(x))/(f(x) + 1)).simplify()\n+\n+    # Edge case by giving list of dependent variables\n+    assert idiff(f(x) - y * exp(x), [f(x), y], x) == (y + Derivative(y, x)) * exp(x)\n+    assert idiff(f(x) - y * exp(x), [y, f(x)], x) == -y + exp(-x) * Derivative(f(x), x)\n+    assert idiff(f(x) - g(x), [f(x), g(x)], x) == Derivative(g(x), x)\n     circ = x**2 + y**2 - 4\n     ans = -3*x*(x**2 + y**2)/y**5\n     assert ans == idiff(circ, y, x, 3).simplify()\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_codegen.py b/sympy/utilities/tests/test_codegen.py\nindex 6bc2605..6e401e2 100644\n--- a/sympy/utilities/tests/test_codegen.py\n+++ b/sympy/utilities/tests/test_codegen.py\n@@ -581,8 +581,19 @@ def test_ccode_cse():\n         '}\\n'\n     )\n     assert source == expected\n-\n-def test_empty_f_code():\n+from sympy.utilities.autowrap import autowrap\n+from sympy import MatrixSymbol\n+import numpy as np\n+\n+def test_ccode_unused_array_arg():\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0  # x does not appear in the output\n+    f = autowrap(expr, args=(x,), backend='cython')\n+\n+    # Call the wrapped function\n+    result = f(np.array([[1.0], [2.0]]))\n+    # Assert the result is 1.0 as the expression does not depend on x\n+    assert result == 1.0\n     code_gen = FCodeGen()\n     source = get_string(code_gen.dump_f95, [])\n     assert source == \"\"\n",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..2e53801 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -342,8 +342,27 @@ def test_intersection():\n     # issue 12178\n     assert Intersection() == S.UniversalSet\n \n-\n-def test_issue_9623():\n+def test_issue_intersection_remove_duplicates():\n+    x = symbols('x')\n+    \n+    # Test: Intersection with duplicates should remove duplicates\n+    assert Intersection({1}, {1}, {x}) == Intersection({1}, {x})\n+    \n+    # Test: Symbolic Intersection that should return with Piecewise based on the input x\n+    assert Intersection({1}, {1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    \n+    # Test with more nested sets to verify behavior\n+    assert Intersection({1, 1, 1, 1}, {1, x, x}, {x, x}) == Piecewise((FiniteSet(1), Eq(x, 1)), (S.EmptySet, True))\n+    \n+    # Test with simple cases and ensure no errors\n+    assert Intersection(FiniteSet(1, 2, 3, 3), FiniteSet(1, 2)) == FiniteSet(1, 2)\n+\n+    # Edge case with symbols\n+    y = symbols('y')\n+    assert Intersection({1, y}, {1, x}) == Piecewise(({1}, Eq(y, 1) & Eq(x, 1)), (S.EmptySet, True))\n+\n+    # More exhaustive symbolic test\n+    assert Intersection({x, y}, {1, y, y}, {1, x}) == Piecewise(({1}, Eq(x, 1) & Eq(y, 1)), (S.EmptySet, True))\n     n = Symbol('n')\n \n     a = S.Reals\n",
  "sympy__sympy-17022": "",
  "sympy__sympy-17139": "diff --git a/sympy/simplify/tests/test_fu.py b/sympy/simplify/tests/test_fu.py\nindex 135b4cd..c0a1c20 100644\n--- a/sympy/simplify/tests/test_fu.py\n+++ b/sympy/simplify/tests/test_fu.py\n@@ -68,6 +68,15 @@ def test_TR3():\n         assert verify_numerically(i, j) and i.func != j.func\n \n \n+    # issue 17137\n+    assert T(sin(x)**I, sin, cos, h, 4, True) == sin(x)**I\n+    assert T(sin(x)**(2*I + 1), sin, cos, h, 4, True) == sin(x)**(2*I + 1)\n+\n+def test_issue_17137_fu():\n+    assert T(cos(x)**I, cos, sin, h, 4, True) == cos(x)**I\n+    assert T(cos(x)**(2*I + 1), cos, sin, h, 4, True) == cos(x)**(2*I + 1)\n+\n+\n def test__TR56():\n     h = lambda x: 1 - x\n     assert T(sin(x)**3, sin, cos, h, 4, False) == sin(x)**3\n",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..a632731 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,4 +1,6 @@\n-from sympy import I, Rational, Symbol, pi, sqrt, S\n+\n+from sympy import I, Rational, Symbol, pi, sqrt, S, sympify\n+from sympy.geometry import Point\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n from sympy.matrices import Matrix\n@@ -28,6 +30,12 @@ def test_point():\n     assert (p2 - p1) == Point(y1 - x1, y2 - x2)\n     assert p4*5 == Point(5, 5)\n     assert -p2 == Point(-y1, -y2)\n+\n+    # Test multiplication and addition ordering issue\n+    p1 = Point(0, 0)\n+    p2 = Point(1, 1)\n+    assert p1 + p2 * sympify(2.0) == Point(2, 2)\n+    assert p1 + sympify(2.0) * p2 == Point(2, 2)\n     raises(ValueError, lambda: Point(3, I))\n     raises(ValueError, lambda: Point(2*I, I))\n     raises(ValueError, lambda: Point(3 + I, I))\n@@ -143,6 +151,12 @@ def test_point3D():\n     assert p4*5 == Point3D(5, 5, 5)\n     assert -p2 == Point3D(-y1, -y2, -y3)\n \n+    # Test multiplication and addition ordering issue for 3D points\n+    p1_3d = Point3D(0, 0, 0)\n+    p2_3d = Point3D(1, 1, 1)\n+    assert p1_3d + p2_3d * sympify(2.0) == Point3D(2, 2, 2)\n+    assert p1_3d + sympify(2.0) * p2_3d == Point3D(2, 2, 2)\n+\n     assert Point(34.05, sqrt(3)) == Point(Rational(681, 20), sqrt(3))\n     assert Point3D.midpoint(p3, p4) == Point3D(half, half, half)\n     assert Point3D.midpoint(p1, p4) == Point3D(half + half*x1, half + half*x2,\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..3a34a01 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1893,8 +1893,28 @@ def test_normal():\n     e = Mul(S.Half, 1 + x, evaluate=False)\n     assert e.normal() == e\n \n+from sympy import Symbol\n+from sympy.core.sympify import sympify\n+from sympy.core.symbol import symbols\n+from sympy.testing.pytest import raises\n \n def test_expr():\n+    # This test checks that the issue with eval in equality comparisons is resolved.\n+\n+    # Ensure equality comparison does not improperly evaluate repr\n+    class C:\n+        def __repr__(self):\n+            return 'x.y'\n+    \n+    x = Symbol('x')\n+    assert (x == C()) is False  # This should not raise an AttributeError\n+    \n+    # Check for proper comparison with an unknown object whose repr is 'x'\n+    class D:\n+        def __repr__(self):\n+            return 'x'\n+    \n+    assert (x == D()) is False  # Should not incorrectly compare as equal to Symbol 'x'\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n \n@@ -1902,4 +1922,4 @@ def test_expr():\n def test_ExprBuilder():\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..09de25f 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -547,7 +547,13 @@ def test_diophantine():\n     assert diophantine(x**2 + y**2 +3*x- 5, permute=True) == \\\n         set([(-1, 1), (-4, -1), (1, -1), (1, 1), (-4, 1), (-1, -1), (4, 1), (4, -1)])\n \n-    # issue 18122\n+    # issue 18186: Test for diophantine with permute=True and different symbols order\n+    from sympy.abc import m, n\n+\n+    assert diophantine(m**4 + n**4 - 2**4 - 3**4, syms=(m, n), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    assert diophantine(m**4 + n**4 - 2**4 - 3**4, syms=(n, m), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n     assert check_solutions(x**2-y)\n     assert check_solutions(y**2-x)\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n",
  "sympy__sympy-18532": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex f97b2ee..03aeb5a 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -137,6 +137,42 @@ def test_subs_with_unicode_symbols():\n \n \n def test_atoms():\n+    from sympy import symbols, Add, Mul, Pow, Integer, Float, Symbol\n+    x, y = symbols('x y')\n+    \n+    # Test an integer atom, it should return itself\n+    expr = Integer(5)\n+    assert expr.atoms() == {expr}\n+    \n+    # Test a float atom, it should return itself\n+    expr = Float(3.14)\n+    assert expr.atoms() == {expr}\n+    \n+    # Test a symbol (which should be an atom)\n+    expr = x\n+    assert expr.atoms() == {x}\n+\n+    # Test an addition expression\n+    expr = Add(x, y, Integer(2))\n+    assert expr.atoms() == {x, y, Integer(2)}\n+\n+    # Test a multiplication expression\n+    expr = Mul(x, y, Integer(3))\n+    assert expr.atoms() == {x, y, Integer(3)}\n+\n+    # Test a power expression\n+    expr = Pow(x, x)\n+    assert expr.atoms() == {x}\n+\n+    # Test with no args (empty set expected)\n+    class BasicNoArgs:\n+        def args(self):\n+            return ()\n+    \n+    basic_no_args_instance = BasicNoArgs()\n+    assert basic_no_args_instance.args() == ()\n+    assert hasattr(basic_no_args_instance, 'args')\n+    # since it's a custom case, atoms checking is to ensure it's consistent\n     assert b21.atoms() == set()\n \n \n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..5fcf65b 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,31 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_BlockDiagMatrix_single_element():\n+    # Test for issue where BlockDiagMatrix with one element raises error when converting back to regular Matrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    B = Matrix(D)\n+\n+    # Assert the resulting matrix is equal to the original matrix\n+    assert B == M\n+\n+def test_BlockDiagMatrix_multiple_elements():\n+    # Ensure that multiple elements in BlockDiagMatrix work as expected\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M, M)\n+    B = Matrix(D)\n+\n+    # Check the resulting matrix matches the expected block diagonal form\n+    expected = Matrix([\n+        [1, 2, 0, 0],\n+        [3, 4, 0, 0],\n+        [0, 0, 1, 2],\n+        [0, 0, 3, 4]\n+    ])\n+\n+    assert B == expected\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..20239b9 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,4 +1,5 @@\n-from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n+\n+from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, MatrixElement, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n from sympy.testing.pytest import raises\n",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..d8f1a6a 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -317,7 +317,36 @@ def test_sign():\n     assert sign(d).func is sign or sign(d) == 0\n \n \n-def test_as_real_imag():\n+def test_rewrite_sign_as_abs():\n+    x, y, z = symbols('x y z')\n+    f = Function('f')\n+    \n+    # Test the rewrite of `sign(x, y)` with `x` being real\n+    assert sign(x).rewrite(Abs) == Piecewise((0, Eq(x, 0)), (x/Abs(x), True))\n+    assert sign(y).rewrite(Abs) == Piecewise((0, Eq(y, 0)), (y/Abs(y), True))\n+    \n+    # Test the rewrite of `sign` when x is a function of y\n+    assert sign(f(y)).rewrite(Abs) == Piecewise((0, Eq(f(y), 0)), (f(y)/Abs(f(y)), True))\n+    \n+    # Test behavior for zero argument\n+    zero = 0\n+    assert sign(zero).rewrite(Abs) == 0\n+    \n+    # Test for a complex expression\n+    complex_expr = 2 + 3*I\n+    assert sign(complex_expr).rewrite(Abs) == complex_expr/Abs(complex_expr)\n+\n+    # Symbolic complex numbers\n+    a = Symbol('a', complex=True)\n+    assert sign(a).rewrite(Abs) == Piecewise((0, Eq(a, 0)), (a/Abs(a), True))\n+\n+    # Test with assumptions\n+    x_nonzero = Symbol('x_nonzero', nonzero=True)\n+    assert sign(x_nonzero).rewrite(Abs) == x_nonzero / Abs(x_nonzero)\n+\n+    # Check SymPy's assumptions hold after rewrite\n+    assert sign(Symbol('p', positive=True)).rewrite(Abs).is_positive is True\n+    assert sign(Symbol('q', negative=True)).rewrite(Abs).is_negative is True\n     n = pi**1000\n     # the special code for working out the real\n     # and complex parts of a power with Integer exponent\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..be32139 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -471,7 +471,22 @@ def test_multiset_permutations():\n         6\\n''')\n \n \n+from sympy.utilities.iterables import partitions\n+from sympy import S\n+\n def test_partitions():\n+    # Test to ensure the same dictionary is not being reused\n+    partitions_list = list(partitions(6, k=2))\n+    first_partition = partitions_list[0].copy()\n+    first_partition[1] += 1  # Modify the first partition\n+    \n+    # Check that the original partitions list is unaffected by the modification\n+    assert partitions_list[0] == {2: 3}, \"Modifying copy should not affect original\"\n+\n+    partitions_list = list(partitions(6))\n+    modified_copy = [{**part} for part in partitions_list]\n+    modified_copy[0][6] = 2\n+    assert partitions_list[0] == {6: 1}, \"Original list should remain unchanged after copying\"\n     ans = [[{}], [(0, {})]]\n     for i in range(2):\n         assert list(partitions(0, size=i)) == ans[i]\n",
  "sympy__sympy-20212": "diff --git a/sympy/core/tests/test_power.py b/sympy/core/tests/test_power.py\nindex 686973b..3b91773 100644\n--- a/sympy/core/tests/test_power.py\n+++ b/sympy/core/tests/test_power.py\n@@ -266,8 +266,12 @@ def test_zero():\n     assert 0**(2*x*y) == 0**(x*y)\n     assert 0**(-2*x*y) == S.ComplexInfinity**(x*y)\n \n+from sympy import S, oo, zoo, pow\n \n-def test_pow_as_base_exp():\n+def test_issue_19572():\n+    # Assert that 0 raised to the power of -oo is ComplexInfinity (zoo)\n+    assert 0**-S.Infinity == S.ComplexInfinity\n+    assert pow(0, -S.Infinity) == S.ComplexInfinity\n     x = Symbol('x')\n     assert (S.Infinity**(2 - x)).as_base_exp() == (S.Infinity, 2 - x)\n     assert (S.Infinity**(x - 2)).as_base_exp() == (S.Infinity, x - 2)\n",
  "sympy__sympy-20442": "",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..2d2b4f7 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -28,6 +28,24 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+import sympy\n+from sympy.testing.pytest import raises\n+\n+def test_symbol_no_dict():\n+    # A new test function for verifying that Sympy Symbol instances do not have __dict__\n+    s = sympy.Symbol('s')\n+    assert not hasattr(s, '__dict__')\n+\n+    # Check whether accessing __dict__ raises an AttributeError\n+    with raises(AttributeError):\n+        _ = s.__dict__\n+\n+def test_symbol_slots():\n+    # A new test function for verifying the __slots__ attribute\n+    s = sympy.Symbol('s')\n+    assert hasattr(s, '__slots__')\n+    assert s.__slots__ == ('name',)\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..965522b 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n                    atan, atan2, nan, Symbol, re, im, sign)\n from sympy.abc import w, x, y, z\n@@ -160,6 +161,24 @@ def test_sign():\n     x = Symbol('x', complex=True)\n     assert refine(sign(x), Q.zero(x)) == 0\n \n+def test_issue_refine_complex_arg():\n+    # Testing arg simplification with positive/negative assumptions\n+    x = Symbol('x', complex=True)\n+\n+    # Check if arg(x) is refined to 0 when x is assumed positive\n+    assert refine(arg(x), Q.positive(x)) == 0\n+\n+    # Check if arg(x) equals pi when x is negative\n+    assert refine(arg(x), Q.negative(x)) == pi\n+\n+    # Verify the specific issue situation with real positive a\n+    a = Symbol('a', real=True)\n+    J = Integral(sin(x) * exp(-a*x), (x, 0, oo))\n+    # Result derived analytically should be 1/(a**2 + 1)\n+    refined_result = refine(J.doit(), Q.positive(a))\n+    expected_result = Piecewise((1/(a**2 + 1), True))\n+    assert refined_result == expected_result\n+\n \n def test_func_args():\n     class MyClass(Expr):\n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..6508288 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -8,6 +9,33 @@ from sympy.core.basic import _aresame\n from sympy.testing.pytest import XFAIL\n from sympy.abc import a, x, y, z, t\n \n+def test_subs_issue_21373():\n+    from sympy.functions.elementary.piecewise import Piecewise\n+    from sympy.functions.elementary.hyperbolic import sinh\n+    expr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\n+    assert expr.subs({1: 1.0}) is not None  # Should not raise PolynomialError\n+\n+    x_r, y_r, z_r = symbols('x_r y_r z_r', real=True)\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr.subs({1: 1.0}) is not None  # Should not raise PolynomialError\n+\n+    # Extra checks: different functions, removing 'exp', 'z', etc.\n+    expr_cosh = exp(cosh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    expr_tanh = exp(tanh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr_cosh.subs({1: 1.0}) is not None  # Should work with cosh\n+    assert expr_tanh.subs({1: 1.0}) is not None  # Should work with tanh\n+\n+    # Removing exp\n+    expr_no_exp = sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r)\n+    assert expr_no_exp.subs({1: 1.0}) is not None\n+\n+    # Check without division by z\n+    expr_no_div_z = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True))))\n+    assert expr_no_div_z.subs({1: 1.0}) is not None\n+\n+    # Make sure it doesn't throw error\n+    assert expr_no_exp.subs({x_r: 1.0}) is not None\n+\n def test_subs():\n     n3 = Rational(3)\n     e = x\n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..a4c6e3a 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,7 +1,9 @@\n+\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n from sympy.core.numbers import pi, zoo, I, AlgebraicNumber\n+from sympy.core.function import Derivative\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n from sympy.integrals.integrals import Integral\n@@ -45,7 +47,10 @@ def test_Matrix_kind():\n         m = cls.zeros(3, 2)\n         assert m.kind is MatrixKind(NumberKind)\n \n-def test_MatMul_kind():\n+def test_Derivative_kind():\n+    A = MatrixSymbol('A', 2, 2)\n+    assert Derivative(comm_x, comm_x).kind is NumberKind\n+    assert Derivative(A, comm_x).kind is MatrixKind(NumberKind)\n     M = Matrix([[1,2],[3,4]])\n     assert MatMul(2, M).kind is MatrixKind(NumberKind)\n     assert MatMul(comm_x, M).kind is MatrixKind(NumberKind)\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..c66295d 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -130,6 +130,26 @@ def test_monomials():\n     assert set(itermonomials([x, y], [2, 1])) == {S.One, x, y, x*y, x**2, x**2*y}\n     assert set(itermonomials([x, y], [2, 2])) == \\\n             {S.One, y**2, x*y**2, x, x*y, x**2, x**2*y**2, y, x**2*y}\n+    # Test cases for issue with min_degrees argument in itermonomials\n+    # These tests assert that the correct monomials are generated when min_degrees and max_degrees are integers\n+\n+    # Case where both maximum and minimum degrees are 3\n+    # Includes monomials of total degree exactly 3\n+    x1, x2, x3 = symbols('x1 x2 x3')\n+    assert set(itermonomials([x1, x2, x3], 3, 3)) == {\n+        x1**3, x2**3, x3**3, x1*x2**2, x2*x1**2, x2*x3**2, x3*x2**2,\n+        x3*x1**2, x1*x3**2, x1*x2*x3, x1**2*x2, x1*x2**2, x2**2*x3,\n+        x2*x3**2, x3**2*x1, x3*x1**2, x1*x3**2, x1**2*x3, x2*x1*x3\n+    }\n+    # Case with max_degrees increased above min_degrees\n+    assert set(itermonomials([x1, x2, x3], 4, 3)) == {\n+        x1**3, x2**3, x3**3, x1*x2**2, x2*x1**2, x2*x3**2, x3*x2**2,\n+        x3*x1**2, x1*x3**2, x1*x2*x3, x1**2*x2, x1*x2**2, x2**2*x3,\n+        x2*x3**2, x3**2*x1, x3*x1**2, x1*x3**2, x1**2*x3, x2*x1*x3,\n+        x1**4, x2**4, x3**4, x1**3*x2, x1**3*x3, x2**3*x1, x2**3*x3,\n+        x3**3*x1, x3**3*x2, x1**2*x2**2, x1**2*x3**2, x2**2*x3**2,\n+        x1*x2*x3**2, x1*x3*x2**2, x2*x3*x1**2, x2*x3*x3**2, \n+    }\n \n     i, j, k = symbols('i j k', commutative=False)\n     assert set(itermonomials([i, j, k], [0, 0, 0])) == {S.One}\n",
  "sympy__sympy-22005": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 341f63c..257c44f 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n@@ -49,8 +50,14 @@ def test_solve_poly_system():\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\n     raises(PolynomialError, lambda: solve_poly_system([1/x], x))\n \n-\n-def test_solve_biquadratic():\n+def test_additional_infinite_solution_cases():\n+    raises(NotImplementedError, lambda: solve_poly_system([x - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([y - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([x - 1, y - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([x**2 + y**2 - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([x + y - 1, x - y], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([x**2 - 1, y - x], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([x**2 + y**2 - 1, x*y - 1/4], (x, y)))\n     x0, y0, x1, y1, r = symbols('x0 y0 x1 y1 r')\n \n     f_1 = (x - 1)**2 + (y - 1)**2 - r**2\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..9dec102 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,9 +1,11 @@\n+\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n from sympy.core.sympify import sympify\n from sympy.functions.elementary.miscellaneous import sqrt\n+from sympy.core.parameters import evaluate\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate, GeometryEntity\n from sympy.matrices import Matrix\n",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..c092ddd 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -347,7 +347,34 @@ def test_cse_MatrixSymbol():\n     B = MatrixSymbol(\"B\", n, n)\n     assert cse(B) == ([], [B])\n \n-def test_cse_MatrixExpr():\n+def test_cse_MatrixSymbol_indexing():\n+    from sympy import cse, MatrixSymbol, symbols\n+    \n+    # Define a 3x3 MatrixSymbol\n+    A = MatrixSymbol(\"A\", 3, 3)\n+\n+    # Test with simple indexing\n+    assert cse(A[0, 0] * A[0, 1] + A[0, 0] * A[0, 1] * A[0, 2]) == (\n+        [(x0, A[0, 0] * A[0, 1])],\n+        [x0 * A[0, 2] + x0]\n+    )\n+\n+    # Test with repeated elements and different expressions\n+    assert cse(A[0, 0] + A[0, 0]) == (\n+        [(x0, A[0, 0])],\n+        [2 * x0]\n+    )\n+\n+    # Testing with a symbolic dimension MatrixSymbol\n+    n = symbols('n', integer=True)\n+    B = MatrixSymbol(\"B\", n, n)\n+    assert cse(B[0, 0] + B[1, 1]) == ([], [B[0, 0] + B[1, 1]])\n+\n+    # Test to ensure no unnecessary replacements for non-Basic elements\n+    assert cse(A[1, 1] * A[1, 2]) == (\n+        [(x0, A[1, 1])],\n+        [x0 * A[1, 2]]\n+    )\n     A = MatrixSymbol('A', 3, 3)\n     y = MatrixSymbol('y', 3, 1)\n \n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..0fdc170 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,6 @@\n+\n+from sympy.tensor.array.dense_ndim_array import MutableSparseNDimArray\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -38,6 +41,13 @@ def test_array_negative_indices():\n         assert test_array[-1, -1] == 10\n \n \n+def test_issue_17851():\n+    for array_type in array_types:\n+        A = array_type([])\n+        assert isinstance(A, array_type), f\"Expected instance of {array_type}, got {type(A)}\"\n+        assert A.shape == (0,), f\"Expected shape (0,), got {A.shape}\"\n+        assert list(A) == [], f\"Expected empty list, got {list(A)}\"\n+\n def test_issue_18361():\n     A = Array([sin(2 * x) - 2 * sin(x) * cos(x)])\n     B = Array([sin(x)**2 + cos(x)**2, 0])\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..9860e0b 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,6 +1175,18 @@ def test_scipy_polys():\n \n \n \n+import inspect\n+from sympy import lambdify, tuple, symbols\n+\n+def test_issue_tuple_single_element():\n+    # Test case for the issue where lambdify with a single element tuple wasn't respected\n+\n+    # Check the generated source code respects the tuple notation\n+    f = lambdify([], (1,))\n+    src = inspect.getsource(f)\n+    \n+    assert 'return (1,)' in src, f\"Expected tuple notation in source, got: {src}\"\n+\n def test_lambdify_inspect():\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..b04ac96 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -541,7 +541,29 @@ def test_issue_20288():\n     assert SI._collect_factor_and_dimension(expr) == (1 + E, Dimension(1))\n \n \n-def test_prefixed_property():\n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units import Quantity\n+    from sympy.physics.units.systems.si import SI\n+    from sympy.functions import exp\n+    from sympy.physics.units.dimensions import Dimension\n+\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..8474c00 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -32,6 +32,13 @@ def test_tensor_product_dagger():\n         TensorProduct(Dagger(mat1), Dagger(mat2))\n \n \n+from sympy import symbols\n+from sympy.physics.quantum import TensorProduct as TP\n+\n+x, A, B, C = symbols('x A B C', commutative=False)\n+U = symbols('U', commutative=False)\n+V = symbols('V', commutative=False)\n+\n def test_tensor_product_abstract():\n \n     assert TP(x*A, 2*B) == x*2*TP(A, B)\n@@ -53,7 +60,31 @@ def test_tensor_product_commutator():\n         TP(A, B)*TP(B, C) - TP(B, C)*TP(A, B)\n \n \n-def test_tensor_product_simp():\n+def test_tensor_product_bug_fix_expansion():\n+    # Tests for fix of issue described in the bug report\n+\n+    # Test 1: Basic expansion of TensorProduct with scalar factors\n+    P = TP(2*U - V, U + V)\n+    assert P.expand(tensorproduct=True) == 2*TP(U, U) + 2*TP(U, V) - TP(V, U) - TP(V, V)\n+\n+    # Test 2: Original test cases expanded further\n+    assert TP(A - B, B - A).expand(tensorproduct=True) == \\\n+        TP(A, B) - TP(A, A) - TP(B, B) + TP(B, A)\n+    \n+    assert TP(2*A + B, A + B).expand(tensorproduct=True) == \\\n+        2*TP(A, A) + 2*TP(A, B) + TP(B, A) + TP(B, B)\n+    \n+    assert TP(2*A*B + A, A + B).expand(tensorproduct=True) == \\\n+        2*TP(A*B, A) + 2*TP(A*B, B) + TP(A, A) + TP(A, B)\n+\n+    # Test 3: Additional test case with zero factor, should evaluate to zero\n+    P_zero = TP(U - U, U + V)\n+    assert P_zero.expand(tensorproduct=True) == 0\n+\n+    # Test 4: Double scalar multipliers\n+    P_double = TP(3*U - 4*V, 5*U + 6*V)\n+    assert P_double.expand(tensorproduct=True) == \\\n+        15*TP(U, U) + 18*TP(U, V) - 20*TP(V, U) - 24*TP(V, V)\n     assert tensor_product_simp(TP(A, B)*TP(B, C)) == TP(A*B, B*C)\n     # tests for Pow-expressions\n     assert tensor_product_simp(TP(A, B)**x) == TP(A**x, B**x)\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..ce1f74a 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -562,7 +563,47 @@ def test_issue_24062():\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n \n-def test_prefixed_property():\n+def test_issue_24211():\n+    from sympy.physics.units import Quantity, acceleration, velocity, time, meter, second\n+    from sympy.physics.units.systems.si import SI\n+\n+    # Original test from the provided patch\n+    V1 = Quantity('V1')\n+    SI.set_quantity_dimension(V1, velocity)\n+    SI.set_quantity_scale_factor(V1, 1 * meter / second)\n+\n+    A1 = Quantity('A1')\n+    SI.set_quantity_dimension(A1, acceleration)\n+    SI.set_quantity_scale_factor(A1, 1 * meter / second**2)\n+\n+    T1 = Quantity('T1')\n+    SI.set_quantity_dimension(T1, time)\n+    SI.set_quantity_scale_factor(T1, 1 * second)\n+\n+    expr = A1*T1 + V1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr)\n+\n+def test_issue_24211_extended():\n+    from sympy.physics.units import Quantity, acceleration, velocity, time, meter, second\n+    from sympy.physics.units.systems.si import SI\n+\n+    # Additional test case based on the original issue description\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+\n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+\n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+\n+    expr1 = a1*t1 + v1\n+    # should not throw ValueError here after the fix\n+    SI._collect_factor_and_dimension(expr1)\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..c45ee61 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, volt, milli\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n@@ -28,6 +29,17 @@ def test_prefix_operations():\n     assert dodeca / dodeca == 1\n \n     m = Quantity(\"fake_meter\")\n+\n+def test_milli_prefix():\n+    # Test specific issue with milli prefix and watt\n+    assert milli * W == W / 1000         # Expected behavior: milli * W should give milliwatt (mW)\n+    assert W * milli == W / 1000         # Commutative multiplication check\n+    # Test with another unit (volt)\n+    assert milli * volt == volt / 1000   # milli prefix with volt should yield millivolt (mV)\n+    assert volt * milli == volt / 1000   # Commutative multiplication with volt\n+    # Test with a numerical result\n+    assert (milli * W).evalf() == 0.001  # Evaluates to 0.001 W\n+    assert (W * milli).evalf() == 0.001\n     SI.set_quantity_dimension(m, S.One)\n     SI.set_quantity_scale_factor(m, S.One)\n \n",
  "django__django-12470": "",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..e0dc65a 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,6 +343,47 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n+    def test_self_referential_foreign_key_ordering(self):\n+        OneModel = self.create_model(\n+            'OneModel',\n+            [\n+                ('root', models.ForeignKey('self', models.CASCADE, null=True)),\n+                ('oneval', models.BigIntegerField(null=True)),\n+            ],\n+            options={'ordering': ('-id',)}\n+        )\n+        TwoModel = self.create_model(\n+            'TwoModel',\n+            [\n+                ('record', models.ForeignKey(OneModel, models.CASCADE)),\n+                ('twoval', models.BigIntegerField(null=True)),\n+            ],\n+        )\n+        \n+        # Create instances of OneModel with self-referencing foreign keys\n+        root1 = OneModel.objects.create(oneval=1)\n+        root2 = OneModel.objects.create(oneval=2, root=root1)\n+        root3 = OneModel.objects.create(oneval=3, root=root2)\n+\n+        # Create instances of TwoModel with foreign keys pointing to OneModel\n+        two1 = TwoModel.objects.create(record=root1, twoval=1)\n+        two2 = TwoModel.objects.create(record=root2, twoval=2)\n+        two3 = TwoModel.objects.create(record=root3, twoval=3)\n+\n+        # This should result in a single join and should not be affected by OneModel's ordering\n+        qs = TwoModel.objects.filter(record__oneval__in=[1,2,3]).order_by('record__root_id')\n+        self.assertQuerysetEqual(qs, [two1, two2, two3], transform=lambda x: x)\n+\n+        # Test with inverted order\n+        qs_inverted = TwoModel.objects.filter(record__oneval__in=[1,2,3]).order_by('-record__root_id')\n+        self.assertQuerysetEqual(qs_inverted, [two3, two2, two1], transform=lambda x: x)\n+\n+        # Annotate and order to ensure correct behavior\n+        qs_annotate = TwoModel.objects.filter(record__oneval__in=[1,2,3]).annotate(\n+            root_id=models.F(\"record__root_id\")\n+        ).order_by('root_id')\n+        self.assertQuerysetEqual(qs_annotate, [two1, two2, two3], transform=lambda x: x)\n+\n     def test_order_by_f_expression(self):\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n",
  "django__django-13265": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..57070e3 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3202,7 +3202,23 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         self.assertEqual(form['field'].id_for_label, 'myCustomID')\n         self.assertEqual(form['field_none'].id_for_label, 'id_field_none')\n \n-    def test_boundfield_widget_type(self):\n+    def test_boundwidget_id_for_label_custom_id(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label correctly uses the id from\n+        self.data['attrs']['id'] if it exists.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(attrs={'id': 'custom_id'})\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+\n+        # Our interest is the id_for_label uses 'custom_id' instead of auto-generated id.\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_1')\n         class SomeForm(Form):\n             first_name = CharField()\n             birthday = SplitDateTimeField(widget=SplitHiddenDateTimeWidget)\n",
  "django__django-16400": "",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..519a4ef 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -640,6 +640,10 @@ def test_colorbar_format(fmt):\n             '$\\\\mathdefault{10^{-2}}$')\n \n \n+import matplotlib.pyplot as plt\n+import numpy as np\n+from matplotlib.colors import LogNorm, Normalize\n+\n def test_colorbar_scale_reset():\n     x, y = np.ogrid[-4:4:31j, -4:4:31j]\n     z = 120000*np.exp(-x**2 - y**2)\n@@ -658,7 +662,45 @@ def test_colorbar_scale_reset():\n     assert cbar.outline.get_edgecolor() == mcolors.to_rgba('red')\n \n \n-def test_colorbar_get_ticks_2():\n+def test_colorbar_norm_update():\n+    # Test updating a colorbar with LogNorm\n+    x, y = np.ogrid[-4:4:31j, -4:4:31j]\n+    data = np.exp(-(x**2 + y**2))\n+    \n+    fig, ax = plt.subplots()\n+    pcm = ax.pcolormesh(data, cmap='viridis')\n+    cbar = fig.colorbar(pcm, ax=ax)\n+\n+    # Set a new LogNorm and attempt to update the colorbar\n+    pcm.set_norm(LogNorm(vmin=data.min(), vmax=data.max()))\n+    try:\n+        cbar.update_normal(pcm)\n+        tick_labels = cbar.ax.yaxis.get_ticklabels()\n+        assert ('$\\\\mathdefault{1e-4}$' in [label.get_text() for label in tick_labels])\n+        print(\"test_colorbar_norm_update passed.\")\n+    except Exception as e:\n+        print(\"test_colorbar_norm_update failed:\", e)\n+\n+    plt.close(fig)\n+\n+def test_colorbar_update_bruteforce():\n+    # Test update_bruteforce method on the colorbar\n+    img = 10**np.random.normal(1, 1, size=(50, 50))\n+    fig, ax = plt.subplots(1, 1)\n+    plot = ax.imshow(img, cmap='gray')\n+    cb = fig.colorbar(plot, ax=ax)\n+\n+    plot.set_norm(LogNorm(vmin=img.min(), vmax=img.max()))\n+    \n+    try:\n+        cb.update_bruteforce(plot)\n+        tick_labels = cb.ax.yaxis.get_ticklabels()\n+        assert ('$\\\\mathdefault{1e1}$' in [label.get_text() for label in tick_labels])\n+        print(\"test_colorbar_update_bruteforce passed.\")\n+    except Exception as e:\n+        print(\"test_colorbar_update_bruteforce failed:\", e)\n+\n+    plt.close(fig)\n     plt.rcParams['_internal.classic_mode'] = False\n     fig, ax = plt.subplots()\n     pc = ax.pcolormesh([[.05, .95]])\n",
  "pydata__xarray-4094": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex a2826fa..1933c6d 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -3044,8 +3044,13 @@ class TestDataset:\n         x0 = y[0].to_unstacked_dataset(\"features\")\n         d0 = D.isel(x=0)\n         assert_identical(d0, x0)\n-\n-    def test_to_stacked_array_to_unstacked_dataset_different_dimension(self):\n+    def test_to_stacked_array_single_dim_variable(self):\n+        # single dimension: regression test for issue GH4049\n+        arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+        data = xr.Dataset({\"a\": arr, \"b\": arr})\n+        stacked = data.to_stacked_array(\"y\", sample_dims=[\"x\"])\n+        unstacked = stacked.to_unstacked_dataset(\"y\")\n+        assert_identical(unstacked, data)\n         # test when variables have different dimensionality\n         a, b = create_test_stacked_array()\n         sample_dims = [\"x\"]\n",
  "scikit-learn__scikit-learn-25747": "",
  "sphinx-doc__sphinx-8801": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 37d6e17..5962ef9 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -106,6 +106,67 @@ def test_inherited_instance_variable(app):\n     ]\n \n \n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+from test_ext_autodoc import do_autodoc  # Assuming do_autodoc is provided in some test module\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_superclass_attributes_with_annotation(app: SphinxTestApp):\n+    options = {\n+        \"members\": None,\n+        \"inherited-members\": True\n+    }\n+    actual = do_autodoc(app, 'class', 'target.example.Bar', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.example',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_superclass_undocumented_attributes(app: SphinxTestApp):\n+    options = {\n+        \"members\": None,\n+        \"inherited-members\": True,\n+        \"undoc-members\": True\n+    }\n+    actual = do_autodoc(app, 'class', 'target.example.Bar', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.example',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n def test_decorators(app):\n     actual = do_autodoc(app, 'class', 'target.decorator.Baz')\n     assert list(actual) == [\n",
  "sympy__sympy-15346": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex cce4836..e7c3763 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     symbols, sin, simplify, cos, trigsimp, rad, tan, exptrigsimp,sinh,\n     cosh, diff, cot, Subs, exp, tanh, exp, S, integrate, I,Matrix,\n@@ -357,8 +358,24 @@ def test_issue_2827_trigsimp_methods():\n     eq = 1/sqrt(E) + E\n     assert exptrigsimp(eq) == eq\n \n-\n-def test_exptrigsimp():\n+def test_issue_15129_trigsimp_methods():\n+    # Original test case from patch\n+    t1 = Matrix([sin(Rational(1, 50)), cos(Rational(1, 50)), 0])\n+    t2 = Matrix([sin(Rational(1, 25)), cos(Rational(1, 25)), 0])\n+    t3 = Matrix([cos(Rational(1, 25)), sin(Rational(1, 25)), 0])\n+    r1 = t1.dot(t2)\n+    r2 = t1.dot(t3)\n+    assert trigsimp(r1) == cos(S(1)/50)\n+    assert trigsimp(r2) == sin(S(3)/50)\n+    \n+    # Additional test cases to verify the fix thoroughly\n+    r = sin(Rational(1, 50)) * sin(Rational(1, 25)) + cos(Rational(1, 50)) * cos(Rational(1, 25))\n+    assert r.simplify() == cos(S(1)/50 - S(1)/25)\n+\n+    # Check acos outcome\n+    r_simplified = r.simplify()\n+    acos_val = acos(r_simplified)\n+    assert acos_val.simplify() == acos(cos(S(1)/50 - S(1)/25))\n     def valid(a, b):\n         from sympy.utilities.randtest import verify_numerically as tn\n         if not (tn(a, b) and a == b):\n",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..dbddc41 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4862,8 +4862,23 @@ k = \u2500\u2500\u2500\u2500\u2500                                \\n\\\n     assert pretty(expr) == ascii_str\n     assert upretty(expr) == ucode_str\n \n-\n-def test_units():\n+def test_sum_with_addition_alignment():\n+    from sympy import Sum, oo\n+    from sympy.abc import x\n+    \n+    expr = Sum(x, (x, 1, oo)) + 3\n+    ucode_str = \\\n+u(\"\"\"\\\n+  \u221e     \\n\\\n+ ___    \\n\\\n+ \u2572      \\n\\\n+  \u2572   x \\n\\\n+  \u2571     \\n\\\n+ \u2571     3\\n\\\n+ \u203e\u203e\u203e    \\n\\\n+x = 1   \\\n+\"\"\")\n+    assert upretty(expr) == ucode_str\n     expr = joule\n     ascii_str1 = \\\n \"\"\"\\\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex b2b6202..51bc844 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -692,7 +692,16 @@ def test_reshape():\n     raises(ValueError, lambda: reshape([0, 1], [-1]))\n     raises(ValueError, lambda: reshape([0, 1], [3]))\n \n-def test_uniq():\n+from sympy.utilities.iterables import uniq\n+from sympy.utilities.pytest import raises\n+\n+def test_uniq_modification():\n+    f = [1]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    f = [[1]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    f = list('THISTLE')\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n     assert list(uniq(p.copy() for p in partitions(4))) == \\\n         [{4: 1}, {1: 1, 3: 1}, {2: 2}, {1: 2, 2: 1}, {1: 4}]\n     assert list(uniq(x % 2 for x in range(5))) == [0, 1]\n",
  "django__django-11797": "",
  "django__django-15320": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 35f7f03..d393ecf 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -546,6 +546,45 @@ class BasicExpressionsTests(TestCase):\n         subquery_test2 = Company.objects.filter(pk=Subquery(small_companies.filter(num_employees=3)))\n         self.assertCountEqual(subquery_test2, [self.foobar_ltd])\n \n+    def test_subquery_sql(self):\n+        from django.db import connection\n+        employees = Employee.objects.all()\n+        \n+        # Test with subquery set to True\n+        employees_subquery = Subquery(employees)\n+        self.assertIs(employees_subquery.query.subquery, True)\n+        self.assertIs(employees.query.subquery, False)\n+        compiler = employees_subquery.query.get_compiler(connection=connection)\n+        sql, _ = employees_subquery.as_sql(compiler, connection)\n+        self.assertIn('(SELECT ', sql)\n+\n+        # Test without subquery set\n+        employees_query = employees.query\n+        subquery_without_setting = Subquery(employees_query)\n+        subquery_without_setting.query.subquery = False\n+        compiler = subquery_without_setting.query.get_compiler(connection=connection)\n+        sql_invalid, _ = subquery_without_setting.as_sql(compiler, connection)\n+        self.assertNotIn('(SELECT ', sql_invalid)\n+        self.assertNotIn('SELECT ', sql_invalid)\n+\n+    def test_subquery_with_changes(self):\n+        from django.db import connection\n+        # Test direct assignment of subquery flag\n+        projects = Project.objects.all()\n+        projects_subquery = Subquery(projects)\n+        projects_subquery.query.subquery = True\n+\n+        compiler = projects_subquery.query.get_compiler(connection=connection)\n+        sql_valid, _ = projects_subquery.as_sql(compiler, connection)\n+        self.assertIn('(SELECT ', sql_valid)\n+        \n+        # Create subquery without explicitly setting subquery\n+        projects_subquery_no_explicit = Subquery(projects)\n+        projects_subquery_no_explicit.query.subquery = False\n+        compiler_no_explicit = projects_subquery_no_explicit.query.get_compiler(connection=connection)\n+        sql_invalid_exp, _ = projects_subquery_no_explicit.as_sql(compiler_no_explicit, connection)\n+        self.assertNotIn('(SELECT ', sql_invalid_exp)\n+\n     def test_uuid_pk_subquery(self):\n         u = UUIDPK.objects.create()\n         UUID.objects.create(uuid_fk=u)\n",
  "django__django-15819": "",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..73550ac 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -152,6 +153,13 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n+    def test_wrong_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(PoolStyle.objects.annotate(\n+                tournament_pool=FilteredRelation('pool__tournament__pool'),\n+            ).select_related('tournament_pool'))\n+            self.assertEqual(p[0].pool.tournament, p[0].tournament_pool.tournament)\n+\n     def test_reverse_fk_select_related_multiple(self):\n         with self.assertNumQueries(1):\n             ps = list(\n@@ -163,4 +171,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "",
  "mwaskom__seaborn-2848": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 5a5e126..c7217c6 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -1,8 +1,11 @@\n+\n from itertools import product\n import numpy as np\n import matplotlib as mpl\n import matplotlib.pyplot as plt\n from matplotlib.colors import same_color, to_rgba\n+import seaborn as sns\n+from seaborn._oldcore import categorical_order\n \n import pytest\n from numpy.testing import assert_array_equal\n@@ -1623,6 +1626,20 @@ class TestScatterPlotter(SharedAxesLevelTests, Helpers):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n+    def test_pairgrid_scatterplot_with_categorical_hue(self):\n+        iris = sns.load_dataset(\"iris\")\n+        g = sns.PairGrid(iris, y_vars=[\"sepal_length\", \"sepal_width\"], x_vars=[\"petal_length\", \"petal_width\"])\n+        \n+        # Catch the exception to verify the issue\n+        try:\n+            g.map(sns.scatterplot, hue=iris[\"species\"])\n+            plt.close(g.fig)\n+            error_raised = False\n+        except TypeError as e:\n+            error_raised = True\n+        \n+        assert not error_raised, \"TypeError was raised when using categorical 'hue' in PairGrid map with scatterplot.\"\n+\n     def test_linewidths(self, long_df):\n \n         f, ax = plt.subplots()\n",
  "pytest-dev__pytest-5413": "diff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 226bfb9..460512e 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -347,6 +347,16 @@ def test_excinfo_str():\n     assert len(s.split(\":\")) >= 3  # on windows it's 4\n \n \n+def test_excinfo_str_on_exception_info():\n+    import pytest\n+\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\"A\\nB\\nC\")\n+\n+    # Ensure str() on the context variable excinfo behaves as expected\n+    assert str(excinfo) != str(excinfo.value)\n+    assert str(excinfo.value) == \"A\\nB\\nC\"\n+\n def test_excinfo_for_later():\n     e = ExceptionInfo.for_later()\n     assert \"for raises\" in repr(e)\n",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..74ff6fe 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -405,6 +405,11 @@ class TestCustomConftests:\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n \n+    def test_collect_only_shortcut(self, testdir):\n+        testdir.makepyfile(\"def test_example(): pass\")\n+        result = testdir.runpytest(\"-C\")\n+        result.stdout.fnmatch_lines([\"*test_example*\"])\n+        \n     def test_pytest_collect_file_from_sister_dir(self, testdir):\n         sub1 = testdir.mkpydir(\"sub1\")\n         sub2 = testdir.mkpydir(\"sub2\")\n",
  "sphinx-doc__sphinx-10451": "diff --git a/tests/roots/test-ext-autodoc/target/typehints.py b/tests/roots/test-ext-autodoc/target/typehints.py\nindex 100ea06..040ee79 100644\n--- a/tests/roots/test-ext-autodoc/target/typehints.py\n+++ b/tests/roots/test-ext-autodoc/target/typehints.py\n@@ -91,11 +91,20 @@ def missing_attr(c,\n     return a + (b or \"\")\n \n \n-class _ClassWithDocumentedInit:\n+class _ClassWithDocumentedInitAndStarArgs:\n+    \"\"\"Class docstring.\"\"\"\n+\n+    def __init__(self, x: int, *args: int, **kwargs: int) -> None:\n+        \"\"\"Init docstring.\n+\n+        :param x: Some integer\n+        :param *args: Some integer\n+        :param **kwargs: Some integer\n+        \"\"\"\n     \"\"\"Class docstring.\"\"\"\n \n     def __init__(self, x: int) -> None:\n         \"\"\"Init docstring.\n \n         :param x: Some integer\n-        \"\"\"\n+        \"\"\"\n",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..ec7b938 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -90,6 +90,21 @@ def test_Identity_doit():\n     assert Inn.doit() == Identity(2*n)\n     assert isinstance(Inn.doit().rows, Mul)\n \n+def test_sum_identity_elements():\n+    from sympy import MatrixSymbol, Identity, Sum, symbols, ask, Q\n+    n = symbols('n', integer=True, positive=True)\n+    i, j = symbols('i j', integer=True)\n+    M = MatrixSymbol('M', n, n)\n+    In = Identity(n)\n+\n+    with assuming(Q.orthogonal(M)):\n+        e = refine((M.T * M).doit())\n+\n+    # Check the sum of diagonal elements which should be 'n'\n+    assert Sum(e[i, i], (i, 0, n-1)).doit() == n\n+\n+    # Check the total sum of elements which should also be 'n'\n+    assert Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit() == n\n \n def test_addition():\n     A = MatrixSymbol('A', n, m)\n",
  "sympy__sympy-20049": "",
  "sympy__sympy-21612": "diff --git a/sympy/parsing/tests/test_latex.py b/sympy/parsing/tests/test_latex.py\nindex b252985..284f7b6 100644\n--- a/sympy/parsing/tests/test_latex.py\n+++ b/sympy/parsing/tests/test_latex.py\n@@ -246,6 +246,14 @@ GOOD_PAIRS = [\n ]\n \n \n+def test_fraction_parsing_issue():\n+    from sympy.parsing.latex import parse_latex\n+    # Test the problematic LaTeX expression reported in the issue\n+    expr = \"\\\\frac{\\\\frac{a^3+b}{c}}{\\\\frac{1}{c^2}}\"\n+    parsed_expr = parse_latex(expr)\n+    expected_expr = ((a**3 + b)/c)/(1/(c**2))\n+    assert parsed_expr == expected_expr, f\"Expected: {expected_expr}, but got: {parsed_expr}\"\n+\n def test_parseable():\n     from sympy.parsing.latex import parse_latex\n     for latex_str, sympy_expr in GOOD_PAIRS:\n"
}