{
  "astropy__astropy-12907": "",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..38e25c9 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,10 +1,54 @@\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n from io import StringIO\n \n from astropy.io import ascii\n+import numpy as np\n+import astropy.units as u\n+from astropy.table import QTable\n+from io import StringIO\n \n-from .common import assert_almost_equal, assert_equal\n+def test_rst_with_header_rows():\n+    \"\"\"Round-trip a table with header_rows specified\"\"\"\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct     \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\"\n+    ]\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"wave\"].dtype == np.float64\n+    assert tbl[\"response\"].dtype == np.float32\n+    assert tbl[\"ints\"].dtype == np.int8\n+\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert out.getvalue().splitlines() == lines\n+\n+def test_rst_with_invalid_header_rows():\n+    \"\"\"Test the behavior when invalid header_rows are provided\"\"\"\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct     \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\"\n+    ]\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    \n+    # Writing with unsupported header_rows should raise an error\n+    with pytest.raises(TypeError):\n+        tbl.write(sys.stdout, format=\"ascii.rst\", header_rows=[\"unknown\"])\n \n \n def assert_equal_splitlines(arg1, arg2):\n",
  "astropy__astropy-14365": "",
  "astropy__astropy-14995": "diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py\nindex fc27f69..e9e6f8c 100644\n--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py\n+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py\n@@ -28,7 +28,47 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n         return False\n \n \n-# Test with Data covers:\n+import numpy as np\n+import pytest\n+from astropy.nddata import NDDataRef\n+\n+def test_nddata_bitmask_arithmetic():\n+    # NDData.mask is usually assumed to be boolean, but could be\n+    # a bitmask. Ensure bitmask works:\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_masked = NDDataRef(array, mask=mask)\n+\n+    # multiply no mask by constant (no mask * no mask)\n+    assert nref_nomask.multiply(1.0, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply no mask by itself (no mask * no mask)\n+    assert nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply masked by constant (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(1.0, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by itself (mask * mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_masked, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by no mask (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_nomask, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # check bitwise logic still works\n+    other_mask = np.array([[64, 1, 0], [2, 1, 0], [8, 0, 2]])\n+    nref_mask_other = NDDataRef(array, mask=other_mask)\n+    np.testing.assert_equal(\n+        nref_mask_other.multiply(nref_masked, handle_mask=np.bitwise_or).mask,\n+        np.bitwise_or(mask, other_mask),\n+    )\n # scalars, 1D, 2D and 3D\n # broadcasting between them\n @pytest.mark.filterwarnings(\"ignore:divide by zero encountered.*\")\n",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..686c522 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -254,6 +254,33 @@ class TestTableFunctions(FitsTestCase):\n \n         t.close()\n \n+    def test_d_exponent_handling(self):\n+        \"\"\"\n+        Test that floats using 'D' as the exponent separator are correctly\n+        handled and written in the ASCII table representation.\n+        \"\"\"\n+        a = np.array([123.456, 789.012])\n+        columns = [\n+            fits.Column(name='col1', format='D20.9', array=a)\n+        ]\n+        hdu = fits.BinTableHDU.from_columns(columns)\n+        filename = self.temp('test_d_exponent_handling.fits')\n+        hdu.writeto(filename, overwrite=True)\n+\n+        # Read the written file and check if it correctly replaced 'E' with 'D'\n+        with open(filename, 'r') as f:\n+            file_contents = f.read()\n+            assert any('1.234560000D+02' in line for line in file_contents.splitlines())\n+            assert any('7.890120000D+02' in line for line in file_contents.splitlines())\n+\n+        # Also, open with fits to ensure data integrity\n+        with fits.open(filename) as hdul:\n+            assert comparerecords(hdu.data, hdul[1].data)\n+\n+        # Clean up\n+        if os.path.exists(filename):\n+            os.remove(filename)\n+\n     def test_ascii_table(self):\n         # ASCII table\n         a = fits.open(self.data('ascii.fits'))\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..41887f9 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1093,6 +1093,22 @@ class OverrideSettingsTests(SimpleTestCase):\n         with self.settings(MEDIA_URL='/test_value/'):\n             self.assertEqual(default_storage.base_url, '/test_value/')\n \n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        Test that the default FILE_UPLOAD_PERMISSIONS is set to 0o644.\n+        \"\"\"\n+        self.assertEqual(default_storage.file_permissions_mode, 0o644)\n+\n+    def test_temporary_file_upload_permissions(self):\n+        \"\"\"\n+        Test permissions of temporarily uploaded files.\n+        This test ensures the permissions are 0o644 regardless of the temporary file being used.\n+        \"\"\"\n+        with self.settings(FILE_UPLOAD_HANDLERS=[\n+            'django.core.files.uploadhandler.MemoryFileUploadHandler',\n+            'django.core.files.uploadhandler.TemporaryFileUploadHandler']):\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n+\n     def test_override_file_upload_permissions(self):\n         \"\"\"\n         Overriding the FILE_UPLOAD_PERMISSIONS setting should be reflected in\n",
  "django__django-10924": "",
  "django__django-11001": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 4e3940c..44d8480 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -384,6 +384,73 @@ class BasicExpressionsTests(TestCase):\n         )\n         self.assertSequenceEqual(mustermanns_by_seniority, [self.max, mary])\n \n+    def test_order_by_multiline_raw_sql(self):\n+        # Import necessary parts\n+        from django.db.models.expressions import RawSQL\n+        from .models import Company\n+\n+        # Setting up test objects, assuming `Company` model has these fields\n+        Company.objects.create(name=\"A\", num_employees=500, num_chairs=50)\n+        Company.objects.create(name=\"B\", num_employees=2000, num_chairs=10)\n+        Company.objects.create(name=\"C\", num_employees=1500, num_chairs=100)\n+\n+        # Define order_by clauses using multiline RawSQL\n+        raw_order_by = (\n+            RawSQL('''\n+                CASE WHEN num_employees > 1000\n+                     THEN num_chairs\n+                     ELSE 0 END\n+            ''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN num_chairs > 1\n+                     THEN 1\n+                     ELSE 0 END\n+            ''', []).asc()\n+        )\n+\n+        # Loop through different querysets to ensure correct ordering\n+        for qs in (\n+            Company.objects.all(),\n+            Company.objects.distinct(),\n+        ):\n+            with self.subTest(qs=qs):\n+                companies = list(qs.order_by(*raw_order_by))\n+                self.assertEqual(companies[0].name, \"A\")  # Check that 'A' is first\n+                self.assertEqual(companies[1].name, \"C\")  # Then 'C'\n+                self.assertEqual(companies[2].name, \"B\")  # Then 'B'\n+\n+    def test_order_by_multiline_sql_edge_case(self):\n+        from django.db.models.expressions import RawSQL\n+        from .models import Company\n+\n+        Company.objects.create(name=\"X\", num_employees=100, num_chairs=5)\n+        Company.objects.create(name=\"Y\", num_employees=1100, num_chairs=8)\n+        Company.objects.create(name=\"Z\", num_employees=1200, num_chairs=3)\n+\n+        # Multiline RawSQL with similar endings but different logic\n+        raw_order_by_edge_case = (\n+            RawSQL('''\n+                CASE WHEN num_employees > 1000\n+                     THEN num_chairs\n+                     ELSE 1 END\n+            ''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN num_employees <= 1000\n+                     THEN num_chairs\n+                     ELSE 0 END\n+            ''', []).asc()\n+        )\n+\n+        for qs in (\n+            Company.objects.all(),\n+            Company.objects.distinct(),\n+        ):\n+            with self.subTest(qs=qs):\n+                companies = list(qs.order_by(*raw_order_by_edge_case))\n+                self.assertEqual(companies[0].name, \"Z\")  # 'Z' with max employees/chairs\n+                self.assertEqual(companies[1].name, \"Y\")\n+                self.assertEqual(companies[2].name, \"X\")\n+    \n     def test_outerref(self):\n         inner = Company.objects.filter(point_of_contact=OuterRef('pk'))\n         msg = (\n",
  "django__django-11039": "",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..f1c82ab 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -75,7 +75,7 @@ class TestValidation(SimpleTestCase):\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n             \"'not a datetime' value has an invalid format. \"\n-            \"It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n         )\n \n \n@@ -84,4 +84,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..38c4498 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -238,6 +238,7 @@ class UsernameValidatorsTests(SimpleTestCase):\n             \"o'connell\", \"\u0639\u0628\u062f \u0627\u0644\",\n             \"zerowidth\\u200Bspace\", \"nonbreaking\\u00A0space\",\n             \"en\\u2013dash\",\n+            'trailingnewline\\n',\n         ]\n         v = validators.UnicodeUsernameValidator()\n         for valid in valid_usernames:\n@@ -251,11 +252,32 @@ class UsernameValidatorsTests(SimpleTestCase):\n     def test_ascii_validator(self):\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n         invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n-        v = validators.ASCIIUsernameValidator()\n+        v = validators.UnicodeUsernameValidator()\n         for valid in valid_usernames:\n             with self.subTest(valid=valid):\n                 v(valid)\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n+\n+    def test_ascii_validator_with_trailing_newline(self):\n+        valid_usernames = ['simpleuser', 'user123', 'user_99']\n+        invalid_usernames = [\n+            \"trailingnewline\\n\", \"space at end \",\n+            'trailingnewline\\n',\n+        ]\n+        for valid in valid_usernames:\n+            with self.subTest(valid=valid):\n+                v(valid)\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n+        for valid in valid_usernames:\n+            with self.subTest(valid=valid):\n+                v(valid)\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..79dc07c 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -363,6 +363,26 @@ class HttpResponseTests(unittest.TestCase):\n \n         # test content via property\n         r = HttpResponse()\n+\n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview'))\n+        self.assertEqual(r.content, b'memoryview')\n+\n+    def test_memoryview_content_with_property(self):\n+        r = HttpResponse()\n+        r.content = memoryview(b'propertyview')\n+        self.assertEqual(r.content, b'propertyview')\n+\n+    def test_memoryview_empty(self):\n+        r = HttpResponse(memoryview(b''))\n+        self.assertEqual(r.content, b'')\n+\n+    def test_memoryview_unicode(self):\n+        # Ensure the server can handle unicode through memoryview after encoding\n+        content = 'unicode content \u00e9\u00fc'\n+        encoded_content = content.encode('utf-8')\n+        r = HttpResponse(memoryview(encoded_content))\n+        self.assertEqual(r.content, encoded_content)\n         r.content = 12345\n         self.assertEqual(r.content, b'12345')\n \n@@ -372,10 +392,50 @@ class HttpResponseTests(unittest.TestCase):\n \n         # test iter content via property\n         r = HttpResponse()\n+\n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview'))\n+        self.assertEqual(r.content, b'memoryview')\n+\n+    def test_memoryview_content_with_property(self):\n+        r = HttpResponse()\n+        r.content = memoryview(b'propertyview')\n+        self.assertEqual(r.content, b'propertyview')\n+\n+    def test_memoryview_empty(self):\n+        r = HttpResponse(memoryview(b''))\n+        self.assertEqual(r.content, b'')\n+\n+    def test_memoryview_unicode(self):\n+        # Ensure the server can handle unicode through memoryview after encoding\n+        content = 'unicode content \u00e9\u00fc'\n+        encoded_content = content.encode('utf-8')\n+        r = HttpResponse(memoryview(encoded_content))\n+        self.assertEqual(r.content, encoded_content)\n         r.content = ['idan', 'alex', 'jacob']\n         self.assertEqual(r.content, b'idanalexjacob')\n \n         r = HttpResponse()\n+\n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview'))\n+        self.assertEqual(r.content, b'memoryview')\n+\n+    def test_memoryview_content_with_property(self):\n+        r = HttpResponse()\n+        r.content = memoryview(b'propertyview')\n+        self.assertEqual(r.content, b'propertyview')\n+\n+    def test_memoryview_empty(self):\n+        r = HttpResponse(memoryview(b''))\n+        self.assertEqual(r.content, b'')\n+\n+    def test_memoryview_unicode(self):\n+        # Ensure the server can handle unicode through memoryview after encoding\n+        content = 'unicode content \u00e9\u00fc'\n+        encoded_content = content.encode('utf-8')\n+        r = HttpResponse(memoryview(encoded_content))\n+        self.assertEqual(r.content, encoded_content)\n         r.content = [1, 2, 3]\n         self.assertEqual(r.content, b'123')\n \n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..0ba9f1e 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,3 +1,5 @@\n+\n+from django.db.models.deletion import Collector\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n@@ -464,7 +466,23 @@ class FastDeleteTests(TestCase):\n         # 1 to delete t, 1 to fast-delete t's m_set\n         self.assertNumQueries(2, f.delete)\n \n-    def test_fast_delete_qs(self):\n+    def test_fast_delete_instance_set_pk_none(self):\n+        u = User.objects.create()\n+        # User can be fast-deleted.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        u.delete()\n+        self.assertIsNone(u.pk)\n+\n+    def test_delete_instance_clears_pk(self):\n+        # Create a User instance\n+        u = User.objects.create()\n+        # Ensure that it has a valid primary key\n+        self.assertIsNotNone(u.pk)\n+        # Delete the instance\n+        u.delete()\n+        # Check that the primary key is set to None\n+        self.assertIsNone(u.pk)\n         u1 = User.objects.create()\n         u2 = User.objects.create()\n         self.assertNumQueries(1, User.objects.filter(pk=u1.pk).delete)\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..8724aad 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,9 +1,11 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n from django.contrib.auth.models import Permission, User\n from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n+from django.test.utils import captured_stdout\n \n from .models import Proxy, UserProxy\n \n@@ -140,7 +142,56 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n-    def test_user_keeps_same_permissions_after_migrating_backward(self):\n+    def test_migrate_with_existing_target_permission(self):\n+        \"\"\"\n+        Permissions may already exist:\n+\n+        - Old workaround was to manually create permissions for proxy models.\n+        - Model may have been concrete and then converted to proxy.\n+\n+        Output a reminder to audit relevant permissions.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='display_proxys',\n+            name='May display proxys information',\n+        )\n+        with captured_stdout() as stdout:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        self.assertIn('A problem arose migrating proxy model permissions', stdout.getvalue())\n+\n+    def test_duplicate_permissions_are_handled_gracefully(self):\n+        \"\"\"\n+        Verifies that duplicate permissions do not cause migrations to fail.\n+\n+        Simulates the scenario where permissions for proxy models may already exist,\n+        potentially causing an IntegrityError if not accounted for.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        # Attempt to create duplicates\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        with captured_stdout() as stdout:\n+            try:\n+                update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+                duplicate_issue_handled = True\n+            except IntegrityError:\n+                duplicate_issue_handled = False\n+        self.assertTrue(duplicate_issue_handled, 'Duplicate permissions should not cause IntegrityError.')\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n         user.user_permissions.add(self.custom_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..8ccc5ef 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -9,6 +9,7 @@ import time\n import types\n import weakref\n import zipfile\n+import shutil\n from importlib import import_module\n from pathlib import Path\n from unittest import mock, skip, skipIf\n@@ -133,7 +134,21 @@ class TestIterModulesAndFiles(SimpleTestCase):\n         self.assertEqual(autoreload.iter_modules_and_files((module,), frozenset()), frozenset())\n \n \n-class TestCommonRoots(SimpleTestCase):\n+class TestManagePyChanges(SimpleTestCase):\n+    def test_manage_py_modification_detected(self):\n+        \"\"\"\n+        Ensure that changes to manage.py are detected by the autoreloader.\n+        \"\"\"\n+        manage_py = self.temporary_file('manage.py')\n+        manage_py.write_text(\"print('Hello, world!')\")\n+\n+        with extend_sys_path(str(manage_py.parent)):\n+            self.import_and_cleanup('manage')\n+\n+        # Simulate file modification by writing again\n+        manage_py.write_text(\"print('Modified manage.py')\")\n+\n+        self.assertFileFound(manage_py.absolute())\n     def test_common_roots(self):\n         paths = (\n             Path('/first/second'),\n",
  "django__django-11583": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 99e5edd..de24e16 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -136,6 +136,33 @@ class TestIterModulesAndFiles(SimpleTestCase):\n         main_module = sys.modules['__main__']\n         self.assertFileFound(Path(main_module.__file__))\n \n+    def test_path_with_embedded_null_bytes(self):\n+        paths_with_null_bytes = [\n+            'embedded_null_byte\\x00.py',\n+            'di\\x00rectory/embedded_null_byte.py',\n+            '\\x00start_with_null.py',\n+            'directory_with_null/\\x00embedded.py',\n+        ]\n+        for path in paths_with_null_bytes:\n+            with self.subTest(path=path):\n+                self.assertEqual(\n+                    autoreload.iter_modules_and_files((), frozenset([path])),\n+                    frozenset(),\n+                )\n+\n+    def test_nonexistent_files(self):\n+        nonexistent_files = [\n+            'nonexistent_file1.py',\n+            'another_nonexistent_file.py',\n+            'yet_another_nonexistent.py'\n+        ]\n+        for path in nonexistent_files:\n+            with self.subTest(path=path):\n+                self.assertEqual(\n+                    autoreload.iter_modules_and_files((), frozenset([path])),\n+                    frozenset(),\n+                )\n+\n     def test_main_module_without_file_is_not_resolved(self):\n         fake_main = types.ModuleType('__main__')\n         self.assertEqual(autoreload.iter_modules_and_files((fake_main,), frozenset()), frozenset())\n",
  "django__django-11620": "",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..be79874 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -191,6 +191,43 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_longer_than_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('ABC', 'Too long'),\n+                    ('OK', 'Enough'),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_nested_choices_longer_than_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Group', [('OK', 'Good'), ('Longer', 'Nope')]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (6 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n     def test_iterable_of_iterable_choices(self):\n         class ThingItem:\n             def __init__(self, value, display):\n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..ab6f747 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -252,7 +252,21 @@ class WriterTests(SimpleTestCase):\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n \n-    def test_serialize_enums(self):\n+    def test_serialize_translated_enum(self):\n+        from django.utils.translation import gettext_lazy as _\n+\n+        class TranslatedEnum(enum.Enum):\n+            A = _('Translated A')\n+            B = _('Translated B')\n+\n+        field = models.CharField(\n+            default=TranslatedEnum.A,\n+            choices=[(tag.value, tag.name) for tag in TranslatedEnum],\n+        )\n+        serialized_field, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\"default=tests.migrations.test_writer.TranslatedEnum['A']\", serialized_field)\n+        self.assertIn(\"(\\'Translated A\\', \\'A\\')\", serialized_field)\n+        self.assertIn(\"(\\'Translated B\\', \\'B\\')\", serialized_field)\n         class TextEnum(enum.Enum):\n             A = 'a-value'\n             B = 'value-b'\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..ce9b34d 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,9 +1,11 @@\n+\n import unittest\n from datetime import datetime\n \n from django.test import SimpleTestCase, ignore_warnings\n from django.utils.datastructures import MultiValueDict\n from django.utils.deprecation import RemovedInDjango40Warning\n+from unittest import mock\n from django.utils.http import (\n     base36_to_int, escape_leading_slashes, http_date, int_to_base36,\n     is_safe_url, is_same_domain, parse_etags, parse_http_date, quote_etag,\n@@ -324,7 +326,25 @@ class HttpDateProcessingTests(unittest.TestCase):\n         parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n-    def test_parsing_year_less_than_70(self):\n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850_with_mocked_current_date(self, mocked_datetime):\n+        # Mock current datetime values to test the 50-year rule\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+\n+        # Test set - Each tuple contains (current datetime, rfc850 date string, expected datetime)\n+        tests = [\n+            (datetime(2019, 11, 6, 8, 49, 37), 'Tuesday, 31-Dec-69 08:49:37 GMT', datetime(1969, 12, 31, 8, 49, 37)),\n+            (datetime(2020, 11, 6, 8, 49, 37), 'Tuesday, 31-Dec-60 08:49:37 GMT', datetime(2060, 12, 31, 8, 49, 37)),\n+            (datetime(2048, 11, 6, 8, 49, 37), 'Sunday, 31-Dec-00 08:49:37 GMT', datetime(2000, 12, 31, 8, 49, 37)),\n+            (datetime(2048, 11, 6, 8, 49, 37), 'Friday, 31-Dec-99 08:49:37 GMT', datetime(1999, 12, 31, 8, 49, 37)),\n+        ]\n+\n+        for current_datetime, rfc850_date, expected_date in tests:\n+            with self.subTest(rfc850_date=rfc850_date):\n+                mocked_datetime.utcnow.return_value = current_datetime\n+                parsed = parse_http_date(rfc850_date)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n         parsed = parse_http_date('Sun Nov  6 08:49:37 0037')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2037, 11, 6, 8, 49, 37))\n \n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..cce2ffa 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -39,8 +39,18 @@ class Gender(models.TextChoices):\n \n     __empty__ = '(Undeclared)'\n \n+from django.test import SimpleTestCase\n \n class ChoicesTests(SimpleTestCase):\n+    def test_enum_field_type(self):\n+        for test in [Gender, Suit, YearInSchool, Vehicle]:\n+            for member in test:\n+                with self.subTest(member=member):\n+                    # Check that the type of the enum value is str for TextChoices, int for IntegerChoices\n+                    if isinstance(member, models.TextChoices):\n+                        self.assertIsInstance(member.value, str)\n+                    elif isinstance(member, models.IntegerChoices):\n+                        self.assertIsInstance(member.value, int)\n     def test_integerchoices(self):\n         self.assertEqual(Suit.choices, [(1, 'Diamond'), (2, 'Spade'), (3, 'Heart'), (4, 'Club')])\n         self.assertEqual(Suit.labels, ['Diamond', 'Spade', 'Heart', 'Club'])\n",
  "django__django-11999": "",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "diff --git a/tests/urlpatterns/path_urls.py b/tests/urlpatterns/path_urls.py\nindex 12487f2..ee3fb2f 100644\n--- a/tests/urlpatterns/path_urls.py\n+++ b/tests/urlpatterns/path_urls.py\n@@ -2,6 +2,15 @@ from django.urls import include, path, re_path\n \n from . import views\n \n+from django.urls import re_path\n+from . import views\n+\n+...\n+\n+urlpatterns += [\n+    re_path(r'^module/(?P<format>(html|json|xml))?/?$', views.modules, name='modules'),\n+]\n+\n urlpatterns = [\n     path('articles/2003/', views.empty_view, name='articles-2003'),\n     path('articles/<int:year>/', views.empty_view, name='articles-year'),\n@@ -14,4 +23,4 @@ urlpatterns = [\n     re_path(r'^regex_optional/(?P<arg1>\\d+)/(?:(?P<arg2>\\d+)/)?', views.empty_view, name='regex_optional'),\n     path('', include('urlpatterns.more_urls')),\n     path('<lang>/<path:url>/', views.empty_view, name='lang-and-path'),\n-]\n+]\n",
  "django__django-12284": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex 7dc81d2..02b346a 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -1,3 +1,4 @@\n+\n import pickle\n \n from django import forms\n@@ -147,9 +148,43 @@ class ChoicesTests(SimpleTestCase):\n             with self.subTest(field=field):\n                 self.assertIsInstance(field.formfield(), forms.ChoiceField)\n \n+from django.db import models\n \n class GetFieldDisplayTests(SimpleTestCase):\n \n+    def test_overriding_inherited_FIELD_display(self):\n+        class Base(models.Model):\n+            foo = models.CharField(max_length=254, choices=[('A', 'Base A')])\n+\n+            class Meta:\n+                abstract = True\n+\n+        class Child(Base):\n+            foo = models.CharField(max_length=254, choices=[('A', 'Child A'), ('B', 'Child B')])\n+\n+        self.assertEqual(Child(foo='A').get_foo_display(), 'Child A')\n+        self.assertEqual(Child(foo='B').get_foo_display(), 'Child B')\n+\n+    def test_inherited_choices_with_additional_value(self):\n+        class AbstractModel(models.Model):\n+            foo_choice = [('A', 'output1'), ('B', 'output2')]\n+            field_foo = models.CharField(max_length=254, choices=foo_choice)\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritedModel(AbstractModel):\n+            foo_choice = [('A', 'output1'), ('B', 'output2'), ('C', 'output3')]\n+            field_foo = models.CharField(max_length=254, choices=foo_choice)\n+\n+        obj_a = InheritedModel(field_foo='A')\n+        obj_b = InheritedModel(field_foo='B')\n+        obj_c = InheritedModel(field_foo='C')\n+\n+        self.assertEqual(obj_a.get_field_foo_display(), 'output1')\n+        self.assertEqual(obj_b.get_field_foo_display(), 'output2')\n+        self.assertEqual(obj_c.get_field_foo_display(), 'output3')\n+\n     def test_choices_and_field_display(self):\n         \"\"\"\n         get_choices() interacts with get_FIELD_display() to return the expected\n",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..52dcf73 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,9 +1,10 @@\n+\n from django.core.checks import Error\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n     check_setting_languages, check_setting_languages_bidi,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, override_settings\n \n \n class TranslationCheckTests(SimpleTestCase):\n",
  "django__django-12308": "",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..38e7c50 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from unittest import mock\n \n@@ -5,7 +6,8 @@ from django.db import DEFAULT_DB_ALIAS, connection, connections\n from django.db.backends.base.creation import (\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, TestCase\n+from ..models import Object, ObjectReference\n \n \n def get_connection_copy():\n@@ -18,6 +20,76 @@ def get_connection_copy():\n     return test_connection\n \n \n+class TestDeserializeDbFromString(TestCase):\n+    databases = {'default'}\n+\n+    def test_circular_reference(self):\n+        # deserialize_db_from_string() handles circular references.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj_ref\": 1, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get()\n+        obj_ref = ObjectReference.objects.get()\n+        self.assertEqual(obj.obj_ref, obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n+\n+    def test_foreign_key_handling_order(self):\n+        # Test data for foreign key references.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 2,\n+                \"fields\": {\"obj\": 2}\n+            },\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 2,\n+                \"fields\": {\"obj_ref\": null, \"related_objects\": []}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get(pk=2)\n+        obj_ref = ObjectReference.objects.get(pk=2)\n+        # Check ForeignKey relation is set properly\n+        self.assertIsNone(obj.obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n+\n+    def test_atomic_transaction_wrapper(self):\n+        # Simulate failure in the middle of deserialization\n+        faulty_data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 3,\n+                \"fields\": {\"obj_ref\": null, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 3,\n+                \"fields\": {\"obj\": \"invalid\"}\n+            }\n+        ]\n+        \"\"\"\n+        with self.assertRaises(Exception):\n+            connection.creation.deserialize_db_from_string(faulty_data)\n+        # Ensure no objects are saved due to atomic rollback\n+        self.assertFalse(Object.objects.filter(pk=3).exists())\n+        self.assertFalse(ObjectReference.objects.filter(pk=3).exists())\n+\n class TestDbSignatureTests(SimpleTestCase):\n     def test_default_name(self):\n         # A test db name isn't set.\n",
  "django__django-12497": "diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 057ec3a..42479e7 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -158,8 +158,63 @@ class RelativeFieldTests(SimpleTestCase):\n                 id='fields.E335',\n             ),\n         ])\n+    def test_correct_hint_for_recursive_m2m_relationship(self):\n+        class Person(models.Model):\n+            pass\n+\n+        class Group(models.Model):\n+            members = models.ManyToManyField('self', through='AmbiguousRelationship')\n+\n+        class AmbiguousRelationship(models.Model):\n+            group = models.ForeignKey(Group, models.CASCADE, related_name='related_group1')\n+            related_group2 = models.ForeignKey(Group, models.CASCADE, related_name='related_group2')\n+\n+        field = Group._meta.get_field('members')\n+        self.assertEqual(field.check(from_model=Group), [\n+            Error(\n+                \"The model is used as an intermediate model by \"\n+                \"'invalid_models_tests.Group.members', but it has more than one \"\n+                \"foreign key from 'Group', which is ambiguous. You must \"\n+                \"specify which foreign key Django should use via the \"\n+                \"through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"AmbiguousRelationship\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n \n-    def test_relationship_model_with_foreign_key_to_wrong_model(self):\n+    def test_custom_message_for_too_many_foreign_keys(self):\n+        class Person(models.Model):\n+            pass\n+\n+        class Group(models.Model):\n+            field = models.ManyToManyField('Person', through=\"InvalidRelationship\")\n+\n+        class InvalidRelationship(models.Model):\n+            person = models.ForeignKey(Person, models.CASCADE)\n+            first_group = models.ForeignKey(Group, models.CASCADE, related_name='group1')\n+            second_group = models.ForeignKey(Group, models.CASCADE, related_name='group2')\n+            third_group = models.ForeignKey(Group, models.CASCADE, related_name='group3')\n+\n+        field = Group._meta.get_field('field')\n+        self.assertEqual(field.check(from_model=Group), [\n+            Error(\n+                \"The model is used as an intermediate model by \"\n+                \"'invalid_models_tests.Group.field', but it has more than two \"\n+                \"foreign keys from 'Group', which is ambiguous. You must \"\n+                \"specify which foreign key Django should use via the \"\n+                \"through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"InvalidRelationship\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n         class WrongModel(models.Model):\n             pass\n \n",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..a0de5c4 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1240,14 +1240,47 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleanse_setting('password', 'super_secret'),\n             reporter_filter.cleansed_substitute,\n         )\n+    def test_cleanse_setting_recurses_in_lists_and_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            \"nested_list\": [\n+                {\"password\": \"secret\"},\n+                [\"foo\", {\"token\": \"abc123\"}, (\"bar\", {\"token\": \"secret\"})]\n+            ],\n+            \"nested_tuple\": (\n+                {\"key\": \"value\", \"SECRET\": \"shhh\"},\n+                [\"another\", {\"api_key\": \"def456\"}]\n+            ),\n+        }\n+\n+        expected = {\n+            \"nested_list\": [\n+                {\"password\": reporter_filter.cleansed_substitute},\n+                [\"foo\", {\"token\": reporter_filter.cleansed_substitute}, (\"bar\", {\"token\": reporter_filter.cleansed_substitute})]\n+            ],\n+            \"nested_tuple\": (\n+                {\"key\": \"value\", \"SECRET\": reporter_filter.cleansed_substitute},\n+                [\"another\", {\"api_key\": reporter_filter.cleansed_substitute}]\n+            ),\n+        }\n \n-    def test_cleanse_setting_recurses_in_dictionary(self):\n+        self.assertEqual(reporter_filter.cleanse_setting('TEST_SETTINGS', initial), expected)\n+\n+    def test_cleanse_setting_mixed_iterables(self):\n         reporter_filter = SafeExceptionReporterFilter()\n-        initial = {'login': 'cooper', 'password': 'secret'}\n-        self.assertEqual(\n-            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n-            {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n-        )\n+        initial = {\n+            \"items\": [\n+                (\"user\", {\"password\": \"unsafe\"}),\n+                [{\"token\": \"unsafe\"}]\n+            ]\n+        }\n+        expected = {\n+            \"items\": [\n+                (\"user\", {\"password\": reporter_filter.cleansed_substitute}),\n+                [{\"token\": reporter_filter.cleansed_substitute}]\n+            ]\n+        }\n+        self.assertEqual(reporter_filter.cleanse_setting('MIXED_SETTING', initial), expected)\n \n     def test_request_meta_filtering(self):\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n",
  "django__django-12708": "",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..1440275 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -697,7 +697,25 @@ class FastDeleteTests(TestCase):\n                 (0, {'delete.User': 0})\n             )\n \n-    def test_fast_delete_combined_relationships(self):\n+    def test_zero_delete_no_foreign_key(self):\n+        \"\"\"\n+        Test that deleting a model with no foreign keys returns a consistent result\n+        when no objects are deleted.\n+        \"\"\"\n+        # Assume BlockLibrary is a simple model with no foreign keys\n+        deleted, deleted_objs = BlockLibrary.objects.filter(name='missing').delete()\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {'my_app.BlockLibrary': 0})\n+\n+    def test_zero_delete_with_foreign_key(self):\n+        \"\"\"\n+        Test that deleting a model with foreign keys returns a consistent result\n+        when no objects are deleted.\n+        \"\"\"\n+        # Assume File is a model with a foreign key relation\n+        deleted, deleted_objs = File.objects.filter(name='missing').delete()\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {'my_app.File': 0})\n         # The cascading fast-delete of SecondReferrer should be combined\n         # in a single DELETE WHERE referrer_id OR unique_field.\n         origin = Origin.objects.create()\n",
  "django__django-12856": "",
  "django__django-12915": "",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..7106aab 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -197,6 +197,17 @@ class TestUtilsText(SimpleTestCase):\n             ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True),\n             ('\u4f60\u597d', '\u4f60\u597d', True),\n             ('\u0130stanbul', 'istanbul', True),\n+            # Test cases for the issue of stripping dashes and underscores\n+            ('___This is a test ---', 'this-is-a-test', False),\n+            ('__strip__underscore-value___', 'strip-underscore-value', False),\n+            ('--strip-dash-value---', 'strip-dash-value', False),\n+            ('__strip-mixed-value---', 'strip-mixed-value', False),\n+            ('_ -strip-mixed-value _-', 'strip-mixed-value', False),\n+            # Additional test cases\n+            ('---leading-dashes', 'leading-dashes', False),\n+            ('trailing-dashes---', 'trailing-dashes', False),\n+            ('_-both-sides-_', 'both-sides', False),\n+            ('mixed-___---characters---_', 'mixed-characters', False),\n         )\n         for value, output, is_unicode in items:\n             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n",
  "django__django-13028": "",
  "django__django-13158": "",
  "django__django-13230": "",
  "django__django-13315": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 64b15bf..4925ee4 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2829,6 +2829,45 @@ class LimitChoicesToTests(TestCase):\n             StumpJokeForm()\n             self.assertEqual(today_callable_dict.call_count, 3)\n \n+class DuplicateLimitChoicesToTests(TestCase):\n+    \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.threepwood = Character.objects.create(username='Threepwood', last_action='2021-12-01T12:00:00Z')\n+        cls.marley = Character.objects.create(username='Marley', last_action='2021-12-01T13:00:00Z')\n+        \n+        cls.joke1 = StumpJoke.objects.create(most_recently_fooled=cls.threepwood)\n+        cls.joke2 = StumpJoke.objects.create(most_recently_fooled=cls.marley)\n+\n+        cls.joke1.has_fooled_today.add(cls.threepwood, cls.marley)\n+        cls.joke2.has_fooled_today.add(cls.marley)\n+\n+    def test_no_duplicate_limit_choices(self):\n+        \"\"\"Ensure there are no duplicate entries in form fields using limit_choices_to with Q objects.\"\"\"\n+        \n+        class CharacterDetailsForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetails\n+                fields = '__all__'\n+        \n+        form = CharacterDetailsForm()\n+        self.assertCountEqual(\n+            form.fields['character1'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character2'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character3'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+\n+\n+from django import forms\n+from django.test import TestCase\n+from .models import Character, StumpJoke\n \n class FormFieldCallbackTests(SimpleTestCase):\n \n",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 536c423..3f2b2e2 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -2,6 +2,8 @@ from django.contrib.contenttypes.fields import (\n     GenericForeignKey, GenericRelation,\n )\n from django.contrib.contenttypes.models import ContentType\n+from django.db import models\n+from django.test import SimpleTestCase\n from django.core.checks import Error\n from django.core.exceptions import FieldDoesNotExist, FieldError\n from django.db import models\n@@ -11,6 +13,36 @@ from django.test.utils import isolate_apps\n \n @isolate_apps('model_inheritance')\n class AbstractInheritanceTests(SimpleTestCase):\n+    def test_abstract_inherited_fields(self):\n+        \"\"\"Field instances from abstract models should not be equal.\"\"\"\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritAbstractModel1(AbstractModel):\n+            pass\n+\n+        class InheritAbstractModel2(AbstractModel):\n+            pass\n+\n+        abstract_model_field = AbstractModel._meta.get_field('field')\n+        inherit1_model_field = InheritAbstractModel1._meta.get_field('field')\n+        inherit2_model_field = InheritAbstractModel2._meta.get_field('field')\n+\n+        self.assertNotEqual(abstract_model_field, inherit1_model_field)\n+        self.assertNotEqual(abstract_model_field, inherit2_model_field)\n+        self.assertNotEqual(inherit1_model_field, inherit2_model_field)\n+\n+        self.assertLess(abstract_model_field, inherit1_model_field)\n+        self.assertLess(abstract_model_field, inherit2_model_field)\n+        self.assertLess(inherit1_model_field, inherit2_model_field)\n+\n+        self.assertNotEqual(hash(abstract_model_field), hash(inherit1_model_field))\n+        self.assertNotEqual(hash(abstract_model_field), hash(inherit2_model_field))\n+        self.assertNotEqual(hash(inherit1_model_field), hash(inherit2_model_field))\n+\n     def test_single_parent(self):\n         class AbstractBase(models.Model):\n             name = models.CharField(max_length=30)\n@@ -347,4 +379,4 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('age', models.SmallIntegerField), ('concretemodel2_ptr', models.OneToOneField),\n                 ('name', models.CharField),\n             ]\n-        )\n+        )\n",
  "django__django-13447": "diff --git a/tests/admin_views/test_adminsite.py b/tests/admin_views/test_adminsite.py\nindex 16a02bb..d6d3eee 100644\n--- a/tests/admin_views/test_adminsite.py\n+++ b/tests/admin_views/test_adminsite.py\n@@ -45,6 +45,16 @@ class SiteEachContextTest(TestCase):\n         request.user = self.u1\n         self.assertEqual(site.each_context(request)['site_url'], '/my-script-name/')\n \n+    def test_model_class_in_app_list(self):\n+        ctx = self.ctx\n+        apps = ctx['available_apps']\n+        \n+        # Ensure each app's models list includes the model class itself\n+        for app in apps:\n+            for model_dict in app['models']:\n+                model_class = model_dict.get('model')\n+                self.assertIsNotNone(model_class, f\"Model class should be present in {model_dict['object_name']}\")\n+\n     def test_available_apps(self):\n         ctx = self.ctx\n         apps = ctx['available_apps']\n",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..3b764b7 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,7 +1,9 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n from django.contrib.auth.models import User\n+from .models import CustomEmailField\n from django.contrib.auth.tokens import PasswordResetTokenGenerator\n from django.test import TestCase\n from django.test.utils import ignore_warnings\n@@ -19,6 +21,27 @@ class MockedPasswordResetTokenGenerator(PasswordResetTokenGenerator):\n \n class TokenGeneratorTest(TestCase):\n \n+    def test_token_with_different_email(self):\n+        \"\"\"Updating the user email address invalidates the token.\"\"\"\n+        tests = [\n+            (CustomEmailField, None),\n+            (CustomEmailField, 'test4@example.com'),\n+            (User, 'test4@example.com'),\n+        ]\n+        for model, email in tests:\n+            with self.subTest(model=model.__qualname__, email=email):\n+                user = model.objects.create_user(\n+                    'changeemailuser',\n+                    email=email,\n+                    password='testpw',\n+                )\n+                p0 = PasswordResetTokenGenerator()\n+                tk1 = p0.make_token(user)\n+                self.assertIs(p0.check_token(user, tk1), True)\n+                setattr(user, user.get_email_field_name(), 'test4new@example.com')\n+                user.save()\n+                self.assertIs(p0.check_token(user, tk1), False)\n+\n     def test_make_token(self):\n         user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')\n         p0 = PasswordResetTokenGenerator()\n",
  "django__django-13590": "",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..5cb56f1 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -23,6 +23,8 @@ from django.core.management.commands.loaddata import Command as LoaddataCommand\n from django.core.management.commands.runserver import (\n     Command as RunserverCommand,\n )\n+from unittest import mock\n+from django.core.management import execute_from_command_line\n from django.core.management.commands.testserver import (\n     Command as TestserverCommand,\n )\n@@ -38,7 +40,34 @@ SYSTEM_CHECK_MSG = 'System check identified no issues'\n \n \n class AdminScriptTestCase(SimpleTestCase):\n-    def setUp(self):\n+    def test_empty_argv(self):\n+        \"\"\"Test with an empty argv list.\"\"\"\n+        args = []\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line([])\n+        self.assertIn('usage:', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_custom_prog_name(self):\n+        \"\"\"Test that a custom program name is used instead of sys.argv[0].\"\"\"\n+        custom_name = \"custom-admin\"\n+        args = ['help']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line([custom_name] + args)\n+        self.assertIn(f'usage: {custom_name} help', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_invalid_prog_name(self):\n+        \"\"\"Test behavior when sys.argv[0] is None and a valid argv is provided.\"\"\"\n+        args = ['help']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line(['django-admin'] + args)\n+        # Ensure the usage message uses 'django-admin'\n+        self.assertIn('usage: django-admin help', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n         tmpdir = tempfile.TemporaryDirectory()\n         self.addCleanup(tmpdir.cleanup)\n         # os.path.realpath() is required for temporary directories on macOS,\n",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..04c9a56 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,3 +1,4 @@\n+\n import sys\n import unittest\n from unittest import mock\n@@ -6,10 +7,50 @@ from django import __version__\n from django.core.management import CommandError, call_command\n from django.test import SimpleTestCase\n from django.test.utils import captured_stdin, captured_stdout\n-\n+script_globals = 'print(\"__name__\" in globals())'\n+script_with_inline_function = (\n+    'import django\\n'\n+    'def f():\\n'\n+    '    print(django.__version__)\\n'\n+    'f()'\n+)\n \n class ShellCommandTestCase(SimpleTestCase):\n \n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n     def test_command_option(self):\n         with self.assertLogs('test', 'INFO') as cm:\n             call_command(\n@@ -49,4 +90,4 @@ class ShellCommandTestCase(SimpleTestCase):\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 2d83d62..855710e 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -962,6 +962,46 @@ class TestReadOnlyChangeViewInlinePermissions(TestCase):\n         response = self.client.get(self.change_url)\n         self.assertNotContains(response, 'id=\"id_question_set-0-text\"')\n \n+    def test_verbose_name_default_to_plural(self):\n+        class DefaultVerboseNameProfileInline(TabularInline):\n+            model = Profile\n+            verbose_name = 'Child'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [DefaultVerboseNameProfileInline]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Expecting 'Childs' as plural\n+        self.assertContains(response, '<h2>Childs</h2>')\n+        self.assertContains(response, 'Add another Child')\n+\n+    def test_verbose_name_no_plural_and_no_meta(self):\n+        class NoMetaProfileInline(TabularInline):\n+            model = VerboseNameProfile\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [NoMetaProfileInline]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Expect model name or verbose_name as plural by default\n+        self.assertContains(response, '<h2>VerbosesNameProfiles</h2>')\n+        self.assertContains(response, 'Add another VerboseNameProfile')\n+from django.urls import reverse\n+from django.test import RequestFactory, TestCase\n+from django.contrib.admin.sites import site as admin_site\n+from django.contrib.admin.options import ModelAdmin, TabularInline\n+from .models import Profile, VerboseNameProfile, VerboseNamePluralProfile, BothVerboseNameProfile, ProfileCollection\n+from django.contrib.auth.models import User \n+from django.test import override_settings\n+from .models import TestDataMixin\n \n @override_settings(ROOT_URLCONF='admin_inlines.urls')\n class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n@@ -1071,6 +1111,46 @@ class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n         self.assertNotContains(response, '<h2>Model with both - plural name</h2>')\n         self.assertNotContains(response, 'Add another Model with both - name')\n \n+    def test_verbose_name_default_to_plural(self):\n+        class DefaultVerboseNameProfileInline(TabularInline):\n+            model = Profile\n+            verbose_name = 'Child'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [DefaultVerboseNameProfileInline]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Expecting 'Childs' as plural\n+        self.assertContains(response, '<h2>Childs</h2>')\n+        self.assertContains(response, 'Add another Child')\n+\n+    def test_verbose_name_no_plural_and_no_meta(self):\n+        class NoMetaProfileInline(TabularInline):\n+            model = VerboseNameProfile\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [NoMetaProfileInline]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Expect model name or verbose_name as plural by default\n+        self.assertContains(response, '<h2>VerbosesNameProfiles</h2>')\n+        self.assertContains(response, 'Add another VerboseNameProfile')\n+from django.urls import reverse\n+from django.test import RequestFactory, TestCase\n+from django.contrib.admin.sites import site as admin_site\n+from django.contrib.admin.options import ModelAdmin, TabularInline\n+from .models import Profile, VerboseNameProfile, VerboseNamePluralProfile, BothVerboseNameProfile, ProfileCollection\n+from django.contrib.auth.models import User \n+from django.test import override_settings\n+from .models import TestDataMixin\n \n @override_settings(ROOT_URLCONF='admin_inlines.urls')\n class SeleniumTests(AdminSeleniumTestCase):\n",
  "django__django-13757": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex f53ff8c..ceb1c35 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -595,7 +595,12 @@ class TestQuerying(TestCase):\n             [self.objs[4]],\n         )\n \n-    def test_isnull_key_or_none(self):\n+    def test_keytransform_isnull_true(self):\n+        # This test will ensure that using __isnull=True on a KeyTransform does not match JSON null on SQLite and Oracle\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],\n+        )\n         obj = NullableJSONModel.objects.create(value={'a': None})\n         self.assertSequenceEqual(\n             NullableJSONModel.objects.filter(Q(value__a__isnull=True) | Q(value__a=None)),\n",
  "django__django-13768": "diff --git a/tests/dispatch/tests.py b/tests/dispatch/tests.py\nindex b1feefd..9f393c9 100644\n--- a/tests/dispatch/tests.py\n+++ b/tests/dispatch/tests.py\n@@ -152,11 +152,51 @@ class DispatcherTests(SimpleTestCase):\n \n     def test_send_robust_no_receivers(self):\n         result = a_signal.send_robust(sender=self, val='test')\n+\n+    def test_send_robust_logging_on_exception(self):\n+        def fails(val, **kwargs):\n+            raise ValueError('this logging test')\n+        a_signal.connect(fails)\n+        try:\n+            with self.assertLogs('django.dispatch', 'ERROR') as cm:\n+                result = a_signal.send_robust(sender=self, val='test')\n+            err = result[0][1]\n+            self.assertIsInstance(err, ValueError)\n+            self.assertEqual(err.args, ('this logging test',))\n+            log_record = cm.records[0]\n+            self.assertIn('Error calling', log_record.getMessage())\n+            self.assertIn('send_robust', log_record.getMessage())\n+            self.assertIsNotNone(log_record.exc_info)\n+            _, exc_value, _ = log_record.exc_info\n+            self.assertIsInstance(exc_value, ValueError)\n+            self.assertEqual(str(exc_value), 'this logging test')\n+        finally:\n+            a_signal.disconnect(fails)\n         self.assertEqual(result, [])\n \n     def test_send_robust_ignored_sender(self):\n         a_signal.connect(receiver_1_arg)\n         result = a_signal.send_robust(sender=self, val='test')\n+\n+    def test_send_robust_logging_on_exception(self):\n+        def fails(val, **kwargs):\n+            raise ValueError('this logging test')\n+        a_signal.connect(fails)\n+        try:\n+            with self.assertLogs('django.dispatch', 'ERROR') as cm:\n+                result = a_signal.send_robust(sender=self, val='test')\n+            err = result[0][1]\n+            self.assertIsInstance(err, ValueError)\n+            self.assertEqual(err.args, ('this logging test',))\n+            log_record = cm.records[0]\n+            self.assertIn('Error calling', log_record.getMessage())\n+            self.assertIn('send_robust', log_record.getMessage())\n+            self.assertIsNotNone(log_record.exc_info)\n+            _, exc_value, _ = log_record.exc_info\n+            self.assertIsInstance(exc_value, ValueError)\n+            self.assertEqual(str(exc_value), 'this logging test')\n+        finally:\n+            a_signal.disconnect(fails)\n         self.assertEqual(result, [(receiver_1_arg, 'test')])\n         a_signal.disconnect(receiver_1_arg)\n         self.assertTestIsClean(a_signal)\n",
  "django__django-13925": "",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..947339e 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -298,6 +298,19 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['INVALID CHOICE'], f.clean, '4')\n \n+        # Additional test for ModelChoiceField to ensure invalid choice value is shown\n+        f = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not among available choices.',\n+            }\n+        )\n+        self.assertFormErrors(\n+            ['\"invalid\" is not among available choices.'],\n+            f.clean,\n+            'invalid'\n+        )\n+\n         # ModelMultipleChoiceField\n         e = {\n             'required': 'REQUIRED',\n@@ -307,4 +320,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "diff --git a/tests/many_to_one/tests.py b/tests/many_to_one/tests.py\nindex 8af1b8e..31cf305 100644\n--- a/tests/many_to_one/tests.py\n+++ b/tests/many_to_one/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n from copy import deepcopy\n \n@@ -12,8 +13,53 @@ from .models import (\n     ToFieldChild,\n )\n \n+from .models import ParentStringPrimaryKey, ChildStringPrimaryKeyParent\n \n class ManyToOneTests(TestCase):\n+\n+    def test_save_fk_after_parent_with_non_numeric_pk_set_on_child_missing_initial_pk(self):\n+        # This test reproduces the issue where setting a parent's PK on a child leads to data loss\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey()  # empty PK initially\n+            child = ChildStringPrimaryKeyParent(parent=parent)\n+            child.parent.name = 'jeff'  # set PK\n+            parent.save()\n+            child.save()  # At this point, the chance of failing due to PK not set properly\n+            child.refresh_from_db()\n+            self.assertEqual(child.parent, parent)\n+            self.assertEqual(child.parent_id, parent.name)\n+        \n+        # Additional validation to ensure no orphan reference is left \n+        with self.assertRaises(IntegrityError):\n+            Order.objects.create(product=Product(sku='unknown'))\n+\n+    def test_save_fk_after_parent_with_non_numeric_pk_set_on_child_with_initial_pk(self):\n+        # This test verifies the correct behavior when PK is already set before assignment\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey(name='jeff')\n+            parent.save()\n+            child = ChildStringPrimaryKeyParent(parent=parent)\n+            child.save()\n+            child.refresh_from_db()\n+            self.assertEqual(child.parent, parent)\n+            self.assertEqual(child.parent_id, parent.name)\n+\n+    def test_order_product_fk_handling(self):\n+        # Test to see if fk constraint is managed properly on Order and Product models\n+        with transaction.atomic():\n+            product = Product(sku='foo')\n+            product.save()\n+            order = Order(product=product)\n+            order.save()\n+            self.assertTrue(Order.objects.filter(product=product).exists())\n+        \n+        # Ensure transaction fails without valid fk\n+        with transaction.atomic():\n+            with self.assertRaises(IntegrityError):\n+                order_invalid = Order()\n+                order_invalid.product = Product()  # Product with undefined SKU\n+                order_invalid.product.sku = ''\n+                order_invalid.save()\n     @classmethod\n     def setUpTestData(cls):\n         # Create a few Reporters.\n",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..9ebe766 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,9 +1,17 @@\n+\n from django.db.models import F, Q\n from django.test import SimpleTestCase\n \n \n class QTests(SimpleTestCase):\n-    def test_combine_and_empty(self):\n+    def test_combine_dict_keys_with_and_or(self):\n+        q = Q(x__in={}.keys())\n+        # | operator test\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n+        # & operator test\n+        self.assertEqual(q & Q(), q)\n+        self.assertEqual(Q() & q, q)\n         q = Q(x=1)\n         self.assertEqual(q & Q(), q)\n         self.assertEqual(Q() & q, q)\n",
  "django__django-14017": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 707f339..e42c59f 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -25,6 +25,7 @@ from django.db.models.functions import (\n from django.db.models.sql import constants\n from django.db.models.sql.datastructures import Join\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n+from django.db.models import Q, Exists, OuterRef\n from django.test.utils import (\n     Approximate, CaptureQueriesContext, isolate_apps, register_lookup,\n )\n",
  "django__django-14155": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 0f968fa..c494212 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1146,6 +1146,10 @@ class ResolverMatchTests(SimpleTestCase):\n         )\n \n \n+import functools\n+from django.urls import resolve\n+from . import views\n+\n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n class ErroneousViewTests(SimpleTestCase):\n \n",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..128385a 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,3 +1,4 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n@@ -66,7 +67,27 @@ class TestDefaultPK(SimpleTestCase):\n             class Model(models.Model):\n                 pass\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_mybigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_mysmallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n@@ -82,7 +103,27 @@ class TestDefaultPK(SimpleTestCase):\n \n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_mybigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_mysmallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_m2m_default_auto_field_setting(self):\n         class M2MModel(models.Model):\n",
  "django__django-14382": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex afeed3e..e328a44 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2217,6 +2217,31 @@ class StartApp(AdminScriptTestCase):\n             \"won't replace conflicting files.\"\n         )\n \n+    def test_trailing_slashes_in_various_directories(self):\n+        \"\"\"\n+        Test django-admin startapp with target directories having trailing slashes.\n+        \"\"\"\n+        # Test with single trailing slash\n+        app_dir_1 = os.path.join(self.test_dir, 'apps', 'app_trailing_slash')\n+        os.makedirs(app_dir_1)\n+        _, err_1 = self.run_django_admin(['startapp', 'app_trailing_slash', os.path.join('apps', 'app_trailing_slash', '')])\n+        self.assertNoOutput(err_1)\n+        self.assertIs(os.path.exists(os.path.join(app_dir_1, 'apps.py')), True)\n+\n+        # Test with multiple trailing slashes\n+        app_dir_2 = os.path.join(self.test_dir, 'apps', 'app_multiple_slashes')\n+        os.makedirs(app_dir_2)\n+        _, err_2 = self.run_django_admin(['startapp', 'app_multiple_slashes', os.path.join('apps', 'app_multiple_slashes', '///')])\n+        self.assertNoOutput(err_2)\n+        self.assertIs(os.path.exists(os.path.join(app_dir_2, 'apps.py')), True)\n+\n+        # Test with no trailing slash to ensure behavior is unchanged\n+        app_dir_3 = os.path.join(self.test_dir, 'apps', 'app_no_slash')\n+        os.makedirs(app_dir_3)\n+        _, err_3 = self.run_django_admin(['startapp', 'app_no_slash', os.path.join('apps', 'app_no_slash')])\n+        self.assertNoOutput(err_3)\n+        self.assertIs(os.path.exists(os.path.join(app_dir_3, 'apps.py')), True)\n+\n     def test_template(self):\n         out, err = self.run_django_admin(['startapp', 'new_app'])\n         self.assertNoOutput(err)\n",
  "django__django-14411": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 331338c..3e4c952 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -14,6 +14,7 @@ from django.core import mail\n from django.core.exceptions import ValidationError\n from django.core.mail import EmailMultiAlternatives\n from django.forms.fields import CharField, Field, IntegerField\n+from django.forms import forms  # Import for the ReadOnlyPasswordHashField in tests\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.utils import translation\n from django.utils.text import capfirst\n@@ -1019,6 +1020,24 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n             </div>\n             \"\"\"\n         )\n+    \n+    def test_readonlypasswordhashwidget_without_for_attribute(self):\n+        \"\"\"\n+        Test that the ReadOnlyPasswordHashWidget doesn't contain a 'for' attribute\n+        in the <label> since it doesn't have any labelable elements.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            password_hash = ReadOnlyPasswordHashField()\n+\n+        form = TestForm()\n+        bound_field = form['password_hash']\n+        \n+        # Assert that id_for_label returns None as there's no labelable element\n+        self.assertIs(bound_field.field.widget.id_for_label('id'), None)\n+        \n+        # Check that the label tag does not include a 'for' attribute\n+        expected_label = '<label>Password hash:</label>'\n+        self.assertEqual(bound_field.label_tag(), expected_label)\n \n     def test_readonly_field_has_changed(self):\n         field = ReadOnlyPasswordHashField()\n",
  "django__django-14580": "",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..03b29a6 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -336,7 +336,9 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at most 1 form.'])\n+        non_form_errors_html = formset.non_form_errors(as_text=False)\n+        self.assertInHTML('<ul class=\"errorlist nonform\"><li>Please submit at most 1 form.</li></ul>', str(non_form_errors_html))\n+        self.assertEqual(formset.non_form_errors(as_text=True), ['Please submit at most 1 form.'])\n \n     def test_formset_validate_min_flag(self):\n         \"\"\"\n@@ -358,7 +360,9 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, min_num=3, validate_min=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at least 3 forms.'])\n+        non_form_errors_html = formset.non_form_errors(as_text=False)\n+        self.assertInHTML('<ul class=\"errorlist nonform\"><li>Please submit at least 3 forms.</li></ul>', str(non_form_errors_html))\n+        self.assertEqual(formset.non_form_errors(as_text=True), ['Please submit at least 3 forms.'])\n \n     def test_formset_validate_min_unchanged_forms(self):\n         \"\"\"\n@@ -982,7 +986,9 @@ class FormsFormsetTestCase(SimpleTestCase):\n         }\n         formset = FavoriteDrinksFormSet(data, prefix='drinks')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n+        non_form_errors_html = formset.non_form_errors(as_text=False)\n+        self.assertInHTML('<ul class=\"errorlist nonform\"><li>You may only specify a drink once.</li></ul>', str(non_form_errors_html))\n+        self.assertEqual(formset.non_form_errors(as_text=True), ['You may only specify a drink once.'])\n \n     def test_formset_iteration(self):\n         \"\"\"Formset instances are iterable.\"\"\"\n",
  "django__django-14672": "",
  "django__django-14752": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex 7ef6d86..d18c5c4 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -293,9 +293,42 @@ class AutocompleteJsonViewTests(AdminViewBasicTestCase):\n             'pagination': {'more': False},\n         })\n \n+import json\n+from datetime import date\n+from django.urls import path\n+from django.test import RequestFactory, TestCase\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+from django.http import JsonResponse\n+from .models import Question\n+from .admin import QuestionAdmin\n \n-@override_settings(ROOT_URLCONF='admin_views.urls')\n-class SeleniumTests(AdminSeleniumTestCase):\n+class AutocompleteJsonViewTest(TestCase):\n+    \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.factory = RequestFactory()\n+        cls.url = '/autocomplete/'\n+        cls.superuser = User.objects.create_superuser(\n+            username='super', password='secret', email='super@example.com',\n+        )\n+        Question.objects.create(question='Question 1', posted=date(2021, 8, 9))\n+        Question.objects.create(question='Question 2', posted=date(2021, 8, 7))\n+\n+    def test_serialize_result_with_extra_field(self):\n+        class CustomAutocompleteJsonView(AutocompleteJsonView):\n+            def serialize_result(self, obj, to_field_name):\n+                return {\n+                    **super().serialize_result(obj, to_field_name),\n+                    'posted': str(obj.posted),\n+                }\n+\n+        request = self.factory.get(self.url, {'term': 'question'})\n+        request.user = self.superuser\n+        response = CustomAutocompleteJsonView.as_view(admin_site=QuestionAdmin.admin_site)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        expected_results = [{'id': str(q.pk), 'text': q.question, 'posted': str(q.posted)} for q in Question.objects.order_by('-posted')]\n+        self.assertEqual(data['results'], expected_results)\n     available_apps = ['admin_views'] + AdminSeleniumTestCase.available_apps\n \n     def setUp(self):\n",
  "django__django-14787": "",
  "django__django-14855": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 507855b..7483f3a 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -5085,7 +5085,43 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase):\n         response = self.client.get(reverse('admin2:auth_user_password_change', args=(su.pk,)))\n         self.assertEqual(response.status_code, 404)\n \n-    def test_change_form_renders_correct_null_choice_value(self):\n+    def test_readonly_foreignkey_links_default_admin_site(self):\n+        \"\"\"\n+        Test that readonly ForeignKey fields in the default admin site have the correct URL format.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1 Default Admin',\n+            content='content',\n+            book=Book.objects.create(name='Book 1')\n+        )\n+        language = Language.objects.create(iso='EN', name='English Default')\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+            language=language,\n+            user=self.superuser,\n+        )\n+        response = self.client.get(reverse('admin:admin_views_readonlyrelatedfield_change', args=(obj.pk,)))\n+        self.assertContains(response, reverse('admin:admin_views_language_change', args=(language.pk,)))\n+        self.assertContains(response, reverse('admin:auth_user_change', args=(self.superuser.pk,)))\n+\n+    def test_readonly_foreignkey_links_custom_admin_site(self):\n+        \"\"\"\n+        Test that readonly ForeignKey fields in a custom admin site have the correct URL format.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1 Custom Admin',\n+            content='content',\n+            book=Book.objects.create(name='Book 1')\n+        )\n+        language = Language.objects.create(iso='FR', name='French Custom')\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+            language=language,\n+            user=self.superuser,\n+        )\n+        response = self.client.get(reverse('custom-admin:admin_views_readonlyrelatedfield_change', args=(obj.pk,)))\n+        self.assertContains(response, reverse('custom-admin:admin_views_language_change', args=(language.pk,)))\n+        self.assertContains(response, reverse('custom-admin:auth_user_change', args=(self.superuser.pk,)))\n         \"\"\"\n         Regression test for #17911.\n         \"\"\"\n",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..ba18c6c 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,9 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n@@ -340,8 +341,25 @@ class ModelChoiceFieldTests(TestCase):\n <div><label><input type=\"checkbox\" name=\"name\" value=\"%d\" data-slug=\"third-test\">Third</label></div>\n </div>\"\"\" % (self.c1.pk, self.c2.pk, self.c3.pk),\n         )\n-\n-    def test_choices_not_fetched_when_not_rendering(self):\n+    \n+    def test_choice_value_hash(self):\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+        # Test that two instances for the same value hash to the same value\n+        self.assertEqual(hash(value_1), hash(ModelChoiceIteratorValue(self.c1.pk, None)))\n+        # Test that different values hash to different results\n+        self.assertNotEqual(hash(value_1), hash(value_2))\n+        \n+    def test_choice_in_dictionary_key(self):\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+        test_dict = {value_1: 'choice 1', value_2: 'choice 2'}\n+        # Test that the dictionary's retrieval uses the hash properly\n+        self.assertEqual(test_dict[ModelChoiceIteratorValue(self.c1.pk, None)], 'choice 1')\n+        self.assertEqual(test_dict[ModelChoiceIteratorValue(self.c2.pk, None)], 'choice 2')\n+        # Ensure that non-matching instances do not return any result\n+        with self.assertRaises(KeyError):\n+            _ = test_dict[ModelChoiceIteratorValue(-1, None)]\n         with self.assertNumQueries(1):\n             field = forms.ModelChoiceField(Category.objects.order_by('-name'))\n             self.assertEqual('Entertainment', field.clean(self.c1.pk).name)\n",
  "django__django-14999": "",
  "django__django-15061": "diff --git a/tests/forms_tests/field_tests/test_multivaluefield.py b/tests/forms_tests/field_tests/test_multivaluefield.py\nindex 53aee21..413121c 100644\n--- a/tests/forms_tests/field_tests/test_multivaluefield.py\n+++ b/tests/forms_tests/field_tests/test_multivaluefield.py\n@@ -135,8 +135,21 @@ class MultiValueFieldTest(SimpleTestCase):\n     def test_disabled_has_changed(self):\n         f = MultiValueField(fields=(CharField(), CharField()), disabled=True)\n         self.assertIs(f.has_changed(['x', 'x'], ['y', 'y']), False)\n+    def test_multivalue_widget_label_for_removal(self):\n+        # Assuming we have corrected the MultiWidget to remove \"for = ...\"\n+        class TestForm(Form):\n+            datetime = SplitDateTimeField()\n \n-    def test_form_as_table(self):\n+        form = TestForm()\n+        # The label should not have the `for` attribute format that includes an index\n+        self.assertHTMLEqual(\n+            form.as_table(),\n+            \"\"\"\n+            <tr><th><label>Datetime:</label></th>\n+            <td><input type=\"text\" name=\"datetime_0\" required id=\"id_datetime_0\">\n+            <input type=\"text\" name=\"datetime_1\" required id=\"id_datetime_1\"></td></tr>\n+            \"\"\"\n+        )\n         form = ComplexFieldForm()\n         self.assertHTMLEqual(\n             form.as_table(),\n",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..7601798 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -70,7 +70,20 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # IPv6.\n             ('http://[12:34::3a53]/', 'http://[12:34::3a53]/'),\n             ('http://[a34:9238::]:8080/', 'http://[a34:9238::]:8080/'),\n+            # Test case for the issue reported: URL with invalid IPv6 part\n+            '////]@N.AN',\n+            # Additional similar edge cases\n+            'http://[::1',\n+            'http://[::1:]8080',\n+            'http://{}/'.format('x'*200),\n+            # Test case to ensure URLField raises ValidationError on URL with invalid IPv6\n+            ('http://[1234:5678:90ab:cdef:ghij]/', 'http://[1234:5678:90ab:cdef:ghij]/'),  # Invalid IPv6 should raise ValidationError\n         ]\n+        msg = \"'Enter a valid URL.'\"\n+        for value in tests:\n+            with self.subTest(value=value):\n+                with self.assertRaisesMessage(ValidationError, msg):\n+                    f.clean(value)\n         for url, expected in tests:\n             with self.subTest(url=url):\n                 self.assertEqual(f.clean(url), expected)\n@@ -100,12 +113,25 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # even on domains that don't fail the domain label length check in\n             # the regex.\n             'http://%s' % (\"X\" * 200,),\n+            # Test case for the issue reported: URL with invalid IPv6 part\n+            '////]@N.AN',\n+            # Additional similar edge cases\n+            'http://[::1',\n+            'http://[::1:]8080',\n+            'http://{}/'.format('x'*200),\n+            # Test case to ensure URLField raises ValidationError on URL with invalid IPv6\n+            ('http://[1234:5678:90ab:cdef:ghij]/', 'http://[1234:5678:90ab:cdef:ghij]/'),  # Invalid IPv6 should raise ValidationError\n         ]\n         msg = \"'Enter a valid URL.'\"\n         for value in tests:\n             with self.subTest(value=value):\n                 with self.assertRaisesMessage(ValidationError, msg):\n                     f.clean(value)\n+        msg = \"'Enter a valid URL.'\"\n+        for value in tests:\n+            with self.subTest(value=value):\n+                with self.assertRaisesMessage(ValidationError, msg):\n+                    f.clean(value)\n \n     def test_urlfield_clean_required(self):\n         f = URLField()\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..3f5e5ac 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -262,6 +262,25 @@ class NonAggregateAnnotationTestCase(TestCase):\n             {'under_40': True, 'count_id': 6},\n         ])\n \n+    def test_expression_wrapper_with_empty_inverse_q(self):\n+        # Updated test for issue: Using ~Q(pk__in=[]) in ExpressionWrapper should not crash.\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+        qs = Book.objects.filter(isbn='159059725').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in qs], [1])\n+\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_aggregate_over_annotation(self):\n         agg = Author.objects.annotate(other_age=F('age')).aggregate(otherage_sum=Sum('other_age'))\n         other_agg = Author.objects.aggregate(age_sum=Sum('age'))\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..9820602 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,4 @@\n+\n import json\n import random\n \n@@ -163,7 +164,18 @@ class CookieTests(BaseTests, SimpleTestCase):\n         decoded_messages = json.loads(value, cls=MessageDecoder)\n         self.assertEqual(messages, decoded_messages)\n \n-    def test_safedata(self):\n+    def test_extra_tags(self):\n+        \"\"\"\n+        A message's extra_tags attribute is correctly preserved when retrieved\n+        from the message storage.\n+        \"\"\"\n+        storage = self.get_storage()\n+        for extra_tags in ['', None, 'some tags']:\n+            with self.subTest(extra_tags=extra_tags):\n+                message = Message(constants.INFO, \"Test message\", extra_tags=extra_tags)\n+                encoded = storage._encode(message)\n+                decoded = storage._decode(encoded)\n+                self.assertEqual(decoded.extra_tags, extra_tags)\n         \"\"\"\n         A message containing SafeData is keeping its safe status when\n         retrieved from the message storage.\n",
  "django__django-15388": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex 42ab5ba..cd0186a 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -1,5 +1,9 @@\n from pathlib import Path\n from unittest import mock\n+from django.test import override_settings\n+from django.conf import settings\n+from django.template.autoreload import template_changed\n+from pathlib import Path\n \n from django.template import autoreload\n from django.test import SimpleTestCase, override_settings\n@@ -39,7 +43,29 @@ class TemplateReloadTests(SimpleTestCase):\n         self.assertIsNone(autoreload.template_changed(None, Path(__file__)))\n         mock_reset.assert_not_called()\n \n-    def test_watch_for_template_changes(self):\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    @override_settings(\n+        TEMPLATES=[{\n+            'DIRS': [settings.BASE_DIR],\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]\n+    )\n+    def test_template_change_detected_with_base_dir(self, mock_reset):\n+        template_path = settings.BASE_DIR / 'some_template_dir' / 'index.html'\n+        self.assertTrue(template_changed(None, template_path))\n+        mock_reset.assert_called_once()\n+\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    @override_settings(\n+        TEMPLATES=[{\n+            'DIRS': [settings.BASE_DIR],\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]\n+    )\n+    def test_dev_server_no_restart_on_non_template_change_with_base_dir(self, mock_reset):\n+        non_template_path = settings.BASE_DIR / 'some_other_dir' / 'some_file.py'\n+        self.assertIsNone(template_changed(None, non_template_path))\n+        mock_reset.assert_not_called()\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n         self.assertSequenceEqual(\n@@ -88,7 +114,29 @@ class TemplateReloadTests(SimpleTestCase):\n @require_jinja2\n @override_settings(INSTALLED_APPS=['template_tests'])\n class Jinja2TemplateReloadTests(SimpleTestCase):\n-    def test_watch_for_template_changes(self):\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    @override_settings(\n+        TEMPLATES=[{\n+            'DIRS': [settings.BASE_DIR],\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]\n+    )\n+    def test_template_change_detected_with_base_dir(self, mock_reset):\n+        template_path = settings.BASE_DIR / 'some_template_dir' / 'index.html'\n+        self.assertTrue(template_changed(None, template_path))\n+        mock_reset.assert_called_once()\n+\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    @override_settings(\n+        TEMPLATES=[{\n+            'DIRS': [settings.BASE_DIR],\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]\n+    )\n+    def test_dev_server_no_restart_on_non_template_change_with_base_dir(self, mock_reset):\n+        non_template_path = settings.BASE_DIR / 'some_other_dir' / 'some_file.py'\n+        self.assertIsNone(template_changed(None, non_template_path))\n+        mock_reset.assert_not_called()\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n         self.assertSequenceEqual(\n",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..f03192f 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -184,7 +185,39 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n-    def test_was_modified_since_fp(self):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"\n+        Test case for empty string as If-Modified-Since header.\n+        Verifies that the empty string does not raise an exception and returns True.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=\"\", mtime=1))\n+\n+    def test_was_modified_since_invalid_date(self):\n+        \"\"\"\n+        Test case for invalid date string in If-Modified-Since header.\n+        Verifies it should return True, allowing the request to continue as if it was modified.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=\"invalid-date\", mtime=1))\n+\n+    def test_was_modified_since_valid_future_date(self):\n+        \"\"\"\n+        Test case for a valid future date in If-Modified-Since header.\n+        Verifies it should return False, indicating resource has not been modified.\n+        \"\"\"\n+        import datetime\n+        future_mtime = datetime.datetime.now().timestamp() + 10000  # Future timestamp\n+        future_header = http_date(future_mtime)\n+        self.assertFalse(was_modified_since(header=future_header, mtime=datetime.datetime.now().timestamp()))\n+\n+    def test_was_modified_since_valid_past_date(self):\n+        \"\"\"\n+        Test case for a valid past date in If-Modified-Since header.\n+        Verifies it should return True, indicating resource usually modified.\n+        \"\"\"\n+        import datetime\n+        past_mtime = datetime.datetime.now().timestamp() - 10000  # Past timestamp\n+        past_header = http_date(past_mtime)\n+        self.assertTrue(was_modified_since(header=past_header, mtime=datetime.datetime.now().timestamp()))\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n         \"\"\"\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..9daaefe 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,3 +1,4 @@\n+\n import os\n from io import StringIO\n from unittest import mock\n@@ -8,6 +9,8 @@ from django.apps import apps\n from django.core import management\n from django.core.checks import Tags\n from django.core.management import BaseCommand, CommandError, find_commands\n+from argparse import ArgumentDefaultsHelpFormatter\n+from django.core.management.base import CommandParser\n from django.core.management.utils import (\n     find_command,\n     get_random_secret_key,\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..1e7b2cf 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,7 +1,10 @@\n+\n import os\n from datetime import datetime\n \n from django.test import SimpleTestCase\n+from django.core.serializers.json import DjangoJSONEncoder\n+import json\n from django.utils.functional import lazystr\n from django.utils.html import (\n     conditional_escape,\n@@ -217,6 +220,37 @@ class TestUtilsHtml(SimpleTestCase):\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n         )\n \n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"custom\": \"output\"}'\n+\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"custom\": \"output\"}</script>',\n+        )\n+\n+    def test_json_script_with_custom_data(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def default(self, o):\n+                if isinstance(o, datetime):\n+                    return o.isoformat()\n+                return super().default(o)\n+\n+        self.assertHTMLEqual(\n+            json_script(\n+                {\"date\": datetime(2020, 1, 1)},\n+                encoder=CustomDjangoJSONEncoder,\n+            ),\n+            '<script type=\"application/json\">{\"date\": \"2020-01-01T00:00:00\"}</script>',\n+        )\n+        \n+    def test_json_script_default_encoder(self):\n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}),\n+            '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n+        )\n+        \n     def test_smart_urlquote(self):\n         items = (\n             (\"http://\u00f6\u00e4\u00fc.com/\", \"http://xn--4ca9at.com/\"),\n",
  "django__django-15790": "diff --git a/tests/check_framework/test_templates.py b/tests/check_framework/test_templates.py\nindex 72e6cfe..e35ebe1 100644\n--- a/tests/check_framework/test_templates.py\n+++ b/tests/check_framework/test_templates.py\n@@ -142,7 +142,67 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n             [self.error_same_tags],\n         )\n \n-    def test_template_tags_with_same_library_name(self):\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\"\n+        ]\n+    )\n+    def test_same_library_error_within_installed_apps(self):\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"same_tags\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+                self.get_settings(\n+                    \"same_tags\", \"anotherapp.templatetags.same_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [\n+                    Error(\n+                        E003.msg.format(\n+                            \"'same_tags'\",\n+                            \"'check_framework.template_test_apps.same_tags_app_1.\"\n+                            \"templatetags.same_tags', \"\n+                            \"'anotherapp.templatetags.same_tags'\",\n+                        ),\n+                        id=E003.id,\n+                    )\n+                ],\n+            )\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\"\n+        ]\n+    )\n+    def test_additional_same_name_library_in_different_app(self):\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"same_tags\", \"anotherapp.different_tags\"\n+                ),\n+                self.get_settings(\n+                    \"same_tags\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [\n+                    Error(\n+                        E003.msg.format(\n+                            \"'same_tags'\",\n+                            \"'anotherapp.different_tags', \"\n+                            \"'check_framework.template_test_apps.same_tags_app_1.\"\n+                            \"templatetags.same_tags'\",\n+                        ),\n+                        id=E003.id,\n+                    )\n+                ],\n+            )\n         with self.settings(\n             TEMPLATES=[\n                 self.get_settings(\n@@ -206,4 +266,4 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n         ]\n     )\n     def test_template_tags_with_different_name(self):\n-        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..8defc9f 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -390,6 +390,18 @@ class ProxyModelTests(TestCase):\n             repr(resp), \"<ProxyImprovement: ProxyImprovement:improve that>\"\n         )\n \n+    def test_select_related_only_with_proxy_model(self):\n+        # Create test data\n+        custom = ProxyCustomModel.objects.create(name=\"Test Name\")\n+        another = AnotherModel.objects.create(custom=custom)\n+\n+        # Use select_related and only on Proxy Model\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+        result = qs.get()\n+\n+        # Check if the query doesn't crash and returns expected results\n+        self.assertEqual(result.custom.name, \"Test Name\")\n+\n     def test_proxy_load_from_fixture(self):\n         management.call_command(\"loaddata\", \"mypeople.json\", verbosity=0)\n         p = MyPerson.objects.get(pk=100)\n",
  "django__django-15851": "diff --git a/django/db/backends/postgresql/client.py b/django/db/backends/postgresql/client.py\nindex 55aff39..f14cf54 100644\n--- a/django/db/backends/postgresql/client.py\n+++ b/django/db/backends/postgresql/client.py\n@@ -1,3 +1,4 @@\n+\n import signal\n \n from django.db.backends.base.client import BaseDatabaseClient\n@@ -32,9 +33,10 @@ class DatabaseClient(BaseDatabaseClient):\n             args += [\"-h\", host]\n         if port:\n             args += [\"-p\", str(port)]\n+        args.extend(parameters)\n+        args.extend(parameters)\n         if dbname:\n             args += [dbname]\n-        args.extend(parameters)\n \n         env = {}\n         if passwd:\n@@ -61,4 +63,4 @@ class DatabaseClient(BaseDatabaseClient):\n             super().runshell(parameters)\n         finally:\n             # Restore the original SIGINT handler.\n-            signal.signal(signal.SIGINT, sigint_handler)\n+            signal.signal(signal.SIGINT, sigint_handler)\n",
  "django__django-15902": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 44ea946..54a223b 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1902,6 +1902,18 @@ class DeprecationTests(SimpleTestCase):\n     def test_warning(self):\n         from django.forms.utils import DEFAULT_TEMPLATE_DEPRECATION_MSG\n \n+    def test_no_management_form_deprecation_warning(self):\n+        \"\"\"\n+        Tests that no deprecation warning is raised when rendering a management form.\n+        \"\"\"\n+        with isolate_lru_cache(get_default_renderer), self.settings(\n+            FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n+        ):\n+            ChoiceFormSet = formset_factory(Choice)\n+            formset = ChoiceFormSet()\n+            # Attempt to render the management form and ensure no warnings.\n+            str(formset.management_form)\n+\n         with isolate_lru_cache(get_default_renderer), self.settings(\n             FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n         ), self.assertRaisesMessage(\n@@ -1909,4 +1921,4 @@ class DeprecationTests(SimpleTestCase):\n         ):\n             ChoiceFormSet = formset_factory(Choice)\n             formset = ChoiceFormSet()\n-            str(formset)\n+            str(formset)\n",
  "django__django-16041": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex a34f3d3..09225cb 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -173,6 +173,19 @@ class FormsFormsetTestCase(SimpleTestCase):\n             self.assertTrue(hasattr(form, \"custom_kwarg\"))\n             self.assertEqual(form.custom_kwarg, i)\n \n+    def test_empty_permitted_handling_empty_form(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        \n+        # Test when empty_permitted is True\n+        formset_true = FormSet(form_kwargs={\"empty_permitted\": True})\n+        # The empty_form's empty_permitted should always be True regardless of what's passed.\n+        self.assertTrue(formset_true.empty_form.empty_permitted)\n+        \n+        # Test when empty_permitted is False\n+        formset_false = FormSet(form_kwargs={\"empty_permitted\": False})\n+        # Similarly, the empty_form's empty_permitted should always be True regardless of what's passed.\n+        self.assertTrue(formset_false.empty_form.empty_permitted)\n+\n     def test_form_kwargs_empty_form(self):\n         FormSet = formset_factory(CustomKwargForm)\n         formset = FormSet(form_kwargs={\"custom_kwarg\": 1})\n",
  "django__django-16046": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 41aae41..a94fb53 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -1,3 +1,4 @@\n+\n from decimal import Decimal\n from sys import float_info\n \n@@ -160,7 +161,17 @@ class TestNumberFormat(SimpleTestCase):\n                     nformat(Decimal(value), \".\", decimal_pos), expected_value\n                 )\n \n-    def test_decimal_subclass(self):\n+    def test_empty(self):\n+        # Test with an empty string input\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        # Test with None input, expecting 'None' as a string\n+        self.assertEqual(nformat(None, \".\"), \"None\")\n+\n+    def test_null_and_whitespace(self):\n+        # Test with None and expect behavior; should not raise an error\n+        self.assertEqual(nformat(None, \",\"), \"None\")\n+        # Test with a string with whitespaces\n+        self.assertEqual(nformat(\"   \", \",\"), \"   \")\n         class EuroDecimal(Decimal):\n             \"\"\"\n             Wrapper for Decimal which prefixes each amount with the \u20ac symbol.\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..0c8e650 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -26,6 +27,8 @@ from django.utils import translation\n from django.utils.text import capfirst\n from django.utils.translation import gettext as _\n \n+from django.urls import reverse\n+import urllib.parse\n from .models.custom_user import (\n     CustomUser,\n     CustomUserWithoutIsActiveField,\n@@ -892,6 +895,26 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # value to render correctly\n         self.assertEqual(form.initial[\"password\"], form[\"password\"].value())\n \n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_password_reset_link_formatted_correctly_with_to_field(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search(r'<a href=\"(.*?)\">', password_help_text)\n+\n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.username,),\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n     def test_custom_form(self):\n         class CustomUserChangeForm(UserChangeForm):\n             class Meta(UserChangeForm.Meta):\n",
  "django__django-16255": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 1469efd..c254dff 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -505,6 +505,16 @@ class HTTPSitemapTests(SitemapTestsBase):\n             \"</urlset>\"\n         )\n         self.assertXMLEqual(index_response.content.decode(), expected_content_index)\n+\n+    def test_callable_sitemod_no_items(self):\n+        index_response = self.client.get(\"/callable-lastmod-no-items/index.xml\")\n+        self.assertNotIn(\"Last-Modified\", index_response)\n+        expected_content_index = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n+        <sitemap><loc>http://example.com/simple/sitemap-callable-lastmod.xml</loc></sitemap>\n+        </sitemapindex>\n+        \"\"\"\n+        self.assertXMLEqual(index_response.content.decode(), expected_content_index)\n         self.assertXMLEqual(sitemap_response.content.decode(), expected_content_sitemap)\n \n \n",
  "django__django-16379": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 014d28a..b67de82 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1,6 +1,9 @@\n+\n # Unit tests for cache framework\n # Uses whatever cache backend is set in the test settings file.\n import copy\n+from unittest import mock, TestCase\n+from django.core.cache import cache\n import io\n import os\n import pickle\n@@ -1763,7 +1766,43 @@ class FileBasedCacheTests(BaseCacheTests, TestCase):\n             self.assertIs(cache._is_expired(fh), True)\n \n \n-@unittest.skipUnless(RedisCache_params, \"Redis backend not configured\")\n+class FileBasedCacheRaceConditionTests(TestCase):\n+    def test_has_key_race_handling(self):\n+        # Ensure that if a FileNotFoundError occurs during open, has_key returns False\n+        self.assertIs(cache.add(\"key\", \"value\"), True)\n+        with mock.patch(\"builtins.open\", side_effect=FileNotFoundError) as mocked_open:\n+            self.assertIs(cache.has_key(\"key\"), False)\n+            mocked_open.assert_called_once()\n+\n+    def test_has_key_with_actual_file_deletion(self):\n+        # Simulate the case where the file actually gets deleted after the exists() check\n+        key = \"to_be_deleted\"\n+        self.assertIs(cache.add(key, \"value\"), True)\n+        file_path = cache._key_to_file(key)\n+\n+        def side_effect(fname, *args, **kwargs):\n+            # Remove the file before it's opened to simulate race condition\n+            if os.path.exists(fname):\n+                os.remove(fname)\n+            raise FileNotFoundError\n+        \n+        with mock.patch(\"builtins.open\", side_effect=side_effect) as mocked_open:\n+            self.assertIs(cache.has_key(key), False)\n+            mocked_open.assert_called_once()\n+\n+    def test_has_key_where_expiry_deletes_the_file(self):\n+        # Cache file will be expired and thus deleted in _is_expired\n+        key = \"expired_key\"\n+        self.assertIs(cache.add(key, \"value\"), True)\n+        file_path = cache._key_to_file(key)\n+\n+        def mock_is_expired(file):\n+            # Simulate that the file is expired and should be deleted\n+            os.remove(file_path)\n+            return True\n+\n+        with mock.patch.object(cache, '_is_expired', mock_is_expired):\n+            self.assertIs(cache.has_key(key), False)\n @override_settings(\n     CACHES=caches_setting_for_tests(\n         base=RedisCache_params,\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..708e968 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -6,7 +7,9 @@ from django.contrib.admin.templatetags.admin_modify import submit_row\n from django.contrib.auth.admin import UserAdmin\n from django.contrib.auth.models import User\n from django.test import RequestFactory, TestCase\n+from django.contrib.auth import get_permission_codename\n from django.urls import reverse\n+from .tests import get_perm\n \n from .admin import ArticleAdmin, site\n from .models import Article, Question\n@@ -33,7 +36,42 @@ class AdminTemplateTagsTest(AdminViewBasicTestCase):\n         self.assertIs(template_context[\"extra\"], True)\n         self.assertIs(template_context[\"show_save\"], True)\n \n-    def test_override_show_save_and_add_another(self):\n+    def test_submit_row_save_as_new_add_permission_required(self):\n+        \"\"\"\n+        Test that 'show_save_as_new' is only true if the user has both 'add' and 'change' permissions.\n+        \"\"\"\n+        # User with only change permission\n+        change_user = User.objects.create_user(\n+            username=\"change_user\", password=\"secret\", is_staff=True\n+        )\n+        change_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = change_user\n+        admin = UserAdmin(User, site)\n+        admin.save_as = True\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], False)\n+\n+        # User with add and change permissions\n+        add_user = User.objects.create_user(\n+            username=\"add_user\", password=\"secret\", is_staff=True\n+        )\n+        add_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"add\", User._meta)),\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = add_user\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], True)\n         request = self.request_factory.get(\n             reverse(\"admin:auth_user_change\", args=[self.superuser.pk]),\n         )\n",
  "django__django-16595": "",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..336d004 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,3 +1,4 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n@@ -26,7 +27,14 @@ class JoinTests(SimpleTestCase):\n         output = self.engine.render_to_string(\"join04\", {\"a\": [\"alpha\", \"beta & me\"]})\n         self.assertEqual(output, \"alpha &amp; beta & me\")\n \n-    # Joining with unsafe joiners doesn't result in unsafe strings.\n+    @setup({\"join09\": '{% autoescape off %}{{ a|join:var }}{% endautoescape %}'})\n+    def test_join_autoescape_off_with_unsafe_joiner(self):\n+        # Test case based on the issue description to ensure the joiner string is not escaped when autoescape is off\n+        output = self.engine.render_to_string(\n+            \"join09\", {\"a\": [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"], \"var\": \"<br/>\"}\n+        )\n+        expected_result = \"<p>Hello World!</p><br/>beta & me<br/><script>Hi!</script>\"\n+        self.assertEqual(output, expected_result)\n     @setup({\"join05\": \"{{ a|join:var }}\"})\n     def test_join05(self):\n         output = self.engine.render_to_string(\n@@ -78,4 +86,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..9aa95d5 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -600,7 +600,30 @@ class BulkCreateTests(TestCase):\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n-    def test_update_conflicts_two_fields_unique_fields_first(self):\n+    def test_bulk_create_update_conflicts_with_returning_ids(self):\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"X\"),\n+            TwoFields(f1=2, f2=2, name=\"Y\"),\n+        ]\n+\n+        # Case where PostgreSQL or similar DB with RETURNING clause can handle it\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            # Create initial objects to ensure conflicts\n+            TwoFields.objects.bulk_create(\n+                [TwoFields(f1=1, f2=1, name=\"Initial\")]\n+            )\n+\n+            results = TwoFields.objects.bulk_create(\n+                conflicting_objects,\n+                update_conflicts=True,\n+                unique_fields=[\"f1\"],\n+                update_fields=[\"name\"],\n+            )\n+\n+            # Check if results returned have primary keys set\n+            self.assertEqual(len(results), len(conflicting_objects))\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n         self._test_update_conflicts_two_fields([\"f1\"])\n \n     @skipUnlessDBFeature(\n@@ -816,4 +839,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..1eeab26 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -197,6 +197,31 @@ class OperationWriterTests(SimpleTestCase):\n             \"),\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -255,12 +280,62 @@ class WriterTests(SimpleTestCase):\n             decimal.Decimal(\"1.3\"), (\"Decimal('1.3')\", {\"from decimal import Decimal\"})\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n         self.assertSerializedEqual(Money(\"1.3\"))\n         self.assertSerializedResultEqual(\n             Money(\"1.3\"),\n             (\"migrations.test_writer.Money('1.3')\", {\"import migrations.test_writer\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -296,6 +371,31 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r\"^foo$\")\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -306,6 +406,31 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\n@@ -313,6 +438,31 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\n@@ -320,10 +470,60 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -331,11 +531,61 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(\n             default=TextEnum.B, choices=[(m.value, m) for m in TextEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -344,10 +594,60 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -356,9 +656,59 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         field = models.CharField(\n             default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -367,9 +717,59 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         field = models.IntegerField(\n             default=IntEnum.A, choices=[(m.value, m) for m in IntEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -379,6 +779,31 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n@@ -387,6 +812,31 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n@@ -394,9 +844,59 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -405,6 +905,31 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A | IntFlagEnum.B,\n             (\n@@ -414,6 +939,31 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = \"A\", \"A value\"\n@@ -433,6 +983,31 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             (\"datetime.date(1969, 7, 20)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         field = models.CharField(default=TextChoices.B, choices=TextChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -440,12 +1015,62 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -456,6 +1081,31 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_nested_class(self):\n         for nested_cls in [self.NestedEnum, self.NestedChoices]:\n             cls_name = nested_cls.__name__\n@@ -478,14 +1128,89 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {\"import uuid\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {\"import uuid\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n         field = models.UUIDField(\n             choices=((uuid_a, \"UUID A\"), (uuid_b, \"UUID B\")), default=uuid_a\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -495,6 +1220,31 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_pathlib(self):\n         # Pure path objects work in all platforms.\n         self.assertSerializedEqual(pathlib.PurePosixPath())\n@@ -523,6 +1273,31 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"models.FilePathField(path=pathlib.PurePosixPath('/home/user'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertIn(\"import pathlib\", imports)\n \n     def test_serialize_path_like(self):\n@@ -554,13 +1329,88 @@ class WriterTests(SimpleTestCase):\n         self.assertSerializedEqual(\n             datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone())\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedEqual(\n             datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180))\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc),\n             (\n@@ -568,6 +1418,31 @@ class WriterTests(SimpleTestCase):\n                 {\"import datetime\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(\n                 2012, 1, 1, 2, 1, tzinfo=zoneinfo.ZoneInfo(\"Europe/Paris\")\n@@ -578,12 +1453,62 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n@@ -593,20 +1518,120 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(\n             SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\")\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedResultEqual(\n             SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)), (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -624,6 +1649,31 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.RegexValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a compiled regex.\n@@ -633,6 +1683,31 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test a string regex with flag\n@@ -643,6 +1718,31 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[0-9]+$', \"\n             \"flags=re.RegexFlag['DOTALL'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n@@ -653,6 +1753,31 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', \"\n             \"'invalid')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a subclass.\n@@ -661,6 +1786,31 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.EmailValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.serialize_round_trip(validator)\n \n         validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(\n@@ -671,9 +1821,59 @@ class WriterTests(SimpleTestCase):\n             string, \"migrations.test_writer.EmailValidator(message='hello')\"\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n         validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(\n             message=\"hello\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n             MigrationWriter.serialize(validator)\n \n@@ -700,6 +1900,31 @@ class WriterTests(SimpleTestCase):\n             models.OrderBy(models.F(\"name\").desc()),\n             name=\"complex_func_index\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         string, imports = MigrationWriter.serialize(index)\n         self.assertEqual(\n             string,\n@@ -711,6 +1936,31 @@ class WriterTests(SimpleTestCase):\n             \"models.OrderBy(models.OrderBy(models.F('name'), descending=True)), \"\n             \"name='complex_func_index')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertEqual(imports, {\"from django.db import models\"})\n \n     def test_serialize_empty_nonempty_tuple(self):\n@@ -762,6 +2012,31 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.models\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         self.assertSerializedEqual(FoodManager(\"a\", \"b\"))\n         self.assertSerializedEqual(FoodManager(\"x\", \"y\", c=3, d=4))\n \n@@ -772,6 +2047,31 @@ class WriterTests(SimpleTestCase):\n             frozenset(\"cba\"), (\"frozenset(['a', 'b', 'c'])\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_serialize_set(self):\n         self.assertSerializedEqual(set())\n         self.assertSerializedResultEqual(set(), (\"set()\", set()))\n@@ -809,6 +2109,31 @@ class WriterTests(SimpleTestCase):\n             (\"('models.Model', {'from django.db import models'})\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -848,6 +2173,31 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [(\"testapp\", \"some_other_one\")],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         # We don't test the output formatting - that's too fragile.\n@@ -887,6 +2237,31 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -896,6 +2271,31 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_sorted_dependencies(self):\n         migration = type(\n             \"Migration\",\n@@ -912,6 +2312,31 @@ class WriterTests(SimpleTestCase):\n                 ],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         output = MigrationWriter(migration, include_header=False).as_string()\n         self.assertIn(\n             \"    dependencies = [\\n\"\n@@ -923,6 +2348,31 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -949,6 +2399,31 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -956,6 +2431,31 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -1001,6 +2501,31 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\"from django.db import migrations\\n\", output)\n@@ -1017,6 +2542,31 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list[str]:\n+                    return [cls.BASIC]\n+\n+            # Define capabilities field and use the default method in Capability class\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field(\"capabilities\")\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+            \"The serialization of the field must include the correct path to the class method.\",\n+        )\n+\n     def test_register_serializer(self):\n         class ComplexSerializer(BaseSerializer):\n             def serialize(self):\n@@ -1032,4 +2582,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "matplotlib__matplotlib-22711": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex 39c625e..589a681 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1120,6 +1120,30 @@ def test_range_slider(orientation):\n     assert_allclose(slider.val, [0.1, 0.34])\n \n \n+@pytest.mark.parametrize(\"orientation\", [\"horizontal\", \"vertical\"])\n+def test_range_slider_initialization(orientation):\n+    fig, ax = plt.subplots()\n+\n+    # Test initialization with a different range\n+    slider = widgets.RangeSlider(\n+        ax=ax, label=\"\",\n+        valmin=-1.0, valmax=3.0,\n+        valinit=[0.5, 2.5],\n+        orientation=orientation\n+    )\n+    assert_allclose(slider.val, (0.5, 2.5))\n+\n+    # Simulate updates and handle changes\n+    slider.set_val((1.0, 2.0))\n+    assert_allclose(slider.val, (1.0, 2.0))\n+\n+    slider.set_val((3.0, -2.0))  # This should set to valmin and valmax\n+    assert_allclose(slider.val, (-1.0, 3.0))\n+\n+    slider.reset()\n+    assert_allclose(slider.val, [0.5, 2.5])\n+\n+\n def check_polygon_selector(event_sequence, expected_result, selections_count,\n                            **kwargs):\n     \"\"\"\n",
  "matplotlib__matplotlib-23299": "diff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 144880c..af4f6b9 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -490,6 +490,10 @@ def test_validate_fontstretch(stretch, parsed_stretch):\n         assert validate_fontstretch(stretch) == parsed_stretch\n \n \n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend\n+from matplotlib import _pylab_helpers\n+\n def test_keymaps():\n     key_list = [k for k in mpl.rcParams if 'keymap' in k]\n     for k in key_list:\n@@ -507,8 +511,32 @@ def test_rcparams_reset_after_fail():\n                 pass\n         assert mpl.rcParams['text.usetex'] is False\n \n+def test_get_backend_does_not_clear_rc_context_figures():\n+    \"\"\"Test that get_backend() does not clear figures created under rc_context.\"\"\"\n+    # Ensure no figures at the start\n+    plt._pylab_helpers.Gcf.destroy_all()\n+\n+    with plt.rc_context():\n+        fig = plt.figure()\n+        before = list(plt._pylab_helpers.Gcf.figs.keys())\n+\n+    get_backend()\n+    after = list(plt._pylab_helpers.Gcf.figs.keys())\n+\n+    assert before == after, f\"Figures before: {before}, Figures after: {after}\"\n+    plt._pylab_helpers.Gcf.destroy_all()\n+\n+\n+def test_get_backend_no_figures():\n+    \"\"\"Ensure get_backend() does nothing when no figures are present.\"\"\"\n+    plt._pylab_helpers.Gcf.destroy_all()\n+\n+    before = list(plt._pylab_helpers.Gcf.figs.keys())\n+    get_backend()\n+    after = list(plt._pylab_helpers.Gcf.figs.keys())\n \n-@pytest.mark.skipif(sys.platform != \"linux\", reason=\"Linux only\")\n+    assert before == after, f\"No figures present; figures before and after should be empty.\"\n+    plt._pylab_helpers.Gcf.destroy_all()\n def test_backend_fallback_headless(tmpdir):\n     env = {**os.environ,\n            \"DISPLAY\": \"\", \"WAYLAND_DISPLAY\": \"\",\n",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..d192d24 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -28,7 +28,32 @@ def test_aspect_equal_error():\n         ax.set_aspect('equal')\n \n \n-@mpl3d_image_comparison(['bar3d.png'])\n+@check_figures_equal(extensions=[\"png\"])\n+def test_invisible_3d_subplot(fig_test, fig_ref):\n+    # Create a 3D subplot and set it to be invisible\n+    ax = fig_test.add_subplot(111, projection='3d')\n+    ax.set_visible(False)\n+\n+    # Create a reference figure with the same subplot that's visible\n+    ax_ref = fig_ref.add_subplot(111, projection='3d')\n+    ax_ref.set_visible(True)\n+\n+@check_figures_equal(extensions=[\"png\"])\n+def test_toggle_visibility_3d_subplot(fig_test, fig_ref):\n+    # Create a 3D subplot, toggle its visibility and set it back\n+    ax = fig_test.add_subplot(111, projection='3d')\n+    ax.set_visible(False)\n+    ax.set_visible(True)\n+\n+    # Create a reference figure with a visible subplot\n+    ax_ref = fig_ref.add_subplot(111, projection='3d')\n+    ax_ref.set_visible(True)\n+\n+def test_invisible_axes_events_3d():\n+    fig, ax = plt.subplots(subplot_kw={'projection': '3d'})\n+    assert fig.canvas.inaxes((200, 200, 200)) is not None\n+    ax.set_visible(False)\n+    assert fig.canvas.inaxes((200, 200, 200)) is None\n def test_bar3d():\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n",
  "matplotlib__matplotlib-23562": "",
  "matplotlib__matplotlib-23563": "",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..109b599 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -773,8 +773,25 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n     for text, color in zip(leg.get_texts(), ['r', 'g', 'b']):\n         assert mpl.colors.same_color(text.get_color(), color)\n \n+import pytest\n+import matplotlib.pyplot as plt\n \n-def test_get_set_draggable():\n+@pytest.mark.parametrize('draggable', (True, False))\n+def test_legend_draggable(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='Line')\n+    leg = ax.legend(draggable=draggable)\n+    assert leg.get_draggable() is draggable\n+\n+def test_legend_toggle_draggable():\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='Line')\n+    leg = ax.legend(draggable=False)\n+    assert not leg.get_draggable()\n+    leg.set_draggable(True)\n+    assert leg.get_draggable()\n+    leg.set_draggable(False)\n+    assert not leg.get_draggable()\n     legend = plt.legend()\n     assert not legend.get_draggable()\n     legend.set_draggable(True)\n",
  "matplotlib__matplotlib-23964": "diff --git a/lib/matplotlib/tests/test_backend_ps.py b/lib/matplotlib/tests/test_backend_ps.py\nindex a1caf1a..2267ed1 100644\n--- a/lib/matplotlib/tests/test_backend_ps.py\n+++ b/lib/matplotlib/tests/test_backend_ps.py\n@@ -246,7 +246,35 @@ def test_fonttype(fonttype):\n \n def test_linedash():\n     \"\"\"Test that dashed lines do not break PS output\"\"\"\n-    fig, ax = plt.subplots()\n+import io\n+from matplotlib.figure import Figure\n+import matplotlib.pyplot as plt\n+\n+def test_empty_line():\n+    # Smoke-test for gh#23954\n+    figure = Figure()\n+    figure.text(0.5, 0.5, \"\\nfoo\\n\\n\")\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n+\n+def test_annotation_with_empty_line():\n+    # Test for annotation with an empty line to ensure it doesn't cause TypeError\n+    figure = Figure()\n+    ax = figure.add_subplot(111)\n+    ax.annotate(text='\\nLower label', xy=(0, 0))\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n+\n+def test_title_with_empty_line():\n+    # Test for title with an empty line to ensure it doesn't cause TypeError\n+    figure = Figure()\n+    ax = figure.add_subplot(111)\n+    ax.set_title('\\nLower title')\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n \n     ax.plot([0, 1], linestyle=\"--\")\n \n",
  "matplotlib__matplotlib-23987": "diff --git a/lib/matplotlib/tests/test_constrainedlayout.py b/lib/matplotlib/tests/test_constrainedlayout.py\nindex 41fdfa1..1e9fbca 100644\n--- a/lib/matplotlib/tests/test_constrainedlayout.py\n+++ b/lib/matplotlib/tests/test_constrainedlayout.py\n@@ -649,10 +649,27 @@ def test_compressed1():\n \n     fig.colorbar(pc, ax=axs)\n     fig.draw_without_rendering()\n+import pytest\n+import numpy as np\n+import matplotlib.pyplot as plt\n \n+@pytest.mark.filterwarnings(\"error\")  # treat warnings as errors\n+def test_no_userwarning_with_constrained_layout_false():\n+    # This test is intended to ensure that no UserWarning is raised when \n+    # calling subplots_adjust with constrained_layout=False.\n+    a = np.linspace(0, 2 * np.pi, 100)\n+    b = np.sin(a)\n+    c = np.cos(a)\n+    try:\n+        fig, ax = plt.subplots(1, 2, figsize=(8, 2), constrained_layout=False)\n+        ax[0].plot(a, b)\n+        ax[1].plot(a, c)\n+        plt.subplots_adjust(wspace=0)  # This should not raise a warning\n+    except UserWarning:\n+        pytest.fail(\"UserWarning should not be raised with constrained_layout=False\")\n     pos = axs[0, 0].get_position()\n     np.testing.assert_allclose(pos.x0, 0.06195, atol=1e-3)\n     np.testing.assert_allclose(pos.y1, 0.8537, atol=1e-3)\n     pos = axs[1, 2].get_position()\n     np.testing.assert_allclose(pos.x1, 0.8618, atol=1e-3)\n-    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n+    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 64ba766..3f8ba16 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -5731,8 +5731,39 @@ def test_set_get_ticklabels():\n     ax[1].set_xticklabels(ax[0].get_xticklabels())\n     ax[1].set_yticklabels(ax[0].get_yticklabels())\n \n+import pytest\n+import matplotlib.pyplot as plt\n \n-@check_figures_equal(extensions=[\"png\"])\n+def test_set_ticks_kwargs_raise_error_without_labels():\n+    \"\"\"\n+    When labels=None and any kwarg is passed, axis.set_ticks() raises a\n+    ValueError.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [1, 2, 3]\n+    with pytest.raises(ValueError, match=\"keyword argument not understood: alpha\"):\n+        ax.xaxis.set_ticks(ticks, alpha=0.5)\n+\n+def test_set_ticks_with_valid_kwargs():\n+    \"\"\"\n+    Valid kwargs should not raise an error when labels are provided.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [0, 1]\n+    labels = [\"a\", \"b\"]\n+    # Valid kwargs example\n+    ax.xaxis.set_ticks(ticks, labels=labels, fontweight='bold')\n+    assert len(ax.get_xticks()) == len(ticks)\n+\n+def test_set_ticks_with_invalid_kwargs_with_labels():\n+    \"\"\"\n+    Invalid kwargs should raise an error even if labels are provided.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [0, 1]\n+    labels = [\"a\", \"b\"]\n+    with pytest.raises(ValueError, match=\"keyword argument not understood: invalid_kwarg\"):\n+        ax.xaxis.set_ticks(ticks, labels=labels, invalid_kwarg='bold')\n def test_set_ticks_with_labels(fig_test, fig_ref):\n     \"\"\"\n     Test that these two are identical::\n",
  "matplotlib__matplotlib-24970": "",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..c8e554f 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -90,6 +91,27 @@ def _generate_complete_test_figure(fig_ref):\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n \n+def test_draggable_legend_pickle():\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111)\n+\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40, 43, 45, 47, 48]\n+\n+    ax.plot(time, speed, label=\"speed\")\n+\n+    leg = ax.legend()\n+    leg.set_draggable(True)\n+\n+    # Attempt to pickle the figure and assert no error\n+    pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+\n+    # Ensure FigureCanvasQTAgg is not in the pickle stream\n+    assert \"FigureCanvasQTAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+\n+    # Load the figure from pickle to ensure it can be deserialized\n+    loaded = pickle.loads(pkl)\n+\n @mpl.style.context(\"default\")\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..772c5fa 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -89,8 +89,35 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+import pytest\n \n-@mpl.style.context(\"default\")\n+@pytest.mark.parametrize('align_func', ['align_labels', 'align_ylabels'])\n+def test_pickle_figure_with_aligned_labels(align_func):\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+\n+    # Plot some data on both axes\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Align labels using align_labels or align_ylabels\n+    getattr(fig, align_func)()\n+\n+    # Attempt to pickle the figure\n+    try:\n+        pickle_data = pickle.dumps(fig)\n+        assert pickle_data is not None\n+    except TypeError as e:\n+        pytest.fail(f\"Pickling failed with TypeError: {e}\")\n+    \n+    plt.close(fig)\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25442": "diff --git a/lib/matplotlib/tests/test_offsetbox.py b/lib/matplotlib/tests/test_offsetbox.py\nindex 204af9c..71f6ddd 100644\n--- a/lib/matplotlib/tests/test_offsetbox.py\n+++ b/lib/matplotlib/tests/test_offsetbox.py\n@@ -445,8 +445,29 @@ def test_paddedbox():\n     pb = PaddedBox(ta, pad=10, patch_attrs={'facecolor': 'b'})\n     ab = AnchoredOffsetbox('upper right', child=pb)\n     ax.add_artist(ab)\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import mplcursors\n+import pytest\n+\n+def test_mplcursor_attribute_error():\n+    x = np.arange(1, 11)\n+    y1 = x\n+    fig, ax = plt.subplots()\n+    ax.scatter(x, y1)\n+\n+    cursor = mplcursors.cursor()\n \n+    # Simulate clicking a few data points to trigger the error\n+    for _ in range(3):\n+        plt.ginput(1)\n+\n+    # Checking that no AttributeError is raised\n+    try:\n+        cursor.disconnect()\n+    except AttributeError as e:\n+        pytest.fail(f\"Unexpected AttributeError: {e}\")\n     ta = TextArea(\"foobar\")\n     pb = PaddedBox(ta, pad=15, draw_frame=True)\n     ab = AnchoredOffsetbox('lower right', child=pb)\n-    ax.add_artist(ab)\n+    ax.add_artist(ab)\n",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "",
  "mwaskom__seaborn-3190": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\nindex 72a27ec..b25c8c3 100644\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -83,6 +83,26 @@ class TestContinuous:\n         s = Continuous(norm=(3, 7))._setup(x, IntervalProperty())\n         assert_array_equal(s(x), [-.5, 0, 1.5])\n \n+    def test_color_mapping_with_booleans(self):\n+        # Import necessary modules for the test\n+        import pandas as pd\n+        from matplotlib.colors import to_rgba_array\n+        from numpy.testing import assert_array_equal\n+        from seaborn.utils import color_palette\n+        from seaborn._core.scales import Continuous\n+        from seaborn._core.properties import Color\n+\n+        # Create boolean series for testing\n+        bool_data = pd.Series([True, False, True, False])\n+        \n+        # Set up color mapping using Continuous scale with a boolean data input\n+        cmap = color_palette(\"ch:\", as_cmap=True)\n+        s = Continuous()._setup(bool_data, Color())\n+        \n+        # Verify the mapping output (expecting a normalized mapping for True/False)\n+        expected_colors = cmap([1, 0, 1, 0])[:, :3]  # True -> max color, False -> min color\n+        assert_array_equal(to_rgba_array(s(bool_data))[:, :3], expected_colors)\n+\n     def test_interval_with_range_norm_and_transform(self, x):\n \n         x = pd.Series([1, 10, 100])\n",
  "mwaskom__seaborn-3407": "",
  "pallets__flask-4992": "",
  "psf__requests-1963": "",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..cd98f0e 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1655,6 +1655,44 @@ def test_urllib3_retries():\n     with pytest.raises(RetryError):\n         s.get(httpbin('status/500'))\n \n+\n+import pytest\n+import requests\n+from requests.adapters import HTTPAdapter\n+from requests.exceptions import ConnectionError, Timeout\n+from requests.packages.urllib3.exceptions import DecodeError, TimeoutError\n+\n+def test_urllib3_exceptions_wrapped():\n+    \"\"\"Test that urllib3 exceptions are wrapped by requests exceptions.\"\"\"\n+    session = requests.Session()\n+    adapter = HTTPAdapter()\n+    session.mount('http://', adapter)\n+\n+    # Simulate a DecodeError\n+    original_urlopen = adapter.urlopen\n+    def urlopen_with_decode_error(*args, **kwargs):\n+        raise DecodeError(\"A decode error occurred\")\n+    adapter.urlopen = urlopen_with_decode_error\n+    \n+    with pytest.raises(ConnectionError) as excinfo:\n+        session.get('http://example.com')\n+    assert \"DecodeError\" in str(excinfo.value)\n+    \n+    # Restore the original urlopen method\n+    adapter.urlopen = original_urlopen\n+\n+    # Simulate a TimeoutError\n+    def urlopen_with_timeout_error(*args, **kwargs):\n+        raise TimeoutError(\"A timeout error occurred\")\n+    adapter.urlopen = urlopen_with_timeout_error\n+    \n+    with pytest.raises(Timeout) as excinfo:\n+        session.get('http://example.com', timeout=0.001)\n+    assert \"TimeoutError\" in str(excinfo.value)\n+    \n+    # Restore the original urlopen method\n+    adapter.urlopen = original_urlopen\n+\n def test_vendor_aliases():\n     from requests.packages import urllib3\n     from requests.packages import chardet\n@@ -1663,4 +1701,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "",
  "psf__requests-863": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 0ee4333..0951982 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -743,8 +743,75 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n             assert 'foo' in response.text\n             assert 'bar' in response.text\n+    def test_multiple_hooks_execution_order(self):\n+        \"\"\"Test if multiple hooks are executed in the given order.\"\"\"\n+        call_order = []\n \n-    def test_session_persistent_cookies(self):\n+        def hook_one(args):\n+            call_order.append('hook_one')\n+            return args\n+\n+        def hook_two(args):\n+            call_order.append('hook_two')\n+            return args\n+\n+        # Register hooks\n+        hooks = [hook_one, hook_two]\n+        r = requests.models.Request(hooks={'args': hooks})\n+        r.send()\n+\n+        # Check if hooks are called in the correct order\n+        assert call_order == ['hook_one', 'hook_two'], \"Hooks not called in order\"\n+\n+    def test_mixed_hook_type_error(self):\n+        \"\"\"Test if non-callable types in hook list raise appropriate error.\"\"\"\n+        def valid_hook(args):\n+            return args\n+\n+        hooks = [valid_hook, \"not_callable\"]\n+        r = requests.models.Request()\n+\n+        try:\n+            r.register_hook('args', hooks)\n+            raised = False\n+        except TypeError:\n+            raised = True\n+\n+        assert raised, \"TypeError not raised for non-callable hook\"\n+\n+    def test_register_hooks_individually_vs_together(self):\n+        \"\"\"Test if individually registered hooks behave the same as collectively registered.\"\"\"\n+        call_order_collective = []\n+        call_order_individual = []\n+\n+        def hook_collective_one(args):\n+            call_order_collective.append('hook_one')\n+            return args\n+\n+        def hook_collective_two(args):\n+            call_order_collective.append('hook_two')\n+            return args\n+\n+        def hook_individual_one(args):\n+            call_order_individual.append('hook_one')\n+            return args\n+\n+        def hook_individual_two(args):\n+            call_order_individual.append('hook_two')\n+            return args\n+\n+        # Register collectively\n+        hooks_collective = [hook_collective_one, hook_collective_two]\n+        r_collective = requests.models.Request(hooks={'args': hooks_collective})\n+        r_collective.send()\n+        \n+        # Register individually\n+        r_individual = requests.models.Request()\n+        r_individual.register_hook('args', hook_individual_one)\n+        r_individual.register_hook('args', hook_individual_two)\n+        r_individual.send()\n+\n+        assert call_order_collective == call_order_individual, \"Mismatch in hook execution between collective and individual registration\"\n \n         s = requests.session()\n \n",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..06e7ad9 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -383,7 +383,15 @@ repr_da = xr.DataArray(\n )\n \n \n-@pytest.mark.parametrize(\"dim\", [\"x\", \"y\", \"z\", \"month\"])\n+\n+@pytest.mark.parametrize(\"dim\", [\"x\", \"y\", \"z\", \"month\", \"letters\"])\n+def test_groupby_no_trailing_whitespace(dim):\n+    ds = xr.Dataset(\n+        {\"foo\": ((\"x\", \"y\"), np.random.rand(4, 3))},\n+        coords={\"x\": [10, 20, 30, 40], \"letters\": (\"x\", list(\"abba\"))},\n+    )\n+    actual_str = str(ds.groupby(dim))\n+    assert not actual_str.endswith(\" \\n\"), f\"Trailing whitespace found in: {actual_str}\"\n @pytest.mark.parametrize(\"obj\", [repr_da, repr_da.to_dataset(name=\"a\")])\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n",
  "pylint-dev__pylint-5859": "diff --git a/tests/checkers/unittest_misc.py b/tests/checkers/unittest_misc.py\nindex 460d485..a5a66b3 100644\n--- a/tests/checkers/unittest_misc.py\n+++ b/tests/checkers/unittest_misc.py\n@@ -51,6 +51,25 @@ class TestFixme(CheckerTestCase):\n             MessageTest(msg_id=\"fixme\", line=2, args=\"XXX\", col_offset=17)\n         ):\n             self.checker.process_tokens(_tokenize_str(code))\n+    @set_config(notes=[\"???\"])\n+    def test_punctuation_notes(self) -> None:\n+        code = \"\"\"a = 1\n+                #???\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n+\n+    @set_config(notes=[\"!!!\"])\n+    def test_other_punctuation_notes(self) -> None:\n+        code = \"\"\"a = 1\n+                #!!!\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"!!!\", col_offset=17)\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n \n     def test_xxx_middle(self) -> None:\n         code = \"\"\"a = 1\n@@ -119,4 +138,4 @@ class TestFixme(CheckerTestCase):\n         # Todoist API: Fetch all Tasks\n         \"\"\"\n         with self.assertNoMessages():\n-            self.checker.process_tokens(_tokenize_str(code))\n+            self.checker.process_tokens(_tokenize_str(code))\n",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..2eb8d1a 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -69,6 +69,7 @@ def test_unknown_option_name(capsys: CaptureFixture) -> None:\n         Run([str(EMPTY_MODULE), \"--unknown-option=yes\"], exit=False)\n     output = capsys.readouterr()\n     assert \"E0015: Unrecognized option found: unknown-option=yes\" in output.out\n+    assert \"Traceback\" not in output.err  # Ensure no traceback is present\n \n \n def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n@@ -77,6 +78,7 @@ def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n         Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n     output = capsys.readouterr()\n     assert \"E0015: Unrecognized option found: Q\" in output.out\n+    assert \"Traceback\" not in output.err  # Ensure no traceback is present\n \n \n def test_unknown_confidence(capsys: CaptureFixture) -> None:\n",
  "pylint-dev__pylint-7080": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex fa7078d..e518561 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1324,11 +1324,41 @@ class TestRunTC:\n                 if not os.path.basename(path) == \"regrtest_data\"\n             ]\n             with _test_cwd():\n-                os.chdir(join(HERE, \"regrtest_data\", \"directory\", \"subdirectory\"))\n+                os.chdir(join(HERE, \"regrtest_data\"))\n                 self._runtest(\n-                    [\".\", \"--recursive=y\"],\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^directory/ignored_subdirectory/.*\"],\n                     code=0,\n                 )\n+                # Check if reports are generated for files that should not be ignored\n+                # and ensure there's no report from the ignored path\n+                output = self._runtest(\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^directory/ignored_subdirectory/.*\"],\n+                    code=0,\n+                    return_output=True,\n+                )\n+                self.assertIn(\"test_file.py\", output)\n+                self.assertNotIn(\"ignored_subdirectory\", output)\n+\n+    def test_ignore_path_recursive_current_dir_more_cases(self):\n+        with _test_sys_path():\n+            sys.path = [\n+                path\n+                for path in sys.path\n+                if not os.path.basename(path) == \"regrtest_data\"\n+            ]\n+            with _test_cwd():\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n+                self._runtest(\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^ignored_subdirectory/.*\"],\n+                    code=0,\n+                )\n+                output = self._runtest(\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^ignored_subdirectory/.*\"],\n+                    code=0,\n+                    return_output=True,\n+                )\n+                self.assertIn(\"main.py\", output)\n+                self.assertNotIn(\"ignored_subdirectory\", output)\n \n     def test_regression_recursive_current_dir(self):\n         with _test_sys_path():\n",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..ca58593 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -934,6 +934,36 @@ print(submodule1)\n             linter.check([\"submodule2.py\"])\n     assert not linter.stats.by_msg\n \n+def test_lint_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for issue with module having the same name as the package\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        # Create files and folders to set up the test case\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        \n+        # Checking the directory 'a' which contains a file 'a.py'\n+        linter.check([\"a\"])\n+\n+    # Ensuring there are no parse errors due to missing __init__.py\n+    assert \"parse-error\" not in linter.stats.by_msg\n+\n+def test_lint_import_from_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for import from a module with the same name as the package\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        # Create directory and files\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        \n+        # Write sample import code\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as r_file:\n+            r_file.write(\"from a import b\")\n+\n+        # Running pylint on the scripts\n+        linter.check([\"r.py\", \"a\"])\n+\n+    # Since it's a valid import setup, there should be no import errors\n+    assert \"no-name-in-module\" not in linter.stats.by_msg\n+\n \n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n@@ -941,4 +971,34 @@ def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n+\n+def test_lint_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for issue with module having the same name as the package\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        # Create files and folders to set up the test case\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        \n+        # Checking the directory 'a' which contains a file 'a.py'\n+        linter.check([\"a\"])\n+\n+    # Ensuring there are no parse errors due to missing __init__.py\n+    assert \"parse-error\" not in linter.stats.by_msg\n+\n+def test_lint_import_from_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for import from a module with the same name as the package\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        # Create directory and files\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        \n+        # Write sample import code\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as r_file:\n+            r_file.write(\"from a import b\")\n+\n+        # Running pylint on the scripts\n+        linter.check([\"r.py\", \"a\"])\n+\n+    # Since it's a valid import setup, there should be no import errors\n+    assert \"no-name-in-module\" not in linter.stats.by_msg\n",
  "pylint-dev__pylint-7993": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 6338072..30c960f 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n@@ -112,8 +113,29 @@ def test_template_option_non_existing(linter) -> None:\n     assert out_lines[1] == \"my_mod:1::()\"\n     assert out_lines[2] == \"my_mod:2::()\"\n \n+def test_custom_brace_template(linter: PyLinter) -> None:\n+    \"\"\"Test handling of custom braces in the message template.\"\"\"\n+    output = StringIO()\n+    linter.reporter.out = output\n+    # Using a custom message template based on the user's previous template\n+    linter.config.msg_template = '{{ \"Category\": \"{category}\" }}'\n+    linter.open()\n+    linter.set_current_module(\"my_mod\")\n+    \n+    # Add several message types\n+    linter.add_message(\"C0301\", line=1, args=(1, 2))\n+    linter.add_message(\"E0401\", line=2, args=(3, 4))\n+    linter.add_message(\"W0611\", line=3, args=(5, 6))\n+\n+    out_lines = output.getvalue().split(\"\\n\")\n+    \n+    # Check if the output matches the expected format\n+    assert out_lines[1] == '{ \"Category\": \"convention\" }'\n+    assert out_lines[2] == '{ \"Category\": \"error\" }'\n+    assert out_lines[3] == '{ \"Category\": \"warning\" }'\n+\n \n-def test_deprecation_set_output(recwarn):\n+def test_deprecation_set_output(recwarn: WarningsRecorder) -> None:\n     \"\"\"TODO remove in 3.0.\"\"\"\n     reporter = BaseReporter()\n     # noinspection PyDeprecation\n",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "diff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\nindex 9989033..0042e46 100644\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -288,7 +288,41 @@ class TestImportPath:\n         fn.write_text(\"def foo(x): return 40 + x\", encoding=\"utf-8\")\n         return fn\n \n-    def test_importmode_importlib(self, simple_module: Path, tmp_path: Path) -> None:\n+    import importlib\n+    import pytest\n+    from pytest import Pytester\n+    from typing import Iterator\n+\n+    def test_doctest_and_normal_imports_with_importlib(pytester: Pytester) -> None:\n+        \"\"\"\n+        Regression test for the issue where modules would be imported twice\n+        using import_mode='importlib', causing side effects.\n+        \"\"\"\n+        pytester.makepyfile(\n+            **{\n+                \"pmxbot/commands.py\": \"from . import logging\",\n+                \"pmxbot/logging.py\": \"class Logger:\\n    store = None\",\n+                \"tests/__init__.py\": \"\",\n+                \"tests/test_commands.py\": '''\n+                    import importlib\n+                    from pmxbot import logging\n+\n+                    class TestCommands:\n+                        def test_boo(self):\n+                            assert importlib.import_module('pmxbot.logging') is logging\n+                ''',\n+            }\n+        )\n+        pytester.makeini(\n+            \"\"\"\n+            [pytest]\n+            addopts=\n+                --doctest-modules\n+                --import-mode importlib\n+            \"\"\"\n+        )\n+        result = pytester.runpytest_subprocess()\n+        result.stdout.fnmatch_lines(\"*1 passed*\")\n         \"\"\"`importlib` mode does not change sys.path.\"\"\"\n         module = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n         assert module.foo(2) == 42  # type: ignore[attr-defined]\n",
  "pytest-dev__pytest-5227": "diff --git a/testing/logging/test_formatter.py b/testing/logging/test_formatter.py\nindex 54a08a2..ff4c016 100644\n--- a/testing/logging/test_formatter.py\n+++ b/testing/logging/test_formatter.py\n@@ -1,11 +1,38 @@\n+\n import logging\n \n import py.io\n \n from _pytest.logging import ColoredLevelFormatter\n \n-\n def test_coloredlogformatter():\n+    logfmt = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n+    record = logging.LogRecord(\n+        name=\"dummy\",\n+        level=logging.INFO,\n+        pathname=\"dummypath\",\n+        lineno=10,\n+        msg=\"Test Message\",\n+        args=(),\n+        exc_info=False,\n+    )\n+\n+    class ColorConfigAlt(object):\n+        class option(object):\n+            pass\n+\n+    tw = py.io.TerminalWriter()\n+    tw.hasmarkup = True\n+    formatter = ColoredLevelFormatter(tw, logfmt)\n+    output = formatter.format(record)\n+    assert output == (\n+        \"\\x1b[32mINFO    \\x1b[0m dummy:dummypath:10 Test Message\"\n+    )\n+\n+    tw.hasmarkup = False\n+    formatter = ColoredLevelFormatter(tw, logfmt)\n+    output = formatter.format(record)\n+    assert output == (\"INFO     dummy:dummypath:10 Test Message\")\n     logfmt = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n \n     record = logging.LogRecord(\n",
  "pytest-dev__pytest-5495": "diff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex b05f85c..5fcf006 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -559,8 +559,28 @@ class TestAssert_reprcompare:\n         assert expl[0] == \"'\u00a3\u20ac' == '\u00a3'\"\n         assert expl[1] == \"- \u00a3\u20ac\"\n         assert expl[2] == \"+ \u00a3\"\n+    \n+    def test_bytes_empty_vs_nonempty(self):\n+        \"\"\"Test comparison of an empty byte string with a non-empty one.\"\"\"\n+        diff = callequal(b\"\", b\"42\", verbose=True)\n+        assert diff == [\n+            \"b'' == b'42'\",\n+            \"Right contains more items, first extra item: 52\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'42'\",\n+        ]\n \n-    def test_nonascii_text(self):\n+    def test_bytes_different_first_byte(self):\n+        \"\"\"Test comparison of byte strings differing at the first byte.\"\"\"\n+        diff = callequal(b\"\", b\"1\", verbose=True)\n+        assert diff == [\n+            \"b'' == b'1'\",\n+            \"Right contains more items, first extra item: 49\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'1'\",\n+        ]\n         \"\"\"\n         :issue: 877\n         non ascii python2 str caused a UnicodeDecodeError\n",
  "pytest-dev__pytest-5692": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3392814..dec40e1 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1,4 +1,7 @@\n+\n import os\n+import platform\n+from datetime import datetime\n from xml.dom import minidom\n \n import py\n",
  "pytest-dev__pytest-7168": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 38e0b6b..88bdc70 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -143,6 +143,37 @@ def test_repr_on_newstyle():\n \n     assert saferepr(Function())\n \n+def test_broken_getattribute():\n+    \"\"\"saferepr() can create proper representations of classes with \n+    broken __getattribute__ and __repr__.\n+    \"\"\"\n+\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError(\"broken getattribute\")\n+\n+        def __repr__(self):\n+            raise RuntimeError(\"broken repr\")\n+\n+    result = saferepr(SomeClass())\n+    assert result.startswith(\"<[RuntimeError('broken \")\n+    assert \" raised in \" in result\n+    assert \"SomeClass object at 0x\" in result\n+\n+\n+def test_broken_getattribute_without_repr():\n+    \"\"\"saferepr() handles classes raising exception in __getattribute__\n+    without __repr__ failure.\n+    \"\"\"\n+\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError(\"broken getattribute\")\n+\n+    result = saferepr(SomeClass())\n+    assert result.startswith(\"<SomeClass object at 0x\")\n+    assert \"broken getattribute\" not in result\n+\n \n def test_unicode():\n     val = \"\u00a3\u20ac\"\n@@ -153,4 +184,4 @@ def test_unicode():\n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n-    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n",
  "pytest-dev__pytest-7220": "diff --git a/testing/test_pytester.py b/testing/test_pytester.py\nindex 5ab5242..d968ed2 100644\n--- a/testing/test_pytester.py\n+++ b/testing/test_pytester.py\n@@ -307,6 +307,30 @@ def test_cwd_snapshot(testdir: Testdir) -> None:\n     snapshot.restore()\n     assert py.path.local() == foo\n \n+def test_failure_with_changed_cwd_shows_correct_path(testdir):\n+    \"\"\"Ensure failure lines show correct paths even if cwd changes in a fixture.\"\"\"\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import os\n+        import pytest\n+\n+        @pytest.fixture\n+        def private_dir():\n+            out_dir = 'temp_test_dir'\n+            os.mkdir(out_dir)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+\n+        def test_should_show_correct_path(private_dir):\n+            assert False\n+        \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    # Check if path in error output is correct relative to testdir, not to the changed cwd\n+    result.stdout.fnmatch_lines([str(p) + \":*: AssertionError\", \"*1 failed in *\"])\n+\n \n class TestSysModulesSnapshot:\n     key = \"my-test-module\"\n",
  "pytest-dev__pytest-7373": "",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..ef4a68e 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -219,7 +219,25 @@ class TestXFail:\n         assert str(callreport.longrepr) == \"[XPASS(strict)] nope\"\n         assert not hasattr(callreport, \"wasxfail\")\n \n-    def test_xfail_run_anyway(self, testdir):\n+    @pytest.mark.parametrize(\n+        \"params, expected_lines\",\n+        [\n+            ([\"-rs\"], [\"SKIPPED [1] test_sample.py:2: unconditional skip\", \"*1 skipped*\"]),\n+            ([\"-rs\", \"--runxfail\"], [\"SKIPPED [1] test_sample.py:2: unconditional skip\", \"*1 skipped*\"]),\n+        ],\n+    )\n+    def test_skip_location_with_runxfail(self, testdir, params, expected_lines):\n+        testdir.makepyfile(\n+            test_sample=\"\"\"\n+            import pytest\n+\n+            @pytest.mark.skip\n+            def test_skip_location():\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(*params)\n+        result.stdout.fnmatch_lines(expected_lines)\n         testdir.makepyfile(\n             \"\"\"\n             import pytest\n",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..e3c0cb5 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,7 +1,9 @@\n+\n import sys\n \n import pytest\n from _pytest.runner import runtestprotocol\n+from _pytest.pytester import Testdir\n from _pytest.skipping import evaluate_skip_marks\n from _pytest.skipping import evaluate_xfail_marks\n from _pytest.skipping import pytest_runtest_setup\n@@ -397,7 +399,30 @@ class TestXFail:\n         result = testdir.runpytest(p, \"-rxX\")\n         result.stdout.fnmatch_lines([\"*XFAIL*test_this*\", \"*XPASS*test_that*\"])\n \n-    def test_dynamic_xfail_no_run(self, testdir):\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # Issue #7486.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir: Testdir) -> None:\n+        # Issue #7486.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\", strict=True))\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n         p = testdir.makepyfile(\n             \"\"\"\n             import pytest\n",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..1ababf9 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,13 +1,32 @@\n+\n import os\n import stat\n+def test_tmp_path_factory_handles_invalid_dir_characters_env_var(monkeypatch: MonkeyPatch, tmp_path_factory: TempPathFactory) -> None:\n+    \"\"\"Test tmp_path_factory handling of invalid directory characters in environment variables.\"\"\"\n+    # Simulate an environment variable affecting the username.\n+    monkeypatch.setenv(\"LOGNAME\", \"env\\\\invalid:char\")\n+    monkeypatch.setattr(getpass, \"getuser\", lambda: os.environ[\"LOGNAME\"])\n+    # Invalidate cached _basetemp to force re-evaluation\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"pytest-of-unknown\" in str(p)\n+\n+def test_tmpdir_factory_resilience_with_invalid_chars(monkeypatch: MonkeyPatch, tmpdir_factory: TempdirFactory) -> None:\n+    \"\"\"Test tmpdir_factory when username contains invalid path characters.\"\"\"\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"invalid\\\\user*name?\")\n+    p = tmpdir_factory.mktemp(\"testdir\")\n+    assert p.isdir()  # Directory should be created successfully despite invalid chars\n+\n import sys\n+from _pytest.monkeypatch import MonkeyPatch\n from pathlib import Path\n from typing import Callable\n from typing import cast\n from typing import List\n \n import attr\n-\n+import getpass\n import pytest\n from _pytest import pathlib\n from _pytest.config import Config\n",
  "scikit-learn__scikit-learn-10297": "",
  "scikit-learn__scikit-learn-11281": "diff --git a/sklearn/mixture/tests/test_bayesian_mixture.py b/sklearn/mixture/tests/test_bayesian_mixture.py\nindex a9d82b7..e6c3e7e 100644\n--- a/sklearn/mixture/tests/test_bayesian_mixture.py\n+++ b/sklearn/mixture/tests/test_bayesian_mixture.py\n@@ -15,7 +15,9 @@ from sklearn.mixture import BayesianGaussianMixture\n \n from sklearn.mixture.tests.test_gaussian_mixture import RandomData\n from sklearn.exceptions import ConvergenceWarning\n-from sklearn.utils.testing import assert_greater_equal, ignore_warnings\n+from sklearn.utils.testing import assert_greater_equal, ignore_warnings, assert_in\n+from sklearn.exceptions import NotFittedError\n+from sklearn.utils.testing import assert_raises\n \n \n COVARIANCE_TYPE = ['full', 'tied', 'diag', 'spherical']\n",
  "scikit-learn__scikit-learn-12471": "diff --git a/sklearn/preprocessing/tests/test_encoders.py b/sklearn/preprocessing/tests/test_encoders.py\nindex 3f9b211..2064835 100644\n--- a/sklearn/preprocessing/tests/test_encoders.py\n+++ b/sklearn/preprocessing/tests/test_encoders.py\n@@ -260,6 +260,8 @@ def test_one_hot_encoder_not_fitted():\n         enc.transform(X)\n \n \n+from numpy.testing import assert_array_equal\n+\n def test_one_hot_encoder_no_categorical_features():\n     X = np.array([[3, 2, 1], [0, 1, 1]], dtype='float64')\n \n@@ -272,6 +274,48 @@ def test_one_hot_encoder_no_categorical_features():\n     assert_array_equal(enc.get_feature_names(), expected_features)\n     assert enc.categories_ == []\n \n+def test_one_hot_encoder_handle_unknown_strings_with_shorter_new_category():\n+    X_train = np.array(['short', 'medium', 'longvalue']).reshape((-1, 1))\n+    X_test = np.array(['new', 'short']).reshape((-1, 1))\n+\n+    ohe = OneHotEncoder(handle_unknown='ignore')\n+    ohe.fit(X_train)\n+\n+    # Expected: new category should produce zeros, 'short' is known\n+    expected = np.array([[0., 0., 0.], [1., 0., 0.]])\n+    result = ohe.transform(X_test).toarray()\n+\n+    # Verify that the transform is correct\n+    assert_array_equal(result, expected)\n+\n+def test_one_hot_encoder_handle_unknown_strings_both_short_and_long():\n+    X_train = np.array(['longlong', 'short', 'medium']).reshape((-1, 1))\n+    X_test = np.array(['extra_longer', 'short', 'tiny']).reshape((-1, 1))\n+\n+    ohe = OneHotEncoder(handle_unknown='ignore')\n+    ohe.fit(X_train)\n+\n+    # Transform test array and check for the expected result\n+    expected = np.array([[0., 0., 0.], [1., 0., 0.], [0., 0., 0.]])\n+    result = ohe.transform(X_test).toarray()\n+\n+    # Verify the transform is correct\n+    assert_array_equal(result, expected)\n+\n+def test_one_hot_encoder_handle_unknown_all_new():\n+    X_train = np.array(['largecategory', 'medium']).reshape((-1, 1))\n+    X_test = np.array(['unknown1', 'unknown2']).reshape((-1, 1))\n+\n+    ohe = OneHotEncoder(handle_unknown='ignore')\n+    ohe.fit(X_train)\n+\n+    # Transform test array and check that all are zeros since they are unknown\n+    expected = np.array([[0., 0.], [0., 0.]])\n+    result = ohe.transform(X_test).toarray()\n+\n+    # Verify that the transform results in all zeros\n+    assert_array_equal(result, expected)\n+\n \n @pytest.mark.parametrize(\"output_dtype\", [np.int32, np.float32, np.float64])\n @pytest.mark.parametrize(\"input_dtype\", [np.int32, np.float32, np.float64])\n",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_bayesian_mixture.py b/sklearn/mixture/tests/test_bayesian_mixture.py\nindex 5f947fe..b5fd20a 100644\n--- a/sklearn/mixture/tests/test_bayesian_mixture.py\n+++ b/sklearn/mixture/tests/test_bayesian_mixture.py\n@@ -450,9 +450,17 @@ def test_bayesian_mixture_fit_predict(seed, max_iter, tol):\n         Y_pred2 = bgmm2.fit_predict(X)\n         assert_array_equal(Y_pred1, Y_pred2)\n \n+import numpy as np\n+from sklearn.mixture import BayesianGaussianMixture\n+from sklearn.utils.testing import assert_array_equal\n \n-def test_bayesian_mixture_predict_predict_proba():\n-    # this is the same test as test_gaussian_mixture_predict_predict_proba()\n+def test_bayesian_mixture_fit_predict_n_init():\n+    # Check that fit_predict is equivalent to fit.predict, when n_init > 1\n+    X = np.random.RandomState(0).randn(1000, 5)\n+    gm = BayesianGaussianMixture(n_components=5, n_init=10, random_state=0)\n+    y_pred1 = gm.fit_predict(X)\n+    y_pred2 = gm.predict(X)\n+    assert_array_equal(y_pred1, y_pred2)\n     rng = np.random.RandomState(0)\n     rand_data = RandomData(rng)\n     for prior_type in PRIOR_TYPE:\n",
  "scikit-learn__scikit-learn-13241": "",
  "scikit-learn__scikit-learn-13439": "",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..5b54a78 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -295,6 +296,12 @@ def test_score_samples():\n                        clf2.score_samples([[2., 2.]]))\n \n \n+from sklearn.ensemble import IsolationForest\n+from numpy.testing import assert_equal\n+from numpy.testing import assert_\n+from sklearn.utils import check_random_state\n+import pytest\n+\n @pytest.mark.filterwarnings('ignore:default contamination')\n @pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n def test_deprecation():\n",
  "scikit-learn__scikit-learn-13497": "diff --git a/sklearn/feature_selection/tests/test_mutual_info.py b/sklearn/feature_selection/tests/test_mutual_info.py\nindex f5a2908..5336982 100644\n--- a/sklearn/feature_selection/tests/test_mutual_info.py\n+++ b/sklearn/feature_selection/tests/test_mutual_info.py\n@@ -172,6 +172,24 @@ def test_mutual_info_classif_mixed():\n         # The MI should be the same\n         assert_equal(mi_nn[2], mi[2])\n \n+def test_mutual_info_discrete_features_with_array():\n+    X = np.array([[0, 1, 2],\n+                  [1, 0, 1],\n+                  [2, 2, 0]])\n+    y = np.array([0, 1, 2])\n+    X_csr = csr_matrix(X)\n+    \n+    for mutual_info in (mutual_info_regression, mutual_info_classif):\n+        # Test with indices of discrete features\n+        assert_raises(ValueError, mutual_info, X, y, discrete_features=[1, 3])\n+        mi_indices = mutual_info(X, y, discrete_features=[0, 2], random_state=0)\n+\n+        # Test with boolean mask\n+        assert_raises(IndexError, mutual_info, X, y, discrete_features=[True, True, False, False])\n+        mi_mask = mutual_info(X, y, discrete_features=[True, False, True], random_state=0)\n+\n+        assert_array_equal(mi_indices, mi_mask)\n+\n \n def test_mutual_info_options():\n     X = np.array([[0, 0, 0],\n@@ -197,4 +215,4 @@ def test_mutual_info_options():\n         assert_array_equal(mi_1, mi_2)\n         assert_array_equal(mi_3, mi_4)\n \n-    assert not np.allclose(mi_1, mi_3)\n+    assert not np.allclose(mi_1, mi_3)\n",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..048dd80 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,3 +1,4 @@\n+\n import re\n from pprint import PrettyPrinter\n \n@@ -8,6 +9,8 @@ from sklearn.pipeline import make_pipeline\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.feature_selection import SelectKBest, chi2\n from sklearn import set_config\n+from sklearn.linear_model import LogisticRegressionCV\n+import numpy as np\n \n \n # Ignore flake8 (lots of line too long issues)\n@@ -214,8 +217,14 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n \n     set_config(print_changed_only=False)\n \n-\n-def test_pipeline():\n+def test_logistic_regression_cv_array_parameter():\n+    # Test that LogisticRegressionCV with array parameter does not raise error\n+    set_config(print_changed_only=True)\n+    model = LogisticRegressionCV(Cs=np.array([0.1, 1]))\n+    # This should not throw any error\n+    result = repr(model)\n+    assert \"LogisticRegressionCV\" in result\n+    set_config(print_changed_only=False)\n     # Render a pipeline object\n     pipeline = make_pipeline(StandardScaler(), LogisticRegression(C=999))\n     expected = \"\"\"\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..1064f5c 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,8 +1,10 @@\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n import numpy as np\n-\n+from sklearn.linear_model import LinearRegression\n+from sklearn.ensemble import RandomForestRegressor\n from sklearn.utils.testing import assert_almost_equal, assert_array_equal\n from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_equal\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "diff --git a/sklearn/neighbors/tests/test_nca.py b/sklearn/neighbors/tests/test_nca.py\nindex 3963eca..f116e77 100644\n--- a/sklearn/neighbors/tests/test_nca.py\n+++ b/sklearn/neighbors/tests/test_nca.py\n@@ -160,8 +160,55 @@ def test_params_validation():\n                          .format(n_components, X.shape[1]),\n                          NCA(n_components=n_components).fit, X, y)\n \n+import pytest\n+import numpy as np\n+from sklearn.neighbors import NeighborhoodComponentsAnalysis\n+from sklearn.utils._testing import assert_raises\n+from sklearn.utils._testing import assert_raise_message\n+from sklearn.utils._testing import assert_warns_message\n+from sklearn.exceptions import ConvergenceWarning\n+from sklearn.model_selection import GridSearchCV\n+from sklearn.pipeline import Pipeline\n+from sklearn.neighbors import KNeighborsClassifier\n+\n+\n+@pytest.mark.parametrize('param, value', [\n+    ('n_components', np.int32(3)),\n+    ('n_components', np.int64(3)),\n+    ('max_iter', np.int32(100)),\n+    ('max_iter', np.int64(100)),\n+    ('tol', np.float32(0.0001)),\n+    ('tol', np.float64(0.0001))\n+])\n+def test_parameters_valid_types(param, value):\n+    # check that no error is raised when parameters have numpy integer or\n+    # floating types.\n+    nca = NeighborhoodComponentsAnalysis(**{param: value})\n+\n+    X = np.random.random_sample((100, 10))\n+    y = np.random.randint(2, size=100)\n+\n+    nca.fit(X, y)\n+\n \n-def test_transformation_dimensions():\n+def test_nca_gridsearchcv():\n+    X = np.random.random_sample((100, 10))\n+    y = np.random.randint(2, size=100)\n+\n+    nca = NeighborhoodComponentsAnalysis()\n+    knn = KNeighborsClassifier()\n+\n+    pipe = Pipeline([('nca', nca),\n+                     ('knn', knn)])\n+    \n+    # Test various valid forms of parameter input, including native and numpy float/int types\n+    params = {\n+        'nca__tol': [0.1, 0.5, 1, np.float64(0.1)],\n+        'nca__n_components': [1, 5, np.int32(2)],\n+    }\n+    \n+    gs = GridSearchCV(estimator=pipe, param_grid=params, error_score='raise')\n+    gs.fit(X, y)\n     X = np.arange(12).reshape(4, 3)\n     y = [1, 1, 2, 2]\n \n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..ebcc6d4 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -680,6 +680,26 @@ def test_unicode_kernel():\n                                 random_seed=0)\n \n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for scenario where support_vectors_ could be empty on sparse data\n+    from scipy import sparse\n+    import numpy as np\n+    from sklearn import svm\n+\n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    \n+    # Ensuring no support vectors and no dual coefficients are present\n+    assert model.support_.size == 0\n+    assert model.dual_coef_.nnz == 0\n+    assert model.support_vectors_.shape == (0, X_train.shape[1])\n+\n+\n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n     sparse_gram = sparse.csr_matrix([[1, 0], [0, 1]])\n",
  "scikit-learn__scikit-learn-14983": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex dd52c66..c950a3f 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -972,6 +972,8 @@ def test_leave_one_p_group_out_error_on_fewer_number_of_groups():\n                          LeavePGroupsOut(n_groups=3).split(X, y, groups))\n \n \n+import pytest\n+\n @ignore_warnings\n def test_repeated_cv_value_errors():\n     # n_repeats is not integer or <= 0\n@@ -980,7 +982,17 @@ def test_repeated_cv_value_errors():\n         assert_raises(ValueError, cv, n_repeats=1.5)\n \n \n-def test_repeated_kfold_determinstic_split():\n+@pytest.mark.parametrize(\n+    \"RepeatedCV, expected_repr\",\n+    [\n+        (RepeatedKFold, \"RepeatedKFold(n_splits=5, n_repeats=10, random_state=None)\"),\n+        (RepeatedStratifiedKFold, \"RepeatedStratifiedKFold(n_splits=5, n_repeats=10, random_state=None)\")\n+    ]\n+)\n+def test_repeated_kfold_repr_correctness(RepeatedCV, expected_repr):\n+    \"\"\"Test that RepeatedKFold and RepeatedStratifiedKFold show the correct __repr__ string.\"\"\"\n+    cv = RepeatedCV()\n+    assert repr(cv) == expected_repr\n     X = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]\n     random_state = 258173307\n     rkf = RepeatedKFold(\n",
  "scikit-learn__scikit-learn-15512": "diff --git a/sklearn/cluster/tests/test_affinity_propagation.py b/sklearn/cluster/tests/test_affinity_propagation.py\nindex 5de7c5e..b590695 100644\n--- a/sklearn/cluster/tests/test_affinity_propagation.py\n+++ b/sklearn/cluster/tests/test_affinity_propagation.py\n@@ -140,8 +140,21 @@ def test_affinity_propagation_predict_non_convergence():\n     # In case of non-convergence of affinity_propagation(), the cluster\n     # centers should be an empty array\n     X = np.array([[0, 0], [1, 1], [-2, -2]])\n-\n-    # Force non-convergence by allowing only a single iteration\n+import numpy as np\n+from sklearn.cluster import AffinityPropagation\n+from sklearn.utils._testing import assert_array_equal\n+\n+def test_affinity_propagation_non_convergence_regressiontest():\n+    # Test to verify non-convergence returns the expected labels and center indices\n+    X = np.array([[1, 0, 0, 0, 0, 0],\n+                  [0, 1, 1, 1, 0, 0],\n+                  [0, 0, 1, 0, 0, 1]])\n+    af = AffinityPropagation(affinity='euclidean', max_iter=2).fit(X)\n+    \n+    # Check that labels are -1 when the algorithm does not converge\n+    assert_array_equal(np.array([-1, -1, -1]), af.labels_)\n+    # Check that cluster_centers_indices_ is empty when not converged\n+    assert_array_equal(np.array([], dtype=int), af.cluster_centers_indices_)\n     af = assert_warns(ConvergenceWarning,\n                       AffinityPropagation(preference=-10, max_iter=1).fit, X)\n \n",
  "scikit-learn__scikit-learn-15535": "",
  "scikit-learn__scikit-learn-25500": "diff --git a/sklearn/tests/test_isotonic.py b/sklearn/tests/test_isotonic.py\nindex 5021282..9e4c9ed 100644\n--- a/sklearn/tests/test_isotonic.py\n+++ b/sklearn/tests/test_isotonic.py\n@@ -1,11 +1,16 @@\n+\n import warnings\n import numpy as np\n import pickle\n import copy\n \n import pytest\n-\n-from sklearn.datasets import make_regression\n+import numpy as np\n+import pytest\n+from sklearn.datasets import make_classification, make_regression\n+from sklearn.calibration import CalibratedClassifierCV\n+from sklearn.linear_model import SGDClassifier\n+from sklearn import set_config\n from sklearn.isotonic import (\n     check_increasing,\n     isotonic_regression,\n",
  "scikit-learn__scikit-learn-25570": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex 23e3b97..432bb11 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -2121,6 +2121,35 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n     with pytest.raises(AttributeError, match=\"not provide get_feature_names_out\"):\n         ct.get_feature_names_out()\n \n+@pytest.mark.parametrize(\n+    \"empty_selection\",\n+    [[], np.array([False, False]), [False, False]],\n+    ids=[\"list\", \"bool\", \"bool_int\"],\n+)\n+def test_empty_selection_pandas_output(empty_selection):\n+    \"\"\"Check that pandas output works when there is an empty selection.\n+\n+    Non-regression test for issue regarding ColumnTransformer with pandas output\n+    and empty feature selectors.\n+    \"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+\n+    X = pd.DataFrame([[1.0, 2.2], [3.0, 1.0]], columns=[\"a\", \"b\"])\n+    ct = ColumnTransformer(\n+        [\n+            (\"categorical\", \"passthrough\", empty_selection),\n+            (\"numerical\", StandardScaler(), [\"a\", \"b\"]),\n+        ],\n+        verbose_feature_names_out=True,\n+    )\n+    ct.set_output(transform=\"pandas\")\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"numerical__a\", \"numerical__b\"])\n+\n+    ct.set_params(verbose_feature_names_out=False)\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"a\", \"b\"])\n+\n     # The feature names are prefixed because verbose_feature_names_out=True is default\n     ct.set_output(transform=\"pandas\")\n     X_trans_df0 = ct.fit_transform(X_df)\n@@ -2128,4 +2157,4 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n \n     ct.set_params(verbose_feature_names_out=False)\n     X_trans_df1 = ct.fit_transform(X_df)\n-    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n+    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n",
  "sphinx-doc__sphinx-10325": "diff --git a/tests/roots/test-ext-autodoc/target/inheritance.py b/tests/roots/test-ext-autodoc/target/inheritance.py\nindex ac389bf..bfce2f9 100644\n--- a/tests/roots/test-ext-autodoc/target/inheritance.py\n+++ b/tests/roots/test-ext-autodoc/target/inheritance.py\n@@ -14,4 +14,14 @@ class Base(object):\n class Derived(Base):\n     def inheritedmeth(self):\n         # no docstring here\n-        pass\n+        pass\n+\n+\n+class IgnoredBase:\n+    def ignoredmeth(self):\n+        \"\"\"Ignored method.\"\"\"\n+\n+\n+class MultipleInheritance(Derived, IgnoredBase):\n+    def ownmeth(self):\n+        \"\"\"Own method.\"\"\"\n",
  "sphinx-doc__sphinx-7975": "",
  "sphinx-doc__sphinx-8435": "diff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex 21b6a7e..7271ef5 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -684,6 +684,16 @@ def test_autodoc_typehints_description(app):\n \n @pytest.mark.sphinx('text', testroot='ext-autodoc',\n                     confoverrides={'autodoc_typehints': \"description\"})\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_autodoc_type_aliases_for_variables(app):\n+    # Define aliases and ensure they apply to variables and attributes\n+    app.config.autodoc_type_aliases = {'String': 'example.MyString'}\n+    options = {\"members\": None, \"undoc-members\": None}\n+    actual = do_autodoc(app, 'module', 'target.annotations', options)\n+    assert '.. py:data:: variable' in actual\n+    assert '.. py:attribute:: Foo.attr' in actual\n+    assert ':type: example.MyString' in actual\n+\n def test_autodoc_typehints_description_for_invalid_node(app):\n     text = \".. py:function:: hello; world\"\n     restructuredtext.parse(app, text)  # raises no error\n",
  "sphinx-doc__sphinx-8506": "",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..44c0dc7 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -21,6 +21,8 @@ from sphinx.ext.autodoc import ALL, ModuleLevelDocumenter, Options\n from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n from sphinx.testing.util import SphinxTestApp, Struct  # NOQA\n from sphinx.util.docutils import LoggingReporter\n+import pytest\n+from .test_ext_autodoc import do_autodoc\n \n try:\n     # Enable pyximport to test cython module\n@@ -29,8 +31,18 @@ try:\n except ImportError:\n     pyximport = None\n \n-\n-def do_autodoc(app, objtype, name, options=None):\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_empty_all_no_members(app):\n+    \"\"\"Test that a module with an empty __all__ attribute does not document any members.\"\"\"\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'empty_all_module', options)  \n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: empty_all_module',\n+        '',\n+        'docstring of empty_all module.',\n+        '',\n+    ]\n     if options is None:\n         options = {}\n     app.env.temp_data.setdefault('docname', 'index')  # set dummy docname\n",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..8ddad6f 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -15,6 +16,7 @@ from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tup\n \n import pytest\n \n+from struct import Struct\n from sphinx.util.typing import restify, stringify\n \n \n@@ -44,6 +46,7 @@ def test_restify():\n     assert restify(None) == \":obj:`None`\"\n     assert restify(Integral) == \":class:`numbers.Integral`\"\n     assert restify(Any) == \":obj:`Any`\"\n+    assert restify(Struct) == \":class:`struct.Struct`\"\n \n \n def test_restify_type_hints_containers():\n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..292809d 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1455,10 +1455,31 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n         expected = \"\"\"\\\n :param param1:\n :type param1: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+    \n+    def test_other_parameters_with_napoleon_use_param(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+\n+\"\"\"\n+\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param2** (:class:`MyClass <name.space.MyClass>` instance)\n \"\"\"\n         self.assertEqual(expected, actual)\n \n-    def test_multiple_parameters(self):\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param param2:\n+:type param2: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n         docstring = \"\"\"\\\n Parameters\n ----------\n",
  "sphinx-doc__sphinx-8721": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\nindex d4fba47..ea75e99 100644\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -61,8 +61,19 @@ def test_linkcode(app, status, warning):\n     assert 'http://foobar/cpp/' in stuff\n \n \n-@pytest.mark.sphinx(testroot='ext-viewcode-find')\n-def test_local_source_files(app, status, warning):\n+# Assuming necessary imports like 'pytest' and 'os' at the top of the file\n+\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode', confoverrides={'viewcode_enable_epub': False})\n+def test_viewcode_epub_disabled(app, status, warning):\n+    app.builder.build_all()\n+    # Test that module pages are not generated when viewcode_enable_epub is False\n+    assert not (app.outdir / '_modules/spam/mod1.xhtml').exists()\n+\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode', confoverrides={'viewcode_enable_epub': True})\n+def test_viewcode_epub_enabled(app, status, warning):\n+    app.builder.build_all()\n+    # Test that module pages are generated when viewcode_enable_epub is True\n+    assert (app.outdir / '_modules/spam/mod1.xhtml').exists()\n     def find_source(app, modname):\n         if modname == 'not_a_package':\n             source = (app.srcdir / 'not_a_package/__init__.py').read_text()\n",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..c4cde54 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -354,6 +354,19 @@ def test_args():\n     # but this is ok because cycles imply that only those listed moved\n     assert Permutation(4, 5) == Permutation([0, 1, 2, 3, 5, 4])\n \n+    # Additional tests for non-disjoint cycles\n+    # Test with repeated elements in non-disjoint cycles\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n+    assert Permutation([[0, 1], [1, 2]]) == Permutation([1, 2, 0])\n+    assert Permutation([[0, 1, 2], [0, 2]]) == Permutation([2, 1, 0])\n+    assert Permutation([[0, 2], [0, 1, 2]]) == Permutation([1, 0, 2])\n+    assert Permutation([[0], [1], [2, 3, 2]]) == Permutation([0, 1, 3, 2])\n+\n+    # Test some edge cases\n+    assert Permutation([[0]]) == Permutation([0])\n+    assert Permutation([[1], [1]]) == Permutation([1, 0])\n+    assert Permutation([[]]) == Permutation([0])\n+\n \n def test_Cycle():\n     assert str(Cycle()) == '()'\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py\nindex fa86bc3..413b755 100644\n--- a/sympy/matrices/tests/test_matrices.py\n+++ b/sympy/matrices/tests/test_matrices.py\n@@ -301,7 +301,30 @@ def test_creation():\n     assert c is not Matrix(c)\n \n \n-def test_tolist():\n+def test_stack_zero_dimension_matrices():\n+    # Test hstack with 0 x n matrices\n+    M1 = Matrix.zeros(0, 0)\n+    M2 = Matrix.zeros(0, 1)\n+    M3 = Matrix.zeros(0, 2)\n+    M4 = Matrix.zeros(0, 3)\n+    hstack_result = Matrix.hstack(M1, M2, M3, M4)\n+    assert hstack_result.shape == (0, 6), f\"hstack shape mismatch: {hstack_result.shape}\"\n+\n+    # Test hstack with 1 x n matrices\n+    M1 = Matrix.zeros(1, 0)\n+    M2 = Matrix.zeros(1, 1)\n+    M3 = Matrix.zeros(1, 2)\n+    M4 = Matrix.zeros(1, 3)\n+    hstack_result = Matrix.hstack(M1, M2, M3, M4)\n+    assert hstack_result.shape == (1, 6), f\"hstack shape mismatch: {hstack_result.shape}\"\n+\n+    # Test vstack with n x 0 matrices\n+    M1 = Matrix.zeros(0, 0)\n+    M2 = Matrix.zeros(1, 0)\n+    M3 = Matrix.zeros(2, 0)\n+    M4 = Matrix.zeros(3, 0)\n+    vstack_result = Matrix.vstack(M1, M2, M3, M4)\n+    assert vstack_result.shape == (6, 0), f\"vstack shape mismatch: {vstack_result.shape}\"\n     lst = [[S.One, S.Half, x*y, S.Zero], [x, y, z, x**2], [y, -S.One, z*x, 3]]\n     m = Matrix(lst)\n     assert m.tolist() == lst\n",
  "sympy__sympy-13471": "diff --git a/sympy/utilities/tests/test_pickling.py b/sympy/utilities/tests/test_pickling.py\nindex 52dcc20..d43396b 100644\n--- a/sympy/utilities/tests/test_pickling.py\n+++ b/sympy/utilities/tests/test_pickling.py\n@@ -99,8 +99,16 @@ def test_core_symbol():\n             Symbol(\"_issue_3130\", commutative=False), Wild, Wild(\"x\")):\n         check(c)\n \n+import sys\n+from sympy import symbols, Float\n+import pickle\n \n-def test_core_numbers():\n+def test_pickle_float_cross_version():\n+    # Simulate a pickle dump in Python 2 and load in Python 3 scenario\n+    expr = symbols(\"x\") + Float(1.0)\n+    pickled = pickle.dumps(expr, protocol=2)\n+    unpickled = pickle.loads(pickled)\n+    assert expr == unpickled\n     for c in (Integer(2), Rational(2, 3), Float(\"1.2\")):\n         check(c)\n \n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..af43124 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -263,6 +263,17 @@ def test_coth():\n     assert coth(pi*I/105) == -cot(pi/105)*I\n     assert coth(-pi*I/105) == cot(pi/105)*I\n \n+    # Test cases for coth(log(tan(x))) substitution for integral values of x\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+    integral_values = [2, 3, 5, 6, 8, 9, 11, 12, 13, 15, 18]\n+\n+    for value in integral_values:\n+        result = e.subs(x, value)  # This should not raise any exceptions\n+        print(f\"coth(log(tan({value}))) substitution result:\", result)\n+\n+    # The expressions are verified to at least run without errors.\n+\n     assert coth(2 + 3*I) == coth(2 + 3*I)\n \n     assert coth(x*I) == -cot(x)*I\n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..9e6b4f4 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -187,6 +187,21 @@ def test_col_join():\n                    [0, 0, 1],\n                    [7, 7, 7]])\n \n+def test_issue_13643_col_insert():\n+    import sympy as sm\n+    M = sm.eye(6)\n+    V = 2 * sm.ones(6, 2)\n+    result_matrix = M.col_insert(3, V)\n+    expected_matrix = sm.Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1],\n+    ])\n+    assert result_matrix == expected_matrix\n+\n def test_row_insert():\n     r4 = Matrix([[4, 4, 4]])\n     for i in range(-4, 5):\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..54c4cf5 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -616,7 +616,36 @@ def test_latex_Range():\n     assert latex(Range(-2, -oo, -1)) == r'\\left\\{-2, -3, \\ldots, -\\infty\\right\\}'\n \n \n+import sympy as sp\n+from sympy import latex, oo, SeqFormula, SeqPer, SeqAdd, SeqMul\n+\n def test_latex_sequences():\n+    # Test cases for different types of sequences\n+    k, m, n = sp.symbols('k m n', integer=True)\n+\n+    # Infinite sequence\n+    s1_infinite = SeqFormula(n**2, (n, 0, sp.oo))\n+    assert latex(s1_infinite) == r'\\left\\[0, 1, 4, 9, \\ldots\\right\\]'\n+\n+    # Finite sequence\n+    s2_finite = SeqFormula(n**2, (n, 0, 3))\n+    assert latex(s2_finite) == r'\\left\\[0, 1, 4, 9\\right\\]'\n+\n+    # Periodic sequence\n+    s3_periodic = SeqPer((1, 2))\n+    assert latex(s3_periodic) == r'\\left\\[1, 2, 1, 2, \\ldots\\right\\]'\n+    \n+    # Mixed infinite and periodic\n+    s4_mixed = SeqAdd(s1_infinite, s3_periodic)\n+    assert latex(s4_mixed) == r'\\left\\[1, 3, 5, 11, \\ldots\\right\\]'\n+\n+    # Test with negative infinity \n+    s5_neg_infinite = SeqFormula(n**2, (n, -sp.oo, 0))\n+    assert latex(s5_neg_infinite) == r'\\left\\[\\ldots, 1, 0, 4, 9\\right\\]'\n+\n+    # Testing edge with long finite sequence\n+    s6_long_finite = SeqFormula(n**2, (n, 0, 5))\n+    assert latex(s6_long_finite) == r'\\left\\[0, 1, 4, 9, 16, 25\\right\\]'\n     s1 = SeqFormula(a**2, (0, oo))\n     s2 = SeqPer((1, 2))\n \n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..8379bbf 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +7,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, EX, RR, CC\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n@@ -172,8 +173,30 @@ def test_Domain_preprocess():\n     assert Domain.preprocess('FF(23)') == FF(23)\n     assert Domain.preprocess('GF(23)') == GF(23)\n \n+    assert Domain.preprocess('RR') == RR\n+    assert Domain.preprocess('RR[x]') == RR[x]\n+    assert Domain.preprocess('RR[x,y]') == RR[x, y]\n     raises(OptionError, lambda: Domain.preprocess('Z[]'))\n \n+def test_Poly_domain_issues():\n+    from sympy import symbols\n+    from sympy.polys.polytools import Poly\n+\n+    x, y, z = symbols('x y z')\n+    \n+    # Test that Poly can be created with domain 'RR[y,z]'\n+    poly = Poly(1.2*x*y*z, x, domain='RR[y,z]')\n+    assert str(poly) == \"Poly(1.2*y*z*x, x, domain='RR[y,z]')\"\n+\n+    # Test other variables as generators\n+    poly_xyz = Poly(1.2*x*y*z, y, domain='RR[x,z]')\n+    assert str(poly_xyz) == \"Poly(1.2*x*z*y, y, domain='RR[x,z]')\"\n+\n+    poly_xz = Poly(1.2*x*y*z, z, domain='RR[y,x]')\n+    assert str(poly_xz) == \"Poly(1.2*y*x*z, z, domain='RR[x,y]')\"\n+\n+    raises(OptionError, lambda: Poly(1.2*x*y*z, x, domain='INVALID_DOMAIN'))\n+\n     assert Domain.preprocess('Z[x]') == ZZ[x]\n     assert Domain.preprocess('Q[x]') == QQ[x]\n \n",
  "sympy__sympy-14774": "",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..222ab50 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6111,6 +6111,34 @@ u(\"\"\"\\\n     assert upretty((1/y)*e.j) == ucode_str\n \n \n+def test_pretty_MatAdd_issue_14814():\n+    # Original test patch for issue #14814\n+    n = symbols('n')\n+    x = MatrixSymbol('x', n, n)\n+    y = MatrixSymbol('y*', n, n)\n+    a = symbols('a')\n+    \n+    assert pretty(x + y) == \"x + y*\"\n+    assert pretty(-a*x + -2*y*y) == \"-a*x - 2*y**y*\"\n+\n+    # Additional test cases\n+    z = MatrixSymbol('z', n, n)\n+    \n+    # Test adding more matrices to ensure + is correct\n+    assert pretty(x + y + z) == \"x + y* + z\"\n+    \n+    # Test different expressions involving negative terms\n+    assert pretty(-x + y) == \"-x + y*\"\n+    assert pretty(-x + -y) == \"-x - y*\"\n+    \n+    # Test using more complex symbols in the sum\n+    x_star = MatrixSymbol('x*', n, n)\n+    assert pretty(x_star + y) == \"x* + y*\"\n+    assert pretty(x_star - y) == \"x* - y*\"\n+\n+from sympy import MatrixSymbol, symbols\n+from sympy.printing.pretty import pretty\n+\n def test_MatrixSymbol_printing():\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..b56d6c6 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -724,6 +724,25 @@ def test_dummification():\n     #Test that \\alpha was properly dummified\n     lam = lambdify((alpha, t), 2*alpha + t)\n     assert lam(2, 1) == 5\n+\n+def test_curly_matrix_symbol():\n+    # Issue described: lambdify does not work with curly brace matrix symbol names, even with dummify\n+    from sympy import MatrixSymbol, lambdify\n+    curlyv = MatrixSymbol(\"{v}\", 2, 1)\n+    \n+    # Testing lambdify with curly brace in matrix symbol name\n+    try:\n+        lam = lambdify(curlyv, curlyv)\n+        assert lam(1) == 1\n+    except SyntaxError:\n+        print(\"Test failed for curlyv without dummify\")\n+\n+    # Testing lambdify with curly brace in matrix symbol and dummify=True\n+    try:\n+        lam_dummify = lambdify(curlyv, curlyv, dummify=True)\n+        assert lam_dummify(1) == 1\n+    except SyntaxError:\n+        print(\"Test failed for curlyv with dummify=True\")\n     raises(SyntaxError, lambda: lambdify(F(t) * G(t), F(t) * G(t) + 5))\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 2 * F(t) + 5))\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 4 * F(t) + 5))\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..d3736c9 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n@@ -26,6 +27,12 @@ def test_Rational():\n \n def test_Function():\n     assert mcode(f(x, y, z)) == \"f[x, y, z]\"\n+    assert mcode(Max(x, 2)) == \"Max[x, 2]\"\n+    assert mcode(Max(2, x)) == \"Max[2, x]\"\n+    assert mcode(Max(x + 1, x - 1)) == \"Max[x + 1, x - 1]\"\n+    assert mcode(Max(x, y, 2)) == \"Max[x, y, 2]\"\n+    assert mcode(Min(x, 2)) == \"Min[x, 2]\"\n+    assert mcode(Max(Max(x, 2), y)) == \"Max[Max[x, 2], y]\"\n     assert mcode(sin(x) ** cos(x)) == \"Sin[x]^Cos[x]\"\n     assert mcode(conjugate(x)) == \"Conjugate[x]\"\n \n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..a3b3edf 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1717,6 +1717,8 @@ def test_issue_13651():\n     assert latex(expr) == r\"c - \\left(a + b\\right)\"\n \n \n+from sympy import symbols, MatrixSymbol, latex\n+\n def test_latex_UnevaluatedExpr():\n     x = symbols(\"x\")\n     he = UnevaluatedExpr(1/x)\n@@ -1726,7 +1728,13 @@ def test_latex_UnevaluatedExpr():\n     assert latex(x*he) == r\"x \\frac{1}{x}\"\n \n \n-def test_MatrixElement_printing():\n+def test_indexed_matrix_expression_latex():\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    \n+    # Test the corrected LaTeX output for the matrix multiplication element\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n     # test cases for issue #11821\n     A = MatrixSymbol(\"A\", 1, 3)\n     B = MatrixSymbol(\"B\", 1, 3)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..801978c 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, exp, Eq\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -21,7 +22,25 @@ def test_idiff():\n     assert idiff(x + t + y, [y, t], x) == -Derivative(t, x) - 1\n \n \n-def test_intersection():\n+def test_idiff_issue_cases():\n+    x = Symbol('x', real=True)\n+    y = Symbol('y', real=True)\n+    f = Function('f')\n+    g = Function('g')\n+\n+    # Test case 1: Verify idiff supports Eq\n+    assert idiff(Eq(y * exp(y), x * exp(x)), y, x).simplify() == (x + 1) * exp(x - y) / (y + 1)\n+    \n+    # Test case 2: Verify idiff supports f(x) instead of y\n+    assert idiff(f(x) * exp(f(x)) - x * exp(x), f(x), x).simplify() == (x + 1) * exp(x - f(x)) / (f(x) + 1)\n+\n+    # Test case 3: More complex expressions with idiffs\n+    assert idiff(f(x) - y * exp(x), [f(x), y], x) == (y + Derivative(y, x)) * exp(x)\n+    assert idiff(f(x) - y * exp(x), [y, f(x)], x) == -y + exp(-x) * Derivative(f(x), x)\n+    assert idiff(f(x) - g(x), [f(x), g(x)], x) == Derivative(g(x), x)\n+\n+    # Edge test case: when f(x) is not present\n+    assert idiff(x * exp(x) - g(x), g(x), x).simplify() == (x + 1) * exp(x - g(x)) / Derivative(g(x), x)\n     assert intersection(Point(0, 0)) == []\n     raises(TypeError, lambda: intersection(Point(0, 0), 3))\n     assert intersection(\n",
  "sympy__sympy-16792": "",
  "sympy__sympy-16988": "",
  "sympy__sympy-17022": "",
  "sympy__sympy-17139": "diff --git a/sympy/simplify/tests/test_fu.py b/sympy/simplify/tests/test_fu.py\nindex 135b4cd..6cb045a 100644\n--- a/sympy/simplify/tests/test_fu.py\n+++ b/sympy/simplify/tests/test_fu.py\n@@ -66,9 +66,14 @@ def test_TR3():\n         i = f(3*pi/7)\n         j = TR3(i)\n         assert verify_numerically(i, j) and i.func != j.func\n-\n-\n-def test__TR56():\n+# Additional imports, if necessary\n+from sympy import I, Symbol, cos, simplify\n+\n+def test_issue_17137_fu():\n+    # Test simplification of complex powers that were failing\n+    x = Symbol('x')\n+    assert simplify(cos(x)**I) == cos(x)**I\n+    assert simplify(cos(x)**(2 + 3*I)) == cos(x)**(2 + 3*I)\n     h = lambda x: 1 - x\n     assert T(sin(x)**3, sin, cos, h, 4, False) == sin(x)**3\n     assert T(sin(x)**10, sin, cos, h, 4, False) == sin(x)**10\n",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..6f00297 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,12 +1,32 @@\n+\n from sympy import I, Rational, Symbol, pi, sqrt, S\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n-from sympy.utilities.pytest import raises, warns\n-\n-\n-def test_point():\n+import sympy\n+\n+def test_issue_regression():\n+    from sympy import geometry as ge\n+    \n+    point1 = ge.Point(0, 0)\n+    point2 = ge.Point(1, 1)\n+\n+    # Original issue's working line\n+    result1 = point1 + point2 * sympy.sympify(2.0)\n+    assert result1 == ge.Point(2, 2)\n+\n+    # The line that caused the issue initially; it should work now\n+    result2 = point1 + sympy.sympify(2.0) * point2\n+    assert result2 == ge.Point(2, 2)\n+\n+    # Additional checks to ensure similar properties hold\n+    point3 = ge.Point(2, 3)\n+    factor = sympy.sympify(1.5)\n+    \n+    # Symmetric multiplication\n+    assert point3 * factor == factor * point3\n+    assert point3 * factor == ge.Point(3.0, 4.5)\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..bbd2064 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1894,6 +1894,36 @@ def test_normal():\n     assert e.normal() == e\n \n \n+from sympy import symbols, Symbol, sympify\n+from sympy.core.expr import Expr\n+from sympy.utilities.pytest import raises\n+\n+class TestSymbolEquality:\n+\n+    def test_no_eval_in_eq(self):\n+        class C:\n+            def __repr__(self):\n+                return 'x.y'\n+\n+        x = symbols('x')\n+        c = C()\n+        \n+        # this should not evaluate the repr of c\n+        assert (x == c) is False\n+        assert (x != c) is True\n+\n+    def test_repr_equal_symbol(self):\n+        class C:\n+            def __repr__(self):\n+                return 'x'\n+\n+        x = symbols('x')\n+        c = C()\n+\n+        # this should not incorrectly evaluate to True\n+        assert (x == c) is False\n+        assert (x != c) is True\n+\n def test_expr():\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n@@ -1902,4 +1932,4 @@ def test_expr():\n def test_ExprBuilder():\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..2c2cee7 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -553,8 +553,21 @@ def test_diophantine():\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n     assert diophantine((y**2-x), t) == set([(t**2, -t)])\n \n+def test_permute_diophantine():\n+    from sympy.solvers.diophantine import diophantine\n+    from sympy.abc import m, n\n \n-def test_general_pythagorean():\n+    # Test original issue (inconsistent results with permute=True and different syms order)\n+    issue_equation = n**4 + m**4 - 2**4 - 3**4\n+\n+    # Different orders of symbols, with permute=True should yield the same results\n+    expected_result = {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n+\n+    result_1 = diophantine(issue_equation, syms=(m, n), permute=True)\n+    result_2 = diophantine(issue_equation, syms=(n, m), permute=True)\n+\n+    assert result_1 == expected_result, f\"Test failed for syms order (m, n): {result_1}\"\n+    assert result_2 == expected_result, f\"Test failed for syms order (n, m): {result_2}\"\n     from sympy.abc import a, b, c, d, e\n \n     assert check_solutions(a**2 + b**2 + c**2 - d**2)\n",
  "sympy__sympy-18532": "diff --git a/sympy/codegen/tests/test_cnodes.py b/sympy/codegen/tests/test_cnodes.py\nindex c30dccd..3a2bb52 100644\n--- a/sympy/codegen/tests/test_cnodes.py\n+++ b/sympy/codegen/tests/test_cnodes.py\n@@ -1,6 +1,8 @@\n+\n from sympy.core.symbol import symbols\n from sympy.printing.ccode import ccode\n from sympy.codegen.ast import Declaration, Variable, float64, int64\n+from sympy.core import Add, Mul, Symbol\n from sympy.codegen.cnodes import (\n     alignof, CommaOperator, goto, Label, PreDecrement, PostDecrement, PreIncrement, PostIncrement,\n     sizeof, union, struct\n@@ -66,7 +68,24 @@ def test_sizeof():\n     assert ccode(sz) == 'sizeof(%s)' % typename\n     assert sz.func(*sz.args) == sz\n     assert not sz.is_Atom\n-    assert all(atom == typename for atom in sz.atoms())\n+    assert sz.atoms() == {String(typename)}\n+\n+def test_atomics_expression():\n+    # Test with atomic expressions\n+    x = Symbol('x')\n+    expr = x + 2\n+    assert expr.atoms() == {x, 2}\n+\n+    expr = x * 3\n+    assert expr.atoms() == {x, 3}\n+\n+    # Test with deeper tree\n+    expr = Add(Mul(x, 3), 5)\n+    assert expr.atoms() == {x, 3, 5}\n+\n+    # Complex expression\n+    expr = Add(Mul(x, x), Mul(x, 3), 5)\n+    assert expr.atoms() == {x, 3, 5}\n \n \n def test_struct():\n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..3ffeca8 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,30 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_single_element_BlockDiagMatrix():\n+    from sympy import Matrix, BlockDiagMatrix\n+\n+    # Test conversion of a single block matrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    \n+    # Attempt to convert BlockDiagMatrix back to regular Matrix\n+    try:\n+        B = Matrix(D)\n+        assert B == M, \"The conversion should match the original matrix\"\n+    except TypeError as e:\n+        assert False, f\"Conversion raised an unexpected TypeError: {e}\"\n+\n+    # Test conversion of a two-block matrix (control case)\n+    D2 = BlockDiagMatrix(M, M)\n+    B2 = Matrix(D2)\n+    assert B2 == Matrix([\n+        [1, 2, 0, 0],\n+        [3, 4, 0, 0],\n+        [0, 0, 1, 2],\n+        [0, 0, 3, 4]\n+    ]), \"Conversion of two-block matrix did not produce expected result\"\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..0bfb986 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n@@ -83,7 +84,21 @@ def test_block_index():\n     assert BI.as_explicit().equals(eye(6))\n \n \n-def test_slicing():\n+def test_block_index_bugs():\n+    # Reproducing the reported issue with symbolic index in BlockMatrix\n+\n+    n, i = symbols('n, i', integer=True)\n+    A = MatrixSymbol('A', 1, 1)\n+    B = MatrixSymbol('B', n, 1)\n+    C = BlockMatrix([[A], [B]])\n+\n+    # Verify that symbolic index does not simplify incorrectly\n+    assert C[i, 0] == MatrixElement(C, i, 0)\n+\n+    # Additional variations to test correct functionality\n+    assert C[0, 0] == A[0, 0]  # first element from A\n+    assert C[n, 0] == B[0, 0]  # first element from B\n+    assert C[n + i - 1, 0] == MatrixElement(C, n + i - 1, 0)  # stays unsimplified when symbolic\n     A.as_explicit()[0, :]  # does not raise an error\n \n \n",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..b13d2e7 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -302,7 +302,30 @@ def test_sign():\n     assert sign(x).rewrite(Heaviside) == 2*Heaviside(x, H0=S(1)/2) - 1\n     assert sign(y).rewrite(Heaviside) == sign(y)\n \n-    # evaluate what can be evaluated\n+    # Test cases for rewriting `sign` in terms of `Abs`\n+    \n+    # Test for real symbol x\n+    x = Symbol('x', real=True)\n+    assert sign(x).rewrite(Abs) == Piecewise((0, Eq(x, 0)), (x/Abs(x), True))\n+    \n+    # Test for general symbol y\n+    y = Symbol('y')\n+    assert sign(y).rewrite(Abs) == Piecewise((0, Eq(y, 0)), (y/Abs(y), True))\n+\n+    # Test for specific constant zero\n+    assert sign(0).rewrite(Abs) == Piecewise((0, True))\n+    \n+    # Test for a function f(y)\n+    f = Function('f')\n+    assert sign(f(y)).rewrite(Abs) == Piecewise((0, Eq(f(y), 0)), (f(y)/Abs(f(y)), True))\n+    \n+    # Test for a negative number\n+    assert sign(-5).rewrite(Abs) == -1\n+    \n+    # Test for a positive number\n+    assert sign(5).rewrite(Abs) == 1\n+\n+    # Evaluate what can be evaluated\n     assert sign(exp_polar(I*pi)*pi) is S.NegativeOne\n \n     eq = -sqrt(10 + 6*sqrt(3)) + sqrt(1 + sqrt(3)) + sqrt(3 + 3*sqrt(3))\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..d504b13 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -470,8 +470,27 @@ def test_multiset_permutations():\n         [1, 1, 0, 0, 0]\n         6\\n''')\n \n-\n-def test_partitions():\n+from sympy.utilities.iterables import partitions\n+\n+def test_partitions_issue():\n+    # Convert partitions to a list and verify uniqueness by comparing the ids\n+    p_list = [p.copy() for p in partitions(6, k=2)]\n+    ids = [id(p) for p in p_list]  # Collect ids of dictionaries\n+    assert len(ids) == len(set(ids))  # Ensure all partitions are unique objects\n+\n+    # Verify with another example\n+    p_list = [p.copy() for p in partitions(6, m=3)]\n+    ids = [id(p) for p in p_list]\n+    assert len(ids) == len(set(ids)) \n+\n+    # Further verification\n+    p_list = [p.copy() for p in partitions(5)]\n+    ids = [id(p) for p in p_list]\n+    assert len(ids) == len(set(ids))\n+\n+    # Check that copy behaves correctly\n+    original = [p for p in partitions(4, k=2)]\n+    assert [p.copy() for p in original] == [{2: 2}, {1: 2, 2: 1}, {1: 4}]\n     ans = [[{}], [(0, {})]]\n     for i in range(2):\n         assert list(partitions(0, size=i)) == ans[i]\n",
  "sympy__sympy-20212": "diff --git a/sympy/core/tests/test_power.py b/sympy/core/tests/test_power.py\nindex 686973b..9bae345 100644\n--- a/sympy/core/tests/test_power.py\n+++ b/sympy/core/tests/test_power.py\n@@ -253,8 +253,12 @@ def test_power_rewrite_exp():\n     assert all((1/func(x)).rewrite(exp) == 1/(func(x).rewrite(exp)) for func in\n                     (sin, cos, tan, sec, csc, sinh, cosh, tanh))\n \n+from sympy import S, oo, zoo\n \n def test_zero():\n+    # Test for issue with 0 raised to -oo\n+    assert 0 ** -S.Infinity == S.ComplexInfinity\n+    assert Pow(0, -oo) == zoo\n     x = Symbol('x')\n     y = Symbol('y')\n     assert 0**x != 0\n",
  "sympy__sympy-20442": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 6a8906d..1df20c2 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (Abs, Add, Function, Number, Rational, S, Symbol,\n                    diff, exp, integrate, log, sin, sqrt, symbols)\n from sympy.physics.units import (amount_of_substance, convert_to, find_unit,\n@@ -41,7 +42,11 @@ def test_convert_to():\n     # assert (2*speed_of_light).convert_to(m / s) == 2 * 299792458 * m / s\n     assert day.convert_to(s) == 86400*s\n \n-    # Wrong dimension to convert:\n+    # Test conversion of incompatible units, expecting original expression back:\n+    from sympy.physics.units import joule\n+\n+    expr = joule * second\n+    assert convert_to(expr, joule) == joule * second\n     assert q.convert_to(s) == q\n     assert speed_of_light.convert_to(m) == speed_of_light\n \n",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..a935452 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -28,6 +28,19 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+from sympy import Symbol\n+\n+def test_symbol_dict_absence():\n+    \"\"\"Test to ensure that Symbol does not have a __dict__ attribute.\"\"\"\n+    s = Symbol('s')\n+    assert not hasattr(s, '__dict__'), 'Symbol instance should not have a __dict__ attribute'\n+\n+def test_symbol_slots():\n+    \"\"\"Test to ensure that Symbol uses __slots__ and check its content.\"\"\"\n+    s = Symbol('s')\n+    assert hasattr(s, '__slots__'), 'Symbol should have __slots__ attribute'\n+    assert s.__slots__ == ('name',), 'Symbol __slots__ content is incorrect'\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..1e0d0c5 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,5 +1,6 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n-                   atan, atan2, nan, Symbol, re, im, sign)\n+                   atan, atan2, nan, Symbol, re, im, sign, sin, Integral, oo)\n from sympy.abc import w, x, y, z\n from sympy.core.relational import Eq, Ne\n from sympy.functions.elementary.piecewise import Piecewise\n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..3e8cd4e 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -20,6 +21,31 @@ def test_subs():\n     assert e == Rational(6)\n \n \n+def test_issue_21373():\n+    from sympy.functions.elementary.trigonometric import sinh\n+    from sympy.functions.elementary.piecewise import Piecewise\n+\n+    # Replicate the original issue with real symbols\n+    x_r, y_r, z_r = symbols('x_r y_r z_r', real=True)\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    \n+    # Check that substitution doesn't raise a PolynomialError\n+    assert expr.subs({1: 1.0}).func == exp\n+\n+    # Additional cases for cosh and tanh\n+    expr_cosh = exp(cosh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr_cosh.subs({1: 1.0}).func == exp\n+\n+    expr_tanh = exp(tanh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr_tanh.subs({1: 1.0}).func == exp\n+\n+    # Check modifications that reportedly make the error go away\n+    expr_no_div = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True))))\n+    assert expr_no_div.subs({1: 1.0}).func == exp\n+\n+    expr_no_exp = sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r)\n+    assert expr_no_exp.subs({1: 1.0}).func == sinh\n+\n def test_subs_Matrix():\n     z = zeros(2)\n     z1 = ZeroMatrix(2, 2)\n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..f9ad90a 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n@@ -5,6 +6,7 @@ from sympy.core.numbers import pi, zoo, I, AlgebraicNumber\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n from sympy.integrals.integrals import Integral\n+from sympy.core.function import Derivative\n from sympy.matrices import (Matrix, SparseMatrix, ImmutableMatrix,\n     ImmutableSparseMatrix, MatrixSymbol, MatrixKind, MatMul)\n \n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..7f1641c 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -131,6 +131,20 @@ def test_monomials():\n     assert set(itermonomials([x, y], [2, 2])) == \\\n             {S.One, y**2, x*y**2, x, x*y, x**2, x**2*y**2, y, x**2*y}\n \n+    # Test case for issue described: test with three variables and min_degree equal to max_degree\n+    x1, x2, x3 = symbols('x1 x2 x3')\n+    assert set(itermonomials([x1, x2, x3], 3, 3)) == {x1**3, x2**3, x3**3, x1*x2**2, x2*x3**2, x1*x3**2,\n+                                                      x1**2*x2, x1**2*x3, x2**2*x3, x1*x2*x3}\n+    \n+    # Test case with three variables and a range of min and max degrees\n+    assert set(itermonomials([x1, x2, x3], 4, 2)) == {x1**2, x2**2, x3**2, x1*x2, x1*x3, x2*x3,\n+                                                      x1**3, x2**3, x3**3, x1**2*x2, x1*x2**2, x1**2*x3,\n+                                                      x1*x3**2, x2**2*x3, x2*x3**2, x1*x2*x3, x1**4,\n+                                                      x2**4, x3**4, x1**3*x2, x1**3*x3, x1*x2**3, x1*x3**3,\n+                                                      x2**3*x3, x2*x3**3, x1**2*x2**2, x1**2*x3**2, x2**2*x3**2,\n+                                                      x1**2*x2*x3, x1*x2**2*x3, x1*x2*x3**2}\n+    \n+    # Test case with non-zero min degrees\n     i, j, k = symbols('i j k', commutative=False)\n     assert set(itermonomials([i, j, k], [0, 0, 0])) == {S.One}\n     assert set(itermonomials([i, j, k], [0, 0, 1])) == {1, k}\n",
  "sympy__sympy-22005": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 341f63c..e31d7a3 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n@@ -45,6 +46,15 @@ def test_solve_poly_system():\n         [x + x*y - 3, y + x*y - 4], x, y) == [(-3, -2), (1, 2)]\n \n     raises(NotImplementedError, lambda: solve_poly_system([x**3 - y**3], x, y))\n+    \n+    # Test cases for infinite solution request detection\n+    raises(NotImplementedError, lambda: solve_poly_system([x - 1], x, y))\n+    raises(NotImplementedError, lambda: solve_poly_system([y - 1], x, y))\n+    raises(NotImplementedError, lambda: solve_poly_system([x - 1, y - 2], x, y))\n+    raises(NotImplementedError, lambda: solve_poly_system([x*y - 1], x, y))\n+    \n+    # Confirm that zero-dimensional systems with more than one variable are handled\n+    assert solve_poly_system([x - 1, y - 2], x, y) == [(1, 2)]\n     raises(NotImplementedError, lambda: solve_poly_system(\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\n     raises(PolynomialError, lambda: solve_poly_system([1/x], x))\n",
  "sympy__sympy-22714": "",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..af8f064 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -338,6 +338,25 @@ def test_cse_Indexed():\n     assert len(replacements) > 0\n \n \n+from sympy import symbols, MatrixSymbol, Matrix, cse\n+\n+def test_cse_MatrixSymbol_indexing():\n+    # Test to ensure cse handles MatrixSymbol indexing correctly\n+    A = MatrixSymbol(\"A\", 4, 4)\n+    B = MatrixSymbol(\"B\", 4, 4)\n+\n+    expr = A[0,0] * B[0,0] + A[0,1] * B[1,0] + A[0,2] * B[2,0] + A[0,3] * B[3,0]\n+    cse_subs, cse_reduced = cse(expr)\n+    assert cse_reduced == [A[0,0] * B[0, 0] + A[0, 1] * B[1, 0] + A[0, 2] * B[2, 0] + A[0, 3] * B[3, 0]]\n+    assert len(cse_subs) > 0\n+\n+    # Additional test to verify more complex expression\n+    expr2 = A[0, 0]*A[0, 1] + A[0, 0]*A[0, 1]*A[0, 2]\n+    cse_subs, cse_reduced = cse(expr2)\n+    assert cse_reduced == [cse_subs[0][0] * A[0, 2] + cse_subs[0][0]]\n+\n+test_cse_MatrixSymbol_indexing()\n+\n def test_cse_MatrixSymbol():\n     # MatrixSymbols have non-Basic args, so make sure that works\n     A = MatrixSymbol(\"A\", 3, 3)\n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..d5b35ed 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -37,8 +38,12 @@ def test_array_negative_indices():\n \n         assert test_array[-1, -1] == 10\n \n-\n-def test_issue_18361():\n+def test_empty_array_creation():\n+    for array_type in array_types:\n+        A = array_type([])\n+        assert isinstance(A, array_type)\n+        assert A.shape == (0,)\n+        assert list(A) == []\n     A = Array([sin(2 * x) - 2 * sin(x) * cos(x)])\n     B = Array([sin(x)**2 + cos(x)**2, 0])\n     C = Array([(x + x**2)/(x*sin(y)**2 + x*cos(y)**2), 2*sin(x)*cos(x)])\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..30438df 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,7 +1175,17 @@ def test_scipy_polys():\n \n \n \n-def test_lambdify_inspect():\n+import inspect\n+from sympy import lambdify\n+\n+def test_issue_tuple_single_element():\n+    # Test case for the issue where a single-element tuple is incorrectly printed\n+    f = lambdify([], (1,))\n+    assert f() == (1,)\n+    \n+    # Verify the source code to ensure it has the correct tuple representation\n+    source_code = inspect.getsource(f)\n+    assert 'return (1,)' in source_code\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n     # details\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..c676a8e 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -528,6 +528,29 @@ def test_issue_22819():\n     assert Da.scale_factor == 1.66053906660000e-24\n \n \n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second, Quantity\n+    from sympy import exp\n+    from sympy.physics.units.systems.si import SI\n+    from sympy.physics.units.dimensions import Dimension\n+\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n+\n def test_issue_20288():\n     from sympy.core.numbers import E\n     from sympy.physics.units import energy\n",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..b880a48 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -45,8 +45,27 @@ def test_tensor_product_expand():\n     assert TP(A + B, B + C).expand(tensorproduct=True) == \\\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n-\n-def test_tensor_product_commutator():\n+def test_new_tensor_product_expansion_issue():\n+    # Test the fix of tensor product expansion related to scalar factors\n+    from sympy.physics.quantum import TensorProduct as TP, Operator\n+    U = Operator('U')\n+    V = Operator('V')\n+    \n+    # Test case from the issue description\n+    P = TP(2*U - V, U + V)\n+    expected = TP(2*U, U) + TP(2*U, V) - TP(V, U) - TP(V, V)\n+    assert P.expand(tensorproduct=True) == expected\n+\n+    # Test the original patch example given in the issue\n+    A = Operator('A')\n+    B = Operator('B')\n+    assert TP(A-B, B-A).expand(tensorproduct=True) == TP(A, B) - TP(A, A) - TP(B, B) + TP(B, A)\n+    assert TP(2*A + B, A + B).expand(tensorproduct=True) == 2 * TP(A, A) + 2 * TP(A, B) + TP(B, A) + TP(B, B)\n+    assert TP(2 * A * B + A, A + B).expand(tensorproduct=True) == 2 * TP(A*B, A) + 2 * TP(A*B, B) + TP(A, A) + TP(A, B)\n+    \n+    # Additional tests to ensure the fix is robust\n+    assert TP(3*A, 3*B).expand(tensorproduct=True) == 9 * TP(A, B)  # Scalability test\n+    assert TP(0*A, B).expand(tensorproduct=True) == 0  # Zero factor should result in zero\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n         TP(A*B, C) - TP(B*A, C)\n     assert Comm(TP(A, B), TP(B, C)).doit() == \\\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..fc03037 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -561,6 +562,52 @@ def test_issue_24062():\n     exp_expr = 1 + exp(expr)\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n+def test_issue_24211():\n+    from sympy.physics.units import Quantity, time, velocity, acceleration, second, meter, SI\n+    \n+    # Original test case to verify the fix.\n+    V1 = Quantity('V1')\n+    SI.set_quantity_dimension(V1, velocity)\n+    SI.set_quantity_scale_factor(V1, 1 * meter / second)\n+    \n+    A1 = Quantity('A1')\n+    SI.set_quantity_dimension(A1, acceleration)\n+    SI.set_quantity_scale_factor(A1, 1 * meter / second**2)\n+    \n+    T1 = Quantity('T1')\n+    SI.set_quantity_dimension(T1, time)\n+    SI.set_quantity_scale_factor(T1, 1 * second)\n+    \n+    expr = A1*T1 + V1\n+    # Should not throw ValueError\n+    SI._collect_factor_and_dimension(expr)\n+    \n+    # Additional test cases\n+    # Test combination of more quantities with equivalent dimensions\n+    T2 = Quantity('T2')\n+    SI.set_quantity_dimension(T2, time)\n+    SI.set_quantity_scale_factor(T2, 2 * second)\n+\n+    A2 = Quantity('A2')\n+    SI.set_quantity_dimension(A2, acceleration)\n+    SI.set_quantity_scale_factor(A2, 9.8 * meter / second**2)\n+    \n+    expr2 = A1*T1 + A2*T2 + V1\n+    # Should not throw ValueError when adding more compatible terms\n+    SI._collect_factor_and_dimension(expr2)\n+    \n+    # Testing the case with purely dimensionless factor\n+    Q1 = Quantity('Q1')\n+    SI.set_quantity_dimension(Q1, dimensionless)\n+    SI.set_quantity_scale_factor(Q1, 1)\n+\n+    Q2 = Quantity('Q2')\n+    SI.set_quantity_dimension(Q2, dimensionless)\n+    SI.set_quantity_scale_factor(Q2, 2)\n+\n+    expr_dimensionless = Q1 + Q2\n+    # Should not raise error since both are dimensionless\n+    SI._collect_factor_and_dimension(expr_dimensionless)\n \n def test_prefixed_property():\n     assert not meter.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..8e4aa71 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, milli, volt\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n@@ -27,6 +28,14 @@ def test_prefix_operations():\n     assert k / dodeca == S(1000) / 12\n     assert dodeca / dodeca == 1\n \n+    # Additional test cases for milli prefix usage\n+    assert milli * W == milli * watt  # Test milli-Watt conversion\n+    assert milli * volt == milli * volt  # Test milli-Volt conversion\n+\n+    # Ensure the resulting scales and symbols\n+    assert str(milli * W) == 'milli*watt'\n+    assert str(milli * volt) == 'milli*volt'\n+\n     m = Quantity(\"fake_meter\")\n     SI.set_quantity_dimension(m, S.One)\n     SI.set_quantity_scale_factor(m, S.One)\n",
  "django__django-12470": "",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..a4d150f 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,6 +343,47 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n+    def test_self_referencing_fk_order_by_record_root_id(self):\n+        # Create OneModel instances that self-reference.\n+        original_author = Author.objects.create(name=\"Original Author\")\n+        author_1 = Author.objects.create(name=\"Author 1\", editor=original_author)\n+        author_2 = Author.objects.create(name=\"Author 2\", editor=author_1)\n+        \n+        # Create two Article instances.\n+        article1 = Article.objects.create(headline=\"Article 1\", author=author_1)\n+        article2 = Article.objects.create(headline=\"Article 2\", author=author_2)\n+\n+        # Check that ordering respects the explicit order_by call.\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline')\n+        )\n+\n+        # Verify that using the explicit foreign key ordering works correctly.\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'),\n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline')\n+        )\n+        \n+    def test_self_referencing_fk_order_by_negative_record_root_id(self):\n+        # Create OneModel instances that self-reference.\n+        original_author = Author.objects.create(name=\"Original Author\")\n+        author_1 = Author.objects.create(name=\"Author 1\", editor=original_author)\n+        author_2 = Author.objects.create(name=\"Author 2\", editor=author_1)\n+\n+        # Create two Article instances.\n+        article1 = Article.objects.create(headline=\"Article 1\", author=author_1)\n+        article2 = Article.objects.create(headline=\"Article 2\", author=author_2)\n+\n+        # Check that the inverted ordering works correctly as well.\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('-author__editor_id'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline')\n+        )\n+\n     def test_order_by_f_expression(self):\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n",
  "django__django-13265": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..d1d057f 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -657,8 +657,21 @@ Java</label></li>\n <div class=\"myradio\"><label for=\"id_language_1\">\n <input id=\"id_language_1\" name=\"language\" type=\"radio\" value=\"J\" required> Java</label></div>\"\"\"\n         )\n+    def test_boundfield_subwidget_id_for_label_with_custom_id(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label uses overridden `id` from ChoiceWidget.options.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple,\n+            )\n \n-    def test_form_with_iterable_boundfield(self):\n+        form = SomeForm(auto_id='custom_%s')\n+        subwidgets = form['field'].subwidgets\n+        # We expect that the overridden id is used instead of the default\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_field_1')\n         class BeatleForm(Form):\n             name = ChoiceField(\n                 choices=[('john', 'John'), ('paul', 'Paul'), ('george', 'George'), ('ringo', 'Ringo')],\n",
  "django__django-16400": "",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..19eeda3 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -639,8 +639,39 @@ def test_colorbar_format(fmt):\n     assert (cbar.ax.yaxis.get_ticklabels()[0].get_text() ==\n             '$\\\\mathdefault{10^{-2}}$')\n \n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.colors import LogNorm, Normalize\n+\n+def test_colorbar_update_after_norm_change():\n+    # Create some data and a figure with a single subplot\n+    img = 10**np.random.normal(1, 1, size=(50, 50))\n+    fig, ax = plt.subplots(1, 1)\n+\n+    # Display the data with imshow and add a colorbar\n+    plot = ax.imshow(img, cmap='gray')\n+    cb = fig.colorbar(plot, ax=ax)\n+\n+    # Change the norm of the plot and update the colorbar\n+    new_norm = LogNorm(vmin=img.min(), vmax=img.max())\n+    plot.set_norm(new_norm)\n+    cb.update_normal(plot)\n+\n+    # Redraw the figure\n+    fig.canvas.draw()\n+\n+    # Check that the scale of the colorbar's axis is now log\n+    assert cb.ax.yaxis.get_scale() == 'log'\n+\n+    # Attempting to use update_bruteforce should not raise an error\n+    try:\n+        cb.update_bruteforce(plot)\n+        no_error = True\n+    except ZeroDivisionError:\n+        no_error = False\n \n-def test_colorbar_scale_reset():\n+    # Assert that no ZeroDivisionError was raised\n+    assert no_error, \"ZeroDivisionError was raised when calling update_bruteforce\"\n     x, y = np.ogrid[-4:4:31j, -4:4:31j]\n     z = 120000*np.exp(-x**2 - y**2)\n \n",
  "pydata__xarray-4094": "",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..83baec8 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -259,4 +259,38 @@ def test_set_output_mro():\n     class C(A, B):\n         pass\n \n-    assert C().transform(None) == \"B\"\n+    assert C().transform(None) == \"B\"\n+\n+\n+def test_feature_union_with_pandas_output_and_aggregation():\n+    import pandas as pd\n+    from sklearn.base import BaseEstimator, TransformerMixin\n+    from sklearn.pipeline import FeatureUnion\n+    from sklearn import set_config\n+    from numpy.testing import assert_array_equal\n+\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+\n+    class MyTransformer(BaseEstimator, TransformerMixin):\n+        def fit(self, X: pd.DataFrame, y: pd.Series | None = None, **kwargs):\n+            return self\n+\n+        def transform(self, X: pd.DataFrame, y: pd.Series | None = None) -> pd.DataFrame:\n+            return X[\"value\"].groupby(X[\"date\"]).sum().reset_index(drop=True)\n+\n+    # Set the transformer to use pandas output\n+    set_config(transform_output=\"pandas\")\n+    \n+    # Create a feature union to test the transformation\n+    feature_union = FeatureUnion([(\"my_transformer\", MyTransformer())])\n+\n+    # Perform fit_transform and test output\n+    transformed_data = feature_union.fit_transform(data)\n+    \n+    # Check if the output is a DataFrame with the expected aggregated values\n+    expected_output = pd.DataFrame([240] * 4, columns=[\"my_transformer__value\"])\n+    \n+    # Ensure the transformed data matches the expected output\n+    pd.testing.assert_frame_equal(transformed_data, expected_output)\n",
  "sphinx-doc__sphinx-8801": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 37d6e17..9fa0f13 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -104,7 +104,75 @@ def test_inherited_instance_variable(app):\n         '      docstring bar',\n         '',\n     ]\n+import pytest\n+import sys\n+from sphinx.ext.autodoc import do_autodoc\n+\n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    # Options to include inherited members in documentation\n+    options = {\"members\": None, \"inherited-members\": True}\n+\n+    # actual documentation generation\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+\n+    # checking that both attr1 from the superclass Foo and attr2 from Bar are documented\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_undoc_members_option(app):\n+    # Options to include both undocumented and inherited members\n+    options = {\"members\": None, \"inherited-members\": True, \"undoc-members\": True}\n \n+    # actual documentation generation\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+\n+    # assert with attr1 and attr2 from both Foo and Bar, ensuring even non-documented members appear\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n \n def test_decorators(app):\n     actual = do_autodoc(app, 'class', 'target.decorator.Baz')\n@@ -114,7 +182,75 @@ def test_decorators(app):\n         '   :module: target.decorator',\n         '',\n     ]\n+import pytest\n+import sys\n+from sphinx.ext.autodoc import do_autodoc\n \n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    # Options to include inherited members in documentation\n+    options = {\"members\": None, \"inherited-members\": True}\n+\n+    # actual documentation generation\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+\n+    # checking that both attr1 from the superclass Foo and attr2 from Bar are documented\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_undoc_members_option(app):\n+    # Options to include both undocumented and inherited members\n+    options = {\"members\": None, \"inherited-members\": True, \"undoc-members\": True}\n+\n+    # actual documentation generation\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+\n+    # assert with attr1 and attr2 from both Foo and Bar, ensuring even non-documented members appear\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n     actual = do_autodoc(app, 'class', 'target.decorator.Qux')\n     assert list(actual) == [\n         '',\n@@ -130,7 +266,75 @@ def test_decorators(app):\n         '   :module: target.decorator',\n         '',\n     ]\n+import pytest\n+import sys\n+from sphinx.ext.autodoc import do_autodoc\n+\n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    # Options to include inherited members in documentation\n+    options = {\"members\": None, \"inherited-members\": True}\n+\n+    # actual documentation generation\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+\n+    # checking that both attr1 from the superclass Foo and attr2 from Bar are documented\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n \n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_undoc_members_option(app):\n+    # Options to include both undocumented and inherited members\n+    options = {\"members\": None, \"inherited-members\": True, \"undoc-members\": True}\n+\n+    # actual documentation generation\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+\n+    # assert with attr1 and attr2 from both Foo and Bar, ensuring even non-documented members appear\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n \n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_slots_attribute(app):\n",
  "sympy__sympy-15346": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex cce4836..be998d3 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     symbols, sin, simplify, cos, trigsimp, rad, tan, exptrigsimp,sinh,\n     cosh, diff, cot, Subs, exp, tanh, exp, S, integrate, I,Matrix,\n@@ -9,8 +10,22 @@ from sympy.utilities.pytest import XFAIL\n from sympy.abc import x, y, z, t, a, b, c, d, e, f, g, h, i, k\n \n \n-\n-def test_trigsimp1():\n+def test_issue_simplify_rational_trigs():\n+    t1 = Matrix([sin(Rational(1, 50)), cos(Rational(1, 50)), 0])\n+    t2 = Matrix([sin(Rational(1, 25)), cos(Rational(1, 25)), 0])\n+    r1 = t1.dot(t2)\n+    r2 = sin(Rational(1, 50)) * sin(Rational(1, 25)) + cos(Rational(1, 50)) * cos(Rational(1, 25))\n+    \n+    # Assert the dot product results are simplified correctly\n+    assert trigsimp(r1) == cos(S(1)/50)\n+    assert trigsimp(r2) == cos(S(1)/50)\n+    \n+    # Additional test for the acos function simplification\n+    assert trigsimp(acos(r2)) == acos(cos(S(1)/50))\n+\n+    # Testing a direct expression using the same rational values\n+    r3 = sin(Rational(1, 50)) * sin(Rational(1, 25)) + cos(Rational(1, 50)) * cos(Rational(1, 25))\n+    assert trigsimp(r3) == cos(S(1)/50)\n     x, y = symbols('x,y')\n \n     assert trigsimp(1 - sin(x)**2) == cos(x)**2\n",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..aaec4e0 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4863,7 +4863,37 @@ k = \u2500\u2500\u2500\u2500\u2500                                \\n\\\n     assert upretty(expr) == ucode_str\n \n \n-def test_units():\n+def test_pretty_sum_alignment():\n+    from sympy import Sum, symbols, oo\n+    from sympy.abc import x\n+\n+    expr = Sum(x, (x, 1, oo)) + 3\n+    ucode_str = \\\n+    u(\"\"\"\\\n+  \u221e    \\n\\\n+ ___   \\n\\\n+ \u2572     \\n\\\n+  \u2572   x\\n\\\n+  \u2571    \\n\\\n+ \u2571   +3\\n\\\n+ \u203e\u203e\u203e   \\n\\\n+x = 1  \\\n+\"\"\")\n+    assert upretty(expr) == ucode_str\n+\n+    expr = Sum(x + 2, (x, 1, oo)) + 3\n+    ucode_str = \\\n+    u(\"\"\"\\\n+  \u221e       \\n\\\n+ ___      \\n\\\n+ \u2572        \\n\\\n+  \u2572   x+2 \\n\\\n+  \u2571       \\n\\\n+ \u2571    +3  \\n\\\n+ \u203e\u203e\u203e      \\n\\\n+x = 1     \\\n+\"\"\")\n+    assert upretty(expr) == ucode_str\n     expr = joule\n     ascii_str1 = \\\n \"\"\"\\\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex b2b6202..b9ccb23 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -704,8 +704,25 @@ def test_uniq():\n     assert list(uniq([2, 3, 2, 4, [2], [1], [2], [3], [1]])) == \\\n         [2, 3, 4, [2], [1], [3]]\n \n-\n-def test_kbins():\n+def test_uniq_runtime_error_on_modification():\n+    # Import raises from pytest\n+    from pytest import raises\n+\n+    f = [1]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    \n+    f = [[1]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Additional test cases for more coverage\n+    f = list(\"THISTLE\")\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    f = [2, 3, 2, 4, [2], [1], [2], [3], [1]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    \n+    # Check that the test_uniq original scenarios work correctly\n+    test_uniq()\n     assert len(list(kbins('1123', 2, ordered=1))) == 24\n     assert len(list(kbins('1123', 2, ordered=11))) == 36\n     assert len(list(kbins('1123', 2, ordered=10))) == 10\n",
  "django__django-11797": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 7beeac3..b50247b 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -1,3 +1,4 @@\n+\n import collections.abc\n from datetime import datetime\n from math import ceil\n@@ -8,6 +9,7 @@ from django.db import connection\n from django.db.models.expressions import Exists, OuterRef\n from django.db.models.functions import Substr\n from django.test import TestCase, skipUnlessDBFeature\n+from django.db.models import Max\n \n from .models import (\n     Article, Author, Game, IsNullWithNoneAsRHS, Player, Season, Tag,\n",
  "django__django-15320": "",
  "django__django-15819": "",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..5c05d38 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -152,6 +153,35 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n+    def test_wrong_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation('pool__tournament__pool'),\n+                ).select_related('tournament_pool')\n+            )\n+            self.assertEqual(p[0].pool.tournament, p[0].tournament_pool.tournament)\n+\n+    def test_multilevel_reverse_fk_cyclic_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation(\"pool__tournament__pool\"),\n+                ).select_related(\"tournament_pool\", \"tournament_pool__tournament\")\n+            )\n+            self.assertEqual(p[0].tournament_pool.tournament, p[0].pool.tournament)\n+\n+    def test_multilevel_reverse_fk_select_related(self):\n+        with self.assertNumQueries(2):\n+            p = list(\n+                Tournament.objects.filter(id=self.t2.id)\n+                .annotate(\n+                    style=FilteredRelation(\"pool__another_style\"),\n+                )\n+                .select_related(\"style\")\n+            )\n+            self.assertEqual(p[0].style.another_pool, self.p3)\n+\n     def test_reverse_fk_select_related_multiple(self):\n         with self.assertNumQueries(1):\n             ps = list(\n@@ -163,4 +193,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex ad1a5e1..cc5f54b 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1,3 +1,28 @@\n+\n+def test_unpickle_with_device_pixel_ratio():\n+    fig = Figure(dpi=42)\n+    fig.canvas._set_device_pixel_ratio(7)\n+    assert fig.dpi == 42 * 7\n+    fig2 = pickle.loads(pickle.dumps(fig))\n+    assert fig2.dpi == 42\n+\n+@pytest.mark.parametrize(\"dpi_value\", [100, 150, 200])\n+def test_dpi_stability_across_pickling(dpi_value):\n+    fig = Figure(dpi=dpi_value)\n+    \n+    for i in range(10):\n+        fig = pickle.loads(pickle.dumps(fig))\n+        assert fig.dpi == dpi_value\n+\n+def test_dpi_not_doubled_through_multiple_iterations():\n+    original_dpi = 200\n+    iters = 20\n+    fig = Figure(dpi=original_dpi)\n+\n+    for _ in range(iters):\n+        fig = pickle.loads(pickle.dumps(fig))\n+    assert fig.dpi == original_dpi\n+\n import copy\n from datetime import datetime\n import io\n@@ -11,7 +36,10 @@ import numpy as np\n import pytest\n from PIL import Image\n \n+import pickle\n+import pytest\n import matplotlib as mpl\n+from matplotlib.figure import Figure\n from matplotlib import gridspec, rcParams\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n from matplotlib.axes import Axes\n",
  "mwaskom__seaborn-2848": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 5a5e126..239728e 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -1,3 +1,4 @@\n+\n from itertools import product\n import numpy as np\n import matplotlib as mpl\n@@ -10,6 +11,7 @@ from numpy.testing import assert_array_equal\n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n \n+from seaborn import PairGrid\n from seaborn.relational import (\n     _RelationalPlotter,\n     _LinePlotter,\n",
  "pytest-dev__pytest-5413": "diff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 226bfb9..5b951b5 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -347,7 +347,18 @@ def test_excinfo_str():\n     assert len(s.split(\":\")) >= 3  # on windows it's 4\n \n \n-def test_excinfo_for_later():\n+def test_str_on_raises_context():\n+    import pytest\n+\n+    # Test with the Issue example\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\"A\\nB\\nC\")\n+\n+    # Check that str(excinfo) resembles the context object, not the exception message\n+    assert str(excinfo).startswith(\"<ExceptionInfo LookupError\")\n+\n+    # Correct way to get the exception message\n+    assert str(excinfo.value) == \"A\\nB\\nC\"\n     e = ExceptionInfo.for_later()\n     assert \"for raises\" in repr(e)\n     assert \"for raises\" in str(e)\n",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..af941a1 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -405,6 +405,11 @@ class TestCustomConftests:\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n \n+        # Test using the new single-character shortcut for --collect-only, assuming it's '-c'\n+        result_shortcut = testdir.runpytest(\"-c\")\n+        result_shortcut.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+\n     def test_pytest_collect_file_from_sister_dir(self, testdir):\n         sub1 = testdir.mkpydir(\"sub1\")\n         sub2 = testdir.mkpydir(\"sub2\")\n@@ -434,8 +439,17 @@ class TestCustomConftests:\n         p.copy(sub1.join(p.basename))\n         p.copy(sub2.join(p.basename))\n         result = testdir.runpytest(\"--collect-only\")\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+\n+        # Test using the new single-character shortcut for --collect-only, assuming it's '-c'\n+        result_shortcut = testdir.runpytest(\"-c\")\n+        result_shortcut.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n         result.stdout.fnmatch_lines([\"*MyModule1*\", \"*MyModule2*\", \"*test_x*\"])\n \n+        # Test using the new single-character shortcut for --collect-only, assuming it's '-c'\n+        result_shortcut = testdir.runpytest(\"-c\")\n+        result_shortcut.stdout.fnmatch_lines([\"*MyModule1*\", \"*MyModule2*\", \"*test_x*\"])\n+\n \n class TestSession:\n     def test_parsearg(self, testdir):\n",
  "sphinx-doc__sphinx-10451": "diff --git a/tests/roots/test-ext-autodoc/target/typehints.py b/tests/roots/test-ext-autodoc/target/typehints.py\nindex 100ea06..bc6d551 100644\n--- a/tests/roots/test-ext-autodoc/target/typehints.py\n+++ b/tests/roots/test-ext-autodoc/target/typehints.py\n@@ -90,12 +90,20 @@ def missing_attr(c,\n     # type: (...) -> str\n     return a + (b or \"\")\n \n+class _ClassWithDocumentedInitAndStarArgs:\n+    \"\"\"Class docstring.\"\"\"\n+\n+    def __init__(self, x: int, *args: int, **kwargs: int) -> None:\n+        \"\"\"Init docstring.\n \n-class _ClassWithDocumentedInit:\n+        :param x: Some integer\n+        :param *args: Some integer\n+        :param **kwargs: Some integer\n+        \"\"\"\n     \"\"\"Class docstring.\"\"\"\n \n     def __init__(self, x: int) -> None:\n         \"\"\"Init docstring.\n \n         :param x: Some integer\n-        \"\"\"\n+        \"\"\"\n",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..113b493 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -80,6 +80,11 @@ def test_Identity():\n     assert A*Im == A\n     assert In*A == A\n \n+    # Testing the total sum of elements in the identity matrix\n+    i, j = symbols('i j')\n+    assert Sum(In[i, j], (i, 0, n-1), (j, 0, n-1)).subs(n,3).doit() == 3\n+    assert Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).subs(n,3).doit() == 3\n+\n     assert transpose(In) == In\n     assert In.inverse() == In\n     assert In.conjugate() == In\n",
  "sympy__sympy-20049": "",
  "sympy__sympy-21612": "diff --git a/sympy/parsing/tests/test_latex.py b/sympy/parsing/tests/test_latex.py\nindex b252985..a4242ce 100644\n--- a/sympy/parsing/tests/test_latex.py\n+++ b/sympy/parsing/tests/test_latex.py\n@@ -246,6 +246,19 @@ GOOD_PAIRS = [\n ]\n \n \n+from sympy.parsing.latex import parse_latex\n+from sympy import Symbol, Rational\n+\n+x = Symbol('x')\n+y = Symbol('y')\n+z = Symbol('z')\n+a = Symbol('a')\n+b = Symbol('b')\n+c = Symbol('c')\n+\n+def test_fraction_parsing_issue():\n+    assert str(parse_latex(\"\\\\frac{\\\\frac{a^3+b}{c}}{\\\\frac{1}{c^2}}\")) == '((a**3 + b)/c)/(1/(c**2))'\n+\n def test_parseable():\n     from sympy.parsing.latex import parse_latex\n     for latex_str, sympy_expr in GOOD_PAIRS:\n"
}