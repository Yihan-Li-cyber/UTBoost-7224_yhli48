{
  "astropy__astropy-12907": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 88711b0..c5f9175 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -134,8 +134,20 @@ def test_separable(compound_model, result):\n     assert_allclose(is_separable(compound_model), result[0])\n     assert_allclose(separability_matrix(compound_model), result[1])\n \n-\n-def test_custom_model_separable():\n+@pytest.mark.parametrize('nested_compound_model, expected', [\n+    (\n+        models.Pix2Sky_TAN() & (models.Linear1D(10) & models.Linear1D(5)),\n+        np.array([\n+            [True, True, False, False],\n+            [True, True, False, False],\n+            [False, False, True, False],\n+            [False, False, False, True]\n+        ])\n+    )\n+])\n+def test_nested_compound_model_separable(nested_compound_model, expected):\n+    separable_result = separability_matrix(nested_compound_model)\n+    assert_allclose(separable_result, expected)\n     @custom_model\n     def model_a(x):\n         return x\n",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..cec451d 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,5 +1,58 @@\n+\n+def test_write_rst_with_header_rows():\n+    \"\"\"Test writing a table to RST format with header_rows\"\"\"\n+    # Prepare a QTable with units\n+    tbl = QTable({'wave': [350, 950]*u.nm, 'response': [0.7, 1.2]*u.count})\n+    \n+    # Capture the output of writing this table with header_rows\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\n+\n+    # Define expected lines with headers\n+    expected = [\n+        \"======= ========\",\n+        \"   wave response\",\n+        \"    nm       ct\",\n+        \"======= ========\",\n+        \"  350.0     0.7\",\n+        \"  950.0     1.2\",\n+        \"======= ========\",\n+    ]\n+\n+    # Check if the output matches the expected lines\n+    assert out.getvalue().splitlines() == expected\n+\n+\n+def test_read_with_header_rows():\n+    \"\"\"Round-trip a table with header_rows specified\"\"\"\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct     \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\",\n+    ]\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"wave\"].dtype == np.float64\n+    assert tbl[\"response\"].dtype == np.float32\n+    assert tbl[\"ints\"].dtype == np.int8\n+\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert out.getvalue().splitlines() == lines\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n+import numpy as np\n+import astropy.units as u\n+from astropy.table import QTable\n+from io import StringIO\n+\n from io import StringIO\n \n from astropy.io import ascii\n",
  "astropy__astropy-14365": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 9b66109..37e32c9 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -108,8 +108,32 @@ def test_roundtrip(tmp_path):\n     for meta_name in [\"initial_comments\", \"comments\"]:\n         assert meta_name in new_table.meta\n \n-\n-def test_read_example():\n+import numpy as np\n+import pytest\n+from astropy.table import Table\n+from astropy.utils.exceptions import AstropyUserWarning\n+from astropy.io.ascii.qdp import _read_table_qdp, _write_table_qdp\n+\n+\n+def test_read_lowercase_commands(tmp_path):\n+    \"\"\"Test reading a QDP file with lowercase commands.\"\"\"\n+    qdp_content = \"\"\"\n+    ! Example QDP with lowercase commands\n+    read serr 1\n+    read serr 2\n+    ! Data starts\n+    1.0 0.1 2.0 0.2\n+    3.0 0.3 4.0 0.4\n+    \"\"\"\n+    qdp_path = str(tmp_path / \"lowercase_commands.qdp\")\n+    with open(qdp_path, \"w\") as fp:\n+        fp.write(qdp_content)\n+    \n+    table = _read_table_qdp(qdp_path)\n+    assert np.allclose(table['col1'], [1.0, 3.0])\n+    assert np.allclose(table['col2'], [0.1, 0.3])\n+    assert np.allclose(table['col3'], [2.0, 4.0])\n+    assert np.allclose(table['col4'], [0.2, 0.4])\n     example_qdp = \"\"\"\n         ! Initial comment line 1\n         ! Initial comment line 2\n",
  "astropy__astropy-14995": "diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py\nindex fc27f69..14465ac 100644\n--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py\n+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py\n@@ -28,6 +28,38 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n         return False\n \n \n+def test_nddata_mask_propagation():\n+    \"\"\"\n+    Test NDDataRef mask propagation with bitwise or operation.\n+    This ensures no TypeError when one operand lacks a mask.\n+    \"\"\"\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_masked = NDDataRef(array, mask=mask)\n+\n+    # multiply no mask by constant (no mask * no mask)\n+    assert nref_nomask.multiply(1.0, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply no mask by itself (no mask * no mask)\n+    assert nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply masked by constant (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(1.0, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by itself (mask * mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_masked, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by no mask (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_nomask, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n # Test with Data covers:\n # scalars, 1D, 2D and 3D\n # broadcasting between them\n",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/fitsrec.py b/astropy/io/fits/fitsrec.py\nindex 88d596b..c9a4f02 100644\n--- a/astropy/io/fits/fitsrec.py\n+++ b/astropy/io/fits/fitsrec.py\n@@ -1261,7 +1261,7 @@ class FITS_rec(np.recarray):\n \n         # Replace exponent separator in floating point numbers\n         if 'D' in format:\n-            output_field.replace(encode_ascii('E'), encode_ascii('D'))\n+            output_field[:] = output_field.replace(encode_ascii('E'), encode_ascii('D'))\n \n \n def _get_recarray_field(array, key):\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..295f532 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1090,6 +1090,13 @@ class OverrideSettingsTests(SimpleTestCase):\n         base_url attribute of django.core.files.storage.default_storage.\n         \"\"\"\n         self.assertEqual(default_storage.base_location, '')\n+\n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        Test that the default FILE_UPLOAD_PERMISSIONS is set to 0o644.\n+        \"\"\"\n+        with self.settings(FILE_UPLOAD_PERMISSIONS=None):\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n         with self.settings(MEDIA_URL='/test_value/'):\n             self.assertEqual(default_storage.base_url, '/test_value/')\n \n",
  "django__django-10924": "",
  "django__django-11001": "",
  "django__django-11039": "",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..ee0814f 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -68,6 +68,28 @@ class TestSerialization(SimpleTestCase):\n class TestValidation(SimpleTestCase):\n \n     def test_invalid_string(self):\n+        # Testing various invalid formats\n+        field = models.DurationField()\n+        \n+        invalid_values = [\n+            '25:61:61',  # Invalid minutes and seconds\n+            '1::30',     # Empty section\n+            '139:00',    # Ambiguous time\n+            'not a time',\n+        ]\n+\n+        expected_error_msg = \"'{value}' value has an invalid format. It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n+\n+        for invalid_value in invalid_values:\n+            with self.assertRaises(exceptions.ValidationError) as cm:\n+                field.clean(invalid_value, None)\n+            self.assertEqual(cm.exception.code, 'invalid')\n+            self.assertEqual(\n+                cm.exception.message % cm.exception.params,\n+                expected_error_msg.format(value=invalid_value)\n+            )\n+\n+    def test_invalid_duration_format_error_message(self):\n         field = models.DurationField()\n         with self.assertRaises(exceptions.ValidationError) as cm:\n             field.clean('not a datetime', None)\n@@ -84,4 +106,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..f37a084 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -248,7 +248,23 @@ class UsernameValidatorsTests(SimpleTestCase):\n                 with self.assertRaises(ValidationError):\n                     v(invalid)\n \n-    def test_ascii_validator(self):\n+    def test_username_with_trailing_newline(self):\n+        # Test cases with trailing newline\n+        invalid_usernames_with_newline = ['joe\\n', 'john_doe\\n', 'username@\\n']\n+        \n+        # Test UnicodeUsernameValidator\n+        unicode_validator = validators.UnicodeUsernameValidator()\n+        for invalid in invalid_usernames_with_newline:\n+            with self.subTest(validator='Unicode', invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    unicode_validator(invalid)\n+        \n+        # Test ASCIIUsernameValidator\n+        ascii_validator = validators.ASCIIUsernameValidator()\n+        for invalid in invalid_usernames_with_newline:\n+            with self.subTest(validator='ASCII', invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    ascii_validator(invalid)\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n         invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n         v = validators.ASCIIUsernameValidator()\n@@ -258,4 +274,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..4c99d0b 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -356,7 +356,15 @@ class HttpResponseTests(unittest.TestCase):\n         r = HttpResponse()\n         self.assertIsNone(r.get('test'))\n \n-    def test_non_string_content(self):\n+    def test_memoryview_content(self):\n+        # Test memoryview content\n+        r = HttpResponse(memoryview(b\"memoryview\"))\n+        self.assertEqual(r.content, b\"memoryview\")\n+\n+        # Test memoryview content via property\n+        r = HttpResponse()\n+        r.content = memoryview(b\"memoryview\")\n+        self.assertEqual(r.content, b\"memoryview\")\n         # Bug 16494: HttpResponse should behave consistently with non-strings\n         r = HttpResponse(12345)\n         self.assertEqual(r.content, b'12345')\n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..94545c1 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,9 +1,11 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n+from django.db.models.deletion import Collector\n from .models import (\n     MR, A, Avatar, Base, Child, HiddenUser, HiddenUserProfile, M, M2MFrom,\n     M2MTo, MRNull, Parent, R, RChild, S, T, User, create_a, get_default_r,\n@@ -464,7 +466,37 @@ class FastDeleteTests(TestCase):\n         # 1 to delete t, 1 to fast-delete t's m_set\n         self.assertNumQueries(2, f.delete)\n \n-    def test_fast_delete_qs(self):\n+    def test_fast_delete_instance_set_pk_none(self):\n+        u = User.objects.create()\n+        # User can be fast-deleted.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        u.delete()\n+        self.assertIsNone(u.pk)\n+\n+    def test_fast_delete_instance_no_change_on_dependencies(self):\n+        u = User.objects.create()\n+        a = Avatar.objects.create(user=u)\n+        u.delete()\n+        # PK should still be None for non-dependent instance\n+        self.assertIsNone(u.pk)\n+        # Avatar instance should not be affected as it's dependent\n+        self.assertIsNotNone(a.pk)\n+        self.assertTrue(Avatar.objects.filter(pk=a.pk).exists())\n+\n+    def test_fast_delete_instance_with_foreign_key(self):\n+        a = Avatar.objects.create()\n+        u = User.objects.create(avatar=a)\n+        collector = Collector(using='default')\n+        can_fast_delete_user = collector.can_fast_delete(u)\n+        can_fast_delete_avatar = collector.can_fast_delete(a)\n+        \n+        self.assertFalse(can_fast_delete_user)\n+        self.assertTrue(can_fast_delete_avatar)\n+\n+        u.delete()\n+        self.assertIsNone(u.pk)\n+        self.assertTrue(Avatar.objects.filter(pk=a.pk).exists())\n         u1 = User.objects.create()\n         u2 = User.objects.create()\n         self.assertNumQueries(1, User.objects.filter(pk=u1.pk).delete)\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..18e2f7a 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,9 +1,11 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n from django.contrib.auth.models import Permission, User\n from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n+from django.test.utils import captured_stdout\n \n from .models import Proxy, UserProxy\n \n@@ -140,7 +142,52 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n-    def test_user_keeps_same_permissions_after_migrating_backward(self):\n+    def test_migrate_with_existing_target_permission(self):\n+        \"\"\"\n+        Permissions may already exist:\n+\n+        - Old workaround was to manually create permissions for proxy models.\n+        - Model may have been concrete and then converted to proxy.\n+\n+        Output a reminder to audit relevant permissions.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='display_proxys',\n+            name='May display proxys information',\n+        )\n+        with captured_stdout() as stdout:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        self.assertIn('A problem arose migrating proxy model permissions', stdout.getvalue())\n+\n+    def test_fix_no_duplicate_permissions_on_update(self):\n+        \"\"\"\n+        Test that the migration does not create duplicate permissions when\n+        permissions already exist for the proxy model.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+\n+        # Verify that only one permission exists with the same codename.\n+        self.assertEqual(\n+            Permission.objects.filter(\n+                content_type=proxy_model_content_type,\n+                codename='add_proxy'\n+            ).count(),\n+            1,\n+            \"Duplicate proxy permissions found after migration.\"\n+        )\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n         user.user_permissions.add(self.custom_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..d2ade7f 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -72,7 +72,25 @@ class TestIterModulesAndFiles(SimpleTestCase):\n \n         self.assertFileFound(filename.absolute())\n \n-    def test_check_errors(self):\n+    def test_manage_py_change_triggers_reload(self):\n+        \"\"\"\n+        Test that changes in a simulated manage.py are tracked by the autoreloader.\n+        \"\"\"\n+        filename = self.temporary_file('manage.py')\n+        initial_content = \"def main():\\n    print('Initial')\\n\"\n+        modified_content = \"def main():\\n    print('Modified')\\n\"\n+        \n+        # Write initial content to simulate initial run.\n+        filename.write_text(initial_content)\n+        \n+        # Ensure initial file state is found.\n+        self.assertFileFound(filename.absolute())\n+        \n+        # Modify the file to trigger reload logic.\n+        filename.write_text(modified_content)\n+        \n+        # Verify that the modified file is still recognized.\n+        self.assertFileFound(filename.absolute())\n         \"\"\"\n         When a file containing an error is imported in a function wrapped by\n         check_errors(), gen_filenames() returns it.\n",
  "django__django-11583": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 99e5edd..7ceeae0 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -139,6 +139,43 @@ class TestIterModulesAndFiles(SimpleTestCase):\n     def test_main_module_without_file_is_not_resolved(self):\n         fake_main = types.ModuleType('__main__')\n         self.assertEqual(autoreload.iter_modules_and_files((fake_main,), frozenset()), frozenset())\n+        \n+    def test_nonexistent_embedded_null_byte_path(self):\n+        paths_with_null_bytes = (\n+            'null_byte_in_path/\\x00',\n+            '\\x00_start_of_path.py',\n+            # Add more variations of path with embedded null bytes\n+        )\n+        for path in paths_with_null_bytes:\n+            with self.subTest(path=path):\n+                self.assertEqual(\n+                    autoreload.iter_modules_and_files((), frozenset([path])),\n+                    frozenset(),\n+                )\n+\n+    def test_directory_with_embedded_null_bytes(self):\n+        paths_with_null_bytes = (\n+            '\\x00embedded_directory/valid.py',\n+            'valid_directory/\\x00embedded_file.py',\n+        )\n+        for path in paths_with_null_bytes:\n+            with self.subTest(path=path):\n+                self.assertEqual(\n+                    autoreload.iter_modules_and_files((), frozenset([path])),\n+                    frozenset(),\n+                )\n+\n+    def test_valid_files_without_null_bytes(self):\n+        valid_paths = (\n+            'normal_file.py',\n+            'normal_directory/another_file.py',\n+        )\n+        for path in valid_paths:\n+            with self.subTest(path=path):\n+                self.assertNotEqual(\n+                    autoreload.iter_modules_and_files((), frozenset([path])),\n+                    frozenset(),\n+                )\n \n \n class TestCommonRoots(SimpleTestCase):\n",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..e517030 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -18,7 +18,8 @@ from django.test import RequestFactory, SimpleTestCase, override_settings\n from django.test.utils import LoggingCaptureMixin\n from django.urls import path, reverse\n from django.utils.functional import SimpleLazyObject\n-from django.utils.safestring import mark_safe\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n from django.views.debug import (\n     CLEANSED_SUBSTITUTE, CallableSettingWrapper, ExceptionReporter,\n     Path as DebugPath, cleanse_setting, default_urlconf,\n@@ -242,7 +243,28 @@ class DebugViewQueriesAllowedTests(SimpleTestCase):\n     # May need a query to initialize MySQL connection\n     databases = {'default'}\n \n-    def test_handle_db_exception(self):\n+    def test_technical_404_converter_raise_404(self):\n+        \"\"\"\n+        Verify that when Http404 is raised in a path converter's to_python method \n+        with DEBUG=True, it results in a technical 404 response and not a generic server error.\n+        \"\"\"\n+        with self.settings(DEBUG=True):\n+            with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+                response = self.client.get('/path-post/1/')\n+                self.assertContains(response, 'Page not found', status_code=404)\n+                self.assertContains(response, 'Technical details:', html=True)\n+\n+    def test_non_404_exception_in_converter(self):\n+        \"\"\"\n+        When a ValueError is raised in a path converter's to_python method, it should\n+        attempt to match the next path converter and not result in a 404 or server error.\n+        \"\"\"\n+        with self.settings(DEBUG=True):\n+            with mock.patch.object(IntConverter, 'to_python', side_effect=ValueError):\n+                response = self.client.get('/path-post/1/')\n+                # Ensure no 404 error is returned, indicating the URL resolver\n+                # tried other converters or patterns\n+                self.assertNotContains(response, 'Page not found', status_code=404)\n         \"\"\"\n         Ensure the debug view works when a database exception is raised by\n         performing an invalid query and passing the exception to the debug view.\n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..bb60364 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -98,7 +98,43 @@ class CharFieldTests(SimpleTestCase):\n         field = Model._meta.get_field('field')\n         self.assertEqual(field.check(), [])\n \n-    def test_missing_max_length(self):\n+    def test_choices_with_max_length_too_small(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('ABC', 'Too Long'), \n+                    ('OK', 'Good')\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_nested_choices_with_max_length_too_small(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=5,\n+                choices=[\n+                    ('Nested', [('OK', 'Good'), ('Longerchoice', 'Even Longer')]),\n+                    ('Grouped', [('Bad', 'Bad Choice')]),\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (10 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n         class Model(models.Model):\n             field = models.CharField()\n \n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..2cecce5 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -252,6 +252,27 @@ class WriterTests(SimpleTestCase):\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n \n+    def test_serialize_translated_enum(self):\n+        class TextTranslatedEnum(enum.Enum):\n+            A = _('a-value')\n+            B = _('value-b')\n+\n+        field = models.CharField(\n+            default=TextTranslatedEnum.A,\n+            choices=[(m.value, m) for m in TextTranslatedEnum],\n+        )\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.TextTranslatedEnum['A']\",\n+            string,\n+            \"The serialized output should use the Enum member's name for the default.\",\n+        )\n+        self.assertIn(\n+            \"choices=[('a-value', migrations.test_writer.TextTranslatedEnum['A']), ('value-b', migrations.test_writer.TextTranslatedEnum['B'])]\",\n+            string,\n+            \"The serialized output should correctly represent the choices.\"\n+        )\n+\n     def test_serialize_enums(self):\n         class TextEnum(enum.Enum):\n             A = 'a-value'\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..e50821c 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,3 +1,4 @@\n+\n import unittest\n from datetime import datetime\n \n@@ -307,7 +308,31 @@ class ETagProcessingTests(unittest.TestCase):\n         self.assertEqual(quote_etag('W/\"etag\"'), 'W/\"etag\"')  # quoted, weak\n \n \n+from unittest import mock\n+\n class HttpDateProcessingTests(unittest.TestCase):\n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850_with_mocked_datetime(self, mocked_datetime):\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+        utcnow_1 = datetime(2019, 11, 6, 8, 49, 37)\n+        utcnow_2 = datetime(2020, 11, 6, 8, 49, 37)\n+        utcnow_3 = datetime(2048, 11, 6, 8, 49, 37)\n+        tests = (\n+            # Original cases as part of the testing logic to verify future/past logic\n+            (utcnow_1, 'Tuesday, 31-Dec-69 08:49:37 GMT', datetime(2069, 12, 31, 8, 49, 37)),\n+            (utcnow_1, 'Tuesday, 10-Nov-70 08:49:37 GMT', datetime(1970, 11, 10, 8, 49, 37)),\n+            (utcnow_2, 'Wednesday, 31-Dec-70 08:49:37 GMT', datetime(2070, 12, 31, 8, 49, 37)),\n+            # New cases to extend coverage with edge year 50\n+            (utcnow_1, 'Wednesday, 31-Dec-50 08:49:37 GMT', datetime(2050, 12, 31, 8, 49, 37)),\n+            (utcnow_1, 'Wednesday, 31-Dec-49 08:49:37 GMT', datetime(2049, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Monday, 01-Jan-49 08:49:37 GMT', datetime(2049, 1, 1, 8, 49, 37)),\n+        )\n+        for utcnow, rfc850str, expected_date in tests:\n+            with self.subTest(rfc850str=rfc850str):\n+                mocked_datetime.utcnow.return_value = utcnow\n+                parsed = parse_http_date(rfc850str)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n     def test_http_date(self):\n         t = 1167616461.0\n         self.assertEqual(http_date(t), 'Mon, 01 Jan 2007 01:54:21 GMT')\n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..1c7545f 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -32,6 +32,10 @@ class Vehicle(models.IntegerChoices):\n     __empty__ = _('(Unknown)')\n \n \n+from django.test import SimpleTestCase\n+from django.utils.translation import gettext_lazy as _\n+from django.db import models\n+\n class Gender(models.TextChoices):\n     MALE = 'M'\n     FEMALE = 'F'\n@@ -39,8 +43,18 @@ class Gender(models.TextChoices):\n \n     __empty__ = '(Undeclared)'\n \n+class MyChoice(models.TextChoices):\n+    FIRST_CHOICE = \"first\", _(\"The first choice, it is\")\n+    SECOND_CHOICE = \"second\", _(\"The second choice, it is\")\n+\n+class EnumTests(SimpleTestCase):\n+    class MyObject(models.Model):\n+        my_str_value = models.CharField(max_length=10, choices=MyChoice.choices)\n \n-class ChoicesTests(SimpleTestCase):\n+    def test_created_object_is_str(self):\n+        my_object = self.MyObject(my_str_value=MyChoice.FIRST_CHOICE)\n+        self.assertIsInstance(my_object.my_str_value, str)\n+        self.assertEqual(my_object.my_str_value, MyChoice.FIRST_CHOICE.value)\n     def test_integerchoices(self):\n         self.assertEqual(Suit.choices, [(1, 'Diamond'), (2, 'Spade'), (3, 'Heart'), (4, 'Club')])\n         self.assertEqual(Suit.labels, ['Diamond', 'Spade', 'Heart', 'Club'])\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..2ef7a8e 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -186,8 +186,22 @@ class GetFieldDisplayTests(SimpleTestCase):\n         self.assertIsNone(WhizIterEmpty(c=None).c)         # Blank value\n         self.assertEqual(WhizIterEmpty(c='').c, '')        # Empty value\n \n+from django.db import models\n+from django.test import TestCase\n+\n+class OverrideGetFieldDisplayTests(TestCase):\n+    def test_custom_get_FIELD_display_override(self):\n+        class FooBar(models.Model):\n+            foo_bar = models.IntegerField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                # Custom override should return 'something'\n+                return 'something'\n \n-class GetChoicesTests(SimpleTestCase):\n+        # Instance of FooBar\n+        instance = FooBar(foo_bar=1)\n+        # Assert that the custom override returns 'something'\n+        self.assertEqual(instance.get_foo_bar_display(), 'something')\n \n     def test_empty_choices(self):\n         choices = []\n",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "",
  "django__django-12284": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex 7dc81d2..3712062 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -1,3 +1,4 @@\n+\n import pickle\n \n from django import forms\n@@ -162,6 +163,23 @@ class GetFieldDisplayTests(SimpleTestCase):\n         self.assertEqual(Whiz(c='').get_c_display(), '')        # Empty value\n         self.assertEqual(WhizDelayed(c=0).get_c_display(), 'Other')  # Delayed choices\n \n+class GetFOODisplayTests(TestCase):\n+    def test_overriding_inherited_FIELD_display(self):\n+        class Base(models.Model):\n+            foo = models.CharField(max_length=254, choices=[('A', 'Base A')])\n+\n+            class Meta:\n+                abstract = True\n+\n+        class Child(Base):\n+            foo = models.CharField(max_length=254, choices=[('A', 'Child A'), ('B', 'Child B'), ('C', 'Child C')])\n+\n+        # Test cases to verify the correct output\n+        self.assertEqual(Child(foo='A').get_foo_display(), 'Child A')\n+        self.assertEqual(Child(foo='B').get_foo_display(), 'Child B')\n+        # New test case added for issue verification\n+        self.assertEqual(Child(foo='C').get_foo_display(), 'Child C')\n+\n     def test_get_FIELD_display_translated(self):\n         \"\"\"A translated display value is coerced to str.\"\"\"\n         val = Whiz(c=5).get_c_display()\n",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..c2dcd59 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,9 +1,10 @@\n+\n from django.core.checks import Error\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n     check_setting_languages, check_setting_languages_bidi,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, override_settings\n \n \n class TranslationCheckTests(SimpleTestCase):\n@@ -75,7 +76,27 @@ class TranslationCheckTests(SimpleTestCase):\n                     Error(msg % tag, id='translation.E003'),\n                 ])\n \n-    def test_inconsistent_language_settings(self):\n+    @override_settings(\n+        USE_I18N=True,\n+        LANGUAGES=[\n+            ('en', 'English'),\n+            ('de', 'German'),\n+            ('es', 'Spanish'),\n+            ('fr', 'French'),\n+        ],\n+    )\n+    def test_sublanguage_with_base_language_available(self):\n+        \"\"\"\n+        Ensure that no error is raised for sublanguages when a base language is available.\n+        \"\"\"\n+        valid_sublanguages = [\n+            'fr-CA',  # French (Canada) with base 'fr'\n+            'de-at',  # Austrian German with base 'de'\n+            'en-GB',  # British English with base 'en'\n+        ]\n+        for tag in valid_sublanguages:\n+            with self.subTest(tag), self.settings(LANGUAGE_CODE=tag):\n+                self.assertEqual(check_language_settings_consistent(None), [])\n         msg = (\n             'You have provided a value for the LANGUAGE_CODE setting that is '\n             'not in the LANGUAGES setting.'\n",
  "django__django-12308": "",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..e75e93a 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from unittest import mock\n \n@@ -17,8 +18,69 @@ def get_connection_copy():\n     )\n     return test_connection\n \n+class TestDeserializeDbFromString(SimpleTestCase):\n+    databases = {'default'}\n+\n+    def test_circular_reference(self):\n+        # deserialize_db_from_string() handles circular references.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj_ref\": 1, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get(pk=1)\n+        obj_ref = ObjectReference.objects.get(pk=1)\n+        self.assertEqual(obj.obj_ref_id, obj_ref.pk)\n+        self.assertEqual(obj_ref.obj_id, obj.pk)\n \n-class TestDbSignatureTests(SimpleTestCase):\n+    def test_no_references(self):\n+        # Test deserializing objects without foreign keys.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 2,\n+                \"fields\": {\"related_objects\": []}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get(pk=2)\n+        self.assertIsNotNone(obj)\n+        self.assertFalse(obj.related_objects.exists())\n+        \n+    def test_reverse_order(self):\n+        # Test deserialization with reverse order of reference.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 2,\n+                \"fields\": {\"obj\": 2}\n+            },\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 2,\n+                \"fields\": {\"obj_ref\": 2, \"related_objects\": []}\n+            }\n+        ]\n+        \"\"\"\n+        # This should work due to the transaction wrapping\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get(pk=2)\n+        obj_ref = ObjectReference.objects.get(pk=2)\n+        self.assertEqual(obj.obj_ref_id, obj_ref.pk)\n+        self.assertEqual(obj_ref.obj_id, obj.pk)\n     def test_default_name(self):\n         # A test db name isn't set.\n         prod_name = 'hodor'\n",
  "django__django-12497": "diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 057ec3a..99b8239 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -159,7 +159,34 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n-    def test_relationship_model_with_foreign_key_to_wrong_model(self):\n+    def test_ambiguous_relationship_with_missing_through_fields(self):\n+        class Person(models.Model):\n+            pass\n+\n+        class Group(models.Model):\n+            members = models.ManyToManyField('Person', through=\"AmbiguousAndComplexRelationship\")\n+\n+        class AmbiguousAndComplexRelationship(models.Model):\n+            person = models.ForeignKey(Person, models.CASCADE)\n+            group1 = models.ForeignKey(Group, models.CASCADE, related_name='group1')\n+            group2 = models.ForeignKey(Group, models.CASCADE, related_name='group2')\n+\n+        field = Group._meta.get_field('members')\n+        self.assertEqual(field.check(from_model=Group), [\n+            Error(\n+                \"The model is used as an intermediate model by \"\n+                \"'invalid_models_tests.Group.members', but it has more than one \"\n+                \"foreign key from 'Group', which is ambiguous. You must \"\n+                \"specify which foreign key Django should use via the \"\n+                \"through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"AmbiguousAndComplexRelationship\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n         class WrongModel(models.Model):\n             pass\n \n",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..0bab98d 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1241,6 +1241,97 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleansed_substitute,\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n+    def test_get_safe_settings_handles_nested_structures(self):\n+        class TestSettings:\n+            MY_SETTING = {\n+                \"foo\": \"value\",\n+                \"secret\": \"value\",\n+                \"token\": \"value\",\n+                \"something\": [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": \"value\"},\n+                    {\"token\": \"value\"},\n+                ],\n+                \"else\": [\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"value\"},\n+                        {\"token\": \"value\"},\n+                    ],\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"value\"},\n+                        {\"token\": \"value\"},\n+                    ],\n+                ],\n+            }\n+        \n+        reporter_filter = SafeExceptionReporterFilter()\n+        original_settings = settings\n+        try:\n+            globals()['settings'] = TestSettings\n+            safe_settings = reporter_filter.get_safe_settings()[\"MY_SETTING\"]\n+            expected_cleansed = {\n+                \"foo\": \"value\",\n+                \"secret\": \"********************\",\n+                \"token\": \"********************\",\n+                \"something\": [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": \"********************\"},\n+                    {\"token\": \"********************\"},\n+                ],\n+                \"else\": [\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"********************\"},\n+                        {\"token\": \"********************\"},\n+                    ],\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"********************\"},\n+                        {\"token\": \"********************\"},\n+                    ],\n+                ],\n+            }\n+            self.assertEqual(safe_settings, expected_cleansed)\n+        finally:\n+            globals()['settings'] = original_settings\n+\n     def test_cleanse_setting_recurses_in_dictionary(self):\n         reporter_filter = SafeExceptionReporterFilter()\n         initial = {'login': 'cooper', 'password': 'secret'}\n@@ -1249,6 +1340,97 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n+    def test_get_safe_settings_handles_nested_structures(self):\n+        class TestSettings:\n+            MY_SETTING = {\n+                \"foo\": \"value\",\n+                \"secret\": \"value\",\n+                \"token\": \"value\",\n+                \"something\": [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": \"value\"},\n+                    {\"token\": \"value\"},\n+                ],\n+                \"else\": [\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"value\"},\n+                        {\"token\": \"value\"},\n+                    ],\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"value\"},\n+                        {\"token\": \"value\"},\n+                    ],\n+                ],\n+            }\n+        \n+        reporter_filter = SafeExceptionReporterFilter()\n+        original_settings = settings\n+        try:\n+            globals()['settings'] = TestSettings\n+            safe_settings = reporter_filter.get_safe_settings()[\"MY_SETTING\"]\n+            expected_cleansed = {\n+                \"foo\": \"value\",\n+                \"secret\": \"********************\",\n+                \"token\": \"********************\",\n+                \"something\": [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": \"********************\"},\n+                    {\"token\": \"********************\"},\n+                ],\n+                \"else\": [\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"********************\"},\n+                        {\"token\": \"********************\"},\n+                    ],\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"********************\"},\n+                        {\"token\": \"********************\"},\n+                    ],\n+                ],\n+            }\n+            self.assertEqual(safe_settings, expected_cleansed)\n+        finally:\n+            globals()['settings'] = original_settings\n+\n     def test_request_meta_filtering(self):\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n@@ -1257,6 +1439,97 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleansed_substitute,\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n+    def test_get_safe_settings_handles_nested_structures(self):\n+        class TestSettings:\n+            MY_SETTING = {\n+                \"foo\": \"value\",\n+                \"secret\": \"value\",\n+                \"token\": \"value\",\n+                \"something\": [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": \"value\"},\n+                    {\"token\": \"value\"},\n+                ],\n+                \"else\": [\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"value\"},\n+                        {\"token\": \"value\"},\n+                    ],\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"value\"},\n+                        {\"token\": \"value\"},\n+                    ],\n+                ],\n+            }\n+        \n+        reporter_filter = SafeExceptionReporterFilter()\n+        original_settings = settings\n+        try:\n+            globals()['settings'] = TestSettings\n+            safe_settings = reporter_filter.get_safe_settings()[\"MY_SETTING\"]\n+            expected_cleansed = {\n+                \"foo\": \"value\",\n+                \"secret\": \"********************\",\n+                \"token\": \"********************\",\n+                \"something\": [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": \"********************\"},\n+                    {\"token\": \"********************\"},\n+                ],\n+                \"else\": [\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"********************\"},\n+                        {\"token\": \"********************\"},\n+                    ],\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"********************\"},\n+                        {\"token\": \"********************\"},\n+                    ],\n+                ],\n+            }\n+            self.assertEqual(safe_settings, expected_cleansed)\n+        finally:\n+            globals()['settings'] = original_settings\n+\n     def test_exception_report_uses_meta_filtering(self):\n         response = self.client.get('/raises500/', HTTP_SECRET_HEADER='super_secret')\n         self.assertNotIn(b'super_secret', response.content)\n@@ -1265,6 +1538,97 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             HTTP_SECRET_HEADER='super_secret',\n             HTTP_ACCEPT='application/json',\n         )\n+\n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n+    def test_get_safe_settings_handles_nested_structures(self):\n+        class TestSettings:\n+            MY_SETTING = {\n+                \"foo\": \"value\",\n+                \"secret\": \"value\",\n+                \"token\": \"value\",\n+                \"something\": [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": \"value\"},\n+                    {\"token\": \"value\"},\n+                ],\n+                \"else\": [\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"value\"},\n+                        {\"token\": \"value\"},\n+                    ],\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"value\"},\n+                        {\"token\": \"value\"},\n+                    ],\n+                ],\n+            }\n+        \n+        reporter_filter = SafeExceptionReporterFilter()\n+        original_settings = settings\n+        try:\n+            globals()['settings'] = TestSettings\n+            safe_settings = reporter_filter.get_safe_settings()[\"MY_SETTING\"]\n+            expected_cleansed = {\n+                \"foo\": \"value\",\n+                \"secret\": \"********************\",\n+                \"token\": \"********************\",\n+                \"something\": [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": \"********************\"},\n+                    {\"token\": \"********************\"},\n+                ],\n+                \"else\": [\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"********************\"},\n+                        {\"token\": \"********************\"},\n+                    ],\n+                    [\n+                        {\"foo\": \"value\"},\n+                        {\"secret\": \"********************\"},\n+                        {\"token\": \"********************\"},\n+                    ],\n+                ],\n+            }\n+            self.assertEqual(safe_settings, expected_cleansed)\n+        finally:\n+            globals()['settings'] = original_settings\n         self.assertNotIn(b'super_secret', response.content)\n \n \n",
  "django__django-12708": "",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..2bcf8c7 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -560,7 +560,34 @@ class DeletionTests(TestCase):\n         for k, v in existed_objs.items():\n             self.assertEqual(deleted_objs[k], v)\n \n-    def test_proxied_model_duplicate_queries(self):\n+    def test_zero_deletion_with_foreign_keys(self):\n+        \"\"\"\n+        Test the deletion of a QuerySet with zero objects and models with foreign keys.\n+        The expected behavior is to return (0, {'my_app.ModelName': 0}) for all models.\n+        \"\"\"\n+        # Assuming RelatedModel has a ForeignKey to MainModel\n+        MainModel.objects.create()  # Create an object and then not filter it\n+        deleted, deleted_objs = MainModel.objects.filter(id=-1).delete()  # This filter should match no records\n+\n+        self.assertEqual(deleted, 0)\n+        # Ensure all relevant models are present with 0 deletions in the dictionary\n+        self.assertIn('my_app.MainModel', deleted_objs)\n+        self.assertIn('my_app.RelatedModel', deleted_objs)\n+        self.assertEqual(deleted_objs['my_app.MainModel'], 0)\n+        self.assertEqual(deleted_objs['my_app.RelatedModel'], 0)\n+\n+    def test_zero_deletion_without_foreign_keys(self):\n+        \"\"\"\n+        Test the deletion of a QuerySet with zero objects and models without foreign keys.\n+        The expected behavior is to return (0, {'my_app.SimpleModel': 0}).\n+        \"\"\"\n+        SimpleModel.objects.create()  # Create an object and then not filter it\n+        deleted, deleted_objs = SimpleModel.objects.filter(id=-1).delete()  # This filter should match no records\n+\n+        self.assertEqual(deleted, 0)\n+        # Ensure SimpleModel is present with 0 deletions in the dictionary\n+        self.assertIn('my_app.SimpleModel', deleted_objs)\n+        self.assertEqual(deleted_objs['my_app.SimpleModel'], 0)\n         \"\"\"\n         #25685 - Deleting instances of a model with existing proxy\n         classes should not issue multiple queries during cascade\n",
  "django__django-12856": "",
  "django__django-12915": "diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex 72f5bd1..7baa467 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -79,7 +79,56 @@ class ASGITest(SimpleTestCase):\n         # Allow response.close() to finish.\n         await communicator.wait()\n \n-    async def test_headers(self):\n+    async def test_async_static_file_response(self):\n+        # This test verifies that the ASGIStaticFilesHandler correctly handles an async static file request.\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        # Construct HTTP request.\n+        scope = self.async_request_factory._base_scope(path='/static/testfile.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+\n+        # Get the file content.\n+        test_static_root = Path(__file__).parent / 'project' / 'static'\n+        file_path = test_static_root / 'testfile.txt'\n+        with open(file_path, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+\n+        # Read the response.\n+        stat = file_path.stat()\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', str(len(test_file_contents)).encode('ascii')),\n+                (b'Content-Type', b'text/plain'),\n+                (b'Content-Disposition', b'inline; filename=\"testfile.txt\"'),\n+                (b'Last-Modified', http_date(stat.st_mtime).encode('ascii')),\n+            },\n+        )\n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], test_file_contents)\n+        # Allow response.close() to finish.\n+        await communicator.wait()\n+\n+    async def test_async_static_file_response_not_found(self):\n+        # This test verifies that the ASGIStaticFilesHandler returns a 404 response for a non-existent file.\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        # Construct HTTP request to a non-existent file.\n+        scope = self.async_request_factory._base_scope(path='/static/non-existent.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+\n+        # Read the response.\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 404)\n+        \n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], b'')  # Typically the body will be empty for a 404\n         application = get_asgi_application()\n         communicator = ApplicationCommunicator(\n             application,\n",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..beff001 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -203,6 +203,13 @@ class TestUtilsText(SimpleTestCase):\n         # interning the result may be useful, e.g. when fed to Path.\n         self.assertEqual(sys.intern(text.slugify('a')), 'a')\n \n+        # New test cases for leading and trailing underscores and dashes\n+        self.assertEqual(text.slugify(\"___This is a test ---\"), \"this-is-a-test\")\n+        self.assertEqual(text.slugify(\"-Leading and trailing-\"), \"leading-and-trailing\")\n+        self.assertEqual(text.slugify(\"_Leading_underscores_\"), \"leading-underscores\")\n+        self.assertEqual(text.slugify(\"---Multiple dashes---\"), \"multiple-dashes\")\n+        self.assertEqual(text.slugify(\"Normal--Text--With--Dashes--\"), \"normal-text-with-dashes\")\n+\n     @ignore_warnings(category=RemovedInDjango40Warning)\n     def test_unescape_entities(self):\n         items = [\n",
  "django__django-13028": "",
  "django__django-13158": "",
  "django__django-13230": "",
  "django__django-13315": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 64b15bf..7ca1426 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2819,7 +2819,66 @@ class LimitChoicesToTests(TestCase):\n         fields = fields_for_model(StumpJoke, ['has_fooled_today'])\n         self.assertSequenceEqual(fields['has_fooled_today'].queryset, [self.threepwood])\n \n-    def test_callable_called_each_time_form_is_instantiated(self):\n+    @isolate_apps('model_forms')\n+    def test_limit_choices_to_no_duplicates(self):\n+        marley = Character.objects.create(username='Marley', last_action='2023-01-01T00:00:00Z')\n+        threepwood = Character.objects.create(username='Threepwood', last_action='2023-01-01T00:00:00Z')\n+        \n+        joke1 = StumpJoke.objects.create(funny=True, most_recently_fooled=threepwood)\n+        joke2 = StumpJoke.objects.create(funny=True, most_recently_fooled=threepwood)\n+        joke3 = StumpJoke.objects.create(funny=True, most_recently_fooled=marley)\n+        StumpJoke.objects.create(funny=False, most_recently_fooled=marley)\n+        \n+        joke1.has_fooled_today.add(marley, threepwood)\n+        joke2.has_fooled_today.add(marley)\n+        joke3.has_fooled_today.add(marley, threepwood)\n+        \n+        class CharacterDetails(models.Model):\n+            character1 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_fk_1',\n+            )\n+            character2 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to={\n+                    'jokes__funny': True,\n+                    'jokes_today__funny': True,\n+                },\n+                related_name='details_fk_2',\n+            )\n+            character3 = models.ManyToManyField(\n+                Character,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_m2m_1',\n+            )\n+        \n+        class CharacterDetailsForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetails\n+                fields = '__all__'\n+        \n+        form = CharacterDetailsForm()\n+        self.assertCountEqual(\n+            form.fields['character1'].queryset,\n+            [marley, threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character2'].queryset,\n+            [marley, threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character3'].queryset,\n+            [marley, threepwood],\n+        )\n         field = StumpJokeForm.base_fields['most_recently_fooled']\n         with mock.patch.object(field, 'limit_choices_to') as today_callable_dict:\n             StumpJokeForm()\n",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 536c423..210506b 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -11,7 +11,40 @@ from django.test.utils import isolate_apps\n \n @isolate_apps('model_inheritance')\n class AbstractInheritanceTests(SimpleTestCase):\n-    def test_single_parent(self):\n+    def test_abstract_inherited_fields_are_distinguishable(self):\n+        \"\"\"Ensure fields from different concrete models inheriting from\n+        the same abstract model are distinguishable.\"\"\"\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritAbstractModel1(AbstractModel):\n+            pass\n+\n+        class InheritAbstractModel2(AbstractModel):\n+            pass\n+\n+        # Retrieve fields\n+        inherit1_model_field = InheritAbstractModel1._meta.get_field('field')\n+        inherit2_model_field = InheritAbstractModel2._meta.get_field('field')\n+\n+        # Assertions check if fields are not considered equal\n+        self.assertNotEqual(inherit1_model_field, inherit2_model_field)\n+        self.assertNotEqual(hash(inherit1_model_field), hash(inherit2_model_field))\n+\n+        # Test ordering\n+        self.assertNotEqual(\n+            sorted([inherit1_model_field, inherit2_model_field]),\n+            [inherit1_model_field, inherit2_model_field]\n+        )\n+\n+        # Additional assertions to ensure each field retains uniqueness\n+        self.assertFalse(inherit1_model_field == inherit2_model_field)\n+        self.assertFalse(inherit1_model_field.__eq__(inherit2_model_field))\n+        self.assertFalse(inherit2_model_field == inherit1_model_field)\n+        self.assertFalse(inherit2_model_field.__eq__(inherit1_model_field))\n         class AbstractBase(models.Model):\n             name = models.CharField(max_length=30)\n \n@@ -347,4 +380,4 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('age', models.SmallIntegerField), ('concretemodel2_ptr', models.OneToOneField),\n                 ('name', models.CharField),\n             ]\n-        )\n+        )\n",
  "django__django-13447": "",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..6096918 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,9 +1,11 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n from django.contrib.auth.models import User\n from django.contrib.auth.tokens import PasswordResetTokenGenerator\n from django.test import TestCase\n+from .models import CustomEmailField, IntegerUsernameUser\n from django.test.utils import ignore_warnings\n from django.utils.deprecation import RemovedInDjango40Warning\n \n@@ -37,7 +39,45 @@ class TokenGeneratorTest(TestCase):\n         tk2 = p0.make_token(user_reload)\n         self.assertEqual(tk1, tk2)\n \n-    def test_timeout(self):\n+    def test_token_with_email_change(self):\n+        \"\"\"Updating the user's email address invalidates the password reset token.\"\"\"\n+        tests = [\n+            (CustomEmailField, None),  # A model where email can be None\n+            (CustomEmailField, 'test4@example.com'),  # A model with an initial email\n+            (User, 'test4@example.com'),  # Standard user model with email\n+        ]\n+        for model, email in tests:\n+            with self.subTest(model=model.__qualname__, email=email):\n+                user = model.objects.create_user(\n+                    'changeemailuser',\n+                    email=email,\n+                    password='testpw',\n+                )\n+                p0 = PasswordResetTokenGenerator()\n+                # Create token with initial email\n+                tk1 = p0.make_token(user)\n+                self.assertTrue(p0.check_token(user, tk1))\n+                \n+                # Change email address\n+                setattr(user, user.get_email_field_name(), 'newemail@example.com')\n+                user.save()\n+                \n+                # The token should now be invalid\n+                self.assertFalse(p0.check_token(user, tk1))\n+\n+    def test_token_persistence_unaffected_by_username(self):\n+        \"\"\"Ensure changing the username doesn't affect the password reset token.\"\"\"\n+        user = User.objects.create_user('originaluser', 'test@example.com', 'testpw')\n+        p0 = PasswordResetTokenGenerator()\n+        tk1 = p0.make_token(user)\n+        self.assertTrue(p0.check_token(user, tk1))\n+        \n+        # Change username\n+        user.username = 'changeduser'\n+        user.save()\n+        \n+        # The token should still be valid since username change should not affect it\n+        self.assertTrue(p0.check_token(user, tk1))\n         \"\"\"The token is valid after n seconds, but no greater.\"\"\"\n         # Uses a mocked version of PasswordResetTokenGenerator so we can change\n         # the value of 'now'.\n",
  "django__django-13590": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 0b4f73f..4160e43 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import pickle\n import unittest\n@@ -884,6 +885,30 @@ class IterableLookupInnerExpressionsTests(TestCase):\n             ordered=False\n         )\n \n+    from collections import namedtuple\n+\n+    def test_range_lookup_namedtuple(self):\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=51, maximum=100),\n+        )\n+        self.assertSequenceEqual(qs, [self.c5])\n+\n+    def test_range_lookup_namedtuple_with_different_values(self):\n+        CustomRange = namedtuple('CustomRange', ['start', 'end'])\n+        qs = Company.objects.filter(\n+            num_employees__range=CustomRange(start=10, end=100),\n+        )\n+        expected_companies = ['<Company: 5020 Ltd>', '<Company: 5040 Ltd>', '<Company: 5050 Ltd>', '<Company: 5060 Ltd>', '<Company: 99300 Ltd>']\n+        self.assertQuerysetEqual(qs, expected_companies, ordered=False)\n+\n+    def test_range_lookup_namedtuple_with_strict_bounds(self):\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=99, maximum=99),\n+        )\n+        self.assertSequenceEqual(qs, [self.c5])\n+\n     @unittest.skipUnless(connection.vendor == 'sqlite',\n                          \"This defensive test only works on databases that don't validate parameter types\")\n     def test_complex_expressions_do_not_introduce_sql_injection_via_untrusted_string_inclusion(self):\n",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..b7058ad 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -31,6 +31,7 @@ from django.db.migrations.recorder import MigrationRecorder\n from django.test import (\n     LiveServerTestCase, SimpleTestCase, TestCase, override_settings,\n )\n+from unittest import mock\n \n custom_templates_dir = os.path.join(os.path.dirname(__file__), 'custom_templates')\n \n@@ -1866,6 +1867,33 @@ class ArgumentOrder(AdminScriptTestCase):\n             \"('verbosity', 1)]\" % option_b\n         )\n \n+class ExecuteFromCommandLine(SimpleTestCase):\n+    def test_program_name_from_argv(self):\n+        \"\"\"\n+        Program name is computed from the execute_from_command_line()'s argv\n+        argument, not sys.argv.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line(['django-admin'] + args)\n+        self.assertIn('usage: django-admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+    \n+    def test_prog_name_with_correct_sys_argv(self):\n+        \"\"\"\n+        Test that the prog name is correctly taken from sys.argv when\n+        execute_from_command_line is called without an argv argument.\n+        \"\"\"\n+        original_argv = sys.argv\n+        try:\n+            sys.argv = ['my_program', 'runserver']\n+            with captured_stdout() as out, captured_stderr() as err:\n+                execute_from_command_line()\n+            self.assertIn('usage: my_program runserver', out.getvalue())\n+            self.assertEqual(err.getvalue(), '')\n+        finally:\n+            sys.argv = original_argv\n \n @override_settings(ROOT_URLCONF='admin_scripts.urls')\n class StartProject(LiveServerTestCase, AdminScriptTestCase):\n",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..9a05f76 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,3 +1,4 @@\n+\n import sys\n import unittest\n from unittest import mock\n@@ -30,6 +31,42 @@ class ShellCommandTestCase(SimpleTestCase):\n             call_command('shell')\n         self.assertEqual(stdout.getvalue().strip(), '100')\n \n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n+\n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n     @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n     @mock.patch.dict('sys.modules', {'IPython': None})\n     def test_shell_with_ipython_not_installed(self, select):\n@@ -37,6 +74,42 @@ class ShellCommandTestCase(SimpleTestCase):\n         with self.assertRaisesMessage(CommandError, \"Couldn't import ipython interface.\"):\n             call_command('shell', interface='ipython')\n \n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n+\n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n     @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n     @mock.patch.dict('sys.modules', {'bpython': None})\n     def test_shell_with_bpython_not_installed(self, select):\n@@ -49,4 +122,4 @@ class ShellCommandTestCase(SimpleTestCase):\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 2d83d62..b66f5e1 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -1071,6 +1071,39 @@ class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n         self.assertNotContains(response, '<h2>Model with both - plural name</h2>')\n         self.assertNotContains(response, 'Add another Model with both - name')\n \n+    def test_auto_plural_fallback(self):\n+        class AutoPluralFallbackInline(TabularInline):\n+            model = VerboseNameProfile\n+            verbose_name = 'Verbose Child'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [AutoPluralFallbackInline]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Check that the plural form uses the verbose_name with an 's' appended\n+        self.assertContains(response, '<h2>Verbose Childs</h2>')\n+        self.assertContains(response, 'Add another Verbose Child')\n+\n+    def test_no_verbose_name_provided(self):\n+        class NoVerboseNameInline(TabularInline):\n+            model = Profile\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [NoVerboseNameInline]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Check default behavior without verbose_name provided\n+        self.assertContains(response, '<h2>Profiles</h2>')\n+        self.assertContains(response, 'Add another Profile')\n+\n \n @override_settings(ROOT_URLCONF='admin_inlines.urls')\n class SeleniumTests(AdminSeleniumTestCase):\n",
  "django__django-13757": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex f53ff8c..97d75a2 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -596,6 +596,25 @@ class TestQuerying(TestCase):\n         )\n \n     def test_isnull_key_or_none(self):\n+        # This tests that objects explicitly having the key with JSON null are excluded\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],\n+        )\n+        # This tests the correct behavior of the current databases for isnull=True\n+        # namely, that objects having the key but with null values should not match\n+        # on SQLite and Oracle.\n+        if connection.vendor in ('sqlite', 'oracle'):\n+            obj_with_null = NullableJSONModel.objects.create(value={'j': None})\n+            self.assertNotIn(\n+                obj_with_null,\n+                NullableJSONModel.objects.filter(value__j__isnull=True)\n+            )\n+        else:\n+            self.assertSequenceEqual(\n+                NullableJSONModel.objects.filter(value__j__isnull=True),\n+                self.objs[:4] + self.objs[5:],\n+            )\n         obj = NullableJSONModel.objects.create(value={'a': None})\n         self.assertSequenceEqual(\n             NullableJSONModel.objects.filter(Q(value__a__isnull=True) | Q(value__a=None)),\n",
  "django__django-13768": "diff --git a/tests/dispatch/tests.py b/tests/dispatch/tests.py\nindex b1feefd..52db26c 100644\n--- a/tests/dispatch/tests.py\n+++ b/tests/dispatch/tests.py\n@@ -165,13 +165,29 @@ class DispatcherTests(SimpleTestCase):\n         def fails(val, **kwargs):\n             raise ValueError('this')\n         a_signal.connect(fails)\n-        result = a_signal.send_robust(sender=self, val=\"test\")\n-        err = result[0][1]\n-        self.assertIsInstance(err, ValueError)\n-        self.assertEqual(err.args, ('this',))\n-        self.assertTrue(hasattr(err, '__traceback__'))\n-        self.assertIsInstance(err.__traceback__, TracebackType)\n-        a_signal.disconnect(fails)\n+        try:\n+            with self.assertLogs('django.dispatch', 'ERROR') as cm:\n+                # Send signal which should cause the receiver to raise an error.\n+                result = a_signal.send_robust(sender=self, val=\"test\")\n+            \n+            err = result[0][1]\n+            self.assertIsInstance(err, ValueError)\n+            self.assertEqual(err.args, ('this',))\n+            self.assertTrue(hasattr(err, '__traceback__'))\n+            self.assertIsInstance(err.__traceback__, TracebackType)\n+\n+            # Verify logging records for the error.\n+            log_record = cm.records[0]\n+            self.assertEqual(\n+                log_record.getMessage(),\n+                f\"Error calling {fails.__qualname__} in Signal.send_robust() (this)\"\n+            )\n+            self.assertIsNotNone(log_record.exc_info)\n+            _, exc_value, _ = log_record.exc_info\n+            self.assertIsInstance(exc_value, ValueError)\n+            self.assertEqual(str(exc_value), 'this')\n+        finally:\n+            a_signal.disconnect(fails)\n         self.assertTestIsClean(a_signal)\n \n     def test_disconnection(self):\n",
  "django__django-13925": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 6424d89..6511e6f 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -395,6 +395,16 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_inherited_manual_pk(self):\n+        # Test that no warning is issued if a child model inherits a manually specified primary key.\n+        class Parent(models.Model):\n+            my_id = models.AutoField(primary_key=True)\n+\n+        class Child(Parent):\n+            pass\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.BigAutoField')\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n@@ -414,4 +424,4 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n             class Meta:\n                 app_label = 'check_framework.apps.CheckPKConfig'\n \n-        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..d60bc84 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -272,8 +272,26 @@ class FormsErrorMessagesTestCase(SimpleTestCase, AssertFormErrorsMixin):\n \n         class SomeForm(Form):\n             field = ModelMultipleChoiceField(ChoiceModel.objects.all())\n-\n         f = SomeForm({'field': ['<script>']})\n+        \n+    def test_modelchoicefield_value_placeholder(self):\n+        # Create choices for the model choice field tests.\n+        ChoiceModel.objects.create(pk=1, name='a')\n+        ChoiceModel.objects.create(pk=2, name='b')\n+        ChoiceModel.objects.create(pk=3, name='c')\n+\n+        # Test the value placeholder in the ModelChoiceField validation error message\n+        f = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            },\n+        )\n+        self.assertFormErrors(\n+            ['\"invalid\" is not one of the available choices.'],\n+            f.clean,\n+            'invalid',\n+        )\n         self.assertHTMLEqual(\n             t.render(Context({'form': f})),\n             '<ul class=\"errorlist\"><li>field<ul class=\"errorlist\">'\n@@ -307,4 +325,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "diff --git a/tests/many_to_one/models.py b/tests/many_to_one/models.py\nindex 1078928..6f7055b 100644\n--- a/tests/many_to_one/models.py\n+++ b/tests/many_to_one/models.py\n@@ -81,7 +81,12 @@ class ToFieldChild(models.Model):\n     parent = models.ForeignKey(Parent, models.CASCADE, to_field='name', related_name='to_field_children')\n \n \n-# Multiple paths to the same model (#7110, #7125)\n+class ParentStringPrimaryKey(models.Model):\n+    name = models.CharField(primary_key=True, max_length=15)\n+\n+\n+class ChildStringPrimaryKeyParent(models.Model):\n+    parent = models.ForeignKey(ParentStringPrimaryKey, on_delete=models.CASCADE)\n class Category(models.Model):\n     name = models.CharField(max_length=20)\n \n",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..084d852 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,9 +1,20 @@\n+\n from django.db.models import F, Q\n from django.test import SimpleTestCase\n \n \n class QTests(SimpleTestCase):\n-    def test_combine_and_empty(self):\n+    def test_combine_dict_keys_and_operator(self):\n+        \"\"\"Test combining Q objects using AND with dict_keys.\"\"\"\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q & Q(), q)\n+        self.assertEqual(Q() & q, q)\n+\n+    def test_combine_dict_keys_or_operator(self):\n+        \"\"\"Test combining Q objects using OR with dict_keys.\"\"\"\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n         q = Q(x=1)\n         self.assertEqual(q & Q(), q)\n         self.assertEqual(Q() & q, q)\n",
  "django__django-14017": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 707f339..16c4dc9 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -25,6 +25,7 @@ from django.db.models.functions import (\n from django.db.models.sql import constants\n from django.db.models.sql.datastructures import Join\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n+from django.db.models import Exists, OuterRef, Q\n from django.test.utils import (\n     Approximate, CaptureQueriesContext, isolate_apps, register_lookup,\n )\n@@ -794,7 +795,20 @@ class BasicExpressionsTests(TestCase):\n         )\n         self.assertCountEqual(qs, [self.example_inc.ceo, self.foobar_ltd.ceo, self.max])\n \n-    def test_boolean_expression_combined(self):\n+    def test_q_exists_commutativity(self):\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        tests = [\n+            Q(salary__gte=30) & Exists(is_ceo),\n+            Exists(is_ceo) & Q(salary__gte=30),\n+            Q() & Exists(is_ceo),\n+            Exists(is_ceo) & Q(),\n+        ]\n+        for idx, conditions in enumerate(tests):\n+            with self.subTest(idx=idx, conditions=conditions):\n+                self.assertCountEqual(Employee.objects.filter(conditions), [self.max])\n         is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n         is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n         self.gmbh.point_of_contact = self.max\n",
  "django__django-14155": "",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..3eaf558 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,4 +1,6 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n+from django.test.utils import isolate_apps\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n from django.test.utils import isolate_apps\n@@ -65,8 +67,31 @@ class TestDefaultPK(SimpleTestCase):\n         with self.assertRaisesMessage(ImproperlyConfigured, msg):\n             class Model(models.Model):\n                 pass\n+    @isolate_apps('model_options')\n+    @override_settings(\n+        DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField'\n+    )\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(\n+        DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField'\n+    )\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n@@ -81,8 +106,31 @@ class TestDefaultPK(SimpleTestCase):\n             pass\n \n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n+    @isolate_apps('model_options')\n+    @override_settings(\n+        DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField'\n+    )\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(\n+        DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField'\n+    )\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_m2m_default_auto_field_setting(self):\n         class M2MModel(models.Model):\n",
  "django__django-14382": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex afeed3e..489bd30 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2197,7 +2197,24 @@ class StartApp(AdminScriptTestCase):\n                     \"make sure the directory is a valid identifier.\" % bad_target\n                 )\n \n-    def test_importable_target_name(self):\n+    def test_trailing_slash_in_target_app_directory_name(self):\n+        app_dir = os.path.join(self.test_dir, 'apps', 'app2/')\n+        os.makedirs(os.path.dirname(app_dir))  # Just create the `apps` directory\n+        _, err = self.run_django_admin(['startapp', 'app2', app_dir])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n+\n+    def test_no_trailing_slash_in_target_app_directory_name(self):\n+        app_dir = os.path.join(self.test_dir, 'apps', 'app3')\n+        os.makedirs(os.path.dirname(app_dir))  # Just create the `apps` directory\n+        _, err = self.run_django_admin(['startapp', 'app3', app_dir])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n+\n+    def test_nonexistent_directory_with_slash(self):\n+        app_dir = os.path.join(self.test_dir, 'nonexistent/')\n+        _, err = self.run_django_admin(['startapp', 'app4', app_dir])\n+        self.assertOutput(err, \"CommandError: Destination directory '{}' does not exist, please create it first.\".format(app_dir))\n         _, err = self.run_django_admin(['startapp', 'app', 'os'])\n         self.assertOutput(\n             err,\n",
  "django__django-14411": "",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..0b344ed 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -658,7 +658,38 @@ class WriterTests(SimpleTestCase):\n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n \n-    def test_simple_migration(self):\n+    def test_serialize_model_with_mixin(self):\n+        \"\"\"\n+        Tests that a model which uses mixins and custom fields\n+        generates a migration file with the correct imports.\n+        \"\"\"\n+        from django.db import models\n+        from django.db.migrations.writer import MigrationWriter\n+\n+        class MyField(models.TextField):\n+            pass\n+\n+        class MyBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        class MyMixin:\n+            pass\n+\n+        class MyModel(MyMixin, MyBaseModel):\n+            name = MyField(primary_key=True)\n+\n+        # Simulate the creation of a migration operation for MyModel\n+        migration_writer = MigrationWriter(None)\n+        serialized_model = migration_writer.serialize(models.Model)\n+        \n+        # This is where we specifically validate the serialized result\n+        expected_serialization = (\"('models.Model', {'from django.db import models'})\", set())\n+        self.assertSerializedResultEqual(serialized_model, expected_serialization)\n+\n+        # Check if generated imports include 'from django.db import models'\n+        imports = migration_writer.get_imports()\n+        self.assertIn(\"from django.db import models\", imports)\n         \"\"\"\n         Tests serializing a simple migration.\n         \"\"\"\n",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..1e09270 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -338,6 +338,12 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['Please submit at most 1 form.'])\n \n+        # Additional test to check for nonform CSS class\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>Please submit at most 1 form.</li></ul>'\n+        )\n+\n     def test_formset_validate_min_flag(self):\n         \"\"\"\n         If validate_min is set and min_num is more than TOTAL_FORMS in the\n@@ -360,6 +366,12 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['Please submit at least 3 forms.'])\n \n+        # Additional test to check for nonform CSS class\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>Please submit at least 3 forms.</li></ul>'\n+        )\n+\n     def test_formset_validate_min_unchanged_forms(self):\n         \"\"\"\n         min_num validation doesn't consider unchanged forms with initial data\n@@ -984,6 +996,12 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n \n+        # Additional test to check for nonform CSS class\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>You may only specify a drink once.</li></ul>'\n+        )\n+\n     def test_formset_iteration(self):\n         \"\"\"Formset instances are iterable.\"\"\"\n         ChoiceFormset = formset_factory(Choice, extra=3)\n",
  "django__django-14672": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex d9eaabe..eea042a 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -20,7 +20,37 @@ class M2mThroughTests(TestCase):\n         cls.rock = Group.objects.create(name='Rock')\n         cls.roll = Group.objects.create(name='Roll')\n \n-    def test_retrieve_intermediate_items(self):\n+    def test_through_fields_hashable(self):\n+        class Parent(models.Model):\n+            name = models.CharField(max_length=256)\n+\n+        class ProxyParent(Parent):\n+            class Meta:\n+                proxy = True\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+            many_to_many_field = models.ManyToManyField(\n+                to=Parent,\n+                through=\"ManyToManyModel\",\n+                through_fields=['child', 'parent'],\n+                related_name=\"something\"\n+            )\n+\n+        class ManyToManyModel(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n+            child = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n+            second_child = models.ForeignKey(Child, on_delete=models.CASCADE, null=True, default=None)\n+\n+        # Attempt to retrieve through_fields and assert they are hashable\n+        m2m_field = Child._meta.get_field('many_to_many_field')\n+        try:\n+            hash(m2m_field.through_fields)\n+            through_fields_hashable = True\n+        except TypeError:\n+            through_fields_hashable = False\n+\n+        self.assertTrue(through_fields_hashable, \"through_fields should be hashable after the fix.\")\n         Membership.objects.create(person=self.jim, group=self.rock)\n         Membership.objects.create(person=self.jane, group=self.rock)\n \n",
  "django__django-14752": "",
  "django__django-14787": "",
  "django__django-14855": "diff --git a/tests/admin_views/admin.py b/tests/admin_views/admin.py\nindex 7959ba6..98ea20d 100644\n--- a/tests/admin_views/admin.py\n+++ b/tests/admin_views/admin.py\n@@ -1149,8 +1149,14 @@ site7.register(Section)\n site7.register(PrePopulatedPost, PrePopulatedPostReadOnlyAdmin)\n \n \n+site2.register(ReadOnlyRelatedField, ReadOnlyRelatedFieldAdmin)\n+site2.register(Language)\n+\n+...\n+\n # Used to test ModelAdmin.sortable_by and get_sortable_by().\n-class ArticleAdmin6(admin.ModelAdmin):\n+class ReadOnlyRelatedFieldAdmin(admin.ModelAdmin):\n+    readonly_fields = ('language',)\n     list_display = (\n         'content', 'date', callable_year, 'model_year', 'modeladmin_year',\n         'model_year_reversed', 'section',\n",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..8bb77cc 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,9 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n",
  "django__django-14999": "",
  "django__django-15061": "",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..a107bc9 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -107,7 +107,17 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n                 with self.assertRaisesMessage(ValidationError, msg):\n                     f.clean(value)\n \n-    def test_urlfield_clean_required(self):\n+    def test_issue_urlfield_valueerror(self):\n+        f = URLField()\n+        tests = [\n+            '////]@N.AN',  # Originally reported issue - should raise ValidationError\n+            '#@A.bO'      # Empty hostname issue - also should raise ValidationError\n+        ]\n+        msg = \"'Enter a valid URL.'\"\n+        for value in tests:\n+            with self.subTest(value=value):\n+                with self.assertRaisesMessage(ValidationError, msg):\n+                    f.clean(value)\n         f = URLField()\n         msg = \"'This field is required.'\"\n         with self.assertRaisesMessage(ValidationError, msg):\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..91added 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -11,7 +11,7 @@ from django.db.models.expressions import RawSQL\n from django.db.models.functions import (\n     Coalesce, ExtractYear, Floor, Length, Lower, Trim,\n )\n-from django.test import TestCase, skipUnlessDBFeature\n+from django.test import TestCase, skipUnlessDBFeature, skipIfDBFeature\n from django.test.utils import register_lookup\n \n from .models import (\n",
  "django__django-15347": "",
  "django__django-15388": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex 42ab5ba..503a703 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -1,4 +1,5 @@\n from pathlib import Path\n+from pathlib import Path\n from unittest import mock\n \n from django.template import autoreload\n@@ -39,7 +40,18 @@ class TemplateReloadTests(SimpleTestCase):\n         self.assertIsNone(autoreload.template_changed(None, Path(__file__)))\n         mock_reset.assert_not_called()\n \n-    def test_watch_for_template_changes(self):\n+    @override_settings(\n+        TEMPLATES=[{\n+            'DIRS': [ROOT],  # Mimic the same action as inserting BASE_DIR directly\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]\n+    )\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    def test_base_dir_in_dirs_prevents_reload(self, mock_reset):\n+        # Ensure `template_changed` does not falsely trigger with root directory files\n+        dummy_file_path = ROOT / 'dummy.txt'\n+        self.assertIsNone(autoreload.template_changed(None, dummy_file_path))\n+        mock_reset.assert_not_called()\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n         self.assertSequenceEqual(\n@@ -88,7 +100,18 @@ class TemplateReloadTests(SimpleTestCase):\n @require_jinja2\n @override_settings(INSTALLED_APPS=['template_tests'])\n class Jinja2TemplateReloadTests(SimpleTestCase):\n-    def test_watch_for_template_changes(self):\n+    @override_settings(\n+        TEMPLATES=[{\n+            'DIRS': [ROOT],  # Mimic the same action as inserting BASE_DIR directly\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]\n+    )\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    def test_base_dir_in_dirs_prevents_reload(self, mock_reset):\n+        # Ensure `template_changed` does not falsely trigger with root directory files\n+        dummy_file_path = ROOT / 'dummy.txt'\n+        self.assertIsNone(autoreload.template_changed(None, dummy_file_path))\n+        mock_reset.assert_not_called()\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n         self.assertSequenceEqual(\n",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..ba57d49 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -184,7 +185,12 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n-    def test_was_modified_since_fp(self):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"\n+        Test that was_modified_since does not raise an exception for an empty string\n+        and returns True as expected.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=\"\", mtime=1))\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n         \"\"\"\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..4da323a 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,3 +1,4 @@\n+\n import os\n from io import StringIO\n from unittest import mock\n@@ -411,6 +412,24 @@ class CommandTests(SimpleTestCase):\n         parser = BaseCommand().create_parser(\"prog_name\", \"subcommand\", epilog=epilog)\n         self.assertEqual(parser.epilog, epilog)\n \n+    def test_custom_command_formatter_example_usage(self):\n+        \"\"\"Test that the command help output format includes a newline after 'Example usage:'.\"\"\"\n+        epilog = '''\n+        Import a contract from tzkt\n+        Example usage:\n+            ./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\n+        '''\n+        command = BaseCommand()\n+        command.help = epilog\n+        parser = command.create_parser(\"prog_name\", \"tzkt_import\")\n+        help_output = parser.format_help()\n+        \n+        # Ensure the help description ends with a newline for example usage.\n+        expected_help_ending = \"Import a contract from tzkt\\n\" \\\n+                               \"Example usage: \\n\" \\\n+                               \"    ./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\\n\"\n+        self.assertIn(expected_help_ending, help_output)\n+\n     def test_outputwrapper_flush(self):\n         out = StringIO()\n         with mock.patch.object(out, \"flush\") as mocked_flush:\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..3aad3a2 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,7 +1,10 @@\n+\n import os\n from datetime import datetime\n \n from django.test import SimpleTestCase\n+from django.core.serializers.json import DjangoJSONEncoder\n+import json\n from django.utils.functional import lazystr\n from django.utils.html import (\n     conditional_escape,\n@@ -217,6 +220,32 @@ class TestUtilsHtml(SimpleTestCase):\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n         )\n \n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"hello\": \"world\"}'\n+\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"hello\": \"world\"}</script>',\n+        )\n+\n+    def test_json_script_default_encoder(self):\n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}),\n+            '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n+        )\n+\n+    def test_json_script_with_custom_encoder_and_id(self):\n+        class ReverseDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return json.dumps({k: str(v)[::-1] for k, v in o.items()})\n+\n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}, element_id=\"reverse_id\", encoder=ReverseDjangoJSONEncoder),\n+            '<script id=\"reverse_id\" type=\"application/json\">{\"key\": \"eulav\"}</script>',\n+        )\n+\n     def test_smart_urlquote(self):\n         items = (\n             (\"http://\u00f6\u00e4\u00fc.com/\", \"http://xn--4ca9at.com/\"),\n",
  "django__django-15790": "diff --git a/tests/check_framework/test_templates.py b/tests/check_framework/test_templates.py\nindex 72e6cfe..194927b 100644\n--- a/tests/check_framework/test_templates.py\n+++ b/tests/check_framework/test_templates.py\n@@ -121,6 +121,9 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n \n     @staticmethod\n     def get_settings(module_name, module_path):\n+        \"\"\"\n+        Helper method to return template settings for a given module name and path.\n+        \"\"\"\n         return {\n             \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n             \"OPTIONS\": {\n@@ -142,6 +145,25 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n             [self.error_same_tags],\n         )\n \n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+        ]\n+    )\n+    def test_single_template_tag_library(self):\n+        \"\"\"Test with a single library to ensure no errors are raised.\"\"\"\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"single_tag\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [],\n+            )\n+\n     def test_template_tags_with_same_library_name(self):\n         with self.settings(\n             TEMPLATES=[\n@@ -158,6 +180,40 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n                 [self.error_same_tags],\n             )\n \n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+            \"check_framework.template_test_apps.different_tags_app\",\n+        ]\n+    )\n+    def test_template_tags_same_name_different_paths(self):\n+        \"\"\"Test libraries with the same name but different paths.\"\"\"\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"same_tags\", \"different_tags_app.templatetags.different_tags\"\n+                ),\n+                self.get_settings(\n+                    \"same_tags\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [\n+                    Error(\n+                        E003.msg.format(\n+                            \"'same_tags'\",\n+                            \"'check_framework.template_test_apps.different_tags_app.\"\n+                            \"templatetags.different_tags', \"\n+                            \"'check_framework.template_test_apps.same_tags_app_1.\"\n+                            \"templatetags.same_tags'\",\n+                        ),\n+                        id=E003.id,\n+                    )\n+                ],\n+            )\n+\n     @override_settings(\n         INSTALLED_APPS=[\"check_framework.template_test_apps.same_tags_app_1\"]\n     )\n@@ -206,4 +262,4 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n         ]\n     )\n     def test_template_tags_with_different_name(self):\n-        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..b83f38c 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -394,8 +394,23 @@ class ProxyModelTests(TestCase):\n         management.call_command(\"loaddata\", \"mypeople.json\", verbosity=0)\n         p = MyPerson.objects.get(pk=100)\n         self.assertEqual(p.name, \"Elvis Presley\")\n-\n-    def test_eq(self):\n+    def test_select_related_only_with_proxy(self):\n+        # Create the CustomModel instance\n+        custom_model_instance = CustomModel.objects.create(name=\"Custom Name\")\n+        \n+        # Create an instance of AnotherModel linking to the CustomModel's proxy\n+        another_model_instance = AnotherModel.objects.create(custom=custom_model_instance)\n+\n+        # Attempt to use select_related and only together with the proxy model\n+        queryset = AnotherModel.objects.select_related('custom').only('custom__name')\n+        \n+        # Check that the query can be evaluated, meaning no error should occur\n+        # We use list to force evaluation of the queryset\n+        result = list(queryset)\n+        \n+        # Ensure we get back the expected result\n+        self.assertEqual(len(result), 1)\n+        self.assertEqual(result[0], another_model_instance)\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n \n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..7540cc3 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -152,6 +152,11 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         )\n \n     def test_parameters(self):\n+        # Test with additional parameters to ensure they appear before the database name.\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"SELECT 1\"]),\n+            ([\"psql\", \"-c\", \"SELECT 1\", \"dbname\"], None),\n+        )\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n             ([\"psql\", \"dbname\", \"--help\"], None),\n@@ -183,4 +188,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "",
  "django__django-16041": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex a34f3d3..221f3cf 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -171,6 +171,25 @@ class FormsFormsetTestCase(SimpleTestCase):\n         formset = DynamicFormSet(form_kwargs={\"custom_kwarg\": \"ignored\"})\n         for i, form in enumerate(formset):\n             self.assertTrue(hasattr(form, \"custom_kwarg\"))\n+\n+    def test_empty_permitted_ignored_empty_form_false(self):\n+        MyModelFormSet = modelformset_factory(MyModel, fields=[\"a_field\"])\n+        formset = MyModelFormSet(queryset=MyModel.objects.none(), form_kwargs={\"empty_permitted\": False})\n+        # The empty_form should have empty_permitted as True regardless of the form_kwargs\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n+\n+    def test_empty_permitted_ignored_empty_form_true(self):\n+        MyModelFormSet = modelformset_factory(MyModel, fields=[\"a_field\"])\n+        formset = MyModelFormSet(queryset=MyModel.objects.none(), form_kwargs={\"empty_permitted\": True})\n+        # The empty_form should have empty_permitted as True regardless of the form_kwargs\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n+\n+    def test_empty_permitted_in_regular_form(self):\n+        MyModelFormSet = modelformset_factory(MyModel, fields=[\"a_field\"])\n+        formset = MyModelFormSet(queryset=MyModel.objects.all(), form_kwargs={\"empty_permitted\": False})\n+        # For a regular form from the formset, empty_permitted from form_kwargs should apply\n+        for form in formset:\n+            self.assertIs(form.empty_permitted, False)\n             self.assertEqual(form.custom_kwarg, i)\n \n     def test_form_kwargs_empty_form(self):\n",
  "django__django-16046": "",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..b22045e 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,7 +1,10 @@\n+\n import datetime\n import re\n from unittest import mock\n \n+from django.urls import reverse\n+import urllib.parse\n from django.contrib.auth.forms import (\n     AdminPasswordChangeForm,\n     AuthenticationForm,\n@@ -884,6 +887,31 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # original hashed password contains $\n         self.assertIn(\"$\", form.cleaned_data[\"password\"])\n \n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field_with_uuid(self):\n+        user = User.objects.create(username=\"uuid_user\", password=\"foo\")\n+        \n+        # Mocking the uuid field for demonstration purposes\n+        user.uuid = \"22222222-3333-4444-5555-666677778888\"\n+        user.save()\n+\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search(r'<a href=\"(.*?)\">', password_help_text)\n+\n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.username,),\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n     def test_bug_19349_bound_password_field(self):\n         user = User.objects.get(username=\"testclient\")\n         form = UserChangeForm(data={}, instance=user)\n",
  "django__django-16255": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 1469efd..be85943 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -508,6 +508,30 @@ class HTTPSitemapTests(SitemapTestsBase):\n         self.assertXMLEqual(sitemap_response.content.decode(), expected_content_sitemap)\n \n \n+from django.test import TestCase\n+from django.contrib.sitemaps import Sitemap\n+from django.urls import path\n+from datetime import datetime\n+from .urls.http import CallableLastmodNoItemsSitemap  # Importing the sitemap class for testing\n+\n+class SitemapIssueTests(TestCase):\n+    def test_callable_lastmod_no_items(self):\n+        \"\"\"Test sitemap with no items and callable lastmod does not raise ValueError.\"\"\"\n+        response = self.client.get(\"/callable-lastmod-no-items/index.xml\")\n+        # Ensure that 'Last-Modified' header is not present in response\n+        self.assertNotIn(\"Last-Modified\", response)\n+        # Check if the XML content is as expected\n+        expected_content = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n+        <sitemap><loc>http://example.com/simple/sitemap-callable-lastmod.xml</loc></sitemap>\n+        </sitemapindex>\"\"\"\n+        self.assertXMLEqual(response.content.decode(), expected_content)\n+        \n+    def test_get_latest_lastmod_with_callable_no_items(self):\n+        \"\"\"Test get_latest_lastmod with callable and no items returns None.\"\"\"\n+        sitemap = CallableLastmodNoItemsSitemap()\n+        self.assertIsNone(sitemap.get_latest_lastmod())\n+\n # RemovedInDjango50Warning\n class DeprecatedTests(SitemapTestsBase):\n     @override_settings(\n",
  "django__django-16379": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 014d28a..8ff755b 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1,3 +1,4 @@\n+\n # Unit tests for cache framework\n # Uses whatever cache backend is set in the test settings file.\n import copy\n@@ -7,6 +8,8 @@ import pickle\n import re\n import shutil\n import sys\n+import unittest\n+from unittest import mock\n import tempfile\n import threading\n import time\n@@ -1755,7 +1758,30 @@ class FileBasedCacheTests(BaseCacheTests, TestCase):\n             with self.assertRaises(OSError):\n                 cache.get(\"foo\")\n \n-    def test_empty_cache_file_considered_expired(self):\n+    def test_has_key_race_handling(self):\n+        self.assertIs(cache.add(\"key\", \"value\"), True)\n+        with mock.patch(\"builtins.open\", side_effect=FileNotFoundError) as mocked_open:\n+            self.assertIs(cache.has_key(\"key\"), False)\n+            mocked_open.assert_called_once()\n+            \n+    def test_has_key_race_condition_expiring_file(self):\n+        # Simulate an expiring file situation\n+        self.assertIs(cache.add(\"key\", \"value\", timeout=1), True)  # Add a key with a very short timeout\n+        fname = cache._key_to_file(\"key\")\n+        with open(fname, \"wb\") as f:\n+            f.write(b\"dummy data\")  # Write data to the cache file\n+        with mock.patch(\"os.path.exists\", return_value=True):\n+            with mock.patch(\"builtins.open\", side_effect=lambda f, _: open(f, \"rb\")):\n+                with mock.patch.object(cache, \"_is_expired\", side_effect=lambda f: True) as mocked_is_expired:\n+                    self.assertIs(cache.has_key(\"key\"), False)\n+                    mocked_is_expired.assert_called_once()\n+                    \n+    def test_has_key_no_race(self):\n+        # Verify the function works normally without race condition\n+        self.assertIs(cache.add(\"key\", \"value\"), True)\n+        self.assertIs(cache.has_key(\"key\"), True)\n+        cache.delete(\"key\")\n+        self.assertIs(cache.has_key(\"key\"), False)\n         cache_file = cache._key_to_file(\"foo\")\n         with open(cache_file, \"wb\") as fh:\n             fh.write(b\"\")\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..7738def 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -8,7 +9,9 @@ from django.contrib.auth.models import User\n from django.test import RequestFactory, TestCase\n from django.urls import reverse\n \n+from django.contrib.auth import get_permission_codename\n from .admin import ArticleAdmin, site\n+from .tests import get_perm\n from .models import Article, Question\n from .tests import AdminViewBasicTestCase\n \n@@ -16,7 +19,43 @@ from .tests import AdminViewBasicTestCase\n class AdminTemplateTagsTest(AdminViewBasicTestCase):\n     request_factory = RequestFactory()\n \n-    def test_submit_row(self):\n+    def test_submit_row_save_as_new_add_permission_required(self):\n+        \"\"\"\n+        Test that the 'show_save_as_new' button is only displayed when the user has both\n+        'add' and 'change' permissions as per the issue described.\n+        \"\"\"\n+        # A user with change permission only should not see \"save as new\"\n+        change_user = User.objects.create_user(\n+            username=\"change_user\", password=\"secret\", is_staff=True\n+        )\n+        change_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = change_user\n+        admin = UserAdmin(User, site)\n+        admin.save_as = True\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], False)\n+\n+        # A user with both add and change permissions should see \"save as new\"\n+        add_user = User.objects.create_user(\n+            username=\"add_user\", password=\"secret\", is_staff=True\n+        )\n+        add_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"add\", User._meta)),\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = add_user\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], True)\n         \"\"\"\n         submit_row template tag should pass whole context.\n         \"\"\"\n",
  "django__django-16595": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 3979e76..a8fdd91 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -236,7 +236,22 @@ class OptimizerTests(SimpleTestCase):\n             ],\n         )\n \n-    def test_alter_alter_table_model(self):\n+    def test_alter_alter_field(self):\n+        \"\"\"\n+        Multiple AlterField operations on the same field should collapse into the last.\n+        This tests for the case described in the issue.\n+        \"\"\"\n+        self.assertOptimizesTo(\n+            [\n+                migrations.AlterField(\"book\", \"title\", models.CharField(max_length=256, null=True)),\n+                migrations.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True)),\n+                migrations.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True, help_text=\"help\")),\n+                migrations.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True, help_text=\"help\", default=None)),\n+            ],\n+            [\n+                migrations.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True, help_text=\"help\", default=None)),\n+            ],\n+        )\n         self._test_alter_alter_model(\n             migrations.AlterModelTable(\"Foo\", \"a\"),\n             migrations.AlterModelTable(\"Foo\", \"b\"),\n",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..d61d1b5 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,3 +1,4 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n@@ -55,8 +56,21 @@ class JoinTests(SimpleTestCase):\n         )\n         self.assertEqual(output, \"alpha & beta &amp; me\")\n \n-\n-class FunctionTests(SimpleTestCase):\n+class JoinAutoescapeOffTests(SimpleTestCase):\n+    @setup({\"join_autoescape_off01\": '{% autoescape off %}{{ some_list|join:some_var }}{% endautoescape %}'})\n+    def test_join_autoescape_off01(self):\n+        some_list = [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"]\n+        some_var = \"<br/>\"\n+        output = self.engine.render_to_string(\"join_autoescape_off01\", {\"some_list\": some_list, \"some_var\": some_var})\n+        self.assertEqual(output, \"<p>Hello World!</p><br/>beta & me<br/><script>Hi!</script>\")\n+\n+    # Additional test with different joining string\n+    @setup({\"join_autoescape_off02\": '{% autoescape off %}{{ some_list|join:some_var }}{% endautoescape %}'})\n+    def test_join_autoescape_off02(self):\n+        some_list = [\"Item 1\", \"Item 2\", \"Item 3\"]\n+        some_var = \" | \"\n+        output = self.engine.render_to_string(\"join_autoescape_off02\", {\"some_list\": some_list, \"some_var\": some_var})\n+        self.assertEqual(output, \"Item 1 | Item 2 | Item 3\")\n     def test_list(self):\n         self.assertEqual(join([0, 1, 2], \"glue\"), \"0glue1glue2\")\n \n@@ -78,4 +92,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..2d72a65 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -596,18 +596,120 @@ class BulkCreateTests(TestCase):\n                 {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n             ],\n         )\n+    \n+    @skipUnlessDBFeature(\n+    )\n+    def test_bulk_create_returning_ids_on_update_conflicts(self):\n+        # Set up initial data.\n+        Country.objects.bulk_create([\n+            Country(name=\"Germany\", iso_two_letter=\"DE\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\"),\n+        ])\n+        \n+        self.assertEqual(Country.objects.count(), 2)\n+\n+        # Prepare conflicting and new data.\n+        new_data = [\n+            Country(name=\"Germany\", iso_two_letter=\"DE\", description=\"Updated description\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\", description=\"Updated description\"),\n+            Country(name=\"Australia\", iso_two_letter=\"AU\"),\n+        ]\n+\n+        # Use bulk_create with update_conflicts\n+        results = Country.objects.bulk_create(\n+            new_data,\n+            update_conflicts=True,\n+            update_fields=[\"description\"],\n+            unique_fields=[\"name\", \"iso_two_letter\"]\n+        )\n+        \n+        # Verify count remains the same for the conflicting records\n+        self.assertEqual(Country.objects.count(), 3)\n+\n+        # Verify that all returned instances have their primary keys set\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_two_fields_unique_fields_first(self):\n         self._test_update_conflicts_two_fields([\"f1\"])\n+    \n+    @skipUnlessDBFeature(\n+    )\n+    def test_bulk_create_returning_ids_on_update_conflicts(self):\n+        # Set up initial data.\n+        Country.objects.bulk_create([\n+            Country(name=\"Germany\", iso_two_letter=\"DE\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\"),\n+        ])\n+        \n+        self.assertEqual(Country.objects.count(), 2)\n+\n+        # Prepare conflicting and new data.\n+        new_data = [\n+            Country(name=\"Germany\", iso_two_letter=\"DE\", description=\"Updated description\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\", description=\"Updated description\"),\n+            Country(name=\"Australia\", iso_two_letter=\"AU\"),\n+        ]\n+\n+        # Use bulk_create with update_conflicts\n+        results = Country.objects.bulk_create(\n+            new_data,\n+            update_conflicts=True,\n+            update_fields=[\"description\"],\n+            unique_fields=[\"name\", \"iso_two_letter\"]\n+        )\n+        \n+        # Verify count remains the same for the conflicting records\n+        self.assertEqual(Country.objects.count(), 3)\n+\n+        # Verify that all returned instances have their primary keys set\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_two_fields_unique_fields_second(self):\n         self._test_update_conflicts_two_fields([\"f2\"])\n+    \n+    @skipUnlessDBFeature(\n+    )\n+    def test_bulk_create_returning_ids_on_update_conflicts(self):\n+        # Set up initial data.\n+        Country.objects.bulk_create([\n+            Country(name=\"Germany\", iso_two_letter=\"DE\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\"),\n+        ])\n+        \n+        self.assertEqual(Country.objects.count(), 2)\n+\n+        # Prepare conflicting and new data.\n+        new_data = [\n+            Country(name=\"Germany\", iso_two_letter=\"DE\", description=\"Updated description\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\", description=\"Updated description\"),\n+            Country(name=\"Australia\", iso_two_letter=\"AU\"),\n+        ]\n+\n+        # Use bulk_create with update_conflicts\n+        results = Country.objects.bulk_create(\n+            new_data,\n+            update_conflicts=True,\n+            update_fields=[\"description\"],\n+            unique_fields=[\"name\", \"iso_two_letter\"]\n+        )\n+        \n+        # Verify count remains the same for the conflicting records\n+        self.assertEqual(Country.objects.count(), 3)\n+\n+        # Verify that all returned instances have their primary keys set\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -641,6 +743,40 @@ class BulkCreateTests(TestCase):\n                 {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n             ],\n         )\n+    \n+    @skipUnlessDBFeature(\n+    )\n+    def test_bulk_create_returning_ids_on_update_conflicts(self):\n+        # Set up initial data.\n+        Country.objects.bulk_create([\n+            Country(name=\"Germany\", iso_two_letter=\"DE\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\"),\n+        ])\n+        \n+        self.assertEqual(Country.objects.count(), 2)\n+\n+        # Prepare conflicting and new data.\n+        new_data = [\n+            Country(name=\"Germany\", iso_two_letter=\"DE\", description=\"Updated description\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\", description=\"Updated description\"),\n+            Country(name=\"Australia\", iso_two_letter=\"AU\"),\n+        ]\n+\n+        # Use bulk_create with update_conflicts\n+        results = Country.objects.bulk_create(\n+            new_data,\n+            update_conflicts=True,\n+            update_fields=[\"description\"],\n+            unique_fields=[\"name\", \"iso_two_letter\"]\n+        )\n+        \n+        # Verify count remains the same for the conflicting records\n+        self.assertEqual(Country.objects.count(), 3)\n+\n+        # Verify that all returned instances have their primary keys set\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -709,12 +845,80 @@ class BulkCreateTests(TestCase):\n                 },\n             ],\n         )\n+    \n+    @skipUnlessDBFeature(\n+    )\n+    def test_bulk_create_returning_ids_on_update_conflicts(self):\n+        # Set up initial data.\n+        Country.objects.bulk_create([\n+            Country(name=\"Germany\", iso_two_letter=\"DE\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\"),\n+        ])\n+        \n+        self.assertEqual(Country.objects.count(), 2)\n+\n+        # Prepare conflicting and new data.\n+        new_data = [\n+            Country(name=\"Germany\", iso_two_letter=\"DE\", description=\"Updated description\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\", description=\"Updated description\"),\n+            Country(name=\"Australia\", iso_two_letter=\"AU\"),\n+        ]\n+\n+        # Use bulk_create with update_conflicts\n+        results = Country.objects.bulk_create(\n+            new_data,\n+            update_conflicts=True,\n+            update_fields=[\"description\"],\n+            unique_fields=[\"name\", \"iso_two_letter\"]\n+        )\n+        \n+        # Verify count remains the same for the conflicting records\n+        self.assertEqual(Country.objects.count(), 3)\n+\n+        # Verify that all returned instances have their primary keys set\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_unique_two_fields_unique_fields_both(self):\n         self._test_update_conflicts_unique_two_fields([\"iso_two_letter\", \"name\"])\n+    \n+    @skipUnlessDBFeature(\n+    )\n+    def test_bulk_create_returning_ids_on_update_conflicts(self):\n+        # Set up initial data.\n+        Country.objects.bulk_create([\n+            Country(name=\"Germany\", iso_two_letter=\"DE\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\"),\n+        ])\n+        \n+        self.assertEqual(Country.objects.count(), 2)\n+\n+        # Prepare conflicting and new data.\n+        new_data = [\n+            Country(name=\"Germany\", iso_two_letter=\"DE\", description=\"Updated description\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\", description=\"Updated description\"),\n+            Country(name=\"Australia\", iso_two_letter=\"AU\"),\n+        ]\n+\n+        # Use bulk_create with update_conflicts\n+        results = Country.objects.bulk_create(\n+            new_data,\n+            update_conflicts=True,\n+            update_fields=[\"description\"],\n+            unique_fields=[\"name\", \"iso_two_letter\"]\n+        )\n+        \n+        # Verify count remains the same for the conflicting records\n+        self.assertEqual(Country.objects.count(), 3)\n+\n+        # Verify that all returned instances have their primary keys set\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -775,6 +979,40 @@ class BulkCreateTests(TestCase):\n                 {\"number\": 4, \"rank\": 4, \"name\": \"Mark\"},\n             ],\n         )\n+    \n+    @skipUnlessDBFeature(\n+    )\n+    def test_bulk_create_returning_ids_on_update_conflicts(self):\n+        # Set up initial data.\n+        Country.objects.bulk_create([\n+            Country(name=\"Germany\", iso_two_letter=\"DE\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\"),\n+        ])\n+        \n+        self.assertEqual(Country.objects.count(), 2)\n+\n+        # Prepare conflicting and new data.\n+        new_data = [\n+            Country(name=\"Germany\", iso_two_letter=\"DE\", description=\"Updated description\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\", description=\"Updated description\"),\n+            Country(name=\"Australia\", iso_two_letter=\"AU\"),\n+        ]\n+\n+        # Use bulk_create with update_conflicts\n+        results = Country.objects.bulk_create(\n+            new_data,\n+            update_conflicts=True,\n+            update_fields=[\"description\"],\n+            unique_fields=[\"name\", \"iso_two_letter\"]\n+        )\n+        \n+        # Verify count remains the same for the conflicting records\n+        self.assertEqual(Country.objects.count(), 3)\n+\n+        # Verify that all returned instances have their primary keys set\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -786,6 +1024,40 @@ class BulkCreateTests(TestCase):\n     @skipIfDBFeature(\"supports_update_conflicts_with_target\")\n     def test_update_conflicts_no_unique_fields(self):\n         self._test_update_conflicts([])\n+    \n+    @skipUnlessDBFeature(\n+    )\n+    def test_bulk_create_returning_ids_on_update_conflicts(self):\n+        # Set up initial data.\n+        Country.objects.bulk_create([\n+            Country(name=\"Germany\", iso_two_letter=\"DE\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\"),\n+        ])\n+        \n+        self.assertEqual(Country.objects.count(), 2)\n+\n+        # Prepare conflicting and new data.\n+        new_data = [\n+            Country(name=\"Germany\", iso_two_letter=\"DE\", description=\"Updated description\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\", description=\"Updated description\"),\n+            Country(name=\"Australia\", iso_two_letter=\"AU\"),\n+        ]\n+\n+        # Use bulk_create with update_conflicts\n+        results = Country.objects.bulk_create(\n+            new_data,\n+            update_conflicts=True,\n+            update_fields=[\"description\"],\n+            unique_fields=[\"name\", \"iso_two_letter\"]\n+        )\n+        \n+        # Verify count remains the same for the conflicting records\n+        self.assertEqual(Country.objects.count(), 3)\n+\n+        # Verify that all returned instances have their primary keys set\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -816,4 +1088,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "",
  "matplotlib__matplotlib-22711": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex 39c625e..1ac678d 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1119,6 +1119,24 @@ def test_range_slider(orientation):\n     slider.reset()\n     assert_allclose(slider.val, [0.1, 0.34])\n \n+@pytest.mark.parametrize(\"init_values, init_expected\", [\n+    ([0.0, 0.0], [0.0, 0.0]),\n+    ([0.2, 0.6], [0.2, 0.6]),\n+    ([0.1, 0.9], [0.1, 0.9])\n+])\n+def test_range_slider_initialization(init_values, init_expected):\n+    \"\"\"\n+    Test the RangeSlider widget to ensure that it initializes without error\n+    and that initial values are set correctly.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    slider = widgets.RangeSlider(ax=ax, label=\"\", valmin=0.0, valmax=1.0, valinit=init_values)\n+    \n+    # Check if slider initializes with the specified initial values\n+    assert_allclose(slider.val, init_expected)\n+\n+    plt.close(fig)\n+\n \n def check_polygon_selector(event_sequence, expected_result, selections_count,\n                            **kwargs):\n",
  "matplotlib__matplotlib-23299": "diff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 144880c..66f9aa1 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -489,8 +489,31 @@ def test_validate_fontstretch(stretch, parsed_stretch):\n     else:\n         assert validate_fontstretch(stretch) == parsed_stretch\n \n-\n-def test_keymaps():\n+import matplotlib.pyplot as plt\n+from matplotlib import rc_context, get_backend\n+from matplotlib._pylab_helpers import Gcf\n+\n+def test_no_backend_reset_rccontext():\n+    assert mpl.rcParams['backend'] != 'module://aardvark'\n+    with mpl.rc_context():\n+        mpl.rcParams['backend'] = 'module://aardvark'\n+    assert mpl.rcParams['backend'] == 'module://aardvark'\n+\n+def test_figures_not_cleared_with_rc_context():\n+    # Create a figure under an rc_context\n+    with rc_context():\n+        fig2 = plt.figure()\n+    \n+    # Check that the figure exists within Gcf.figs\n+    before = f'{id(Gcf.figs)} {Gcf.figs!r}'\n+    \n+    # Call get_backend() \n+    get_backend()\n+    \n+    # Verify that the figures within Gcf.figs have not been cleared\n+    after = f'{id(Gcf.figs)} {Gcf.figs!r}'\n+    \n+    assert before == after, f\"Figures were cleared unexpectedly after get_backend call:\\nBefore: {before}\\nAfter: {after}\"\n     key_list = [k for k in mpl.rcParams if 'keymap' in k]\n     for k in key_list:\n         assert isinstance(mpl.rcParams[k], list)\n",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..4944883 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -20,6 +20,15 @@ import numpy as np\n mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n+@check_figures_equal(extensions=[\"png\"])\n+def test_invisible_3d_axes(fig_test, fig_ref):\n+    ax = fig_test.add_subplot(111, projection='3d')\n+    ax.scatter([1], [1], [1])\n+    ax.set_visible(False)\n+\n+    ax_ref = fig_ref.add_subplot(111, projection='3d')\n+    ax_ref.scatter([1], [1], [1])\n+    ax_ref.set_alpha(0)  # Simulate invisibility for comparison\n \n def test_aspect_equal_error():\n     fig = plt.figure()\n",
  "matplotlib__matplotlib-23562": "",
  "matplotlib__matplotlib-23563": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex a51a857..cbebcee 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -1786,7 +1786,39 @@ def test_text_3d(fig_test, fig_ref):\n     assert t3d.get_position_3d() == (0.5, 0.5, 1)\n \n \n-@check_figures_equal(extensions=[\"png\"])\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from mpl_toolkits.mplot3d import Axes3D\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+def test_line3d_attribute_error():\n+    fig = plt.figure()\n+    ax = fig.add_subplot(projection='3d')\n+    \n+    # First plot with integer inputs directly\n+    x_s_0 = np.array([1, 2])\n+    y_s_0 = np.array([1, 2])\n+    z_s_0 = np.array([1, 2])\n+    \n+    x_e_0 = np.array([2, 3])\n+    y_e_0 = np.array([2, 3])\n+    z_e_0 = np.array([2, 3])\n+\n+    ax.plot(x_s_0, y_s_0, z_s_0, 'r-')\n+\n+    # Now change to integer input to numpy arrays and plot\n+    x_s_0 = np.array([4])\n+    y_s_0 = np.array([4])\n+    z_s_0 = np.array([4])\n+    \n+    x_e_0 = np.array([5])\n+    y_e_0 = np.array([5])\n+    z_e_0 = np.array([5])\n+\n+    # The error was happening here in actual usage cases\n+    ax.plot(x_s_0, y_s_0, z_s_0, 'r-')\n+\n+    plt.show()\n def test_pathpatch_3d(fig_test, fig_ref):\n     ax = fig_ref.add_subplot(projection=\"3d\")\n     path = Path.unit_rectangle()\n",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..3738429 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -774,7 +774,12 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n         assert mpl.colors.same_color(text.get_color(), color)\n \n \n-def test_get_set_draggable():\n+@pytest.mark.parametrize('draggable', (True, False))\n+def test_legend_draggable(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='shabnams')\n+    leg = ax.legend(draggable=draggable)\n+    assert leg.get_draggable() is draggable\n     legend = plt.legend()\n     assert not legend.get_draggable()\n     legend.set_draggable(True)\n",
  "matplotlib__matplotlib-23964": "diff --git a/lib/matplotlib/tests/test_backend_ps.py b/lib/matplotlib/tests/test_backend_ps.py\nindex a1caf1a..9fc4621 100644\n--- a/lib/matplotlib/tests/test_backend_ps.py\n+++ b/lib/matplotlib/tests/test_backend_ps.py\n@@ -255,6 +255,27 @@ def test_linedash():\n \n     assert buf.tell() > 0\n \n+import io\n+from matplotlib.figure import Figure\n+\n+def test_empty_line():\n+    # Smoke-test for gh#23954\n+    figure = Figure()\n+    figure.text(0.5, 0.5, \"\\nfoo\\n\\n\")\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n+\n+def test_multiline_text_labels():\n+    # Test multiline text with leading, trailing, and multiple consecutive empty lines\n+    figure = Figure()\n+    ax = figure.add_subplot(111)\n+    ax.annotate(text='\\n\\nLabel with leading empty lines\\n', xy=(0, 0))\n+    ax.annotate(text='Label with trailing empty lines\\n\\n', xy=(0.5, 0.5))\n+    ax.annotate(text='\\n\\nLabel with\\nmultiple\\n\\nempty lines\\n\\n', xy=(1, 1))\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n \n def test_no_duplicate_definition():\n \n",
  "matplotlib__matplotlib-23987": "",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "",
  "matplotlib__matplotlib-24970": "diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex 2be14fe..50b38c5 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -30,11 +30,24 @@ def test_create_lookup_table(N, result):\n     assert_array_almost_equal(mcolors._create_lookup_table(N, data), result)\n \n \n-def test_resampled():\n-    \"\"\"\n-    GitHub issue #6025 pointed to incorrect ListedColormap.resampled;\n-    here we test the method for LinearSegmentedColormap as well.\n-    \"\"\"\n+import pytest\n+import numpy as np\n+import matplotlib as mpl\n+from numpy.testing import assert_array_equal\n+\n+@pytest.mark.parametrize(\"dtype\", [np.uint8, int, np.float16, float])\n+def test_index_dtype_no_deprecation_warnings(dtype):\n+    # Create a color map object\n+    cm = mpl.colormaps[\"viridis\"]\n+\n+    # Use the colormap and assert no deprecation warnings are raised\n+    with pytest.warns(None) as record:\n+        cm(dtype(0))\n+        cm(np.array([0, 257, 256, 258], dtype=dtype))\n+\n+    # Ensure no DeprecationWarnings are recorded\n+    deprecation_warnings = [w for w in record if issubclass(w.category, DeprecationWarning)]\n+    assert not deprecation_warnings, \"Deprecation warnings were raised!\"\n     n = 101\n     colorlist = np.empty((n, 4), float)\n     colorlist[:, 0] = np.linspace(0, 1, n)\n",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..a11379e 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -90,7 +91,31 @@ def _generate_complete_test_figure(fig_ref):\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n \n+import pickletools\n+\n @mpl.style.context(\"default\")\n+\n+def test_pickle_draggable_legend():\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111)\n+\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40, 43, 45, 47, 48]\n+\n+    ax.plot(time, speed, label=\"speed\")\n+\n+    leg = ax.legend()\n+    leg.set_draggable(True)\n+\n+    # Attempt to pickle the figure and check if it succeeds.\n+    pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+    \n+    # Ensure no FigureCanvasAgg is present in the pickle stream\n+    assert \"FigureCanvasAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+    \n+    # Ensure that the loaded figure is correctly reconstructed\n+    loaded = pickle.loads(pkl)\n+    assert loaded is not None\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..87e0c85 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -89,8 +89,32 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n \n @mpl.style.context(\"default\")\n+def test_pickle_figure_with_aligned_labels():\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    fig.align_labels()  # This is where the bug occurs in the original issue\n+\n+    # Try to pickle the figure\n+    pkl = BytesIO()\n+    pickle.dump(fig, pkl, pickle.HIGHEST_PROTOCOL)\n+    loaded = pickle.loads(pkl.getvalue())\n+    loaded.canvas.draw()\n+\n+    plt.close(loaded)\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25442": "diff --git a/lib/matplotlib/tests/test_offsetbox.py b/lib/matplotlib/tests/test_offsetbox.py\nindex 204af9c..a336f13 100644\n--- a/lib/matplotlib/tests/test_offsetbox.py\n+++ b/lib/matplotlib/tests/test_offsetbox.py\n@@ -446,7 +446,39 @@ def test_paddedbox():\n     ab = AnchoredOffsetbox('upper right', child=pb)\n     ax.add_artist(ab)\n \n+def test_mplcursor_matplotlib_interaction():\n+    x = np.arange(1, 11)\n+    y1 = x\n+\n+    fig, ax = plt.subplots()\n+    ax.scatter(x, y1)\n+\n+    mpl.cursor(ax)\n+\n+    # Simulate a click event on the scatter plot\n+    click_event = MouseEvent('button_press_event', fig.canvas, x=5, y=5)\n+    fig.canvas.callbacks.process('button_press_event', click_event)\n+\n+    # Check if the canvas is still present, indicative of stability of code\n+    assert hasattr(fig, 'canvas')\n+\n     ta = TextArea(\"foobar\")\n     pb = PaddedBox(ta, pad=15, draw_frame=True)\n     ab = AnchoredOffsetbox('lower right', child=pb)\n-    ax.add_artist(ab)\n+    ax.add_artist(ab)\n+\n+def test_mplcursor_matplotlib_interaction():\n+    x = np.arange(1, 11)\n+    y1 = x\n+\n+    fig, ax = plt.subplots()\n+    ax.scatter(x, y1)\n+\n+    mpl.cursor(ax)\n+\n+    # Simulate a click event on the scatter plot\n+    click_event = MouseEvent('button_press_event', fig.canvas, x=5, y=5)\n+    fig.canvas.callbacks.process('button_press_event', click_event)\n+\n+    # Check if the canvas is still present, indicative of stability of code\n+    assert hasattr(fig, 'canvas')\n",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\nindex 9aa3203..3cedf9b 100644\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -1,4 +1,5 @@\n \n+\n import numpy as np\n import pandas as pd\n \n@@ -8,8 +9,33 @@ from numpy.testing import assert_array_equal, assert_array_almost_equal\n from seaborn._core.groupby import GroupBy\n from seaborn._stats.regression import PolyFit\n \n+from pandas.testing import assert_frame_equal\n \n class TestPolyFit:\n+    \n+    def test_missing_data_handling(self, df):\n+        # Inject missing data into the DataFrame\n+        df_with_nan = df.copy()\n+        df_with_nan.loc[0:5, 'x'] = np.nan\n+        \n+        # Instantiate GroupBy and PolyFit\n+        groupby = GroupBy([\"group\"])\n+        \n+        # Compute the result with and without dropping NaNs to see if results are handled properly\n+        result_with_nan = PolyFit()(df_with_nan[[\"x\", \"y\"]], groupby, \"x\", {})\n+        result_without_nan = PolyFit()(df_with_nan[[\"x\", \"y\"]].dropna(), groupby, \"x\", {})\n+        \n+        # Assert - results should be the same if NaNs are properly handled\n+        assert_frame_equal(result_with_nan, result_without_nan)\n+\n+    def test_no_missing_data(self, df):\n+        # Ensure PolyFit works without NaNs as a control test\n+        groupby = GroupBy([\"group\"])\n+        result = PolyFit()(df[[\"x\", \"y\"]], groupby, \"x\", {})\n+        \n+        # Check that result is a DataFrame and has no NaN values\n+        assert isinstance(result, pd.DataFrame)\n+        assert not result.isnull().values.any()\n \n     @pytest.fixture\n     def df(self, rng):\n",
  "mwaskom__seaborn-3190": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\nindex 72a27ec..580d0d7 100644\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -83,6 +83,24 @@ class TestContinuous:\n         s = Continuous(norm=(3, 7))._setup(x, IntervalProperty())\n         assert_array_equal(s(x), [-.5, 0, 1.5])\n \n+    def test_boolean_color_mapping(self):\n+        import pandas as pd\n+        import numpy as np\n+        import seaborn.objects as so\n+        import matplotlib.pyplot as plt\n+\n+        # Test case for boolean color mapping\n+        plot = so.Plot([\"a\", \"b\"], [1, 2], color=[True, False]).add(so.Bar())\n+\n+        try:\n+            plot.show()  # This should render without error\n+            success = True\n+        except TypeError as e:\n+            success = False\n+            print(\"TypeError encountered:\", e)\n+\n+        assert success, \"Plot with boolean color mapping failed\"\n+\n     def test_interval_with_range_norm_and_transform(self, x):\n \n         x = pd.Series([1, 10, 100])\n",
  "mwaskom__seaborn-3407": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\nindex b2e4a92..3ae1648 100644\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -1100,6 +1100,22 @@ class TestPairGrid:\n         list_pal = color_palette([\"blue\", \"red\", \"green\"])\n         g = ag.PairGrid(self.df, hue=\"a\", hue_order=list(\"cab\"),\n                         palette=dict_pal)\n+\n+    def test_pairplot_column_multiindex(self):\n+\n+        # Creating a MultiIndex dataframe similar to the one described in the issue\n+        arrays = [['A', 'A', 'B', 'B'], ['1', '2', '1', '2']]\n+        columns = pd.MultiIndex.from_tuples(list(zip(*arrays)))\n+        df = pd.DataFrame(np.random.randn(10, 4), columns=columns)\n+\n+        # Attempt to create a pairplot and check that it does not raise an error\n+        g = ag.pairplot(df)\n+        assert g is not None  # Basic check that the grid is created\n+\n+        # Test with the workaround: \"flatten\" the columns\n+        df.columns = [\"\".join(column) for column in df.columns]\n+        g = ag.pairplot(df)\n+        assert g is not None  # Ensure that the pairplot is successful after flattening\n         assert g.palette == list_pal\n \n     def test_hue_kws(self):\n",
  "pallets__flask-4992": "diff --git a/tests/test_config.py b/tests/test_config.py\nindex 179b09c..8c0f0d7 100644\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -1,8 +1,11 @@\n+\n import json\n import os\n import textwrap\n-\n import pytest\n+import tomllib\n+import tempfile\n+import json\n \n import flask\n \n",
  "psf__requests-1963": "",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..764a574 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1636,6 +1636,11 @@ def test_prepared_request_complete_copy():\n     assert_copy(p, p.copy())\n \n \n+import requests\n+from requests.adapters import HTTPAdapter\n+from requests.exceptions import DecodeError, Timeout\n+import pytest\n+\n def test_prepare_unicode_url():\n     p = PreparedRequest()\n     p.prepare(\n@@ -1655,7 +1660,18 @@ def test_urllib3_retries():\n     with pytest.raises(RetryError):\n         s.get(httpbin('status/500'))\n \n-def test_vendor_aliases():\n+def test_urllib3_exceptions_wrapped():\n+    s = requests.Session()\n+    adapter = HTTPAdapter()\n+    s.mount('http://', adapter)\n+\n+    # Simulate DecodeError\n+    with pytest.raises(DecodeError):\n+        raise requests.packages.urllib3.exceptions.DecodeError(\"Decode error occurred\")\n+\n+    # Simulate TimeoutError\n+    with pytest.raises(Timeout):\n+        raise requests.packages.urllib3.exceptions.TimeoutError(\"Timeout error occurred when proxying\")\n     from requests.packages import urllib3\n     from requests.packages import chardet\n \n@@ -1663,4 +1679,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 52d1693..189aa05 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -980,7 +980,35 @@ class TestRequests:\n         chunks = r.iter_content(decode_unicode=True)\n         assert all(isinstance(chunk, str) for chunk in chunks)\n \n-    def test_response_chunk_size_int(self):\n+    def test_iter_content_decode_unicode(self):\n+        \"\"\"\n+        Verify iter_content with decode_unicode=True against a known encoding behaves like r.text.\n+        \"\"\"\n+\n+        # Set up a response object\n+        r = requests.Response()\n+        r._content_consumed = True\n+        r._content = b'the content'\n+        r.encoding = 'ascii'\n+\n+        # Using iter_content with decode_unicode=True\n+        chunks = list(r.iter_content(16 * 1024, decode_unicode=True))\n+        combined_chunks = ''.join(chunks)\n+\n+        # Verify it matches r.text\n+        assert combined_chunks == r.text\n+\n+        # Also test with an explicit encoding set\n+        r = requests.Response()\n+        r._content_consumed = True\n+        r._content = b'some more content'\n+        r.encoding = 'utf-8'  # Explicitly setting an encoding\n+\n+        chunks = list(r.iter_content(1024, decode_unicode=True))\n+        combined_chunks = ''.join(chunks)\n+\n+        # Verify it matches r.text\n+        assert combined_chunks == r.text\n         \"\"\"Ensure that chunk_size is passed as an integer, otherwise\n         raise a TypeError.\n         \"\"\"\n",
  "psf__requests-863": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 0ee4333..5f16361 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -744,7 +744,44 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n             assert 'foo' in response.text\n             assert 'bar' in response.text\n \n-    def test_session_persistent_cookies(self):\n+    def test_allow_list_of_hooks_with_multiple_calls(self):\n+        \"\"\"Test registering multiple hooks using lists and ensuring they're called correctly.\"\"\"\n+        def add_foo_header(args):\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers'].update({\n+                'X-Foo': 'foo'\n+            })\n+            return args\n+\n+        def add_bar_header(args):\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers'].update({\n+                'X-Bar': 'bar'\n+            })\n+            return args\n+\n+        def check_hook_order(args):\n+            # This hook checks that the 'X-Foo' header is present, ensuring order of execution.\n+            assert 'X-Foo' in args['headers']\n+            return args\n+        \n+        hooks = [add_foo_header, add_bar_header, check_hook_order]\n+        r = requests.models.Request(hooks={'args': hooks})\n+        \n+        for hook in hooks:\n+            r.register_hook('args', hook)\n+\n+        assert_hooks_are_callable(r.hooks)\n+        \n+        # Simulate different scenarios where hooks should be applied.\n+        response_args = {}\n+        for hook in r.hooks['args']:\n+            response_args = hook(response_args)\n+\n+        assert 'X-Foo' in response_args['headers']\n+        assert 'X-Bar' in response_args['headers']\n \n         s = requests.session()\n \n",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..6c4a2a9 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -388,7 +388,7 @@ repr_da = xr.DataArray(\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over %r \" % dim\n+    expected += \", grouped over %r\" % dim\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj[dim])))\n     if dim == \"x\":\n         expected += \"1, 2, 3, 4, 5.\"\n@@ -405,7 +405,7 @@ def test_groupby_repr(obj, dim):\n def test_groupby_repr_datetime(obj):\n     actual = repr(obj.groupby(\"t.month\"))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over 'month' \"\n+    expected += \", grouped over 'month'\"\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj.t.dt.month)))\n     expected += \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.\"\n     assert actual == expected\n",
  "pylint-dev__pylint-5859": "diff --git a/tests/checkers/unittest_misc.py b/tests/checkers/unittest_misc.py\nindex 460d485..c1ea447 100644\n--- a/tests/checkers/unittest_misc.py\n+++ b/tests/checkers/unittest_misc.py\n@@ -89,7 +89,29 @@ class TestFixme(CheckerTestCase):\n         ):\n             self.checker.process_tokens(_tokenize_str(code))\n \n-    def test_issue_2321_should_not_trigger(self) -> None:\n+    @set_config(notes=[\"???\"])\n+    def test_punctuation_only_codetag(self) -> None:\n+        code = \"\"\"a = 1\n+                # ???\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n+\n+    @set_config(notes=[\"!!!\", \"%%%\", \"....\"])\n+    def test_multiple_punctuation_only_cotetags(self) -> None:\n+        code = \"\"\"a = 1\n+                # !!!\n+                # %%%\n+                # ....\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"!!!\", col_offset=17),\n+            MessageTest(msg_id=\"fixme\", line=3, args=\"%%%\", col_offset=17),\n+            MessageTest(msg_id=\"fixme\", line=4, args=\"....\", col_offset=17),\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n         code = 'print(\"# TODO this should not trigger a fixme\")'\n         with self.assertNoMessages():\n             self.checker.process_tokens(_tokenize_str(code))\n@@ -119,4 +141,4 @@ class TestFixme(CheckerTestCase):\n         # Todoist API: Fetch all Tasks\n         \"\"\"\n         with self.assertNoMessages():\n-            self.checker.process_tokens(_tokenize_str(code))\n+            self.checker.process_tokens(_tokenize_str(code))\n",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..39227db 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -79,6 +79,22 @@ def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n     assert \"E0015: Unrecognized option found: Q\" in output.out\n \n \n+def test_unrecognized_option_no_traceback(capsys: CaptureFixture) -> None:\n+    \"\"\"Check no traceback is printed for unrecognized option.\"\"\"\n+    with pytest.raises(SystemExit):\n+        Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"E0015: Unrecognized option found: Q\" in output.err\n+    assert \"Traceback\" not in output.err\n+\n+def test_unrecognized_long_option_no_traceback(capsys: CaptureFixture) -> None:\n+    \"\"\"Check no traceback is printed for unrecognized long option.\"\"\"\n+    with pytest.raises(SystemExit):\n+        Run([str(EMPTY_MODULE), \"--nonexistent-long-option\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"E0015: Unrecognized option found: nonexistent-long-option\" in output.err\n+    assert \"Traceback\" not in output.err\n+\n def test_unknown_confidence(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly error an unknown confidence value.\"\"\"\n     with pytest.raises(SystemExit):\n",
  "pylint-dev__pylint-7080": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex fa7078d..d405706 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1324,9 +1324,32 @@ class TestRunTC:\n                 if not os.path.basename(path) == \"regrtest_data\"\n             ]\n             with _test_cwd():\n-                os.chdir(join(HERE, \"regrtest_data\", \"directory\", \"subdirectory\"))\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n+                self._runtest(\n+                    [\n+                        \".\",\n+                        \"--recursive=y\",\n+                        \"--ignore-paths=^subdirectory/.*\",  # ignore subdirectory\n+                    ], \n+                    code=0,\n+                )\n+\n+    def test_ignore_path_recursive_explicit_path(self) -> None:\n+        \"\"\"Tests that ignoring paths works even with explicit path and recursion.\"\"\"\n+        with _test_sys_path():\n+            sys.path = [\n+                path\n+                for path in sys.path\n+                if not os.path.basename(path) == \"regrtest_data\"\n+            ]\n+            with _test_cwd():\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n                 self._runtest(\n-                    [\".\", \"--recursive=y\"],\n+                    [\n+                        \"subdirectory\",\n+                        \"--recursive=y\",\n+                        \"--ignore-paths=^subdirectory/.*\",\n+                    ],\n                     code=0,\n                 )\n \n",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..7bf97f0 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -935,10 +935,64 @@ print(submodule1)\n     assert not linter.stats.by_msg\n \n \n+def test_module_with_same_name(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test for the issue where linting fails if a module contains a module of the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        # This creates the directory structure: a/a.py and a/b.py\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        \n+        # Running pylint on the directory should succeed without errors regarding __init__.py.\n+        linter.check([\"a\"])\n+    \n+    # Check that the problematic error messages are not present\n+    assert \"parse-error\" not in linter.stats.by_msg\n+\n+    # Test the side-effect issue when another module imports from the problematic one\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        \n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"from a import b\\n\")\n+        \n+        linter.check([\"r\", \"a\"])\n+\n+    # Check that there are no import errors relating to the module resolution\n+    assert \"no-name-in-module\" not in linter.stats.by_msg\n+    assert \"parse-error\" not in linter.stats.by_msg\n+\n+\n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n     linter = initialized_linter\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n+\n+\n+def test_module_with_same_name(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test for the issue where linting fails if a module contains a module of the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        # This creates the directory structure: a/a.py and a/b.py\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        \n+        # Running pylint on the directory should succeed without errors regarding __init__.py.\n+        linter.check([\"a\"])\n+    \n+    # Check that the problematic error messages are not present\n+    assert \"parse-error\" not in linter.stats.by_msg\n+\n+    # Test the side-effect issue when another module imports from the problematic one\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        \n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"from a import b\\n\")\n+        \n+        linter.check([\"r\", \"a\"])\n+\n+    # Check that there are no import errors relating to the module resolution\n+    assert \"no-name-in-module\" not in linter.stats.by_msg\n+    assert \"parse-error\" not in linter.stats.by_msg\n",
  "pylint-dev__pylint-7993": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 6338072..854f38e 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n@@ -9,6 +10,7 @@ from __future__ import annotations\n import sys\n import warnings\n from contextlib import redirect_stdout\n+from _pytest.recwarn import WarningsRecorder\n from io import StringIO\n from json import dumps\n from typing import TYPE_CHECKING\n@@ -113,7 +115,23 @@ def test_template_option_non_existing(linter) -> None:\n     assert out_lines[2] == \"my_mod:2::()\"\n \n \n-def test_deprecation_set_output(recwarn):\n+def test_template_with_custom_message_braces(linter: PyLinter) -> None:\n+    \"\"\"Test using custom braces in message template.\"\"\"\n+    output = StringIO()\n+    linter.reporter.out = output\n+    linter.config.msg_template = '{{ \"Category\": \"{category}\" }}'\n+    linter.open()\n+    linter.set_current_module(\"my_custom_mod\")\n+\n+    linter.add_message(\"C0301\", line=1, args=(1, 2))\n+    linter.add_message(\"E0001\", line=2, end_lineno=2, end_col_offset=4, args=(3, 4))\n+\n+    out_lines = output.getvalue().split(\"\\n\")\n+    assert out_lines[1] == '{ \"Category\": \"convention\" }'\n+    assert out_lines[2] == '{ \"Category\": \"error\" }'\n+\n+\n+def test_deprecation_set_output(recwarn: WarningsRecorder):\n     \"\"\"TODO remove in 3.0.\"\"\"\n     reporter = BaseReporter()\n     # noinspection PyDeprecation\n",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "diff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\nindex 9989033..f53ccc6 100644\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -289,6 +289,10 @@ class TestImportPath:\n         return fn\n \n     def test_importmode_importlib(self, simple_module: Path, tmp_path: Path) -> None:\n+        \"\"\"`importlib` mode should not import modules multiple times.\"\"\"\n+        module1 = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n+        module2 = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n+        assert module1 is module2  # Ensure only one instance exists in sys.modules\n         \"\"\"`importlib` mode does not change sys.path.\"\"\"\n         module = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n         assert module.foo(2) == 42  # type: ignore[attr-defined]\n",
  "pytest-dev__pytest-5227": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 1ebe9d0..01f354c 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -15,7 +15,7 @@ from _pytest.compat import dummy_context_manager\n from _pytest.config import create_terminal_writer\n from _pytest.pathlib import Path\n \n-DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n+DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n \n \n",
  "pytest-dev__pytest-5495": "",
  "pytest-dev__pytest-5692": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3392814..9822730 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1,4 +1,7 @@\n+\n import os\n+from datetime import datetime\n+import platform\n from xml.dom import minidom\n \n import py\n@@ -157,6 +160,30 @@ class TestPython:\n         val = tnode[\"time\"]\n         assert round(float(val), 2) >= 0.03\n \n+    def test_hostname_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+        \"\"\"\n+        )\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        node.assert_attr(hostname=platform.node())\n+\n+    def test_timestamp_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+        \"\"\"\n+        )\n+        start_time = datetime.now()\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        timestamp = datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S.%f\")\n+        assert start_time <= timestamp < datetime.now()\n+\n     @pytest.mark.parametrize(\"duration_report\", [\"call\", \"total\"])\n     def test_junit_duration_report(self, testdir, monkeypatch, duration_report):\n \n",
  "pytest-dev__pytest-7168": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 38e0b6b..013cc22 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -143,6 +143,43 @@ def test_repr_on_newstyle():\n \n     assert saferepr(Function())\n \n+def test_broken_getattribute():\n+    \"\"\"saferepr() can create proper representations of classes with\n+    broken __getattribute__ (#7145)\n+    \"\"\"\n+\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError\n+\n+        def __repr__(self):\n+            raise RuntimeError\n+\n+    assert saferepr(SomeClass()).startswith(\n+        \"<[RuntimeError() raised in repr()] SomeClass object at 0x\"\n+    )\n+\n+def test_exception_in_repr():\n+    \"\"\"Test if saferepr correctly handles exceptions in __repr__ method.\"\"\"\n+\n+    class FaultyRepr:\n+        def __repr__(self):\n+            raise ValueError(\"Intentional error in __repr__\")\n+\n+    assert saferepr(FaultyRepr()).startswith(\n+        \"<[ValueError('Intentional error in __repr__') raised in repr()] FaultyRepr object at 0x\"\n+    )\n+\n+def test_safeformat_with_exception():\n+    \"\"\"Test if safeformat can handle a __repr__ method that raises an exception.\"\"\"\n+\n+    class FaultyRepr:\n+        def __repr__(self):\n+            raise ValueError(\"Intentional error in __repr__\")\n+\n+    formatted = safeformat(FaultyRepr())\n+    assert \"Intentional error in __repr__\" in formatted\n+\n \n def test_unicode():\n     val = \"\u00a3\u20ac\"\n@@ -153,4 +190,4 @@ def test_unicode():\n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n-    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n",
  "pytest-dev__pytest-7220": "diff --git a/testing/test_pytester.py b/testing/test_pytester.py\nindex 5ab5242..b7cbb9e 100644\n--- a/testing/test_pytester.py\n+++ b/testing/test_pytester.py\n@@ -70,6 +70,29 @@ def test_make_hook_recorder(testdir) -> None:\n     recorder.hook.pytest_runtest_logreport(report=rep3)\n     pytest.raises(ValueError, recorder.getfailures)\n \n+def test_failure_with_changed_cwd(testdir):\n+    \"\"\"Test that failure lines use correct paths if CWD has changed.\"\"\"\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import os\n+        import pytest\n+\n+        @pytest.fixture\n+        def private_dir():\n+            out_dir = 'ddd'\n+            os.mkdir(out_dir)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+\n+        def test_show_wrong_path(private_dir):\n+            assert False\n+        \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([str(p) + \":*: AssertionError\", \"*1 failed in *\"])\n+\n \n def test_parseconfig(testdir) -> None:\n     config1 = testdir.parseconfig()\n",
  "pytest-dev__pytest-7373": "diff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 309636c..6b718c6 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -708,7 +708,63 @@ class TestFunctional:\n \n \n class TestKeywordSelection:\n-    def test_select_simple(self, testdir):\n+    def test_reevaluate_dynamic_expr(self, testdir):\n+        \"\"\"#7360 - Verify caching issue with skipif condition evaluation\"\"\"\n+        py_file1 = testdir.makepyfile(\n+            test_reevaluate_dynamic_expr1=\"\"\"\n+            import pytest\n+\n+            skip = True\n+\n+            @pytest.mark.skipif(\"skip\")\n+            def test_should_skip():\n+                assert False\n+        \"\"\"\n+        )\n+        py_file2 = testdir.makepyfile(\n+            test_reevaluate_dynamic_expr2=\"\"\"\n+            import pytest\n+\n+            skip = False\n+\n+            @pytest.mark.skipif(\"skip\")\n+            def test_should_not_skip():\n+                assert False\n+        \"\"\"\n+        )\n+        file_name1 = py_file1.basename\n+        file_name2 = py_file2.basename\n+        reprec = testdir.inline_run(file_name1, file_name2)\n+        reprec.assertoutcome(skipped=1, failed=1)\n+\n+    def test_caching_behavior_with_different_globals(self, testdir):\n+        \"\"\"Ensure skipif condition is evaluated with correct globals context.\"\"\"\n+        py_file1 = testdir.makepyfile(\n+            test_diff_globals_context1=\"\"\"\n+            import pytest\n+\n+            condition = True\n+\n+            @pytest.mark.skipif(\"condition\")\n+            def test_should_skip_with_true_cond():\n+                assert False\n+        \"\"\"\n+        )\n+        py_file2 = testdir.makepyfile(\n+            test_diff_globals_context2=\"\"\"\n+            import pytest\n+\n+            condition = False\n+\n+            @pytest.mark.skipif(\"condition\")\n+            def test_should_not_skip_with_false_cond():\n+                assert False\n+        \"\"\"\n+        )\n+        file_name1 = py_file1.basename\n+        file_name2 = py_file2.basename\n+        reprec = testdir.inline_run(file_name1, file_name2)\n+        reprec.assertoutcome(skipped=1, failed=1)\n         file_test = testdir.makepyfile(\n             \"\"\"\n             def test_one():\n",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..5a6a042 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -219,7 +219,40 @@ class TestXFail:\n         assert str(callreport.longrepr) == \"[XPASS(strict)] nope\"\n         assert not hasattr(callreport, \"wasxfail\")\n \n-    def test_xfail_run_anyway(self, testdir):\n+    @pytest.mark.parametrize(\n+        \"test_input,expected_substr\",\n+        [\n+            ([\"-rs\"], \"SKIPPED [1] test_sample.py:2: unconditional skip\"),\n+            ([\"-rs\", \"--runxfail\"], \"SKIPPED [1] test_sample.py:2: unconditional skip\"),\n+        ],\n+    )\n+    def test_skip_location_report(self, testdir, test_input, expected_substr):\n+        testdir.makepyfile(\n+            test_sample=\"\"\"\n+            import pytest\n+\n+            @pytest.mark.skip\n+            def test_sample():\n+                assert False\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(*test_input)\n+        result.stdout.fnmatch_lines([f\"*{expected_substr}*\"])\n+\n+    def test_skipif_conditional_skip_report(self, testdir):\n+        testdir.makepyfile(\n+            test_sample=\"\"\"\n+            import pytest\n+\n+            @pytest.mark.skipif(True, reason=\"conditional skip\")\n+            def test_sample():\n+                assert False\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(\"-rs\")\n+        result.stdout.fnmatch_lines([\"SKIPPED [1] test_sample.py:3: conditional skip\"])\n+        result = testdir.runpytest(\"-rs\", \"--runxfail\")\n+        result.stdout.fnmatch_lines([\"SKIPPED [1] test_sample.py:3: conditional skip\"])\n         testdir.makepyfile(\n             \"\"\"\n             import pytest\n",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..6af7432 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,3 +1,4 @@\n+\n import sys\n \n import pytest\n@@ -153,7 +154,34 @@ class TestEvaluation:\n         assert skipped.reason == \"condition: config._hackxyz\"\n \n \n+from _pytest.pytester import Testdir\n+\n class TestXFail:\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # Verify the dynamic xfail marks a failing test as xfailed.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed(self, testdir: Testdir) -> None:\n+        # Verify the dynamic xfail marks a passing test as xpassed.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+                assert 1\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p, \"-rX\")\n+        result.stdout.fnmatch_lines([\"*XPASS*test_this*\", \"*1 xpassed*\"])\n     @pytest.mark.parametrize(\"strict\", [True, False])\n     def test_xfail_simple(self, testdir, strict):\n         item = testdir.getitem(\n",
  "pytest-dev__pytest-8365": "",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..5701b0a 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -574,6 +574,33 @@ def test_class_weights_cv():\n     assert_array_equal(reg.predict([[-.2, 2]]), np.array([-1]))\n \n \n+def test_ridge_classifier_cv_store_cv_values():\n+    # Test RidgeClassifierCV with store_cv_values=True\n+    rng = np.random.RandomState(42)\n+    \n+    # Simple dataset\n+    X = np.array([[-1.0, -1.0], [-1.0, 0], [-.8, -1.0], [1.0, 1.0], [1.0, 0.0]])\n+    y = np.array([1, 1, 1, -1, -1])\n+    \n+    n_samples = X.shape[0]\n+    alphas = [1e-1, 1e0, 1e1]\n+    n_alphas = len(alphas)\n+\n+    # Initialize RidgeClassifierCV with store_cv_values=True\n+    clf = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+    clf.fit(X, y)\n+    \n+    # Test the cv_values_ attribute\n+    assert clf.cv_values_.shape == (n_samples, n_alphas)\n+\n+    # Also testing with multiple outputs\n+    y_multi = rng.randint(low=0, high=2, size=(n_samples, 3)) * 2 - 1  # Random -1/1\n+    clf_multi = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+    clf_multi.fit(X, y_multi)\n+    \n+    assert clf_multi.cv_values_.shape == (n_samples, y_multi.shape[1], n_alphas)\n+\n+\n def test_ridgecv_store_cv_values():\n     # Test _RidgeCV's store_cv_values attribute.\n     rng = rng = np.random.RandomState(42)\n",
  "scikit-learn__scikit-learn-11281": "diff --git a/sklearn/mixture/tests/test_bayesian_mixture.py b/sklearn/mixture/tests/test_bayesian_mixture.py\nindex a9d82b7..259f23f 100644\n--- a/sklearn/mixture/tests/test_bayesian_mixture.py\n+++ b/sklearn/mixture/tests/test_bayesian_mixture.py\n@@ -14,7 +14,9 @@ from sklearn.mixture.bayesian_mixture import _log_wishart_norm\n from sklearn.mixture import BayesianGaussianMixture\n \n from sklearn.mixture.tests.test_gaussian_mixture import RandomData\n-from sklearn.exceptions import ConvergenceWarning\n+from sklearn.exceptions import ConvergenceWarning, NotFittedError\n+from sklearn.utils.testing import assert_array_equal, assert_greater\n+from sklearn.mixture import BayesianGaussianMixture\n from sklearn.utils.testing import assert_greater_equal, ignore_warnings\n \n \n",
  "scikit-learn__scikit-learn-12471": "",
  "scikit-learn__scikit-learn-13142": "",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..a3d1dea 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,3 +1,4 @@\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n@@ -70,8 +71,20 @@ def test_kernel_pca_consistent_transform():\n     transformed2 = kpca.transform(X_copy)\n     assert_array_almost_equal(transformed1, transformed2)\n \n+from sklearn.utils.testing import assert_allclose\n+\n+def test_kernel_pca_sign_flips():\n+    rng = np.random.RandomState(42)\n+    X = rng.rand(10, 5)\n+\n+    kpca = KernelPCA(n_components=7, kernel='rbf', random_state=42, copy_X=False)\n+    transformed_X1 = kpca.fit_transform(X)\n+    transformed_X2 = kpca.fit_transform(X)\n+\n+    # We check if the transformations are consistent up to a sign flip\n+    assert_allclose(np.abs(transformed_X1), np.abs(transformed_X2))\n \n-def test_kernel_pca_sparse():\n+    # since sign flip can occur in each component, this will verify that the issue is fixed\n     rng = np.random.RandomState(0)\n     X_fit = sp.csr_matrix(rng.random_sample((5, 4)))\n     X_pred = sp.csr_matrix(rng.random_sample((2, 4)))\n",
  "scikit-learn__scikit-learn-13439": "diff --git a/sklearn/tests/test_pipeline.py b/sklearn/tests/test_pipeline.py\nindex 318940e..b35bae7 100644\n--- a/sklearn/tests/test_pipeline.py\n+++ b/sklearn/tests/test_pipeline.py\n@@ -1058,7 +1058,26 @@ def test_pipeline_memory():\n         shutil.rmtree(cachedir)\n \n \n-def test_make_pipeline_memory():\n+def test_len_of_pipeline():\n+    from sklearn.feature_selection import SelectKBest\n+    from sklearn.feature_selection import f_regression\n+    from sklearn.svm import SVC\n+    from sklearn.pipeline import Pipeline\n+\n+    anova_filter = SelectKBest(f_regression, k=5)\n+    clf = SVC(kernel='linear')\n+    pipe = Pipeline([('anova', anova_filter), ('svc', clf)])\n+    \n+    # Verify that the length of the pipeline is equal to the number of steps\n+    assert len(pipe) == 2\n+\n+    # Test with no steps in the pipeline\n+    empty_pipe = Pipeline([])\n+    assert len(empty_pipe) == 0\n+\n+    # Verify length with more steps\n+    extra_step_pipe = Pipeline([('anova', anova_filter), ('svc', clf), ('another_svc', SVC())])\n+    assert len(extra_step_pipe) == 3\n     cachedir = mkdtemp()\n     if LooseVersion(joblib_version) < LooseVersion('0.12'):\n         # Deal with change of API in joblib\n@@ -1070,4 +1089,4 @@ def test_make_pipeline_memory():\n     pipeline = make_pipeline(DummyTransf(), SVC())\n     assert pipeline.memory is None\n \n-    shutil.rmtree(cachedir)\n+    shutil.rmtree(cachedir)\n",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..95dce1b 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -7,6 +8,8 @@ Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n # License: BSD 3 clause\n \n import pytest\n+from sklearn.ensemble import IsolationForest\n+from sklearn.utils import check_random_state\n \n import numpy as np\n \n@@ -297,6 +300,28 @@ def test_score_samples():\n \n @pytest.mark.filterwarnings('ignore:default contamination')\n @pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n+def test_iforest_warm_start_false():\n+    \"\"\"Test IsolationForest doesn't reuse estimators when warm_start is False\"\"\"\n+\n+    rng = check_random_state(42)\n+    X = rng.randn(30, 2)\n+\n+    # fit first 10 trees\n+    clf = IsolationForest(n_estimators=10, max_samples=20,\n+                          random_state=rng, warm_start=False)\n+    clf.fit(X)\n+    # remember the first set of trees\n+    trees_before = clf.estimators_.copy()\n+    \n+    # fit another 10 trees, should create new estimators\n+    clf.set_params(n_estimators=20)\n+    clf.fit(X)\n+    # expecting 20 new fitted trees, with none reused\n+    trees_after = clf.estimators_\n+    \n+    # No objects should be the same because warm_start is False\n+    assert all(t1 is not t2 for t1, t2 in zip(trees_before, trees_after[:len(trees_before)]))\n+@pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n def test_deprecation():\n     X = [[0.0], [1.0]]\n     clf = IsolationForest()\n",
  "scikit-learn__scikit-learn-13497": "",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..ffa862d 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,3 +1,4 @@\n+\n import re\n from pprint import PrettyPrinter\n \n@@ -8,6 +9,8 @@ from sklearn.pipeline import make_pipeline\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.feature_selection import SelectKBest, chi2\n from sklearn import set_config\n+from sklearn.linear_model import LogisticRegressionCV\n+import numpy as np\n \n \n # Ignore flake8 (lots of line too long issues)\n@@ -214,8 +217,17 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n \n     set_config(print_changed_only=False)\n \n-\n-def test_pipeline():\n+def test_vector_param_in_repr():\n+    # Ensure that array parameters don't throw errors (See issue description)\n+    set_config(print_changed_only=True)\n+    estimator = LogisticRegressionCV(Cs=np.array([0.1, 1]))\n+    try:\n+        repr(estimator)  # Should not raise an error\n+    except ValueError as e:\n+        assert False, f\"Unexpected ValueError raised: {e}\"\n+    finally:\n+        # Reset to default\n+        set_config(print_changed_only=False)\n     # Render a pipeline object\n     pipeline = make_pipeline(StandardScaler(), LogisticRegression(C=999))\n     expected = \"\"\"\n",
  "scikit-learn__scikit-learn-13779": "",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..855b560 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -679,6 +679,31 @@ def test_unicode_kernel():\n                                 kernel='linear',\n                                 random_seed=0)\n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for issue where sparse fit results in empty support vectors\n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    assert not model.support_vectors_.data.size\n+    assert not model.dual_coef_.data.size\n+\n+def test_sparse_fit_no_support_vectors_but_no_error():\n+    # Ensuring no error is raised when there are no support vectors\n+    X_train = sparse.csr_matrix([[0, 0, 0, 0],\n+                                 [0, 0, 0, 0],\n+                                 [0, 0, 0, 0],\n+                                 [0, 0, 0, 0]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear')\n+    # Fit should not raise an error even if it leads to zero support vectors\n+    model.fit(X_train, y_train)\n+    assert model.support_.size == 0\n+    assert model.dual_coef_.shape[1] == 0\n+\n \n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n",
  "scikit-learn__scikit-learn-14983": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex dd52c66..700a41c 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -972,7 +972,34 @@ def test_leave_one_p_group_out_error_on_fewer_number_of_groups():\n                          LeavePGroupsOut(n_groups=3).split(X, y, groups))\n \n \n-@ignore_warnings\n+from sklearn.model_selection import RepeatedKFold, RepeatedStratifiedKFold\n+import pytest\n+\n+@pytest.mark.parametrize(\n+    \"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold]\n+)\n+def test_repeated_cv_repr(RepeatedCV):\n+    n_splits, n_repeats = 2, 6\n+    repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats)\n+    repeated_cv_repr = ('{}(n_repeats=6, n_splits=2, random_state=None)'\n+                        .format(repeated_cv.__class__.__name__))\n+    assert repeated_cv_repr == repr(repeated_cv)\n+\n+# Test with different parameters to ensure robustness of __repr__\n+@pytest.mark.parametrize(\n+    \"RepeatedCV, n_splits, n_repeats, random_state\",\n+    [\n+        (RepeatedKFold, 3, 5, 42),\n+        (RepeatedStratifiedKFold, 7, 8, 0),\n+        (RepeatedKFold, 10, 1, None),\n+        (RepeatedStratifiedKFold, 4, 3, 1234)\n+    ]\n+)\n+def test_repeated_cv_repr_varied_parameters(RepeatedCV, n_splits, n_repeats, random_state):\n+    repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats, random_state=random_state)\n+    repeated_cv_repr = ('{}(n_repeats={}, n_splits={}, random_state={})'\n+                        .format(repeated_cv.__class__.__name__, n_repeats, n_splits, random_state))\n+    assert repeated_cv_repr == repr(repeated_cv)\n def test_repeated_cv_value_errors():\n     # n_repeats is not integer or <= 0\n     for cv in (RepeatedKFold, RepeatedStratifiedKFold):\n",
  "scikit-learn__scikit-learn-15512": "",
  "scikit-learn__scikit-learn-15535": "diff --git a/sklearn/metrics/cluster/tests/test_common.py b/sklearn/metrics/cluster/tests/test_common.py\nindex 9991cff..9c8e822 100644\n--- a/sklearn/metrics/cluster/tests/test_common.py\n+++ b/sklearn/metrics/cluster/tests/test_common.py\n@@ -162,6 +162,8 @@ def test_format_invariance(metric_name):\n         yield y, 'array of ints'\n         yield y.tolist(), 'list of ints'\n         yield [str(x) for x in y.tolist()], 'list of strs'\n+        yield [str(x) + \"-a\" for x in y.tolist()], 'list of modified strs'\n+        yield (np.array([str(x) + \"-a\" for x in y.tolist()], dtype=object), 'array of modified strs (object)')\n         yield y - 1, 'including negative ints'\n         yield y + 1, 'strictly positive ints'\n \n",
  "scikit-learn__scikit-learn-25500": "diff --git a/sklearn/tests/test_isotonic.py b/sklearn/tests/test_isotonic.py\nindex 5021282..701e7b7 100644\n--- a/sklearn/tests/test_isotonic.py\n+++ b/sklearn/tests/test_isotonic.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n import numpy as np\n import pickle\n@@ -5,7 +6,10 @@ import copy\n \n import pytest\n \n-from sklearn.datasets import make_regression\n+from sklearn.datasets import make_regression, make_classification\n+from sklearn.calibration import CalibratedClassifierCV\n+from sklearn.linear_model import SGDClassifier\n+from sklearn import set_config\n from sklearn.isotonic import (\n     check_increasing,\n     isotonic_regression,\n",
  "scikit-learn__scikit-learn-25570": "",
  "sphinx-doc__sphinx-10325": "diff --git a/tests/test_ext_autodoc_automodule.py b/tests/test_ext_autodoc_automodule.py\nindex 787cd0c..b084640 100644\n--- a/tests/test_ext_autodoc_automodule.py\n+++ b/tests/test_ext_autodoc_automodule.py\n@@ -112,6 +112,9 @@ def test_automodule_special_members(app):\n         '',\n     ]\n \n+import pytest\n+import sys\n+from .test_ext_autodoc import do_autodoc\n \n @pytest.mark.sphinx('html', testroot='ext-autodoc',\n                     confoverrides={'autodoc_mock_imports': ['missing_module',\n@@ -120,9 +123,243 @@ def test_automodule_special_members(app):\n                                                             'missing_package3',\n                                                             'sphinx.missing_module4']})\n @pytest.mark.usefixtures(\"rollback_sysmodules\")\n+def test_automodule_inherited_members_with_exclusions(app):\n+    sys.modules.pop('target', None)  # unload target module to clear the module cache\n+\n+    # Testing the exclusion of specific inherited classes\n+    options = {'members': None, 'inherited-members': 'Base, list'}\n+    actual = do_autodoc(app, 'module', 'target.inheritance', options)\n+    assert '.. py:class:: MyList' in actual\n+    assert '.. py:method:: MyList.meth' in actual\n+    assert '.. py:method:: Base.inheritedclassmeth' in actual\n+    assert '.. py:method:: Base.inheritedmeth' in actual\n+    assert '.. py:method:: Base.inheritedstaticmeth' in actual\n+    assert '.. py:method:: Derived.inheritedmeth' in actual\n+@pytest.mark.usefixtures(\"rollback_sysmodules\")\n def test_subclass_of_mocked_object(app):\n     sys.modules.pop('target', None)  # unload target module to clear the module cache\n \n     options = {'members': None}\n     actual = do_autodoc(app, 'module', 'target.need_mocks', options)\n-    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n",
  "sphinx-doc__sphinx-7975": "",
  "sphinx-doc__sphinx-8435": "diff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex 21b6a7e..d9cdbed 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -737,7 +737,52 @@ def test_autodoc_type_aliases(app):\n     ]\n \n \n-@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+@pytest.mark.skipif(sys.version_info < (3, 7), reason='python 3.7+ is required.')\n+@pytest.mark.sphinx('text', testroot='ext-autodoc')\n+def test_autodoc_type_aliases_for_vars_and_attrs(app):\n+    # Define a simple module that uses type aliases in variables and class attributes\n+    module_content = '''\n+from __future__ import annotations\n+\n+#: module-level variable with a type alias\n+var: MyType\n+\n+class ExampleClass:\n+    \"\"\"Example class.\"\"\"\n+\n+    #: class attribute with a type alias\n+    attr: MyType\n+'''\n+    \n+    config = {'autodoc_type_aliases': {'MyType': 'int'}}\n+    \n+    options = {\"members\": None, \"undoc-members\": None}\n+    \n+    # Create a temporary module for the testing (assuming `do_autodoc` can work with strings or handle test environment appropriately)\n+    with app.rootdir.joinpath('target/generated_example.py').open('w') as f:\n+        f.write(module_content)\n+    \n+    actual = do_autodoc(app, 'module', 'target.generated_example', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.generated_example',\n+        '',\n+        '',\n+        '.. py:data:: var',\n+        '   :module: target.generated_example',\n+        '   :type: int',  # Expecting the type alias 'MyType' to be resolved to 'int'\n+        '',\n+        '',\n+        '.. py:class:: ExampleClass',\n+        '   :module: target.generated_example',\n+        '',\n+        '   Example class.',\n+        '',\n+        '   .. py:attribute:: ExampleClass.attr',\n+        '      :module: target.generated_example',\n+        '      :type: int',  # Expecting the type alias 'MyType' to be resolved to 'int'\n+        '',\n+    ]\n def test_autodoc_default_options(app):\n     # no settings\n     actual = do_autodoc(app, 'class', 'target.enums.EnumCls')\n",
  "sphinx-doc__sphinx-8506": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 08bd595..6e8de5d 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -78,7 +78,50 @@ def test_get_full_qualified_name():\n     domain = StandardDomain(env)\n \n     # normal references\n-    node = nodes.reference()\n+from sphinx import nodes\n+from sphinx.testing.util import assert_node\n+from sphinx.domains.std import StandardDomain\n+from sphinx.testing.restructuredtext import parse as rst_parse\n+\n+def test_cmd_option_with_optional_value(app):\n+    text = \".. option:: -j[=N]\"\n+    doctree = rst_parse(app, text)\n+    assert_node(doctree, (\n+        [nodes.desc, ([nodes.desc_signature, ([nodes.desc_name, '-j'],\n+                                              [nodes.desc_addname, '[=N]'])],\n+                      [nodes.desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('-j', '-j', 'cmdoption', 'index', 'cmdoption-j', 1) in objects\n+\n+def test_cmd_option_starting_with_bracket(app):\n+    text = \".. option:: [enable=]PATTERN\"\n+    doctree = rst_parse(app, text)\n+    assert_node(doctree, (\n+        [nodes.desc, ([nodes.desc_signature, ([nodes.desc_name, '[enable'],\n+                                              [nodes.desc_addname, '=]PATTERN'])],\n+                      [nodes.desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('[enable', '[enable', 'cmdoption', 'index', 'cmdoption-arg-enable', 1) in objects\n+\n+def test_cmd_option_brackets(app):\n+    text = \".. option:: --option[=value]\"\n+    doctree = rst_parse(app, text)\n+    assert_node(doctree, (\n+        [nodes.desc, ([nodes.desc_signature, ([nodes.desc_name, '--option'],\n+                                              [nodes.desc_addname, '[=value]'])],\n+                      [nodes.desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('--option', '--option', 'cmdoption', 'index', 'cmdoption-option', 1) in objects\n+\n+def test_cmd_option_variations(app):\n+    text = \".. option:: option[=opt] /opt\"\n+    doctree = rst_parse(app, text)\n+    assert_node(doctree, (\n+        [nodes.desc, ([nodes.desc_signature, ([nodes.desc_name, 'option'],\n+                                              [nodes.desc_addname, '[=opt] /opt'])],\n+                      [nodes.desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('option', 'option', 'cmdoption', 'index', 'cmdoption-option', 1) in objects\n     assert domain.get_full_qualified_name(node) is None\n \n     # simple reference to options\n",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..ed1e8f0 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -22,9 +22,9 @@ from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_op\n from sphinx.testing.util import SphinxTestApp, Struct  # NOQA\n from sphinx.util.docutils import LoggingReporter\n \n+from .test_ext_autodoc import do_autodoc\n try:\n     # Enable pyximport to test cython module\n-    import pyximport\n     pyximport.install()\n except ImportError:\n     pyximport = None\n",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..c1514b9 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -10,6 +11,7 @@\n \n import sys\n from numbers import Integral\n+from struct import Struct\n from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tuple, TypeVar,\n                     Union)\n \n@@ -44,6 +46,8 @@ def test_restify():\n     assert restify(None) == \":obj:`None`\"\n     assert restify(Integral) == \":class:`numbers.Integral`\"\n     assert restify(Any) == \":obj:`Any`\"\n+    # Test case for struct.Struct type annotation resolution\n+    assert restify(Struct) == \":class:`struct.Struct`\"\n \n \n def test_restify_type_hints_containers():\n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..b4b85e1 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1457,8 +1457,31 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n :type param1: :class:`MyClass <name.space.MyClass>` instance\n \"\"\"\n         self.assertEqual(expected, actual)\n+    \n+    def test_other_parameters_section(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n \n-    def test_multiple_parameters(self):\n+\"\"\"\n+        \n+        # Test with napoleon_use_param set to False\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param2** (:class:`MyClass <name.space.MyClass>` instance)\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        # Test with napoleon_use_param set to True\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param param2:\n+:type param2: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n         docstring = \"\"\"\\\n Parameters\n ----------\n",
  "sphinx-doc__sphinx-8721": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\nindex d4fba47..c32693d 100644\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -61,7 +61,18 @@ def test_linkcode(app, status, warning):\n     assert 'http://foobar/cpp/' in stuff\n \n \n-@pytest.mark.sphinx(testroot='ext-viewcode-find')\n+import pytest\n+\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode')\n+def test_viewcode_epub_default(app, status, warning):\n+    app.builder.build_all()\n+    assert not (app.outdir / '_modules/spam/mod1.xhtml').exists()\n+\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode',\n+                    confoverrides={'viewcode_enable_epub': True})\n+def test_viewcode_epub_enabled(app, status, warning):\n+    app.builder.build_all()\n+    assert (app.outdir / '_modules/spam/mod1.xhtml').exists()\n def test_local_source_files(app, status, warning):\n     def find_source(app, modname):\n         if modname == 'not_a_package':\n",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..33e0201 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -336,6 +336,19 @@ def test_args():\n         Permutation(((0, ), [1]))\n     assert Permutation([[1, 2]]) == Permutation([0, 2, 1])\n     assert Permutation([[1], [4, 2]]) == Permutation([0, 1, 4, 3, 2])\n+\n+    # New test cases for non-disjoint cycles as per the issue statement\n+    # Identity permutation from non-disjoint cycles\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n+    # Applying cycles in left-to-right order\n+    assert Permutation([[0, 1], [1, 2]]) == Permutation([1, 2, 0])\n+    assert Permutation([[2, 3], [1, 3]]) == Permutation([0, 3, 2, 1])\n+    # Singleton cycles in between\n+    assert Permutation([[0, 1], [1], [2, 3]]) == Permutation([1, 0, 3, 2])\n+    # Larger non-disjoint cycles\n+    assert Permutation([[0, 1, 2], [1, 2, 3]]) == Permutation([2, 3, 0, 1])\n+    # Mix of disjoint and non-disjoint cycles\n+    assert Permutation([[0, 1], [2, 3], [0, 2]]) == Permutation([2, 1, 0, 3])\n     assert Permutation([[1], [4, 2]], size=1) == Permutation([0, 1, 4, 3, 2])\n     assert Permutation(\n         [[1], [4, 2]], size=6) == Permutation([0, 1, 4, 3, 2, 5])\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..46ef8d0 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -1,3 +1,4 @@\n+\n from sympy import Abs, S, Symbol, I, Rational, PurePoly\n from sympy.matrices import Matrix, SparseMatrix, eye, zeros, ShapeError\n from sympy.utilities.pytest import raises\n@@ -107,7 +108,34 @@ def test_sparse_matrix():\n     A = SparseMatrix([[2, 1, 3], [4, 2, 4], [6, 12, 1]])\n     assert (A**3)[:] == [290, 262, 251, 448, 440, 368, 702, 954, 433]\n \n-    # test_creation\n+    # Additional tests for matrix stacking involving zero-dimension matrices\n+\n+    # Test hstack with matrices having zero rows\n+    sparse_matrices = [SparseMatrix.zeros(0, n) for n in range(4)]\n+    assert SparseMatrix.hstack(*sparse_matrices).shape == (0, 6)\n+\n+    # Test hstack with matrices having zero columns\n+    sparse_matrices = [SparseMatrix.zeros(n, 0) for n in range(4)]\n+    assert SparseMatrix.vstack(*sparse_matrices).shape == (6, 0)\n+\n+    # Test hstack with a matrix having non-zero rows and zero columns\n+    matrices = [\n+        SparseMatrix.zeros(1, 0),\n+        SparseMatrix.zeros(1, 1),\n+        SparseMatrix.zeros(1, 2),\n+        SparseMatrix.zeros(1, 3)\n+    ]\n+    # Expected shape is (1, 6) after hstack\n+    assert SparseMatrix.hstack(*matrices).shape == (1, 6)\n+\n+    # Test vstack with a matrix having zero rows and non-zero columns\n+    matrices_v = [\n+        SparseMatrix.zeros(0, 0),\n+        SparseMatrix.zeros(2, 0),\n+        SparseMatrix.zeros(4, 0)\n+    ]\n+    # Expected shape is (6, 0) after vstack\n+    assert SparseMatrix.vstack(*matrices_v).shape == (6, 0)\n     x = Symbol(\"x\")\n     a = SparseMatrix([[x, 0], [0, 0]])\n     m = a\n",
  "sympy__sympy-13471": "diff --git a/sympy/utilities/tests/test_pickling.py b/sympy/utilities/tests/test_pickling.py\nindex 52dcc20..b151002 100644\n--- a/sympy/utilities/tests/test_pickling.py\n+++ b/sympy/utilities/tests/test_pickling.py\n@@ -114,6 +114,20 @@ def test_core_relational():\n               StrictLessThan(x, y), Unequality, Unequality(x, y)):\n         check(c)\n \n+import sys\n+import pickle\n+import sympy\n+\n+def test_python2_to_python3_float_pickle():\n+    # Simulate pickling in Python 2.7 and unpickling in Python 3.6\n+    # '1L' used in Python 2 long gets changed to '1' in Python 3 int\n+    x = sympy.symbols(\"x\")\n+    data = (2, '1L', 1, 15)  # hypothetical pickle data resembling Python 2 pickle\n+    serialized_data = pickle.dumps(data, 2)\n+    \n+    if sys.version_info.major == 3:\n+        deserialized_data = pickle.loads(serialized_data)\n+        assert deserialized_data == (2, '1', 1, 15)\n \n def test_core_add():\n     x = Symbol(\"x\")\n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..22057ab 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -261,6 +261,23 @@ def test_coth():\n     assert coth(-5*pi*I/6) == -sqrt(3)*I\n \n     assert coth(pi*I/105) == -cot(pi/105)*I\n+\n+def test_issue_fix_coth_log_tan():\n+    from sympy import Symbol, coth, log, tan, I, pi\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+    # Testing for specific integral values that previously raised an error\n+    assert e.subs(x, 2).evalf() # Converts to a numerical expression for evaluation\n+    assert e.subs(x, 3).evalf()\n+    assert e.subs(x, 5).evalf()\n+    assert e.subs(x, 6).evalf()\n+    assert e.subs(x, 8).evalf()\n+    assert e.subs(x, 9).evalf()\n+    assert e.subs(x, 11).evalf()\n+    assert e.subs(x, 12).evalf()\n+    assert e.subs(x, 13).evalf()\n+    assert e.subs(x, 15).evalf()\n+    assert e.subs(x, 18).evalf()\n     assert coth(-pi*I/105) == cot(pi/105)*I\n \n     assert coth(2 + 3*I) == coth(2 + 3*I)\n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..cc04533 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -201,7 +201,20 @@ def test_col_insert():\n         l.insert(i, 4)\n         assert flatten(zeros_Shaping(3).col_insert(i, c4).row(0).tolist()) == l\n \n-def test_extract():\n+def test_col_insert_issue_13643():\n+    from sympy import Matrix, eye, ones\n+    M = eye(6)\n+    V = 2 * ones(6, 2)\n+    expected = Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    result = M.col_insert(3, V)\n+    assert result == expected\n     m = ShapingOnlyMatrix(4, 3, lambda i, j: i*3 + j)\n     assert m.extract([0, 1, 3], [0, 1]) == Matrix(3, 2, [0, 1, 3, 4, 9, 10])\n     assert m.extract([0, 3], [0, 0, 2]) == Matrix(2, 3, [0, 0, 2, 9, 9, 11])\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..825f07e 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -615,6 +615,16 @@ def test_latex_Range():\n \n     assert latex(Range(-2, -oo, -1)) == r'\\left\\{-2, -3, \\ldots, -\\infty\\right\\}'\n \n+    \n+def test_latex_sequences_new():\n+    # Test case to check if the SeqFormula does not escape brackets\n+    n = symbols('n', integer=True)\n+    s = SeqFormula(n**2, (n, 0, oo))\n+    \n+    # Expected correct latex output without backslash-escaped brackets\n+    expected_output = r'[0, 1, 4, 9, \\ldots]'\n+    \n+    assert latex(s).replace(r'\\left', '').replace(r'\\right', '') == expected_output\n \n def test_latex_sequences():\n     s1 = SeqFormula(a**2, (0, oo))\n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..655dd27 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +7,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n@@ -186,9 +187,34 @@ def test_Domain_preprocess():\n     assert Domain.preprocess('ZZ[x,y]') == ZZ[x, y]\n     assert Domain.preprocess('QQ[x,y]') == QQ[x, y]\n \n-    raises(OptionError, lambda: Domain.preprocess('Z()'))\n+    # Test new domain cases\n+    assert Domain.preprocess('RR[x]') == RR[x]\n+    assert Domain.preprocess('CC[x]') == CC[x]\n+    assert Domain.preprocess('R[x,y]') == RR[x, y]\n+    assert Domain.preprocess('C[x,y]') == CC[x, y]\n+    assert Domain.preprocess('RR[x,y]') == RR[x, y]\n+    assert Domain.preprocess('CC[x,y]') == CC[x, y]\n+\n+    # Assert OptionError raised for invalid domain\n+    raises(OptionError, lambda: Domain.preprocess('RR(y,z)'))\n+    raises(OptionError, lambda: Domain.preprocess('C()'))\n \n     assert Domain.preprocess('Z(x)') == ZZ.frac_field(x)\n+\n+    # Test Poly creation with specified domain\n+    from sympy import symbols\n+    x, y, z = symbols('x y z')\n+    from sympy.polys.polytools import Poly\n+\n+    # Check that creating Poly with this domain doesn't raise an error\n+    p = Poly(1.2 * x * y * z, x, domain='RR[y,z]')\n+    assert isinstance(p, Poly)\n+    assert p.domain == RR[y, z]\n+\n+    # Repeat with complex domain\n+    p = Poly(1.2 * x * y * z, x, domain='CC[y,z]')\n+    assert isinstance(p, Poly)\n+    assert p.domain == CC[y, z]\n     assert Domain.preprocess('Q(x)') == QQ.frac_field(x)\n \n     assert Domain.preprocess('ZZ(x)') == ZZ.frac_field(x)\n",
  "sympy__sympy-14774": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 48a5cf2..4ff491e 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Add, Abs, Chi, Ci, CosineTransform, Dict, Ei, Eq, FallingFactorial,\n     FiniteSet, Float, FourierTransform, Function, IndexedBase, Integral,\n@@ -298,6 +299,22 @@ def test_latex_functions():\n         r\"\\sin {x^{2}}\"\n \n     assert latex(asin(x)**2) == r\"\\operatorname{asin}^{2}{\\left (x \\right )}\"\n+\n+    # Testing acsc function\n+    assert latex(acsc(x), inv_trig_style=\"full\") == \\\n+        r\"\\operatorname{arccsc}{\\left (x \\right )}\"\n+    assert latex(acsc(x)**2, inv_trig_style=\"full\") == \\\n+        r\"\\operatorname{arccsc}^{2}{\\left (x \\right )}\"\n+    assert latex(acsc(x), inv_trig_style=\"power\") == \\\n+        r\"\\csc^{-1}{\\left (x \\right )}\"\n+    \n+    # Testing asec function\n+    assert latex(Symbol('asec')(x), inv_trig_style=\"full\") == \\\n+        r\"\\operatorname{arcsec}{\\left (x \\right )}\"\n+    assert latex(Symbol('asec')(x)**2, inv_trig_style=\"full\") == \\\n+        r\"\\operatorname{arcsec}^{2}{\\left (x \\right )}\"\n+    assert latex(Symbol('asec')(x), inv_trig_style=\"power\") == \\\n+        r\"\\sec^{-1}{\\left (x \\right )}\"\n     assert latex(asin(x)**2, inv_trig_style=\"full\") == \\\n         r\"\\arcsin^{2}{\\left (x \\right )}\"\n     assert latex(asin(x)**2, inv_trig_style=\"power\") == \\\n",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..99e1b93 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6111,6 +6111,33 @@ u(\"\"\"\\\n     assert upretty((1/y)*e.j) == ucode_str\n \n \n+from sympy import MatrixSymbol, pretty, symbols\n+\n+def test_MatrixSymbol_add_pretty_printing_issue():\n+    n = symbols('n')\n+\n+    # Test from original patch\n+    x = MatrixSymbol('x', n, n)\n+    y_star = MatrixSymbol('y*', n, n)\n+    \n+    assert pretty(x + y_star) == \"x + y*\"\n+\n+    # Additional test cases\n+    x2 = MatrixSymbol('x2', n, n)\n+    y_prime = MatrixSymbol('y\\'', n, n)\n+    assert pretty(x + y_prime) == \"x + y'\"\n+    \n+    z = MatrixSymbol('z', n, n)\n+    assert pretty(x2 + z) == \"x2 + z\"\n+    \n+    # Negative terms\n+    a = symbols('a')\n+    assert pretty(-a*x2 + 2*y_prime*y_star) == \"-a*x2 + 2*y'*y*\"\n+\n+    # Complex expressions\n+    expr = x2 + y_star - z\n+    assert pretty(expr) == \"x2 + y* - z\"\n+\n def test_MatrixSymbol_printing():\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..59cf4a1 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -721,6 +721,29 @@ def test_dummification():\n     assert lam(3, 9) == 2\n     lam = lambdify(sin(t), 2 * sin(t)**2)\n     assert lam(F(t)) == 2 * F(t)**2\n+\n+def test_curly_matrix_symbol():\n+    # Issue #15009\n+    curlyv = sympy.MatrixSymbol(\"{v}\", 2, 1)\n+    \n+    # Test without dummify=True\n+    try:\n+        lam = lambdify(curlyv, curlyv)\n+        assert lam([[1], [1]]) == [[1], [1]], \"Lambda without dummify should work with curly braces in MatrixSymbol name.\"\n+    except SyntaxError:\n+        assert False, \"Lambdify should not throw SyntaxError for curly braces without dummify.\"\n+        \n+    # Test with dummify=True\n+    try:\n+        lam = lambdify(curlyv, curlyv, dummify=True)\n+        assert lam([[1], [1]]) == [[1], [1]], \"Lambda with dummify=True should work with curly braces in MatrixSymbol name.\"\n+    except SyntaxError:\n+        assert False, \"Lambdify should not throw SyntaxError for curly braces with dummify=True.\"\n+\n+    # Additional tests for other non-standard characters in MatrixSymbol with dummify=True\n+    specialCharMatrix = sympy.MatrixSymbol(\"v$\", 2, 1)\n+    lam = lambdify(specialCharMatrix, specialCharMatrix, dummify=True)\n+    assert lam([[1], [1]]) == [[1], [1]], \"Lambda with dummify=True should work with special characters in MatrixSymbol name.\"\n     #Test that \\alpha was properly dummified\n     lam = lambdify((alpha, t), 2*alpha + t)\n     assert lam(2, 1) == 5\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..b85d0d7 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n@@ -18,6 +19,14 @@ def test_Integer():\n def test_Rational():\n     assert mcode(Rational(3, 7)) == \"3/7\"\n     assert mcode(Rational(18, 9)) == \"2\"\n+    assert mcode(Max(x, 2)) == \"Max[x, 2]\"\n+    assert mcode(Max(2, x)) == \"Max[2, x]\"\n+    assert mcode(Max(x, y, 2)) == \"Max[x, y, 2]\"\n+    assert mcode(Max(2, y, x)) == \"Max[2, y, x]\"\n+    assert mcode(Min(x, 2)) == \"Min[x, 2]\"\n+    assert mcode(Min(2, x)) == \"Min[2, x]\"\n+    assert mcode(Min(x, y, 2)) == \"Min[x, y, 2]\"\n+    assert mcode(Min(2, y, x)) == \"Min[2, y, x]\"\n     assert mcode(Rational(3, -7)) == \"-3/7\"\n     assert mcode(Rational(-3, -7)) == \"3/7\"\n     assert mcode(x + Rational(3, 7)) == \"x + 3/7\"\n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..201da13 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1727,6 +1727,12 @@ def test_latex_UnevaluatedExpr():\n \n \n def test_MatrixElement_printing():\n+    # Test for issue 'Indexed matrix-expression LaTeX printer is not compilable'\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    # Test if LaTeX output of indexed matrix multiplication is correct\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n     # test cases for issue #11821\n     A = MatrixSymbol(\"A\", 1, 3)\n     B = MatrixSymbol(\"B\", 1, 3)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..a3b0f7a 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,3 +1,4 @@\n+\n from sympy import Symbol, sqrt, Derivative, S\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n@@ -20,9 +21,22 @@ def test_idiff():\n     assert True in [sol.diff(x, 3).equals(explicit) for sol in solve(circ, y)]\n     assert idiff(x + t + y, [y, t], x) == -Derivative(t, x) - 1\n \n+from sympy import Function, exp, Eq\n \n-def test_intersection():\n-    assert intersection(Point(0, 0)) == []\n+def test_idiff_issue_cases():\n+    x = Symbol('x', real=True)\n+    y = Symbol('y', real=True)\n+    f = Function('f')\n+    g = Function('g')\n+    \n+    # Test case for Eq not previously supported\n+    assert idiff(Eq(y*exp(y), x*exp(x)), y, x) == (x + 1)*exp(x - y)/(y + 1)\n+    \n+    # Test cases to verify functionality with functions like f(x)\n+    assert idiff(f(x)*exp(f(x)) - x*exp(x), f(x), x) == (x + 1) * exp(x - f(x))/(f(x) + 1)\n+    assert idiff(f(x) - y * exp(x), [f(x), y], x) == (y + Derivative(y, x)) * exp(x)\n+    assert idiff(f(x) - y * exp(x), [y, f(x)], x) == -y + exp(-x) * Derivative(f(x), x)\n+    assert idiff(f(x) - g(x), [f(x), g(x)], x) == Derivative(g(x), x)\n     raises(TypeError, lambda: intersection(Point(0, 0), 3))\n     assert intersection(\n             Segment((0, 0), (2, 0)),\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_codegen.py b/sympy/utilities/tests/test_codegen.py\nindex 6bc2605..2dda9f2 100644\n--- a/sympy/utilities/tests/test_codegen.py\n+++ b/sympy/utilities/tests/test_codegen.py\n@@ -581,8 +581,37 @@ def test_ccode_cse():\n         '}\\n'\n     )\n     assert source == expected\n+from sympy.utilities.autowrap import autowrap\n+from sympy import MatrixSymbol\n+import numpy as np\n+\n+def test_ccode_unused_array_arg():\n+    x = MatrixSymbol('x', 2, 1)\n+    # x does not appear in output\n+    name_expr = (\"test\", 1.0)\n+    generator = CCodeGen()\n+    result = codegen(name_expr, code_gen=generator, header=False, empty=False, argument_sequence=(x,))\n+    source = result[0][1]\n+    # note: x should appear as (double *)\n+    expected = (\n+        '#include \"test.h\"\\n'\n+        '#include <math.h>\\n'\n+        'double test(double *x) {\\n'\n+        '   double test_result;\\n'\n+        '   test_result = 1.0;\\n'\n+        '   return test_result;\\n'\n+        '}\\n'\n+    )\n+    assert source == expected\n+\n+def test_autowrap_cython_unused_array_arg():\n+    x = MatrixSymbol('x', 2, 1)\n+    # Expression that does not depend on x\n+    expr = 1.0\n+    f = autowrap(expr, args=(x,), backend='cython')\n \n-def test_empty_f_code():\n+    result = f(np.array([[1.0], [2.0]]))\n+    assert result == 1.0\n     code_gen = FCodeGen()\n     source = get_string(code_gen.dump_f95, [])\n     assert source == \"\"\n",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..3c8af44 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -342,8 +342,22 @@ def test_intersection():\n     # issue 12178\n     assert Intersection() == S.UniversalSet\n \n-\n-def test_issue_9623():\n+from sympy import Piecewise, Eq\n+from sympy.sets import Intersection, FiniteSet, EmptySet\n+from sympy.abc import x\n+\n+def test_intersection_duplicates_issue():\n+    # Test case based on the issue\n+    assert Intersection({1}, {1}, {x}) == Intersection({1}, {x})\n+    \n+    # Additional test cases to ensure duplicates are removed and correct behavior\n+    assert Intersection({1}, {1}, {x}) == Piecewise(({1}, Eq(x, 1)), (EmptySet(), True))\n+    \n+    # Cases with more duplicates and varied expressions\n+    assert Intersection({1, 1, 2}, {1}, {x}) == Piecewise(({1}, Eq(x, 1)), (EmptySet(), True))\n+    assert Intersection({1, 2, 2}, {2}, {x}) == Piecewise(({2}, Eq(x, 2)), (EmptySet(), True))\n+    assert Intersection({1, 2}, {2, 2}, {x}, {2}) == Piecewise(({2}, Eq(x, 2)), (EmptySet(), True))\n+    assert Intersection({x, x, 2}, {x}) == Intersection({x, 2}, {x})\n     n = Symbol('n')\n \n     a = S.Reals\n",
  "sympy__sympy-17022": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex bd254ca..6a3faf7 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -388,6 +388,30 @@ def test_numpy_matrix():\n     raises(Exception, lambda: lambdify(x, x_dot_mtx, printer=p3)(inp))\n \n \n+def test_issue_identity_matrix_lambdify():\n+    if not numpy:\n+        skip(\"NumPy not installed\")\n+\n+    from sympy.matrices import MatrixSymbol, Identity\n+    from sympy import symbols\n+    A = MatrixSymbol(\"A\", 2, 2)\n+    a = numpy.array([[1, 2], [3, 4]])\n+    expected_result = numpy.array([[2, 2], [3, 5]])\n+    \n+    # Test a fixed size identity matrix\n+    f_fixed = lambdify(A, A + Identity(2), modules='numpy')\n+    numpy.testing.assert_array_equal(f_fixed(a), expected_result)\n+\n+    # Test with a symbol for size\n+    n = symbols('n', integer=True)\n+    A_dynamic = MatrixSymbol(\"A\", n, n)\n+    f_dynamic = lambdify(A_dynamic, A_dynamic + Identity(n), modules='numpy')\n+    numpy.testing.assert_array_equal(f_dynamic(a), expected_result)\n+\n+    # Test for raising an error when using non-fixed 'n'\n+    N_dynamic = MatrixSymbol(\"M\", n, n)\n+    raises(NotImplementedError, lambda: lambdify(N_dynamic, N_dynamic + Identity(n), modules='numpy'))\n+\n def test_numpy_transpose():\n     if not numpy:\n         skip(\"numpy not installed.\")\n",
  "sympy__sympy-17139": "",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..84e4c0c 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy import I, Rational, Symbol, pi, sqrt, S\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n@@ -91,6 +92,16 @@ def test_point():\n     assert (-p3).__rsub__(p4) == p3.midpoint(p4).scale(2, 2)\n \n     assert p4 * 5 == Point(5, 5)\n+    # Test for symmetric multiplication with a number\n+    from sympy import sympify\n+    assert sympify(2.0) * p4 == Point(2, 2), \"Multiplication commutativity failed\"\n+    assert p4 * sympify(2.0) == Point(2, 2), \"Multiplication commutativity failed\"\n+    # Based on the issue description\n+    point1 = Point(0, 0)\n+    point2 = Point(1, 1)\n+    result = point1 + sympify(2.0) * point2\n+    expected = Point(2.0, 2.0)\n+    assert result == expected, \"Issue-related test failed\"\n     assert p4 / 5 == Point(0.2, 0.2)\n \n     raises(ValueError, lambda: Point(0, 0) + 10)\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..66edbf2 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1894,6 +1894,64 @@ def test_normal():\n     assert e.normal() == e\n \n \n+from sympy import Symbol, sympify, symbols, tan\n+from sympy.core.expr import ExprBuilder\n+from sympy.core.mul import Mul\n+from sympy.testing.pytest import raises\n+\n+# Test case based on original test patch\n+def test_non_string_equality():\n+    # Expressions should not compare equal to strings\n+    x = symbols('x')\n+    one = sympify(1)\n+    assert (x == 'x') is False\n+    assert (x != 'x') is True\n+    assert (one == '1') is False\n+    assert (one != '1') is True\n+    assert (x + 1 == 'x + 1') is False\n+    assert (x + 1 != 'x + 1') is True\n+\n+    # Make sure == doesn't try to convert the resulting expression to a string\n+    # (e.g., by calling sympify() instead of _sympify())\n+\n+    class BadRepr(object):\n+        def __repr__(self):\n+            raise RuntimeError\n+\n+    assert (x == BadRepr()) is False\n+    assert (x != BadRepr()) is True\n+    \n+    v = ['d', 'e', 'fg']\n+    assert v != ['d', 'e', 'fg']\n+    assert v == [Symbol('d'), Symbol('e'), Symbol('fg')]\n+\n+\n+def test_eq_with_non_evaluable_repr():\n+    # Test comparing Symbol with an object having non-evaluable repr\n+    x = symbols('x')\n+    \n+    class NonEvaluableRepr(object):\n+        def __repr__(self):\n+            # return a string that looks like code, but can't/shouldn't be evaluated\n+            return 'some.non.evaluable.code'\n+    \n+    obj = NonEvaluableRepr()\n+    assert x == obj  # should be False because obj can't become a Symbol\n+    assert not (x != obj)  # should be True because they are not equal\n+\n+def test_eq_with_similar_repr():\n+    # Test comparing SymPy Symbol with an object having a repr that\n+    # seems like a valid symbol name.\n+    x = symbols('x')\n+    \n+    class SimilarRepr(object):\n+        def __repr__(self):\n+            return 'x'\n+    \n+    obj = SimilarRepr()\n+    assert x == obj  # should be False because x should not equal obj\n+    assert not (x != obj)  # should be True because they should not be considered equal\n+\n def test_expr():\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n@@ -1902,4 +1960,4 @@ def test_expr():\n def test_ExprBuilder():\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..89efe84 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -553,8 +553,23 @@ def test_diophantine():\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n     assert diophantine((y**2-x), t) == set([(t**2, -t)])\n \n-\n-def test_general_pythagorean():\n+def test_issue_18186():\n+    from sympy.solvers.diophantine import diophantine\n+    from sympy import symbols\n+\n+    x, y = symbols('x y', integer=True)\n+    \n+    eq = x**4 + y**4 - 2**4 - 3**4\n+    \n+    # Check that changing the order of symbols does not affect the result\n+    sol1 = diophantine(eq, syms=(x, y), permute=True)\n+    sol2 = diophantine(eq, syms=(y, x), permute=True)\n+    \n+    expected = set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), \n+                    (2, -3), (2, 3), (3, -2), (3, 2)])\n+    \n+    assert sol1 == expected, f\"Unexpected solutions for syms=(x, y): {sol1}\"\n+    assert sol2 == expected, f\"Unexpected solutions for syms=(y, x): {sol2}\"\n     from sympy.abc import a, b, c, d, e\n \n     assert check_solutions(a**2 + b**2 + c**2 - d**2)\n",
  "sympy__sympy-18532": "diff --git a/sympy/codegen/tests/test_cnodes.py b/sympy/codegen/tests/test_cnodes.py\nindex c30dccd..a2e0d62 100644\n--- a/sympy/codegen/tests/test_cnodes.py\n+++ b/sympy/codegen/tests/test_cnodes.py\n@@ -1,6 +1,7 @@\n+\n from sympy.core.symbol import symbols\n from sympy.printing.ccode import ccode\n-from sympy.codegen.ast import Declaration, Variable, float64, int64\n+from sympy.codegen.ast import Declaration, Variable, float64, int64, String\n from sympy.codegen.cnodes import (\n     alignof, CommaOperator, goto, Label, PreDecrement, PostDecrement, PreIncrement, PostIncrement,\n     sizeof, union, struct\n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..c4e9ae0 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,40 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_issue_BlockDiagMatrix_single_element():\n+    # Test for the issue where converting a BlockDiagMatrix with one element to a regular Matrix fails\n+    \n+    from sympy import Matrix, BlockDiagMatrix\n+\n+    # Single matrix block\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    \n+    try:\n+        B = Matrix(D)\n+        assert B == M, \"Conversion did not produce expected matrix\"\n+    except TypeError as e:\n+        assert False, f\"TypeError was raised: {e}\"\n+\n+def test_issue_BlockDiagMatrix_multiple_elements():\n+    # Test to ensure BlockDiagMatrix with multiple elements converts correctly\n+\n+    from sympy import Matrix, BlockDiagMatrix\n+\n+    # Two matrix blocks\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M, M)\n+    B = Matrix(D)\n+    \n+    expected_matrix = Matrix([\n+        [1, 2, 0, 0],\n+        [3, 4, 0, 0],\n+        [0, 0, 1, 2],\n+        [0, 0, 3, 4]\n+    ])\n+    \n+    assert B == expected_matrix, \"Block matrix conversion did not match expected result\"\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..e8b8e1b 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n@@ -83,7 +84,17 @@ def test_block_index():\n     assert BI.as_explicit().equals(eye(6))\n \n \n-def test_slicing():\n+def test_block_index_symbolic_specific_issue():\n+    from sympy import MatrixSymbol, BlockMatrix, MatrixElement, symbols\n+    # Given code from the issue report\n+    n, i = symbols('n, i', integer=True)\n+    A = MatrixSymbol('A', 1, 1)\n+    B = MatrixSymbol('B', n, 1)\n+    C = BlockMatrix([[A], [B]])\n+\n+    # Check that C[i, 0] is not simplified to a specific block\n+    # Even in the provided code, the resolution was to wrap this as a MatrixElement\n+    assert C[i, 0] == MatrixElement(C, i, 0)\n     A.as_explicit()[0, :]  # does not raise an error\n \n \n",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..ed1628f 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -200,7 +200,25 @@ def test_im():\n     X = FunctionMatrix(3, 3, Lambda((n, m), n + m*I))\n     assert im(X) == Matrix([[0, 1, 2], [0, 1, 2], [0, 1, 2]])\n \n+from sympy import Symbol, Abs, Piecewise, Eq, I, nan, S, sign, sqrt, sin, cos, Function, oo, AccumBounds, FunctionMatrix, Lambda, Derivative\n+\n def test_sign():\n+    # Test cases for sign.rewrite(Abs)\n+    y = Symbol('y')\n+    assert sign(y).rewrite(Abs) == Piecewise((0, Eq(y, 0)), (y/Abs(y), True))\n+    \n+    f = Function('f')\n+    assert sign(f(y)).rewrite(Abs) == Piecewise((0, Eq(f(y), 0)), (f(y)/Abs(f(y)), True))\n+\n+    # Test cases for specific numbers\n+    assert sign(0).rewrite(Abs) == 0  # handling of zero\n+    assert sign(3).rewrite(Abs) == 1  # positive number\n+    assert sign(-3).rewrite(Abs) == -1  # negative number\n+    assert sign(3*I).rewrite(Abs) == I  # imaginary number\n+    assert sign(-3*I).rewrite(Abs) == -I  # negative imaginary number\n+    assert sign(2 + 3*I).rewrite(Abs) == (2 + 3*I) / Abs(2 + 3*I)  # complex number\n+\n+    assert sign(0).rewrite(Abs) != nan  # assert that 0 handling doesn't give nan, to document desired behavior\n     assert sign(1.2) == 1\n     assert sign(-1.2) == -1\n     assert sign(3*I) == I\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..bec07b6 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -514,7 +514,23 @@ def test_partitions():\n         assert i == RGS_enum(n)\n \n \n-def test_binary_partitions():\n+def test_partitions_reusability():\n+    # Test that multiple calls to list(partitions(...)) return lists of independent dictionaries.\n+    results1 = list(partitions(4, k=3))\n+    results2 = list(partitions(4, k=3))\n+\n+    # Check that none of the partitions in results1 are the same object as in results2\n+    for r1, r2 in zip(results1, results2):\n+        assert r1 is not r2\n+        assert r1 == r2\n+\n+    # Test that modifying a partition doesn't affect the others\n+    results = list(partitions(4, k=2))\n+    first = results[0]\n+    first_copy = first.copy()  # Create a copy to verify against changes\n+    first[1] = 99  # Modify the partition\n+    # Ensure that modifying one partition doesn't change its independent copy\n+    assert first != first_copy\n     assert [i[:] for i in binary_partitions(10)] == [[8, 2], [8, 1, 1],\n         [4, 4, 2], [4, 4, 1, 1], [4, 2, 2, 2], [4, 2, 2, 1, 1],\n         [4, 2, 1, 1, 1, 1], [4, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2],\n",
  "sympy__sympy-20212": "diff --git a/sympy/core/tests/test_power.py b/sympy/core/tests/test_power.py\nindex 686973b..ac7372b 100644\n--- a/sympy/core/tests/test_power.py\n+++ b/sympy/core/tests/test_power.py\n@@ -254,6 +254,8 @@ def test_power_rewrite_exp():\n                     (sin, cos, tan, sec, csc, sinh, cosh, tanh))\n \n \n+from sympy import S, oo\n+\n def test_zero():\n     x = Symbol('x')\n     y = Symbol('y')\n@@ -265,6 +267,11 @@ def test_zero():\n     assert 0**(x - 2) != S.Infinity**(2 - x)\n     assert 0**(2*x*y) == 0**(x*y)\n     assert 0**(-2*x*y) == S.ComplexInfinity**(x*y)\n+    \n+    # Test issue 19572\n+    # Verify that 0**-oo returns zoo (ComplexInfinity)\n+    assert 0**-oo == S.ComplexInfinity\n+    assert Pow(0, -oo) == S.ComplexInfinity\n \n \n def test_pow_as_base_exp():\n",
  "sympy__sympy-20442": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 6a8906d..fd70579 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (Abs, Add, Function, Number, Rational, S, Symbol,\n                    diff, exp, integrate, log, sin, sqrt, symbols)\n from sympy.physics.units import (amount_of_substance, convert_to, find_unit,\n@@ -10,8 +11,10 @@ from sympy.physics.units.definitions import (amu, au, centimeter, coulomb,\n \n from sympy.physics.units.definitions.dimension_definitions import (\n     Dimension, charge, length, time, temperature, pressure,\n-    energy\n+    energy, mass\n )\n+from sympy.physics.units import joule\n+from sympy import Mul\n from sympy.physics.units.prefixes import PREFIXES, kilo\n from sympy.physics.units.quantities import Quantity\n from sympy.physics.units.systems import SI\n",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..cb32185 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -28,6 +28,21 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+# Test to ensure that Symbol instances do not have a __dict__ attribute\n+import sympy\n+\n+def test_symbol_no_dict():\n+    s = sympy.Symbol('s')\n+    # Check that AttributeError is raised for __dict__\n+    with raises(AttributeError):\n+        _ = s.__dict__\n+\n+def test_symbol_slots():\n+    s = sympy.Symbol('s')\n+    # Check that the __slots__ exist and are as expected\n+    expected_slots = ('name',)\n+    assert s.__slots__ == expected_slots\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..53f5b30 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,5 +1,6 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n-                   atan, atan2, nan, Symbol, re, im, sign)\n+                   atan, atan2, nan, Symbol, re, im, sign, arg, Integral, sin, oo)\n from sympy.abc import w, x, y, z\n from sympy.core.relational import Eq, Ne\n from sympy.functions.elementary.piecewise import Piecewise\n@@ -161,7 +162,20 @@ def test_sign():\n     assert refine(sign(x), Q.zero(x)) == 0\n \n \n-def test_func_args():\n+def test_complex_refinements():\n+    a = Symbol('a', real=True)\n+    assert refine(arg(a), Q.positive(a)) == 0\n+    assert refine(arg(-a), Q.positive(a)) == pi\n+    assert refine(Abs(a), Q.positive(a)) == a\n+    assert refine(Abs(a), Q.negative(a)) == -a\n+\n+    x = Symbol('x', real=True)\n+    # Testing integration simplification\n+    J = Integral(sin(x)*exp(-a*x), (x, 0, oo))\n+    simplified_result = refine(J.doit(), Q.positive(a))\n+    assert simplified_result == 1/(a**2 + 1)\n+\n+    assert refine(simplified_result, Q.real(a)) == simplified_result  # Ensure no further simplification occurs\n     class MyClass(Expr):\n         # A class with nontrivial .func\n \n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..040812d 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -9,6 +10,34 @@ from sympy.testing.pytest import XFAIL\n from sympy.abc import a, x, y, z, t\n \n def test_subs():\n+    # Test for issue 21373 on subs() with hyperbolic functions and Piecewise\n+    from sympy.functions.elementary.trigonometric import sinh, cosh, tanh\n+    from sympy.functions.elementary.piecewise import Piecewise\n+\n+    # Variables\n+    x_r, y_r, z_r = symbols('x_r y_r z_r', real=True)\n+\n+    # Case 1: expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    expr1 = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr1.subs({1: 1.0}) == expr1\n+\n+    # Ensure the error does not arise with cosh and tanh as well\n+    expr2 = exp(cosh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr2.subs({1: 1.0}) == expr2\n+\n+    expr3 = exp(tanh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr3.subs({1: 1.0}) == expr3\n+\n+    # Test without division\n+    expr4 = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True))))\n+    assert expr4.subs({1: 1.0}) == expr4\n+\n+    # Test with other functions like sin, log\n+    expr5 = sin(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r)\n+    assert expr5.subs({1: 1.0}) == expr5\n+\n+    expr6 = log(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r)\n+    assert expr6.subs({1: 1.0}) == expr6\n     n3 = Rational(3)\n     e = x\n     e = e.subs(x, n3)\n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..705e8d8 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,5 +1,7 @@\n+\n from sympy.core.add import Add\n-from sympy.core.kind import NumberKind, UndefinedKind\n+from sympy.core.function import Derivative\n+from sympy.core.kind import NumberKind, UndefinedKind, MatrixKind\n from sympy.core.mul import Mul\n from sympy.core.numbers import pi, zoo, I, AlgebraicNumber\n from sympy.core.singleton import S\n@@ -45,7 +47,12 @@ def test_Matrix_kind():\n         m = cls.zeros(3, 2)\n         assert m.kind is MatrixKind(NumberKind)\n \n-def test_MatMul_kind():\n+def test_Derivative_kind():\n+    A = MatrixSymbol('A', 2, 2)\n+    d = Derivative(comm_x, comm_x)\n+    assert d.kind is NumberKind\n+    d_matrix = Derivative(A, comm_x)\n+    assert d_matrix.kind is MatrixKind(NumberKind)\n     M = Matrix([[1,2],[3,4]])\n     assert MatMul(2, M).kind is MatrixKind(NumberKind)\n     assert MatMul(comm_x, M).kind is MatrixKind(NumberKind)\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..ae1d574 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -131,7 +131,22 @@ def test_monomials():\n     assert set(itermonomials([x, y], [2, 2])) == \\\n             {S.One, y**2, x*y**2, x, x*y, x**2, x**2*y**2, y, x**2*y}\n \n+    assert set(itermonomials([x, y], 3, 3)) == {x**3, x**2*y, x*y**2, y**3}\n+    assert set(itermonomials([x, y], 3, 2)) == {x**2, x*y, y**2, x**3, x**2*y, x*y**2, y**3}\n+    \n+    assert set(itermonomials([x, y, z], 3, 3)) == {x**3, y**3, z**3, x**2*y, x*y**2, y**2*z, y*z**2, z**2*x, z*x**2, x*z**2, x*y*z}\n+    \n     i, j, k = symbols('i j k', commutative=False)\n+    \n+    assert set(itermonomials([i, j, k], 2, 2)) == \\\n+            {k*i, i**2, i*j, j*k, j*i, k**2, j**2, k*j, i*k}\n+\n+    assert set(itermonomials([i, j, k], 3, 2)) == \\\n+            {j*k**2, i*k**2, k*i*j, k*i**2, k**2, j*k*j, k*j**2, i*k*i, i*j,\n+                    j**2*k, i**2*j, j*i*k, j**3, i**3, k*j*i, j*k*i, j*i,\n+                    k**2*j, j*i**2, k*j, k*j*k, i*j*i, j*i*j, i*j**2, j**2,\n+                    k*i*k, i**2, j*k, i*k, i*k*j, k**3, i**2*k, j**2*i, k**2*i,\n+                    i*j*k, k*i}\n     assert set(itermonomials([i, j, k], [0, 0, 0])) == {S.One}\n     assert set(itermonomials([i, j, k], [0, 0, 1])) == {1, k}\n     assert set(itermonomials([i, j, k], [0, 1, 0])) == {1, j}\n",
  "sympy__sympy-22005": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 341f63c..1db720a 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n@@ -49,6 +50,21 @@ def test_solve_poly_system():\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\n     raises(PolynomialError, lambda: solve_poly_system([1/x], x))\n \n+    # Tests for the fix related to infinite solution request detection\n+    raises(NotImplementedError, lambda: solve_poly_system([x - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([y - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([x*y - 1], (x, y, z)))\n+    raises(NotImplementedError, lambda: solve_poly_system([x - 1, y - 2], (x, y, z)))\n+    raises(NotImplementedError, lambda: solve_poly_system([x + y - 1], (x, y)))\n+    \n+    # Variations on single variable system\n+    assert solve_poly_system([x - 1], x) == [(1,)]\n+    assert solve_poly_system([y - 1], y) == [(1,)]\n+\n+    # Edge cases\n+    raises(NotImplementedError, lambda: solve_poly_system([x*y], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([], (x, y, z)))\n+\n \n def test_solve_biquadratic():\n     x0, y0, x1, y1, r = symbols('x0 y0 x1 y1 r')\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..2d4d0fc 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n@@ -9,10 +10,15 @@ from sympy.geometry.entity import rotate, scale, translate, GeometryEntity\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.misc import Undecidable\n-from sympy.testing.pytest import raises, warns\n+from sympy.core.parameters import evaluate\n \n \n-def test_point():\n+def test_issue_22684():\n+    # Test with evaluate(False) to ensure it doesn't raise unexpected errors\n+    with evaluate(False):\n+        p = Point2D(Integer(1), Integer(2))\n+    # Verify that the coordinates are correct\n+    assert p == Point2D(1, 2)\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..74d7c57 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -338,7 +338,46 @@ def test_cse_Indexed():\n     assert len(replacements) > 0\n \n \n+from sympy import Matrix, MatrixSymbol, cse, symbols, IndexedBase, Idx\n+\n def test_cse_MatrixSymbol():\n+    # Test case derived from the issue description\n+    def sub_in_matrixsymbols(exp, matrices):\n+        for matrix in matrices:\n+            for i in range(matrix.shape[0]):\n+                for j in range(matrix.shape[1]):\n+                    name = \"%s_%d_%d\" % (matrix.name, i, j)\n+                    sym = symbols(name)\n+                    exp = exp.subs(sym, matrix[i, j])\n+        return exp\n+\n+    # Original issue test case for cse with MatrixSymbols\n+    def t44(name):\n+        return Matrix(4, 4, lambda i, j: symbols('%s_%d_%d' % (name, i, j)))\n+\n+    a = t44(\"a\")\n+    b = t44(\"b\")\n+    e = a * b\n+    e2 = sub_in_matrixsymbols(e, [MatrixSymbol(\"a\", 4, 4), MatrixSymbol(\"b\", 4, 4)])\n+    cse_subs, cse_reduced = cse(e2)\n+\n+    # Assert that replacements are generated correctly\n+    assert cse_subs == [\n+        (symbols('x0'), MatrixSymbol('a', 4, 4)),\n+        (symbols('x1'), symbols('x0')[0, 0]),\n+        (symbols('x2'), MatrixSymbol('b', 4, 4)),\n+        (symbols('x3'), symbols('x2')[0, 0]),\n+        (symbols('x4'), symbols('x0')[0, 1]),\n+        (symbols('x5'), symbols('x2')[1, 0]),\n+        (symbols('x6'), symbols('x0')[0, 2]),\n+        (symbols('x7'), symbols('x2')[2, 0]),\n+        (symbols('x8'), symbols('x0')[0, 3]),\n+        (symbols('x9'), symbols('x2')[3, 0]),\n+        # and so on for all necessary elements...\n+    ]    \n+\n+    # Assert that reduced expressions correspond to the expected form\n+    assert isinstance(cse_reduced[0], Matrix)\n     # MatrixSymbols have non-Basic args, so make sure that works\n     A = MatrixSymbol(\"A\", 3, 3)\n     assert cse(A) == ([], [A])\n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..949c62c 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -7,7 +8,7 @@ from sympy.tensor.array.dense_ndim_array import (\n     ImmutableDenseNDimArray, MutableDenseNDimArray)\n from sympy.tensor.array.sparse_ndim_array import (\n     ImmutableSparseNDimArray, MutableSparseNDimArray)\n-\n+from sympy.tensor.array import Array\n from sympy.abc import x, y\n \n array_types = [\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..fc3b0fe 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,7 +1175,26 @@ def test_scipy_polys():\n \n \n \n-def test_lambdify_inspect():\n+def test_tuple_with_one_element():\n+    # Test with a single integer element\n+    f1 = lambdify([], (1,))\n+    assert f1() == (1,)\n+    \n+    # Test with a single float element\n+    f2 = lambdify([], (3.14,))\n+    assert f2() == (3.14,)\n+    \n+    # Test with a single string element\n+    f3 = lambdify([], (\"test\",))\n+    assert f3() == (\"test\",)\n+    \n+    # Test with a single symbol element\n+    f4 = lambdify([], (x,))\n+    assert f4() == (x,)\n+    \n+    # Test with a single list element\n+    f5 = lambdify([], ([\"a\", \"b\"],))\n+    assert f5() == ([\"a\", \"b\"],)\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n     # details\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..9b5e3d6 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -541,6 +541,28 @@ def test_issue_20288():\n     assert SI._collect_factor_and_dimension(expr) == (1 + E, Dimension(1))\n \n \n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units.quantity import Quantity\n+    from sympy.physics.units.systems.si import SI\n+\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n+\n def test_prefixed_property():\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..e2ff819 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -45,6 +45,23 @@ def test_tensor_product_expand():\n     assert TP(A + B, B + C).expand(tensorproduct=True) == \\\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n+    # Tests for fix of tensor product expansion issue\n+    assert TP(A - B, B - A).expand(tensorproduct=True) == \\\n+        TP(A, B) - TP(A, A) - TP(B, B) + TP(B, A)\n+\n+    assert TP(2*A + B, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A, A) + 2 * TP(A, B) + TP(B, A) + TP(B, B)\n+\n+    assert TP(2 * A * B + A, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A*B, A) + 2 * TP(A*B, B) + TP(A, A) + TP(A, B)\n+\n+    # Check with zero factor within a tensor product\n+    assert TP(A - A, B + C).expand(tensorproduct=True) == 0\n+\n+    # Check nested tensor products\n+    assert TP(TP(A, B) + TP(B, A), C).expand(tensorproduct=True) == \\\n+        TP(A, B, C) + TP(B, A, C)\n+\n \n def test_tensor_product_commutator():\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..d337506 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -562,7 +563,31 @@ def test_issue_24062():\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n \n-def test_prefixed_property():\n+def test_issue_24211():\n+    from sympy.physics.units import Quantity, velocity, acceleration, time, meter, second\n+    from sympy.physics.units.systems.si import SI\n+\n+    # Define quantities\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+\n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+\n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+\n+    # Expression under test\n+    expr1 = a1 * t1 + v1\n+\n+    # This should not throw ValueError\n+    SI._collect_factor_and_dimension(expr1)\n+\n+\n+# Existing test case\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..028b100 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, milli, W, V\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n@@ -27,6 +28,18 @@ def test_prefix_operations():\n     assert k / dodeca == S(1000) / 12\n     assert dodeca / dodeca == 1\n \n+def test_milli_prefix_with_units():\n+    # Verify milli prefix with Watt\n+    assert milli * W == W / 1000\n+    assert W * milli == W / 1000\n+    \n+    # Verify milli prefix with another unit such as Volt\n+    assert milli * V == V / 1000\n+    assert V * milli == V / 1000\n+    \n+    # Check multiplication by milli for identity\n+    assert milli * 1000 == 1\n+\n     m = Quantity(\"fake_meter\")\n     SI.set_quantity_dimension(m, S.One)\n     SI.set_quantity_scale_factor(m, S.One)\n",
  "django__django-12470": "diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py\nindex 067de1c..d12289e 100644\n--- a/tests/model_inheritance/tests.py\n+++ b/tests/model_inheritance/tests.py\n@@ -5,6 +5,7 @@ from django.db import connection, models\n from django.test import SimpleTestCase, TestCase\n from django.test.utils import CaptureQueriesContext, isolate_apps\n \n+from django.db import connection\n from .models import (\n     Base, Chef, CommonInfo, GrandChild, GrandParent, ItalianRestaurant,\n     MixinModel, ParkingLot, Place, Post, Restaurant, Student, SubBase,\n@@ -204,8 +205,31 @@ class ModelInheritanceTests(TestCase):\n \n         self.assertEqual(A.attr.called, (A, 'attr'))\n \n+class ModelInheritanceOrderingTests(TestCase):\n+    def test_inherited_ordering_pk_desc(self):\n+        p1 = Parent.objects.create(first_name='Joe', email='joe@email.com')\n+        p2 = Parent.objects.create(first_name='Jon', email='jon@email.com')\n+        c1 = Child.objects.create(first_name='Ann', email='ann@email.com')\n+        c2 = Child.objects.create(first_name='Bob', email='bob@email.com')\n \n-class ModelInheritanceDataTests(TestCase):\n+        expected_order_by_sql_parent = 'ORDER BY %s.%s DESC' % (\n+            connection.ops.quote_name(Parent._meta.db_table),\n+            connection.ops.quote_name('id'),\n+        )\n+        expected_order_by_sql_child = 'ORDER BY %s.%s DESC' % (\n+            connection.ops.quote_name(Child._meta.db_table),\n+            connection.ops.quote_name('parent_ptr_id'),\n+        )\n+\n+        # Test Parent ordering\n+        parent_qs = Parent.objects.all()\n+        self.assertSequenceEqual(parent_qs, [p2, p1])\n+        self.assertIn(expected_order_by_sql_parent, str(parent_qs.query))\n+\n+        # Test Child ordering\n+        child_qs = Child.objects.all()\n+        self.assertSequenceEqual(child_qs, [c2, c1])\n+        self.assertIn(expected_order_by_sql_child, str(child_qs.query))\n     @classmethod\n     def setUpTestData(cls):\n         cls.restaurant = Restaurant.objects.create(\n",
  "django__django-13033": "",
  "django__django-13265": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..297b5b7 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3201,8 +3201,35 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         form = SomeForm()\n         self.assertEqual(form['field'].id_for_label, 'myCustomID')\n         self.assertEqual(form['field_none'].id_for_label, 'id_field_none')\n+    def test_boundwidget_custom_id_for_label(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label correctly uses the custom 'id' set\n+        through ChoiceWidget.options and falls back to generated ID if not provided.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple(\n+                    options={'attrs': [{'id': 'custom_id_a'}, {'id': 'custom_id_b'}]}\n+                ),\n+            )\n+\n+        form = SomeForm(auto_id='custom_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_a')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_b')\n+\n+        # Now testing fallback if no custom 'id' is provided; it should use default auto_id\n+        class AnotherForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('c', 'C'), ('d', 'D')],\n+                widget=CheckboxSelectMultiple,\n+            )\n \n-    def test_boundfield_widget_type(self):\n+        another_form = AnotherForm(auto_id='generated_%s')\n+        another_subwidgets = another_form['field'].subwidgets\n+        self.assertEqual(another_subwidgets[0].id_for_label, 'generated_field_0')\n+        self.assertEqual(another_subwidgets[1].id_for_label, 'generated_field_1')\n         class SomeForm(Form):\n             first_name = CharField()\n             birthday = SplitDateTimeField(widget=SplitHiddenDateTimeWidget)\n",
  "django__django-16400": "",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..59c908b 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -633,6 +633,42 @@ def test_colorbar_format(fmt):\n     fig.canvas.draw()\n     assert cbar.ax.yaxis.get_ticklabels()[4].get_text() == '2.00e+02'\n \n+\n+def test_update_colorbar_after_changing_norm():\n+    import matplotlib.pyplot as plt\n+    from matplotlib.colors import LogNorm, Normalize\n+    import numpy as np\n+\n+    img = 10**np.random.normal(1, 1, size=(50, 50))\n+\n+    fig, ax = plt.subplots(1, 1)\n+    plot = ax.imshow(img, cmap='gray')\n+    cb = fig.colorbar(plot, ax=ax)\n+    \n+    # Initially, log normalization should not be applied\n+    assert cb.ax.yaxis.get_scale() == 'linear'\n+    \n+    # Change norm to LogNorm\n+    plot.norm = LogNorm()\n+    cb.update_normal(plot)\n+    \n+    # The colorbar should now reflect the log scale\n+    assert cb.ax.yaxis.get_scale() == 'log'\n+    \n+    # Ensure the colorbar ticks are recalculated correctly\n+    fig.canvas.draw()\n+    tick_texts = [tick.get_text() for tick in cb.ax.get_yticklabels()]\n+    assert all(t != '' for t in tick_texts), \"All tick labels should be updated and not empty.\"\n+\n+    # Reverting back to linear norm\n+    plot.set_norm(Normalize())\n+    cb.update_normal(plot)\n+    \n+    assert cb.ax.yaxis.get_scale() == 'linear'\n+    fig.canvas.draw()\n+    tick_texts = [tick.get_text() for tick in cb.ax.get_yticklabels()]\n+    assert all(t != '' for t in tick_texts), \"All tick labels should be updated and not empty after reverting.\"\n+\n     # but if we change the norm:\n     im.set_norm(LogNorm(vmin=0.1, vmax=10))\n     fig.canvas.draw()\n",
  "pydata__xarray-4094": "",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..1d63482 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -259,4 +259,34 @@ def test_set_output_mro():\n     class C(A, B):\n         pass\n \n-    assert C().transform(None) == \"B\"\n+    assert C().transform(None) == \"B\"\n+\n+def test_feature_union_with_pandas_output():\n+    \"\"\"Test FeatureUnion with pandas output to ensure it handles grouping \n+    operations correctly and does not throw errors when using pandas configurations.\"\"\"\n+\n+    import pandas as pd\n+    from sklearn.base import BaseEstimator, TransformerMixin\n+    from sklearn.pipeline import make_union\n+    from sklearn import set_config\n+\n+    # Setup data\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+\n+    # Custom transformer\n+    class MyTransformer(BaseEstimator, TransformerMixin):\n+        def fit(self, X: pd.DataFrame, y=None, **kwargs):\n+            return self\n+\n+        def transform(self, X: pd.DataFrame, y=None) -> pd.DataFrame:\n+            return X[\"value\"].groupby(X[\"date\"]).sum().to_frame()\n+\n+    # Test with pandas output\n+    set_config(transform_output=\"pandas\")\n+    try:\n+        result = make_union(MyTransformer()).fit_transform(data)\n+        print(result)  # To verify no exception and to inspect transformed DataFrame\n+    except ValueError as e:\n+        pytest.fail(f\"FeatureUnion with pandas output failed: {e}\")\n",
  "sphinx-doc__sphinx-8801": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 37d6e17..ded0ad7 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -106,6 +106,36 @@ def test_inherited_instance_variable(app):\n     ]\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    # Test case to check if annotation only members in superclass are documented\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'target.example.Bar', options)\n+\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n def test_decorators(app):\n     actual = do_autodoc(app, 'class', 'target.decorator.Baz')\n     assert list(actual) == [\n@@ -115,6 +145,36 @@ def test_decorators(app):\n         '',\n     ]\n \n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    # Test case to check if annotation only members in superclass are documented\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'target.example.Bar', options)\n+\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n     actual = do_autodoc(app, 'class', 'target.decorator.Qux')\n     assert list(actual) == [\n         '',\n@@ -132,6 +192,36 @@ def test_decorators(app):\n     ]\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    # Test case to check if annotation only members in superclass are documented\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'target.example.Bar', options)\n+\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_slots_attribute(app):\n     options = {\"members\": None}\n",
  "sympy__sympy-15346": "",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..d363c79 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4862,8 +4862,36 @@ k = \u2500\u2500\u2500\u2500\u2500                                \\n\\\n     assert pretty(expr) == ascii_str\n     assert upretty(expr) == ucode_str\n \n+def test_sum_alignment_with_addition():\n+    from sympy import Sum, oo, pprint\n+    from sympy.abc import x\n \n-def test_units():\n+    expr = Sum(x, (x, 1, oo)) + 3\n+    pretty_str = \\\n+u(\"\"\"\\\n+  \u221e   \\n\\\n+ ___  \\n\\\n+ \u2572    \\n\\\n+  \u2572   x\\n\\\n+  \u2571  +3\\n\\\n+ \u2571    \\n\\\n+ \u203e\u203e\u203e  \\n\\\n+x = 1 \\n\\\n+\"\"\")\n+    assert upretty(expr) == pretty_str\n+\n+    ascii_str = \\\n+\"\"\"\\\n+  oo \\n\\\n+ ___ \\n\\\n+ \\\\   \\n\\\n+  \\\\  x\\n\\\n+  / +3\\n\\\n+ /   \\n\\\n+/___ \\n\\\n+x = 1\\n\\\n+\"\"\"\n+    assert pretty(expr) == ascii_str\n     expr = joule\n     ascii_str1 = \\\n \"\"\"\\\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex b2b6202..f554a59 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -704,6 +704,25 @@ def test_uniq():\n     assert list(uniq([2, 3, 2, 4, [2], [1], [2], [3], [1]])) == \\\n         [2, 3, 4, [2], [1], [3]]\n \n+def test_uniq_modification():\n+    from sympy.utilities.iterables import uniq\n+    from sympy.utilities.pytest import raises\n+\n+    # Test a list with unique elements removed while iterating\n+    f = list('THISTLE')\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Test modification with nested lists\n+    f = [['T'], ['H', 'I'], ['S', 'T']]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Test edge case with empty list\n+    f = []\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Test edge case with single element list\n+    f = ['A']\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n \n def test_kbins():\n     assert len(list(kbins('1123', 2, ordered=1))) == 24\n",
  "django__django-11797": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 7beeac3..5cd6cdf 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -1,9 +1,11 @@\n+\n import collections.abc\n from datetime import datetime\n from math import ceil\n from operator import attrgetter\n \n from django.core.exceptions import FieldError\n+from django.db.models import Max\n from django.db import connection\n from django.db.models.expressions import Exists, OuterRef\n from django.db.models.functions import Substr\n",
  "django__django-15320": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 35f7f03..fbbf112 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -536,6 +536,15 @@ class BasicExpressionsTests(TestCase):\n             qs.query.annotations['is_ceo'],\n             qs.query.annotations['small_company'],\n         )\n+    def test_subquery_sql(self):\n+        employees = Employee.objects.all()\n+        employees_subquery = Subquery(employees)\n+        self.assertTrue(employees_subquery.query.subquery)\n+        self.assertFalse(employees.query.subquery)\n+        compiler = employees_subquery.query.get_compiler(connection=connection)\n+        sql, _ = employees_subquery.as_sql(compiler, connection)\n+        self.assertIn('(SELECT ', sql)\n+        self.assertTrue(sql.endswith(')'))  # Ensures that the SQL ends with a closing parenthesis.\n \n     def test_in_subquery(self):\n         # This is a contrived test (and you really wouldn't write this query),\n",
  "django__django-15819": "",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..a8d281e 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -152,7 +153,34 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n-    def test_reverse_fk_select_related_multiple(self):\n+    def test_wrong_select_related(self):\n+        with self.assertNumQueries(3):\n+            pools = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation('pool__tournament__pool'),\n+                ).select_related('tournament_pool', 'tournament_pool__tournament')\n+            )\n+            self.assertEqual(pools[0].tournament_pool.tournament, pools[0].pool.tournament)\n+\n+    def test_multilevel_reverse_fk_cyclic_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation(\"pool__tournament__pool\"),\n+                ).select_related(\"tournament_pool\", \"tournament_pool__tournament\")\n+            )\n+            self.assertEqual(p[0].tournament_pool.tournament, p[0].pool.tournament)\n+\n+    def test_multilevel_reverse_fk_select_related(self):\n+        with self.assertNumQueries(2):\n+            p = list(\n+                Tournament.objects.filter(id=self.t2.id)\n+                .annotate(\n+                    style=FilteredRelation(\"pool__another_style\"),\n+                )\n+                .select_related(\"style\")\n+            )\n+            self.assertEqual(p[0].style.another_pool, self.p3)\n         with self.assertNumQueries(1):\n             ps = list(\n                 PoolStyle.objects.annotate(\n@@ -163,4 +191,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex ad1a5e1..7bbdf99 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1,3 +1,29 @@\n+\n+def test_unpickle_with_device_pixel_ratio():\n+    fig = Figure(dpi=42)\n+    fig.canvas._set_device_pixel_ratio(7)\n+    assert fig.dpi == 42*7\n+    fig2 = pickle.loads(pickle.dumps(fig))\n+    assert fig2.dpi == 42\n+\n+def test_dpi_stability_after_pickle():\n+    fig = plt.figure(dpi=200)\n+    # Verify initial DPI\n+    assert fig.dpi == 200\n+\n+    # Pickle and unpickle the figure in a loop\n+    for _ in range(32):\n+        fig = pickle.loads(pickle.dumps(fig))\n+        assert fig.dpi == 200\n+\n+def test_dpi_invariance_on_m1_mac():\n+    is_m1_mac = platform.system() == 'Darwin' and 'arm64' in platform.platform()\n+    if is_m1_mac:\n+        fig = plt.figure(dpi=200)\n+        for _ in range(32):\n+            fig = pickle.loads(pickle.dumps(fig))\n+            assert fig.dpi == 200\n+\n import copy\n from datetime import datetime\n import io\n@@ -5,7 +31,8 @@ from pathlib import Path\n import platform\n from threading import Timer\n from types import SimpleNamespace\n-import warnings\n+import pickle\n+import matplotlib.pyplot as plt\n \n import numpy as np\n import pytest\n@@ -13,7 +40,7 @@ from PIL import Image\n \n import matplotlib as mpl\n from matplotlib import gridspec, rcParams\n-from matplotlib.testing.decorators import image_comparison, check_figures_equal\n+from matplotlib.figure import Figure\n from matplotlib.axes import Axes\n from matplotlib.figure import Figure, FigureBase\n from matplotlib.layout_engine import (ConstrainedLayoutEngine,\n",
  "mwaskom__seaborn-2848": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 5a5e126..f46adf1 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -1,3 +1,4 @@\n+\n from itertools import product\n import numpy as np\n import matplotlib as mpl\n@@ -10,6 +11,8 @@ from numpy.testing import assert_array_equal\n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n \n+from seaborn import PairGrid, scatterplot, regplot\n+\n from seaborn.relational import (\n     _RelationalPlotter,\n     _LinePlotter,\n",
  "pytest-dev__pytest-5413": "",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..178533e 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -404,8 +404,16 @@ class TestCustomConftests:\n         testdir.makepyfile(\"def test_x(): pass\")\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n-\n-    def test_pytest_collect_file_from_sister_dir(self, testdir):\n+    \n+    def test_collect_only_shortcut(self, testdir):\n+        testdir.makepyfile(\"def test_x(): pass\")\n+        # Test using the long form\n+        result = testdir.runpytest(\"--collect-only\")\n+        result.stdout.fnmatch_lines([\"*test_x*\"])\n+        \n+        # Test using the proposed shortcut '-C'\n+        result = testdir.runpytest(\"-C\")\n+        result.stdout.fnmatch_lines([\"*test_x*\"])\n         sub1 = testdir.mkpydir(\"sub1\")\n         sub2 = testdir.mkpydir(\"sub2\")\n         conf1 = testdir.makeconftest(\n",
  "sphinx-doc__sphinx-10451": "diff --git a/tests/roots/test-ext-autodoc/target/typehints.py b/tests/roots/test-ext-autodoc/target/typehints.py\nindex 100ea06..040ee79 100644\n--- a/tests/roots/test-ext-autodoc/target/typehints.py\n+++ b/tests/roots/test-ext-autodoc/target/typehints.py\n@@ -91,11 +91,20 @@ def missing_attr(c,\n     return a + (b or \"\")\n \n \n-class _ClassWithDocumentedInit:\n+class _ClassWithDocumentedInitAndStarArgs:\n+    \"\"\"Class docstring.\"\"\"\n+\n+    def __init__(self, x: int, *args: int, **kwargs: int) -> None:\n+        \"\"\"Init docstring.\n+\n+        :param x: Some integer\n+        :param *args: Some integer\n+        :param **kwargs: Some integer\n+        \"\"\"\n     \"\"\"Class docstring.\"\"\"\n \n     def __init__(self, x: int) -> None:\n         \"\"\"Init docstring.\n \n         :param x: Some integer\n-        \"\"\"\n+        \"\"\"\n",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..2e60b1a 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -80,6 +80,11 @@ def test_Identity():\n     assert A*Im == A\n     assert In*A == A\n \n+    # Additional Test: Ensure that the sum of all elements in the identity matrix equals 'n'\n+    assert Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).doit() == n.subs(n, 3).subs(n, 3)\n+    assert Sum(Sum(In[i, j], (i, 0, 2)), (j, 0, 2)).doit() == 3  # For n=3\n+    assert Sum(Sum(In[i, j], (i, 0, 4)), (j, 0, 4)).doit() == 5  # For n=5\n+\n     assert transpose(In) == In\n     assert In.inverse() == In\n     assert In.conjugate() == In\n",
  "sympy__sympy-20049": "",
  "sympy__sympy-21612": "diff --git a/sympy/parsing/tests/test_latex.py b/sympy/parsing/tests/test_latex.py\nindex b252985..0117e27 100644\n--- a/sympy/parsing/tests/test_latex.py\n+++ b/sympy/parsing/tests/test_latex.py\n@@ -251,7 +251,11 @@ def test_parseable():\n     for latex_str, sympy_expr in GOOD_PAIRS:\n         assert parse_latex(latex_str) == sympy_expr, latex_str\n \n-# These bad LaTeX strings should raise a LaTeXParsingError when parsed\n+def test_issue_21537():\n+    from sympy.parsing.latex import parse_latex\n+    expr = parse_latex(\"\\\\frac{\\\\frac{a^3+b}{c}}{\\\\frac{1}{c^2}}\")\n+    expected_expr = ((a**3 + b)/c)/(1/(c**2))\n+    assert expr == expected_expr, f\"Expected {expected_expr}, but got {expr}\"\n BAD_STRINGS = [\n     r\"(\",\n     r\")\",\n"
}