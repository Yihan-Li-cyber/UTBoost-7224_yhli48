{
  "astropy__astropy-12907": "",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..0b2cf62 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,6 +1,10 @@\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n from io import StringIO\n+import numpy as np\n+import astropy.units as u\n+from astropy.table import QTable\n \n from astropy.io import ascii\n \n",
  "astropy__astropy-14365": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 9b66109..29c5a35 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -109,7 +109,31 @@ def test_roundtrip(tmp_path):\n         assert meta_name in new_table.meta\n \n \n-def test_read_example():\n+@pytest.mark.parametrize(\"command_case\", [\"upper\", \"lower\", \"mixed\"])\n+def test_command_case(tmp_path, command_case):\n+    command_map = {\n+        \"upper\": lambda x: x.upper(),\n+        \"lower\": lambda x: x.lower(),\n+        \"mixed\": lambda x: ''.join(c.lower() if i % 2 else c.upper() for i, c in enumerate(x))\n+    }\n+    \n+    example_qdp = f\"\"\"\n+    ! This is a test for case insensitivity in QDP commands\n+    {command_map[command_case](\"READ SERR 1 2\")}\n+    1 0.5 1 0.5\n+    NO NO NO NO\n+    \"\"\"\n+\n+    path = str(tmp_path / \"case_test.qdp\")\n+\n+    with open(path, \"w\") as fp:\n+        print(example_qdp, file=fp)\n+\n+    table = Table.read(path, format='ascii.qdp')\n+    assert np.isclose(table['col1'][0], 1.0)\n+    assert np.isclose(table['col2'][0], 0.5)\n+    assert np.isclose(table['col3'][0], 1.0)\n+    assert np.isclose(table['col4'][0], 0.5)\n     example_qdp = \"\"\"\n         ! Initial comment line 1\n         ! Initial comment line 2\n",
  "astropy__astropy-14995": "diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py\nindex fc27f69..6d8b96b 100644\n--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py\n+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py\n@@ -31,7 +31,9 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n # Test with Data covers:\n # scalars, 1D, 2D and 3D\n # broadcasting between them\n-@pytest.mark.filterwarnings(\"ignore:divide by zero encountered.*\")\n+import numpy as np\n+import pytest\n+from astropy.nddata import NDDataRef\n @pytest.mark.parametrize(\n     (\"data1\", \"data2\"),\n     [\n@@ -44,7 +46,43 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n         (np.arange(1000).reshape(20, 5, 10), np.ones((20, 5, 10)) * 3),\n     ],\n )\n-def test_arithmetics_data(data1, data2):\n+def test_nddata_bitmask_arithmetic():\n+    # NDData.mask is usually assumed to be boolean, but could be\n+    # a bitmask. Ensure bitmask works:\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_masked = NDDataRef(array, mask=mask)\n+\n+    # Multiply no mask by constant (no mask * no mask)\n+    assert nref_nomask.multiply(1.0, handle_mask=np.bitwise_or).mask is None\n+\n+    # Multiply no mask by itself (no mask * no mask)\n+    assert nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask is None\n+\n+    # Multiply masked by constant (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(1.0, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # Multiply masked by itself (mask * mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_masked, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # Multiply masked by no mask (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_nomask, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # Check bitwise logic still works\n+    other_mask = np.array([[64, 1, 0], [2, 1, 0], [8, 0, 2]])\n+    nref_mask_other = NDDataRef(array, mask=other_mask)\n+    np.testing.assert_equal(\n+        nref_mask_other.multiply(nref_masked, handle_mask=np.bitwise_or).mask,\n+        np.bitwise_or(mask, other_mask),\n+    )\n     nd1 = NDDataArithmetic(data1)\n     nd2 = NDDataArithmetic(data2)\n \n",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..27927cb 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -281,7 +281,20 @@ class TestTableFunctions(FitsTestCase):\n \n         assert comparerecords(a[1].data[::2], ra3)\n \n-        # Test Start Column\n+    def test_fits_table_with_d_exponent(self):\n+        # Create a table with a double precision format using 'D'\n+        r1 = np.array([1.23e3, 4.56e7])\n+        c2 = fits.Column(name='exp_column', format='D', array=r1)\n+        hdu = fits.TableHDU.from_columns([c2])\n+        hdu.writeto(self.temp('exp_table.fits'), overwrite=True)\n+        \n+        with open(self.temp('exp_table.fits'), 'r') as f:\n+            content = f.read()\n+            assert '1.2300000000000000D+03' in content\n+            assert '4.5600000000000000D+07' in content\n+\n+        with fits.open(self.temp('exp_table.fits')) as hdul:\n+            assert comparerecords(hdu.data, hdul[1].data)\n \n         a1 = chararray.array(['abcd', 'def'])\n         r1 = np.array([11., 12.])\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..522253b 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1092,8 +1092,12 @@ class OverrideSettingsTests(SimpleTestCase):\n         self.assertEqual(default_storage.base_location, '')\n         with self.settings(MEDIA_URL='/test_value/'):\n             self.assertEqual(default_storage.base_url, '/test_value/')\n-\n-    def test_override_file_upload_permissions(self):\n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        Ensure that the default FILE_UPLOAD_PERMISSIONS is set to 0o644.\n+        \"\"\"\n+        with self.settings(FILE_UPLOAD_PERMISSIONS=None):\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n         \"\"\"\n         Overriding the FILE_UPLOAD_PERMISSIONS setting should be reflected in\n         the file_permissions_mode attribute of\n",
  "django__django-10924": "",
  "django__django-11001": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 4e3940c..00e6617 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -367,6 +367,32 @@ class BasicExpressionsTests(TestCase):\n         )\n         self.assertEqual(str(qs.query).count('JOIN'), 1)\n \n+    def test_order_by_multiline_rawsql(self):\n+        raw_order_by = (\n+            RawSQL('''\n+                CASE WHEN salary > 50000\n+                     THEN id\n+                     ELSE 0 END\n+            ''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN salary < 50000\n+                     THEN 1\n+                     ELSE 0 END\n+            ''', []).asc()\n+        )\n+        Employee.objects.create(firstname='Alice', lastname='A', salary=60000)\n+        Employee.objects.create(firstname='Bob', lastname='B', salary=30000)\n+        Employee.objects.create(firstname='Charlie', lastname='C', salary=70000)\n+        \n+        expected_order = [\n+            Employee.objects.get(firstname='Charlie'),\n+            Employee.objects.get(firstname='Alice'),\n+            Employee.objects.get(firstname='Bob'),\n+        ]\n+        \n+        qs = Employee.objects.all().order_by(*raw_order_by)\n+        self.assertSequenceEqual(qs, expected_order)\n+\n     def test_ticket_18375_chained_filters(self):\n         # F() expressions do not reuse joins from previous filter.\n         qs = Employee.objects.filter(\n",
  "django__django-11039": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex dbcbef0..8f34fa2 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -514,6 +514,22 @@ class MigrateTests(MigrationTestBase):\n             out.getvalue()\n         )\n \n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_when_no_transactional_ddl_support(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support transactional DDL\n+        even when migration is atomic.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command('sqlmigrate', 'migrations', '0001', stdout=out)\n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n+\n     @override_settings(INSTALLED_APPS=['migrations.migrations_test_apps.unmigrated_app'])\n     def test_showmigrations_plan_app_label_no_migrations(self):\n         out = io.StringIO()\n",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..117b0ec 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -68,6 +68,24 @@ class TestSerialization(SimpleTestCase):\n class TestValidation(SimpleTestCase):\n \n     def test_invalid_string(self):\n+        # Test correctly formatted strings\n+        field = models.DurationField()\n+        for value in ['10 20:59:59', '59:59', '23:45', '1 00:00:01.123456']:\n+            with self.subTest(value=value):\n+                field.clean(value, None)  # Should not raise exception\n+\n+        # Test various incorrectly formatted strings\n+        with self.assertRaises(exceptions.ValidationError):\n+            field.clean('14:00', None)  # Missing seconds\n+\n+        with self.assertRaises(exceptions.ValidationError):\n+            field.clean('1 :45:30', None)  # Extra space\n+\n+        with self.assertRaises(exceptions.ValidationError):\n+            field.clean('1 abc:45:30', None)  # Invalid hour\n+\n+        with self.assertRaises(exceptions.ValidationError):\n+            field.clean('1:45:60', None)  # Invalid seconds\n         field = models.DurationField()\n         with self.assertRaises(exceptions.ValidationError) as cm:\n             field.clean('not a datetime', None)\n@@ -75,7 +93,7 @@ class TestValidation(SimpleTestCase):\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n             \"'not a datetime' value has an invalid format. \"\n-            \"It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n         )\n \n \n@@ -84,4 +102,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..436c0da 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -233,11 +233,11 @@ class NumericPasswordValidatorTest(SimpleTestCase):\n \n class UsernameValidatorsTests(SimpleTestCase):\n     def test_unicode_validator(self):\n-        valid_usernames = ['joe', 'Ren\u00e9', '\u1d2e\u1d35\u1d33\u1d2e\u1d35\u1d3f\u1d30', '\u0623\u062d\u0645\u062f']\n+        valid_usernames = ['joe', 'Ren\u00e9', '\u1d2e\u1d35\u1d33\u1d2e\u1d35\u1d3f\u1d30', '\u0623\u062d\u0645\u062f', 'trailingnewline']\n         invalid_usernames = [\n             \"o'connell\", \"\u0639\u0628\u062f \u0627\u0644\",\n             \"zerowidth\\u200Bspace\", \"nonbreaking\\u00A0space\",\n-            \"en\\u2013dash\",\n+            \"en\\u2013dash\", \"trailingnewline\\n\",\n         ]\n         v = validators.UnicodeUsernameValidator()\n         for valid in valid_usernames:\n@@ -250,7 +250,7 @@ class UsernameValidatorsTests(SimpleTestCase):\n \n     def test_ascii_validator(self):\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n-        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n+        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\", \"trailingnewline\\n\"]\n         v = validators.ASCIIUsernameValidator()\n         for valid in valid_usernames:\n             with self.subTest(valid=valid):\n@@ -258,4 +258,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..59c6988 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -356,6 +356,10 @@ class HttpResponseTests(unittest.TestCase):\n         r = HttpResponse()\n         self.assertIsNone(r.get('test'))\n \n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview'))\n+        self.assertEqual(r.content, b'memoryview')\n+\n     def test_non_string_content(self):\n         # Bug 16494: HttpResponse should behave consistently with non-strings\n         r = HttpResponse(12345)\n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..ba3b350 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,9 +1,12 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n+from django.db.models.deletion import Collector\n+\n from .models import (\n     MR, A, Avatar, Base, Child, HiddenUser, HiddenUserProfile, M, M2MFrom,\n     M2MTo, MRNull, Parent, R, RChild, S, T, User, create_a, get_default_r,\n@@ -464,7 +467,28 @@ class FastDeleteTests(TestCase):\n         # 1 to delete t, 1 to fast-delete t's m_set\n         self.assertNumQueries(2, f.delete)\n \n-    def test_fast_delete_qs(self):\n+    def test_fast_delete_instance_set_pk_none(self):\n+        # Test deletion on a model instance without dependencies sets pk to None\n+        u = User.objects.create()\n+        # User can be fast-deleted\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        # Delete the user instance\n+        u.delete()\n+        # Ensure the pk is set to None after deletion\n+        self.assertIsNone(u.pk)\n+\n+    def test_fast_delete_instance_with_dependencies_does_not_set_pk_none(self):\n+        # Test deletion on a model instance with dependencies does not set pk to None\n+        a = Avatar.objects.create(desc='a')\n+        u = User.objects.create(avatar=a)\n+        # User should not be fast-deleted because it depends on avatar\n+        collector = Collector(using='default')\n+        self.assertFalse(collector.can_fast_delete(u))\n+        # Delete the user instance\n+        u.delete()\n+        # Ensure the pk is still not set to None after deletion\n+        self.assertIsNotNone(u.pk)  # This is where correct behavior differs for dependencies\n         u1 = User.objects.create()\n         u2 = User.objects.create()\n         self.assertNumQueries(1, User.objects.filter(pk=u1.pk).delete)\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..2359558 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,9 +1,72 @@\n+\n+class MigrationAuthTests(TestCase):\n+    available_apps = [\n+        'auth_tests',\n+        'django.contrib.auth',\n+        'django.contrib.contenttypes',\n+    ]\n+    \n+    def test_migrate_with_existing_target_permission(self):\n+        \"\"\"\n+        Test migration when permissions already exist:\n+        \n+        - Simulates manually created permissions for proxy models.\n+        - Ensures it does not recreate already existing permissions.\n+        \n+        Outputs a reminder to audit relevant permissions if problems arise.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='display_proxys',\n+            name='May display proxys information',\n+        )\n+        with captured_stdout() as stdout:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        self.assertIn('A problem arose migrating proxy model permissions', stdout.getvalue())\n+    \n+    def test_no_duplicate_permission_creation(self):\n+        \"\"\"\n+        Test that existing permissions do not cause duplicates after migration.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        \n+        # Check initial permissions count to establish a baseline.\n+        initial_count = Permission.objects.filter(content_type=proxy_model_content_type).count()\n+\n+        # Run migration.\n+        update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+\n+        # Re-check permissions count. Should be unchanged.\n+        final_count = Permission.objects.filter(content_type=proxy_model_content_type).count()\n+        self.assertEqual(initial_count, final_count)\n+\n+    def test_proxy_permission_migration_reverts(self):\n+        \"\"\"\n+        Test that permissions are reverted correctly when rolling back migration.\n+        \"\"\"\n+        update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        update_proxy_permissions.revert_proxy_model_permissions(apps, None)\n+        \n+        # Capture the state after reverting to check consistency.\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        self.assertEqual(\n+            Permission.objects.filter(content_type=proxy_model_content_type).count(),\n+            Permission.objects.filter(content_type=ContentType.objects.get_for_model(Proxy, for_concrete_model=True)).count()\n+        )\n+\n from importlib import import_module\n \n from django.apps import apps\n from django.contrib.auth.models import Permission, User\n from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n+from django.test.utils import captured_stdout\n \n from .models import Proxy, UserProxy\n \n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..b4a9773 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -3,6 +3,10 @@ import os\n import py_compile\n import shutil\n import sys\n+import os\n+import sys\n+import shutil\n+import py_compile\n import tempfile\n import threading\n import time\n@@ -133,7 +137,24 @@ class TestIterModulesAndFiles(SimpleTestCase):\n         self.assertEqual(autoreload.iter_modules_and_files((module,), frozenset()), frozenset())\n \n \n-class TestCommonRoots(SimpleTestCase):\n+class TestManagePyReloader(SimpleTestCase):\n+    def setUp(self):\n+        self.manage_py = self.temporary_file('manage.py')\n+        self.manage_py.write_text(\"def main():\\n    print('original')\\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ticket_30479.settings')\")\n+\n+    def test_manage_py_triggers_reloader(self):\n+        \"\"\"\n+        Editing manage.py should trigger the autoreloader.\n+        \"\"\"\n+        with extend_sys_path(str(self.manage_py.parent)):\n+            import_module('manage')  # Assume initial import\n+            self.assertFileFound(self.manage_py)\n+\n+            # Simulating edit to manage.py\n+            self.manage_py.write_text(\"def main():\\n    print('updated')\\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ticket_30479.settings')\")\n+\n+            # Check if the file change is detected\n+            self.assertFileFound(self.manage_py)\n     def test_common_roots(self):\n         paths = (\n             Path('/first/second'),\n",
  "django__django-11583": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 99e5edd..273a485 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -153,6 +153,27 @@ class TestCommonRoots(SimpleTestCase):\n         self.assertCountEqual(results, [Path('/first/'), Path('/root/first/')])\n \n \n+class TestEmbeddedNullByteHandling(SimpleTestCase):\n+    def test_iter_modules_and_files_with_embedded_null_bytes(self):\n+        # Test for embedded null bytes in paths\n+        paths_with_null_bytes = [\n+            Path('embedded_null_byte\\x00.py'),\n+            Path('di\\x00rectory/embedded_null_byte.py'),\n+            Path('/invalid\\x00/path/with/null/byte'),\n+        ]\n+        for path in paths_with_null_bytes:\n+            with self.subTest(path=path):\n+                self.assertEqual(\n+                    autoreload.iter_modules_and_files((), frozenset([str(path)])),\n+                    frozenset()\n+                )\n+\n+    def test_handle_null_byte_gracefully(self):\n+        # Ensure the underlying system handles null bytes in file paths gracefully\n+        invalid_path = Path('some_path\\x00.py')\n+        with self.assertRaises(ValueError):\n+            invalid_path.resolve(strict=True)\n+\n class TestSysPathDirectories(SimpleTestCase):\n     def setUp(self):\n         self._directory = tempfile.TemporaryDirectory()\n",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..05cf956 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1,5 +1,31 @@\n import importlib\n import inspect\n+class CustomConverter(IntConverter):\n+    def to_python(self, value):\n+        raise Http404\n+\n+\n+def custom_view(request, param):\n+    return Http404\n+\n+\n+urlpatterns = [\n+    path('path-converter/<int:param>/', custom_view),\n+    re_path(r'^path-custom/(?P<param>.+)/$', custom_view),\n+]\n+\n+\n+class TestCustomPathConverter(SimpleTestCase):\n+    def test_technical_404_converter_custom_raise_404(self):\n+        with mock.patch.object(CustomConverter, 'to_python', side_effect=Http404):\n+            response = self.client.get('/path-custom/abc/')\n+            self.assertContains(response, 'Page not found', status_code=404)\n+\n+    def test_technical_404_converter_int_converter(self):\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+            response = self.client.get('/path-converter/123/')\n+            self.assertContains(response, 'Page not found', status_code=404)\n+\n import os\n import re\n import sys\n@@ -8,6 +34,11 @@ import threading\n from io import StringIO\n from pathlib import Path\n from unittest import mock\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n+from django.urls import re_path\n+from django.test import SimpleTestCase\n+from django.urls import path\n \n from django.core import mail\n from django.core.files.uploadedfile import SimpleUploadedFile\n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..b129f9b 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -334,21 +334,45 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n-    @unittest.skipUnless(connection.vendor == 'mysql',\n-                         \"Test valid only for MySQL\")\n-    def test_too_long_char_field_under_mysql(self):\n-        from django.db.backends.mysql.validation import DatabaseValidation\n+    def test_choices_longer_than_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('ABC', 'Value Too Long!'),  # longest choice is 3 characters 'ABC'\n+                    ('OK', 'Good'),\n+                ]\n+            )\n \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value \"\n+                \"in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_nested_grouped_choices_longer_than_max_length(self):\n         class Model(models.Model):\n-            field = models.CharField(unique=True, max_length=256)\n+            field = models.CharField(\n+                max_length=5,\n+                choices=[\n+                    ('Grouped', [\n+                        ('Short', 'Shrt'),\n+                        ('WayLonger', 'Too Long!'),  # longest is 8 characters 'WayLonger'\n+                    ])\n+                ]\n+            )\n \n         field = Model._meta.get_field('field')\n-        validator = DatabaseValidation(connection=connection)\n-        self.assertEqual(validator.check_field(field), [\n+        self.assertEqual(field.check(), [\n             Error(\n-                'MySQL does not allow unique CharFields to have a max_length > 255.',\n+                \"'max_length' is too small to fit the longest value \"\n+                \"in 'choices' (8 characters).\",\n                 obj=field,\n-                id='mysql.E001',\n+                id='fields.E009',\n             )\n         ])\n \n",
  "django__django-11815": "",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..643ec67 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,5 +1,7 @@\n+\n import unittest\n from datetime import datetime\n+from unittest import mock\n \n from django.test import SimpleTestCase, ignore_warnings\n from django.utils.datastructures import MultiValueDict\n@@ -316,9 +318,30 @@ class HttpDateProcessingTests(unittest.TestCase):\n         parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n-    def test_parsing_rfc850(self):\n-        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n-        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850(self, mocked_datetime):\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+\n+        utcnow_1 = datetime(2019, 11, 6, 8, 49, 37)\n+        utcnow_2 = datetime(2020, 11, 6, 8, 49, 37)\n+        utcnow_3 = datetime(2048, 11, 6, 8, 49, 37)\n+\n+        tests = (\n+            (utcnow_1, 'Tuesday, 31-Dec-69 08:49:37 GMT', datetime(2069, 12, 31, 8, 49, 37)),\n+            (utcnow_1, 'Tuesday, 10-Nov-70 08:49:37 GMT', datetime(1970, 11, 10, 8, 49, 37)),\n+            (utcnow_1, 'Sunday, 06-Nov-94 08:49:37 GMT', datetime(1994, 11, 6, 8, 49, 37)),\n+            (utcnow_2, 'Wednesday, 31-Dec-70 08:49:37 GMT', datetime(2070, 12, 31, 8, 49, 37)),\n+            (utcnow_2, 'Friday, 31-Dec-71 08:49:37 GMT', datetime(1971, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Sunday, 31-Dec-00 08:49:37 GMT', datetime(2000, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Friday, 31-Dec-99 08:49:37 GMT', datetime(1999, 12, 31, 8, 49, 37)),\n+        )\n+\n+        for utcnow, rfc850str, expected_date in tests:\n+            with self.subTest(rfc850str=rfc850str):\n+                mocked_datetime.utcnow.return_value = utcnow\n+                parsed = parse_http_date(rfc850str)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n \n     def test_parsing_asctime(self):\n         parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..c749cf6 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -40,7 +40,35 @@ class Gender(models.TextChoices):\n     __empty__ = '(Undeclared)'\n \n \n-class ChoicesTests(SimpleTestCase):\n+from django.utils.translation import gettext_lazy as _\n+# Add the necessary imports for testing\n+from django.test import TestCase\n+\n+class MyChoice(models.TextChoices):\n+    FIRST_CHOICE = \"first\", _(\"The first choice\")\n+    SECOND_CHOICE = \"second\", _(\"The second choice\")\n+\n+class TestEnumBehavior(TestCase):\n+    def setUp(self):\n+        class MyObject(models.Model):\n+            my_str_value = models.CharField(max_length=10, choices=MyChoice.choices)\n+\n+        self.my_object = MyObject.objects.create(my_str_value=MyChoice.FIRST_CHOICE)\n+\n+    def test_created_object_is_str(self):\n+        my_object = self.my_object\n+        self.assertIsInstance(my_object.my_str_value, str)\n+        self.assertEqual(str(my_object.my_str_value), \"first\")\n+\n+    def test_retrieved_object_is_str(self):\n+        my_object = MyObject.objects.last()\n+        self.assertIsInstance(my_object.my_str_value, str)\n+        self.assertEqual(str(my_object.my_str_value), \"first\")\n+        \n+    def test_str_output_consistency(self):\n+        for choice in MyChoice:\n+            with self.subTest(choice=choice):\n+                self.assertEqual(str(choice.value), choice)\n     def test_integerchoices(self):\n         self.assertEqual(Suit.choices, [(1, 'Diamond'), (2, 'Spade'), (3, 'Heart'), (4, 'Club')])\n         self.assertEqual(Suit.labels, ['Diamond', 'Spade', 'Heart', 'Club'])\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..0673238 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -148,7 +148,19 @@ class ChoicesTests(SimpleTestCase):\n                 self.assertIsInstance(field.formfield(), forms.ChoiceField)\n \n \n-class GetFieldDisplayTests(SimpleTestCase):\n+from django.test import TestCase\n+from django.db import models\n+\n+class CustomGetFieldDisplayTests(TestCase):\n+    def test_overriding_get_field_display(self):\n+        class FooBar(models.Model):\n+            foo_bar = models.IntegerField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                return \"something\"\n+\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), \"something\")\n \n     def test_choices_and_field_display(self):\n         \"\"\"\n",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "diff --git a/tests/urlpatterns/tests.py b/tests/urlpatterns/tests.py\nindex 7b8648d..894a380 100644\n--- a/tests/urlpatterns/tests.py\n+++ b/tests/urlpatterns/tests.py\n@@ -73,7 +73,22 @@ class SimplifiedURLTests(SimpleTestCase):\n         self.assertEqual(match.url_name, 'inner-extra')\n         self.assertEqual(match.route, 'included_urls/extra/<extra>/')\n \n-    def test_path_lookup_with_empty_string_inclusion(self):\n+    def test_re_path_with_missing_optional_parameter_modules(self):\n+        # Simulate the scenario described in the issue, where the `format` parameter is optional.\n+        for url, expected_kwargs in [\n+            ('/module/', {'format': 'html'}),  # Default should apply when not specified.\n+            ('/module/html/', {'format': 'html'}),\n+            ('/module/json/', {'format': 'json'}),\n+            ('/module/xml/', {'format': 'xml'}),\n+        ]:\n+            with self.subTest(url=url):\n+                match = resolve(url)\n+                self.assertEqual(match.url_name, 'modules')\n+                self.assertEqual(match.kwargs, expected_kwargs)\n+                self.assertEqual(\n+                    match.route,\n+                    r'^module/(?P<format>(html|json|xml))?/?$'\n+                )\n         match = resolve('/more/99/')\n         self.assertEqual(match.url_name, 'inner-more')\n         self.assertEqual(match.route, r'^more/(?P<extra>\\w+)/$')\n",
  "django__django-12284": "",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..72a2d59 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,9 +1,10 @@\n+\n from django.core.checks import Error\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n     check_setting_languages, check_setting_languages_bidi,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, override_settings\n \n \n class TranslationCheckTests(SimpleTestCase):\n@@ -75,6 +76,22 @@ class TranslationCheckTests(SimpleTestCase):\n                     Error(msg % tag, id='translation.E003'),\n                 ])\n \n+    @override_settings(\n+        USE_I18N=True,\n+        LANGUAGES=[\n+            ('de', 'German'),  # provided base language\n+            ('es', 'Spanish'),\n+            ('fr', 'French'),\n+            ('en', 'English'),  # provided default language\n+        ]\n+    )\n+    def test_language_fallback_to_base_language(self):\n+        # Sublanguages should fall back to base languages without raising E004.\n+        for language_code in ['de-at', 'de-ch', 'de-li']:  # de (German) base is available\n+            with self.subTest(language_code=language_code):\n+                with self.settings(LANGUAGE_CODE=language_code):\n+                    self.assertEqual(check_language_settings_consistent(None), [])\n+\n     def test_inconsistent_language_settings(self):\n         msg = (\n             'You have provided a value for the LANGUAGE_CODE setting that is '\n",
  "django__django-12308": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex acbcf33..7095a60 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -176,6 +176,21 @@ class UtilsTests(SimpleTestCase):\n         display_value = display_for_field(None, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, self.empty_value)\n \n+    def test_json_display_for_field_readonly(self):\n+        # Tests specifically for readonly JSONField display issue\n+        tests = [\n+            ({'foo': 'bar'}, '{\"foo\": \"bar\"}'),\n+            ([1, 2, 3], '[1, 2, 3]'),\n+            ('simple string', '\"simple string\"'),\n+            ({\"tuple\": (1, 2)}, '{\"tuple\": [1, 2]}'),  # Converts tuples to lists in JSON\n+            ({\"none\": None}, '{\"none\": null}'),  # None should be null in JSON\n+            ({'a': datetime.datetime(2023, 10, 13, 12, 30)}, '{\"a\": \"2023-10-13T12:30:00\"}'),  # JSON serializes dates\n+        ]\n+        for value, expected_display in tests:\n+            with self.subTest(value=value):\n+                display_value = display_for_field(value, models.JSONField(), self.empty_value)\n+                self.assertEqual(display_value, expected_display)\n+\n     def test_number_formats_display_for_field(self):\n         display_value = display_for_field(12345.6789, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, '12345.6789')\n",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..c3d72e5 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,3 +1,60 @@\n+\n+class TestDeserializeDbFromString(SimpleTestCase):\n+    databases = {'default'}\n+\n+    def test_circular_reference(self):\n+        # deserialize_db_from_string() handles circular references.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj_ref\": 1, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get()\n+        obj_ref = ObjectReference.objects.get()\n+        self.assertEqual(obj.obj_ref, obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n+\n+class TestSerializedRollbackOrder(TransactionTestCase):\n+    databases = {'default'}\n+\n+    def test_foreign_key_order(self):\n+        # serialize_db_to_string() does not guarantee order based on foreign keys,\n+        # verify deserialization does not produce integrity errors.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 2,\n+                \"fields\": {\"obj\": 2}\n+            },\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 2,\n+                \"fields\": {\"obj_ref\": null, \"related_objects\": []}\n+            }\n+        ]\n+        \"\"\"\n+        with self.assertRaises(Object.DoesNotExist):\n+            ObjectReference.objects.get(pk=2)\n+\n+        connection.creation.deserialize_db_from_string(data)\n+\n+        obj = Object.objects.get(pk=2)\n+        obj_ref = ObjectReference.objects.get(pk=2)\n+\n+        self.assertIsNone(obj.obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n+\n import copy\n from unittest import mock\n \n@@ -5,7 +62,8 @@ from django.db import DEFAULT_DB_ALIAS, connection, connections\n from django.db.backends.base.creation import (\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, TransactionTestCase\n+from ..models import Object, ObjectReference\n \n \n def get_connection_copy():\n",
  "django__django-12497": "diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 057ec3a..6599846 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -159,7 +159,39 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n-    def test_relationship_model_with_foreign_key_to_wrong_model(self):\n+    def test_invalid_foreign_key_hint(self):\n+        \"\"\"\n+        Test that the system gives the correct hint regarding 'symmetrical' and 'through'\n+        with ManyToManyField instead of ForeignKey.\n+        \"\"\"\n+\n+        class Team(models.Model):\n+            field = models.ManyToManyField('Person', through='Relation')\n+\n+        class Person(models.Model):\n+            pass\n+\n+        class Relation(models.Model):\n+            person = models.ForeignKey(Person, models.CASCADE)\n+            first_team = models.ForeignKey(Team, models.CASCADE, related_name='first')\n+            second_team = models.ForeignKey(Team, models.CASCADE, related_name='second')\n+\n+        field = Team._meta.get_field('field')\n+        self.assertEqual(field.check(from_model=Team), [\n+            Error(\n+                \"The model is used as an intermediate model by \"\n+                \"'invalid_models_tests.Team.field', but it has more than one \"\n+                \"foreign key from 'Team', which is ambiguous. You must \"\n+                \"specify which foreign key Django should use via the \"\n+                \"through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"Relation\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n         class WrongModel(models.Model):\n             pass\n \n",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..20d3a1b 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1248,8 +1248,56 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleanse_setting('SETTING_NAME', initial),\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n-\n-    def test_request_meta_filtering(self):\n+    def test_cleanse_setting_recurses_in_list_tuples_deep(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            \"foo\": \"value\",\n+            \"secret\": \"value\",\n+            \"token\": \"value\",\n+            \"something\": [\n+                {\"foo\": \"value\"},\n+                {\"secret\": \"value\"},\n+                {\"token\": \"value\"},\n+            ],\n+            \"else\": [\n+                [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": \"value\"},\n+                    {\"token\": \"value\"},\n+                ],\n+                [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": \"value\"},\n+                    {\"token\": \"value\"},\n+                ],\n+            ]\n+        }\n+        cleansed = {\n+            \"foo\": \"value\",\n+            \"secret\": reporter_filter.cleansed_substitute,\n+            \"token\": reporter_filter.cleansed_substitute,\n+            \"something\": [\n+                {\"foo\": \"value\"},\n+                {\"secret\": reporter_filter.cleansed_substitute},\n+                {\"token\": reporter_filter.cleansed_substitute},\n+            ],\n+            \"else\": [\n+                [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": reporter_filter.cleansed_substitute},\n+                    {\"token\": reporter_filter.cleansed_substitute},\n+                ],\n+                [\n+                    {\"foo\": \"value\"},\n+                    {\"secret\": reporter_filter.cleansed_substitute},\n+                    {\"token\": reporter_filter.cleansed_substitute},\n+                ],\n+            ]\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('MY_SETTING', initial),\n+            cleansed,\n+        )\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n         self.assertEqual(\n",
  "django__django-12708": "",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..0f8423b 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -530,7 +530,28 @@ class DeletionTests(TestCase):\n         for k, v in existed_objs.items():\n             self.assertEqual(deleted_objs[k], v)\n \n-    def test_model_delete_returns_num_rows(self):\n+    def test_queryset_delete_zero_objects_with_fk(self):\n+        \"\"\"\n+        QuerySet.delete() should return a consistent tuple when zero objects\n+        are deleted, with models having foreign keys returning an empty dict.\n+        \"\"\"\n+        # Assuming there is a foreign key relation in HiddenUser relating to another model.\n+        self.assertEqual(\n+            HiddenUser.objects.filter(id=-1).delete(),\n+            (0, {})\n+        )\n+\n+    def test_queryset_delete_zero_objects_without_fk(self):\n+        \"\"\"\n+        QuerySet.delete() should return a consistent tuple when zero objects\n+        are deleted, with models having no foreign keys also returning a dict\n+        with model-label keys and zero value.\n+        \"\"\"\n+        # Assuming R is a model with no foreign key relations\n+        self.assertEqual(\n+            R.objects.filter(id=-1).delete(),\n+            (0, {R._meta.label: 0})\n+        )\n         \"\"\"\n         Model.delete() should return the number of deleted rows and a\n         dictionary with the number of deletions for each object type.\n",
  "django__django-12856": "",
  "django__django-12915": "diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex 72f5bd1..4759654 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -94,6 +94,37 @@ class ASGITest(SimpleTestCase):\n             ),\n         )\n         await communicator.send_input({'type': 'http.request'})\n+\n+    async def test_static_file_response_async(self):\n+        # Ensure the async handling of static files functions correctly.\n+        handler = ASGIStaticFilesHandler(ASGIHandler())\n+        request = self.async_request_factory.get('/static/file.txt')\n+\n+        # Read file contents.\n+        file_path = TEST_STATIC_ROOT / 'file.txt'\n+        with open(file_path, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+\n+        # Mock response\n+        response = await handler.get_response_async(request)\n+        response_content = response.content\n+\n+        # Perform assertions\n+        self.assertEqual(response.status_code, 200)\n+        self.assertEqual(response_content, test_file_contents)\n+        self.assertEqual(response['Content-Type'], 'text/plain')\n+        self.assertEqual(response['Content-Disposition'], 'inline; filename=\"file.txt\"')\n+\n+    async def test_static_file_not_found_async(self):\n+        # Ensure a 404 status when requesting a non-existent static file.\n+        handler = ASGIStaticFilesHandler(ASGIHandler())\n+        request = self.async_request_factory.get('/static/not-found.txt')\n+\n+        # Mock response\n+        response = await handler.get_response_async(request)\n+\n+        # Perform assertions\n+        self.assertEqual(response.status_code, 404)\n         response_start = await communicator.receive_output()\n         self.assertEqual(response_start['type'], 'http.response.start')\n         self.assertEqual(response_start['status'], 200)\n",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..a67b0d6 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -197,6 +197,13 @@ class TestUtilsText(SimpleTestCase):\n             ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True),\n             ('\u4f60\u597d', '\u4f60\u597d', True),\n             ('\u0130stanbul', 'istanbul', True),\n+            # Test for leading and trailing underscores and dashes\n+            ('___This is a test ---', 'this-is-a-test', False),\n+            ('--leading-dashes', 'leading-dashes', False),\n+            ('trailing-dashes--', 'trailing-dashes', False),\n+            ('__leading-underscores', 'leading-underscores', False),\n+            ('trailing-underscores__', 'trailing-underscores', False),\n+            ('__mixed__-dashes-and-underscores--', 'mixed-dashes-and-underscores', False),\n         )\n         for value, output, is_unicode in items:\n             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n",
  "django__django-13028": "",
  "django__django-13158": "",
  "django__django-13230": "",
  "django__django-13315": "",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex e39d03e..f8a7591 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -102,8 +102,78 @@ class BasicFieldTests(SimpleTestCase):\n         name, path, args, kwargs = Nested.Field().deconstruct()\n         self.assertEqual(path, 'model_fields.tests.Nested.Field')\n \n+from django.db import models\n+from django.test import SimpleTestCase\n+\n+class AbstractInheritedFieldsTests(SimpleTestCase):\n+    \n+    def test_abstract_inherited_fields_are_not_equal(self):\n+        \"\"\"Fields from distinct abstract models should not be considered equal\"\"\"\n+\n+        class BaseAbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class DerivedModel1(BaseAbstractModel):\n+            pass\n+\n+        class DerivedModel2(BaseAbstractModel):\n+            pass\n+\n+        base_field = BaseAbstractModel._meta.get_field('field')\n+        derived1_field = DerivedModel1._meta.get_field('field')\n+        derived2_field = DerivedModel2._meta.get_field('field')\n+\n+        self.assertNotEqual(base_field, derived1_field)\n+        self.assertNotEqual(derived1_field, derived2_field)\n+        self.assertNotEqual(base_field, derived2_field)\n+\n+    def test_abstract_inherited_fields_ordering(self):\n+        \"\"\"Order abstract fields correctly based on creation_order and model.\"\"\"\n+\n+        class BaseAbstractModel(models.Model):\n+            field = models.IntegerField()\n+            \n+            class Meta:\n+                abstract = True\n+\n+        class DerivedModel1(BaseAbstractModel):\n+            pass\n+\n+        class DerivedModel2(BaseAbstractModel):\n+            pass\n+\n+        base_field = BaseAbstractModel._meta.get_field('field')\n+        derived1_field = DerivedModel1._meta.get_field('field')\n+        derived2_field = DerivedModel2._meta.get_field('field')\n+\n+        self.assertLess(base_field, derived1_field)\n+        self.assertLess(derived1_field, derived2_field)\n+\n+    def test_abstract_inherited_fields_hashing(self):\n+        \"\"\"Ensure hashes differ for fields from different abstract model inheritance\"\"\"\n+\n+        class BaseAbstractModel(models.Model):\n+            field = models.IntegerField()\n+            \n+            class Meta:\n+                abstract = True\n+\n+        class DerivedModel1(BaseAbstractModel):\n+            pass\n+\n+        class DerivedModel2(BaseAbstractModel):\n+            pass\n+\n+        base_field_hash = hash(BaseAbstractModel._meta.get_field('field'))\n+        derived1_field_hash = hash(DerivedModel1._meta.get_field('field'))\n+        derived2_field_hash = hash(DerivedModel2._meta.get_field('field'))\n \n-class ChoicesTests(SimpleTestCase):\n+        self.assertNotEqual(base_field_hash, derived1_field_hash)\n+        self.assertNotEqual(derived1_field_hash, derived2_field_hash)\n+        self.assertNotEqual(base_field_hash, derived2_field_hash)\n \n     @classmethod\n     def setUpClass(cls):\n",
  "django__django-13447": "",
  "django__django-13551": "diff --git a/tests/auth_tests/models/__init__.py b/tests/auth_tests/models/__init__.py\nindex c6505e4..d1b0da6 100644\n--- a/tests/auth_tests/models/__init__.py\n+++ b/tests/auth_tests/models/__init__.py\n@@ -1,3 +1,4 @@\n+\n from .custom_permissions import CustomPermissionsUser\n from .custom_user import (\n     CustomUser, CustomUserWithoutIsActiveField, ExtensionUser,\n@@ -9,6 +10,7 @@ from .no_password import NoPasswordUser\n from .proxy import Proxy, UserProxy\n from .uuid_pk import UUIDUser\n from .with_foreign_key import CustomUserWithFK, Email\n+from .with_custom_email_field import CustomEmailField\n from .with_integer_username import IntegerUsernameUser\n from .with_last_login_attr import UserWithDisabledLastLoginField\n from .with_many_to_many import (\n@@ -22,4 +24,4 @@ __all__ = (\n     'IntegerUsernameUser', 'IsActiveTestUser1', 'MinimalUser',\n     'NoPasswordUser', 'Organization', 'Proxy', 'UUIDUser', 'UserProxy',\n     'UserWithDisabledLastLoginField',\n-)\n+)\n",
  "django__django-13590": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 0b4f73f..f87eacf 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import pickle\n import unittest\n@@ -6,6 +7,7 @@ from copy import deepcopy\n from decimal import Decimal\n from unittest import mock\n \n+from collections import namedtuple\n from django.core.exceptions import FieldError\n from django.db import DatabaseError, NotSupportedError, connection\n from django.db.models import (\n@@ -875,6 +877,30 @@ class IterableLookupInnerExpressionsTests(TestCase):\n             ['<Company: 5020 Ltd>', '<Company: 5040 Ltd>', '<Company: 5050 Ltd>', '<Company: 5060 Ltd>'],\n             ordered=False\n         )\n+\n+    def test_namedtuple_with_range_lookup(self):\n+        \"\"\"\n+        Test the usage of namedtuple as an argument to __range in filter.\n+        This aims to validate that the previously mentioned issue is fixed.\n+        \"\"\"\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        # Test with a namedtuple that should match a record\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=51, maximum=100),\n+        )\n+        self.assertQuerysetEqual(qs, ['<Company: 99300 Ltd>'], ordered=False)\n+\n+        # Test with a namedtuple that should not match any record\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=101, maximum=200),\n+        )\n+        self.assertQuerysetEqual(qs, [])\n+\n+        # Test if reversing the range also returns no results\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=100, maximum=51),\n+        )\n+        self.assertQuerysetEqual(qs, [])\n         self.assertQuerysetEqual(\n             Company.objects.filter(num_employees__range=(1, 100)),\n             [\n@@ -884,6 +910,30 @@ class IterableLookupInnerExpressionsTests(TestCase):\n             ordered=False\n         )\n \n+    def test_namedtuple_with_range_lookup(self):\n+        \"\"\"\n+        Test the usage of namedtuple as an argument to __range in filter.\n+        This aims to validate that the previously mentioned issue is fixed.\n+        \"\"\"\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        # Test with a namedtuple that should match a record\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=51, maximum=100),\n+        )\n+        self.assertQuerysetEqual(qs, ['<Company: 99300 Ltd>'], ordered=False)\n+\n+        # Test with a namedtuple that should not match any record\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=101, maximum=200),\n+        )\n+        self.assertQuerysetEqual(qs, [])\n+\n+        # Test if reversing the range also returns no results\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=100, maximum=51),\n+        )\n+        self.assertQuerysetEqual(qs, [])\n+\n     @unittest.skipUnless(connection.vendor == 'sqlite',\n                          \"This defensive test only works on databases that don't validate parameter types\")\n     def test_complex_expressions_do_not_introduce_sql_injection_via_untrusted_string_inclusion(self):\n",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..ffb980d 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -28,6 +28,8 @@ from django.core.management.commands.testserver import (\n )\n from django.db import ConnectionHandler, connection\n from django.db.migrations.recorder import MigrationRecorder\n+from unittest import mock\n+from django.test.utils import captured_stderr, captured_stdout\n from django.test import (\n     LiveServerTestCase, SimpleTestCase, TestCase, override_settings,\n )\n",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..ff00076 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,3 +1,4 @@\n+\n import sys\n import unittest\n from unittest import mock\n@@ -29,15 +30,93 @@ class ShellCommandTestCase(SimpleTestCase):\n             stdin.seek(0)\n             call_command('shell')\n         self.assertEqual(stdout.getvalue().strip(), '100')\n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n+\n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n \n-    @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n     @mock.patch.dict('sys.modules', {'IPython': None})\n     def test_shell_with_ipython_not_installed(self, select):\n         select.return_value = ([], [], [])\n         with self.assertRaisesMessage(CommandError, \"Couldn't import ipython interface.\"):\n             call_command('shell', interface='ipython')\n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n \n-    @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n     @mock.patch.dict('sys.modules', {'bpython': None})\n     def test_shell_with_bpython_not_installed(self, select):\n         select.return_value = ([], [], [])\n@@ -49,4 +128,4 @@ class ShellCommandTestCase(SimpleTestCase):\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 2d83d62..bfb79bb 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -1013,7 +1013,31 @@ class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n         self.assertContains(response, 'Add another Model with both - name')\n         self.assertNotContains(response, '<h2>Model with both - plural name</h2>')\n \n-    def test_both_verbose_names_inline(self):\n+    def test_inline_default_verbose_name_plural(self):\n+        class InlineWithoutVerboseNamePlural(TabularInline):\n+            model = VerboseNameProfile\n+            verbose_name = 'Custom Inline Verbose Name'\n+\n+        class InlineWithOnlyVerboseName(TabularInline):\n+            model = VerboseNameProfile\n+            verbose_name = 'Single Verbose'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [\n+            InlineWithoutVerboseNamePlural,\n+            InlineWithOnlyVerboseName,\n+        ]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Inline without explicit verbose_name_plural, should use verbose_name.\n+        self.assertContains(response, '<h2>Custom Inline Verbose Names</h2>')\n+\n+        # Inline with only verbose_name, should default plural based on that.\n+        self.assertContains(response, '<h2>Single Verboses</h2>')\n         class NonVerboseProfileInline(TabularInline):\n             model = Profile\n             verbose_name = 'Non-verbose childs - name'\n",
  "django__django-13757": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex f53ff8c..6585d3b 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -596,6 +596,15 @@ class TestQuerying(TestCase):\n         )\n \n     def test_isnull_key_or_none(self):\n+        # Test to ensure objects with JSON null value should not match when using __isnull=True on SQLite and Oracle\n+        # Since this tests primarily for SQLite and Oracle behavior, it's useful to verify JSON null handling\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],\n+        )\n+        \n+        # Since self.objs[j] and self.objs[k] are ambiguous in the context,\n+        # make sure to customize the expected outputs if needed based on the setup data.\n         obj = NullableJSONModel.objects.create(value={'a': None})\n         self.assertSequenceEqual(\n             NullableJSONModel.objects.filter(Q(value__a__isnull=True) | Q(value__a=None)),\n",
  "django__django-13768": "diff --git a/tests/dispatch/tests.py b/tests/dispatch/tests.py\nindex b1feefd..4409ca0 100644\n--- a/tests/dispatch/tests.py\n+++ b/tests/dispatch/tests.py\n@@ -165,12 +165,27 @@ class DispatcherTests(SimpleTestCase):\n         def fails(val, **kwargs):\n             raise ValueError('this')\n         a_signal.connect(fails)\n-        result = a_signal.send_robust(sender=self, val=\"test\")\n+\n+        with self.assertLogs('django.dispatch', 'ERROR') as cm:\n+            result = a_signal.send_robust(sender=self, val=\"test\")\n+        \n         err = result[0][1]\n         self.assertIsInstance(err, ValueError)\n         self.assertEqual(err.args, ('this',))\n         self.assertTrue(hasattr(err, '__traceback__'))\n         self.assertIsInstance(err.__traceback__, TracebackType)\n+\n+        # Verify that the log message is captured\n+        log_record = cm.records[0]\n+        self.assertEqual(\n+            log_record.getMessage(),\n+            'Error calling fails in Signal.send_robust() (this)',\n+        )\n+        self.assertIsNotNone(log_record.exc_info)\n+        _, exc_value, _ = log_record.exc_info\n+        self.assertIsInstance(exc_value, ValueError)\n+        self.assertEqual(str(exc_value), 'this')\n+\n         a_signal.disconnect(fails)\n         self.assertTestIsClean(a_signal)\n \n",
  "django__django-13925": "",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..f3632d9 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -281,6 +281,19 @@ class FormsErrorMessagesTestCase(SimpleTestCase, AssertFormErrorsMixin):\n             '</ul></li></ul>'\n         )\n \n+from django.test import TestCase\n+from django.forms import ModelChoiceField, ModelMultipleChoiceField\n+from .models import ChoiceModel\n+\n+class AssertFormErrorsMixin:\n+    def assertFormErrors(self, expected_errors, callable_obj, *args, **kwargs):\n+        try:\n+            callable_obj(*args, **kwargs)\n+        except Exception as e:\n+            assert hasattr(e, 'messages')\n+            assert e.messages == expected_errors\n+        else:\n+            assert False, 'ValidationError not raised'\n \n class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n     def test_modelchoicefield(self):\n@@ -297,8 +310,18 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['INVALID CHOICE'], f.clean, '4')\n-\n-        # ModelMultipleChoiceField\n+    def test_modelchoicefield_value_placeholder(self):\n+        f = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            },\n+        )\n+        self.assertFormErrors(\n+            ['\"invalid\" is not one of the available choices.'],\n+            f.clean,\n+            'invalid',\n+        )\n         e = {\n             'required': 'REQUIRED',\n             'invalid_choice': '%(value)s IS INVALID CHOICE',\n@@ -307,4 +330,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "diff --git a/tests/many_to_one/models.py b/tests/many_to_one/models.py\nindex 1078928..177e544 100644\n--- a/tests/many_to_one/models.py\n+++ b/tests/many_to_one/models.py\n@@ -81,6 +81,13 @@ class ToFieldChild(models.Model):\n     parent = models.ForeignKey(Parent, models.CASCADE, to_field='name', related_name='to_field_children')\n \n \n+class ParentStringPrimaryKey(models.Model):\n+    name = models.CharField(primary_key=True, max_length=15)\n+\n+\n+class ChildStringPrimaryKeyParent(models.Model):\n+    parent = models.ForeignKey(ParentStringPrimaryKey, on_delete=models.CASCADE)\n+\n # Multiple paths to the same model (#7110, #7125)\n class Category(models.Model):\n     name = models.CharField(max_length=20)\n",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..f58da7e 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,9 +1,23 @@\n+\n from django.db.models import F, Q\n from django.test import SimpleTestCase\n \n \n class QTests(SimpleTestCase):\n-    def test_combine_and_empty(self):\n+    def test_dict_keys_handling(self):\n+        q = Q(x__in={}.keys())\n+        # Test combining with AND and OR operators\n+        self.assertEqual(q & Q(), q)\n+        self.assertEqual(Q() & q, q)\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n+\n+        # Test the issue specifically with the | operator as described\n+        try:\n+            result = Q() | Q(x__in={}.keys())\n+            self.assertEqual(result, q)\n+        except TypeError:\n+            self.fail(\"TypeError: cannot pickle 'dict_keys' object\")\n         q = Q(x=1)\n         self.assertEqual(q & Q(), q)\n         self.assertEqual(Q() & q, q)\n",
  "django__django-14017": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 707f339..32cb99b 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -25,6 +25,7 @@ from django.db.models.functions import (\n from django.db.models.sql import constants\n from django.db.models.sql.datastructures import Join\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n+from django.db.models import Q, Exists, BooleanField, OuterRef\n from django.test.utils import (\n     Approximate, CaptureQueriesContext, isolate_apps, register_lookup,\n )\n@@ -790,8 +791,28 @@ class BasicExpressionsTests(TestCase):\n                 When(Exists(is_poc), then=True),\n                 default=False,\n                 output_field=BooleanField(),\n-            ),\n+            ),  \n         )\n+      \n+    def test_issue_q_exists_commutativity(self):\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        self.example_inc.ceo = self.max\n+        self.example_inc.save()\n+\n+        test_cases = [\n+            (Exists(is_ceo) & Q(), [self.max]),\n+            (Q() & Exists(is_ceo), [self.max]),\n+            (Exists(is_poc) | Q(), [self.example_inc.ceo, self.max]),\n+            (Q() | Exists(is_poc), [self.example_inc.ceo, self.max]),\n+        ]\n+\n+        for conditions, expected in test_cases:\n+            with self.subTest(conditions=conditions):\n+                self.assertCountEqual(\n+                    Employee.objects.filter(conditions),\n+                    expected,\n+                )\n         self.assertCountEqual(qs, [self.example_inc.ceo, self.foobar_ltd.ceo, self.max])\n \n     def test_boolean_expression_combined(self):\n",
  "django__django-14155": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 0f968fa..63f0494 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1146,6 +1146,11 @@ class ResolverMatchTests(SimpleTestCase):\n         )\n \n \n+import functools\n+from django import views\n+from django.urls import resolve\n+from django.test import SimpleTestCase, override_settings\n+\n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n class ErroneousViewTests(SimpleTestCase):\n \n",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..c94bb06 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,6 +1,8 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n+from .models import MyBigAutoField, MySmallAutoField\n from django.test.utils import isolate_apps\n \n \n@@ -65,8 +67,22 @@ class TestDefaultPK(SimpleTestCase):\n         with self.assertRaisesMessage(ImproperlyConfigured, msg):\n             class Model(models.Model):\n                 pass\n+    \n+    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n \n     @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n@@ -81,8 +97,22 @@ class TestDefaultPK(SimpleTestCase):\n             pass\n \n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n+    \n+    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n \n     @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_m2m_default_auto_field_setting(self):\n         class M2MModel(models.Model):\n",
  "django__django-14382": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex afeed3e..b7579dd 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2168,8 +2168,33 @@ class StartApp(AdminScriptTestCase):\n                     \"sure the name is a valid identifier.\".format(bad_name)\n                 )\n                 self.assertFalse(os.path.exists(testproject_dir))\n+    def test_trailing_slash_in_target_app_directory_name(self):\n+        app_dir = os.path.join(self.test_dir, 'apps', 'app1')\n+        os.makedirs(app_dir)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', 'app1', '')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n+\n+    def test_no_trailing_slash_in_target_app_directory_name(self):\n+        app_dir_no_slash = os.path.join(self.test_dir, 'apps', 'app2')\n+        os.makedirs(app_dir_no_slash)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', 'app2')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir_no_slash, 'apps.py')), True)\n \n-    def test_importable_name(self):\n+    def test_multiple_trailing_slashes_in_target_app_directory_name(self):\n+        app_dir_multi_slash = os.path.join(self.test_dir, 'apps', 'app3')\n+        os.makedirs(app_dir_multi_slash)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', 'app3', '//')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir_multi_slash, 'apps.py')), True)\n+\n+    def test_complex_path_with_trailing_slash_in_target_app_directory_name(self):\n+        complex_path = os.path.join(self.test_dir, 'complex/path/to/app4')\n+        os.makedirs(complex_path)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('complex', 'path', 'to', 'app4', '/')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(complex_path, 'apps.py')), True)\n         \"\"\"\n         startapp validates that app name doesn't clash with existing Python\n         modules.\n",
  "django__django-14411": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 331338c..904de6f 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -8,6 +8,7 @@ from django.contrib.auth.forms import (\n     SetPasswordForm, UserChangeForm, UserCreationForm,\n )\n from django.contrib.auth.models import User\n+from django.forms import forms\n from django.contrib.auth.signals import user_login_failed\n from django.contrib.sites.models import Site\n from django.core import mail\n@@ -1026,6 +1027,31 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n         self.assertFalse(field.has_changed('aaa', 'bbb'))\n \n \n+class ReadOnlyPasswordHashWidgetTest(TestCase):\n+    def test_label_without_for_attribute(self):\n+        \"\"\"\n+        Test that ReadOnlyPasswordHashWidget's label does not contain a 'for'\n+        attribute, as it does not have any labelable elements.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            hash_field = ReadOnlyPasswordHashField()\n+\n+        bound_field = TestForm()['hash_field']\n+        self.assertIsNone(bound_field.field.widget.id_for_label('id'))\n+        self.assertEqual(bound_field.label_tag(), '<label>Hash field:</label>')\n+\n+    def test_widget_render_plain_text(self):\n+        \"\"\"\n+        Ensure ReadOnlyPasswordHashWidget renders as plain text, confirming that\n+        it behaves correctly as a non-input widget.\n+        \"\"\"\n+        widget = ReadOnlyPasswordHashWidget()\n+        rendered = widget.render(name=\"password\", value=\"dummyhash\")\n+        self.assertIn(\"dummyhash\", rendered)\n+        self.assertNotIn(\"for=\", rendered)\n+        self.assertNotIn(\"id=\", rendered)\n+\n+\n class AdminPasswordChangeFormTest(TestDataMixin, TestCase):\n \n     @mock.patch('django.contrib.auth.password_validation.password_changed')\n",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..a9f5e0e 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -658,7 +658,48 @@ class WriterTests(SimpleTestCase):\n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n \n-    def test_simple_migration(self):\n+    def test_serialize_type_model(self):\n+        self.assertSerializedEqual(models.Model)\n+        self.assertSerializedResultEqual(\n+            MigrationWriter.serialize(models.Model),\n+            (\"('models.Model', {'from django.db import models'})\", set()),\n+        )\n+\n+    def test_mixed_inheritance_migration_imports(self):\n+        \"\"\"\n+        Test serializing a model with a mixin and an abstract base class\n+        requires the correct imports in migration.\n+        \"\"\"\n+        class MyMixin:\n+            pass\n+\n+        class MyField(models.TextField):\n+            pass\n+\n+        class MyAbstractBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        class MyModel(MyMixin, MyAbstractBaseModel):\n+            name = MyField(primary_key=True)\n+\n+        migration = migrations.CreateModel(\n+            name='MyModel',\n+            fields=[\n+                ('name', MyField(primary_key=True, serialize=False)),\n+            ],\n+            options={\n+                'abstract': False,\n+            },\n+            bases=(MyMixin, models.Model),\n+        )\n+\n+        writer = MigrationWriter(None)\n+        serialized_migration = writer.serialize(migration)\n+        \n+        self.assertIn(\"from django.db import models\", serialized_migration[0])\n+        self.assertIn(\"app.models.MyMixin\", serialized_migration[0])\n+        self.assertIn(\"app.models.MyField\", serialized_migration[0])\n         \"\"\"\n         Tests serializing a simple migration.\n         \"\"\"\n",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..4b5183d 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -337,6 +337,8 @@ class FormsFormsetTestCase(SimpleTestCase):\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['Please submit at most 1 form.'])\n+        # Additional check for the nonform CSS class\n+        self.assertIn('nonform', formset.non_form_errors().as_ul())\n \n     def test_formset_validate_min_flag(self):\n         \"\"\"\n@@ -359,6 +361,8 @@ class FormsFormsetTestCase(SimpleTestCase):\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['Please submit at least 3 forms.'])\n+        # Additional check for the nonform CSS class\n+        self.assertIn('nonform', formset.non_form_errors().as_ul())\n \n     def test_formset_validate_min_unchanged_forms(self):\n         \"\"\"\n@@ -983,6 +987,8 @@ class FormsFormsetTestCase(SimpleTestCase):\n         formset = FavoriteDrinksFormSet(data, prefix='drinks')\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n+        # Additional check for the nonform CSS class\n+        self.assertIn('nonform', formset.non_form_errors().as_ul())\n \n     def test_formset_iteration(self):\n         \"\"\"Formset instances are iterable.\"\"\"\n",
  "django__django-14672": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex d9eaabe..d391523 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -11,6 +11,9 @@ from .models import (\n )\n \n \n+from django.test import TestCase\n+from .models import Person, PersonChild, Event, Invitation, Relationship, SymmetricalFriendship\n+\n class M2mThroughTests(TestCase):\n     @classmethod\n     def setUpTestData(cls):\n@@ -31,6 +34,13 @@ class M2mThroughTests(TestCase):\n             attrgetter(\"name\")\n         )\n \n+    def test_reverse_inherited_m2m_with_through_fields_list_hashable(self):\n+        reverse_m2m = Person._meta.get_field('events_invited')\n+        self.assertEqual(reverse_m2m.through_fields, ['event', 'invitee'])\n+        inherited_reverse_m2m = PersonChild._meta.get_field('events_invited')\n+        self.assertEqual(inherited_reverse_m2m.through_fields, ['event', 'invitee'])\n+        self.assertEqual(hash(reverse_m2m), hash(inherited_reverse_m2m))\n+\n     def test_get_on_intermediate_model(self):\n         Membership.objects.create(person=self.jane, group=self.rock)\n \n",
  "django__django-14752": "",
  "django__django-14787": "diff --git a/tests/decorators/tests.py b/tests/decorators/tests.py\nindex 5ea3da6..369d25b 100644\n--- a/tests/decorators/tests.py\n+++ b/tests/decorators/tests.py\n@@ -426,7 +426,37 @@ class MethodDecoratorTests(SimpleTestCase):\n                     return \"tests\"\n \n \n-class XFrameOptionsDecoratorsTests(TestCase):\n+class MethodDecoratorTests(TestCase):\n+    def test_wrapper_assignments_for_partial(self):\n+        \"\"\"@method_decorator can handle functools.partial objects\"\"\"\n+        func_name = None\n+        func_module = None\n+\n+        def decorator(func):\n+            @wraps(func)\n+            def inner(*args, **kwargs):\n+                nonlocal func_name, func_module\n+                func_name = getattr(func, '__name__', None)\n+                func_module = getattr(func, '__module__', None)\n+                return func(*args, **kwargs)\n+            return inner\n+\n+        @method_decorator(decorator)\n+        def method_to_decorate():\n+            return \"testing\"\n+\n+        # Create a partial object\n+        partial_method = partial(method_to_decorate)\n+\n+        # Assign the decorator to the partial object\n+        decorated_partial_method = decorator(partial_method)\n+\n+        # Call the decorated partial method\n+        decorated_partial_method()\n+\n+        # Assertions\n+        self.assertEqual(func_name, 'method_to_decorate')\n+        self.assertIsNotNone(func_module)\n     \"\"\"\n     Tests for the X-Frame-Options decorators.\n     \"\"\"\n",
  "django__django-14855": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 507855b..644e93d 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -5083,6 +5083,27 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase):\n     def test_user_password_change_limited_queryset(self):\n         su = User.objects.filter(is_superuser=True)[0]\n         response = self.client.get(reverse('admin2:auth_user_password_change', args=(su.pk,)))\n+\n+    def test_readonly_foreignkey_links_custom_admin_site(self):\n+        \"\"\"\n+        Test that ForeignKey readonly fields have links with the correct URL paths in a custom admin site.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter 2',\n+            content='content 2',\n+            book=Book.objects.create(name='Book 2'),\n+        )\n+        language = Language.objects.create(iso='en', name='Custom Admin Test')\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+            language=language,\n+            user=self.superuser,\n+        )\n+        # Testing for custom admin site\n+        response = self.client.get(\n+            reverse('site2:admin_views_readonlyrelatedfield_change', args=(obj.pk,))\n+        )\n+        self.assertContains(response, '/site2/', msg_prefix=\"Readonly ForeignKey field should use custom admin URL.\")\n         self.assertEqual(response.status_code, 404)\n \n     def test_change_form_renders_correct_null_choice_value(self):\n",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..350b8cc 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,10 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n+import json\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n",
  "django__django-14999": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 3e4c6c7..462b634 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -793,7 +793,55 @@ class OperationTests(OperationTestBase):\n         self.assertEqual(Rider.objects.count(), 2)\n         self.assertEqual(Pony._meta.get_field('riders').remote_field.through.objects.count(), 2)\n \n-    def test_rename_m2m_target_model(self):\n+    def test_rename_model_with_db_table_noop_postgres(self):\n+        if connection.vendor != 'postgresql':\n+            self.skipTest(\"This test is specific to PostgreSQL behavior.\")\n+        \n+        app_label = 'test_rmwdbtn_postgres'\n+        project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+            migrations.CreateModel('Rider', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+            ], options={'db_table': 'rider'}),\n+            migrations.CreateModel('Pony', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+            ]),\n+        ])\n+        new_state = project_state.clone()\n+        operation = migrations.RenameModel('Rider', 'Runner')\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            with self.assertNumQueries(0):\n+                operation.database_forwards(app_label, editor, project_state, new_state)\n+        with connection.schema_editor() as editor:\n+            with self.assertNumQueries(0):\n+                operation.database_backwards(app_label, editor, new_state, project_state)\n+        \n+    def test_rename_model_with_db_table_noop_sqlite(self):\n+        if connection.vendor != 'sqlite':\n+            self.skipTest(\"This test is specific to SQLite behavior.\")\n+        \n+        app_label = 'test_rmwdbtn_sqlite'\n+        project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+            migrations.CreateModel('Rider', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+            ], options={'db_table': 'rider'}),\n+            migrations.CreateModel('Pony', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+            ]),\n+        ])\n+        new_state = project_state.clone()\n+        operation = migrations.RenameModel('Rider', 'Runner')\n+        operation.state_forwards(app_label, new_state)\n+\n+        with connection.schema_editor() as editor:\n+            with self.assertNumQueries(0):\n+                operation.database_forwards(app_label, editor, project_state, new_state)\n+        with connection.schema_editor() as editor:\n+            with self.assertNumQueries(0):\n+                operation.database_backwards(app_label, editor, new_state, project_state)\n         app_label = \"test_rename_m2m_target_model\"\n         project_state = self.apply_operations(app_label, ProjectState(), operations=[\n             migrations.CreateModel(\"Rider\", fields=[\n",
  "django__django-15061": "diff --git a/tests/forms_tests/field_tests/test_multivaluefield.py b/tests/forms_tests/field_tests/test_multivaluefield.py\nindex 53aee21..478645c 100644\n--- a/tests/forms_tests/field_tests/test_multivaluefield.py\n+++ b/tests/forms_tests/field_tests/test_multivaluefield.py\n@@ -154,7 +154,19 @@ class MultiValueFieldTest(SimpleTestCase):\n             \"\"\",\n         )\n \n-    def test_form_as_table_data(self):\n+    def test_multivalue_widget_label(self):\n+        class MultiValueForm(Form):\n+            field = SplitDateTimeField()\n+\n+        form = MultiValueForm()\n+        self.assertHTMLEqual(\n+            form.as_table(),\n+            \"\"\"\n+            <tr><th><label>Field:</label></th>\n+            <td><input type=\"text\" name=\"field_0\" id=\"id_field_0\" required>\n+            <input type=\"text\" name=\"field_1\" id=\"id_field_1\" required></td></tr>\n+            \"\"\",\n+        )\n         form = ComplexFieldForm({\n             'field1_0': 'some text',\n             'field1_1': ['J', 'P'],\n",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..a0eacb1 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -70,6 +70,11 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # IPv6.\n             ('http://[12:34::3a53]/', 'http://[12:34::3a53]/'),\n             ('http://[a34:9238::]:8080/', 'http://[a34:9238::]:8080/'),\n+            # Edge case for testing IPv6 URL parsing error\n+            '////]@N.AN',\n+            # Additional similar edge cases\n+            '#@A.bO',\n+            'http://example[12::3a53]',\n         ]\n         for url, expected in tests:\n             with self.subTest(url=url):\n@@ -100,6 +105,11 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # even on domains that don't fail the domain label length check in\n             # the regex.\n             'http://%s' % (\"X\" * 200,),\n+            # Edge case for testing IPv6 URL parsing error\n+            '////]@N.AN',\n+            # Additional similar edge cases\n+            '#@A.bO',\n+            'http://example[12::3a53]',\n         ]\n         msg = \"'Enter a valid URL.'\"\n         for value in tests:\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..aaf9994 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -262,7 +262,27 @@ class NonAggregateAnnotationTestCase(TestCase):\n             {'under_40': True, 'count_id': 6},\n         ])\n \n-    def test_aggregate_over_annotation(self):\n+    def test_full_expression_annotation(self):\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    @skipUnlessDBFeature('supports_boolean_expr_in_select_clause')\n+    def test_full_expression_annotation_with_aggregation(self):\n+        qs = Book.objects.filter(isbn='159059725').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in qs], [1])\n+\n+    @skipUnlessDBFeature('supports_boolean_expr_in_select_clause')\n+    def test_aggregate_over_full_expression_annotation(self):\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         agg = Author.objects.annotate(other_age=F('age')).aggregate(otherage_sum=Sum('other_age'))\n         other_agg = Author.objects.aggregate(age_sum=Sum('age'))\n         self.assertEqual(agg['otherage_sum'], other_agg['age_sum'])\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..4beb465 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,4 @@\n+\n import json\n import random\n \n@@ -143,7 +144,30 @@ class CookieTests(BaseTests, SimpleTestCase):\n         for illegal in non_compliant_chars:\n             self.assertEqual(encoded.find(illegal), -1)\n \n-    def test_json_encoder_decoder(self):\n+    def test_extra_tags_preservation(self):\n+        \"\"\"\n+        Test that extra_tags are correctly preserved after encoding and decoding.\n+        \"\"\"\n+        storage = self.get_storage()\n+\n+        # Define test cases for various extra_tags scenarios\n+        test_cases = [\n+            (\"\", \"extra_tags should remain an empty string\"),\n+            (None, \"extra_tags should remain None\"),\n+            (\"some tags\", \"extra_tags should remain 'some tags'\"),\n+        ]\n+\n+        for extra_tags_value, description in test_cases:\n+            with self.subTest(extra_tags=extra_tags_value):\n+                # Create a message with the given extra_tags\n+                message = Message(constants.DEBUG, \"Test message\", extra_tags=extra_tags_value)\n+                \n+                # Encode and decode the message\n+                encoded = storage._encode(message)\n+                decoded_message = storage._decode(encoded)\n+\n+                # Check if the extra_tags are preserved\n+                self.assertEqual(decoded_message.extra_tags, extra_tags_value, description)\n         \"\"\"\n         A complex nested data structure containing Message\n         instances is properly encoded/decoded by the custom JSON\n",
  "django__django-15388": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex 42ab5ba..fade419 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -1,5 +1,8 @@\n from pathlib import Path\n+import os\n from unittest import mock\n+from pathlib import Path\n+from django.core.management import call_command\n \n from django.template import autoreload\n from django.test import SimpleTestCase, override_settings\n@@ -59,7 +62,31 @@ class TemplateReloadTests(SimpleTestCase):\n             }\n         )\n \n-    @mock.patch('django.template.loaders.base.Loader.reset')\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    def test_dev_server_restarts_with_base_dir_in_dirs(self, mock_reset):\n+        # Simulate the setup with BASE_DIR in TEMPLATES[0]['DIRS']\n+        with override_settings(\n+            TEMPLATES=[{\n+                'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+                'DIRS': [str(ROOT)],\n+            }]\n+        ):\n+            # Simulate file change and check if reset_loaders is called\n+            self.assertTrue(autoreload.template_changed(None, Path(__file__)))\n+            mock_reset.assert_called_once()\n+\n+    def test_dev_server_manual_restart_required_without_base_dir(self):\n+        # Simulate the setup without BASE_DIR in TEMPLATES[0]['DIRS']\n+        with override_settings(\n+            TEMPLATES=[{\n+                'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+                'DIRS': [],\n+            }]\n+        ):\n+            mock_reloader = mock.MagicMock()\n+            # Simulate file change, and expect no automatic restart\n+            autoreload.watch_for_template_changes(mock_reloader)\n+            self.assertFalse(autoreload.template_changed(None, Path(__file__)))\n     def test_reset_all_loaders(self, mock_reset):\n         autoreload.reset_loaders()\n         self.assertEqual(mock_reset.call_count, 2)\n",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..0b65578 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -184,7 +185,35 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n-    def test_was_modified_since_fp(self):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"Test handling of empty string as If-Modified-Since header.\"\"\"\n+        # Since the fix, an empty string should not raise an exception.\n+        # Assuming...\n+        self.assertTrue(was_modified_since(header=\"\", mtime=1))\n+    \n+    def test_was_modified_since_no_header(self):\n+        \"\"\"Test handling of no If-Modified-Since header.\"\"\"\n+        # No header should be handled and return True indicating the resource is modified.\n+        self.assertTrue(was_modified_since(None, 1))\n+\n+    def test_was_modified_since_invalid_date(self):\n+        \"\"\"Test handling of invalid date string in the If-Modified-Since header.\"\"\"\n+        # An invalid date header should not cause an exception, should assume modified.\n+        self.assertTrue(was_modified_since(\"not-a-date\", 1))\n+\n+    def test_was_modified_since_valid_date_greater_than_mtime(self):\n+        \"\"\"Test valid date string newer than mtime.\"\"\"\n+        # If the date in the header is newer, the response should be not modified.\n+        valid_newer_date = http_date(1343416142)  # Assuming mtime < this date\n+        mtime = 1343416141\n+        self.assertFalse(was_modified_since(valid_newer_date, mtime))\n+\n+    def test_was_modified_since_valid_date_older_than_mtime(self):\n+        \"\"\"Test valid date string older than mtime.\"\"\"\n+        # If the date in the header is older, the response should be modified.\n+        valid_older_date = http_date(1343416140)  # Assuming this date < mtime\n+        mtime = 1343416141\n+        self.assertTrue(was_modified_since(valid_older_date, mtime))\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n         \"\"\"\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..d681311 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,3 +1,4 @@\n+\n import os\n from io import StringIO\n from unittest import mock\n@@ -8,6 +9,8 @@ from django.apps import apps\n from django.core import management\n from django.core.checks import Tags\n from django.core.management import BaseCommand, CommandError, find_commands\n+from argparse import ArgumentDefaultsHelpFormatter\n+from django.core.management.base import CommandParser\n from django.core.management.utils import (\n     find_command,\n     get_random_secret_key,\n@@ -411,7 +414,35 @@ class CommandTests(SimpleTestCase):\n         parser = BaseCommand().create_parser(\"prog_name\", \"subcommand\", epilog=epilog)\n         self.assertEqual(parser.epilog, epilog)\n \n-    def test_outputwrapper_flush(self):\n+    def test_custom_formatter_on_create_parser(self):\n+        \"\"\"Test if a custom formatter class can be set in create_parser.\"\"\"\n+        epilog = \"Test epilog\"\n+        parser = BaseCommand().create_parser(\n+            \"prog_name\",\n+            \"subcommand\",\n+            epilog=epilog,\n+            formatter_class=ArgumentDefaultsHelpFormatter,\n+        )\n+        self.assertEqual(parser.formatter_class, ArgumentDefaultsHelpFormatter)\n+\n+    def test_example_usage_formatting(self):\n+        \"\"\"Test if the example usage text is correctly formatted in the help output.\"\"\"\n+        class ExampleCommand(BaseCommand):\n+            help = (\n+                \"Import a contract from tzkt\\n\"\n+                \"Example usage:\\n\"\n+                \"\\t./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\"\n+            )\n+\n+        command = ExampleCommand()\n+        parser = command.create_parser(\"manage.py\", \"tzkt_import\")\n+        with mock.patch('sys.stdout', new=StringIO()) as stdout:\n+            parser.print_help()\n+            output = stdout.getvalue()\n+        self.assertIn(\n+            \"Example usage:\\n\\t./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\",\n+            output\n+        )\n         out = StringIO()\n         with mock.patch.object(out, \"flush\") as mocked_flush:\n             management.call_command(\"outputwrapper\", stdout=out)\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..e1d2bca 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,7 +1,10 @@\n+\n import os\n from datetime import datetime\n \n from django.test import SimpleTestCase\n+from django.core.serializers.json import DjangoJSONEncoder\n+import json\n from django.utils.functional import lazystr\n from django.utils.html import (\n     conditional_escape,\n@@ -211,6 +214,18 @@ class TestUtilsHtml(SimpleTestCase):\n             with self.subTest(arg=arg):\n                 self.assertEqual(json_script(arg, \"test_id\"), expected)\n \n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                # Custom encode method that returns a fixed JSON string\n+                return '{\"custom\": \"value\"}'\n+\n+        # Test that json_script uses the custom encoder\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"custom\": \"value\"}</script>',\n+        )\n+\n     def test_json_script_without_id(self):\n         self.assertHTMLEqual(\n             json_script({\"key\": \"value\"}),\n",
  "django__django-15790": "",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..6de6874 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -382,7 +382,21 @@ class ProxyModelTests(TestCase):\n             repr(resp), \"<ProxyImprovement: ProxyImprovement:improve that>\"\n         )\n \n-        # Select related + filter on a related proxy of proxy field\n+from django.test import TestCase\n+from .models import CustomModel, ProxyCustomModel, AnotherModel\n+\n+class ProxyModelTests(TestCase):\n+    def setUp(self):\n+        self.custom = ProxyCustomModel.objects.create(name=\"Proxy\")\n+\n+    def test_select_related_only_proxy_model(self):\n+        another_object = AnotherModel.objects.create(custom=self.custom)\n+        \n+        # Test that select_related and only work together on proxy models\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+        result = qs.get()\n+        self.assertEqual(result, another_object)\n+        self.assertEqual(result.custom.name, \"Proxy\")\n         resp = ProxyImprovement.objects.select_related().get(\n             associated_bug__summary__icontains=\"fix\"\n         )\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..2ca7f82 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -156,8 +156,22 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n             ([\"psql\", \"dbname\", \"--help\"], None),\n         )\n-\n-    @skipUnless(connection.vendor == \"postgresql\", \"Requires a PostgreSQL connection\")\n+    \n+    def test_parameters_ordering(self):\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env(\n+                {\n+                    \"NAME\": \"dbname\",\n+                    \"USER\": \"someuser\",\n+                    \"PASSWORD\": \"somepassword\",\n+                },\n+                [\"-c\", \"SELECT 1\"]\n+            ),\n+            (\n+                [\"psql\", \"-U\", \"someuser\", \"-c\", \"SELECT 1\", \"dbname\"],\n+                {\"PGPASSWORD\": \"somepassword\"},\n+            ),\n+        )\n     def test_sigint_handler(self):\n         \"\"\"SIGINT is ignored in Python and passed to psql to abort queries.\"\"\"\n \n@@ -183,4 +197,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 44ea946..fcec5c7 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1909,4 +1909,26 @@ class DeprecationTests(SimpleTestCase):\n         ):\n             ChoiceFormSet = formset_factory(Choice)\n             formset = ChoiceFormSet()\n-            str(formset)\n+            str(formset)\n+\n+    def test_no_management_form_deprecation_warning(self):\n+        \"\"\"\n+        Management forms should not produce a deprecation warning \n+        related to the default template usage.\n+        \"\"\"\n+        from django.forms.formsets import formset_factory, BaseFormSet\n+        from django.test import SimpleTestCase\n+        from django.utils.deprecation import RemovedInDjango50Warning\n+        from django.forms.utils import get_default_renderer\n+        from unittest import TestCase\n+        from django.forms.utils import DEFAULT_TEMPLATE_DEPRECATION_MSG\n+\n+        with isolate_lru_cache(get_default_renderer), self.settings(\n+            FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n+        ):\n+            ChoiceFormSet = formset_factory(BaseFormSet, extra=0)\n+            formset = ChoiceFormSet()\n+            with self.assertRaisesMessage(\n+                RemovedInDjango50Warning, DEFAULT_TEMPLATE_DEPRECATION_MSG\n+            ):\n+                _ = str(formset.management_form)\n",
  "django__django-16041": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex a34f3d3..145e892 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -179,7 +179,17 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertTrue(hasattr(formset.empty_form, \"custom_kwarg\"))\n         self.assertEqual(formset.empty_form.custom_kwarg, 1)\n \n-    def test_formset_validation(self):\n+    def test_empty_permitted_ignored_empty_form_true(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        formset = FormSet(form_kwargs={\"empty_permitted\": True})\n+        # empty_permitted should not have an effect on empty_form\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n+\n+    def test_empty_permitted_ignored_empty_form_false(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        formset = FormSet(form_kwargs={\"empty_permitted\": False})\n+        # empty_permitted should not have an effect on empty_form\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n         # FormSet instances can also have an error attribute if validation failed for\n         # any of the forms.\n         formset = self.make_choiceformset([(\"Calexico\", \"\")])\n",
  "django__django-16046": "",
  "django__django-16139": "",
  "django__django-16255": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 1469efd..7cdcd3e 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -508,6 +508,39 @@ class HTTPSitemapTests(SitemapTestsBase):\n         self.assertXMLEqual(sitemap_response.content.decode(), expected_content_sitemap)\n \n \n+from django.urls import path\n+from django.contrib.sitemaps import Sitemap\n+from django.test import SimpleTestCase\n+from django.utils.decorators import override_settings\n+import os\n+from . import views\n+\n+class CallableLastmodNoItemsSitemap(Sitemap):\n+    def items(self):\n+        return []\n+\n+    def lastmod(self, obj):\n+        return obj.lastmod\n+\n+class SitemapTests(SimpleTestCase):\n+    def setUp(self):\n+        self.client = self.client_class()\n+\n+    def test_callable_lastmod_no_items(self):\n+        \"\"\"Test a sitemap with no items and a callable lastmod method.\"\"\"\n+        response = self.client.get(\"/callable-lastmod-no-items/index.xml\")\n+        self.assertNotIn(\"Last-Modified\", response)\n+        expected_content = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n+        <sitemap><loc>http://example.com/callable-lastmod-no-items/sitemap.xml</loc></sitemap>\n+        </sitemapindex>\n+        \"\"\"\n+        self.assertXMLEqual(response.content.decode(), expected_content)\n+\n+urlpatterns = [\n+    path(\"callable-lastmod-no-items/index.xml\", views.index, {\"sitemaps\": {\"callable-lastmod-no-items\": CallableLastmodNoItemsSitemap}}),\n+]\n+\n # RemovedInDjango50Warning\n class DeprecatedTests(SitemapTestsBase):\n     @override_settings(\n",
  "django__django-16379": "",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..761166a 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,7 +1,10 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n from django.contrib.admin.templatetags.admin_list import date_hierarchy\n+from django.contrib.auth import get_permission_codename\n+from .tests import get_perm\n from django.contrib.admin.templatetags.admin_modify import submit_row\n from django.contrib.auth.admin import UserAdmin\n from django.contrib.auth.models import User\n",
  "django__django-16595": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 3979e76..0a3cea6 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -236,7 +236,49 @@ class OptimizerTests(SimpleTestCase):\n             ],\n         )\n \n-    def test_alter_alter_table_model(self):\n+from django.db import models, migrations\n+from django.test import TestCase\n+from django.db.migrations.optimizer import MigrationOptimizer\n+\n+class TestMigrationsOptimizer(TestCase):\n+    def _test_alter_alter_field(self, alter_foo, alter_bar):\n+        \"\"\"\n+        Two AlterField should collapse into the second.\n+        \"\"\"\n+        optimizer = MigrationOptimizer()\n+        operations = [alter_foo, alter_bar]\n+        optimized_operations = optimizer.optimize(operations, \"test_app\")\n+        self.assertEqual(len(optimized_operations), 1)\n+        self.assertIsInstance(optimized_operations[0], migrations.AlterField)\n+        self.assertEqual(optimized_operations[0].field.help_text, alter_bar.field.help_text)\n+\n+    def test_alter_alter_field_with_help_text(self):\n+        self._test_alter_alter_field(\n+            migrations.AlterField(\n+                model_name=\"book\",\n+                name=\"title\",\n+                field=models.CharField(max_length=128, null=True),\n+            ),\n+            migrations.AlterField(\n+                model_name=\"book\",\n+                name=\"title\",\n+                field=models.CharField(max_length=128, null=True, help_text=\"help\"),\n+            ),\n+        )\n+\n+    def test_alter_alter_field_with_default(self):\n+        self._test_alter_alter_field(\n+            migrations.AlterField(\n+                model_name=\"book\",\n+                name=\"title\",\n+                field=models.CharField(max_length=128, null=True, help_text=\"help\"),\n+            ),\n+            migrations.AlterField(\n+                model_name=\"book\",\n+                name=\"title\",\n+                field=models.CharField(max_length=128, null=True, help_text=\"help\", default=None),\n+            ),\n+        )\n         self._test_alter_alter_model(\n             migrations.AlterModelTable(\"Foo\", \"a\"),\n             migrations.AlterModelTable(\"Foo\", \"b\"),\n",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..5c6932b 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,3 +1,4 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n@@ -26,7 +27,21 @@ class JoinTests(SimpleTestCase):\n         output = self.engine.render_to_string(\"join04\", {\"a\": [\"alpha\", \"beta & me\"]})\n         self.assertEqual(output, \"alpha &amp; beta & me\")\n \n-    # Joining with unsafe joiners doesn't result in unsafe strings.\n+    @setup(\n+        {\n+            \"join_autoescape_off\": (\n+                \"{% autoescape off %}\"\n+                \"{{ var_list|join:var_joiner }}\"\n+                \"{% endautoescape %}\"\n+            ),\n+        }\n+    )\n+    def test_join_autoescape_off(self):\n+        var_list = [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"]\n+        context = {\"var_list\": var_list, \"var_joiner\": \"<br/>\"}\n+        output = self.engine.render_to_string(\"join_autoescape_off\", context)\n+        expected_result = \"<p>Hello World!</p><br/>beta & me<br/><script>Hi!</script>\"\n+        self.assertEqual(output, expected_result)\n     @setup({\"join05\": \"{{ a|join:var }}\"})\n     def test_join05(self):\n         output = self.engine.render_to_string(\n@@ -78,4 +93,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..78dd425 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -596,18 +596,117 @@ class BulkCreateTests(TestCase):\n                 {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n             ],\n         )\n+    def test_bulk_create_return_ids_with_update_conflicts(self):\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"initial\"),\n+            TwoFields(f1=2, f2=2, name=\"initial\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Prepare conflicting objects which should update existing ones.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated\"),\n+            TwoFields(f1=2, f2=2, name=\"updated\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"]\n+        )\n+\n+        # Verify that the IDs are returned for updated objects.\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"updated\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"updated\"},\n+            ],\n+        )\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_two_fields_unique_fields_first(self):\n         self._test_update_conflicts_two_fields([\"f1\"])\n+    def test_bulk_create_return_ids_with_update_conflicts(self):\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"initial\"),\n+            TwoFields(f1=2, f2=2, name=\"initial\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Prepare conflicting objects which should update existing ones.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated\"),\n+            TwoFields(f1=2, f2=2, name=\"updated\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"]\n+        )\n+\n+        # Verify that the IDs are returned for updated objects.\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"updated\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"updated\"},\n+            ],\n+        )\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_two_fields_unique_fields_second(self):\n         self._test_update_conflicts_two_fields([\"f2\"])\n+    def test_bulk_create_return_ids_with_update_conflicts(self):\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"initial\"),\n+            TwoFields(f1=2, f2=2, name=\"initial\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Prepare conflicting objects which should update existing ones.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated\"),\n+            TwoFields(f1=2, f2=2, name=\"updated\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"]\n+        )\n+\n+        # Verify that the IDs are returned for updated objects.\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"updated\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"updated\"},\n+            ],\n+        )\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -641,6 +740,39 @@ class BulkCreateTests(TestCase):\n                 {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n             ],\n         )\n+    def test_bulk_create_return_ids_with_update_conflicts(self):\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"initial\"),\n+            TwoFields(f1=2, f2=2, name=\"initial\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Prepare conflicting objects which should update existing ones.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated\"),\n+            TwoFields(f1=2, f2=2, name=\"updated\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"]\n+        )\n+\n+        # Verify that the IDs are returned for updated objects.\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"updated\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"updated\"},\n+            ],\n+        )\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -709,12 +841,78 @@ class BulkCreateTests(TestCase):\n                 },\n             ],\n         )\n+    def test_bulk_create_return_ids_with_update_conflicts(self):\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"initial\"),\n+            TwoFields(f1=2, f2=2, name=\"initial\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Prepare conflicting objects which should update existing ones.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated\"),\n+            TwoFields(f1=2, f2=2, name=\"updated\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"]\n+        )\n+\n+        # Verify that the IDs are returned for updated objects.\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"updated\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"updated\"},\n+            ],\n+        )\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_unique_two_fields_unique_fields_both(self):\n         self._test_update_conflicts_unique_two_fields([\"iso_two_letter\", \"name\"])\n+    def test_bulk_create_return_ids_with_update_conflicts(self):\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"initial\"),\n+            TwoFields(f1=2, f2=2, name=\"initial\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Prepare conflicting objects which should update existing ones.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated\"),\n+            TwoFields(f1=2, f2=2, name=\"updated\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"]\n+        )\n+\n+        # Verify that the IDs are returned for updated objects.\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"updated\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"updated\"},\n+            ],\n+        )\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -775,6 +973,39 @@ class BulkCreateTests(TestCase):\n                 {\"number\": 4, \"rank\": 4, \"name\": \"Mark\"},\n             ],\n         )\n+    def test_bulk_create_return_ids_with_update_conflicts(self):\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"initial\"),\n+            TwoFields(f1=2, f2=2, name=\"initial\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Prepare conflicting objects which should update existing ones.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated\"),\n+            TwoFields(f1=2, f2=2, name=\"updated\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"]\n+        )\n+\n+        # Verify that the IDs are returned for updated objects.\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"updated\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"updated\"},\n+            ],\n+        )\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -786,6 +1017,39 @@ class BulkCreateTests(TestCase):\n     @skipIfDBFeature(\"supports_update_conflicts_with_target\")\n     def test_update_conflicts_no_unique_fields(self):\n         self._test_update_conflicts([])\n+    def test_bulk_create_return_ids_with_update_conflicts(self):\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"initial\"),\n+            TwoFields(f1=2, f2=2, name=\"initial\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Prepare conflicting objects which should update existing ones.\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated\"),\n+            TwoFields(f1=2, f2=2, name=\"updated\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"]\n+        )\n+\n+        # Verify that the IDs are returned for updated objects.\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"updated\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"updated\"},\n+            ],\n+        )\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -816,4 +1080,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "",
  "matplotlib__matplotlib-22711": "",
  "matplotlib__matplotlib-23299": "diff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 144880c..c97080e 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -486,6 +486,34 @@ def test_validate_fontstretch(stretch, parsed_stretch):\n     if parsed_stretch is ValueError:\n         with pytest.raises(ValueError):\n             validate_fontstretch(stretch)\n+\n+\n+def test_get_backend_does_not_clear_gcf_figs():\n+    import matplotlib.pyplot as plt\n+    from matplotlib import rc_context, get_backend\n+    # Clear any pre-existing figures.\n+    plt.close('all')\n+\n+    # Define context to create a figure.\n+    with rc_context():\n+        fig1 = plt.figure()\n+\n+    # Save the state of Gcf.figs before calling get_backend()\n+    before_backend = plt._pylab_helpers.Gcf.figs.copy()\n+\n+    # Call get_backend()\n+    get_backend()\n+\n+    # Save the state of Gcf.figs after calling get_backend()\n+    after_backend = plt._pylab_helpers.Gcf.figs.copy()\n+\n+    # Count of figures should be the same before and after calling get_backend\n+    assert len(before_backend) == len(after_backend), f\"Count of figures changed: before = {len(before_backend)}, after = {len(after_backend)}\"\n+\n+    # Check that each figure manager is still present after calling get_backend\n+    for key, manager in before_backend.items():\n+        assert key in after_backend, f\"Figure manager with key {key} is missing after get_backend\"\n+        assert after_backend[key] == manager, f\"Figure manager with key {key} is different after get_backend\"\n     else:\n         assert validate_fontstretch(stretch) == parsed_stretch\n \n",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..52c83ec 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -15,13 +15,26 @@ from matplotlib.patches import Circle\n \n import matplotlib.pyplot as plt\n import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.testing.decorators import check_figures_equal\n \n \n mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n \n-def test_aspect_equal_error():\n+@check_figures_equal(extensions=[\"png\"])\n+def test_3d_set_visible_false(fig_test, fig_ref):\n+    # Create a figure with two 3D subplots in `fig_test`, one of them will be invisible.\n+    ax1 = fig_test.add_subplot(1, 2, 1, projection='3d')\n+    ax2 = fig_test.add_subplot(1, 2, 2, projection='3d')\n+    ax1.scatter(1, 1, 1)\n+    ax2.scatter(1, 1, 1, c='r')\n+    ax1.set_visible(False)  # This subplot should not be visible.\n+\n+    # Create a reference figure with a single visible 3D subplot in `fig_ref`.\n+    ax_ref = fig_ref.add_subplot(1, 2, 2, projection='3d')\n+    ax_ref.scatter(1, 1, 1, c='r')\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     with pytest.raises(NotImplementedError):\n",
  "matplotlib__matplotlib-23562": "",
  "matplotlib__matplotlib-23563": "",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..0f369ea 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -774,7 +774,12 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n         assert mpl.colors.same_color(text.get_color(), color)\n \n \n-def test_get_set_draggable():\n+@pytest.mark.parametrize('draggable', (True, False))\n+def test_legend_draggable_at_creation(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot([0, 1, 2], [0, 1, 4], label='Test Line')\n+    legend = ax.legend(draggable=draggable)\n+    assert legend.get_draggable() is draggable\n     legend = plt.legend()\n     assert not legend.get_draggable()\n     legend.set_draggable(True)\n",
  "matplotlib__matplotlib-23964": "diff --git a/lib/matplotlib/tests/test_backend_ps.py b/lib/matplotlib/tests/test_backend_ps.py\nindex a1caf1a..d2d0c26 100644\n--- a/lib/matplotlib/tests/test_backend_ps.py\n+++ b/lib/matplotlib/tests/test_backend_ps.py\n@@ -246,7 +246,25 @@ def test_fonttype(fonttype):\n \n def test_linedash():\n     \"\"\"Test that dashed lines do not break PS output\"\"\"\n-    fig, ax = plt.subplots()\n+import io\n+import matplotlib.pyplot as plt\n+from matplotlib.figure import Figure\n+\n+def test_empty_line():\n+    # Smoke-test for gh#23954\n+    figure = Figure()\n+    figure.text(0.5, 0.5, \"\\nfoo\\n\\n\")\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n+\n+def test_annotation_with_empty_line():\n+    figure = Figure()\n+    ax = figure.add_subplot(111)\n+    ax.annotate(text='\\nLower label', xy=(0, 0))\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n \n     ax.plot([0, 1], linestyle=\"--\")\n \n",
  "matplotlib__matplotlib-23987": "",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "",
  "matplotlib__matplotlib-24970": "diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex 2be14fe..1a4addc 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -30,7 +30,34 @@ def test_create_lookup_table(N, result):\n     assert_array_almost_equal(mcolors._create_lookup_table(N, data), result)\n \n \n-def test_resampled():\n+import pytest\n+import numpy as np\n+import matplotlib as mpl\n+from numpy.testing import assert_array_equal\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+@pytest.mark.parametrize(\"dtype\", [np.uint8, int, np.float16, float])\n+def test_index_dtype_no_deprecation_warnings(dtype):\n+    cm = mpl.colormaps[\"viridis\"]\n+    with pytest.warns(None) as record:\n+        assert_array_equal(cm(dtype(0)), cm(0))\n+    # Check that no DeprecationWarnings were issued\n+    assert not any(item.category == DeprecationWarning for item in record)\n+\n+@check_figures_equal()\n+def test_plot_with_colormap(fig_test, fig_ref):\n+    np.random.seed(0)\n+    x = np.random.rand(10)\n+    y = np.random.rand(10)\n+\n+    ax_test = fig_test.add_subplot()\n+    ax_ref = fig_ref.add_subplot()\n+\n+    # Apply a colormap to trigger potential warnings\n+    cmap = mpl.colormaps[\"viridis\"]\n+\n+    ax_test.scatter(x, y, c=y, cmap=cmap)\n+    ax_ref.scatter(x, y, c=y, cmap=\"viridis\")\n     \"\"\"\n     GitHub issue #6025 pointed to incorrect ListedColormap.resampled;\n     here we test the method for LinearSegmentedColormap as well.\n",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..53aee6c 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -89,6 +90,7 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n+import pickletools\n \n @mpl.style.context(\"default\")\n @check_figures_equal(extensions=[\"png\"])\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..f3b9fa5 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -91,6 +91,35 @@ def _generate_complete_test_figure(fig_ref):\n \n \n @mpl.style.context(\"default\")\n+def test_pickle_after_align_labels():\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    \n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    fig.align_labels()  # Test if pickling a figure with aligned labels works\n+\n+    try:\n+        pkl = pickle.dumps(fig)  # Attempt to pickle the figure\n+        fig_loaded = pickle.loads(pkl)  # Unpickle to ensure it works\n+        fig_loaded.canvas.draw()  # Invoke a draw to verify no errors\n+        plt.close(fig_loaded)\n+        print(\"Pickling after align_labels() succeeded.\")\n+    except Exception as e:\n+        print(f\"Pickling after align_labels() failed: {e}\")\n+        raise\n+\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25442": "",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "",
  "mwaskom__seaborn-3190": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\nindex 72a27ec..a91d7ce 100644\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -96,12 +96,32 @@ class TestContinuous:\n         s = Continuous()._setup(x, Color())\n         assert_array_equal(s(x), cmap([0, .25, 1])[:, :3])  # FIXME RGBA\n \n+    def test_color_with_boolean_data(self):\n+        # Test case to cover the issue described with color mapping boolean data\n+        x = pd.Series([True, False, True, False])\n+        cmap = color_palette(\"viridis\", as_cmap=True)\n+        # Expect boolean values to map to discrete colors\n+        expected_colors = cmap([1, 0, 1, 0])[:, :3]  # Assuming True maps to one extreme and False to the other\n+\n+        s = Continuous()._setup(x, Color())\n+        assert_array_equal(s(x), expected_colors)  # Check actual colors match expected\n+\n     def test_color_named_values(self, x):\n \n         cmap = color_palette(\"viridis\", as_cmap=True)\n         s = Continuous(\"viridis\")._setup(x, Color())\n         assert_array_equal(s(x), cmap([0, .25, 1])[:, :3])  # FIXME RGBA\n \n+    def test_color_with_boolean_data(self):\n+        # Test case to cover the issue described with color mapping boolean data\n+        x = pd.Series([True, False, True, False])\n+        cmap = color_palette(\"viridis\", as_cmap=True)\n+        # Expect boolean values to map to discrete colors\n+        expected_colors = cmap([1, 0, 1, 0])[:, :3]  # Assuming True maps to one extreme and False to the other\n+\n+        s = Continuous()._setup(x, Color())\n+        assert_array_equal(s(x), expected_colors)  # Check actual colors match expected\n+\n     def test_color_tuple_values(self, x):\n \n         cmap = color_palette(\"blend:b,g\", as_cmap=True)\n",
  "mwaskom__seaborn-3407": "",
  "pallets__flask-4992": "diff --git a/tests/test_config.py b/tests/test_config.py\nindex 179b09c..ee07162 100644\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -1,8 +1,11 @@\n+\n import json\n import os\n import textwrap\n \n import pytest\n+import tomllib\n+import io\n \n import flask\n \n",
  "psf__requests-1963": "",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..20e3d6e 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1636,6 +1636,43 @@ def test_prepared_request_complete_copy():\n     assert_copy(p, p.copy())\n \n \n+import pytest\n+import requests\n+from requests.exceptions import RequestException\n+from requests.adapters import HTTPAdapter\n+from requests.packages.urllib3.exceptions import DecodeError\n+from requests.packages.urllib3.util.retry import Retry\n+from urllib3 import HTTPResponse\n+import socket\n+\n+### Define a mock URL and HTTPBin-like behavior\n+def httpbin(path):\n+    return 'http://httpbin.org/' + path\n+\n+def test_decode_error_is_wrapped():\n+    class MockHTTPAdapter(HTTPAdapter):\n+        def send(self, *args, **kwargs):\n+            raise DecodeError(\"Mock DecodeError for testing\")\n+\n+    s = requests.Session()\n+    s.mount('http://', MockHTTPAdapter())\n+    \n+    with pytest.raises(RequestException) as excinfo:\n+        s.get(httpbin('status/200'))\n+    assert \"Mock DecodeError for testing\" in str(excinfo.value)\n+\n+def test_proxy_timeout_error_is_wrapped():\n+    class MockHTTPAdapter(HTTPAdapter):\n+        def send(self, *args, **kwargs):\n+            raise socket.timeout(\"Mock TimeoutError for testing\")\n+\n+    s = requests.Session()\n+    s.mount('http://', MockHTTPAdapter())\n+    \n+    with pytest.raises(RequestException) as excinfo:\n+        s.get(httpbin('status/200'))\n+    assert \"Mock TimeoutError for testing\" in str(excinfo.value)\n+\n def test_prepare_unicode_url():\n     p = PreparedRequest()\n     p.prepare(\n@@ -1663,4 +1700,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 52d1693..455af8b 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -980,6 +980,25 @@ class TestRequests:\n         chunks = r.iter_content(decode_unicode=True)\n         assert all(isinstance(chunk, str) for chunk in chunks)\n \n+    def test_iter_content_decoding(self):\n+        \"\"\"\n+        When iter_content is called with decode_unicode=True, it should\n+        return decoded strings if the encoding is set, otherwise bytes.\n+        \"\"\"\n+        # Test with encoding set\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'the content')\n+        r.encoding = 'utf-8'\n+        chunks = r.iter_content(16*1024, decode_unicode=True)\n+        assert all(isinstance(chunk, str) for chunk in chunks), \"All chunks should be str when decode_unicode=True and encoding is set\"\n+\n+        # Test with decode_unicode=True but no encoding\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'the content')\n+        r.encoding = None\n+        chunks = r.iter_content(16*1024, decode_unicode=True)\n+        assert all(isinstance(chunk, bytes) for chunk in chunks), \"Chunks should be bytes when decode_unicode=True but no encoding is set\"\n+\n     def test_response_chunk_size_int(self):\n         \"\"\"Ensure that chunk_size is passed as an integer, otherwise\n         raise a TypeError.\n",
  "psf__requests-863": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 0ee4333..7a08894 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -731,8 +731,37 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n             })\n \n             return args\n-\n-        for service in SERVICES:\n+        def test_hooks_as_list_initialized_via_constructor(self):\n+            \"\"\"Test multiple hooks can be passed in as list via constructor\"\"\"\n+            def add_baz_header(args):\n+                if not args.get('headers'):\n+                    args['headers'] = {}\n+\n+                args['headers'].update({\n+                    'X-Baz': 'baz'\n+                })\n+\n+                return args\n+\n+            hooks = {\n+                'args': [add_foo_header, add_bar_header, add_baz_header]\n+            }\n+\n+            r = requests.models.Request(hooks=hooks)\n+            assert 'args' in r.hooks\n+            assert len(r.hooks['args']) == 3\n+\n+            for hook in r.hooks['args']:\n+                assert callable(hook) is True\n+\n+            # Simulating hook execution\n+            args = {}\n+            for hook in r.hooks['args']:\n+                args = hook(args)\n+            \n+            assert args['headers']['X-Foo'] == 'foo'\n+            assert args['headers']['X-Bar'] == 'bar'\n+            assert args['headers']['X-Baz'] == 'baz'\n             url = service('headers')\n \n             response = get(url=url,\n",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..6c4a2a9 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -388,7 +388,7 @@ repr_da = xr.DataArray(\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over %r \" % dim\n+    expected += \", grouped over %r\" % dim\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj[dim])))\n     if dim == \"x\":\n         expected += \"1, 2, 3, 4, 5.\"\n@@ -405,7 +405,7 @@ def test_groupby_repr(obj, dim):\n def test_groupby_repr_datetime(obj):\n     actual = repr(obj.groupby(\"t.month\"))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over 'month' \"\n+    expected += \", grouped over 'month'\"\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj.t.dt.month)))\n     expected += \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.\"\n     assert actual == expected\n",
  "pylint-dev__pylint-5859": "diff --git a/tests/checkers/unittest_misc.py b/tests/checkers/unittest_misc.py\nindex 460d485..9ed7e73 100644\n--- a/tests/checkers/unittest_misc.py\n+++ b/tests/checkers/unittest_misc.py\n@@ -94,7 +94,15 @@ class TestFixme(CheckerTestCase):\n         with self.assertNoMessages():\n             self.checker.process_tokens(_tokenize_str(code))\n \n-    def test_issue_2321_should_trigger(self) -> None:\n+    @set_config(notes=[\"???\"])\n+    def test_punctuation_codetag(self) -> None:\n+        code = \"\"\"a = 1\n+                #???\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n         code = \"# TODO this should not trigger a fixme\"\n         with self.assertAddsMessages(\n             MessageTest(\n@@ -119,4 +127,4 @@ class TestFixme(CheckerTestCase):\n         # Todoist API: Fetch all Tasks\n         \"\"\"\n         with self.assertNoMessages():\n-            self.checker.process_tokens(_tokenize_str(code))\n+            self.checker.process_tokens(_tokenize_str(code))\n",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..e80f84f 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -73,10 +73,12 @@ def test_unknown_option_name(capsys: CaptureFixture) -> None:\n \n def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly raise a message on an unknown short option.\"\"\"\n-    with pytest.raises(_UnrecognizedOptionError):\n+    with pytest.raises(SystemExit):\n         Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n     output = capsys.readouterr()\n     assert \"E0015: Unrecognized option found: Q\" in output.out\n+    assert \"usage: pylint\" in output.err\n+    assert \"error: unrecognized arguments: -Q\" in output.err\n \n \n def test_unknown_confidence(capsys: CaptureFixture) -> None:\n",
  "pylint-dev__pylint-7080": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex fa7078d..0bc5724 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1330,6 +1330,23 @@ class TestRunTC:\n                     code=0,\n                 )\n \n+    def test_ignore_path_with_recursive(self):\n+        \"\"\"Tests that 'ignore-paths' is respected with recursive option.\"\"\"\n+        with _test_sys_path():\n+            # pytest is including directory HERE/regrtest_data to sys.path which causes\n+            # astroid to believe that directory is a package.\n+            sys.path = [\n+                path\n+                for path in sys.path\n+                if not os.path.basename(path) == \"regrtest_data\"\n+            ]\n+            with _test_cwd():\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n+                self._runtest(\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^subdirectory/.*\"],\n+                    code=0,\n+                )\n+\n     def test_regression_recursive_current_dir(self):\n         with _test_sys_path():\n             # pytest is including directory HERE/regrtest_data to sys.path which causes\n",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..3eebf0c 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -935,10 +935,38 @@ print(submodule1)\n     assert not linter.stats.by_msg\n \n \n+def test_identically_named_nested_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test to ensure pylint runs successfully when a module contains a module with the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        # Write some simple content to a.py and b.py\n+        with open(\"a/a.py\", \"w\", encoding=\"utf-8\") as file_a:\n+            file_a.write(\"print('Module a.py')\")\n+        with open(\"a/b.py\", \"w\", encoding=\"utf-8\") as file_b:\n+            file_b.write(\"print('Module b.py')\")\n+\n+        # Running pylint should not fail due to missing __init__.py\n+        linter.check([\"a\"])\n+    assert not linter.stats.by_msg\n+\n+def test_import_resolution_in_presence_of_identically_named_nested_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test for import resolution for modules with the same name, ensuring correct import behavior.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        # Write content to r.py trying to import b from a\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as file_r:\n+            file_r.write(\"from a import b\\n\")\n+\n+        # Running pylint on both r.py and the package a should not present import errors\n+        linter.check([\"r.py\", \"a\"])\n+    assert not linter.stats.by_msg\n+\n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n     linter = initialized_linter\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n",
  "pylint-dev__pylint-7993": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 6338072..b5ee89b 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n@@ -9,6 +10,7 @@ from __future__ import annotations\n import sys\n import warnings\n from contextlib import redirect_stdout\n+from _pytest.recwarn import WarningsRecorder\n from io import StringIO\n from json import dumps\n from typing import TYPE_CHECKING\n",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "",
  "pytest-dev__pytest-5227": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 1ebe9d0..01f354c 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -15,7 +15,7 @@ from _pytest.compat import dummy_context_manager\n from _pytest.config import create_terminal_writer\n from _pytest.pathlib import Path\n \n-DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n+DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n \n \n",
  "pytest-dev__pytest-5495": "diff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex b05f85c..ec18066 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -324,6 +324,25 @@ class TestAssert_reprcompare:\n         assert \"- \" + \"a\" * 50 + \"spam\" in lines\n         assert \"+ \" + \"a\" * 50 + \"eggs\" in lines\n \n+    def test_bytes_diff_comparison(self):\n+        left = b\"\"\n+        right_42 = b\"42\"\n+        right_1 = b\"1\"\n+        \n+        diff_42 = callequal(left, right_42, verbose=True)\n+        assert diff_42[0] == \"b'' == b'42'\"\n+        assert diff_42[1] == \"Right contains more items, first extra item: 52\"\n+        assert diff_42[2] == \"Full diff:\"\n+        assert diff_42[3] == \"- b''\"\n+        assert diff_42[4] == \"+ b'42'\"\n+        \n+        diff_1 = callequal(left, right_1, verbose=True)\n+        assert diff_1[0] == \"b'' == b'1'\"\n+        assert diff_1[1] == \"Right contains more items, first extra item: 49\"\n+        assert diff_1[2] == \"Full diff:\"\n+        assert diff_1[3] == \"- b''\"\n+        assert diff_1[4] == \"+ b'1'\"\n+        \n     def test_multiline_text_diff(self):\n         left = \"foo\\nspam\\nbar\"\n         right = \"foo\\neggs\\nbar\"\n",
  "pytest-dev__pytest-5692": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3392814..27b9b56 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1,9 +1,12 @@\n+\n import os\n from xml.dom import minidom\n \n import py\n \n import pytest\n+import platform\n+from datetime import datetime\n from _pytest.junitxml import LogXML\n from _pytest.reports import BaseReport\n \n@@ -157,7 +160,29 @@ class TestPython:\n         val = tnode[\"time\"]\n         assert round(float(val), 2) >= 0.03\n \n-    @pytest.mark.parametrize(\"duration_report\", [\"call\", \"total\"])\n+    def test_hostname_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+        \"\"\"\n+        )\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        node.assert_attr(hostname=platform.node())\n+\n+    def test_timestamp_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+        \"\"\"\n+        )\n+        start_time = datetime.now()\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        timestamp = datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S.%f\")\n+        assert start_time <= timestamp < datetime.now()\n     def test_junit_duration_report(self, testdir, monkeypatch, duration_report):\n \n         # mock LogXML.node_reporter so it always sets a known duration to each test report object\n",
  "pytest-dev__pytest-7168": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 38e0b6b..9c6e5ca 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -143,6 +143,45 @@ def test_repr_on_newstyle():\n \n     assert saferepr(Function())\n \n+def test_broken_getattribute():\n+    \"\"\"saferepr() can create proper representations of classes with\n+    broken __getattribute__ (#7145)\n+    \"\"\"\n+\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError\n+\n+        def __repr__(self):\n+            raise RuntimeError\n+\n+    assert saferepr(SomeClass()).startswith(\n+        \"<[RuntimeError() raised in repr()] SomeClass object at 0x\"\n+    )\n+\n+def test_broken_repr():\n+    \"\"\"Test saferepr handles exceptions in __repr__ method correctly.\"\"\"\n+\n+    class AnotherClass:\n+        def __repr__(self):\n+            raise ValueError(\"Error in repr\")\n+\n+    result = saferepr(AnotherClass())\n+    assert result.startswith(\"<[ValueError('Error in repr') raised in repr()] AnotherClass object at 0x\")\n+\n+def test_broken_getattribute_and_repr():\n+    \"\"\"Test saferepr with exceptions in both __getattribute__ and __repr__.\"\"\"\n+\n+    class CombinedClass:\n+        def __getattribute__(self, attr):\n+            raise AttributeError(\"Error in getattribute\")\n+\n+        def __repr__(self):\n+            raise RuntimeError(\"Error in repr\")\n+\n+    result = saferepr(CombinedClass())\n+    assert result.startswith(\"<[RuntimeError('Error in repr') raised in repr()] CombinedClass object at 0x\")\n+\n \n def test_unicode():\n     val = \"\u00a3\u20ac\"\n@@ -153,4 +192,4 @@ def test_unicode():\n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n-    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n",
  "pytest-dev__pytest-7220": "diff --git a/testing/test_pytester.py b/testing/test_pytester.py\nindex 5ab5242..3590d20 100644\n--- a/testing/test_pytester.py\n+++ b/testing/test_pytester.py\n@@ -76,8 +76,31 @@ def test_parseconfig(testdir) -> None:\n     config2 = testdir.parseconfig()\n     assert config2 is not config1\n \n+def test_failure_with_changed_cwd(testdir) -> None:\n+    \"\"\"\n+    Test failure lines should use absolute paths if cwd has changed since\n+    invocation, so the path is correct.\n+    \"\"\"\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import os\n+        import pytest\n \n-def test_testdir_runs_with_plugin(testdir) -> None:\n+        @pytest.fixture\n+        def private_dir():\n+            out_dir = 'ddd'\n+            os.mkdir(out_dir)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+\n+        def test_show_wrong_path(private_dir):\n+            assert False\n+    \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([str(p) + \":*: AssertionError\", \"*1 failed in *\"])\n     testdir.makepyfile(\n         \"\"\"\n         pytest_plugins = \"pytester\"\n",
  "pytest-dev__pytest-7373": "diff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 309636c..c93853c 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1,5 +1,38 @@\n import os\n import sys\n+def test_reevaluate_dynamic_expr(testdir):\n+    \"\"\"Check reevaluation of dynamic expressions for skipif decorators - Issue #7360\"\"\"\n+    py_file1 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr1=\"\"\"\n+        import pytest\n+\n+        skip = True\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_skip():\n+            assert False\n+    \"\"\"\n+    )\n+    \n+    py_file2 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr2=\"\"\"\n+        import pytest\n+\n+        skip = False\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_not_skip():\n+            assert False\n+    \"\"\"\n+    )\n+\n+    file_name1 = os.path.basename(py_file1.strpath)\n+    file_name2 = os.path.basename(py_file2.strpath)\n+    reprec = testdir.inline_run(file_name1, file_name2)\n+    reprec.assertoutcome(passed=1, skipped=1)\n+\n+import os\n+\n from unittest import mock\n \n import pytest\n",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..3c82887 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -152,8 +152,33 @@ class TestEvaluation:\n         assert skipped\n         assert skipped.reason == \"condition: config._hackxyz\"\n \n+import pytest\n \n-class TestXFail:\n+class TestSkipWithRunXfail:\n+    @pytest.mark.parametrize(\n+        \"test_input,expected\",\n+        [\n+            (\n+                [\"-rs\"],\n+                [\"SKIPPED [1] test_sample.py:3: unconditional skip\", \"*1 skipped*\"],\n+            ),\n+            (\n+                [\"-rs\", \"--runxfail\"],\n+                [\"SKIPPED [1] test_sample.py:3: unconditional skip\", \"*1 skipped*\"],\n+            ),\n+        ],\n+    )\n+    def test_skip_location_with_runxfail(self, testdir, test_input, expected):\n+        testdir.makepyfile(\n+            test_sample=\"\"\"\n+            import pytest\n+            @pytest.mark.skip\n+            def test_skip_location() -> None:\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(*test_input)\n+        result.stdout.fnmatch_lines(expected)\n     @pytest.mark.parametrize(\"strict\", [True, False])\n     def test_xfail_simple(self, testdir, strict):\n         item = testdir.getitem(\n",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..8c26b06 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,3 +1,4 @@\n+\n import sys\n \n import pytest\n@@ -219,7 +220,30 @@ class TestXFail:\n         assert str(callreport.longrepr) == \"[XPASS(strict)] nope\"\n         assert not hasattr(callreport, \"wasxfail\")\n \n-    def test_xfail_run_anyway(self, testdir):\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # Issue #7486.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir: Testdir) -> None:\n+        # Issue #7486.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\", strict=True))\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n         testdir.makepyfile(\n             \"\"\"\n             import pytest\n",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..df90276 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,7 +1,9 @@\n+\n import os\n import stat\n import sys\n from pathlib import Path\n+from _pytest.monkeypatch import MonkeyPatch\n from typing import Callable\n from typing import cast\n from typing import List\n",
  "scikit-learn__scikit-learn-10297": "",
  "scikit-learn__scikit-learn-11281": "diff --git a/sklearn/mixture/tests/test_bayesian_mixture.py b/sklearn/mixture/tests/test_bayesian_mixture.py\nindex a9d82b7..d7e6d8c 100644\n--- a/sklearn/mixture/tests/test_bayesian_mixture.py\n+++ b/sklearn/mixture/tests/test_bayesian_mixture.py\n@@ -14,8 +14,8 @@ from sklearn.mixture.bayesian_mixture import _log_wishart_norm\n from sklearn.mixture import BayesianGaussianMixture\n \n from sklearn.mixture.tests.test_gaussian_mixture import RandomData\n-from sklearn.exceptions import ConvergenceWarning\n-from sklearn.utils.testing import assert_greater_equal, ignore_warnings\n+from sklearn.exceptions import ConvergenceWarning, NotFittedError\n+from sklearn.utils.testing import assert_greater_equal, ignore_warnings, assert_array_equal\n \n \n COVARIANCE_TYPE = ['full', 'tied', 'diag', 'spherical']\n",
  "scikit-learn__scikit-learn-12471": "",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex f8e4d54..c5bff48 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -598,7 +598,17 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n \n-def test_gaussian_mixture_fit():\n+import numpy as np\n+from sklearn.mixture import GaussianMixture\n+from numpy.testing import assert_array_equal\n+\n+def test_gaussian_mixture_fit_predict_n_init():\n+    # Check that fit_predict is equivalent to fit.predict, when n_init > 1\n+    X = np.random.RandomState(0).randn(1000, 5)\n+    gm = GaussianMixture(n_components=5, n_init=5, random_state=0)\n+    y_pred1 = gm.fit_predict(X)\n+    y_pred2 = gm.predict(X)\n+    assert_array_equal(y_pred1, y_pred2)\n     # recover the ground truth\n     rng = np.random.RandomState(0)\n     rand_data = RandomData(rng)\n",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..6a3da9f 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,3 +1,4 @@\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n@@ -5,8 +6,22 @@ import pytest\n from sklearn.utils.testing import (assert_array_almost_equal, assert_less,\n                                    assert_equal, assert_not_equal,\n                                    assert_raises)\n-\n+from sklearn.utils.testing import assert_allclose\n from sklearn.decomposition import PCA, KernelPCA\n+\n+def test_kernel_pca_sign_consistency():\n+    rng = np.random.RandomState(0)\n+    X = rng.rand(10, 10)\n+\n+    kpca = KernelPCA(n_components=7, kernel='rbf', random_state=rng)\n+    transformed_X1 = kpca.fit_transform(X)\n+\n+    # Reset and refit to check sign consistency\n+    kpca2 = KernelPCA(n_components=7, kernel='rbf', random_state=rng)\n+    transformed_X2 = kpca2.fit_transform(X)\n+\n+    # Check if the absolute values are close, i.e., signs might differ\n+    assert_allclose(np.abs(transformed_X1), np.abs(transformed_X2))\n from sklearn.datasets import make_circles\n from sklearn.linear_model import Perceptron\n from sklearn.pipeline import Pipeline\n",
  "scikit-learn__scikit-learn-13439": "diff --git a/sklearn/tests/test_pipeline.py b/sklearn/tests/test_pipeline.py\nindex 318940e..a71515b 100644\n--- a/sklearn/tests/test_pipeline.py\n+++ b/sklearn/tests/test_pipeline.py\n@@ -1057,6 +1057,25 @@ def test_pipeline_memory():\n     finally:\n         shutil.rmtree(cachedir)\n \n+def test_pipeline_length():\n+    from sklearn.pipeline import Pipeline\n+    from sklearn.feature_selection import SelectKBest, f_regression\n+    from sklearn.svm import SVC\n+\n+    # Create a pipeline with a length of 2\n+    anova_filter = SelectKBest(f_regression, k=5)\n+    clf = SVC(kernel='linear')\n+    pipe = Pipeline([('anova', anova_filter), ('svc', clf)])\n+    assert len(pipe) == 2\n+\n+    # Test empty pipeline\n+    empty_pipe = Pipeline([])\n+    assert len(empty_pipe) == 0\n+\n+    # Test single step pipeline\n+    single_step_pipe = Pipeline([('anova', anova_filter)])\n+    assert len(single_step_pipe) == 1\n+\n \n def test_make_pipeline_memory():\n     cachedir = mkdtemp()\n@@ -1070,4 +1089,4 @@ def test_make_pipeline_memory():\n     pipeline = make_pipeline(DummyTransf(), SVC())\n     assert pipeline.memory is None\n \n-    shutil.rmtree(cachedir)\n+    shutil.rmtree(cachedir)\n",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..fbe05c7 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -11,6 +12,8 @@ import pytest\n import numpy as np\n \n from sklearn.utils.testing import assert_array_equal\n+from sklearn.ensemble import IsolationForest\n+from sklearn.utils import check_random_state\n from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_raises\n from sklearn.utils.testing import assert_raises_regex\n@@ -281,7 +284,38 @@ def test_iforest_average_path_length():\n     assert_array_equal(avg_path_length, np.sort(avg_path_length))\n \n \n+@pytest.mark.filterwarnings('ignore:default contamination')\n @pytest.mark.filterwarnings('ignore:default contamination')\n+@pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n+def test_iforest_warm_start_incremental_fit():\n+    \"\"\"Test incremental fitting with warm_start and changes in n_estimators.\"\"\"\n+\n+    rng = check_random_state(0)\n+    X = rng.randn(20, 2)\n+\n+    # Fit first 15 trees\n+    clf = IsolationForest(n_estimators=15, max_samples=20, random_state=rng, warm_start=True)\n+    clf.fit(X)\n+    tree_initial = clf.estimators_[0]\n+    \n+    # Increment to 25 trees\n+    clf.set_params(n_estimators=25)\n+    clf.fit(X)\n+    assert len(clf.estimators_) == 25\n+    assert clf.estimators_[0] is tree_initial\n+\n+    # Further increment to 30 trees\n+    clf.set_params(n_estimators=30)\n+    clf.fit(X)\n+    assert len(clf.estimators_) == 30\n+    assert clf.estimators_[0] is tree_initial\n+\n+    # Ensure predictive consistency\n+    prediction = clf.predict(X)\n+    clf.set_params(n_estimators=30)\n+    clf.fit(X)\n+    assert (prediction == clf.predict(X)).all()\n+    \n @pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n def test_score_samples():\n     X_train = [[1, 1], [1, 2], [2, 1]]\n@@ -296,6 +330,37 @@ def test_score_samples():\n \n \n @pytest.mark.filterwarnings('ignore:default contamination')\n+@pytest.mark.filterwarnings('ignore:default contamination')\n+@pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n+def test_iforest_warm_start_incremental_fit():\n+    \"\"\"Test incremental fitting with warm_start and changes in n_estimators.\"\"\"\n+\n+    rng = check_random_state(0)\n+    X = rng.randn(20, 2)\n+\n+    # Fit first 15 trees\n+    clf = IsolationForest(n_estimators=15, max_samples=20, random_state=rng, warm_start=True)\n+    clf.fit(X)\n+    tree_initial = clf.estimators_[0]\n+    \n+    # Increment to 25 trees\n+    clf.set_params(n_estimators=25)\n+    clf.fit(X)\n+    assert len(clf.estimators_) == 25\n+    assert clf.estimators_[0] is tree_initial\n+\n+    # Further increment to 30 trees\n+    clf.set_params(n_estimators=30)\n+    clf.fit(X)\n+    assert len(clf.estimators_) == 30\n+    assert clf.estimators_[0] is tree_initial\n+\n+    # Ensure predictive consistency\n+    prediction = clf.predict(X)\n+    clf.set_params(n_estimators=30)\n+    clf.fit(X)\n+    assert (prediction == clf.predict(X)).all()\n+    \n @pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n def test_deprecation():\n     X = [[0.0], [1.0]]\n",
  "scikit-learn__scikit-learn-13497": "diff --git a/sklearn/feature_selection/tests/test_mutual_info.py b/sklearn/feature_selection/tests/test_mutual_info.py\nindex f5a2908..a02ba7a 100644\n--- a/sklearn/feature_selection/tests/test_mutual_info.py\n+++ b/sklearn/feature_selection/tests/test_mutual_info.py\n@@ -164,6 +164,32 @@ def test_mutual_info_classif_mixed():\n     for n_neighbors in [5, 7, 9]:\n         mi_nn = mutual_info_classif(X, y, discrete_features=[2],\n                                     n_neighbors=n_neighbors, random_state=0)\n+\n+def test_estimate_mi_handle_varied_discrete_features():\n+    X = np.array([[0, 1, 1],\n+                  [1, 0, 1],\n+                  [0, 1, 0],\n+                  [1, 0, 0],\n+                  [1, 1, 0]], dtype=float)\n+    y = np.array([0, 1, 0, 1, 1], dtype=float)\n+\n+    X_csr = csr_matrix(X)\n+\n+    for mutual_info in (mutual_info_regression, mutual_info_classif):\n+        # Check different forms of discrete_features\n+        mi_bool_mask = mutual_info(X, y, discrete_features=[True, False, True], random_state=0)\n+        mi_indices = mutual_info(X, y, discrete_features=[0, 2], random_state=0)\n+        assert_array_equal(mi_bool_mask, mi_indices)\n+\n+        # Test with a boolean mask of incorrect length\n+        assert_raises(IndexError, mutual_info, X, y, discrete_features=[True, False])\n+\n+        # Test with indices that are out of bounds\n+        assert_raises(IndexError, mutual_info, X, y, discrete_features=[1, 3])\n+\n+        # Test full boolean mask\n+        mi_full_bool = mutual_info(X, y, discrete_features=[True, True, True], random_state=0)\n+        assert not np.allclose(mi_bool_mask, mi_full_bool)  # Should differ due to all being discrete\n         # Check that the continuous values have an higher MI with greater\n         # n_neighbors\n         assert_greater(mi_nn[0], mi[0])\n@@ -173,6 +199,13 @@ def test_mutual_info_classif_mixed():\n         assert_equal(mi_nn[2], mi[2])\n \n \n+from sklearn.feature_selection import mutual_info_classif\n+from sklearn.feature_selection import mutual_info_regression\n+from sklearn.utils._testing import assert_raises\n+from sklearn.utils._testing import assert_array_equal\n+from scipy.sparse import csr_matrix\n+import numpy as np\n+\n def test_mutual_info_options():\n     X = np.array([[0, 0, 0],\n                   [1, 1, 0],\n@@ -197,4 +230,4 @@ def test_mutual_info_options():\n         assert_array_equal(mi_1, mi_2)\n         assert_array_equal(mi_3, mi_4)\n \n-    assert not np.allclose(mi_1, mi_3)\n+    assert not np.allclose(mi_1, mi_3)\n",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..10ab93b 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,3 +1,4 @@\n+\n import re\n from pprint import PrettyPrinter\n \n@@ -8,6 +9,7 @@ from sklearn.pipeline import make_pipeline\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.feature_selection import SelectKBest, chi2\n from sklearn import set_config\n+from sklearn.linear_model import LogisticRegressionCV\n \n \n # Ignore flake8 (lots of line too long issues)\n@@ -214,8 +216,19 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n \n     set_config(print_changed_only=False)\n \n-\n-def test_pipeline():\n+def test_logistic_regression_cv_vector_values():\n+    \"\"\"Test LogisticRegressionCV representation with vector values for Cs when print_changed_only=True.\"\"\"\n+    set_config(print_changed_only=True)\n+    # Check that no error is raised when print_changed_only is True\n+    try:\n+        repr_result = repr(LogisticRegressionCV(Cs=np.array([0.1, 1])))\n+    except ValueError as e:\n+        assert False, f\"ValueError raised: {e}\"\n+    else:\n+        assert repr_result is not None\n+\n+    # Reset config to avoid affecting other tests\n+    set_config(print_changed_only=False)\n     # Render a pipeline object\n     pipeline = make_pipeline(StandardScaler(), LogisticRegression(C=999))\n     expected = \"\"\"\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..7401826 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,9 +1,12 @@\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n import numpy as np\n \n from sklearn.utils.testing import assert_almost_equal, assert_array_equal\n+from sklearn.linear_model import LinearRegression\n+from sklearn.ensemble import RandomForestRegressor\n from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_equal\n from sklearn.utils.testing import assert_raise_message\n@@ -506,4 +509,32 @@ def test_transform():\n     assert_array_almost_equal(\n             eclf3.transform(X).swapaxes(0, 1).reshape((4, 6)),\n             eclf2.transform(X)\n-    )\n+    )\n+\n+\n+@pytest.mark.parametrize(\n+    \"X, y, voter\",\n+    [\n+        (datasets.load_iris(return_X_y=True), VotingClassifier(\n+            estimators=[\n+                ('lr', LogisticRegression()),\n+                ('rf', RandomForestClassifier(n_estimators=5))\n+            ]\n+        )),\n+        (datasets.make_classification(n_samples=50, n_features=5, random_state=1), VotingRegressor(\n+            estimators=[\n+                ('lr', LinearRegression()),\n+                ('rf', RandomForestRegressor(n_estimators=5))\n+            ]\n+        ))\n+    ]\n+)\n+def test_voting_none_estimator_with_weights(X_y, voter):\n+    X, y = X_y\n+    # Check that an estimator can be set to None while passing sample weights\n+    # Regression test for voting estimator with None estimator and weights\n+    voter.fit(X, y, sample_weight=np.ones(y.shape))\n+    voter.set_params(lr=None)\n+    voter.fit(X, y, sample_weight=np.ones(y.shape))\n+    y_pred = voter.predict(X)\n+    assert y_pred.shape == y.shape\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "diff --git a/sklearn/neighbors/tests/test_nca.py b/sklearn/neighbors/tests/test_nca.py\nindex 3963eca..1a3fb61 100644\n--- a/sklearn/neighbors/tests/test_nca.py\n+++ b/sklearn/neighbors/tests/test_nca.py\n@@ -511,8 +511,31 @@ def test_expected_transformation_shape():\n     nca.fit(X, y)\n     assert_equal(transformation_storer.transformation.size, X.shape[1]**2)\n \n+import pytest\n+import numpy as np\n+from sklearn.utils._testing import assert_raises, assert_raise_message\n+from sklearn.model_selection import GridSearchCV\n+from sklearn.pipeline import Pipeline\n+from sklearn.neighbors import NeighborhoodComponentsAnalysis\n+from sklearn.neighbors import KNeighborsClassifier\n+\n+def test_nca_gridsearch_parameter_types():\n+    # Test GridSearchCV with various parameter types and check for TypeError\n+    X = np.random.random_sample((100, 10))\n+    y = np.random.randint(2, size=100)\n+\n+    nca = NeighborhoodComponentsAnalysis()\n+    knn = KNeighborsClassifier()\n+\n+    pipe = Pipeline([('nca', nca), ('knn', knn)])\n+    params = {'nca__tol': [0.1, 0.5, 1],  # Include an integer\n+              'nca__n_components': np.arange(1, 10)}  # np.int64 values\n+    gs = GridSearchCV(estimator=pipe, param_grid=params, error_score='raise')\n \n-def test_convergence_warning():\n+    try:\n+        gs.fit(X, y)  # Should not raise an error\n+    except TypeError as e:\n+        pytest.fail(f\"GridSearchCV with NCA raised TypeError unexpectedly: {e}\")\n     nca = NeighborhoodComponentsAnalysis(max_iter=2, verbose=1)\n     cls_name = nca.__class__.__name__\n     assert_warns_message(ConvergenceWarning,\n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..10be691 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -680,6 +680,43 @@ def test_unicode_kernel():\n                                 random_seed=0)\n \n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for ZeroDivisionError in _sparse_fit when\n+    # support_vectors_ are empty.\n+    from scipy import sparse\n+    import numpy as np\n+    from sklearn import svm\n+    \n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    \n+    # Verify that no support vectors are left after training (edge case)\n+    assert model.support_.size == 0\n+    assert model.dual_coef_.shape[1] == 0\n+\n+def test_sparse_fit_no_zero_division():\n+    # Ensures that changing the sparsity level doesn't raise a division error.\n+    from scipy import sparse\n+    import numpy as np\n+    from sklearn import svm\n+    \n+    X_train = sparse.csr_matrix([[0, 0, 0, 0],\n+                                 [0, 0, 0, 0],\n+                                 [0, 0, 0, 0]])\n+    y_train = np.array([0.04, 0.04, 0.04])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    \n+    # Check that it doesn't crash and verify properties\n+    assert model.support_.size == 0\n+    assert model.dual_coef_.shape[1] == 0\n+\n+\n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n     sparse_gram = sparse.csr_matrix([[1, 0], [0, 1]])\n",
  "scikit-learn__scikit-learn-14983": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex dd52c66..15bb8f3 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -972,6 +972,24 @@ def test_leave_one_p_group_out_error_on_fewer_number_of_groups():\n                          LeavePGroupsOut(n_groups=3).split(X, y, groups))\n \n \n+import pytest\n+from sklearn.model_selection import RepeatedKFold, RepeatedStratifiedKFold\n+\n+@pytest.mark.parametrize(\"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold])\n+def test_repeated_cv_repr_default(RepeatedCV):\n+    # Test the default representation\n+    repeated_cv = RepeatedCV()\n+    default_repr = '{}(n_splits=5, n_repeats=10, random_state=None)'.format(repeated_cv.__class__.__name__)\n+    assert repr(repeated_cv) == default_repr\n+\n+@pytest.mark.parametrize(\"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold])\n+def test_repeated_cv_repr_custom(RepeatedCV):\n+    # Test the representation with custom initialization\n+    n_splits, n_repeats, random_state = 3, 7, 42\n+    repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats, random_state=random_state)\n+    custom_repr = '{}(n_splits=3, n_repeats=7, random_state=42)'.format(repeated_cv.__class__.__name__)\n+    assert repr(repeated_cv) == custom_repr\n+\n @ignore_warnings\n def test_repeated_cv_value_errors():\n     # n_repeats is not integer or <= 0\n",
  "scikit-learn__scikit-learn-15512": "",
  "scikit-learn__scikit-learn-15535": "",
  "scikit-learn__scikit-learn-25500": "",
  "scikit-learn__scikit-learn-25570": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex 23e3b97..9d6ce3b 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -2125,7 +2125,33 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n     ct.set_output(transform=\"pandas\")\n     X_trans_df0 = ct.fit_transform(X_df)\n     assert_array_equal(X_trans_df0.columns, expected_verbose_names)\n+    # Test handling of ColumnTransformer with empty feature sets\n+    @pytest.mark.parametrize(\n+        \"empty_features\",\n+        [[], np.array([False, False, False, False]), [False, False, False, False]],\n+        ids=[\"list\", \"ndarray\", \"list_of_bools\"]\n+    )\n+    def test_column_transformer_with_empty_features(empty_features):\n+        \"\"\"Check if the ColumnTransformer handles empty feature lists correctly.\"\"\"\n+        pd = pytest.importorskip(\"pandas\")\n+        X = pd.DataFrame(data=[[1.0, 2.0, 3.0, 4.0], [4.0, 2.0, 2.0, 5.0]],\n+                         columns=[\"a\", \"b\", \"c\", \"d\"])\n+        y = np.array([0, 1])\n+\n+        ct = ColumnTransformer(\n+            [\n+                ('empty_selector', 'passthrough', empty_features),\n+                ('numerical', RobustScaler(), [\"a\", \"b\", \"c\"]),\n+            ],\n+            remainder='drop',\n+            verbose_feature_names_out=True\n+        ).set_output(transform=\"pandas\")\n+\n+        X_out = ct.fit_transform(X)\n+        assert_array_equal(X_out.columns, [\"numerical__a\", \"numerical__b\", \"numerical__c\"])\n \n-    ct.set_params(verbose_feature_names_out=False)\n+        ct.set_params(verbose_feature_names_out=False)\n+        X_out = ct.fit_transform(X)\n+        assert_array_equal(X_out.columns, [\"a\", \"b\", \"c\"])\n     X_trans_df1 = ct.fit_transform(X_df)\n-    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n+    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n",
  "sphinx-doc__sphinx-10325": "diff --git a/tests/roots/test-ext-autodoc/target/inheritance.py b/tests/roots/test-ext-autodoc/target/inheritance.py\nindex ac389bf..04bc27b 100644\n--- a/tests/roots/test-ext-autodoc/target/inheritance.py\n+++ b/tests/roots/test-ext-autodoc/target/inheritance.py\n@@ -14,4 +14,10 @@ class Base(object):\n class Derived(Base):\n     def inheritedmeth(self):\n         # no docstring here\n-        pass\n+        pass\n+\n+\n+class MultiDerived(Base, list):\n+    def specificmeth(self):\n+        # no docstring here\n+        pass\n",
  "sphinx-doc__sphinx-7975": "diff --git a/tests/test_environment_indexentries.py b/tests/test_environment_indexentries.py\nindex 9775484..12e2306 100644\n--- a/tests/test_environment_indexentries.py\n+++ b/tests/test_environment_indexentries.py\n@@ -15,6 +15,22 @@ from sphinx.testing import restructuredtext\n \n \n @pytest.mark.sphinx('dummy', freshenv=True)\n+def test_symbols_index_issue(app):\n+    # Test to ensure symbols appear in a single \"Symbols\" section\n+    text = (\".. index:: @mention\\n\"\n+            \".. index:: \u00a3100\\n\"\n+            \".. index:: \u2190 arrow\\n\")\n+    restructuredtext.parse(app, text)\n+    index = IndexEntries(app.env).create_index(app.builder)\n+    \n+    # Because the entries @mention, \u00a3100, and \u2190 arrow are symbols, they should all appear together\n+    assert len(index) == 1\n+    assert index[0] == ('Symbols', [\n+        ('@mention', [[('', '#index-0')], [], None]),\n+        ('\u00a3100', [[('', '#index-1')], [], None]),\n+        ('\u2190 arrow', [[('', '#index-2')], [], None])\n+    ])\n+\n def test_create_single_index(app):\n     text = (\".. index:: docutils\\n\"\n             \".. index:: Python\\n\"\n",
  "sphinx-doc__sphinx-8435": "",
  "sphinx-doc__sphinx-8506": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 08bd595..58f73bd 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -91,6 +91,66 @@ def test_get_full_qualified_name():\n     assert domain.get_full_qualified_name(node) == 'ls.-l'\n \n \n+# Import necessary modules and functions for testing\n+from sphinx.testing.util import SphinxTestApp\n+from sphinx import addnodes\n+from sphinx.domains.std import StandardDomain\n+import restructuredtext_lint\n+from sphinx_testing import with_app\n+\n+def test_cmd_option_with_optional_value(app):\n+    text = \".. option:: -j[=N]\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (index,\n+                          [desc, ([desc_signature, ([desc_name, '-j'],\n+                                                    [desc_addname, '[=N]'])],\n+                                  [desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('-j', '-j', 'cmdoption', 'index', 'cmdoption-j', 1) in objects\n+\n+def test_cmd_option_starting_with_bracket(app):\n+    text = \".. option:: [enable=]PATTERN\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (index,\n+                          [desc, ([desc_signature, ([desc_name, '[enable'],\n+                                                    [desc_addname, '=]PATTERN'])],\n+                                  [desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('[enable', '[enable', 'cmdoption', 'index', 'cmdoption-arg-enable', 1) in objects\n+\n+# Test cases for more complex patterns\n+@with_app(buildername='html', srcdir='.')\n+def test_cmd_option_with_complex_patterns(app, status, warning):\n+    text1 = \".. option:: [start,[no-]stop]=VALUE\"\n+    doctree1 = restructuredtext.parse(app, text1)\n+    assert_node(doctree1, (index,\n+                          [desc, ([desc_signature, ([desc_name, '[start,[no-]stop'],\n+                                                    [desc_addname, '=VALUE'])],\n+                                  [desc_content, ()])]))\n+    objects1 = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('[start,[no-]stop', '[start,[no-]stop', 'cmdoption', 'index', 'cmdoption-arg-start', 1) in objects1\n+\n+    text2 = \".. option:: --range=[MIN:MAX]\"\n+    doctree2 = restructuredtext.parse(app, text2)\n+    assert_node(doctree2, (index,\n+                          [desc, ([desc_signature, ([desc_name, '--range'],\n+                                                    [desc_addname, '=[MIN:MAX]'])],\n+                                  [desc_content, ()])]))\n+    objects2 = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('--range', '--range', 'cmdoption', 'index', 'cmdoption-range', 1) in objects2\n+\n+# Test for handling unusual characters in options\n+@with_app(buildername='html', srcdir='.')\n+def test_unusual_characters_in_option(app, status, warning):\n+    text = \".. option:: --numb#ers@=COUNT%\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (index,\n+                          [desc, ([desc_signature, ([desc_name, '--numb#ers'],\n+                                                    [desc_addname, '@=COUNT%'])],\n+                                  [desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('--numb#ers@', '--numb#ers@', 'cmdoption', 'index', 'cmdoption-numbers', 1) in objects\n+\n def test_glossary(app):\n     text = (\".. glossary::\\n\"\n             \"\\n\"\n",
  "sphinx-doc__sphinx-8595": "",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..8ddad6f 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -15,6 +16,7 @@ from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tup\n \n import pytest\n \n+from struct import Struct\n from sphinx.util.typing import restify, stringify\n \n \n@@ -44,6 +46,7 @@ def test_restify():\n     assert restify(None) == \":obj:`None`\"\n     assert restify(Integral) == \":class:`numbers.Integral`\"\n     assert restify(Any) == \":obj:`Any`\"\n+    assert restify(Struct) == \":class:`struct.Struct`\"\n \n \n def test_restify_type_hints_containers():\n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..f80d237 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1457,8 +1457,32 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n :type param1: :class:`MyClass <name.space.MyClass>` instance\n \"\"\"\n         self.assertEqual(expected, actual)\n+    def test_other_parameters_section(self):\n+        # Test the behavior when napoleon_use_param is False\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+    An instance of MyClass\n \n-    def test_multiple_parameters(self):\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param2** (:class:`MyClass <name.space.MyClass>` instance)\n+    An instance of MyClass\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        # Test the behavior when napoleon_use_param is True\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param param2:\n+:type param2: :class:`MyClass <name.space.MyClass>` instance\n+    An instance of MyClass\n+\"\"\"\n+        self.assertEqual(expected, actual)\n         docstring = \"\"\"\\\n Parameters\n ----------\n",
  "sphinx-doc__sphinx-8721": "",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..e9c097a 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -321,6 +321,22 @@ def test_mul():\n         h2 = _af_rmuln(*a[:i + 1])\n         assert h == h2\n \n+def test_permutation_non_disjoint_cycles():\n+    # Test case for non-disjoint cycles that should compose into an identity permutation.\n+    p = Permutation([[0, 1], [0, 1]])\n+    assert p.array_form == [0, 1]  # Equivalent to identity permutation [0, 1]\n+\n+    # Another complex case with multiple overlapping cycles\n+    p = Permutation([[0, 1], [1, 2], [0, 1]])\n+    assert p.array_form == [1, 2, 0]  # Should be a valid permutation [1, 2, 0]\n+\n+    # A more comprehensive case to test the left-to-right cycle application\n+    p = Permutation([[0, 2], [0, 1], [1, 3]])\n+    assert p.array_form == [2, 3, 1, 0]  # Effective operations: (0, 2), (1, 3), then (0, 1)\n+    \n+    # Ensure order and identity cases are respected\n+    p = Permutation([[3, 2], [2, 3]])\n+    assert p.array_form == [0, 1, 2, 3]  # Should effectively result in an identity\n \n def test_args():\n     p = Permutation([(0, 3, 1, 2), (4, 5)])\n",
  "sympy__sympy-13031": "",
  "sympy__sympy-13471": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\nindex 0a3b6ce..7e60e60 100644\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -567,6 +567,11 @@ def test_Float_eval():\n     assert (a**2).is_Float\n \n \n+def test_Float_from_tuple():\n+    a = Float((0, '1L', 0, 1))\n+    b = Float((0, '1', 0, 1))\n+    assert a == b\n+\n def test_Float_issue_2107():\n     a = Float(0.1, 10)\n     b = Float(\"0.1\", 10)\n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..fd47b5e 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -273,6 +273,18 @@ def test_coth():\n     assert coth(k*pi*I) == -cot(k*pi)*I\n \n \n+from sympy import Symbol, coth, log, tan, I, pi\n+\n+def test_coth_log_tan_subs():\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+    # Testing the substitution for several integers which previously raised errors\n+    int_values_to_test = [2, 3, 5, 6, 8, 9, 11, 12, 13, 15, 18]\n+    for val in int_values_to_test:\n+        result = e.subs(x, val)\n+        assert result is not None  # Check that no exception is raised and a result is returned\n+        # Optionally, we could check against known correct outcomes if available\n+\n def test_coth_series():\n     x = Symbol('x')\n     assert coth(x).series(x, 0, 8) == \\\n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..06d8a41 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -201,7 +201,46 @@ def test_col_insert():\n         l.insert(i, 4)\n         assert flatten(zeros_Shaping(3).col_insert(i, c4).row(0).tolist()) == l\n \n-def test_extract():\n+def test_issue_13643():\n+    from sympy import eye, Matrix, ones\n+    \n+    M = eye(6)\n+    V = 2 * ones(6, 2)\n+    \n+    expected = Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    \n+    assert M.col_insert(3, V) == expected\n+\n+    # Additional test cases covering edge cases and other scenarios\n+\n+    # Test insertion at the start\n+    expected_start = Matrix([\n+        [2, 2, 1, 0, 0, 0, 0, 0],\n+        [2, 2, 0, 1, 0, 0, 0, 0],\n+        [2, 2, 0, 0, 1, 0, 0, 0],\n+        [2, 2, 0, 0, 0, 1, 0, 0],\n+        [2, 2, 0, 0, 0, 0, 1, 0],\n+        [2, 2, 0, 0, 0, 0, 0, 1]\n+    ])\n+    assert M.col_insert(0, V) == expected_start\n+\n+    # Test insertion at the end\n+    expected_end = Matrix([\n+        [1, 0, 0, 0, 0, 0, 2, 2],\n+        [0, 1, 0, 0, 0, 0, 2, 2],\n+        [0, 0, 1, 0, 0, 0, 2, 2],\n+        [0, 0, 0, 1, 0, 0, 2, 2],\n+        [0, 0, 0, 0, 1, 0, 2, 2],\n+        [0, 0, 0, 0, 0, 1, 2, 2]\n+    ])\n+    assert M.col_insert(6, V) == expected_end\n     m = ShapingOnlyMatrix(4, 3, lambda i, j: i*3 + j)\n     assert m.extract([0, 1, 3], [0, 1]) == Matrix(3, 2, [0, 1, 3, 4, 9, 10])\n     assert m.extract([0, 3], [0, 0, 2]) == Matrix(2, 3, [0, 0, 2, 9, 9, 11])\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..9ec3eb1 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -616,7 +616,20 @@ def test_latex_Range():\n     assert latex(Range(-2, -oo, -1)) == r'\\left\\{-2, -3, \\ldots, -\\infty\\right\\}'\n \n \n-def test_latex_sequences():\n+from sympy import symbols, oo, SeqFormula, InitPrinting as init_printing\n+init_printing()  # Ensure latex functionality is initialized\n+\n+def test_seqformula_brackets():\n+    n = symbols('n')\n+    seq = SeqFormula(n**2, (n, 0, oo))\n+    \n+    # Test the original incorrect escaping behavior\n+    incorrect_latex_str = r'\\left\\[0, 1, 4, 9, \\ldots\\right\\]'\n+    assert latex(seq) != incorrect_latex_str\n+\n+    # Test the expected correct behavior without escaped brackets\n+    correct_latex_str = r'\\left[0, 1, 4, 9, \\ldots\\right]'\n+    assert latex(seq) == correct_latex_str\n     s1 = SeqFormula(a**2, (0, oo))\n     s2 = SeqPer((1, 2))\n \n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..f47ca8f 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +7,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n",
  "sympy__sympy-14774": "",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..dbf6c96 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6111,6 +6111,29 @@ u(\"\"\"\\\n     assert upretty((1/y)*e.j) == ucode_str\n \n \n+from sympy import MatrixSymbol, pretty, symbols\n+from sympy.abc import a, n\n+\n+def test_pretty_MatAdd():\n+    # issue #14814\n+    x = MatrixSymbol('x', n, n)\n+    y_star = MatrixSymbol('y*', n, n)\n+\n+    # This should pretty print as \"x + y*\" without raising an error\n+    assert pretty(x + y_star) == \"x + y*\"\n+    # Additional case testing operations involving negative coefficients\n+    assert pretty(-a*x + -2*y_star*y_star) == \"-a*x -2*y**y*\"\n+    \n+    # Test with more complex expressions to ensure robustness\n+    z = MatrixSymbol('z', n, n)\n+    assert pretty(x + y_star + z) == \"x + y* + z\"\n+    assert pretty(-a*x + y_star*z) == \"-a*x + y* * z\"\n+    assert pretty(-x - y_star - z) == \"-x - y* - z\"\n+\n+    # Test involving matrix multiplication with special characters\n+    assert pretty(x*y_star + z) == \"x*y* + z\"\n+    assert pretty(y_star*x - z) == \"y* * x - z\"\n+\n def test_MatrixSymbol_printing():\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..1617da2 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -720,6 +720,31 @@ def test_dummification():\n     lam = lambdify((F(t), G(t)), some_expr)\n     assert lam(3, 9) == 2\n     lam = lambdify(sin(t), 2 * sin(t)**2)\n+\n+def test_curly_matrix_symbol_issue():\n+    import sympy as sy\n+    from sympy import MatrixSymbol, symbols\n+\n+    # Testing MatrixSymbol with curly braces in variable name\n+    curlyv = MatrixSymbol(\"{v}\", 2, 1)\n+    curlyx = symbols(\"{x}\")\n+\n+    # Test lambdify without dummify\n+    lam1 = lambdify(curlyv, curlyv)\n+    assert lam1([1, 1]) == [1, 1]  # Ensure no SyntaxError\n+    lam2 = lambdify(curlyx, curlyx)\n+    assert lam2(1) == 1  # Ensure no SyntaxError\n+\n+    # Test lambdify with dummify=True\n+    lam3 = lambdify(curlyv, curlyv, dummify=True)\n+    assert lam3([1, 1]) == [1, 1]  # Ensure correct behavior\n+    lam4 = lambdify(curlyx, curlyx, dummify=True)\n+    assert lam4(1) == 1  # Ensure correct behavior\n+\n+    # Additional test case with other characters\n+    specialv = MatrixSymbol(\"[v]\", 2, 1)\n+    lam5 = lambdify(specialv, specialv)\n+    assert lam5([2, 2]) == [2, 2]\n     assert lam(F(t)) == 2 * F(t)**2\n     #Test that \\alpha was properly dummified\n     lam = lambdify((alpha, t), 2*alpha + t)\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..7eaf694 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..7cfa987 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1717,6 +1717,17 @@ def test_issue_13651():\n     assert latex(expr) == r\"c - \\left(a + b\\right)\"\n \n \n+from sympy import symbols, MatrixSymbol, latex\n+\n+...\n+\n+def test_indexed_matrix_expression_latex():\n+    # Test case for verifying the fix of indexed matrix-expression LaTeX printing\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n+\n def test_latex_UnevaluatedExpr():\n     x = symbols(\"x\")\n     he = UnevaluatedExpr(1/x)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..6f553cb 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, exp, Eq\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -20,8 +21,22 @@ def test_idiff():\n     assert True in [sol.diff(x, 3).equals(explicit) for sol in solve(circ, y)]\n     assert idiff(x + t + y, [y, t], x) == -Derivative(t, x) - 1\n \n-\n-def test_intersection():\n+def test_idiff_extended():\n+    x = Symbol('x', real=True)\n+    y = Symbol('y', real=True)\n+    f = Function('f')\n+    g = Function('g')\n+\n+    # Testing the Eq support by using equation objects\n+    assert idiff(Eq(y*exp(y), x*exp(x)), y, x).simplify() == (x + 1)*exp(x - y)/(y + 1)\n+    \n+    # Testing the support for function notation f(x)\n+    assert idiff(f(x)*exp(f(x)) - x*exp(x), f(x), x).simplify() == (x + 1) * exp(x - f(x))/(f(x) + 1)\n+\n+    # Additional test cases for idiff with different function derivative structure\n+    assert idiff(f(x) - y * exp(x), [f(x), y], x) == (y + Derivative(y, x)) * exp(x)\n+    assert idiff(f(x) - y * exp(x), [y, f(x)], x) == -y + exp(-x) * Derivative(f(x), x)\n+    assert idiff(f(x) - g(x), [f(x), g(x)], x) == Derivative(g(x), x)\n     assert intersection(Point(0, 0)) == []\n     raises(TypeError, lambda: intersection(Point(0, 0), 3))\n     assert intersection(\n",
  "sympy__sympy-16792": "",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..044c83c 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -339,6 +339,25 @@ def test_intersection():\n \n     assert Intersection(S.Complexes, FiniteSet(S.ComplexInfinity)) == S.EmptySet\n \n+    # Test cases for issue: Intersection should remove duplicates\n+    x = Symbol('x')\n+    \n+    # Checking intersections with duplicates\n+    assert Intersection({1}, {1}, {x}) == Intersection({1}, {x})\n+    assert Intersection({1}, {1, x}) == Intersection({1}, {x})\n+    \n+    # Verifying the issue statement with symbolic and numeric elements\n+    assert Intersection({1}, {1}, {x}).contains(1) == Eq(x, 1)\n+    assert Intersection({1}, {1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    \n+    # With direct numeric and symbolic comparison\n+    assert Intersection({1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    assert Intersection({1}, {x, 1}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    \n+    # Ensure correct ordering and removal\n+    assert Intersection({x, 1}, {1, x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    assert Intersection({x, 1, 2}, {1, x, 2}) == Intersection({1, 2}, {x})\n+\n     # issue 12178\n     assert Intersection() == S.UniversalSet\n \n",
  "sympy__sympy-17022": "diff --git a/sympy/printing/tests/test_numpy.py b/sympy/printing/tests/test_numpy.py\nindex fa5ed1f..0c1fb08 100644\n--- a/sympy/printing/tests/test_numpy.py\n+++ b/sympy/printing/tests/test_numpy.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Piecewise, lambdify, Equality, Unequality, Sum, Mod, cbrt, sqrt,\n     MatrixSymbol, BlockMatrix\n@@ -26,6 +27,21 @@ def test_numpy_piecewise_regression():\n     assert NumPyPrinter().doprint(p) == 'numpy.select([numpy.less(x, 0),True], [1,0], default=numpy.nan)'\n \n \n+def test_issue_17006():\n+    if not np:\n+        skip(\"NumPy not installed\")\n+\n+    M = MatrixSymbol(\"M\", 2, 2)\n+    f = lambdify(M, M + Identity(2), 'numpy')\n+    ma = np.array([[1, 2], [3, 4]])\n+    mr = np.array([[2, 2], [3, 5]])\n+    assert (f(ma) == mr).all()\n+\n+    from sympy import symbols\n+    n = symbols('n', integer=True)\n+    N = MatrixSymbol(\"M\", n, n)\n+    raises(NotImplementedError, lambda: lambdify(N, N + Identity(n)))\n+\n def test_sum():\n     if not np:\n         skip(\"NumPy not installed\")\n",
  "sympy__sympy-17139": "",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..70137bf 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,12 +1,28 @@\n+\n from sympy import I, Rational, Symbol, pi, sqrt, S\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n+from sympy import sympify\n from sympy.geometry.entity import rotate, scale, translate\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.pytest import raises, warns\n \n-\n-def test_point():\n+def test_geometry_point_multiplication():\n+    # Test multiplication of Point2D with scalar in both orders\n+    p1 = Point2D(0, 0)\n+    p2 = Point2D(1, 1)\n+    scalar = sympify(2.0)\n+    \n+    # Test the expected behavior for both multiplication orders\n+    assert p1 + p2 * scalar == Point2D(2, 2), \"Multiplication with scalar after point failed\"\n+    assert p1 + scalar * p2 == Point2D(2, 2), \"Multiplication with scalar before point failed\"\n+\n+    # Test multiplication of Point3D with scalar in both orders\n+    p3_1 = Point3D(0, 0, 0)\n+    p3_2 = Point3D(1, 1, 1)\n+    \n+    assert p3_1 + p3_2 * scalar == Point3D(2, 2, 2), \"Multiplication with scalar after point failed for Point3D\"\n+    assert p3_1 + scalar * p3_2 == Point3D(2, 2, 2), \"Multiplication with scalar before point failed for Point3D\"\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..6260204 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1899,7 +1899,29 @@ def test_expr():\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n \n \n-def test_ExprBuilder():\n+from sympy import Symbol, symbols\n+from sympy.core.sympify import SympifyError\n+import pytest\n+\n+def test_equivalence_handling():\n+    # Define a custom class with a misleading repr\n+    class misleadingC:\n+        def __repr__(self):\n+            return 'x.y'\n+\n+    class reprAsSymbol:\n+        def __repr__(self):\n+            return 'x'\n+    \n+    x = Symbol('x')\n+    \n+    # Test that sympy does not evaluate the repr\n+    with pytest.raises(SympifyError):\n+        _ = sympy.Sympify(x == misleadingC())\n+    \n+    # Correct behavior for repr that matches Symbol name\n+    assert (x == reprAsSymbol()) is False\n+    assert (x != reprAsSymbol()) is True\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..b03a7d8 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -553,8 +553,19 @@ def test_diophantine():\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n     assert diophantine((y**2-x), t) == set([(t**2, -t)])\n \n-\n-def test_general_pythagorean():\n+def test_syms_order_with_permute_true():\n+    from sympy.solvers.diophantine import diophantine\n+    from sympy.abc import m, n\n+\n+    # Test the original issue case with specific symbol ordering\n+    eq = n**4 + m**4 - 2**4 - 3**4\n+    \n+    # Case 1: This should return all permutations of base solutions along with sign changes\n+    expected_result = {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n+    assert diophantine(eq, syms=(m, n), permute=True) == expected_result\n+    \n+    # Case 2: This should also return the same set irrespective of the order of symbols\n+    assert diophantine(eq, syms=(n, m), permute=True) == expected_result\n     from sympy.abc import a, b, c, d, e\n \n     assert check_solutions(a**2 + b**2 + c**2 - d**2)\n",
  "sympy__sympy-18532": "diff --git a/sympy/codegen/tests/test_cnodes.py b/sympy/codegen/tests/test_cnodes.py\nindex c30dccd..c33ff77 100644\n--- a/sympy/codegen/tests/test_cnodes.py\n+++ b/sympy/codegen/tests/test_cnodes.py\n@@ -1,6 +1,7 @@\n+\n from sympy.core.symbol import symbols\n from sympy.printing.ccode import ccode\n-from sympy.codegen.ast import Declaration, Variable, float64, int64\n+from sympy.codegen.ast import Declaration, Variable, float64, int64, String, Basic\n from sympy.codegen.cnodes import (\n     alignof, CommaOperator, goto, Label, PreDecrement, PostDecrement, PreIncrement, PostIncrement,\n     sizeof, union, struct\n@@ -66,8 +67,14 @@ def test_sizeof():\n     assert ccode(sz) == 'sizeof(%s)' % typename\n     assert sz.func(*sz.args) == sz\n     assert not sz.is_Atom\n+    # Original test case\n     assert all(atom == typename for atom in sz.atoms())\n \n+    # New test case: ensure atoms() returns objects with no args, not subclasses of Atom\n+    assert sz.atoms() == {String('unsigned int'), String('sizeof')}\n+    b21 = Basic()  # Example with Basic which has no args\n+    assert b21.atoms() == set()\n+\n \n def test_struct():\n     vx, vy = Variable(x, type=float64), Variable(y, type=float64)\n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..ac922b1 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,28 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_single_element_BlockDiagMatrix_conversion():\n+    from sympy import Matrix, BlockDiagMatrix\n+\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    B = Matrix(D)\n+    assert B == M\n+\n+def test_multiple_element_BlockDiagMatrix_conversion():\n+    from sympy import Matrix, BlockDiagMatrix\n+\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M, M)\n+    B = Matrix(D)\n+    expected_result = Matrix([\n+        [1, 2, 0, 0],\n+        [3, 4, 0, 0],\n+        [0, 0, 1, 2],\n+        [0, 0, 3, 4]\n+    ])\n+    assert B == expected_result\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..ab7e3d0 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -199,8 +199,23 @@ def test_im():\n \n     X = FunctionMatrix(3, 3, Lambda((n, m), n + m*I))\n     assert im(X) == Matrix([[0, 1, 2], [0, 1, 2], [0, 1, 2]])\n+from sympy import Abs, sign, Symbol, Piecewise, I, Eq\n \n def test_sign():\n+    # Test case for rewriting sign in terms of Abs\n+    x = Symbol('x')\n+    assert sign(x).rewrite(Abs) == Piecewise((0, Eq(x, 0)), (x/Abs(x), True))\n+\n+    y = Symbol('y', real=True)\n+    assert sign(y).rewrite(Abs) == Piecewise((0, Eq(y, 0)), (y/Abs(y), True))\n+\n+    pos_x = Symbol('pos_x', positive=True)\n+    assert sign(pos_x).rewrite(Abs) == pos_x/Abs(pos_x)\n+\n+    neg_x = Symbol('neg_x', negative=True)\n+    assert sign(neg_x).rewrite(Abs) == neg_x/Abs(neg_x)\n+\n+    assert sign(0).rewrite(Abs) == 0  # Ensure that sign(0) still equals 0 after rewrite\n     assert sign(1.2) == 1\n     assert sign(-1.2) == -1\n     assert sign(3*I) == I\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..7724b58 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -480,6 +480,11 @@ def test_partitions():\n         assert list(partitions(6, 2, None, size=i)) != ans[i]\n         assert list(partitions(6, None, 2, size=i)) != ans[i]\n         assert list(partitions(6, 2, 0, size=i)) == ans[i]\n+        \n+    # Check that partitions do not reuse dictionary objects\n+    first_set = [id(p) for p in partitions(6, k=2)]\n+    second_set = [id(p) for p in partitions(6, k=2)]\n+    assert first_set != second_set, \"Partitions are reusing the same dictionary object.\"\n \n     assert [p.copy() for p in partitions(6, k=2)] == [\n         {2: 3}, {1: 2, 2: 2}, {1: 4, 2: 1}, {1: 6}]\n",
  "sympy__sympy-20212": "diff --git a/sympy/core/tests/test_power.py b/sympy/core/tests/test_power.py\nindex 686973b..798fbe1 100644\n--- a/sympy/core/tests/test_power.py\n+++ b/sympy/core/tests/test_power.py\n@@ -244,7 +244,7 @@ def test_power_rewrite_exp():\n \n     assert ((-2)**S(-5)).rewrite(exp) == (-2)**S(-5)\n \n-    x, y = symbols('x y')\n+    from sympy import symbols, oo, S, pow\n     assert (x**y).rewrite(exp) == exp(y*log(x))\n     assert (7**x).rewrite(exp) == exp(x*log(7), evaluate=False)\n     assert ((2 + 3*I)**x).rewrite(exp) == exp(x*(log(sqrt(13)) + I*atan(Rational(3, 2))))\n@@ -254,6 +254,11 @@ def test_power_rewrite_exp():\n                     (sin, cos, tan, sec, csc, sinh, cosh, tanh))\n \n \n+def test_issue_19572():\n+    # Test for 0**-oo returning zoo as expected\n+    assert pow(0, -oo) == S.ComplexInfinity\n+    assert (0 ** -oo) == S.ComplexInfinity\n+\n def test_zero():\n     x = Symbol('x')\n     y = Symbol('y')\n",
  "sympy__sympy-20442": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 6a8906d..c8743ea 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (Abs, Add, Function, Number, Rational, S, Symbol,\n                    diff, exp, integrate, log, sin, sqrt, symbols)\n from sympy.physics.units import (amount_of_substance, convert_to, find_unit,\n@@ -46,7 +47,29 @@ def test_convert_to():\n     assert speed_of_light.convert_to(m) == speed_of_light\n \n \n-def test_Quantity_definition():\n+from sympy.physics.units.definitions import joule\n+from sympy import simplify\n+\n+def test_convert_to_orthogonal_units():\n+    # Test converting an expression with orthogonal units to a single unit\n+    expr = joule * second\n+    # Conversion to joule should ideally return the original expr or raise an error\n+    converted_expr = convert_to(expr, joule)\n+    assert converted_expr == expr or raises(TypeError, lambda: convert_to(expr, joule))\n+\n+    # Test conversion to the original unit\n+    assert convert_to(expr, joule * second) == joule * second\n+\n+    # Test to a compatible unit combination in base units\n+    assert simplify(convert_to(expr, kg * meter**2 / second)) == kg * meter**2 / second\n+\n+    # Test conversion that results in a fractional unit should fail or return original expression\n+    converted_expr = convert_to(expr, [joule])\n+    assert converted_expr == expr or raises(TypeError, lambda: convert_to(expr, [joule]))\n+\n+    # Test conversion to time unit (minute), should return minutes representation\n+    converted_expr = convert_to(expr, minute)\n+    assert simplify(converted_expr) == expr * (minute / second)\n     q = Quantity(\"s10\", abbrev=\"sabbr\")\n     q.set_global_relative_scale_factor(10, second)\n     u = Quantity(\"u\", abbrev=\"dam\")\n",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..7019c1b 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -28,6 +28,14 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+from sympy import Symbol\n+from pytest import raises\n+\n+def test_symbol_dict_and_slots():\n+    s = Symbol('x')\n+    assert not hasattr(s, '__dict__'), \"Symbol instance should not have a __dict__ attribute\"\n+    assert hasattr(s, '__slots__') and s.__slots__ == ('name',), \"Symbol instance must have __slots__ attribute with ('name',)\"\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..4ce530e 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n                    atan, atan2, nan, Symbol, re, im, sign)\n from sympy.abc import w, x, y, z\n@@ -5,8 +6,19 @@ from sympy.core.relational import Eq, Ne\n from sympy.functions.elementary.piecewise import Piecewise\n from sympy.matrices.expressions.matexpr import MatrixSymbol\n \n+def test_issue_refine_complex_arguments():\n+    # Test that refine can simplify arg() when assuming a is positive\n+    a = Symbol('a', positive=True)\n+    assert refine(arg(a), Q.positive(a)) == 0  # arg(a) should be 0 since a is real and positive\n+\n+    # Test arg() with a negative real number\n+    b = Symbol('b', negative=True)\n+    assert refine(arg(b), Q.negative(b)) == pi  # arg(b) should be pi since b is real and negative\n \n-def test_Abs():\n+    # Test with complex symbols\n+    c = Symbol('c', complex=True)\n+    assert refine(arg(c), Q.positive(c)) == 0\n+    assert refine(arg(c), Q.negative(c)) == pi\n     assert refine(Abs(x), Q.positive(x)) == x\n     assert refine(1 + Abs(x), Q.positive(x)) == 1 + x\n     assert refine(Abs(x), Q.negative(x)) == -x\n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..1ec55dc 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -7,8 +8,50 @@ from sympy import (\n from sympy.core.basic import _aresame\n from sympy.testing.pytest import XFAIL\n from sympy.abc import a, x, y, z, t\n-\n-def test_subs():\n+from sympy import sinh, exp, Piecewise\n+def test_issue_21373():\n+    # Recreate the scenarios described in the issue\n+    x_r, y_r, z_r = symbols('x_r y_r z_r', real=True)\n+    \n+    # Expression with sinh and Piecewise; it should not raise an error\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    \n+    # Perform the substitution and ensure no PolynomialError is raised\n+    try:\n+        res = expr.subs({1: 1.0})\n+        assert res == expr.subs({1: 1.0})  # Assert that the substitution works as expected\n+    except Exception as e:\n+        assert False, f\"Unexpected exception occurred: {e}\"\n+    \n+    # Additional tests for related hyperbolic functions mentioned in the issue\n+    expr_cosh = exp(cosh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    expr_tanh = exp(tanh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    \n+    try:\n+        res_cosh = expr_cosh.subs({1: 1.0})\n+        assert res_cosh == expr_cosh.subs({1: 1.0})\n+    except Exception as e:\n+        assert False, f\"Unexpected exception with cosh: {e}\"\n+    \n+    try:\n+        res_tanh = expr_tanh.subs({1: 1.0})\n+        assert res_tanh == expr_tanh.subs({1: 1.0})\n+    except Exception as e:\n+        assert False, f\"Unexpected exception with tanh: {e}\"\n+\n+    # Expressions without division to confirm other correct behaviors\n+    expr_no_div = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True))))\n+    try:\n+        res_no_div = expr_no_div.subs({1: 1.0})\n+        assert res_no_div == expr_no_div.subs({1: 1.0})\n+    except Exception as e:\n+        assert False, f\"Unexpected exception without division: {e}\"\n+\n+    # Confirm that clearing cache and rerunning does not affect result\n+    from sympy.core.cache import clear_cache\n+    clear_cache()\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr.subs({1: 1.0}) == expr.subs({1: 1.0})  # No error\n     n3 = Rational(3)\n     e = x\n     e = e.subs(x, n3)\n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..14ceb4f 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,8 +1,10 @@\n+\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n from sympy.core.numbers import pi, zoo, I, AlgebraicNumber\n from sympy.core.singleton import S\n+from sympy.core.function import Derivative\n from sympy.core.symbol import Symbol\n from sympy.integrals.integrals import Integral\n from sympy.matrices import (Matrix, SparseMatrix, ImmutableMatrix,\n@@ -39,6 +41,12 @@ def test_Integral_kind():\n     assert Integral(comm_x, comm_x).kind is NumberKind\n     assert Integral(A, comm_x).kind is MatrixKind(NumberKind)\n \n+def test_Derivative_kind():\n+    A = MatrixSymbol('A', 2,2)\n+    # Test if the Derivative of a MatrixSymbol respects the kind hierarchy\n+    assert Derivative(comm_x, comm_x).kind is NumberKind\n+    assert Derivative(A, comm_x).kind is MatrixKind(NumberKind)\n+\n def test_Matrix_kind():\n     classes = (Matrix, SparseMatrix, ImmutableMatrix, ImmutableSparseMatrix)\n     for cls in classes:\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..56c04c4 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -131,7 +131,10 @@ def test_monomials():\n     assert set(itermonomials([x, y], [2, 2])) == \\\n             {S.One, y**2, x*y**2, x, x*y, x**2, x**2*y**2, y, x**2*y}\n \n-    i, j, k = symbols('i j k', commutative=False)\n+    # Issue-specific test cases\n+    assert set(itermonomials([x1, x2, x3], 3, 3)) == {x1**3, x2**3, x3**3, x1*x2**2, x1**2*x3, x1*x3**2, x2**2*x3, x2*x3**2, x2**2*x1, x3**2*x1, x3**2*x2, x1*x2*x3}\n+    assert set(itermonomials([x1, x2, x3], 4, 3)) == {x1**3, x2**3, x3**3, x1*x2**2, x1**2*x3, x1*x3**2, x2**2*x3, x2*x3**2, x2**2*x1, x3**2*x1, x3**2*x2, x1*x2*x3,\n+                                                     x1**4, x2**4, x3**4, x1**2*x2, x2**2*x3, x3**2*x3, x1*x2*x3**2, x1*x2**3, x1**2*x2*x3}\n     assert set(itermonomials([i, j, k], [0, 0, 0])) == {S.One}\n     assert set(itermonomials([i, j, k], [0, 0, 1])) == {1, k}\n     assert set(itermonomials([i, j, k], [0, 1, 0])) == {1, j}\n",
  "sympy__sympy-22005": "",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..a4363e0 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n@@ -9,6 +10,7 @@ from sympy.geometry.entity import rotate, scale, translate, GeometryEntity\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.misc import Undecidable\n+from sympy.core.parameters import evaluate\n from sympy.testing.pytest import raises, warns\n \n \n@@ -440,6 +442,20 @@ def test_unit():\n     assert Point(1, 1).unit == Point(sqrt(2)/2, sqrt(2)/2)\n \n \n+def test_issue_22684():\n+    # This test checks if Point2D works inside evaluate(False) without errors\n+    with evaluate(False):\n+        p = Point2D(1, 2)\n+    assert p.x == 1\n+    assert p.y == 2\n+\n+def test_Point2D_no_imaginary_error():\n+    # Verifying that there's no error with imaginary coordinates\n+    with evaluate(False):\n+        raises(ValueError, lambda: Point2D(1 + I, 2))\n+        raises(ValueError, lambda: Point2D(1, 2 + I))\n+        raises(ValueError, lambda: Point2D(1 + I, 2 + I))\n+\n def test_dot():\n     raises(TypeError, lambda: Point(1, 2).dot(Line((0, 0), (1, 1))))\n \n",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..6648c4d 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -339,6 +339,22 @@ def test_cse_Indexed():\n \n \n def test_cse_MatrixSymbol():\n+    from sympy import cse, MatrixSymbol\n+    \n+    # MatrixSymbols have non-Basic args, so make sure that works\n+    A = MatrixSymbol(\"A\", 3, 3)\n+    assert cse(A) == ([], [A])\n+\n+    # Additional test cases to address the issue of strange behavior\n+    assert cse(A[0, 0] * A[0, 1] + A[0, 1] * A[0, 2]) == ([(x0, A[0, 1])], [A[0, 0] * x0 + x0 * A[0, 2]])\n+    \n+    n = symbols('n', integer=True)\n+    B = MatrixSymbol(\"B\", n, n)\n+    assert cse(B) == ([], [B])\n+    \n+    # Check if cse correctly identifies subexpressions with matrix symbols\n+    assert cse(A[0] * A[0]) == ([], [A[0] * A[0]])\n+    assert cse(A[0, 0] * A[0, 1] + A[0, 0] * A[0, 1] * A[0, 2]) == ([(x0, A[0, 0] * A[0, 1])], [x0 * A[0, 2] + x0])\n     # MatrixSymbols have non-Basic args, so make sure that works\n     A = MatrixSymbol(\"A\", 3, 3)\n     assert cse(A) == ([], [A])\n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..5b6a04e 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -17,8 +18,16 @@ array_types = [\n     MutableSparseNDimArray\n ]\n \n-\n-def test_array_negative_indices():\n+def test_issue_sympy_array_empty():\n+    \"\"\"\n+    Testing issue where sympy.Array([]) fails.\n+    Verify that empty arrays can be constructed.\n+    \"\"\"\n+    for array_type in array_types:\n+        A = array_type([])\n+        assert isinstance(A, array_type), f\"Expected type {array_type} but got {type(A)}\"\n+        assert A.shape == (0,), \"Expected shape (0,) for an empty array\"\n+        assert list(A) == [], \"Expected an empty list for an empty array representation\"\n     for ArrayType in array_types:\n         test_array = ArrayType([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n         assert test_array[:, -1] == Array([5, 10])\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..0f25bad 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,7 +1175,22 @@ def test_scipy_polys():\n \n \n \n-def test_lambdify_inspect():\n+def test_lambdify_single_element_tuple():\n+    # Verifying that the output generates a tuple with a single element correctly\n+    f2b = lambdify([], (1,))  # From the original test patch\n+    assert f2b() == (1,)\n+    \n+    # Ensuring the source code is as expected with the trailing comma\n+    source_code = inspect.getsource(lambdify([], (1,)))\n+    expected_output = 'def _lambdifygenerated():\\n    return (1,)\\n'\n+    assert source_code == expected_output\n+\n+    # Ensuring that tuples with multiple elements are unaffected\n+    f_multiple = lambdify([], (1, 2))\n+    assert f_multiple() == (1, 2)\n+    source_code_multiple = inspect.getsource(lambdify([], (1, 2)))\n+    expected_output_multiple = 'def _lambdifygenerated():\\n    return (1, 2)\\n'\n+    assert source_code_multiple == expected_output_multiple\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n     # details\n",
  "sympy__sympy-24066": "",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..0cd60d4 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -46,6 +46,24 @@ def test_tensor_product_expand():\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n \n+def test_tensor_product_issue_expansion():\n+    assert TP(2*U - V, U + V).expand(tensorproduct=True) == \\\n+        2*TP(U, U) + 2*TP(U, V) - TP(V, U) - TP(V, V)\n+    assert TP(U - U, U + V).expand(tensorproduct=True) == \\\n+        TP(0, U) + TP(0, V)  # Should expand to zero tensor product\n+\n+    # Tests for modified code fix with combinations of scalars and tensor products\n+    assert TP(3*A, B - C).expand(tensorproduct=True) == \\\n+        3*TP(A, B) - 3*TP(A, C)\n+    assert TP(2*(A + B), C).expand(tensorproduct=True) == \\\n+        2*TP(A, C) + 2*TP(B, C)\n+\n+    # Test nesting of tensor products with scalars\n+    assert TP(A, TP(2*B, C)).expand(tensorproduct=True) == \\\n+        2*TP(A, B, C)\n+    assert TP(2*A, TP(B, C + D)).expand(tensorproduct=True) == \\\n+        2*TP(A, B, C) + 2*TP(A, B, D)\n+\n def test_tensor_product_commutator():\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n         TP(A*B, C) - TP(B*A, C)\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..78f613a 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -9,6 +10,8 @@ from sympy.functions.elementary.complexes import Abs\n from sympy.functions.elementary.exponential import (exp, log)\n from sympy.functions.elementary.miscellaneous import sqrt\n from sympy.functions.elementary.trigonometric import sin\n+from sympy.physics.units import Quantity, time, velocity, acceleration, second, meter\n+from sympy.physics.units.systems.si import SI\n from sympy.integrals.integrals import integrate\n from sympy.physics.units import (amount_of_substance, area, convert_to, find_unit,\n                                  volume, kilometer, joule, molar_gas_constant,\n@@ -562,7 +565,45 @@ def test_issue_24062():\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n \n-def test_prefixed_property():\n+def test_issue_24211():\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+    \n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+    \n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+    \n+    expr1 = a1 * t1 + v1\n+    try:\n+        SI._collect_factor_and_dimension(expr1)\n+        print(\"Test passed: No ValueError raised.\")\n+    except ValueError as e:\n+        print(\"Test failed: ValueError was raised\", e)\n+\n+    # Adding a similar test with different values\n+    V2 = Quantity('V2')\n+    SI.set_quantity_dimension(V2, velocity)\n+    SI.set_quantity_scale_factor(V2, 3 * meter / second)\n+\n+    A2 = Quantity('A2')\n+    SI.set_quantity_dimension(A2, acceleration)\n+    SI.set_quantity_scale_factor(A2, 4 * meter / second**2)\n+\n+    T2 = Quantity('T2')\n+    SI.set_quantity_dimension(T2, time)\n+    SI.set_quantity_scale_factor(T2, 2 * second)\n+\n+    expr2 = A2 * T2 - V2\n+    try:\n+        SI._collect_factor_and_dimension(expr2)\n+        print(\"Test passed: No ValueError raised.\")\n+    except ValueError as e:\n+        print(\"Test failed: ValueError was raised\", e)\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..3ecea2f 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, milli\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n@@ -27,6 +28,10 @@ def test_prefix_operations():\n     assert k / dodeca == S(1000) / 12\n     assert dodeca / dodeca == 1\n \n+    # Test the issue with milli prefix and Watt unit\n+    assert milli * W == W / 1000  # milliWatt should be 0.001 Watt\n+    assert W * milli == W / 1000  # Check both commutative multiplications\n+\n     m = Quantity(\"fake_meter\")\n     SI.set_quantity_dimension(m, S.One)\n     SI.set_quantity_scale_factor(m, S.One)\n",
  "django__django-12470": "diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py\nindex 067de1c..da0c6e5 100644\n--- a/tests/model_inheritance/tests.py\n+++ b/tests/model_inheritance/tests.py\n@@ -7,7 +7,7 @@ from django.test.utils import CaptureQueriesContext, isolate_apps\n \n from .models import (\n     Base, Chef, CommonInfo, GrandChild, GrandParent, ItalianRestaurant,\n-    MixinModel, ParkingLot, Place, Post, Restaurant, Student, SubBase,\n+    Child, MixinModel, ParkingLot, Place, Post, Restaurant, Student, SubBase,\n     Supplier, Title, Worker,\n )\n \n@@ -204,6 +204,26 @@ class ModelInheritanceTests(TestCase):\n \n         self.assertEqual(A.attr.called, (A, 'attr'))\n \n+    def test_inherited_ordering_pk_desc(self):\n+        \"\"\"Test that a Child model inherits ordering by '-pk' from Parent.\"\"\"\n+        parent1 = Parent.objects.create(first_name='John', last_name='Doe', email='john.doe@example.com')\n+        parent2 = Parent.objects.create(first_name='Jane', last_name='Doe', email='jane.doe@example.com')\n+        \n+        # Create Child instances using the created Parent instances\n+        child1 = Child.objects.create(id=parent1.id)  # To sync with parent's pk\n+        child2 = Child.objects.create(id=parent2.id)\n+\n+        # Query all Child instances and check their order\n+        qs = Child.objects.all()\n+        self.assertSequenceEqual(qs, [child2, child1])  # Check expected order by '-pk'\n+\n+        # Verify the query has the correct ORDER BY clause\n+        expected_order_by_sql = 'ORDER BY %s.%s DESC' % (\n+            connection.ops.quote_name(Parent._meta.db_table),\n+            connection.ops.quote_name('id'),\n+        )\n+        self.assertIn(expected_order_by_sql, str(qs.query))\n+\n \n class ModelInheritanceDataTests(TestCase):\n     @classmethod\n",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..2ec7445 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,6 +343,35 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n+    def test_self_referencing_foreign_key_order(self):\n+        # Create instances of OneModel\n+        one1 = OneModel.objects.create(root=None, oneval=1)\n+        one2 = OneModel.objects.create(root=one1, oneval=2)\n+        one3 = OneModel.objects.create(root=one2, oneval=3)\n+        \n+        # Create corresponding instances of TwoModel\n+        two1 = TwoModel.objects.create(record=one1, twoval=100)\n+        two2 = TwoModel.objects.create(record=one2, twoval=200)\n+        two3 = TwoModel.objects.create(record=one3, twoval=300)\n+        \n+        # Test ordering by 'record__root_id'\n+        qs = TwoModel.objects.filter(record__oneval__in=[1, 2, 3]).order_by('record__root_id')\n+        self.assertQuerysetEqual(\n+            qs,\n+            [two1, two2, two3],\n+            transform=lambda x: x,\n+            ordered=True\n+        )\n+\n+        # Test ordering explicitly by 'record__root_id' DESC\n+        qs_desc = TwoModel.objects.filter(record__oneval__in=[1, 2, 3]).order_by('-record__root_id')\n+        self.assertQuerysetEqual(\n+            qs_desc,\n+            [two3, two2, two1],\n+            transform=lambda x: x,\n+            ordered=True\n+        )\n+\n     def test_order_by_f_expression(self):\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n",
  "django__django-13265": "",
  "django__django-14534": "",
  "django__django-16400": "",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..f20bfee 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -658,7 +658,34 @@ def test_colorbar_scale_reset():\n     assert cbar.outline.get_edgecolor() == mcolors.to_rgba('red')\n \n \n-def test_colorbar_get_ticks_2():\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.colors import LogNorm, Normalize\n+\n+...\n+\n+def test_colorbar_update_after_norm_change():\n+    # Set up initial data and plot with linear normalization\n+    data = 10**np.random.normal(1, 1, size=(50, 50))\n+\n+    fig, ax = plt.subplots()\n+    cax = ax.imshow(data, cmap='gray')\n+    cbar = fig.colorbar(cax, ax=ax)\n+    fig.canvas.draw()\n+\n+    # Test initial state with linear scale\n+    assert cbar.ax.yaxis.get_scale() == 'linear'\n+\n+    # Change to logarithmic normalization and update colorbar\n+    cax.set_norm(LogNorm())\n+    cbar.update_normal(cax)  # Should update without errors or issues\n+\n+    fig.canvas.draw()\n+    \n+    # Test updated state with logarithmic scale\n+    assert cbar.ax.yaxis.get_scale() == 'log'\n+\n+    plt.close(fig)  # Close figure to free resources\n     plt.rcParams['_internal.classic_mode'] = False\n     fig, ax = plt.subplots()\n     pc = ax.pcolormesh([[.05, .95]])\n",
  "pydata__xarray-4094": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex a2826fa..835d4a3 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -3045,7 +3045,13 @@ class TestDataset:\n         d0 = D.isel(x=0)\n         assert_identical(d0, x0)\n \n-    def test_to_stacked_array_to_unstacked_dataset_different_dimension(self):\n+    def test_to_stacked_array_to_unstacked_dataset_single_dim(self):\n+        # single dimension: regression test for the issue\n+        arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+        data = xr.Dataset({\"a\": arr, \"b\": arr})\n+        stacked = data.to_stacked_array(\"y\", sample_dims=[\"x\"])\n+        unstacked = stacked.to_unstacked_dataset(\"y\")\n+        assert_identical(unstacked, data)\n         # test when variables have different dimensionality\n         a, b = create_test_stacked_array()\n         sample_dims = [\"x\"]\n",
  "scikit-learn__scikit-learn-25747": "",
  "sphinx-doc__sphinx-8801": "",
  "sympy__sympy-15346": "",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..a029aaf 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4863,7 +4863,25 @@ k = \u2500\u2500\u2500\u2500\u2500                                \\n\\\n     assert upretty(expr) == ucode_str\n \n \n-def test_units():\n+def test_sum_alignment_with_addition():\n+    from sympy import Sum, oo, pprint\n+    from sympy.abc import x\n+\n+    # The expression of concern: Sum(x, (x, 1, oo)) + 3\n+    expr = Sum(x, (x, 1, oo)) + 3\n+    \n+    # Expected pretty print format, ensuring `x` and `+ 3` are aligned\n+    expected_pretty = u(\"\"\"\\\n+  \u221e    \\n\\\n+ ____  \\n\\\n+ \u2572     \\n\\\n+  \u2572   x\\n\\\n+  \u2571    \\n\\\n+ \u2571   + 3\\n\\\n+ \u203e\u203e\u203e\u203e  \\n\\\n+x = 1  \\\n+\"\"\")\n+    assert upretty(expr) == expected_pretty\n     expr = joule\n     ascii_str1 = \\\n \"\"\"\\\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex b2b6202..7d6a9ec 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -692,6 +692,8 @@ def test_reshape():\n     raises(ValueError, lambda: reshape([0, 1], [-1]))\n     raises(ValueError, lambda: reshape([0, 1], [3]))\n \n+from sympy.testing.pytest import raises\n+\n def test_uniq():\n     assert list(uniq(p.copy() for p in partitions(4))) == \\\n         [{4: 1}, {1: 1, 3: 1}, {2: 2}, {1: 2, 2: 1}, {1: 4}]\n@@ -704,6 +706,24 @@ def test_uniq():\n     assert list(uniq([2, 3, 2, 4, [2], [1], [2], [3], [1]])) == \\\n         [2, 3, 4, [2], [1], [3]]\n \n+    f = [1]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    f = [[1]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Additional test cases\n+    f = list(range(100))\n+    raises(RuntimeError, lambda: [f.pop(i) for i in uniq(f)])\n+\n+    f = list('AABBC')\n+    raises(RuntimeError, lambda: [f.pop() for i in uniq(f)])\n+\n+    f = [1, 2, 2, 3, 4]\n+    raises(RuntimeError, lambda: [f.pop() for i in uniq(f)])\n+\n+    f = ['apple', 'banana', 'apple', 'pear']\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n \n def test_kbins():\n     assert len(list(kbins('1123', 2, ordered=1))) == 24\n",
  "django__django-11797": "",
  "django__django-15320": "",
  "django__django-15819": "diff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py\nindex 0ecd041..d924b7d 100644\n--- a/tests/inspectdb/tests.py\n+++ b/tests/inspectdb/tests.py\n@@ -437,6 +437,33 @@ class InspectDBTestCase(TestCase):\n class InspectDBTransactionalTests(TransactionTestCase):\n     available_apps = [\"inspectdb\"]\n \n+    def test_related_name_on_same_relation(self):\n+        \"\"\"\n+        Test that inspectdb generates related_name when there are multiple\n+        relationships to the same model.\n+        \"\"\"\n+        out = StringIO()\n+        with connection.cursor() as cursor:\n+            # Here we simulate tables with multiple foreign keys to the same model\n+            cursor.execute(\"CREATE TABLE test_multiple_rel (id serial PRIMARY KEY, people_a_id integer, people_b_id integer);\")\n+            cursor.execute(\"ALTER TABLE test_multiple_rel ADD CONSTRAINT people_a_fk FOREIGN KEY (people_a_id) REFERENCES inspectdb_people(id);\")\n+            cursor.execute(\"ALTER TABLE test_multiple_rel ADD CONSTRAINT people_b_fk FOREIGN KEY (people_b_id) REFERENCES inspectdb_people(id);\")\n+        \n+        # Run inspectdb and capture the output\n+        call_command('inspectdb', stdout=out)\n+\n+        output = out.getvalue()\n+\n+        # Check that the related_name parameter is generated for both foreign keys\n+        self.assertIn('people_a = models.ForeignKey(', output)\n+        self.assertIn('related_name=', output)        \n+        self.assertIn('people_b = models.ForeignKey(', output)\n+        self.assertIn('related_name=', output)\n+\n+        # Clean up the test table\n+        with connection.cursor() as cursor:\n+            cursor.execute(\"DROP TABLE test_multiple_rel;\")\n+\n     def test_include_views(self):\n         \"\"\"inspectdb --include-views creates models for database views.\"\"\"\n         with connection.cursor() as cursor:\n",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..2d1a8ae 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -152,7 +153,35 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n-    def test_reverse_fk_select_related_multiple(self):\n+    def test_multilevel_reverse_fk_cyclic_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation(\"pool__tournament__pool\"),\n+                ).select_related(\"tournament_pool\", \"tournament_pool__tournament\")\n+            )\n+            # Check that the tournament from the relationship matches\n+            self.assertEqual(p[0].tournament_pool.tournament, p[0].pool.tournament)\n+\n+    def test_multilevel_reverse_fk_select_related(self):\n+        with self.assertNumQueries(2):\n+            p = list(\n+                Tournament.objects.filter(id=self.t2.id)\n+                .annotate(\n+                    style=FilteredRelation(\"pool__another_style\"),\n+                )\n+                .select_related(\"style\")\n+            )\n+            # Assert the proper relationship of related objects\n+            self.assertEqual(p[0].style.another_pool, self.p3)\n+            \n+    def test_wrong_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(PoolStyle.objects.annotate(\n+                tournament_pool=FilteredRelation('pool__tournament__pool'),\n+            ).select_related('tournament_pool'))\n+            # Check equality based on tournament relationships\n+            self.assertEqual(p[0].tournament_pool.tournament, p[0].pool.tournament)\n         with self.assertNumQueries(1):\n             ps = list(\n                 PoolStyle.objects.annotate(\n@@ -163,4 +192,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex ad1a5e1..c370487 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1,3 +1,16 @@\n+\n+def test_dpi_consistency_after_pickle():\n+    # Create a figure with specific DPI\n+    original_dpi = 100\n+    fig = plt.figure(dpi=original_dpi)\n+\n+    # Pickle and unpickle the figure\n+    pickled_fig = pickle.dumps(fig)\n+    unpickled_fig = pickle.loads(pickled_fig)\n+\n+    # Assert that the DPI remains unchanged\n+    assert unpickled_fig.dpi == original_dpi, f\"Expected DPI: {original_dpi}, but got: {unpickled_fig.dpi}\"\n+\n import copy\n from datetime import datetime\n import io\n@@ -13,7 +26,8 @@ from PIL import Image\n \n import matplotlib as mpl\n from matplotlib import gridspec, rcParams\n-from matplotlib.testing.decorators import image_comparison, check_figures_equal\n+import pickle\n+import matplotlib.pyplot as plt\n from matplotlib.axes import Axes\n from matplotlib.figure import Figure, FigureBase\n from matplotlib.layout_engine import (ConstrainedLayoutEngine,\n",
  "mwaskom__seaborn-2848": "",
  "pytest-dev__pytest-5413": "diff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 226bfb9..42c932e 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -323,6 +323,8 @@ class TestTraceback_f_g_h:\n         assert entry.frame.code.name == \"g\"\n \n \n+import pytest\n+\n def test_excinfo_exconly():\n     excinfo = pytest.raises(ValueError, h)\n     assert excinfo.exconly().startswith(\"ValueError\")\n@@ -347,7 +349,13 @@ def test_excinfo_str():\n     assert len(s.split(\":\")) >= 3  # on windows it's 4\n \n \n-def test_excinfo_for_later():\n+def test_pytest_raises_str_behavior():\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\"A\\nB\\nC\")\n+    \n+    # Test the behavior of `str()` on the context variable\n+    assert str(excinfo) == \"<ExceptionInfo LookupError tblen=1>\", \"Unexpected str() behavior on pytest.raises context\"\n+    assert str(excinfo.value) == \"A\\nB\\nC\", \"Unexpected exception message\"\n     e = ExceptionInfo.for_later()\n     assert \"for raises\" in repr(e)\n     assert \"for raises\" in str(e)\n",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..bcffed0 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -436,9 +436,17 @@ class TestCustomConftests:\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule1*\", \"*MyModule2*\", \"*test_x*\"])\n \n-\n-class TestSession:\n-    def test_parsearg(self, testdir):\n+    \n+    def test_collect_only_shortcut(self, testdir):\n+        testdir.makepyfile(test_func=\"\"\"\n+            def test_example():\n+                assert 1 == 1\n+        \"\"\")\n+        result = testdir.runpytest(\"-co\")\n+        result.stdout.fnmatch_lines([\n+            \"*<Module*\",\n+            \"*test_example*\"\n+        ])\n         p = testdir.makepyfile(\"def test_func(): pass\")\n         subdir = testdir.mkdir(\"sub\")\n         subdir.ensure(\"__init__.py\")\n",
  "sphinx-doc__sphinx-10451": "diff --git a/tests/roots/test-ext-autodoc/target/typehints.py b/tests/roots/test-ext-autodoc/target/typehints.py\nindex 100ea06..040ee79 100644\n--- a/tests/roots/test-ext-autodoc/target/typehints.py\n+++ b/tests/roots/test-ext-autodoc/target/typehints.py\n@@ -91,11 +91,20 @@ def missing_attr(c,\n     return a + (b or \"\")\n \n \n-class _ClassWithDocumentedInit:\n+class _ClassWithDocumentedInitAndStarArgs:\n+    \"\"\"Class docstring.\"\"\"\n+\n+    def __init__(self, x: int, *args: int, **kwargs: int) -> None:\n+        \"\"\"Init docstring.\n+\n+        :param x: Some integer\n+        :param *args: Some integer\n+        :param **kwargs: Some integer\n+        \"\"\"\n     \"\"\"Class docstring.\"\"\"\n \n     def __init__(self, x: int) -> None:\n         \"\"\"Init docstring.\n \n         :param x: Some integer\n-        \"\"\"\n+        \"\"\"\n",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..f96fbd9 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -83,8 +83,18 @@ def test_Identity():\n     assert transpose(In) == In\n     assert In.inverse() == In\n     assert In.conjugate() == In\n+def test_Identity_sum_elements():\n+    # Test case to verify the sum of all elements in an identity matrix is 'n'\n+    n = Symbol('n', integer=True, positive=True)\n+    \n+    # Create an identity matrix of size n\n+    In = Identity(n)\n+\n+    # Calculate the sum of all elements\n+    total_sum = Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).doit()\n \n-def test_Identity_doit():\n+    # Assert that the sum of all elements is 'n'\n+    assert total_sum == n\n     Inn = Identity(Add(n, n, evaluate=False))\n     assert isinstance(Inn.rows, Add)\n     assert Inn.doit() == Identity(2*n)\n",
  "sympy__sympy-20049": "",
  "sympy__sympy-21612": "diff --git a/sympy/parsing/tests/test_latex.py b/sympy/parsing/tests/test_latex.py\nindex b252985..b003e3e 100644\n--- a/sympy/parsing/tests/test_latex.py\n+++ b/sympy/parsing/tests/test_latex.py\n@@ -251,7 +251,21 @@ def test_parseable():\n     for latex_str, sympy_expr in GOOD_PAIRS:\n         assert parse_latex(latex_str) == sympy_expr, latex_str\n \n-# These bad LaTeX strings should raise a LaTeXParsingError when parsed\n+def test_issue_latex_fraction_parsing():\n+    from sympy.parsing.latex import parse_latex\n+    from sympy import symbols, Rational\n+\n+    a, b, c = symbols('a b c')\n+\n+    # Original problematic latex expression\n+    problematic_latex = \"\\\\frac{\\\\frac{a^3+b}{c}}{\\\\frac{1}{c^2}}\"\n+    expected_expr = Rational((a**3 + b)/c, 1/(c**2))\n+\n+    assert parse_latex(problematic_latex) == expected_expr\n+\n+    # Additional related test case for robustness\n+    another_latex = \"\\\\frac{a^3 + b}{c} / \\\\frac{1}{c^2}\"\n+    assert parse_latex(another_latex) == expected_expr\n BAD_STRINGS = [\n     r\"(\",\n     r\")\",\n"
}