{
  "astropy__astropy-12907": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 88711b0..2c93051 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -129,7 +129,49 @@ def test_arith_oper():\n         _arith_oper(sh1, map1)\n \n \n+from astropy.modeling import models as m\n+from astropy.modeling.separable import separability_matrix, is_separable\n+import numpy as np\n+import pytest\n+\n+sh1 = m.Shift(1, name='sh1')\n+sh2 = m.Shift(2, name='sh2')\n+scl1 = m.Scale(1, name='scl1')\n+scl2 = m.Scale(2, name='scl2')\n+rot = m.Rotation2D(2, name='rotation')\n+p2 = m.Polynomial2D(1, name='p2')\n+p22 = m.Polynomial2D(2, name='p22')\n+\n+cm = m.Linear1D(10) & m.Linear1D(5)\n+complex_model = m.Pix2Sky_TAN() & m.Linear1D(10) & m.Linear1D(5)\n+nested_model = m.Pix2Sky_TAN() & cm\n+\n @pytest.mark.parametrize(('compound_model', 'result'), compound_models.values())\n+def test_separable_predefined(compound_model, result):\n+    assert_allclose(is_separable(compound_model), result[0])\n+    assert_allclose(separability_matrix(compound_model), result[1])\n+\n+def test_separability_of_linear():\n+    expected_separation = np.array([[True, False], [False, True]])\n+    assert_allclose(separability_matrix(cm), expected_separation)\n+\n+def test_separability_of_complex():\n+    expected_separation = np.array([\n+        [True, True, False, False],\n+        [True, True, False, False],\n+        [False, False, True, False],\n+        [False, False, False, True]\n+    ])\n+    assert_allclose(separability_matrix(complex_model), expected_separation)\n+\n+def test_separability_of_nested():\n+    expected_separation = np.array([\n+        [True, True, False, False],\n+        [True, True, False, False],\n+        [False, False, True, True],\n+        [False, False, True, True]\n+    ])\n+    assert_allclose(separability_matrix(nested_model), expected_separation)\n def test_separable(compound_model, result):\n     assert_allclose(is_separable(compound_model), result[0])\n     assert_allclose(separability_matrix(compound_model), result[1])\n",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..495c57d 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,8 +1,12 @@\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n from io import StringIO\n \n from astropy.io import ascii\n+from astropy.table import QTable\n+import numpy as np\n+import astropy.units as u\n \n from .common import assert_almost_equal, assert_equal\n \n@@ -184,4 +188,52 @@ Col1      Col2 Col3 Col4\n  2.4 's worlds    2    2\n ==== ========= ==== ====\n \"\"\",\n-    )\n+    )\n+\n+\n+def test_write_with_header_rows():\n+    \"\"\"Test writing a QTable with `header_rows` in RST format.\"\"\"\n+    tbl = QTable({\n+        'wave': [350, 950] * u.nm,\n+        'response': [0.7, 1.2] * u.count\n+    })\n+    \n+    output = StringIO()\n+    tbl.write(output, format='ascii.rst', header_rows=['name', 'unit'])\n+    \n+    expected = \"\"\"\\\n+=====\n+ wave response\n+=====\n+ nm count\n+=====\n+350.0 0.7\n+950.0 1.2\n+=====\n+\"\"\"\n+    assert output.getvalue().strip() == expected.strip()\n+\n+\n+def test_round_trip_with_header_rows():\n+    \"\"\"Round-trip a table with header_rows specified\"\"\"\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct     \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\",\n+    ]\n+    \n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"wave\"].dtype == np.float64\n+    assert tbl[\"response\"].dtype == np.float32\n+    assert tbl[\"ints\"].dtype == np.int8\n+\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert out.getvalue().strip().splitlines() == [line.strip() for line in lines]\n",
  "astropy__astropy-14365": "",
  "astropy__astropy-14995": "",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..401db5f 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -254,6 +254,28 @@ class TestTableFunctions(FitsTestCase):\n \n         t.close()\n \n+    def test_float_exponent_replacement(self):\n+        \"\"\"Test that floating point numbers with 'D' expontent are correctly written.\"\"\"\n+        a1 = chararray.array(['text1', 'text2'])\n+        r1 = np.array([123.456, 789.012])\n+        \n+        # Define a column with 'D' format to test the replacement\n+        c1 = fits.Column(name='text', format='A6', array=a1)\n+        c2 = fits.Column(name='numbers', format='D15.7', array=r1)\n+        coldefs = fits.ColDefs([c1, c2])\n+        hdu = fits.BinTableHDU.from_columns(coldefs)\n+        \n+        # Write to a temporary FITS file\n+        hdu.writeto(self.temp('exponent_test.fits'), overwrite=True)\n+        \n+        # Read back the file and check if 'D' is used in exponents instead of 'E'\n+        with open(self.temp('exponent_test.fits')) as f:\n+            content = f.read()\n+            assert '1.2345600D+02' in content, \"Exponent 'E' was not replaced with 'D'\"\n+            assert '7.8901200D+02' in content, \"Exponent 'E' was not replaced with 'D'\"\n+        with fits.open(self.temp('exponent_test.fits')) as hdul:\n+            assert comparerecords(hdu.data, hdul[1].data)\n+\n     def test_ascii_table(self):\n         # ASCII table\n         a = fits.open(self.data('ascii.fits'))\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..fc9e295 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1090,6 +1090,13 @@ class OverrideSettingsTests(SimpleTestCase):\n         base_url attribute of django.core.files.storage.default_storage.\n         \"\"\"\n         self.assertEqual(default_storage.base_location, '')\n+\n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        Ensure default FILE_UPLOAD_PERMISSIONS is set to 0o644 when not specified.\n+        \"\"\"\n+        with self.settings(FILE_UPLOAD_PERMISSIONS=None):\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n         with self.settings(MEDIA_URL='/test_value/'):\n             self.assertEqual(default_storage.base_url, '/test_value/')\n \n",
  "django__django-10924": "",
  "django__django-11001": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 4e3940c..313b472 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -367,7 +367,56 @@ class BasicExpressionsTests(TestCase):\n         )\n         self.assertEqual(str(qs.query).count('JOIN'), 1)\n \n-    def test_ticket_18375_chained_filters(self):\n+from django.db.models.expressions import RawSQL\n+from django.test import TestCase\n+\n+...\n+\n+class ExpressionTests(TestCase):\n+    def test_order_by_multiline_sql(self):\n+        raw_order_by = (\n+            RawSQL('''\n+                CASE WHEN num_employees > 1000\n+                     THEN num_chairs\n+                     ELSE 0 END\n+            ''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN num_chairs > 1\n+                     THEN 1\n+                     ELSE 0 END\n+            ''', []).asc()\n+        )\n+        for qs in (\n+            Company.objects.all(),\n+            Company.objects.distinct(),\n+        ):\n+            with self.subTest(qs=qs):\n+                self.assertSequenceEqual(\n+                    qs.order_by(*raw_order_by),\n+                    [self.example_inc, self.gmbh, self.foobar_ltd],\n+                )\n+\n+    def test_order_by_multiline_rawsql_similar_ending(self):\n+        raw_order_by = (\n+            RawSQL('''\n+                CASE WHEN status = 'active'\n+                     THEN 5\n+                     ELSE 10 END\n+            ''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN status = 'inactive'\n+                     THEN 7\n+                     ELSE 10 END\n+            ''', []).asc()\n+        )\n+        for qs in (\n+            Company.objects.all(),\n+            Company.objects.distinct(),\n+        ):\n+            with self.subTest(qs=qs):\n+                query = qs.order_by(*raw_order_by)\n+                expected_order = [self.active_company, self.inactive_company, self.other_company]\n+                self.assertSequenceEqual(query, expected_order)\n         # F() expressions do not reuse joins from previous filter.\n         qs = Employee.objects.filter(\n             company_ceo_set__num_employees=F('pk')\n",
  "django__django-11039": "",
  "django__django-11049": "",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..d99cecb 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -238,6 +238,7 @@ class UsernameValidatorsTests(SimpleTestCase):\n             \"o'connell\", \"\u0639\u0628\u062f \u0627\u0644\",\n             \"zerowidth\\u200Bspace\", \"nonbreaking\\u00A0space\",\n             \"en\\u2013dash\",\n+            'trailingnewline\\n',\n         ]\n         v = validators.UnicodeUsernameValidator()\n         for valid in valid_usernames:\n@@ -248,9 +249,28 @@ class UsernameValidatorsTests(SimpleTestCase):\n                 with self.assertRaises(ValidationError):\n                     v(invalid)\n \n+    def test_unicode_validator_no_trailing_newline(self):\n+        invalid_usernames = [\n+            \"uname_with_trailing_newline\\n\",\n+            \"\u0645\u062b\u0627\u0644\\n\",\n+        ]\n+        v = validators.UnicodeUsernameValidator()\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n+        v = validators.UnicodeUsernameValidator()\n+        for valid in valid_usernames:\n+            with self.subTest(valid=valid):\n+                v(valid)\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n+\n     def test_ascii_validator(self):\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n-        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n+        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\", 'trailingnewline\\n']\n         v = validators.ASCIIUsernameValidator()\n         for valid in valid_usernames:\n             with self.subTest(valid=valid):\n@@ -258,4 +278,42 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n+    \n+    def test_ascii_validator_no_trailing_newline(self):\n+        invalid_usernames = [\n+            \"ascii_with_trailing_newline\\n\",\n+            \"anotherone\\n\"\n+            'trailingnewline\\n',\n+        ]\n+        v = validators.UnicodeUsernameValidator()\n+        for valid in valid_usernames:\n+            with self.subTest(valid=valid):\n+                v(valid)\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n+\n+    def test_unicode_validator_no_trailing_newline(self):\n+        invalid_usernames = [\n+            \"uname_with_trailing_newline\\n\",\n+            \"\u0645\u062b\u0627\u0644\\n\",\n+        ]\n+        v = validators.UnicodeUsernameValidator()\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n+        v = validators.ASCIIUsernameValidator()\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n+        for valid in valid_usernames:\n+            with self.subTest(valid=valid):\n+                v(valid)\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..ee9c282 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -356,6 +356,27 @@ class HttpResponseTests(unittest.TestCase):\n         r = HttpResponse()\n         self.assertIsNone(r.get('test'))\n \n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview'))\n+        self.assertEqual(r.content, b'memoryview')\n+\n+    def test_memoryview_content_assignment(self):\n+        # Test direct assignment of memoryview to content property\n+        r = HttpResponse()\n+        r.content = memoryview(b'memoryview_direct_assignment')\n+        self.assertEqual(r.content, b'memoryview_direct_assignment')\n+\n+    def test_memoryview_empty(self):\n+        # Test handling of an empty memoryview\n+        r = HttpResponse(memoryview(b''))\n+        self.assertEqual(r.content, b'')\n+\n+    def test_memoryview_large_content(self):\n+        # Test handling of a large memoryview content\n+        large_content = b'x' * (10**6)  # 1 MB of data\n+        r = HttpResponse(memoryview(large_content))\n+        self.assertEqual(r.content, large_content)\n+\n     def test_non_string_content(self):\n         # Bug 16494: HttpResponse should behave consistently with non-strings\n         r = HttpResponse(12345)\n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..a4d2853 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,9 +1,11 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n+from django.db.models.deletion import Collector\n from .models import (\n     MR, A, Avatar, Base, Child, HiddenUser, HiddenUserProfile, M, M2MFrom,\n     M2MTo, MRNull, Parent, R, RChild, S, T, User, create_a, get_default_r,\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..339eb4a 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,9 +1,11 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n from django.contrib.auth.models import Permission, User\n from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n+from django.test.utils import captured_stdout\n \n from .models import Proxy, UserProxy\n \n@@ -140,6 +142,46 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n+    def test_migrate_with_existing_target_permission(self):\n+        \"\"\"\n+        This test simulates the scenario where permissions already exist for a\n+        proxy model. This may happen in cases where permissions were manually \n+        created or if a model was converted from concrete to proxy.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='display_proxys',\n+            name='May display proxys information',\n+        )\n+        with captured_stdout() as stdout:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        self.assertIn('A problem arose migrating proxy model permissions', stdout.getvalue())\n+\n+    def test_no_duplicate_permissions_on_proxy_migration(self):\n+        \"\"\"\n+        Ensure no duplicate permissions are created when a model transitions\n+        from concrete to proxy with existing permissions.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(UserProxy, for_concrete_model=False)\n+        concrete_model_content_type = ContentType.objects.get_for_model(UserProxy, for_concrete_model=True)\n+        \n+        # Create permissions for the concrete model.\n+        Permission.objects.create(\n+            content_type=concrete_model_content_type,\n+            codename='add_userproxy',\n+            name='Can add userproxy',\n+        )\n+        \n+        with captured_stdout() as stdout:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        self.assertNotIn('A problem arose migrating proxy model permissions', stdout.getvalue())\n+\n     def test_user_keeps_same_permissions_after_migrating_backward(self):\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..d66544d 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -11,6 +11,7 @@ import weakref\n import zipfile\n from importlib import import_module\n from pathlib import Path\n+import sys\n from unittest import mock, skip, skipIf\n \n from django.apps.registry import Apps\n@@ -97,6 +98,15 @@ class TestIterModulesAndFiles(SimpleTestCase):\n                 autoreload.check_errors(import_module)('test_exception')\n         self.assertFileFound(filename)\n \n+    def test_main_module_is_resolved(self):\n+        \"\"\"Test if the main module (manage.py) is tracked by autoreload.\"\"\"\n+        # Simulate the __main__ module as manage.py\n+        main_module = types.ModuleType('__main__')\n+        main_module.__file__ = 'manage.py'\n+        sys.modules['__main__'] = main_module\n+\n+        self.assertFileFound(Path(main_module.__file__))\n+\n     def test_zip_reload(self):\n         \"\"\"\n         Modules imported from zipped files have their archive location included\n",
  "django__django-11583": "",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..fb51a7a 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -5,6 +5,8 @@ import re\n import sys\n import tempfile\n import threading\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n from io import StringIO\n from pathlib import Path\n from unittest import mock\n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..376fbdb 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -163,7 +163,42 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n-    def test_non_iterable_choices(self):\n+    def test_ensure_max_length_fits_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Short', 'Too Long'),  # Short (5), more than max_length (3)\n+                    ('Ok', 'Okay')\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (5 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_nested_choices_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=4,\n+                choices=[\n+                    ('Group', [('Nested', 'Nuff'), ('Wide_Spread', 'Wide Spread')]),  # 'Wide_Spread' is longer than max_length (4)\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (11 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n         class Model(models.Model):\n             field = models.CharField(max_length=10, choices='bad')\n \n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..4ab645d 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -252,6 +252,24 @@ class WriterTests(SimpleTestCase):\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n \n+    def test_serialize_translated_enum(self):\n+        class TranslatedEnum(enum.Enum):\n+            A = _('a-value')\n+            B = _('b-value')\n+\n+        field = models.CharField(\n+            default=TranslatedEnum.A,\n+            choices=[(m.value, m) for m in TranslatedEnum],\n+        )\n+\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(string, \n+            \"models.CharField(choices=[\"\n+            \"('a-value', test_writer.TranslatedEnum['A']), \"\n+            \"('b-value', test_writer.TranslatedEnum['B'])], \"\n+            \"default=test_writer.TranslatedEnum['A'])\")\n+        self.assertEqual(imports, {'import test_writer'})\n+\n     def test_serialize_enums(self):\n         class TextEnum(enum.Enum):\n             A = 'a-value'\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..35c9513 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,3 +1,4 @@\n+\n import unittest\n from datetime import datetime\n \n@@ -320,7 +321,23 @@ class HttpDateProcessingTests(unittest.TestCase):\n         parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n-    def test_parsing_asctime(self):\n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850_with_mock(self, mocked_datetime):\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+        \n+        # Define some test datetimes for simulation of current UTC time\n+        current_year_tests = [\n+            (datetime.datetime(2023, 11, 6, 8, 49, 37), 'Tuesday, 31-Dec-74 08:49:37 GMT', datetime.datetime(1974, 12, 31, 8, 49, 37)),\n+            (datetime.datetime(2050, 11, 6, 8, 49, 37), 'Monday, 02-Jan-00 08:49:37 GMT', datetime.datetime(2000, 1, 2, 8, 49, 37)),\n+            (datetime.datetime(2090, 11, 6, 8, 49, 37), 'Tuesday, 31-Dec-39 08:49:37 GMT', datetime.datetime(2039, 12, 31, 8, 49, 37)),\n+        ]\n+        \n+        for current_utc, rfc850_str, expected_date in current_year_tests:\n+            with self.subTest(rfc850_str=rfc850_str):\n+                mocked_datetime.utcnow.return_value = current_utc\n+                parsed = parse_http_date(rfc850_str)\n+                self.assertEqual(datetime.datetime.utcfromtimestamp(parsed), expected_date)\n         parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..f195920 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -32,6 +32,38 @@ class Vehicle(models.IntegerChoices):\n     __empty__ = _('(Unknown)')\n \n \n+# Additional models for specific test case\n+\n+class MyChoice(models.TextChoices):\n+    FIRST_CHOICE = \"first\", _(\"The first choice, it is\")\n+    SECOND_CHOICE = \"second\", _(\"The second choice, it is\")\n+\n+class MyObject(models.Model):\n+    my_str_value = models.CharField(max_length=10, choices=MyChoice.choices)\n+\n+class MyEnumTest(TestCase):\n+    def setUp(self) -> None:\n+        self.my_object = MyObject.objects.create(my_str_value=MyChoice.FIRST_CHOICE)\n+\n+    def test_created_object_is_str(self):\n+        my_object = self.my_object\n+        # Verifying that the field value is stored as a string\n+        self.assertIsInstance(my_object.my_str_value, str)\n+        self.assertEqual(my_object.my_str_value, \"first\")\n+\n+    def test_retrieved_object_is_str(self):\n+        my_object = MyObject.objects.last()\n+        # Verifying that the retrieved field value is also a string\n+        self.assertIsInstance(my_object.my_str_value, str)\n+        self.assertEqual(my_object.my_str_value, \"first\")\n+\n+    def test_enum_str_representation(self):\n+        # Ensure enum-to-string conversion generates expected value\n+        for test in [MyChoice]:\n+            for member in test:\n+                with self.subTest(member=member):\n+                    self.assertEqual(str(test[member.name]), str(member.value))\n+\n class Gender(models.TextChoices):\n     MALE = 'M'\n     FEMALE = 'F'\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..0f76b6a 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -147,8 +147,19 @@ class ChoicesTests(SimpleTestCase):\n             with self.subTest(field=field):\n                 self.assertIsInstance(field.formfield(), forms.ChoiceField)\n \n+from django.test import SimpleTestCase\n+from django.db import models\n+\n+class FooBarTests(SimpleTestCase):\n+    def test_overriding_field_display(self):\n+        class FooBar(models.Model):\n+            foo_bar = models.CharField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                return 'something'\n \n-class GetFieldDisplayTests(SimpleTestCase):\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), 'something')\n \n     def test_choices_and_field_display(self):\n         \"\"\"\n",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "",
  "django__django-12284": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex 7dc81d2..3c49ec6 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -1,3 +1,33 @@\n+\n+class InheritedChoicesFieldDisplayTests(TestCase):\n+    def test_inherited_field_display(self):\n+        \"\"\"\n+        Test that get_FIELD_display() works correctly with inherited model field choices.\n+        \"\"\"\n+\n+        class Base(models.Model):\n+            foo = models.CharField(max_length=254, choices=[('A', 'Base A'), ('B', 'Base B')])\n+\n+            class Meta:\n+                abstract = True\n+\n+        class Child(Base):\n+            foo = models.CharField(max_length=254, choices=[('A', 'Child A'), ('B', 'Child B'), ('C', 'Child C')])\n+\n+        # Create an instance of Child with various values and test get_foo_display\n+        child_a = Child(foo='A')\n+        self.assertEqual(child_a.get_foo_display(), 'Child A')\n+\n+        child_b = Child(foo='B')\n+        self.assertEqual(child_b.get_foo_display(), 'Child B')\n+\n+        child_c = Child(foo='C')\n+        self.assertEqual(child_c.get_foo_display(), 'Child C')\n+\n+        # Test a value that should not be found in the choices\n+        child_invalid = Child(foo='D')\n+        self.assertEqual(child_invalid.get_foo_display(), 'D')\n+\n import pickle\n \n from django import forms\n",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..3245b1a 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,3 +1,4 @@\n+\n from django.core.checks import Error\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n@@ -5,9 +6,42 @@ from django.core.checks.translation import (\n )\n from django.test import SimpleTestCase\n \n+from django.test import override_settings\n \n class TranslationCheckTests(SimpleTestCase):\n \n+    def test_issue_translation_E004(self):\n+        msg = (\n+            'You have provided a value for the LANGUAGE_CODE setting that is '\n+            'not in the LANGUAGES setting.'\n+        )\n+        # Set of test cases to verify sublanguage resolution to base language.\n+        # These should pass without raising E004 if the base language is present.\n+        test_cases = [\n+            ('de-at', [('de', 'German')]),  # Base 'de' should prevent E004 on 'de-at'\n+            ('es-ar', [('es', 'Spanish')]),  # Base 'es' should prevent E004 on 'es-ar'\n+        ]\n+        for language_code, languages in test_cases:\n+            with self.subTest(language_code=language_code), override_settings(USE_I18N=True, LANGUAGE_CODE=language_code, LANGUAGES=languages):\n+                self.assertEqual(check_language_settings_consistent(None), [])\n+\n+    def test_fallback_to_base_language(self):\n+        # This test checks if the fallback mechanism works correctly.\n+        msg = (\n+            'You have provided a value for the LANGUAGE_CODE setting that is '\n+            'not in the LANGUAGES setting.'\n+        )\n+        # The sublanguage exists without its corresponding base language\n+        test_cases_invalid = [\n+            ('de-at', [('fr', 'French')]),  # No 'de' provided\n+            ('es-ar', [('en', 'English')]),  # No 'es' provided\n+        ]\n+        for language_code, languages in test_cases_invalid:\n+            with self.subTest(language_code=language_code), override_settings(USE_I18N=True, LANGUAGE_CODE=language_code, LANGUAGES=languages):\n+                self.assertEqual(check_language_settings_consistent(None), [\n+                    Error(msg, id='translation.E004'),\n+                ])\n+\n     def setUp(self):\n         self.valid_tags = (\n             'en',              # language\n",
  "django__django-12308": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex acbcf33..3bfba91 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -173,6 +173,20 @@ class UtilsTests(SimpleTestCase):\n         display_value = display_for_field(None, models.DecimalField(), self.empty_value)\n         self.assertEqual(display_value, self.empty_value)\n \n+    def test_jsonfield_display_for_field(self):\n+        tests = [\n+            ({'foo': 'bar'}, '{\"foo\": \"bar\"}'),  # Standard JSON dict\n+            ([1, 2, 3], '[1, 2, 3]'),            # JSON list\n+            ('simple string', '\"simple string\"'), # JSON string\n+            ({'nested': {'a': 1}}, '{\"nested\": {\"a\": 1}}'),  # Nested JSON\n+            ({('not', 'json'): 'value'}, \"{('not', 'json'): 'value'}\"),  # Invalid JSON\n+            (None, self.empty_value),            # None value\n+        ]\n+        for input_value, expected_output in tests:\n+            with self.subTest(input_value=input_value):\n+                display_value = display_for_field(input_value, models.JSONField(), self.empty_value)\n+                self.assertEqual(display_value, expected_output)\n+\n         display_value = display_for_field(None, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, self.empty_value)\n \n",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..3c2adf0 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,5 +1,8 @@\n+\n import copy\n-from unittest import mock\n+from ..models import Object, ObjectReference\n+from django.db import IntegrityError\n+from django.db import transaction\n \n from django.db import DEFAULT_DB_ALIAS, connection, connections\n from django.db.backends.base.creation import (\n@@ -18,7 +21,69 @@ def get_connection_copy():\n     return test_connection\n \n \n-class TestDbSignatureTests(SimpleTestCase):\n+class TestDeserializeDbFromString(SimpleTestCase):\n+    databases = {'default'}\n+\n+    def test_circular_reference(self):\n+        # deserialize_db_from_string() handles circular references.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj_ref\": 1, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get()\n+        obj_ref = ObjectReference.objects.get()\n+        self.assertEqual(obj.obj_ref, obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n+\n+    def test_missing_reference(self):\n+        # A deserialization with missing foreign key references should raise an IntegrityError.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj_ref\": 2, \"related_objects\": []}\n+            }\n+        ]\n+        \"\"\"\n+        with self.assertRaises(IntegrityError):\n+            connection.creation.deserialize_db_from_string(data)\n+\n+    def test_valid_serialization_order(self):\n+        # Serialization should not fail if objects are serialized in correct order.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            },\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj_ref\": 1, \"related_objects\": []}\n+            }\n+        ]\n+        \"\"\"\n+        try:\n+            connection.creation.deserialize_db_from_string(data)\n+            obj = Object.objects.get()\n+            obj_ref = ObjectReference.objects.get()\n+            self.assertEqual(obj.obj_ref, obj_ref)\n+            self.assertEqual(obj_ref.obj, obj)\n+        except IntegrityError:\n+            self.fail(\"Deserialization raised IntegrityError unexpectedly!\")\n     def test_default_name(self):\n         # A test db name isn't set.\n         prod_name = 'hodor'\n",
  "django__django-12497": "diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 057ec3a..192ca70 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -159,7 +159,34 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n-    def test_relationship_model_with_foreign_key_to_wrong_model(self):\n+    def test_fixed_recursive_relationship_hint(self):\n+        class Person(models.Model):\n+            pass\n+\n+        class Group(models.Model):\n+            field = models.ManyToManyField('Person', through='AmbiguousRelationship')\n+\n+        class AmbiguousRelationship(models.Model):\n+            person = models.ForeignKey(Person, models.CASCADE)\n+            first_group = models.ForeignKey(Group, models.CASCADE, related_name='first')\n+            second_group = models.ForeignKey(Group, models.CASCADE, related_name='second')\n+\n+        field = Group._meta.get_field('field')\n+        self.assertEqual(field.check(from_model=Group), [\n+            Error(\n+                \"The model is used as an intermediate model by \"\n+                \"'invalid_models_tests.Group.field', but it has more than one \"\n+                \"foreign key from 'Group', which is ambiguous. You must \"\n+                \"specify which foreign key Django should use via the \"\n+                \"through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"AmbiguousRelationship\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n         class WrongModel(models.Model):\n             pass\n \n",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..f466c7a 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1248,8 +1248,32 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleanse_setting('SETTING_NAME', initial),\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n-\n-    def test_request_meta_filtering(self):\n+    def test_cleanse_setting_recurses_in_nested_iterables(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            'credentials': [\n+                {'username': 'user1', 'password': 'secret1'},\n+                ('nested_tuple', [{'api_key': 'a06b-c462cffae87a'}, {'token': 'abcd-efgh'}]),\n+            ],\n+            'outer_tuple': (\n+                {'token': 'tokenvalue'},\n+                [{'nested_dict': {'password': 'secretpassword'}}],\n+            ),\n+        }\n+        cleansed = {\n+            'credentials': [\n+                {'username': 'user1', 'password': reporter_filter.cleansed_substitute},\n+                ('nested_tuple', [{'api_key': reporter_filter.cleansed_substitute}, {'token': reporter_filter.cleansed_substitute}]),\n+            ],\n+            'outer_tuple': (\n+                {'token': reporter_filter.cleansed_substitute},\n+                [{'nested_dict': {'password': reporter_filter.cleansed_substitute}}],\n+            ),\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n         self.assertEqual(\n",
  "django__django-12708": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 2df48a2..795311a 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1759,7 +1759,28 @@ class OperationTests(OperationTestBase):\n         operation = migrations.AlterIndexTogether(\"Pony\", None)\n         self.assertEqual(operation.describe(), \"Alter index_together for Pony (0 constraint(s))\")\n \n-    @skipUnlessDBFeature('supports_table_check_constraints')\n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_alter_index_together_remove_with_unique_together(self):\n+        app_label = 'test_alintoremove_wunto'\n+        table_name = '%s_pony' % app_label\n+        project_state = self.set_up_test_model(app_label, unique_together=True)\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+        # Add index together.\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexExists(table_name, ['pink', 'weight'])\n+        # Remove index together.\n+        project_state = new_state\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', set())\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n     def test_add_constraint(self):\n         project_state = self.set_up_test_model(\"test_addconstraint\")\n         gt_check = models.Q(pink__gt=2)\n",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..d958a76 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -697,7 +697,23 @@ class FastDeleteTests(TestCase):\n                 (0, {'delete.User': 0})\n             )\n \n-    def test_fast_delete_combined_relationships(self):\n+    def test_query_set_delete_zero_objects_with_fk(self):\n+        \"\"\"\n+        Test that QuerySet.delete() returns a consistent result when zero objects are deleted for models with foreign keys.\n+        \"\"\"\n+        R.objects.create()  # Create an instance to ensure the model table is not empty\n+        deleted, deleted_objs = R.objects.none().delete()\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {R._meta.label: 0})\n+\n+    def test_query_set_delete_zero_objects_without_fk(self):\n+        \"\"\"\n+        Test that QuerySet.delete() returns a consistent result when zero objects are deleted for models without foreign keys.\n+        \"\"\"\n+        BlockLibrary.objects.create()  # Create an instance to ensure the model table is not empty\n+        deleted, deleted_objs = BlockLibrary.objects.none().delete()\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {'my_app.BlockLibrary': 0})\n         # The cascading fast-delete of SecondReferrer should be combined\n         # in a single DELETE WHERE referrer_id OR unique_field.\n         origin = Origin.objects.create()\n",
  "django__django-12856": "",
  "django__django-12915": "diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex 72f5bd1..f5fbe14 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -79,6 +79,44 @@ class ASGITest(SimpleTestCase):\n         # Allow response.close() to finish.\n         await communicator.wait()\n \n+    async def test_static_file_async_handler(self):\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        scope = self.async_request_factory._base_scope(path='/static/file_async.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+\n+        file_path = TEST_STATIC_ROOT / 'file_async.txt'\n+        with open(file_path, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', str(len(test_file_contents)).encode('ascii')),\n+                (b'Content-Type', b'text/plain'),\n+                (b'Content-Disposition', b'inline; filename=\"file_async.txt\"'),\n+                (b'Last-Modified', http_date(file_path.stat().st_mtime).encode('ascii')),\n+            },\n+        )\n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], test_file_contents)\n+        await communicator.wait()\n+\n+    async def test_static_file_not_found_async_handler(self):\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        scope = self.async_request_factory._base_scope(path='/static/not_found_async.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 404)\n+        await communicator.wait()\n+\n     async def test_headers(self):\n         application = get_asgi_application()\n         communicator = ApplicationCommunicator(\n",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..3c46f2e 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -197,6 +197,16 @@ class TestUtilsText(SimpleTestCase):\n             ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True),\n             ('\u4f60\u597d', '\u4f60\u597d', True),\n             ('\u0130stanbul', 'istanbul', True),\n+            # New cases to cover the original issue\n+            (' multiple---dash and  space ', 'multiple-dash-and-space', False),\n+            ('\\t whitespace-in-value \\n', 'whitespace-in-value', False),\n+            ('underscore_in-value', 'underscore_in-value', False),\n+            ('__strip__underscore-value___', 'strip-underscore-value', False),\n+            ('--strip-dash-value---', 'strip-dash-value', False),\n+            ('__strip-mixed-value---', 'strip-mixed-value', False),\n+            ('_ -strip-mixed-value _-', 'strip-mixed-value', False),\n+            # Case from the issue description\n+            ('___This is a test ---', 'this-is-a-test', False),\n         )\n         for value, output, is_unicode in items:\n             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n",
  "django__django-13028": "",
  "django__django-13158": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 070e08e..4590fde 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -1,3 +1,4 @@\n+\n import operator\n \n from django.db import DatabaseError, NotSupportedError, connection\n@@ -138,7 +139,12 @@ class QuerySetSetOperationTests(TestCase):\n             operator.itemgetter('alias'),\n         )\n \n-    def test_union_with_values(self):\n+    def test_union_none(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.filter(num__gte=8)\n+        qs_union = qs1.union(qs2)\n+        self.assertEqual(qs_union.none().count(), 0)\n+        self.assertNumbersEqual(qs_union, [0, 1, 8, 9], ordered=False)\n         ReservedName.objects.create(name='a', order=2)\n         qs1 = ReservedName.objects.all()\n         reserved_name = qs1.union(qs1).values('name', 'order', 'id').get()\n@@ -313,4 +319,4 @@ class QuerySetSetOperationTests(TestCase):\n                         NotSupportedError,\n                         msg % (operation, combinator),\n                     ):\n-                        getattr(getattr(qs, combinator)(qs), operation)()\n+                        getattr(getattr(qs, combinator)(qs), operation)()\n",
  "django__django-13230": "",
  "django__django-13315": "",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 536c423..eef492f 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -11,7 +11,33 @@ from django.test.utils import isolate_apps\n \n @isolate_apps('model_inheritance')\n class AbstractInheritanceTests(SimpleTestCase):\n-    def test_single_parent(self):\n+    def test_abstract_inherited_fields_inequality(self):\n+        \"\"\"Field instances from abstract models with different derived models should not be equal.\"\"\"\n+        class AbstractBase(models.Model):\n+            some_field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritedModel1(AbstractBase):\n+            pass\n+\n+        class InheritedModel2(AbstractBase):\n+            pass\n+\n+        # Fetch the fields\n+        field_from_model1 = InheritedModel1._meta.get_field('some_field')\n+        field_from_model2 = InheritedModel2._meta.get_field('some_field')\n+\n+        # Test that these fields are not considered equal\n+        self.assertNotEqual(field_from_model1, field_from_model2)\n+\n+        # Test hash inequality as well\n+        self.assertNotEqual(hash(field_from_model1), hash(field_from_model2))\n+\n+        # Test ordering consistency\n+        self.assertLess(field_from_model1.creation_counter, field_from_model2.creation_counter)\n+        self.assertTrue(field_from_model1 < field_from_model2)\n         class AbstractBase(models.Model):\n             name = models.CharField(max_length=30)\n \n@@ -347,4 +373,4 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('age', models.SmallIntegerField), ('concretemodel2_ptr', models.OneToOneField),\n                 ('name', models.CharField),\n             ]\n-        )\n+        )\n",
  "django__django-13447": "diff --git a/tests/admin_views/test_adminsite.py b/tests/admin_views/test_adminsite.py\nindex 16a02bb..35cae1e 100644\n--- a/tests/admin_views/test_adminsite.py\n+++ b/tests/admin_views/test_adminsite.py\n@@ -64,6 +64,26 @@ class SiteEachContextTest(TestCase):\n         user = auth['models'][0]\n         self.assertEqual(user['object_name'], 'User')\n \n+\n+    def test_app_list_contains_model_class(self):\n+        ctx = self.ctx\n+        apps = ctx['available_apps']\n+\n+        # Check that 'admin_views.Article' contains model class reference\n+        admin_views = apps[0]\n+        article = admin_views['models'][0]\n+        self.assertEqual(article['object_name'], 'Article')\n+        # Verify this test needs to check for a model class field\n+        self.assertIn('model', article)\n+        self.assertEqual(article['model'], Article)\n+\n+        # Check that 'auth.User' contains model class reference\n+        auth = apps[1]\n+        user = auth['models'][0]\n+        self.assertEqual(user['object_name'], 'User')\n+        self.assertIn('model', user)\n+        self.assertEqual(user['model'], User)\n+\n         self.assertEqual(auth['app_url'], '/test_admin/admin/auth/')\n         self.assertIs(auth['has_module_perms'], True)\n \n",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..c103617 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,10 +1,12 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n from django.contrib.auth.models import User\n from django.contrib.auth.tokens import PasswordResetTokenGenerator\n from django.test import TestCase\n-from django.test.utils import ignore_warnings\n+from .with_custom_email_field import CustomEmailField\n+from .models import CustomEmailField, IntegerUsernameUser\n from django.utils.deprecation import RemovedInDjango40Warning\n \n \n",
  "django__django-13590": "",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..208fa99 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -19,7 +19,8 @@ from django.conf import settings\n from django.core.management import (\n     BaseCommand, CommandError, call_command, color,\n )\n-from django.core.management.commands.loaddata import Command as LoaddataCommand\n+from unittest import mock\n+from django.core.management import execute_from_command_line\n from django.core.management.commands.runserver import (\n     Command as RunserverCommand,\n )\n",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..ff00076 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,3 +1,4 @@\n+\n import sys\n import unittest\n from unittest import mock\n@@ -29,15 +30,93 @@ class ShellCommandTestCase(SimpleTestCase):\n             stdin.seek(0)\n             call_command('shell')\n         self.assertEqual(stdout.getvalue().strip(), '100')\n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n+\n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n \n-    @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n     @mock.patch.dict('sys.modules', {'IPython': None})\n     def test_shell_with_ipython_not_installed(self, select):\n         select.return_value = ([], [], [])\n         with self.assertRaisesMessage(CommandError, \"Couldn't import ipython interface.\"):\n             call_command('shell', interface='ipython')\n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n \n-    @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n     @mock.patch.dict('sys.modules', {'bpython': None})\n     def test_shell_with_bpython_not_installed(self, select):\n         select.return_value = ([], [], [])\n@@ -49,4 +128,4 @@ class ShellCommandTestCase(SimpleTestCase):\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 2d83d62..913ef03 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -967,22 +967,41 @@ class TestReadOnlyChangeViewInlinePermissions(TestCase):\n class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n     factory = RequestFactory()\n \n-    def test_verbose_name_plural_inline(self):\n-        class NonVerboseProfileInline(TabularInline):\n+    def test_inline_verbose_name_defaults_to_plural_if_unspecified(self):\n+        class InlineWithoutPluralVerboseName(TabularInline):\n             model = Profile\n-            verbose_name_plural = 'Non-verbose childs'\n+            verbose_name = 'Inline singular name'\n \n-        class VerboseNameProfileInline(TabularInline):\n+        class InlineWithModelOnly(TabularInline):\n             model = VerboseNameProfile\n-            verbose_name_plural = 'Childs with verbose name'\n \n-        class VerboseNamePluralProfileInline(TabularInline):\n-            model = VerboseNamePluralProfile\n-            verbose_name_plural = 'Childs with verbose name plural'\n+        class InlineWithBothNames(TabularInline):\n+            model = VerboseNameProfile\n+            verbose_name = 'Inline singular name'\n+            verbose_name_plural = 'Inline plural name'\n \n-        class BothVerboseNameProfileInline(TabularInline):\n-            model = BothVerboseNameProfile\n-            verbose_name_plural = 'Childs with both verbose names'\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [\n+            InlineWithoutPluralVerboseName,\n+            InlineWithModelOnly,\n+            InlineWithBothNames,\n+        ]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Inline without plural verbose name specified.\n+        self.assertContains(response, '<h2>Inline singular names</h2>')\n+        self.assertContains(response, 'Add another Inline singular name')\n+\n+        # Inline with only model defaults should use model's verbose name if verbose_name is not set.\n+        self.assertContains(response, '<h2>VerboseNameProfiles</h2>')\n+\n+        # Inline with both names should respect both\n+        self.assertContains(response, '<h2>Inline plural name</h2>')\n+        self.assertContains(response, 'Add another Inline singular name')\n \n         modeladmin = ModelAdmin(ProfileCollection, admin_site)\n         modeladmin.inlines = [\n",
  "django__django-13757": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex f53ff8c..b77c5b2 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -586,14 +586,29 @@ class TestQuerying(TestCase):\n             NullableJSONModel.objects.filter(value__a__isnull=True),\n             self.objs[:3] + self.objs[5:],\n         )\n+        # Verify the behavior for SQLite and Oracle where keys with JSON null should not match when __isnull=True\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],  # Ensure objects with key 'j' having JSON null are not included\n+        )\n         self.assertSequenceEqual(\n             NullableJSONModel.objects.filter(value__a__isnull=False),\n             [self.objs[3], self.objs[4]],\n         )\n+        # Verify the behavior for SQLite and Oracle where keys with JSON null should not match when __isnull=True\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],  # Ensure objects with key 'j' having JSON null are not included\n+        )\n         self.assertSequenceEqual(\n             NullableJSONModel.objects.filter(value__j__isnull=False),\n             [self.objs[4]],\n         )\n+        # Verify the behavior for SQLite and Oracle where keys with JSON null should not match when __isnull=True\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__j__isnull=True),\n+            self.objs[:4] + self.objs[5:],  # Ensure objects with key 'j' having JSON null are not included\n+        )\n \n     def test_isnull_key_or_none(self):\n         obj = NullableJSONModel.objects.create(value={'a': None})\n",
  "django__django-13768": "",
  "django__django-13925": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 6424d89..92a5b64 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -402,6 +402,68 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n \n         self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n \n+    def test_explicit_inherited_pk(self):\n+        class Parent(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class Child(Parent):\n+            pass\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n+    def test_explicit_inherited_parent_link(self):\n+        class Parent(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class Child(Parent):\n+            parent_ptr = models.OneToOneField(Parent, models.CASCADE, parent_link=True)\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n+    def test_auto_created_inherited_pk(self):\n+        class Parent(models.Model):\n+            pass\n+\n+        class Child(Parent):\n+            pass\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [\n+            Warning(\n+                \"Auto-created primary key used when not defining a primary \"\n+                \"key type, by default 'django.db.models.AutoField'.\",\n+                hint=(\n+                    \"Configure the DEFAULT_AUTO_FIELD setting or the \"\n+                    \"CheckDefaultPKConfig.default_auto_field attribute to \"\n+                    \"point to a subclass of AutoField, e.g. \"\n+                    \"'django.db.models.BigAutoField'.\"\n+                ),\n+                obj=Parent,\n+                id='models.W042',\n+            ),\n+        ])\n+\n+    def test_auto_created_inherited_parent_link(self):\n+        class Parent(models.Model):\n+            pass\n+\n+        class Child(Parent):\n+            parent_ptr = models.OneToOneField(Parent, models.CASCADE, parent_link=True)\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [\n+            Warning(\n+                \"Auto-created primary key used when not defining a primary \"\n+                \"key type, by default 'django.db.models.AutoField'.\",\n+                hint=(\n+                    \"Configure the DEFAULT_AUTO_FIELD setting or the \"\n+                    \"CheckDefaultPKConfig.default_auto_field attribute to \"\n+                    \"point to a subclass of AutoField, e.g. \"\n+                    \"'django.db.models.BigAutoField'.\"\n+                ),\n+                obj=Parent,\n+                id='models.W042',\n+            ),\n+        ])\n+\n     def test_explicit_pk(self):\n         class Model(models.Model):\n             id = models.BigAutoField(primary_key=True)\n@@ -414,4 +476,4 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n             class Meta:\n                 app_label = 'check_framework.apps.CheckPKConfig'\n \n-        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n",
  "django__django-13933": "",
  "django__django-13964": "diff --git a/tests/many_to_one/models.py b/tests/many_to_one/models.py\nindex 1078928..48db61e 100644\n--- a/tests/many_to_one/models.py\n+++ b/tests/many_to_one/models.py\n@@ -63,6 +63,8 @@ class Third(models.Model):\n     third = models.ForeignKey('self', models.SET_NULL, null=True, related_name='child_set')\n \n \n+from django.db import models\n+\n class Parent(models.Model):\n     name = models.CharField(max_length=20, unique=True)\n     bestchild = models.ForeignKey('Child', models.SET_NULL, null=True, related_name='favored_by')\n@@ -89,7 +91,11 @@ class Category(models.Model):\n         return self.name\n \n \n-class Record(models.Model):\n+class ParentStringPrimaryKey(models.Model):\n+    name = models.CharField(primary_key=True, max_length=15)\n+\n+class ChildStringPrimaryKeyParent(models.Model):\n+    parent = models.ForeignKey(ParentStringPrimaryKey, on_delete=models.CASCADE)\n     category = models.ForeignKey(Category, models.CASCADE)\n \n \n",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..a32d05a 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import F, Q\n from django.test import SimpleTestCase\n \n@@ -19,7 +20,16 @@ class QTests(SimpleTestCase):\n     def test_combine_or_both_empty(self):\n         self.assertEqual(Q() | Q(), Q())\n \n-    def test_combine_not_q_object(self):\n+    def test_combine_q_with_dict_keys(self):\n+        # Test using 'AND' operator with non-pickleable type dict_keys\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q & Q(), q)\n+        self.assertEqual(Q() & q, q)\n+        \n+        # Test using 'OR' operator with non-pickleable type dict_keys\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n         obj = object()\n         q = Q(x=1)\n         with self.assertRaisesMessage(TypeError, str(obj)):\n",
  "django__django-14017": "",
  "django__django-14155": "",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..b1b84a2 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,4 +1,6 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n+from .models import MyBigAutoField, MySmallAutoField\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n from django.test.utils import isolate_apps\n@@ -67,6 +69,20 @@ class TestDefaultPK(SimpleTestCase):\n                 pass\n \n     @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_mybigautofield(self):\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_mysmallautofield(self):\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n@@ -83,6 +99,20 @@ class TestDefaultPK(SimpleTestCase):\n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n \n     @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_mybigautofield(self):\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_mysmallautofield(self):\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_m2m_default_auto_field_setting(self):\n         class M2MModel(models.Model):\n",
  "django__django-14382": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex afeed3e..19ca7c3 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2196,8 +2196,16 @@ class StartApp(AdminScriptTestCase):\n                     \"CommandError: '%s' is not a valid app directory. Please \"\n                     \"make sure the directory is a valid identifier.\" % bad_target\n                 )\n-\n-    def test_importable_target_name(self):\n+    def test_trailing_slash_in_target_app_directory_name(self):\n+        \"\"\"\n+        Test that 'django-admin startapp' works with a trailing slash in\n+        the target directory.\n+        \"\"\"\n+        app_dir = os.path.join(self.test_dir, 'trailing_slash_app')\n+        os.makedirs(app_dir)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('trailing_slash_app', '')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n         _, err = self.run_django_admin(['startapp', 'app', 'os'])\n         self.assertOutput(\n             err,\n",
  "django__django-14411": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 331338c..e9c252d 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,6 +1,7 @@\n import datetime\n import re\n from unittest import mock\n+from django.forms import forms\n \n from django.contrib.auth.forms import (\n     AdminPasswordChangeForm, AuthenticationForm, PasswordChangeForm,\n@@ -1025,6 +1026,23 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n         self.assertIs(field.disabled, True)\n         self.assertFalse(field.has_changed('aaa', 'bbb'))\n \n+    def test_label_for_readonlypasswordhashwidget(self):\n+        \"\"\"\n+        Test that the <label> for ReadOnlyPasswordHashWidget does not have a 'for'\n+        attribute since there is no labelable element.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            hash_field = ReadOnlyPasswordHashField()\n+\n+        bound_field = TestForm()['hash_field']\n+        widget_id = bound_field.field.widget.id_for_label('id')\n+        label_tag = bound_field.label_tag()\n+        \n+        # Assert that id_for_label returns None, indicating no labelable element\n+        self.assertIsNone(widget_id)\n+        # Assert that label_tag does not contain a 'for' attribute\n+        self.assertEqual(label_tag, '<label>Hash field:</label>')\n+\n \n class AdminPasswordChangeFormTest(TestDataMixin, TestCase):\n \n",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..215e086 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -658,6 +658,33 @@ class WriterTests(SimpleTestCase):\n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n \n+    def test_missing_models_import_in_migration(self):\n+        \"\"\"\n+        Tests that the 'models' import statement is included in the generated migration\n+        when a model with a custom field and mixin is present.\n+        \"\"\"\n+        model_definitions = '''\n+        from django.db import models\n+\n+        class MyField(models.TextField):\n+            pass\n+\n+        class MyMixin:\n+            pass\n+\n+        class MyBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        class MyModel(MyMixin, MyBaseModel):\n+            name = MyField(primary_key=True)\n+        '''\n+\n+        with self.modify_models(model_definitions):\n+            migration = self.make_migrations('app')\n+            self.assertIn(\"from django.db import models\", migration)\n+            self.assertIn(\"bases=(app.models.MyMixin, models.Model)\", migration)\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..678d3da 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -336,7 +336,7 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at most 1 form.'])\n+        self.assertEqual(formset.non_form_errors(), ErrorList(['Please submit at most 1 form.'], error_class='nonform'))\n \n     def test_formset_validate_min_flag(self):\n         \"\"\"\n@@ -358,7 +358,7 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, min_num=3, validate_min=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at least 3 forms.'])\n+        self.assertEqual(formset.non_form_errors(), ErrorList(['Please submit at least 3 forms.'], error_class='nonform'))\n \n     def test_formset_validate_min_unchanged_forms(self):\n         \"\"\"\n@@ -982,7 +982,7 @@ class FormsFormsetTestCase(SimpleTestCase):\n         }\n         formset = FavoriteDrinksFormSet(data, prefix='drinks')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n+        self.assertEqual(formset.non_form_errors(), ErrorList(['You may only specify a drink once.'], error_class='nonform'))\n \n     def test_formset_iteration(self):\n         \"\"\"Formset instances are iterable.\"\"\"\n",
  "django__django-14672": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex d9eaabe..fb48a0d 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -20,7 +20,31 @@ class M2mThroughTests(TestCase):\n         cls.rock = Group.objects.create(name='Rock')\n         cls.roll = Group.objects.create(name='Roll')\n \n-    def test_retrieve_intermediate_items(self):\n+    def test_m2m_with_proxy_model_and_through_fields(self):\n+        class BaseModel(models.Model):\n+            name = models.CharField(max_length=100)\n+        \n+        class ProxyModel(BaseModel):\n+            class Meta:\n+                proxy = True\n+        \n+        class IntermediateModel(models.Model):\n+            basemodel = models.ForeignKey(BaseModel, on_delete=models.CASCADE)\n+            proxymodel = models.ForeignKey(ProxyModel, on_delete=models.CASCADE)\n+        \n+        class TestModel(models.Model):\n+            base_many = models.ManyToManyField(\n+                BaseModel,\n+                through=IntermediateModel,\n+                through_fields=['basemodel', 'proxymodel'],\n+                related_name='test_models'\n+            )\n+        \n+        # Make sure no TypeError is raised due to unhashable 'through_fields'\n+        try:\n+            hash(TestModel.base_many.remote_field)\n+        except TypeError:\n+            self.fail(\"ManyToManyRel through_fields is not hashable\")\n         Membership.objects.create(person=self.jim, group=self.rock)\n         Membership.objects.create(person=self.jane, group=self.rock)\n \n",
  "django__django-14752": "",
  "django__django-14787": "diff --git a/tests/decorators/tests.py b/tests/decorators/tests.py\nindex 5ea3da6..7121a71 100644\n--- a/tests/decorators/tests.py\n+++ b/tests/decorators/tests.py\n@@ -412,7 +412,7 @@ class MethodDecoratorTests(SimpleTestCase):\n \n     def test_invalid_method_name_to_decorate(self):\n         \"\"\"\n-        @method_decorator on a nonexistent method raises an error.\n+from functools import partial, wraps\n         \"\"\"\n         msg = (\n             \"The keyword argument `name` must be the name of a method of the \"\n",
  "django__django-14855": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 507855b..cec9f00 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -5103,12 +5103,84 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase):\n             content='content',\n             book=Book.objects.create(name='Book 1'),\n         )\n+\n+    def _test_readonly_foreignkey_links(self, admin_site):\n+        \"\"\"\n+        Helper method to test readonly ForeignKey links for a given admin site.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1',\n+            content='content',\n+            book=Book.objects.create(name='Book 1'),\n+        )\n+        language = Language.objects.create(iso='en', name='English')\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+            language=language,\n+            user=self.superuser,\n+        )\n+        with self.subTest(admin_site=admin_site):\n+            # Fetch change view of the object\n+            response = self.client.get(reverse(f'{admin_site}:admin_views_readonlyrelatedfield_change', args=(obj.pk,)))\n+            self.assertEqual(response.status_code, 200)\n+\n+            # Check if the link points to the correct admin site\n+            expected_link = reverse(f'{admin_site}:admin_views_language_change', args=[obj.language.pk])\n+            self.assertContains(response, f'href=\"{expected_link}\"', html=True)\n+\n+    def test_readonly_foreignkey_links_default_admin_site(self):\n+        \"\"\"\n+        Test readonly ForeignKey links in the default admin site.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('admin')\n+\n+    def test_readonly_foreignkey_links_custom_admin_site(self):\n+        \"\"\"\n+        Test readonly ForeignKey links in a custom admin site.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('custom_admin')\n         language = Language.objects.create(iso='_40', name='Test')\n         obj = ReadOnlyRelatedField.objects.create(\n             chapter=chapter,\n             language=language,\n             user=self.superuser,\n         )\n+\n+    def _test_readonly_foreignkey_links(self, admin_site):\n+        \"\"\"\n+        Helper method to test readonly ForeignKey links for a given admin site.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1',\n+            content='content',\n+            book=Book.objects.create(name='Book 1'),\n+        )\n+        language = Language.objects.create(iso='en', name='English')\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+            language=language,\n+            user=self.superuser,\n+        )\n+        with self.subTest(admin_site=admin_site):\n+            # Fetch change view of the object\n+            response = self.client.get(reverse(f'{admin_site}:admin_views_readonlyrelatedfield_change', args=(obj.pk,)))\n+            self.assertEqual(response.status_code, 200)\n+\n+            # Check if the link points to the correct admin site\n+            expected_link = reverse(f'{admin_site}:admin_views_language_change', args=[obj.language.pk])\n+            self.assertContains(response, f'href=\"{expected_link}\"', html=True)\n+\n+    def test_readonly_foreignkey_links_default_admin_site(self):\n+        \"\"\"\n+        Test readonly ForeignKey links in the default admin site.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('admin')\n+\n+    def test_readonly_foreignkey_links_custom_admin_site(self):\n+        \"\"\"\n+        Test readonly ForeignKey links in a custom admin site.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('custom_admin')\n         response = self.client.get(\n             reverse('admin:admin_views_readonlyrelatedfield_change', args=(obj.pk,)),\n         )\n",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..350b8cc 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,10 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n+import json\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n",
  "django__django-14999": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 3e4c6c7..dfb8de6 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -792,8 +792,34 @@ class OperationTests(OperationTestBase):\n         self.assertEqual(Pony.objects.count(), 2)\n         self.assertEqual(Rider.objects.count(), 2)\n         self.assertEqual(Pony._meta.get_field('riders').remote_field.through.objects.count(), 2)\n+    from django.db import connection, models\n+    from django.db.migrations.state import ProjectState\n+    from django.test import TestCase\n+    import django.db.migrations.operations as migrations\n+\n+    class RenameModelWithDbTableNoOpTests(TestCase):\n+        def test_rename_model_with_db_table_noop(self):\n+            app_label = 'test_rmwdbtn'\n+            project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+                migrations.CreateModel('Rider', fields=[\n+                    ('id', models.AutoField(primary_key=True)),\n+                ], options={'db_table': 'rider'}),\n+                migrations.CreateModel('Pony', fields=[\n+                    ('id', models.AutoField(primary_key=True)),\n+                    ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+                ]),\n+            ])\n+            new_state = project_state.clone()\n+            operation = migrations.RenameModel('Rider', 'Runner')\n+            operation.state_forwards(app_label, new_state)\n \n-    def test_rename_m2m_target_model(self):\n+            with connection.schema_editor() as editor:\n+                with self.assertNumQueries(0):\n+                    operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+            with connection.schema_editor() as editor:\n+                with self.assertNumQueries(0):\n+                    operation.database_backwards(app_label, editor, new_state, project_state)\n         app_label = \"test_rename_m2m_target_model\"\n         project_state = self.apply_operations(app_label, ProjectState(), operations=[\n             migrations.CreateModel(\"Rider\", fields=[\n",
  "django__django-15061": "diff --git a/tests/forms_tests/field_tests/test_multivaluefield.py b/tests/forms_tests/field_tests/test_multivaluefield.py\nindex 53aee21..6567edf 100644\n--- a/tests/forms_tests/field_tests/test_multivaluefield.py\n+++ b/tests/forms_tests/field_tests/test_multivaluefield.py\n@@ -136,23 +136,12 @@ class MultiValueFieldTest(SimpleTestCase):\n         f = MultiValueField(fields=(CharField(), CharField()), disabled=True)\n         self.assertIs(f.has_changed(['x', 'x'], ['y', 'y']), False)\n \n-    def test_form_as_table(self):\n+    def test_multivalue_label_id(self):\n         form = ComplexFieldForm()\n-        self.assertHTMLEqual(\n-            form.as_table(),\n-            \"\"\"\n-            <tr><th><label for=\"id_field1_0\">Field1:</label></th>\n-            <td><input type=\"text\" name=\"field1_0\" id=\"id_field1_0\" required>\n-            <select multiple name=\"field1_1\" id=\"id_field1_1\" required>\n-            <option value=\"J\">John</option>\n-            <option value=\"P\">Paul</option>\n-            <option value=\"G\">George</option>\n-            <option value=\"R\">Ringo</option>\n-            </select>\n-            <input type=\"text\" name=\"field1_2_0\" id=\"id_field1_2_0\" required>\n-            <input type=\"text\" name=\"field1_2_1\" id=\"id_field1_2_1\" required></td></tr>\n-            \"\"\",\n-        )\n+        rendered_html = form.as_table()\n+        \n+        # Checking that the label is correct and does not have unnecessary \"0\"\n+        self.assertIn('<th><label for=\"id_field1_0\">Field1:</label></th>', rendered_html)\n \n     def test_form_as_table_data(self):\n         form = ComplexFieldForm({\n",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..112ee2b 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -70,6 +70,9 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # IPv6.\n             ('http://[12:34::3a53]/', 'http://[12:34::3a53]/'),\n             ('http://[a34:9238::]:8080/', 'http://[a34:9238::]:8080/'),\n+            # URLs causing ValueError instead of ValidationError\n+            ('////]@N.AN', None), # invalid URL \n+            ('#@A.bO', None), # empty hostname\n         ]\n         for url, expected in tests:\n             with self.subTest(url=url):\n@@ -100,6 +103,9 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # even on domains that don't fail the domain label length check in\n             # the regex.\n             'http://%s' % (\"X\" * 200,),\n+            # URLs causing ValueError instead of ValidationError\n+            ('////]@N.AN', None), # invalid URL \n+            ('#@A.bO', None), # empty hostname\n         ]\n         msg = \"'Enter a valid URL.'\"\n         for value in tests:\n@@ -107,7 +113,20 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n                 with self.assertRaisesMessage(ValidationError, msg):\n                     f.clean(value)\n \n-    def test_urlfield_clean_required(self):\n+    def test_urlfield_clean_valueerror(self):\n+        f = URLField()\n+        tests = [\n+            '////]@N.AN',\n+            '#@A.bO',\n+            # URLs causing ValueError instead of ValidationError\n+            ('////]@N.AN', None), # invalid URL \n+            ('#@A.bO', None), # empty hostname\n+        ]\n+        msg = \"'Enter a valid URL.'\"\n+        for value in tests:\n+            with self.subTest(value=value):\n+                with self.assertRaisesMessage(ValidationError, msg):\n+                    f.clean(value)\n         f = URLField()\n         msg = \"'This field is required.'\"\n         with self.assertRaisesMessage(ValidationError, msg):\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..8ab0197 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -12,6 +12,7 @@ from django.db.models.functions import (\n     Coalesce, ExtractYear, Floor, Length, Lower, Trim,\n )\n from django.test import TestCase, skipUnlessDBFeature\n+from django.db import connection\n from django.test.utils import register_lookup\n \n from .models import (\n@@ -197,7 +198,38 @@ class NonAggregateAnnotationTestCase(TestCase):\n         combined = int(test.pages + test.rating)\n         self.assertEqual(b.combined, combined)\n \n-    def test_empty_expression_annotation(self):\n+    def test_full_expression_annotation(self):\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_full_expression_annotation_with_aggregation(self):\n+        qs = Book.objects.filter(isbn='159059725').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in qs], [1])\n+\n+    def test_aggregate_over_full_expression_annotation(self):\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n+    def test_expressionwrapper_with_not_q_on_empty_list(self):\n+        books = Book.objects.annotate(\n+            foo=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).values(\"foo\")\n+        expected_query = 'SELECT 1 AS \"foo\" FROM \"annotations_book\"'\n+        actual_query = str(books.query)\n+        with connection.cursor() as cursor:\n+            cursor.execute(actual_query)\n+            result = cursor.fetchall()\n+\n+        self.assertEqual(expected_query, actual_query)\n+        self.assertTrue(all(row[0] == True for row in result))\n         books = Book.objects.annotate(\n             selected=ExpressionWrapper(Q(pk__in=[]), output_field=BooleanField())\n         )\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..b9dd9c3 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,4 @@\n+\n import json\n import random\n \n@@ -163,7 +164,16 @@ class CookieTests(BaseTests, SimpleTestCase):\n         decoded_messages = json.loads(value, cls=MessageDecoder)\n         self.assertEqual(messages, decoded_messages)\n \n-    def test_safedata(self):\n+    def test_extra_tags_serialization(self):\n+        \"\"\"\n+        Test that a message with empty string extra_tags is serialized\n+        and deserialized correctly without changing to None.\n+        \"\"\"\n+        storage = self.get_storage()\n+        message = Message(constants.INFO, 'Test message', extra_tags='')\n+        encoded = storage._encode(message)\n+        decoded = storage._decode(encoded)\n+        self.assertEqual(decoded.extra_tags, '')\n         \"\"\"\n         A message containing SafeData is keeping its safe status when\n         retrieved from the message storage.\n",
  "django__django-15388": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex 42ab5ba..c3a75f6 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -39,7 +39,16 @@ class TemplateReloadTests(SimpleTestCase):\n         self.assertIsNone(autoreload.template_changed(None, Path(__file__)))\n         mock_reset.assert_not_called()\n \n-    def test_watch_for_template_changes(self):\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    def test_dev_server_restart_on_file_change_with_base_dir_in_templates(self, mock_reset):\n+        test_directory = EXTRA_TEMPLATES_DIR / \"test_dir\"\n+        # Simulate adding BASE_DIR to TEMPLATES[0]['DIRS']\n+        with override_settings(TEMPLATES=[{\n+            'DIRS': [str(ROOT)],\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]):\n+            autoreload.template_changed(None, test_directory / 'test.html')\n+            mock_reset.assert_called_once()\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n         self.assertSequenceEqual(\n@@ -88,7 +97,16 @@ class TemplateReloadTests(SimpleTestCase):\n @require_jinja2\n @override_settings(INSTALLED_APPS=['template_tests'])\n class Jinja2TemplateReloadTests(SimpleTestCase):\n-    def test_watch_for_template_changes(self):\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    def test_dev_server_restart_on_file_change_with_base_dir_in_templates(self, mock_reset):\n+        test_directory = EXTRA_TEMPLATES_DIR / \"test_dir\"\n+        # Simulate adding BASE_DIR to TEMPLATES[0]['DIRS']\n+        with override_settings(TEMPLATES=[{\n+            'DIRS': [str(ROOT)],\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]):\n+            autoreload.template_changed(None, test_directory / 'test.html')\n+            mock_reset.assert_called_once()\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n         self.assertSequenceEqual(\n",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..90a4fdd 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -184,6 +185,27 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"\n+        Test was_modified_since with an empty string for If-Modified-Since header.\n+        Ensure it returns True without raising an exception.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=\"\", mtime=1))\n+\n+    def test_was_modified_since_none_header(self):\n+        \"\"\"\n+        Test was_modified_since with None as If-Modified-Since header.\n+        Ensure it returns True without raising an exception.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=None, mtime=1))\n+\n+    def test_was_modified_since_invalid_date(self):\n+        \"\"\"\n+        Test was_modified_since with an invalid date string for If-Modified-Since header.\n+        Ensure it returns True as the header cannot be parsed into a date.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=\"invalid-date\", mtime=1))\n+\n     def test_was_modified_since_fp(self):\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..3240aee 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,3 +1,4 @@\n+\n import os\n from io import StringIO\n from unittest import mock\n@@ -8,6 +9,7 @@ from django.apps import apps\n from django.core import management\n from django.core.checks import Tags\n from django.core.management import BaseCommand, CommandError, find_commands\n+from argparse import ArgumentDefaultsHelpFormatter\n from django.core.management.utils import (\n     find_command,\n     get_random_secret_key,\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..d560196 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,6 +1,8 @@\n+\n import os\n from datetime import datetime\n \n+from django.core.serializers.json import DjangoJSONEncoder\n from django.test import SimpleTestCase\n from django.utils.functional import lazystr\n from django.utils.html import (\n@@ -211,7 +213,20 @@ class TestUtilsHtml(SimpleTestCase):\n             with self.subTest(arg=arg):\n                 self.assertEqual(json_script(arg, \"test_id\"), expected)\n \n-    def test_json_script_without_id(self):\n+    def test_json_script_custom_encoder(self):\n+        # Define a custom JSON encoder\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                # Custom-encode the JSON output\n+                return '{\"custom\": \"output\"}'\n+\n+        # Test that `json_script` properly uses the custom encoder\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"custom\": \"output\"}</script>',\n+        )\n+\n+    def test_json_script_existing_behavior(self):\n         self.assertHTMLEqual(\n             json_script({\"key\": \"value\"}),\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n",
  "django__django-15790": "",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..4a7b842 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -395,7 +395,20 @@ class ProxyModelTests(TestCase):\n         p = MyPerson.objects.get(pk=100)\n         self.assertEqual(p.name, \"Elvis Presley\")\n \n-    def test_eq(self):\n+    def test_select_related_only_with_proxy(self):\n+        # Set up initial data for testing.\n+        custom = CustomModel.objects.create(name=\"Test\")\n+        proxy_custom = ProxyCustomModel.objects.create(name=\"Test\")\n+        another_model = AnotherModel.objects.create(custom=proxy_custom)\n+\n+        # Test the broken behavior\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+\n+        # Ensure no error occurs and the retrieved element is correct.\n+        result = qs.get()\n+        self.assertEqual(result, another_model)\n+        self.assertEqual(result.custom, proxy_custom)\n+        self.assertEqual(result.custom.name, \"Test\")\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n \n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..bfa4fe4 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -154,7 +154,14 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n     def test_parameters(self):\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n-            ([\"psql\", \"dbname\", \"--help\"], None),\n+            ([\"psql\", \"--help\", \"dbname\"], None),\n+        )\n+\n+    def test_query_parameter_before_dbname(self):\n+        # Test additional parameter -c \"SELECT...\" is before dbname\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"select * from some_table;\"]),\n+            ([\"psql\", \"-c\", \"select * from some_table;\", \"dbname\"], None),\n         )\n \n     @skipUnless(connection.vendor == \"postgresql\", \"Requires a PostgreSQL connection\")\n@@ -183,4 +190,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 44ea946..437139b 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1901,6 +1901,27 @@ class AllValidTests(SimpleTestCase):\n class DeprecationTests(SimpleTestCase):\n     def test_warning(self):\n         from django.forms.utils import DEFAULT_TEMPLATE_DEPRECATION_MSG\n+        from django.forms import formset_factory\n+        from django.test import TestCase, override_settings\n+        from myapp.forms import Choice, BaseFormSet\n+        from django.core.exceptions import ImproperlyConfigured\n+        import warnings\n+\n+        class ManagementFormDeprecationWarningTests(TestCase):\n+\n+            def test_no_warning_for_management_form_with_choice(self):\n+                \"\"\"Test that rendering management form does not raise deprecation warning.\"\"\"\n+\n+                with isolate_lru_cache(get_default_renderer), self.settings(\n+                    FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n+                ):\n+                    ChoiceFormSet = formset_factory(Choice, formset=BaseFormSet)\n+                    formset = ChoiceFormSet()\n+                    with warnings.catch_warnings(record=True) as captured_warnings:\n+                        warnings.simplefilter(\"always\")  # Capture all warnings\n+                        str(formset.management_form)\n+                        # Assert that no warnings are captured on management_form rendering\n+                        self.assertFalse(bool(captured_warnings), \"Deprecation warning raised for management form.\")\n \n         with isolate_lru_cache(get_default_renderer), self.settings(\n             FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n@@ -1909,4 +1930,4 @@ class DeprecationTests(SimpleTestCase):\n         ):\n             ChoiceFormSet = formset_factory(Choice)\n             formset = ChoiceFormSet()\n-            str(formset)\n+            str(formset)\n",
  "django__django-16041": "",
  "django__django-16046": "",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..38a6e5c 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -21,6 +22,8 @@ from django.core.exceptions import ValidationError\n from django.core.mail import EmailMultiAlternatives\n from django.forms import forms\n from django.forms.fields import CharField, Field, IntegerField\n+import urllib.parse\n+from django.urls import reverse\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.utils import translation\n from django.utils.text import capfirst\n@@ -884,7 +887,26 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # original hashed password contains $\n         self.assertIn(\"$\", form.cleaned_data[\"password\"])\n \n-    def test_bug_19349_bound_password_field(self):\n+\n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search('<a href=\"(.*?)\">', password_help_text)\n+\n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.username,),  # assuming username is used in the URL when to_field\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n         user = User.objects.get(username=\"testclient\")\n         form = UserChangeForm(data={}, instance=user)\n         # When rendering the bound password field,\n",
  "django__django-16255": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 1469efd..ebca383 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -508,6 +508,61 @@ class HTTPSitemapTests(SitemapTestsBase):\n         self.assertXMLEqual(sitemap_response.content.decode(), expected_content_sitemap)\n \n \n+from django.test import TestCase\n+from django.contrib.sitemaps import Sitemap\n+from django.urls import path\n+from datetime import datetime\n+from .views import index\n+\n+class CallableLastmodNoItemsSitemap(Sitemap):\n+    location = \"/location/\"\n+\n+    def items(self):\n+        return []\n+\n+    def lastmod(self, obj):\n+        return obj.lastmod\n+\n+class SitemapTestsBase(TestCase):\n+    def test_callable_sitemod_no_items(self):\n+        index_response = self.client.get(\"/callable-lastmod-no-items/index.xml\")\n+        self.assertNotIn(\"Last-Modified\", index_response)\n+        expected_content_index = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n+        <sitemap><loc>http://example.com/simple/sitemap-callable-lastmod.xml</loc></sitemap>\n+        </sitemapindex>\n+        \"\"\"\n+        self.assertXMLEqual(index_response.content.decode(), expected_content_index)\n+\n+class CallableLastmodItemsSitemap(Sitemap):\n+    location = \"/location/\"\n+\n+    def items(self):\n+        o1 = TestModel()\n+        o1.lastmod = datetime(2023, 1, 1, 10, 0, 0)\n+        return [o1]\n+\n+    def lastmod(self, obj):\n+        return obj.lastmod\n+\n+    def test_callable_sitemod_with_items(self):\n+        index_response = self.client.get(\"/callable-lastmod-with-items/index.xml\")\n+        self.assertIn(\"Last-Modified\", index_response)\n+        expected_content_index = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n+        <sitemap><loc>http://example.com/simple/sitemap-callable-lastmod.xml</loc></sitemap>\n+        </sitemapindex>\n+        \"\"\"\n+        self.assertXMLEqual(index_response.content.decode(), expected_content_index)\n+\n+callable_lastmod_no_items_sitemap = {\n+    \"callable-lastmod\": CallableLastmodNoItemsSitemap,\n+}\n+\n+urlpatterns += [\n+    path(\"callable-lastmod-no-items/index.xml\", index, {\"sitemaps\": callable_lastmod_no_items_sitemap}),\n+]\n+\n # RemovedInDjango50Warning\n class DeprecatedTests(SitemapTestsBase):\n     @override_settings(\n",
  "django__django-16379": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 014d28a..394cccf 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1,6 +1,8 @@\n+\n # Unit tests for cache framework\n # Uses whatever cache backend is set in the test settings file.\n import copy\n+from unittest import mock\n import io\n import os\n import pickle\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..0bca1f7 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,10 +1,13 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n from django.contrib.admin.templatetags.admin_list import date_hierarchy\n from django.contrib.admin.templatetags.admin_modify import submit_row\n from django.contrib.auth.admin import UserAdmin\n+from django.contrib.auth import get_permission_codename\n from django.contrib.auth.models import User\n+from .tests import get_perm\n from django.test import RequestFactory, TestCase\n from django.urls import reverse\n \n@@ -33,7 +36,42 @@ class AdminTemplateTagsTest(AdminViewBasicTestCase):\n         self.assertIs(template_context[\"extra\"], True)\n         self.assertIs(template_context[\"show_save\"], True)\n \n-    def test_override_show_save_and_add_another(self):\n+    def test_submit_row_save_as_new_with_add_permission(self):\n+        \"\"\"Ensure 'show_save_as_new' is True when 'add' permission is present.\"\"\"\n+        add_user = User.objects.create_user(\n+            username=\"test_add_user\", password=\"secret\", is_staff=True\n+        )\n+        add_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"add\", User._meta)),\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk]),\n+        )\n+        request.user = add_user\n+        admin = UserAdmin(User, site)\n+        admin.save_as = True\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], True)\n+\n+    def test_submit_row_save_as_new_without_add_permission(self):\n+        \"\"\"Ensure 'show_save_as_new' is False when 'add' permission is absent.\"\"\"\n+        change_user = User.objects.create_user(\n+            username=\"test_change_user\", password=\"secret\", is_staff=True\n+        )\n+        change_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk]),\n+        )\n+        request.user = change_user\n+        admin = UserAdmin(User, site)\n+        admin.save_as = True\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], False)\n         request = self.request_factory.get(\n             reverse(\"admin:auth_user_change\", args=[self.superuser.pk]),\n         )\n",
  "django__django-16595": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 3979e76..525d66f 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -236,7 +236,36 @@ class OptimizerTests(SimpleTestCase):\n             ],\n         )\n \n-    def test_alter_alter_table_model(self):\n+    def _test_alter_alter_field(self, alter_foo, alter_bar):\n+        \"\"\"AlterField should collapse into the second.\"\"\"\n+        self.assertOptimizesTo(\n+            [\n+                alter_foo,\n+                alter_bar,\n+            ],\n+            [\n+                alter_bar,\n+            ],\n+        )\n+\n+    def test_alter_alter_field(self):\n+        self._test_alter_alter_field(\n+            operations.AlterField(\"book\", \"title\", models.CharField(max_length=256, null=True)),\n+            operations.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True, help_text=\"help\", default=None)),\n+        )\n+\n+    def test_multiple_alter_fields(self):\n+        self.assertOptimizesTo(\n+            [\n+                operations.AlterField(\"book\", \"title\", models.CharField(max_length=256, null=True)),\n+                operations.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True)),\n+                operations.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True, help_text=\"help\")),\n+                operations.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True, help_text=\"help\", default=None)),\n+            ],\n+            [\n+                operations.AlterField(\"book\", \"title\", models.CharField(max_length=128, null=True, help_text=\"help\", default=None)),\n+            ],\n+        )\n         self._test_alter_alter_model(\n             migrations.AlterModelTable(\"Foo\", \"a\"),\n             migrations.AlterModelTable(\"Foo\", \"b\"),\n",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..8c7b319 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,3 +1,4 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n@@ -5,7 +6,26 @@ from django.utils.safestring import mark_safe\n from ..utils import setup\n \n \n+from django.template.defaultfilters import escape\n+\n class JoinTests(SimpleTestCase):\n+    # Issue reproduction and verification test\n+    @setup({\"join_autoescape_off_issue\": '{% autoescape off %}{{ some_list|join:some_var }}{% endautoescape %}'})\n+    def test_join_autoescape_off_issue(self):\n+        some_list = [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"]\n+        some_var = \"<br/>\"\n+        output = self.engine.render_to_string(\"join_autoescape_off_issue\", {\"some_list\": some_list, \"some_var\": some_var})\n+        # The original issue shows that some_var is currently being escaped, but it shouldn't be.\n+        self.assertEqual(output, some_var.join(some_list))\n+        \n+    # Additional test to confirm the fixed expected behavior matches when not using autoescape\n+    @setup({\"join_autoescape_false\": '{{ some_list|join:some_var }}'})\n+    def test_join_autoescape_false(self):\n+        some_list = [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"]\n+        some_var = \"<br/>\"\n+        output = self.engine.render_to_string(\"join_autoescape_false\", {\"some_list\": some_list, \"some_var\": some_var})\n+        # Here, some_var is escaped because autoescape is on by default\n+        self.assertEqual(output, escape(some_var.join(some_list)))\n     @setup({\"join01\": '{{ a|join:\", \" }}'})\n     def test_join01(self):\n         output = self.engine.render_to_string(\"join01\", {\"a\": [\"alpha\", \"beta & me\"]})\n@@ -78,4 +98,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..f8a2f2d 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -569,6 +569,63 @@ class BulkCreateTests(TestCase):\n                 unique_fields=[\"big_auto_fields\"],\n             )\n \n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        # Create initial objects\n+        obj1 = TwoFields.objects.create(f1=1, f2=1, name=\"Initial Name 1\")\n+        obj2 = TwoFields.objects.create(f1=2, f2=2, name=\"Initial Name 2\")\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        # Update objects with conflicting f1 and f2 but should return IDs\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"New Name 1\"),\n+            TwoFields(f1=2, f2=2, name=\"New Name 2\"),\n+        ]\n+        \n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            update_fields=[\"name\"],\n+            unique_fields=[\"f1\", \"f2\"],\n+        )\n+\n+        self.assertEqual(len(results), 2)\n+\n+        for instance in results:\n+            self.assertIsNotNone(instance.pk)\n+\n+        updated_objects = TwoFields.objects.all()\n+        self.assertCountEqual([obj.name for obj in updated_objects], [\"New Name 1\", \"New Name 2\"])\n+\n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_bulk_create_upsert_returns_all_ids(self):\n+        # Set up initial data\n+        existing_data = [\n+            UpsertConflict(number=1, rank=1, name=\"John\"),\n+            UpsertConflict(number=2, rank=2, name=\"Mary\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(existing_data)\n+\n+        # Upsert data with some new rows\n+        upsert_data = [\n+            UpsertConflict(number=1, rank=1, name=\"Johnny\"),  # Conflict, should update\n+            UpsertConflict(number=3, rank=3, name=\"Hannah\"),  # New, should insert\n+        ]\n+\n+        results = UpsertConflict.objects.bulk_create(\n+            upsert_data,\n+            update_conflicts=True,\n+            update_fields=[\"name\"],\n+            unique_fields=[\"number\"],\n+        )\n+\n+        self.assertEqual(UpsertConflict.objects.count(), 3)\n+\n+        # Validate returning IDs\n+        self.assertEqual(len(results), 2)\n+        for instance in results:\n+            self.assertIsNotNone(instance.pk)\n+\n     def _test_update_conflicts_two_fields(self, unique_fields):\n         TwoFields.objects.bulk_create(\n             [\n@@ -816,4 +873,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..cce1d05 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -197,6 +197,34 @@ class OperationWriterTests(SimpleTestCase):\n             \"),\",\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -255,12 +283,68 @@ class WriterTests(SimpleTestCase):\n             decimal.Decimal(\"1.3\"), (\"Decimal('1.3')\", {\"from decimal import Decimal\"})\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n         self.assertSerializedEqual(Money(\"1.3\"))\n         self.assertSerializedResultEqual(\n             Money(\"1.3\"),\n             (\"migrations.test_writer.Money('1.3')\", {\"import migrations.test_writer\"}),\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -296,6 +380,34 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set()),\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r\"^foo$\")\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -306,6 +418,34 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\n@@ -313,6 +453,34 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\n@@ -320,10 +488,66 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -331,11 +555,67 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(\n             default=TextEnum.B, choices=[(m.value, m) for m in TextEnum]\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -344,10 +624,66 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -356,9 +692,65 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         field = models.CharField(\n             default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum]\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -367,9 +759,65 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         field = models.IntegerField(\n             default=IntEnum.A, choices=[(m.value, m) for m in IntEnum]\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -379,6 +827,34 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n@@ -387,6 +863,34 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n@@ -394,9 +898,65 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -405,6 +965,34 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A | IntFlagEnum.B,\n             (\n@@ -414,6 +1002,34 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = \"A\", \"A value\"\n@@ -433,6 +1049,34 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             (\"datetime.date(1969, 7, 20)\", {\"import datetime\"}),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         field = models.CharField(default=TextChoices.B, choices=TextChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -440,12 +1084,68 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -456,6 +1156,34 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\",\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_nested_class(self):\n         for nested_cls in [self.NestedEnum, self.NestedChoices]:\n             cls_name = nested_cls.__name__\n@@ -478,14 +1206,98 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {\"import uuid\"}),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {\"import uuid\"}),\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n         field = models.UUIDField(\n             choices=((uuid_a, \"UUID A\"), (uuid_b, \"UUID B\")), default=uuid_a\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -495,6 +1307,34 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\",\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_pathlib(self):\n         # Pure path objects work in all platforms.\n         self.assertSerializedEqual(pathlib.PurePosixPath())\n@@ -523,6 +1363,34 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"models.FilePathField(path=pathlib.PurePosixPath('/home/user'))\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertIn(\"import pathlib\", imports)\n \n     def test_serialize_path_like(self):\n@@ -554,13 +1422,97 @@ class WriterTests(SimpleTestCase):\n         self.assertSerializedEqual(\n             datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone())\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedEqual(\n             datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180))\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {\"import datetime\"}),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc),\n             (\n@@ -568,6 +1520,34 @@ class WriterTests(SimpleTestCase):\n                 {\"import datetime\"},\n             ),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(\n                 2012, 1, 1, 2, 1, tzinfo=zoneinfo.ZoneInfo(\"Europe/Paris\")\n@@ -578,12 +1558,68 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"}),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n@@ -593,20 +1629,132 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(\n             SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\")\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedResultEqual(\n             SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"}),\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)), (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -624,6 +1772,34 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.RegexValidator(message='hello')\"\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a compiled regex.\n@@ -633,6 +1809,34 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test a string regex with flag\n@@ -643,6 +1847,34 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[0-9]+$', \"\n             \"flags=re.RegexFlag['DOTALL'])\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n@@ -653,6 +1885,34 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', \"\n             \"'invalid')\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a subclass.\n@@ -661,6 +1921,34 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.EmailValidator(message='hello')\"\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.serialize_round_trip(validator)\n \n         validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(\n@@ -671,9 +1959,65 @@ class WriterTests(SimpleTestCase):\n             string, \"migrations.test_writer.EmailValidator(message='hello')\"\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n         validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(\n             message=\"hello\"\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n             MigrationWriter.serialize(validator)\n \n@@ -700,6 +2044,34 @@ class WriterTests(SimpleTestCase):\n             models.OrderBy(models.F(\"name\").desc()),\n             name=\"complex_func_index\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         string, imports = MigrationWriter.serialize(index)\n         self.assertEqual(\n             string,\n@@ -711,6 +2083,34 @@ class WriterTests(SimpleTestCase):\n             \"models.OrderBy(models.OrderBy(models.F('name'), descending=True)), \"\n             \"name='complex_func_index')\",\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertEqual(imports, {\"from django.db import models\"})\n \n     def test_serialize_empty_nonempty_tuple(self):\n@@ -762,6 +2162,34 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.models\"},\n             ),\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         self.assertSerializedEqual(FoodManager(\"a\", \"b\"))\n         self.assertSerializedEqual(FoodManager(\"x\", \"y\", c=3, d=4))\n \n@@ -772,6 +2200,34 @@ class WriterTests(SimpleTestCase):\n             frozenset(\"cba\"), (\"frozenset(['a', 'b', 'c'])\", set())\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_serialize_set(self):\n         self.assertSerializedEqual(set())\n         self.assertSerializedResultEqual(set(), (\"set()\", set()))\n@@ -809,6 +2265,34 @@ class WriterTests(SimpleTestCase):\n             (\"('models.Model', {'from django.db import models'})\", set()),\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -848,6 +2332,34 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [(\"testapp\", \"some_other_one\")],\n             },\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         # We don't test the output formatting - that's too fragile.\n@@ -887,6 +2399,34 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -896,6 +2436,34 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_sorted_dependencies(self):\n         migration = type(\n             \"Migration\",\n@@ -912,6 +2480,34 @@ class WriterTests(SimpleTestCase):\n                 ],\n             },\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         output = MigrationWriter(migration, include_header=False).as_string()\n         self.assertIn(\n             \"    dependencies = [\\n\"\n@@ -923,6 +2519,34 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -949,6 +2573,34 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -956,6 +2608,34 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -1001,6 +2681,34 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\"from django.db import migrations\\n\", output)\n@@ -1017,6 +2725,34 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\",\n         )\n \n+    class Profile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be serialized\n+        correctly when used as a field default value.\n+        \"\"\"\n+        field = django.contrib.postgres.fields.ArrayField(\n+            models.CharField(choices=self.Profile.Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=self.Profile.Capability.default\n+        )\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"django.contrib.postgres.fields.ArrayField(\"\n+            \"base_field=models.CharField(max_length=30, blank=True, choices=\"\n+            \"[('BASIC', 'Basic'), ('PROFESSIONAL', 'Professional')]), \"\n+            \"default=migrations.test_writer.WriterTests.Profile.Capability.default, null=True)\",\n+            serialized_field\n+        )\n+\n     def test_register_serializer(self):\n         class ComplexSerializer(BaseSerializer):\n             def serialize(self):\n@@ -1032,4 +2768,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "matplotlib__matplotlib-22711": "",
  "matplotlib__matplotlib-23299": "diff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 144880c..337cac1 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -507,8 +507,25 @@ def test_rcparams_reset_after_fail():\n                 pass\n         assert mpl.rcParams['text.usetex'] is False\n \n+def test_get_backend_does_not_clear_figs_created_in_rccontext():\n+    import matplotlib.pyplot as plt\n+    from matplotlib import get_backend\n \n-@pytest.mark.skipif(sys.platform != \"linux\", reason=\"Linux only\")\n+    # Create a figure within an rc_context\n+    with plt.rc_context():\n+        fig2 = plt.figure()\n+\n+    # Capture the state before calling get_backend()\n+    before = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+\n+    # Call get_backend() which should not clear the figures\n+    get_backend()\n+\n+    # Capture the state after calling get_backend()\n+    after = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+\n+    # Assert that the figures are not cleared\n+    assert before == after, '\\n' + before + '\\n' + after\n def test_backend_fallback_headless(tmpdir):\n     env = {**os.environ,\n            \"DISPLAY\": \"\", \"WAYLAND_DISPLAY\": \"\",\n",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..0c47b41 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -21,7 +21,23 @@ mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n \n-def test_aspect_equal_error():\n+@check_figures_equal(extensions=[\"png\"])\n+def test_invisible_3d_axes(fig_test, fig_ref):\n+    ax_test = fig_test.add_subplot(projection='3d')\n+    ax_test.scatter([1], [1], [1], c='b')\n+    ax_test.set_visible(False)\n+    \n+    ax_ref = fig_ref.add_subplot(projection='3d')\n+    ax_ref.scatter([1], [1], [1], c='b')\n+    ax_ref.set_facecolor('w')\n+\n+@check_figures_equal(extensions=[\"png\"])\n+def test_visible_3d_axes(fig_test, fig_ref):\n+    ax_test = fig_test.add_subplot(projection='3d')\n+    ax_test.scatter([1], [1], [1], c='b')\n+    \n+    ax_ref = fig_ref.add_subplot(projection='3d')\n+    ax_ref.scatter([1], [1], [1], c='b')\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     with pytest.raises(NotImplementedError):\n",
  "matplotlib__matplotlib-23562": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex a51a857..2ed35f3 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -1802,7 +1802,33 @@ def test_pathpatch_3d(fig_test, fig_ref):\n @image_comparison(baseline_images=['scatter_spiral.png'],\n                   remove_text=True,\n                   style='default')\n-def test_scatter_spiral():\n+def test_Poly3DCollection_get_facecolor():\n+    # Test to ensure get_facecolor does not raise any error\n+    y, x = np.ogrid[1:10:100j, 1:10:100j]\n+    z2 = np.cos(x) ** 3 - np.sin(y) ** 2\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111, projection='3d')\n+    r = ax.plot_surface(x, y, z2, cmap='hot')\n+    try:\n+        r.get_facecolor()\n+        facecolor_error_raised = False\n+    except AttributeError:\n+        facecolor_error_raised = True\n+    assert not facecolor_error_raised, \"get_facecolor() raised AttributeError unexpectedly!\"\n+\n+def test_Poly3DCollection_get_edgecolor():\n+    # Test to ensure get_edgecolor does not raise any error\n+    y, x = np.ogrid[1:10:100j, 1:10:100j]\n+    z2 = np.cos(x) ** 3 - np.sin(y) ** 2\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111, projection='3d')\n+    r = ax.plot_surface(x, y, z2, cmap='hot')\n+    try:\n+        r.get_edgecolor()\n+        edgecolor_error_raised = False\n+    except AttributeError:\n+        edgecolor_error_raised = True\n+    assert not edgecolor_error_raised, \"get_edgecolor() raised AttributeError unexpectedly!\"\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     th = np.linspace(0, 2 * np.pi * 6, 256)\n",
  "matplotlib__matplotlib-23563": "",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..aff4909 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -773,6 +773,24 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n     for text, color in zip(leg.get_texts(), ['r', 'g', 'b']):\n         assert mpl.colors.same_color(text.get_color(), color)\n \n+import matplotlib.pyplot as plt\n+import pytest\n+\n+@pytest.mark.parametrize('draggable', (True, False))\n+def test_legend_draggable(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='shabnams')\n+    leg = ax.legend(draggable=draggable)\n+    assert leg.get_draggable() is draggable\n+\n+@pytest.mark.parametrize('handles, labels, draggable', [\n+    ([], [], True),\n+    ([], [], False),\n+])\n+def test_legend_no_handles_labels(handles, labels, draggable):\n+    fig, ax = plt.subplots()\n+    leg = ax.legend(handles, labels, draggable=draggable)\n+    assert leg.get_draggable() is draggable\n \n def test_get_set_draggable():\n     legend = plt.legend()\n",
  "matplotlib__matplotlib-23964": "diff --git a/lib/matplotlib/tests/test_backend_ps.py b/lib/matplotlib/tests/test_backend_ps.py\nindex a1caf1a..a49baad 100644\n--- a/lib/matplotlib/tests/test_backend_ps.py\n+++ b/lib/matplotlib/tests/test_backend_ps.py\n@@ -256,6 +256,38 @@ def test_linedash():\n     assert buf.tell() > 0\n \n \n+import io\n+from matplotlib.figure import Figure\n+\n+def test_empty_line():\n+    # Smoke-test for issue with multi-line text with empty line in PS backend\n+    figure = Figure()\n+    figure.text(0.5, 0.5, \"\\nfoo\\n\\n\")\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n+    assert buf.tell() > 0\n+\n+def test_empty_line_annotation():\n+    # Test with an annotation that includes an empty line\n+    figure = Figure()\n+    ax = figure.add_subplot(111)\n+    ax.annotate(text='\\nTest annotation with empty line\\n', xy=(0, 0))\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n+    assert buf.tell() > 0\n+\n+def test_empty_multiline_title():\n+    # Test with a title that includes an empty line\n+    figure = Figure()\n+    ax = figure.add_subplot(111)\n+    ax.set_title('\\nTitle with empty line\\nAnother line')\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n+    assert buf.tell() > 0\n+\n def test_no_duplicate_definition():\n \n     fig = Figure()\n",
  "matplotlib__matplotlib-23987": "diff --git a/lib/matplotlib/tests/test_constrainedlayout.py b/lib/matplotlib/tests/test_constrainedlayout.py\nindex 41fdfa1..344d79f 100644\n--- a/lib/matplotlib/tests/test_constrainedlayout.py\n+++ b/lib/matplotlib/tests/test_constrainedlayout.py\n@@ -652,7 +652,27 @@ def test_compressed1():\n \n     pos = axs[0, 0].get_position()\n     np.testing.assert_allclose(pos.x0, 0.06195, atol=1e-3)\n+\n+# Test to ensure no UserWarning is raised when constrained_layout=False\n+@pytest.mark.filterwarnings('error::UserWarning')\n+def test_no_userwarning_constrained_layout_false():\n+    import matplotlib.pyplot as plt\n+    import numpy as np\n+    \n+    a = np.linspace(0, 2*np.pi, 100)\n+    b = np.sin(a)\n+    c = np.cos(a)\n+    \n+    # Test case for the reported bug\n+    fig, ax = plt.subplots(1, 2, figsize=(8, 2), constrained_layout=False)\n+    ax[0].plot(a, b)\n+    ax[1].plot(a, c)\n+\n+    try:\n+        plt.subplots_adjust(wspace=0)\n+    except UserWarning:\n+        pytest.fail(\"Unexpected UserWarning raised with constrained_layout=False\")\n     np.testing.assert_allclose(pos.y1, 0.8537, atol=1e-3)\n     pos = axs[1, 2].get_position()\n     np.testing.assert_allclose(pos.x1, 0.8618, atol=1e-3)\n-    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n+    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "",
  "matplotlib__matplotlib-24970": "diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex 2be14fe..bc81b60 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -29,8 +29,21 @@ def test_create_lookup_table(N, result):\n     data = [(0.0, 1.0, 1.0), (0.5, 0.2, 0.2), (1.0, 0.0, 0.0)]\n     assert_array_almost_equal(mcolors._create_lookup_table(N, data), result)\n \n+import pytest\n+import matplotlib.pyplot as plt\n+import numpy as np\n+from numpy.testing import assert_array_equal\n+import matplotlib as mpl\n+\n+@pytest.mark.parametrize(\"dtype\", [np.uint8, int, np.float16, float])\n+def test_index_dtype(dtype):\n+    # We use subtraction in the indexing, so need to verify that uint8 works\n+    cm = mpl.colormaps[\"viridis\"]\n+    assert_array_equal(cm(dtype(0)), cm(0))\n \n-def test_resampled():\n+def test_deprecation_warning_fix():\n+    with pytest.deprecated_call():\n+        plt.get_cmap()(np.empty((0,), dtype=np.uint8))\n     \"\"\"\n     GitHub issue #6025 pointed to incorrect ListedColormap.resampled;\n     here we test the method for LinearSegmentedColormap as well.\n",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..ba9a49c 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -16,8 +17,28 @@ import matplotlib.transforms as mtransforms\n import matplotlib.figure as mfigure\n from mpl_toolkits.axes_grid1 import parasite_axes\n \n+import pickletools\n \n-def test_simple():\n+def test_pickling_draggable_legend():\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111)\n+    \n+    time = [0, 1, 2, 3, 4]\n+    speed = [40, 43, 45, 47, 48]\n+    \n+    ax.plot(time, speed, label=\"speed\")\n+    leg = ax.legend()\n+    leg.set_draggable(True)\n+    \n+    # Pickle the figure\n+    pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+    \n+    # Check that 'FigureCanvasAgg' is not in the pickle stream\n+    assert \"FigureCanvasAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+    \n+    # Load the pickle to ensure it can be loaded without errors\n+    loaded_fig = pickle.loads(pkl)\n+    assert loaded_fig is not None\n     fig = plt.figure()\n     pickle.dump(fig, BytesIO(), pickle.HIGHEST_PROTOCOL)\n \n",
  "matplotlib__matplotlib-25332": "",
  "matplotlib__matplotlib-25442": "diff --git a/lib/matplotlib/tests/test_offsetbox.py b/lib/matplotlib/tests/test_offsetbox.py\nindex 204af9c..722985e 100644\n--- a/lib/matplotlib/tests/test_offsetbox.py\n+++ b/lib/matplotlib/tests/test_offsetbox.py\n@@ -446,7 +446,57 @@ def test_paddedbox():\n     ab = AnchoredOffsetbox('upper right', child=pb)\n     ax.add_artist(ab)\n \n+def test_mplcursor_interaction():\n+    import matplotlib.pyplot as plt\n+    import mplcursors\n+\n+    fig, ax = plt.subplots()\n+    x = range(10)\n+    y = range(10)\n+    scatter = ax.scatter(x, y)\n+    \n+    cursor = mplcursors.cursor(scatter, hover=True)\n+    cursor.connect(\"add\", lambda sel: sel.annotation.set_text(f'x: {sel.index}'))\n+\n+    plt_connect = fig.canvas.mpl_connect\n+    plt_disconnect = fig.canvas.mpl_disconnect\n+\n+    # Simulating events to ensure no errors\n+    cid_press = plt_connect(\"button_press_event\", lambda event: None)\n+    cid_release = plt_connect(\"button_release_event\", lambda event: None)\n+    fig.canvas.callbacks.process(\"button_press_event\", None)\n+    fig.canvas.callbacks.process(\"button_release_event\", None)\n+    plt_disconnect(cid_press)\n+    plt_disconnect(cid_release)\n+\n+    plt.close(fig)\n+\n     ta = TextArea(\"foobar\")\n     pb = PaddedBox(ta, pad=15, draw_frame=True)\n     ab = AnchoredOffsetbox('lower right', child=pb)\n-    ax.add_artist(ab)\n+    ax.add_artist(ab)\n+\n+def test_mplcursor_interaction():\n+    import matplotlib.pyplot as plt\n+    import mplcursors\n+\n+    fig, ax = plt.subplots()\n+    x = range(10)\n+    y = range(10)\n+    scatter = ax.scatter(x, y)\n+    \n+    cursor = mplcursors.cursor(scatter, hover=True)\n+    cursor.connect(\"add\", lambda sel: sel.annotation.set_text(f'x: {sel.index}'))\n+\n+    plt_connect = fig.canvas.mpl_connect\n+    plt_disconnect = fig.canvas.mpl_disconnect\n+\n+    # Simulating events to ensure no errors\n+    cid_press = plt_connect(\"button_press_event\", lambda event: None)\n+    cid_release = plt_connect(\"button_release_event\", lambda event: None)\n+    fig.canvas.callbacks.process(\"button_press_event\", None)\n+    fig.canvas.callbacks.process(\"button_release_event\", None)\n+    plt_disconnect(cid_press)\n+    plt_disconnect(cid_release)\n+\n+    plt.close(fig)\n",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\nindex 9aa3203..acd93a6 100644\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -1,4 +1,5 @@\n \n+\n import numpy as np\n import pandas as pd\n \n@@ -8,9 +9,39 @@ from numpy.testing import assert_array_equal, assert_array_almost_equal\n from seaborn._core.groupby import GroupBy\n from seaborn._stats.regression import PolyFit\n \n+from pandas.testing import assert_frame_equal\n \n class TestPolyFit:\n \n+    def test_polyfit_with_missing_data(self):\n+        df = pd.DataFrame({\n+            'x': [1, 2, 3, None, 4, 5],\n+            'y': [1, 4, 9, 16, 25, 36],\n+            'group': [1, 1, 1, 1, 1, 1]\n+        })\n+        groupby = GroupBy(['group'])\n+        # Apply PolyFit to data with missing values removed\n+        res1 = PolyFit()(df.dropna(subset=['x', 'y']), groupby, 'x', {})\n+        # Apply PolyFit to data without removing missing values to see if it handles automatically\n+        res2 = PolyFit()(df, groupby, 'x', {})\n+\n+        # Ensure the results are the same, implying missing values are handled correctly\n+        assert_frame_equal(res1, res2)\n+\n+    def test_polyfit_with_all_missing_data(self):\n+        df = pd.DataFrame({\n+            'x': [None, None, None, None],\n+            'y': [None, None, None, None],\n+            'group': [1, 1, 1, 1]\n+        })\n+        groupby = GroupBy(['group'])\n+        # Apply PolyFit to data with all missing values\n+        res = PolyFit()(df, groupby, 'x', {})\n+        \n+        # The expected result should be empty as there's no valid data to fit\n+        expected_result = pd.DataFrame(columns=['x', 'y'])\n+        assert_frame_equal(res, expected_result)\n+\n     @pytest.fixture\n     def df(self, rng):\n \n",
  "mwaskom__seaborn-3190": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\nindex 72a27ec..6b98a82 100644\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -86,6 +86,18 @@ class TestContinuous:\n     def test_interval_with_range_norm_and_transform(self, x):\n \n         x = pd.Series([1, 10, 100])\n+\n+    def test_color_mapping_with_bools(self):\n+        x = pd.Series([True, False, True])\n+        cmap = color_palette(\"viridis\", as_cmap=True)\n+        s = Continuous(\"viridis\")._setup(x, Color())\n+        assert_array_equal(s(x), cmap([1.0, 0.0, 1.0])[:, :3])\n+\n+    def test_color_mapping_with_mixed_bools(self):\n+        x = pd.Series([True, False, False, True, False])\n+        cmap = color_palette(\"viridis\", as_cmap=True)\n+        s = Continuous(\"viridis\")._setup(x, Color())\n+        assert_array_equal(s(x), cmap([1.0, 0.0, 0.0, 1.0, 0.0])[:, :3])\n         # TODO param order?\n         s = Continuous((2, 3), (10, 100), \"log\")._setup(x, IntervalProperty())\n         assert_array_equal(s(x), [1, 2, 3])\n",
  "mwaskom__seaborn-3407": "",
  "pallets__flask-4992": "",
  "psf__requests-1963": "diff --git a/requests/sessions.py b/requests/sessions.py\nindex 7fdc4a9..5e44c5a 100644\n--- a/requests/sessions.py\n+++ b/requests/sessions.py\n@@ -83,7 +83,12 @@ def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):\n class SessionRedirectMixin(object):\n     def resolve_redirects(self, resp, req, stream=False, timeout=None,\n                           verify=True, cert=None, proxies=None):\n-        \"\"\"Receives a Response. Returns a generator of Responses.\"\"\"\n+        \"\"\"Receives a Response. Returns a generator of Responses.\n+\n+        Ensures that the HTTP method on redirected requests is correctly handled,\n+        so that POST requests are not incorrectly re-issued after a redirect that\n+        changes the method.\n+        \"\"\"\n \n         i = 0\n \n",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..440b8c1 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1655,7 +1655,41 @@ def test_urllib3_retries():\n     with pytest.raises(RetryError):\n         s.get(httpbin('status/500'))\n \n-def test_vendor_aliases():\n+from requests.exceptions import DecodeError, Timeout, RetryError\n+from requests.adapters import HTTPAdapter\n+from requests.packages.urllib3.exceptions import DecodeError as Urllib3DecodeError\n+from requests.packages.urllib3.exceptions import TimeoutError as Urllib3TimeoutError\n+import pytest\n+import requests\n+import socket\n+\n+def test_handle_decode_error():\n+    class MockHTTPConnection:\n+        def __init__(self, *args, **kwargs):\n+            raise Urllib3DecodeError(\"Decoding error\")\n+\n+    session = requests.Session()\n+    adapter = HTTPAdapter()\n+    adapter.get_connection = lambda *_: MockHTTPConnection()  # Mocking connection\n+    session.mount('http://', adapter)\n+\n+    with pytest.raises(DecodeError) as excinfo:\n+        session.get('http://example.com')\n+    assert \"Decoding\" in str(excinfo.value)\n+\n+def test_handle_timeout_error():\n+    class MockHTTPConnection:\n+        def __init__(self, *args, **kwargs):\n+            raise Urllib3TimeoutError(\"Connection timed out\")\n+\n+    session = requests.Session()\n+    adapter = HTTPAdapter()\n+    adapter.get_connection = lambda *_: MockHTTPConnection()  # Mocking connection\n+    session.mount('http://', adapter)\n+\n+    with pytest.raises(Timeout) as excinfo:\n+        session.get('http://example.com', timeout=0.01)\n+    assert \"timed out\" in str(excinfo.value)\n     from requests.packages import urllib3\n     from requests.packages import chardet\n \n@@ -1663,4 +1697,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "",
  "psf__requests-863": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 0ee4333..de62b64 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -743,8 +743,49 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n             assert 'foo' in response.text\n             assert 'bar' in response.text\n+    def test_executes_list_of_hooks_in_order(self):\n+        \"\"\"Verify hooks execute in proper order and affect the request\"\"\"\n+        \n+        events = []\n \n-    def test_session_persistent_cookies(self):\n+        def hook1(args):\n+            events.append('hook1')\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers']['Called-Hook-1'] = 'yes'\n+\n+        def hook2(args):\n+            events.append('hook2')\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers']['Called-Hook-2'] = 'yes'\n+\n+        hooks = [hook1, hook2]\n+        r = requests.models.Request(hooks={'args': hooks})\n+        \n+        assert 'Called-Hook-1' in r.headers\n+        assert 'Called-Hook-2' in r.headers\n+        assert r.headers['Called-Hook-1'] == 'yes'\n+        assert r.headers['Called-Hook-2'] == 'yes'\n+        assert events == ['hook1', 'hook2']\n+\n+    def test_no_hooks(self):\n+        \"\"\"Test behavior when no hooks are provided.\"\"\"\n+        r = requests.models.Request()\n+        assert r.hooks == {'args': []}  # Assuming 'args' is a key populated by default\n+\n+    def test_single_hook(self):\n+        \"\"\"Test behavior with a single hook.\"\"\"\n+        def single_hook(args):\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers']['Single-Hook'] = 'activated'\n+\n+        hooks = [single_hook]\n+        r = requests.models.Request(hooks={'args': hooks})\n+        \n+        assert 'Single-Hook' in r.headers\n+        assert r.headers['Single-Hook'] == 'activated'\n \n         s = requests.session()\n \n",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..6c4a2a9 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -388,7 +388,7 @@ repr_da = xr.DataArray(\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over %r \" % dim\n+    expected += \", grouped over %r\" % dim\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj[dim])))\n     if dim == \"x\":\n         expected += \"1, 2, 3, 4, 5.\"\n@@ -405,7 +405,7 @@ def test_groupby_repr(obj, dim):\n def test_groupby_repr_datetime(obj):\n     actual = repr(obj.groupby(\"t.month\"))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over 'month' \"\n+    expected += \", grouped over 'month'\"\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj.t.dt.month)))\n     expected += \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.\"\n     assert actual == expected\n",
  "pylint-dev__pylint-5859": "",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..ccf43aa 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -79,7 +79,14 @@ def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n     assert \"E0015: Unrecognized option found: Q\" in output.out\n \n \n-def test_unknown_confidence(capsys: CaptureFixture) -> None:\n+def test_unrecognized_option_traceback(capsys: CaptureFixture) -> None:\n+    \"\"\"Ensure no traceback is printed for unrecognized option.\"\"\"\n+    with pytest.raises(SystemExit):  # Expect SystemExit due to unrecognized option\n+        Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"E0015: Unrecognized option found: Q\" in output.out\n+    assert \"usage: pylint\" in output.err  # Check for usage message\n+    assert \"Traceback\" not in output.err  # Ensure no traceback is printed\n     \"\"\"Check that we correctly error an unknown confidence value.\"\"\"\n     with pytest.raises(SystemExit):\n         Run([str(EMPTY_MODULE), \"--confidence=UNKNOWN_CONFIG\"], exit=False)\n",
  "pylint-dev__pylint-7080": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex fa7078d..9979674 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1330,6 +1330,28 @@ class TestRunTC:\n                     code=0,\n                 )\n \n+    def test_ignore_paths_with_recursive_flag(self):\n+        \"\"\"Ensures that `--ignore-paths` works with `--recursive=y`.\"\"\"\n+        with _test_sys_path():\n+            # Temporarily change the system path for the test\n+            sys.path = [\n+                path\n+                for path in sys.path\n+                if not os.path.basename(path) == \"regrtest_data\"\n+            ]\n+            with _test_cwd():\n+                # Change to the directory where we'll apply pylint\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n+                # Run pylint with expected ignore-paths behavior\n+                self._runtest(\n+                    [\n+                        \".\", \n+                        \"--recursive=y\", \n+                        \"--ignore-paths=^ignored_subdirectory/.*\"\n+                    ],\n+                    code=0,  # Expect to pass without considering ignored paths\n+                )\n+\n     def test_regression_recursive_current_dir(self):\n         with _test_sys_path():\n             # pytest is including directory HERE/regrtest_data to sys.path which causes\n",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..94eff0d 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -935,10 +935,40 @@ print(submodule1)\n     assert not linter.stats.by_msg\n \n \n+def test_lint_identically_named_nested_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test for a module with the same name as its parent directory.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        # Case where module and directory have the same name\n+        create_files([\"module/module.py\", \"module/other.py\"])\n+        linter.check([\"module\"])\n+        assert not linter.stats.by_msg.get(\"parse-error\")\n+\n+        # Adding __init__.py should not change the outcome; it should pass either way\n+        create_files([\"module/__init__.py\"])\n+        linter.check([\"module\"])\n+        assert not linter.stats.by_msg.get(\"parse-error\")\n+\n+\n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n     linter = initialized_linter\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n+\n+\n+def test_lint_identically_named_nested_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test for a module with the same name as its parent directory.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        # Case where module and directory have the same name\n+        create_files([\"module/module.py\", \"module/other.py\"])\n+        linter.check([\"module\"])\n+        assert not linter.stats.by_msg.get(\"parse-error\")\n+\n+        # Adding __init__.py should not change the outcome; it should pass either way\n+        create_files([\"module/__init__.py\"])\n+        linter.check([\"module\"])\n+        assert not linter.stats.by_msg.get(\"parse-error\")\n",
  "pylint-dev__pylint-7993": "",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "diff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\nindex 9989033..bc7a660 100644\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -289,6 +289,19 @@ class TestImportPath:\n         return fn\n \n     def test_importmode_importlib(self, simple_module: Path, tmp_path: Path) -> None:\n+        \"\"\"Test that importlib mode does not import a module twice.\"\"\"\n+        module_name = \"_src.tests.mymod\"\n+        \n+        # Assert module is imported once and in sys.modules\n+        assert module_name in sys.modules\n+        \n+        # Try to import the module again and check it's still the same object\n+        imported_module = importlib.import_module(module_name)\n+        original_module = sys.modules[module_name]\n+        assert imported_module is original_module\n+        \n+        # Ensure no duplicate imports\n+        assert len([m for m in sys.modules if m == module_name]) == 1\n         \"\"\"`importlib` mode does not change sys.path.\"\"\"\n         module = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n         assert module.foo(2) == 42  # type: ignore[attr-defined]\n",
  "pytest-dev__pytest-5227": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 1ebe9d0..01f354c 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -15,7 +15,7 @@ from _pytest.compat import dummy_context_manager\n from _pytest.config import create_terminal_writer\n from _pytest.pathlib import Path\n \n-DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n+DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n \n \n",
  "pytest-dev__pytest-5495": "diff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex b05f85c..0bf83a4 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -301,6 +301,29 @@ def callequal(left, right, verbose=False):\n \n \n class TestAssert_reprcompare:\n+    def test_bytes_confusing_assertion_message_empty_vs_42(self):\n+        \"\"\"Test confusing assertion message for empty byte string compared to '42'.\"\"\"\n+        diff = callequal(b\"\", b\"42\")\n+        assert diff == [\n+            \"b'' == b'42'\",\n+            \"Right contains more items, first extra item: 52\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'42'\",\n+            \"?  ++\"\n+        ]\n+\n+    def test_bytes_confusing_assertion_message_empty_vs_1(self):\n+        \"\"\"Test confusing assertion message for empty byte string compared to '1'.\"\"\"\n+        diff = callequal(b\"\", b\"1\")\n+        assert diff == [\n+            \"b'' == b'1'\",\n+            \"Right contains more items, first extra item: 49\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'1'\",\n+            \"?  +\"\n+        ]\n     def test_different_types(self):\n         assert callequal([0, 1], \"foo\") is None\n \n",
  "pytest-dev__pytest-5692": "",
  "pytest-dev__pytest-7168": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 38e0b6b..ac85f38 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -144,6 +144,21 @@ def test_repr_on_newstyle():\n     assert saferepr(Function())\n \n \n+def test_broken_getattribute():\n+    \"\"\" saferepr() can create proper representations of classes with\n+    broken __getattribute__ and __repr__ methods (#7145)\"\"\"\n+\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError(\"Error in __getattribute__\")\n+\n+        def __repr__(self):\n+            raise RuntimeError(\"Error in __repr__\")\n+\n+    assert saferepr(SomeClass()).startswith(\n+        \"<[RuntimeError('Error in __repr__') raised in repr()] SomeClass object at 0x\"\n+    )\n+\n def test_unicode():\n     val = \"\u00a3\u20ac\"\n     reprval = \"'\u00a3\u20ac'\"\n@@ -153,4 +168,4 @@ def test_unicode():\n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n-    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n",
  "pytest-dev__pytest-7220": "diff --git a/testing/test_pytester.py b/testing/test_pytester.py\nindex 5ab5242..6821f64 100644\n--- a/testing/test_pytester.py\n+++ b/testing/test_pytester.py\n@@ -86,6 +86,30 @@ def test_testdir_runs_with_plugin(testdir) -> None:\n     \"\"\"\n     )\n     result = testdir.runpytest()\n+\n+def test_failure_path_reporting_after_dir_change(testdir) -> None:\n+    \"\"\"Ensure that the file path in test failure is reported correctly \n+    when the current working directory is changed in a fixture.\"\"\"\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import os\n+        import pytest\n+\n+        @pytest.fixture\n+        def private_dir():\n+            out_dir = 'new_dir'\n+            os.mkdir(out_dir)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+\n+        def test_trigger_failure(private_dir):\n+            assert False\n+        \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([str(p) + \":*: AssertionError\", \"*1 failed in *\"])\n     result.assert_outcomes(passed=1)\n \n \n",
  "pytest-dev__pytest-7373": "diff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 309636c..d5d8d19 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -41,6 +41,35 @@ class TestMark:\n         with pytest.raises(AttributeError):\n             mark._some_name\n \n+def test_reevaluate_dynamic_expr(testdir):\n+    \"\"\"Verify dynamic evaluation of mark expressions without caching issues.\"\"\"\n+    # Prepare test files\n+    py_file1 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr1=\"\"\"\n+        import pytest\n+        skip = True\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_skip():\n+            assert False  # Should not run, skip.\n+        \"\"\"\n+    )\n+    py_file2 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr2=\"\"\"\n+        import pytest\n+        skip = False\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_not_skip():\n+            assert True  # Should run, not skip.\n+        \"\"\"\n+    )\n+\n+    # Run both test files\n+    file_name1 = py_file1.strpath\n+    file_name2 = py_file2.strpath\n+    reprec = testdir.inline_run(file_name1, file_name2)\n+    reprec.assertoutcome(passed=1, skipped=1)\n \n def test_marked_class_run_twice(testdir):\n     \"\"\"Test fails file is run twice that contains marked class.\n",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..b9dc16b 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -154,6 +154,42 @@ class TestEvaluation:\n \n \n class TestXFail:\n+    \n+    @pytest.mark.parametrize(\n+        \"test_input, expected\",\n+        [\n+            ([\"-rs\"], [\"SKIPPED [1] test_sample.py:2: unconditional skip\", \"*1 skipped*\"]),\n+            ([\"-rs\", \"--runxfail\"], [\"SKIPPED [1] test_sample.py:2: unconditional skip\", \"*1 skipped*\"]),\n+        ],\n+    )\n+    def test_xfail_run_with_skip_mark(self, testdir, test_input, expected):\n+        testdir.makepyfile(\n+            test_sample=\"\"\"\n+            import pytest\n+            @pytest.mark.skip\n+            def test_skip_location() -> None:\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(*test_input)\n+        result.stdout.fnmatch_lines(expected)\n+\n+    def test_skip_location_is_reported_correctly(self, testdir):\n+        testdir.makepyfile(\n+            test_sample=\"\"\"\n+            import pytest\n+            @pytest.mark.skip(reason=\"skip reason\")\n+            def test_skip_func():\n+                assert 0\n+            \"\"\"\n+        )\n+        # running without --runxfail\n+        result = testdir.runpytest(\"-rs\")\n+        result.stdout.fnmatch_lines([\"SKIPPED [1] test_sample.py:2: skip reason\", \"*1 skipped*\"])\n+        \n+        # running with --runxfail\n+        result = testdir.runpytest(\"-rs\", \"--runxfail\")\n+        result.stdout.fnmatch_lines([\"SKIPPED [1] test_sample.py:2: skip reason\", \"*1 skipped*\"])\n     @pytest.mark.parametrize(\"strict\", [True, False])\n     def test_xfail_simple(self, testdir, strict):\n         item = testdir.getitem(\n",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..ac596e9 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,3 +1,4 @@\n+\n import sys\n \n import pytest\n@@ -203,7 +204,30 @@ class TestXFail:\n         callreport = reports[1]\n         assert callreport.wasxfail\n \n-    def test_xfail_xpassed_strict(self, testdir):\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # Issue #7486.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir: Testdir) -> None:\n+        # Issue #7486.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\", strict=True))\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n         item = testdir.getitem(\n             \"\"\"\n             import pytest\n",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..9246486 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,3 +1,4 @@\n+\n import os\n import stat\n import sys\n@@ -442,6 +443,32 @@ def test_basetemp_with_read_only_files(pytester: Pytester) -> None:\n     )\n     result = pytester.runpytest(\"--basetemp=tmp\")\n     assert result.ret == 0\n+\n+def test_tmpdir_factory_handles_invalid_dir_characters(tmpdir_factory: TempdirFactory, monkeypatch: MonkeyPatch) -> None:\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"invalid/char:*?name\")\n+    monkeypatch.setattr(tmpdir_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmpdir_factory, \"_given_basetemp\", None)\n+    p = tmpdir_factory.mktemp(\"foobar\")\n+    assert \"pytest-of-unknown\" in str(p)\n+    \n+def test_tmpdir_without_invalid_characters(tmpdir_factory: TempdirFactory) -> None:\n+    # This test checks that normal usernames don't alter the behavior.\n+    p = tmpdir_factory.mktemp(\"foobar\")\n+    assert p.exists()\n+    assert \"pytest-of-\" in str(p)\n     # running a second time and ensure we don't crash\n     result = pytester.runpytest(\"--basetemp=tmp\")\n-    assert result.ret == 0\n+    assert result.ret == 0\n+\n+def test_tmpdir_factory_handles_invalid_dir_characters(tmpdir_factory: TempdirFactory, monkeypatch: MonkeyPatch) -> None:\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"invalid/char:*?name\")\n+    monkeypatch.setattr(tmpdir_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmpdir_factory, \"_given_basetemp\", None)\n+    p = tmpdir_factory.mktemp(\"foobar\")\n+    assert \"pytest-of-unknown\" in str(p)\n+    \n+def test_tmpdir_without_invalid_characters(tmpdir_factory: TempdirFactory) -> None:\n+    # This test checks that normal usernames don't alter the behavior.\n+    p = tmpdir_factory.mktemp(\"foobar\")\n+    assert p.exists()\n+    assert \"pytest-of-\" in str(p)\n",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..6f71f07 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -573,8 +573,30 @@ def test_class_weights_cv():\n \n     assert_array_equal(reg.predict([[-.2, 2]]), np.array([-1]))\n \n+from sklearn.linear_model import RidgeClassifierCV\n+import numpy as np\n+import pytest\n+\n+def test_ridge_classifier_cv_store_cv_values():\n+    # Test RidgeClassifierCV's store_cv_values attribute.\n+    rng = np.random.RandomState(0)\n+\n+    # Test with y having shape (n_samples,)\n+    X = np.array([[-1.0, -1.0], [-1.0, 0], [-.8, -1.0], [1.0, 1.0], [1.0, 0.0]])\n+    y = np.array([1, 1, 1, -1, -1])\n+    n_samples, n_features = X.shape\n+    alphas = [0.1, 1.0, 10.0]\n+    n_alphas = len(alphas)\n+\n+    clf = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+    clf.fit(X, y)\n+    assert clf.cv_values_.shape == (n_samples, n_alphas)\n \n-def test_ridgecv_store_cv_values():\n+    # Test with y having shape (n_samples, n_targets)\n+    y_multi = np.array([[1, 1], [1, -1], [1, 1], [-1, -1], [-1, 1]])\n+    n_targets = y_multi.shape[1]\n+    clf.fit(X, y_multi)\n+    assert clf.cv_values_.shape == (n_samples, n_targets, n_alphas)\n     # Test _RidgeCV's store_cv_values attribute.\n     rng = rng = np.random.RandomState(42)\n \n",
  "scikit-learn__scikit-learn-11281": "diff --git a/sklearn/mixture/tests/test_bayesian_mixture.py b/sklearn/mixture/tests/test_bayesian_mixture.py\nindex a9d82b7..b34c380 100644\n--- a/sklearn/mixture/tests/test_bayesian_mixture.py\n+++ b/sklearn/mixture/tests/test_bayesian_mixture.py\n@@ -5,7 +5,7 @@\n import numpy as np\n from scipy.special import gammaln\n \n-from sklearn.utils.testing import assert_raise_message\n+from sklearn.utils.testing import assert_raise_message, assert_greater\n from sklearn.utils.testing import assert_almost_equal\n \n from sklearn.mixture.bayesian_mixture import _log_dirichlet_norm\n",
  "scikit-learn__scikit-learn-12471": "diff --git a/sklearn/preprocessing/tests/test_encoders.py b/sklearn/preprocessing/tests/test_encoders.py\nindex 3f9b211..68d3fa8 100644\n--- a/sklearn/preprocessing/tests/test_encoders.py\n+++ b/sklearn/preprocessing/tests/test_encoders.py\n@@ -260,6 +260,11 @@ def test_one_hot_encoder_not_fitted():\n         enc.transform(X)\n \n \n+from sklearn.preprocessing import OneHotEncoder\n+import numpy as np\n+from numpy.testing import assert_array_equal\n+import pytest\n+\n def test_one_hot_encoder_no_categorical_features():\n     X = np.array([[3, 2, 1], [0, 1, 1]], dtype='float64')\n \n@@ -273,6 +278,35 @@ def test_one_hot_encoder_no_categorical_features():\n     assert enc.categories_ == []\n \n \n+def test_one_hot_encoder_handle_unknown_strings():\n+    X = np.array(['11111111', '22', '333', '4444']).reshape((-1, 1))\n+    X2 = np.array(['55555', '22']).reshape((-1, 1))\n+    # Non Regression test for the issue #12470\n+    # Test the ignore option, when categories are numpy string dtype\n+    # particularly when the known category strings are larger\n+    # than the unknown category strings\n+    oh = OneHotEncoder(handle_unknown='ignore')\n+    oh.fit(X)\n+    X2_passed = X2.copy()\n+    assert_array_equal(\n+        oh.transform(X2_passed).toarray(),\n+        np.array([[0.,  0.,  0.,  0.], [0.,  1.,  0.,  0.]]))\n+    # ensure transformed data was not modified in place\n+    assert_array_equal(X2, X2_passed)\n+\n+def test_one_hot_encoder_handle_unknown_short_strings():\n+    X = np.array(['aaa', 'bb', 'c', 'dddddddd']).reshape((-1, 1))\n+    X2 = np.array(['eee', 'c']).reshape((-1, 1))\n+    # Test scenario with string categories of various lengths\n+    oh = OneHotEncoder(handle_unknown='ignore')\n+    oh.fit(X)\n+    X2_passed = X2.copy()\n+    assert_array_equal(\n+        oh.transform(X2_passed).toarray(),\n+        np.array([[0., 0., 0., 0.], [0., 0., 1., 0.]]))\n+    # ensure transformed data was not modified in place\n+    assert_array_equal(X2, X2_passed)\n+\n @pytest.mark.parametrize(\"output_dtype\", [np.int32, np.float32, np.float64])\n @pytest.mark.parametrize(\"input_dtype\", [np.int32, np.float32, np.float64])\n def test_one_hot_encoder_dtype(input_dtype, output_dtype):\n",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex f8e4d54..c5bff48 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -598,7 +598,17 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n \n-def test_gaussian_mixture_fit():\n+import numpy as np\n+from sklearn.mixture import GaussianMixture\n+from numpy.testing import assert_array_equal\n+\n+def test_gaussian_mixture_fit_predict_n_init():\n+    # Check that fit_predict is equivalent to fit.predict, when n_init > 1\n+    X = np.random.RandomState(0).randn(1000, 5)\n+    gm = GaussianMixture(n_components=5, n_init=5, random_state=0)\n+    y_pred1 = gm.fit_predict(X)\n+    y_pred2 = gm.predict(X)\n+    assert_array_equal(y_pred1, y_pred2)\n     # recover the ground truth\n     rng = np.random.RandomState(0)\n     rand_data = RandomData(rng)\n",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..3de4fc2 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,3 +1,4 @@\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n@@ -71,7 +72,20 @@ def test_kernel_pca_consistent_transform():\n     assert_array_almost_equal(transformed1, transformed2)\n \n \n-def test_kernel_pca_sparse():\n+def test_kernel_pca_sign_invariance():\n+    rng = np.random.RandomState(0)\n+    X = rng.rand(10, 10)\n+\n+    # Apply KernelPCA with RBF kernel and fixed eigen_solver\n+    kpca_arpack = KernelPCA(n_components=7, kernel='rbf', eigen_solver='arpack', random_state=rng)\n+    transformed_arpack = kpca_arpack.fit_transform(X)\n+\n+    # Apply KernelPCA with RBF kernel and dense eigen_solver\n+    kpca_dense = KernelPCA(n_components=7, kernel='rbf', eigen_solver='dense', random_state=rng)\n+    transformed_dense = kpca_dense.fit_transform(X)\n+\n+    # Ensure the magnitudes are the same (allowing sign differences)\n+    assert_allclose(np.abs(transformed_arpack), np.abs(transformed_dense))\n     rng = np.random.RandomState(0)\n     X_fit = sp.csr_matrix(rng.random_sample((5, 4)))\n     X_pred = sp.csr_matrix(rng.random_sample((2, 4)))\n",
  "scikit-learn__scikit-learn-13439": "diff --git a/sklearn/tests/test_pipeline.py b/sklearn/tests/test_pipeline.py\nindex 318940e..1d5eea5 100644\n--- a/sklearn/tests/test_pipeline.py\n+++ b/sklearn/tests/test_pipeline.py\n@@ -1057,8 +1057,26 @@ def test_pipeline_memory():\n     finally:\n         shutil.rmtree(cachedir)\n \n-\n-def test_make_pipeline_memory():\n+def test_pipeline_len():\n+    # Test if the length of the pipeline is equal to the number of steps\n+    from sklearn.pipeline import Pipeline\n+    from sklearn.feature_selection import SelectKBest\n+    from sklearn.feature_selection import f_regression\n+    from sklearn.svm import SVC\n+\n+    anova_filter = SelectKBest(f_regression, k=5)\n+    clf = SVC(kernel='linear')\n+    pipe = Pipeline([('anova', anova_filter), ('svc', clf)])\n+\n+    assert len(pipe) == 2, f\"Expected pipeline length of 2, but got {len(pipe)}\"\n+\n+    # Test a pipeline with a single step\n+    single_step_pipeline = Pipeline([('svc', clf)])\n+    assert len(single_step_pipeline) == 1, f\"Expected pipeline length of 1, but got {len(single_step_pipeline)}\"\n+\n+    # Test an empty pipeline\n+    empty_pipeline = Pipeline([])\n+    assert len(empty_pipeline) == 0, f\"Expected pipeline length of 0, but got {len(empty_pipeline)}\"\n     cachedir = mkdtemp()\n     if LooseVersion(joblib_version) < LooseVersion('0.12'):\n         # Deal with change of API in joblib\n@@ -1070,4 +1088,4 @@ def test_make_pipeline_memory():\n     pipeline = make_pipeline(DummyTransf(), SVC())\n     assert pipeline.memory is None\n \n-    shutil.rmtree(cachedir)\n+    shutil.rmtree(cachedir)\n",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..f4289c2 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -9,6 +10,8 @@ Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n import pytest\n \n import numpy as np\n+from sklearn.ensemble import IsolationForest\n+from sklearn.utils import check_random_state\n \n from sklearn.utils.testing import assert_array_equal\n from sklearn.utils.testing import assert_array_almost_equal\n",
  "scikit-learn__scikit-learn-13497": "diff --git a/sklearn/feature_selection/tests/test_mutual_info.py b/sklearn/feature_selection/tests/test_mutual_info.py\nindex f5a2908..0ebc39a 100644\n--- a/sklearn/feature_selection/tests/test_mutual_info.py\n+++ b/sklearn/feature_selection/tests/test_mutual_info.py\n@@ -197,4 +197,29 @@ def test_mutual_info_options():\n         assert_array_equal(mi_1, mi_2)\n         assert_array_equal(mi_3, mi_4)\n \n-    assert not np.allclose(mi_1, mi_3)\n+    assert not np.allclose(mi_1, mi_3)\n+\n+def test_mutual_info_discrete_features_array():\n+    X = np.array([[0, 0, 0],\n+                  [1, 1, 0],\n+                  [2, 0, 1],\n+                  [2, 0, 1],\n+                  [2, 0, 1]], dtype=float)\n+    y = np.array([0, 1, 2, 2, 1], dtype=float)\n+\n+    for mutual_info in (mutual_info_regression, mutual_info_classif):\n+        # Test with discrete_features as a boolean mask\n+        mi_bool_mask = mutual_info(X, y, discrete_features=[True, False, True], random_state=0)\n+        \n+        # Test with discrete_features as an array of indices\n+        mi_indices = mutual_info(X, y, discrete_features=[0, 2], random_state=0)\n+\n+        # Both should give the same result\n+        assert_array_equal(mi_bool_mask, mi_indices)\n+\n+        # Edge cases\n+        # Mismatched boolean mask length\n+        assert_raises(IndexError, mutual_info, X, y, discrete_features=[True, False])\n+        \n+        # Mismatched indices (index out of range)\n+        assert_raises(IndexError, mutual_info, X, y, discrete_features=[0, 3])\n",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..344182c 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,3 +1,4 @@\n+\n import re\n from pprint import PrettyPrinter\n \n@@ -5,6 +6,8 @@ import numpy as np\n \n from sklearn.utils._pprint import _EstimatorPrettyPrinter\n from sklearn.pipeline import make_pipeline\n+from sklearn.linear_model import LogisticRegressionCV\n+import sklearn\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.feature_selection import SelectKBest, chi2\n from sklearn import set_config\n@@ -215,7 +218,18 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n     set_config(print_changed_only=False)\n \n \n-def test_pipeline():\n+def test_logistic_regression_cv_array_param():\n+    # Ensure that array parameters don't throw an error with print_changed_only=True\n+    sklearn.set_config(print_changed_only=True)\n+    estimator = LogisticRegressionCV(Cs=np.array([0.1, 1]))\n+    try:\n+        repr_output = repr(estimator)\n+        assert isinstance(repr_output, str), \"The repr should be a string.\"\n+    except ValueError:\n+        assert False, \"Array parameter in LogisticRegressionCV should not raise a ValueError.\"\n+\n+    # Reset the config for other tests\n+    sklearn.set_config(print_changed_only=False)\n     # Render a pipeline object\n     pipeline = make_pipeline(StandardScaler(), LogisticRegression(C=999))\n     expected = \"\"\"\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..a16fbd8 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n@@ -9,6 +10,8 @@ from sklearn.utils.testing import assert_equal\n from sklearn.utils.testing import assert_raise_message\n from sklearn.exceptions import NotFittedError\n from sklearn.linear_model import LogisticRegression\n+from sklearn.linear_model import LinearRegression\n+from sklearn.ensemble import RandomForestRegressor\n from sklearn.naive_bayes import GaussianNB\n from sklearn.ensemble import RandomForestClassifier\n from sklearn.ensemble import VotingClassifier, VotingRegressor\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..0bbd34b 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -680,6 +680,56 @@ def test_unicode_kernel():\n                                 random_seed=0)\n \n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for the issue\n+    X_train = sparse.csr_matrix(\n+        [\n+            [0, 1, 0, 0],\n+            [0, 0, 0, 1],\n+            [0, 0, 1, 0],\n+            [0, 0, 0, 1]\n+        ]\n+    )\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    assert not model.support_vectors_.data.size\n+    assert not model.dual_coef_.data.size\n+\n+def test_sparse_fit_with_no_support_vectors():\n+    # Test SVR with conditions resulting in no support vectors\n+    X_train = sparse.csr_matrix(\n+        [\n+            [0, 0, 0, 0],\n+            [0, 0, 0, 0],\n+            [0, 0, 0, 0],\n+            [0, 0, 0, 0]\n+        ]\n+    )\n+    y_train = np.array([0, 0, 0, 0])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    assert not model.support_vectors_.size\n+    assert not model.dual_coef_.size\n+\n+def test_sparse_fit_different_parameters():\n+    # Test with different hyperparameters to ensure adaptability\n+    X_train = sparse.csr_matrix(\n+        [\n+            [0, 1, 0, 0],\n+            [0, 0, 0, 1],\n+            [0, 0, 1, 0],\n+            [0, 0, 0, 1]\n+        ]\n+    )\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(C=1.0, epsilon=0.2, kernel='linear', max_iter=10000)\n+    model.fit(X_train, y_train)\n+    # The fitting should not result in errors, assert on attributes directly\n+    assert not model.support_vectors_.data.size\n+    assert not model.dual_coef_.data.size\n+\n+\n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n     sparse_gram = sparse.csr_matrix([[1, 0], [0, 1]])\n",
  "scikit-learn__scikit-learn-14983": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex dd52c66..529526b 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -972,6 +972,24 @@ def test_leave_one_p_group_out_error_on_fewer_number_of_groups():\n                          LeavePGroupsOut(n_groups=3).split(X, y, groups))\n \n \n+from sklearn.model_selection import RepeatedKFold, RepeatedStratifiedKFold\n+import pytest\n+\n+@pytest.mark.parametrize(\n+    \"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold]\n+)\n+def test_repeated_cv_repr_with_different_states(RepeatedCV):\n+    n_splits, n_repeats = 2, 6\n+    repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats, random_state=42)\n+    repeated_cv_repr = ('{}(n_repeats=6, n_splits=2, random_state=42)'\n+                        .format(repeated_cv.__class__.__name__))\n+    assert repeated_cv_repr == repr(repeated_cv)\n+    \n+    repeated_cv_none = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats, random_state=None)\n+    repeated_cv_none_repr = ('{}(n_repeats=6, n_splits=2, random_state=None)'\n+                             .format(repeated_cv_none.__class__.__name__))\n+    assert repeated_cv_none_repr == repr(repeated_cv_none)\n+\n @ignore_warnings\n def test_repeated_cv_value_errors():\n     # n_repeats is not integer or <= 0\n",
  "scikit-learn__scikit-learn-15512": "diff --git a/sklearn/cluster/tests/test_affinity_propagation.py b/sklearn/cluster/tests/test_affinity_propagation.py\nindex 5de7c5e..379ac97 100644\n--- a/sklearn/cluster/tests/test_affinity_propagation.py\n+++ b/sklearn/cluster/tests/test_affinity_propagation.py\n@@ -152,6 +152,30 @@ def test_affinity_propagation_predict_non_convergence():\n     assert_array_equal(np.array([-1, -1, -1]), y)\n \n \n+import numpy as np\n+from sklearn.cluster import AffinityPropagation\n+from sklearn.utils._testing import assert_array_equal\n+import pytest\n+\n+def test_affinity_propagation_convergence_behavior():\n+    # Test to verify behavior of affinity propagation when it does not converge.\n+    # This should return an empty list for cluster_centers_indices_ and an array of -1 for labels_.\n+    X = np.array([[1, 0, 0, 0, 0, 0],\n+                  [0, 1, 1, 1, 0, 0],\n+                  [0, 0, 1, 0, 0, 1]])\n+    \n+    # Force non-convergence by allowing only two iterations\n+    af = AffinityPropagation(affinity='euclidean', max_iter=2).fit(X)\n+    \n+    # Assert that cluster_centers_indices_ is empty\n+    assert af.cluster_centers_indices_ == []\n+\n+    # Assert that labels_ is an array of -1\n+    assert_array_equal(af.labels_, np.array([-1, -1, -1]))\n+\n+    # Test convergence property\n+    assert af.n_iter_ == 2  # Should run for the max_iter iterations\n+\n def test_equal_similarities_and_preferences():\n     # Unequal distances\n     X = np.array([[0, 0], [1, 1], [-2, -2]])\n",
  "scikit-learn__scikit-learn-15535": "diff --git a/sklearn/metrics/cluster/tests/test_common.py b/sklearn/metrics/cluster/tests/test_common.py\nindex 9991cff..bf069d4 100644\n--- a/sklearn/metrics/cluster/tests/test_common.py\n+++ b/sklearn/metrics/cluster/tests/test_common.py\n@@ -158,6 +158,9 @@ def test_format_invariance(metric_name):\n     y_pred = [0, 1, 2, 3, 4, 5, 6, 7]\n \n     def generate_formats(y):\n+        y = np.array(y)\n+        yield [str(x) + \"-a\" for x in y.tolist()], 'list of strs with suffix'\n+        yield np.array([str(x) + \"-a\" for x in y.tolist()], dtype=object), 'array of strs with suffix'\n         y = np.array(y)\n         yield y, 'array of ints'\n         yield y.tolist(), 'list of ints'\n",
  "scikit-learn__scikit-learn-25500": "diff --git a/sklearn/tests/test_isotonic.py b/sklearn/tests/test_isotonic.py\nindex 5021282..c9e2e9c 100644\n--- a/sklearn/tests/test_isotonic.py\n+++ b/sklearn/tests/test_isotonic.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n import numpy as np\n import pickle\n@@ -668,6 +669,29 @@ def test_isotonic_regression_sample_weight_not_overwritten():\n \n \n @pytest.mark.parametrize(\"shape\", [\"1d\", \"2d\"])\n+def test_calibrated_classifier_isotonic_regression_pandas_output():\n+    \"\"\"Test CalibratedClassifierCV with isotonic regression and pandas output.\"\"\"\n+\n+    # Check if pandas is available\n+    pd = pytest.importorskip(\"pandas\")\n+    \n+    # Create a simple dataset\n+    X = np.arange(90).reshape(30, 3)\n+    y = np.arange(30) % 2\n+\n+    # Setup the configuration to have pandas DataFrame output\n+    set_config(transform_output=\"pandas\")\n+    \n+    # CalibratedClassifierCV with isotonic regression\n+    model = CalibratedClassifierCV(SGDClassifier(), method='isotonic')\n+    model.fit(X, y)\n+\n+    # Ensure `predict` method works without errors\n+    predictions = model.predict(X)\n+\n+    # Assertions\n+    assert isinstance(predictions, np.ndarray), \"Predictions should be a numpy array.\"\n+\n def test_get_feature_names_out(shape):\n     \"\"\"Check `get_feature_names_out` for `IsotonicRegression`.\"\"\"\n     X = np.arange(10)\n",
  "scikit-learn__scikit-learn-25570": "",
  "sphinx-doc__sphinx-10325": "diff --git a/tests/test_ext_autodoc_automodule.py b/tests/test_ext_autodoc_automodule.py\nindex 787cd0c..6e7ad8d 100644\n--- a/tests/test_ext_autodoc_automodule.py\n+++ b/tests/test_ext_autodoc_automodule.py\n@@ -112,6 +112,62 @@ def test_automodule_special_members(app):\n         '',\n     ]\n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_automodule_inherited_members_multiple_classes(app):\n+    options = {'members': None,\n+               'undoc-members': None,\n+               'inherited-members': 'Base, MyList'}\n+    actual = do_autodoc(app, 'module', 'target.inheritance', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.inheritance',\n+        '',\n+        '',\n+        '.. py:class:: Base()',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedclassmeth()',\n+        '      :module: target.inheritance',\n+        '      :classmethod:',\n+        '',\n+        '      Inherited class method.',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedmeth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      Inherited function.',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedstaticmeth(cls)',\n+        '      :module: target.inheritance',\n+        '      :staticmethod:',\n+        '',\n+        '      Inherited static method.',\n+        '',\n+        '',\n+        '.. py:class:: Derived()',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: Derived.inheritedmeth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      Inherited function.',\n+        '',\n+        '',\n+        '.. py:class:: MyList(iterable=(), /)',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: MyList.meth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n \n @pytest.mark.sphinx('html', testroot='ext-autodoc',\n                     confoverrides={'autodoc_mock_imports': ['missing_module',\n@@ -125,4 +181,225 @@ def test_subclass_of_mocked_object(app):\n \n     options = {'members': None}\n     actual = do_autodoc(app, 'module', 'target.need_mocks', options)\n-    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n",
  "sphinx-doc__sphinx-7975": "",
  "sphinx-doc__sphinx-8435": "",
  "sphinx-doc__sphinx-8506": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 08bd595..fe8a6c2 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -78,6 +78,31 @@ def test_get_full_qualified_name():\n     domain = StandardDomain(env)\n \n     # normal references\n+from sphinx import restructuredtext\n+from sphinx.testing.util import assert_node\n+from sphinx.addnodes import desc, desc_signature, desc_name, desc_addname, desc_content, index\n+import sphinx.domains.std\n+\n+def test_cmd_option_with_optional_value(app):\n+    text = \".. option:: -j[=N]\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (index,\n+                          [desc, ([desc_signature, ([desc_name, '-j'],\n+                                                    [desc_addname, '[=N]'])],\n+                                  [desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('-j', '-j', 'cmdoption', 'index', 'cmdoption-j', 1) in objects\n+\n+def test_cmd_option_starting_with_bracket(app):\n+    text = \".. option:: [enable=]PATTERN\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (index,\n+                          [desc, ([desc_signature, ([desc_name, '[enable'],\n+                                                    [desc_addname, '=]PATTERN'])],\n+                                  [desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('[enable', '[enable', 'cmdoption', 'index', 'cmdoption-arg-enable', 1) in objects\n+\n     node = nodes.reference()\n     assert domain.get_full_qualified_name(node) is None\n \n",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..95979aa 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -21,6 +21,8 @@ from sphinx.ext.autodoc import ALL, ModuleLevelDocumenter, Options\n from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n from sphinx.testing.util import SphinxTestApp, Struct  # NOQA\n from sphinx.util.docutils import LoggingReporter\n+from .test_ext_autodoc import do_autodoc\n+import pytest\n \n try:\n     # Enable pyximport to test cython module\n@@ -30,6 +32,61 @@ except ImportError:\n     pyximport = None\n \n \n+def test_empty_all_function_exclusions(app):\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.empty_all', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.empty_all',\n+        '',\n+        'docsting of empty_all module.',\n+        '',\n+    ]\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_non_empty_all(app):\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.non_empty_all', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.non_empty_all',\n+        '',\n+        'docsting of non_empty_all module.',\n+        '',\n+        '.. py:function:: foo()',\n+        '   :module: target.non_empty_all',\n+        '',\n+        '   docstring',\n+        '',\n+    ]\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_no_all_defined(app):\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.no_all', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.no_all',\n+        '',\n+        'docsting of no_all module.',\n+        '',\n+        '.. py:function:: foo()',\n+        '   :module: target.no_all',\n+        '',\n+        '   docstring',\n+        '',\n+        '.. py:function:: bar()',\n+        '   :module: target.no_all',\n+        '',\n+        '   docstring',\n+        '',\n+        '.. py:function:: baz()',\n+        '   :module: target.no_all',\n+        '',\n+        '   docstring',\n+        '',\n+    ]\n+\n def do_autodoc(app, objtype, name, options=None):\n     if options is None:\n         options = {}\n",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..01b2169 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -15,6 +16,7 @@ from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tup\n \n import pytest\n \n+from struct import Struct\n from sphinx.util.typing import restify, stringify\n \n \n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..96482bc 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1455,6 +1455,29 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n         expected = \"\"\"\\\n :param param1:\n :type param1: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+    \n+    def test_other_parameters_with_class_reference(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+\n+\"\"\"\n+\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param2** (:class:`MyClass <name.space.MyClass>` instance)\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param param2:\n+:type param2: :class:`MyClass <name.space.MyClass>` instance\n \"\"\"\n         self.assertEqual(expected, actual)\n \n",
  "sphinx-doc__sphinx-8721": "",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..6239203 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -321,8 +321,27 @@ def test_mul():\n         h2 = _af_rmuln(*a[:i + 1])\n         assert h == h2\n \n+def test_non_disjoint_cycles():\n+    # Test case for non-disjoint cycles expecting the identity permutation due to repeated elements without impact\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n \n-def test_args():\n+    # Test case where cycles repeat an element, the final permutation should reflect correct transformations\n+    assert Permutation([[0, 1], [1, 2]]) == Permutation([1, 2, 0])\n+    assert Permutation([[1, 2], [0, 1]]) == Permutation([2, 0, 1])\n+\n+    # Test case with more complex non-disjoint cycles\n+    assert Permutation([[0, 1, 2], [1, 2, 3]]) == Permutation([2, 3, 0, 1])\n+    \n+    # Test identity permutation creation from repeated single element cycles\n+    assert Permutation([[0], [0]]) == Permutation([0])\n+\n+    # Edge case where one cycle is a subset of another\n+    assert Permutation([[0, 1, 2], [1, 2]]) == Permutation([1, 2, 0])\n+\n+    # Ensure proper handling of size parameter\n+    assert Permutation([[0, 1], [0, 1]], size=3) == Permutation([0, 1, 2])\n+\n+# Existing tests\n     p = Permutation([(0, 3, 1, 2), (4, 5)])\n     assert p._cyclic_form is None\n     assert Permutation(p) == p\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..0059896 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -1,4 +1,5 @@\n-from sympy import Abs, S, Symbol, I, Rational, PurePoly\n+\n+from sympy import Abs, S, Symbol, I, Rational, PurePoly, Matrix\n from sympy.matrices import Matrix, SparseMatrix, eye, zeros, ShapeError\n from sympy.utilities.pytest import raises\n \n@@ -26,7 +27,15 @@ def test_sparse_matrix():\n     assert type(a.row_join(b)) == type(a)\n     assert type(a.col_join(b)) == type(a)\n \n-    # test element assignment\n+    # Test hstack behavior for zero-dimension matrices\n+    def test_sparse_hstack_zero_dim():\n+        matrices = [SparseMatrix.zeros(0, n) for n in range(4)]\n+        assert SparseMatrix.hstack(*matrices).shape == (0, 6)\n+\n+    # Test vstack behavior for zero-dimension matrices\n+    def test_sparse_vstack_zero_dim():\n+        matrices = [SparseMatrix.zeros(n, 0) for n in range(4)]\n+        assert SparseMatrix.vstack(*matrices).shape == (6, 0)\n     a = SparseMatrix((\n         (1, 0),\n         (0, 1)\n",
  "sympy__sympy-13471": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\nindex 0a3b6ce..0aa0fad 100644\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -567,7 +567,24 @@ def test_Float_eval():\n     assert (a**2).is_Float\n \n \n-def test_Float_issue_2107():\n+def test_Float_from_tuple_issue():\n+    a = Float((0, '1L', 0, 1))\n+    b = Float((0, '1', 0, 1))\n+    assert a == b\n+\n+import pickle\n+import sys\n+import sympy\n+\n+def test_pickle_cross_version():\n+    # Test pickling in Python 2 style and unpickling in Python 3 style\n+    # The expression x + 1.0, where x is symbolic, should be correctly managed\n+    x = sympy.symbols(\"x\")\n+    expr = x + 1.0\n+    pickled = pickle.dumps(expr, protocol=2)  # Simulate Python 2 pickling\n+    # In Python 3, we need to load from bytes\n+    unpickled_expr = pickle.loads(pickled)\n+    assert expr == unpickled_expr\n     a = Float(0.1, 10)\n     b = Float(\"0.1\", 10)\n \n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..f3cbecf 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -260,7 +260,23 @@ def test_coth():\n     assert coth(7*pi*I/6) == -sqrt(3)*I\n     assert coth(-5*pi*I/6) == -sqrt(3)*I\n \n-    assert coth(pi*I/105) == -cot(pi/105)*I\n+from sympy import coth, log, tan, Symbol, pi, I\n+\n+def test_issue_coth_subs():\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+    # Testing for previously problematic integral values\n+    assert e.subs(x, 2) not in [None, float('nan'), float('inf')]\n+    assert e.subs(x, 3) not in [None, float('nan'), float('inf')]\n+    assert e.subs(x, 5) not in [None, float('nan'), float('inf')]\n+    assert e.subs(x, 6) not in [None, float('nan'), float('inf')]\n+    assert e.subs(x, 8) not in [None, float('nan'), float('inf')]\n+    assert e.subs(x, 9) not in [None, float('nan'), float('inf')]\n+    assert e.subs(x, 11) not in [None, float('nan'), float('inf')]\n+    assert e.subs(x, 12) not in [None, float('nan'), float('inf')]\n+    assert e.subs(x, 13) not in [None, float('nan'), float('inf')]\n+    assert e.subs(x, 15) not in [None, float('nan'), float('inf')]\n+    assert e.subs(x, 18) not in [None, float('nan'), float('inf')]\n     assert coth(-pi*I/105) == cot(pi/105)*I\n \n     assert coth(2 + 3*I) == coth(2 + 3*I)\n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..bf6890e 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -187,6 +187,33 @@ def test_col_join():\n                    [0, 0, 1],\n                    [7, 7, 7]])\n \n+def test_issue_13643_col_insert():\n+    from sympy import Matrix, eye, ones\n+    M = eye(6)\n+    V = 2 * ones(6, 2)\n+    expected = Matrix([[1, 0, 0, 2, 2, 0, 0, 0],\n+                       [0, 1, 0, 2, 2, 0, 0, 0],\n+                       [0, 0, 1, 2, 2, 0, 0, 0],\n+                       [0, 0, 0, 2, 2, 1, 0, 0],\n+                       [0, 0, 0, 2, 2, 0, 1, 0],\n+                       [0, 0, 0, 2, 2, 0, 0, 1]])\n+    assert M.col_insert(3, V) == expected\n+\n+    # More thorough tests\n+    N = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n+    col_vec = Matrix([10, 11, 12])\n+    expected_N = Matrix([[1, 2, 10, 3],\n+                         [4, 5, 11, 6],\n+                         [7, 8, 12, 9]])\n+    assert N.col_insert(2, col_vec) == expected_N\n+\n+    zero_matrix = Matrix(3, 3, [0] * 9)\n+    col_scalar = Matrix([1, 1, 1])\n+    expected_zero = Matrix([[1, 0, 0, 0],\n+                            [1, 0, 0, 0],\n+                            [1, 0, 0, 0]])\n+    assert zero_matrix.col_insert(0, col_scalar) == expected_zero\n+\n def test_row_insert():\n     r4 = Matrix([[4, 4, 4]])\n     for i in range(-4, 5):\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..30d7489 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -620,46 +620,46 @@ def test_latex_sequences():\n     s1 = SeqFormula(a**2, (0, oo))\n     s2 = SeqPer((1, 2))\n \n-    latex_str = r'\\left\\[0, 1, 4, 9, \\ldots\\right\\]'\n+    latex_str = r'\\left[0, 1, 4, 9, \\ldots\\right]'\n     assert latex(s1) == latex_str\n \n-    latex_str = r'\\left\\[1, 2, 1, 2, \\ldots\\right\\]'\n+    latex_str = r'\\left[1, 2, 1, 2, \\ldots\\right]'\n     assert latex(s2) == latex_str\n \n     s3 = SeqFormula(a**2, (0, 2))\n     s4 = SeqPer((1, 2), (0, 2))\n \n-    latex_str = r'\\left\\[0, 1, 4\\right\\]'\n+    latex_str = r'\\left[0, 1, 4\\right]'\n     assert latex(s3) == latex_str\n \n-    latex_str = r'\\left\\[1, 2, 1\\right\\]'\n+    latex_str = r'\\left[1, 2, 1\\right]'\n     assert latex(s4) == latex_str\n \n     s5 = SeqFormula(a**2, (-oo, 0))\n     s6 = SeqPer((1, 2), (-oo, 0))\n \n-    latex_str = r'\\left\\[\\ldots, 9, 4, 1, 0\\right\\]'\n+    latex_str = r'\\left[\\ldots, 9, 4, 1, 0\\right]'\n     assert latex(s5) == latex_str\n \n-    latex_str = r'\\left\\[\\ldots, 2, 1, 2, 1\\right\\]'\n+    latex_str = r'\\left[\\ldots, 2, 1, 2, 1\\right]'\n     assert latex(s6) == latex_str\n \n-    latex_str = r'\\left\\[1, 3, 5, 11, \\ldots\\right\\]'\n+    latex_str = r'\\left[1, 3, 5, 11, \\ldots\\right]'\n     assert latex(SeqAdd(s1, s2)) == latex_str\n \n-    latex_str = r'\\left\\[1, 3, 5\\right\\]'\n+    latex_str = r'\\left[1, 3, 5\\right]'\n     assert latex(SeqAdd(s3, s4)) == latex_str\n \n-    latex_str = r'\\left\\[\\ldots, 11, 5, 3, 1\\right\\]'\n+    latex_str = r'\\left[\\ldots, 11, 5, 3, 1\\right]'\n     assert latex(SeqAdd(s5, s6)) == latex_str\n \n-    latex_str = r'\\left\\[0, 2, 4, 18, \\ldots\\right\\]'\n+    latex_str = r'\\left[0, 2, 4, 18, \\ldots\\right]'\n     assert latex(SeqMul(s1, s2)) == latex_str\n \n-    latex_str = r'\\left\\[0, 2, 4\\right\\]'\n+    latex_str = r'\\left[0, 2, 4\\right]'\n     assert latex(SeqMul(s3, s4)) == latex_str\n \n-    latex_str = r'\\left\\[\\ldots, 18, 4, 2, 0\\right\\]'\n+    latex_str = r'\\left[\\ldots, 18, 4, 2, 0\\right]'\n     assert latex(SeqMul(s5, s6)) == latex_str\n \n \n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..f47ca8f 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +7,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n",
  "sympy__sympy-14774": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 48a5cf2..0e366c9 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Add, Abs, Chi, Ci, CosineTransform, Dict, Ei, Eq, FallingFactorial,\n     FiniteSet, Float, FourierTransform, Function, IndexedBase, Integral,\n@@ -307,6 +308,19 @@ def test_latex_functions():\n         r\"\\sin^{-1} {x^{2}}\"\n \n     assert latex(factorial(k)) == r\"k!\"\n+\n+    # Test for acsc with full inverse trig style\n+    assert latex(acsc(x), inv_trig_style=\"full\") == r\"\\operatorname{arccsc}{\\left (x \\right )}\"\n+    assert latex(acsc(x), inv_trig_style=\"abbreviated\") == r\"\\operatorname{acsc}{\\left (x \\right )}\"\n+    assert latex(acsc(x), inv_trig_style=\"power\") == r\"\\csc^{-1}{\\left (x \\right )}\"\n+\n+    # Test for asec with full inverse trig style\n+    assert latex(asec(x), inv_trig_style=\"full\") == r\"\\operatorname{arcsec}{\\left (x \\right )}\"\n+    assert latex(asec(x), inv_trig_style=\"abbreviated\") == r\"\\operatorname{asec}{\\left (x \\right )}\"\n+    assert latex(asec(x), inv_trig_style=\"power\") == r\"\\sec^{-1}{\\left (x \\right )}\"\n+\n+    # Test for known issue - original patch\n+    assert latex(acsc(x), inv_trig_style=\"full\") == r\"\\operatorname{arccsc}{\\left (x \\right )}\"\n     assert latex(factorial(-k)) == r\"\\left(- k\\right)!\"\n \n     assert latex(subfactorial(k)) == r\"!k\"\n",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..5efedcd 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6110,8 +6110,19 @@ u(\"\"\"\\\n \"\"\")\n     assert upretty((1/y)*e.j) == ucode_str\n \n-\n-def test_MatrixSymbol_printing():\n+def test_MatAdd_pretty_printing():\n+    # issue #14814\n+    n = 3\n+    x = MatrixSymbol('x', n, n)\n+    y = MatrixSymbol('y*', n, n)\n+    a = MatrixSymbol('a', n, n)\n+    assert pretty(x + y) == \"x + y*\"\n+\n+    # Additional test cases to ensure correct behavior and fix verification\n+    assert pretty(-x + y) == \"-x + y*\"\n+    assert pretty(-a*x + -2*y*y) == \"-a*x - 2*y**2\"\n+    assert pretty(a*x - 2*y) == \"a*x - 2*y*\"\n+    assert pretty(a*x + y*2) == \"a*x + 2*y*\"\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n     B = MatrixSymbol(\"B\", 3, 3)\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..15b6413 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -721,6 +721,32 @@ def test_dummification():\n     assert lam(3, 9) == 2\n     lam = lambdify(sin(t), 2 * sin(t)**2)\n     assert lam(F(t)) == 2 * F(t)**2\n+\n+def test_curly_matrix_symbol():\n+    # Original issue test\n+    curlyv = MatrixSymbol(\"{v}\", 2, 1) \n+    lam = lambdify(curlyv, curlyv)\n+    assert (lam([[1], [1]]) == [[1], [1]]).all()\n+    \n+    # Test with dummification\n+    lam_dummified = lambdify(curlyv, curlyv, dummify=True)\n+    assert (lam_dummified([[1], [1]]) == [[1], [1]]).all()\n+\n+    # Additional Test Cases\n+    # Lambdifying with curly braces and multiple elements\n+    curlyM = MatrixSymbol(\"{M}\", 2, 2)\n+    curlyMFunc = lambdify(curlyM, curlyM.T)\n+    assert (curlyMFunc([[1, 2], [3, 4]]) == [[1, 3], [2, 4]]).all()\n+\n+    # Verify lambdify with single character MatrixSymbol with curly braces\n+    singleCurly = MatrixSymbol(\"{A}\", 1, 1)\n+    singleCurlyFunc = lambdify(singleCurly, 2*singleCurly)\n+    assert singleCurlyFunc([[3]]) == [[6]]\n+\n+    # Verify error handling of an incorrect input to lambdified function\n+    raises(TypeError, lambda: lam(1))\n+    raises(TypeError, lambda: lam_dummified(1))\n+    raises(TypeError, lambda: curlyMFunc(1))\n     #Test that \\alpha was properly dummified\n     lam = lambdify((alpha, t), 2*alpha + t)\n     assert lam(2, 1) == 5\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..29885ee 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n@@ -20,6 +21,14 @@ def test_Rational():\n     assert mcode(Rational(18, 9)) == \"2\"\n     assert mcode(Rational(3, -7)) == \"-3/7\"\n     assert mcode(Rational(-3, -7)) == \"3/7\"\n+\n+def test_Max_Min():\n+    assert mcode(Max(x, 2)) == \"Max[x, 2]\"\n+    assert mcode(Max(2, x)) == \"Max[2, x]\"\n+    assert mcode(Max(x, y, z) * Min(y, z)) == \"Max[x, y, z]*Min[y, z]\"\n+    assert mcode(Max(3, 5, x)) == \"Max[3, 5, x]\"\n+    assert mcode(Min(3, x, 1)) == \"Min[3, x, 1]\"\n+    assert mcode(Min(Max(x, 4), 2)) == \"Min[Max[x, 4], 2]\"\n     assert mcode(x + Rational(3, 7)) == \"x + 3/7\"\n     assert mcode(Rational(3, 7)*x) == \"(3/7)*x\"\n \n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..92df3ad 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1717,6 +1717,34 @@ def test_issue_13651():\n     assert latex(expr) == r\"c - \\left(a + b\\right)\"\n \n \n+def test_extended_indexed_matrix_expression_latex():\n+    # Additional tests to ensure the fix works across different matrix expressions\n+    i, j, k, l = symbols(\"i j k l\")\n+    M = MatrixSymbol(\"M\", k, l)\n+    N = MatrixSymbol(\"N\", l, k)\n+    \n+    # Multiple matrix product\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{l - 1} M_{i, i_{1}} N_{i_{1}, j}'\n+\n+    # Different matrix dimensions and variables for summation index\n+    P = MatrixSymbol(\"P\", k, l)\n+    assert latex((M*P)[i, j]) == r'\\sum_{i_{1}=0}^{l - 1} M_{i, i_{1}} P_{i_{1}, j}'\n+\n+    # Testing with different subscripts\n+    Q = MatrixSymbol(\"Q\", l, l)\n+    assert latex((Q*Q)[i, j]) == r'\\sum_{i_{1}=0}^{l - 1} Q_{i, i_{1}} Q_{i_{1}, j}'\n+\n+def test_indexed_matrix_expression_latex():\n+    # Test for the issue where indexed matrix expressions produce LaTeX output that doesn't compile\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    \n+    # Check if the LaTeX representation is now correctly fixed\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n+\n+from sympy import symbols, MatrixSymbol, latex\n+\n def test_latex_UnevaluatedExpr():\n     x = symbols(\"x\")\n     he = UnevaluatedExpr(1/x)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..e9c8864 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, exp, Eq\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -21,7 +22,31 @@ def test_idiff():\n     assert idiff(x + t + y, [y, t], x) == -Derivative(t, x) - 1\n \n \n-def test_intersection():\n+def test_idiff_issue_cases():\n+    x = Symbol('x', real=True)\n+    y = Function('y')(x)\n+    f = Function('f')\n+\n+    # Original issue cases\n+    assert idiff(Eq(y*exp(y), x*exp(x)), y, x).simplify() == (x + 1)*exp(x - y)/(y + 1)\n+    assert idiff(f(x)*exp(f(x)) - x*exp(x), f(x), x) == (x + 1) * exp(x - f(x))/(f(x) + 1)\n+    assert idiff(y*exp(y) - x*exp(x), y, x) == (x + 1)*exp(x - y)/(y + 1)\n+\n+    # New test cases\n+    # Testing with an explicit equation with Eq\n+    eq = Eq(f(x)**2 + x**2, 1)\n+    assert idiff(eq, f(x), x).simplify() in [-x/f(x), x/f(x)]\n+    \n+    # Testing multiple dependent variables with an Eq\n+    assert idiff(Eq(f(x) - y, x**2), [f(x), y], x) == 2*x\n+\n+    # Another case with functional and explicit difference\n+    assert idiff(Eq(x**2 + y**3, f(x)), y, x).simplify() == Derivative(f(x), x)/(3*y**2) - 2*x/(3*y**2)\n+\n+    # Ensure that an unrelated existing test is not broken\n+    circ = x**2 + y**2 - 4\n+    ans = -3*x*(x**2 + y**2)/y**5\n+    assert ans == idiff(circ, Function('y')(x), x, 3).simplify()\n     assert intersection(Point(0, 0)) == []\n     raises(TypeError, lambda: intersection(Point(0, 0), 3))\n     assert intersection(\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_codegen.py b/sympy/utilities/tests/test_codegen.py\nindex 6bc2605..e7e5ece 100644\n--- a/sympy/utilities/tests/test_codegen.py\n+++ b/sympy/utilities/tests/test_codegen.py\n@@ -582,6 +582,43 @@ def test_ccode_cse():\n     )\n     assert source == expected\n \n+def test_ccode_unused_array_arg():\n+    from sympy.utilities.codegen import codegen\n+    from sympy.utilities.codegen import CCodeGen\n+    from sympy import MatrixSymbol\n+\n+    x = MatrixSymbol('x', 2, 1)\n+    # x does not appear in output\n+    name_expr = (\"test\", 1.0)\n+    generator = CCodeGen()\n+    result = codegen(name_expr, code_gen=generator, header=False, empty=False, argument_sequence=(x,))\n+    source = result[0][1]\n+    # note: x should appear as (double *)\n+    expected = (\n+        '#include \"test.h\"\\n'\n+        '#include <math.h>\\n'\n+        'double test(double *x) {\\n'\n+        '   double test_result;\\n'\n+        '   test_result = 1.0;\\n'\n+        '   return test_result;\\n'\n+        '}\\n'\n+    )\n+    assert source == expected\n+\n+def test_autowrap_cython_unused_array_arg():\n+    from sympy.utilities.autowrap import autowrap\n+    from sympy import MatrixSymbol\n+    import numpy as np\n+\n+    x = MatrixSymbol('x', 2, 1)\n+    # Expression does not use `x`\n+    expr = 1.0\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    \n+    result = f(np.array([[1.0, 2.0]]))\n+    expected = 1.0\n+    assert result == expected\n+\n def test_empty_f_code():\n     code_gen = FCodeGen()\n     source = get_string(code_gen.dump_f95, [])\n",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..e92ef6c 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -342,8 +342,25 @@ def test_intersection():\n     # issue 12178\n     assert Intersection() == S.UniversalSet\n \n-\n-def test_issue_9623():\n+from sympy import symbols, Intersection, FiniteSet, Eq, S\n+\n+def test_intersection_duplicates_removal():\n+    x = symbols('x')\n+    \n+    # Test case 1: Intersection with duplicates {1}, {1}, {x}\n+    intersection_result = Intersection({1}, {1}, {x})\n+    expected_result = Intersection({1}, {x})\n+    assert intersection_result == expected_result\n+\n+    # Test case 2: Intersection {1}, {x}\n+    piecewise_result = Intersection({1}, {x})\n+    expected_piecewise_result = S.Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    assert piecewise_result == expected_piecewise_result\n+\n+    # Test case 3: Checking with empty set and unordered inputs with duplicates\n+    assert Intersection({1}, {1}, S.EmptySet) == S.EmptySet\n+    assert Intersection({1, 1, 2}, {1, 2, 2}, {2, 3}) == {2}\n+    assert Intersection({1, 2, 2}, {2, 2, 3}, {2, 3, 3, 4}) == {2}\n     n = Symbol('n')\n \n     a = S.Reals\n",
  "sympy__sympy-17022": "diff --git a/sympy/printing/tests/test_numpy.py b/sympy/printing/tests/test_numpy.py\nindex fa5ed1f..b044c27 100644\n--- a/sympy/printing/tests/test_numpy.py\n+++ b/sympy/printing/tests/test_numpy.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Piecewise, lambdify, Equality, Unequality, Sum, Mod, cbrt, sqrt,\n     MatrixSymbol, BlockMatrix\n@@ -10,7 +11,27 @@ from sympy.codegen.array_utils import (CodegenArrayContraction,\n         CodegenArrayPermuteDims, CodegenArrayElementwiseAdd)\n from sympy.printing.lambdarepr import NumPyPrinter\n \n-from sympy.utilities.pytest import warns_deprecated_sympy\n+from sympy.utilities.pytest import warns_deprecated_sympy, raises\n+from sympy import symbols, Identity\n+from sympy.external import import_module\n+\n+np = import_module('numpy')\n+\n+def test_issue_lambdify_identity():\n+    if not np:\n+        skip(\"NumPy not installed\")\n+\n+    # Test for specific size matrix\n+    M = MatrixSymbol(\"M\", 2, 2)\n+    f = lambdify(M, M + Identity(2), 'numpy')\n+    ma = np.array([[1, 2], [3, 4]])\n+    expected_result = np.array([[2, 2], [3, 5]])\n+    assert (f(ma) == expected_result).all()\n+\n+    # Test for dynamic size matrix which should raise NotImplementedError\n+    n = symbols('n', integer=True)\n+    N = MatrixSymbol(\"M\", n, n)\n+    raises(NotImplementedError, lambda: lambdify(N, N + Identity(n), 'numpy'))\n from sympy.utilities.pytest import skip\n from sympy.external import import_module\n \n",
  "sympy__sympy-17139": "",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..2c62355 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,12 +1,17 @@\n-from sympy import I, Rational, Symbol, pi, sqrt, S\n+\n+from sympy import I, Rational, Symbol, pi, sqrt, S, sympify\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.pytest import raises, warns\n \n-\n-def test_point():\n+def test_point_operations():\n+    p1 = Point(0, 0)\n+    p2 = Point(1, 1)\n+    num = sympify(2.0)\n+    assert p1 + p2 * num == Point2D(2, 2)\n+    assert p1 + num * p2 == Point2D(2, 2)\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n@@ -118,8 +123,12 @@ def test_point():\n     raises(ValueError, lambda: p3.transform(p3))\n     raises(ValueError, lambda: p.transform(Matrix([[1, 0], [0, 1]])))\n \n-\n-def test_point3D():\n+def test_point_operations():\n+    p1 = Point(0, 0)\n+    p2 = Point(1, 1)\n+    num = sympify(2.0)\n+    assert p1 + p2 * num == Point2D(2, 2)\n+    assert p1 + num * p2 == Point2D(2, 2)\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..23f6344 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1893,8 +1893,40 @@ def test_normal():\n     e = Mul(S.Half, 1 + x, evaluate=False)\n     assert e.normal() == e\n \n+from sympy import Symbol, symbols, sympify\n+from sympy.utilities.pytest import raises\n \n-def test_expr():\n+def test_sympy_equality_with_custom_repr():\n+    # Test for evaluating equality with objects having misleading repr\n+    x = Symbol('x')\n+\n+    class MisleadingRepr:\n+        def __repr__(self):\n+            return 'non.existing'\n+\n+    class ExactRepr:\n+        def __repr__(self):\n+            return 'x'\n+\n+    # Case 1: Repr that results in a non-existent attribute should not be evaluated\n+    obj = MisleadingRepr()\n+    assert (x == obj) is False, \"A misleading repr should not affect equality check.\"\n+\n+    # Case 2: Repr that matches existing Symbol name exactly, should not modify equality\n+    obj = ExactRepr()\n+    assert (x == obj) is False, \"Exact repr match should not mislead equality.\"\n+\n+    # Related issue: Check complex string evaluation doesn't occur\n+    class ComplexRepr:\n+        def __repr__(self):\n+            return 'x + y'\n+\n+    expr_obj = ComplexRepr()\n+    assert (x + sympify('y') == expr_obj) is False, \"Should not evaluate complex repr.\"\n+\n+    # Confirm proper unequal checks remain unaffected\n+    y = Symbol('y')\n+    assert (x != y) is True, \"Different symbols should remain unequal.\"\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n \n@@ -1902,4 +1934,4 @@ def test_expr():\n def test_ExprBuilder():\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..d7a167e 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -547,7 +547,17 @@ def test_diophantine():\n     assert diophantine(x**2 + y**2 +3*x- 5, permute=True) == \\\n         set([(-1, 1), (-4, -1), (1, -1), (1, 1), (-4, 1), (-1, -1), (4, 1), (4, -1)])\n \n-    # issue 18122\n+    # test issue 18186\n+    assert diophantine(y**4 + x**4 - 2**4 - 3**4, syms=(x, y), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    assert diophantine(y**4 + x**4 - 2**4 - 3**4, syms=(y, x), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+   \n+    # additional tests for more coverage\n+    assert diophantine(x**4 + x**4 - 2**4 - 3**4, syms=(x, x), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    assert diophantine(x**4 + y**4 - 1**4 - 1**4, syms=(x, y), permute=True) == \\\n+        set([(0, 1), (0, -1), (1, 0), (-1, 0)])\n     assert check_solutions(x**2-y)\n     assert check_solutions(y**2-x)\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n",
  "sympy__sympy-18532": "diff --git a/sympy/codegen/tests/test_cnodes.py b/sympy/codegen/tests/test_cnodes.py\nindex c30dccd..13ebf86 100644\n--- a/sympy/codegen/tests/test_cnodes.py\n+++ b/sympy/codegen/tests/test_cnodes.py\n@@ -1,3 +1,5 @@\n+\n+from sympy import Basic, Symbol\n from sympy.core.symbol import symbols\n from sympy.printing.ccode import ccode\n from sympy.codegen.ast import Declaration, Variable, float64, int64\n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..96d1f66 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,41 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_blockdiagmatrix_single_element():\n+    from sympy import Matrix, BlockDiagMatrix\n+    # Create a sample matrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    # Create a BlockDiagMatrix with a single element\n+    D = BlockDiagMatrix(M)\n+    # Convert it back to a regular Matrix\n+    B = Matrix(D)\n+    # Assert that the conversion works as expected\n+    assert B == M\n+\n+def test_blockdiagmatrix_multiple_elements():\n+    from sympy import Matrix, BlockDiagMatrix, ZeroMatrix\n+    # Test with multiple elements\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M, M)\n+    B = Matrix(D)\n+    # Expected result after conversion\n+    expected = Matrix([\n+        [1, 2, 0, 0],\n+        [3, 4, 0, 0],\n+        [0, 0, 1, 2],\n+        [0, 0, 3, 4]\n+    ])\n+    assert B == expected\n+\n+def test_blockdiagmatrix_zero_matrix():\n+    from sympy import Matrix, BlockDiagMatrix, ZeroMatrix\n+    # Test with zero matrix\n+    Z = ZeroMatrix(2, 2)\n+    D = BlockDiagMatrix(Z)\n+    B = Matrix(D)\n+    # Assert that the zero matrix remains a zero matrix\n+    assert B == Matrix.zeros(2)\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..77d0592 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n@@ -83,6 +84,14 @@ def test_block_index():\n     assert BI.as_explicit().equals(eye(6))\n \n \n+def test_block_index_symbolic():\n+    # Ensure that symbolic indices correctly refer to matrix elements without premature simplification\n+    n, i = symbols('n, i', integer=True)\n+    A = MatrixSymbol('A', 1, 1)\n+    B = MatrixSymbol('B', n, 1)\n+    C = BlockMatrix([[A], [B]])\n+    assert C[i, 0] == MatrixElement(C, i, 0)  # Check for proper indexing without simplification\n+\n def test_slicing():\n     A.as_explicit()[0, :]  # does not raise an error\n \n",
  "sympy__sympy-19487": "",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..9d5e702 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -470,8 +470,24 @@ def test_multiset_permutations():\n         [1, 1, 0, 0, 0]\n         6\\n''')\n \n+from sympy.utilities.iterables import partitions\n \n-def test_partitions():\n+def test_partitions_non_reuse():\n+    # Test that the dictionaries returned by partitions are distinct instances\n+    results1 = [p.copy() for p in partitions(6, k=2)]\n+    results2 = [p.copy() for p in partitions(6, k=2)]\n+\n+    for res1, res2 in zip(results1, results2):\n+        assert res1 is not res2, \"The result dictionaries should be distinct instances\"\n+        assert res1 == res2, \"The result contents should be equivalent\"\n+\n+    # Checking that appending to a dictionary of one does not affect the other\n+    results1 = [p.copy() for p in partitions(6, k=2)]\n+    results2 = [p.copy() for p in partitions(6, k=2)]\n+\n+    results1[0][1] = 100  # Modify the first partition returned\n+\n+    assert results1[0] != results2[0], \"Modifications in one partition should not affect another\"\n     ans = [[{}], [(0, {})]]\n     for i in range(2):\n         assert list(partitions(0, size=i)) == ans[i]\n",
  "sympy__sympy-20212": "diff --git a/sympy/core/tests/test_power.py b/sympy/core/tests/test_power.py\nindex 686973b..3f23b56 100644\n--- a/sympy/core/tests/test_power.py\n+++ b/sympy/core/tests/test_power.py\n@@ -253,8 +253,12 @@ def test_power_rewrite_exp():\n     assert all((1/func(x)).rewrite(exp) == 1/(func(x).rewrite(exp)) for func in\n                     (sin, cos, tan, sec, csc, sinh, cosh, tanh))\n \n+from sympy import oo, S, power, Pow\n \n-def test_zero():\n+def test_issue_0_neg_infinity():\n+    # Test for 0 raised to negative infinity\n+    assert Pow(S.Zero, -oo) == S.ComplexInfinity\n+    assert power(S.Zero, -oo) == S.ComplexInfinity\n     x = Symbol('x')\n     y = Symbol('y')\n     assert 0**x != 0\n",
  "sympy__sympy-20442": "",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..b2b206b 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -27,8 +27,14 @@ def test__aresame():\n     assert not _aresame(Basic([]), Basic(()))\n     assert not _aresame(Basic(2), Basic(2.))\n \n-\n-def test_structure():\n+from sympy import Symbol\n+from pytest import raises\n+\n+def test_symbol_no_dict():\n+    s = Symbol('s')\n+    assert not hasattr(s, '__dict__')\n+    with raises(AttributeError):\n+        _ = s.__dict__\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n     assert bool(b1)\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..17209d8 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,5 +1,6 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n-                   atan, atan2, nan, Symbol, re, im, sign)\n+                   atan, atan2, nan, Symbol, re, im, sign, Integral, sin, oo)\n from sympy.abc import w, x, y, z\n from sympy.core.relational import Eq, Ne\n from sympy.functions.elementary.piecewise import Piecewise\n@@ -160,6 +161,28 @@ def test_sign():\n     x = Symbol('x', complex=True)\n     assert refine(sign(x), Q.zero(x)) == 0\n \n+def test_refine_arg_with_complex_assumptions():\n+    a = Symbol('a', complex=True)\n+    x = Symbol('x', real=True)\n+\n+    # Original issue test: arg with positive assumption\n+    assert refine(arg(a), Q.positive(a)) == 0\n+    \n+    # New cases:\n+    # Test arg under negative assumption\n+    assert refine(arg(a), Q.negative(a)) == pi\n+\n+    # Test arg with zero assumption\n+    assert refine(arg(a), Q.zero(a)) == 0\n+\n+    # Test Integral case mentioned in the issue with appropriate assumption\n+    J = Integral(sin(x)*exp(-a*x),(x,0,oo)).doit()\n+    refined_J = refine(J, Q.positive(a))\n+    assert str(refined_J) == '1/(a**2 + 1)'\n+\n+    # Test abs with positive assumption\n+    assert refine(Abs(a), Q.positive(a)) == a\n+\n \n def test_func_args():\n     class MyClass(Expr):\n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..089f318 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -19,8 +20,15 @@ def test_subs():\n     e = e.subs(x, n3)\n     assert e == Rational(6)\n \n-\n-def test_subs_Matrix():\n+def test_issue_21373():\n+    from sympy.functions.elementary.trigonometric import sinh\n+    from sympy.functions.elementary.piecewise import Piecewise\n+    x_r, y_r, z = symbols('x_r y_r z', real=True)\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))\n+    result = expr.subs({1: 1.0})\n+    assert result.is_Pow\n+    assert isinstance(result, exp)\n+    assert sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) * z ** -1.0).is_zero in (None, False)\n     z = zeros(2)\n     z1 = ZeroMatrix(2, 2)\n     assert (x*y).subs({x:z, y:0}) in [z, z1]\n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..5e2d540 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,9 +1,11 @@\n+\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n from sympy.core.numbers import pi, zoo, I, AlgebraicNumber\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n+from sympy.core.function import Derivative\n from sympy.integrals.integrals import Integral\n from sympy.matrices import (Matrix, SparseMatrix, ImmutableMatrix,\n     ImmutableSparseMatrix, MatrixSymbol, MatrixKind, MatMul)\n@@ -45,7 +47,10 @@ def test_Matrix_kind():\n         m = cls.zeros(3, 2)\n         assert m.kind is MatrixKind(NumberKind)\n \n-def test_MatMul_kind():\n+def test_Derivative_kind():\n+    A = MatrixSymbol('A', 2, 2)\n+    assert Derivative(comm_x, comm_x).kind is NumberKind\n+    assert Derivative(A, comm_x).kind is MatrixKind(NumberKind)\n     M = Matrix([[1,2],[3,4]])\n     assert MatMul(2, M).kind is MatrixKind(NumberKind)\n     assert MatMul(comm_x, M).kind is MatrixKind(NumberKind)\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..920e181 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -131,6 +131,24 @@ def test_monomials():\n     assert set(itermonomials([x, y], [2, 2])) == \\\n             {S.One, y**2, x*y**2, x, x*y, x**2, x**2*y**2, y, x**2*y}\n \n+    x1, x2, x3 = symbols('x1 x2 x3')\n+    assert set(itermonomials([x1, x2, x3], 3, 3)) == {\n+        x1**3, x2**3, x3**3, \n+        x1**2*x2, x1**2*x3, x2**2*x1, x2**2*x3, x3**2*x1, x3**2*x2,\n+        x1*x2*x3, x1*x2**2, x1*x3**2, x2*x3**2, x2*x1**2, \n+        x3*x1**2, x3*x2**2\n+    }\n+    assert set(itermonomials([x1, x2, x3], 4, 3)) == {\n+        x1**3, x2**3, x3**3, \n+        x1**2*x2, x1**2*x3, x2**2*x1, x2**2*x3, x3**2*x1, x3**2*x2,\n+        x1*x2*x3, x1*x2**2, x1*x3**2, x2*x3**2, x2*x1**2, \n+        x3*x1**2, x3*x2**2,\n+        x1**4, x2**4, x3**4,\n+        x1*x2**3, x1*x3**3, x2*x3**3,\n+        x1**3*x2, x1**3*x3, x2**3*x1, x2**3*x3, x3**3*x1, x3**3*x2,\n+        x1**2*x2*x3, x2**2*x1*x3, x3**2*x1*x2\n+    }\n+\n     i, j, k = symbols('i j k', commutative=False)\n     assert set(itermonomials([i, j, k], [0, 0, 0])) == {S.One}\n     assert set(itermonomials([i, j, k], [0, 0, 1])) == {1, k}\n",
  "sympy__sympy-22005": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 341f63c..a42c36e 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n@@ -49,8 +50,19 @@ def test_solve_poly_system():\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\n     raises(PolynomialError, lambda: solve_poly_system([1/x], x))\n \n+    # Tests related to the specific issue with infinite solutions\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [x - 1], (x, y)))  # Original test case\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [y - 1], (x, y)))  # Original test case\n \n-def test_solve_biquadratic():\n+    # Additional test for handling correct behavior\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [x**2 - 1, y], (x, y)))  # Both should be univariate but two variables\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [x*y - 1], (x, y)))  # Multivariate polynomial case\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [x, y, z - 1], (x, y, z)))  # More variables than equations\n     x0, y0, x1, y1, r = symbols('x0 y0 x1 y1 r')\n \n     f_1 = (x - 1)**2 + (y - 1)**2 - r**2\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..b9e4949 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n@@ -9,6 +10,7 @@ from sympy.geometry.entity import rotate, scale, translate, GeometryEntity\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.misc import Undecidable\n+from sympy.core.parameters import evaluate\n from sympy.testing.pytest import raises, warns\n \n \n@@ -440,6 +442,11 @@ def test_unit():\n     assert Point(1, 1).unit == Point(sqrt(2)/2, sqrt(2)/2)\n \n \n+def test_issue_22684():\n+    # Verify that Point2D with evaluate(False) doesn't raise an error\n+    with evaluate(False):\n+        assert isinstance(Point2D(Integer(1), Integer(2)), Point2D)\n+\n def test_dot():\n     raises(TypeError, lambda: Point(1, 2).dot(Line((0, 0), (1, 1))))\n \n",
  "sympy__sympy-22840": "",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..64a3867 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -9,6 +10,7 @@ from sympy.tensor.array.sparse_ndim_array import (\n     ImmutableSparseNDimArray, MutableSparseNDimArray)\n \n from sympy.abc import x, y\n+from sympy.tensor.array.dense_ndim_array import MutableDenseNDimArray, MutableSparseNDimArray\n \n array_types = [\n     ImmutableDenseNDimArray,\n@@ -16,9 +18,12 @@ array_types = [\n     MutableDenseNDimArray,\n     MutableSparseNDimArray\n ]\n-\n-\n-def test_array_negative_indices():\n+def test_empty_array_creation():\n+    for ArrayType in array_types:\n+        A = ArrayType([])\n+        assert isinstance(A, ArrayType)\n+        assert A.shape == (0,)\n+        assert list(A) == []\n     for ArrayType in array_types:\n         test_array = ArrayType([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n         assert test_array[:, -1] == Array([5, 10])\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..854ed33 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,6 +1175,42 @@ def test_scipy_polys():\n \n \n \n+def test_tuple_with_one_element():\n+    # Test for ensuring tuples with single element have the trailing comma\n+    f2b = lambdify([], (1,))\n+    assert f2b() == (1,)\n+    code_str = inspect.getsource(f2b)\n+    assert 'return (1,)' in code_str\n+    \n+    # Test for ensuring tuples with multiple elements\n+    f_multi = lambdify([], (1, 2))\n+    assert f_multi() == (1, 2)\n+    code_str_multi = inspect.getsource(f_multi)\n+    assert 'return (1, 2)' in code_str_multi\n+\n+def test_tuple_output():\n+    # Test using a 2-element tuple\n+    f2 = lambdify([], (1, 2))\n+    assert f2() == (1, 2)\n+    code_str = inspect.getsource(f2)\n+    assert 'return (1, 2)' in code_str\n+    \n+    # Test using a single element list\n+    f2_single = lambdify([], [1])\n+    assert f2_single() == [1]\n+    code_str_single = inspect.getsource(f2_single)\n+    assert 'return [1]' in code_str_single\n+\n+def test_tuple_with_none():\n+    # Test using a tuple with one element and a None element\n+    f2_none = lambdify([], (1, None))\n+    assert f2_none() == (1, None)\n+    code_str_none = inspect.getsource(f2_none)\n+    assert 'return (1, None)' in code_str_none\n+\n+import inspect\n+from sympy import lambdify\n+\n def test_lambdify_inspect():\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..fd1822f 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -528,6 +528,28 @@ def test_issue_22819():\n     assert Da.scale_factor == 1.66053906660000e-24\n \n \n+from sympy.core.numbers import E\n+from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+from sympy.physics.units.systems.si import SI\n+...\n+def test_issue_24062():\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n+\n+\n def test_issue_20288():\n     from sympy.core.numbers import E\n     from sympy.physics.units import energy\n",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..4a117c0 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -46,6 +46,26 @@ def test_tensor_product_expand():\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n \n+def test_tensor_product_expand_with_scalars():\n+    # This test checks expansion with scalar multiplication within factors\n+    U = Operator('U')\n+    V = Operator('V')\n+\n+    P = TP(2*U - V, U + V)\n+    expanded_P = P.expand(tensorproduct=True)\n+    assert expanded_P == 2*TP(U, U) + 2*TP(U, V) - TP(V, U) - TP(V, V), \\\n+        \"The expansion did not distribute the scalar multiplication correctly.\"\n+\n+    P2 = TP(3*U, 4*V + U)\n+    expanded_P2 = P2.expand(tensorproduct=True)\n+    assert expanded_P2 == 3*4*TP(U, V) + 3*TP(U, U), \\\n+        \"The expansion did not distribute the scalar multiplication correctly.\"\n+\n+    P3 = TP(U + 2*V, 3*U - V)\n+    expanded_P3 = P3.expand(tensorproduct=True)\n+    assert expanded_P3 == TP(U, 3*U) - TP(U, V) + 2*TP(V, 3*U) - 2*TP(V, V), \\\n+        \"The expansion did not distribute the scalar multiplication correctly.\"\n+\n def test_tensor_product_commutator():\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n         TP(A*B, C) - TP(B*A, C)\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..7ccd6d4 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -562,7 +563,46 @@ def test_issue_24062():\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n \n-def test_prefixed_property():\n+from sympy.physics.units import Quantity, time, velocity, acceleration, second, meter, SI\n+\n+def test_issue_24211():\n+    from sympy.physics.units import time, velocity, acceleration, second, meter\n+    V1 = Quantity('V1')\n+    SI.set_quantity_dimension(V1, velocity)\n+    SI.set_quantity_scale_factor(V1, 1 * meter / second)\n+    A1 = Quantity('A1')\n+    SI.set_quantity_dimension(A1, acceleration)\n+    SI.set_quantity_scale_factor(A1, 1 * meter / second**2)\n+    T1 = Quantity('T1')\n+    SI.set_quantity_dimension(T1, time)\n+    SI.set_quantity_scale_factor(T1, 1 * second)\n+\n+    expr = A1*T1 + V1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr)\n+\n+def test_collect_factor_and_dimension_issue():\n+    # Set up quantities and their corresponding dimensions and scale factors\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+\n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+\n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+\n+    expr1 = a1 * t1 + v1\n+\n+    # The function should not raise a ValueError now\n+    factor, dim = SI._collect_factor_and_dimension(expr1)\n+\n+    # Verify that the dimensions are equivalent\n+    assert dim == velocity\n+    assert factor == -9.8 * 5 + 2\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..a61375b 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, milli\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n",
  "django__django-12470": "diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py\nindex 067de1c..4521c90 100644\n--- a/tests/model_inheritance/tests.py\n+++ b/tests/model_inheritance/tests.py\n@@ -13,6 +13,24 @@ from .models import (\n \n \n class ModelInheritanceTests(TestCase):\n+    def test_child_ordering_inheritance(self):\n+        # Create instances of Parent and Child to test ordering\n+        p1 = Parent.objects.create(first_name='Alice', email='alice@example.com')\n+        p2 = Parent.objects.create(first_name='Bob', email='bob@example.com')\n+        c1 = Child.objects.create(first_name='Charlie', email='charlie@example.com')\n+        c2 = Child.objects.create(first_name='Dave', email='dave@example.com')\n+\n+        # Verify that Parent instances are ordered by `-pk`\n+        parents = Parent.objects.all()\n+        self.assertSequenceEqual(parents, [p2, p1], \"Parent objects are not ordered by -pk\")\n+\n+        # Verify that Child instances inherit and order by `-pk` from Parent\n+        children = Child.objects.all()\n+        self.assertSequenceEqual(children, [c2, c1], \"Child objects are not ordered by -pk\")\n+\n+        # Check that the generated SQL query contains the expected ORDER BY clause for the Child model\n+        expected_order_by_sql = 'ORDER BY \"tests_grandparent\".\"id\" DESC'\n+        self.assertIn(expected_order_by_sql, str(children.query), \"ORDER BY clause not found in query for Child\")\n     def test_abstract(self):\n         # The Student and Worker models both have 'name' and 'age' fields on\n         # them and inherit the __str__() method, just as with normal Python\n",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..2279ba4 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,7 +343,27 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n-    def test_order_by_f_expression(self):\n+    def test_self_reference_ordering(self):\n+        # Setup authors and articles as per the situation described in the issue\n+        author_1 = Author.objects.create(name='Author 1')\n+        author_2 = Author.objects.create(name='Author 2', editor=author_1)\n+\n+        article1 = Article.objects.create(headline='Article 1', author=author_1)\n+        article2 = Article.objects.create(headline='Article 2', author=author_2)\n+\n+        # Test ordering by 'author__editor'\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor'), \n+            ['Article 2', 'Article 1'], \n+            lambda a: a.headline\n+        )\n+\n+        # Test ordering by 'author__editor_id'\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'), \n+            ['Article 1', 'Article 2'], \n+            lambda a: a.headline\n+        )\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n                 \"Article 1\",\n",
  "django__django-13265": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..7eb8ddc 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3201,8 +3201,23 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         form = SomeForm()\n         self.assertEqual(form['field'].id_for_label, 'myCustomID')\n         self.assertEqual(form['field_none'].id_for_label, 'id_field_none')\n+    def test_boundfield_subwidget_id_for_label_checkbox_select_multiple(self):\n+        \"\"\"\n+        Test that CheckboxSelectMultiple subwidgets use the correct ID for label\n+        when the auto_id is provided.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple,\n+            )\n \n-    def test_boundfield_widget_type(self):\n+        # Test with a custom auto_id format\n+        form = SomeForm(auto_id='custom_%s')\n+        subwidgets = form['field'].subwidgets\n+        # Ensure the custom id is correctly used for each subwidget\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_field_1')\n         class SomeForm(Form):\n             first_name = CharField()\n             birthday = SplitDateTimeField(widget=SplitHiddenDateTimeWidget)\n",
  "django__django-16400": "diff --git a/tests/auth_tests/test_management.py b/tests/auth_tests/test_management.py\nindex de2502e..7836452 100644\n--- a/tests/auth_tests/test_management.py\n+++ b/tests/auth_tests/test_management.py\n@@ -1484,4 +1484,40 @@ class CreatePermissionsTests(TestCase):\n                 content_type__app_label=opts.app_label,\n                 codename=codename,\n             ).exists()\n-        )\n+        )\n+\n+@override_settings(DATABASE_ROUTERS=[DefaultDBRouter()])\n+class MigrateCommandDatabaseParameterTests(TestCase):\n+    databases = {\"default\", \"other\"}\n+\n+    def test_migrate_command_respects_database_parameter(self):\n+        \"\"\"\n+        Test that the migrate command respects the database parameter when adding permissions.\n+        \"\"\"\n+        # Ensure no permissions exist in the \"other\" database initially.\n+        Permission.objects.using(\"other\").delete()\n+        Permission.objects.using(\"default\").delete()\n+\n+        # Manually create permissions in default database\n+        create_permissions(apps.get_app_config(\"auth\"), verbosity=0, using=\"default\")\n+\n+        # Execute the migrate command specifically on the \"other\" database\n+        call_command(\"migrate\", database=\"other\", verbosity=0)\n+\n+        # Check that permissions are still absent in \"default\" and now present in \"other\".\n+        self.assertEqual(Permission.objects.using(\"default\").count(), 0)\n+        self.assertGreater(Permission.objects.using(\"other\").count(), 0)\n+\n+    def test_no_default_read_when_using_other_database(self):\n+        \"\"\"\n+        Test that no read operations are routed to default when specifying 'other' database in migrate.\n+        \"\"\"\n+        Permission.objects.using(\"other\").delete()\n+        Permission.objects.using(\"default\").delete()\n+\n+        with self.assertNumQueries(6, using=\"other\") as captured_queries:\n+            create_permissions(apps.get_app_config(\"auth\"), verbosity=0, using=\"other\")\n+\n+        # There should be no reads against the \"default\" database\n+        for query in captured_queries.captured_queries:\n+            self.assertNotIn('FROM \"default\".', query[\"sql\"])\n",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..a3d8a8c 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -657,6 +657,36 @@ def test_colorbar_scale_reset():\n \n     assert cbar.outline.get_edgecolor() == mcolors.to_rgba('red')\n \n+def test_update_colorbar_after_change_norm():\n+    # Test case to verify the specific issue of updating colorbar\n+    import matplotlib.pyplot as plt\n+    from matplotlib.colors import LogNorm, Normalize\n+    import numpy as np\n+    \n+    img = 10**np.random.normal(1, 1, size=(50, 50))\n+\n+    fig, ax = plt.subplots(1, 1)\n+    plot = ax.imshow(img, cmap='gray')\n+    cb = fig.colorbar(plot, ax=ax)\n+    \n+    # Check initial norm and colorbar scale\n+    assert isinstance(plot.norm, Normalize)\n+    assert cb.ax.yaxis.get_scale() == 'linear'\n+    \n+    # Change norm to LogNorm and update colorbar\n+    plot.set_norm(LogNorm(vmin=img.min(), vmax=img.max()))\n+    cb.update_normal(plot)\n+    \n+    # Verify if the colorbar scale has been updated to 'log'\n+    fig.canvas.draw()\n+    assert cb.ax.yaxis.get_scale() == 'log'\n+    \n+    # Restore a linear scale\n+    plot.set_norm(Normalize(vmin=img.min(), vmax=img.max()))\n+    cb.update_normal(plot)\n+    fig.canvas.draw()\n+    assert cb.ax.yaxis.get_scale() == 'linear'\n+\n \n def test_colorbar_get_ticks_2():\n     plt.rcParams['_internal.classic_mode'] = False\n",
  "pydata__xarray-4094": "",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..c01d153 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -259,4 +259,31 @@ def test_set_output_mro():\n     class C(A, B):\n         pass\n \n-    assert C().transform(None) == \"B\"\n+    assert C().transform(None) == \"B\"\n+\n+import pandas as pd\n+import pytest\n+from sklearn.base import BaseEstimator, TransformerMixin\n+from sklearn.pipeline import FeatureUnion\n+from sklearn import set_config\n+\n+class MyTransformer(BaseEstimator, TransformerMixin):\n+    def fit(self, X: pd.DataFrame, y=None):\n+        return self\n+\n+    def transform(self, X: pd.DataFrame, y=None) -> pd.DataFrame:\n+        return X[\"value\"].groupby(X[\"date\"]).sum()\n+\n+def test_feature_union_pandas_transform_output():\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+\n+    # Test with pandas output\n+    set_config(transform_output=\"pandas\")\n+    feature_union = FeatureUnion([(\"mytransformer\", MyTransformer())])\n+    transformed_data = feature_union.fit_transform(data)\n+    \n+    # Check if transformed data is correct length and type (DataFrame)\n+    assert isinstance(transformed_data, pd.DataFrame)\n+    assert len(transformed_data) == data[\"date\"].nunique()\n",
  "sphinx-doc__sphinx-8801": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 37d6e17..9ef55f7 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -106,6 +106,32 @@ def test_inherited_instance_variable(app):\n     ]\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'target.uninitialized_attributes.Derived', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Derived',\n+        '   :module: target.uninitialized_attributes',\n+        '',\n+        '',\n+        '   .. py:attribute:: Derived.attr1',\n+        '      :module: target.uninitialized_attributes',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Derived.attr3',\n+        '      :module: target.uninitialized_attributes',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n def test_decorators(app):\n     actual = do_autodoc(app, 'class', 'target.decorator.Baz')\n     assert list(actual) == [\n@@ -115,6 +141,32 @@ def test_decorators(app):\n         '',\n     ]\n \n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'target.uninitialized_attributes.Derived', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Derived',\n+        '   :module: target.uninitialized_attributes',\n+        '',\n+        '',\n+        '   .. py:attribute:: Derived.attr1',\n+        '      :module: target.uninitialized_attributes',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Derived.attr3',\n+        '      :module: target.uninitialized_attributes',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n     actual = do_autodoc(app, 'class', 'target.decorator.Qux')\n     assert list(actual) == [\n         '',\n@@ -132,6 +184,32 @@ def test_decorators(app):\n     ]\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app):\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'target.uninitialized_attributes.Derived', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Derived',\n+        '   :module: target.uninitialized_attributes',\n+        '',\n+        '',\n+        '   .. py:attribute:: Derived.attr1',\n+        '      :module: target.uninitialized_attributes',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Derived.attr3',\n+        '      :module: target.uninitialized_attributes',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_slots_attribute(app):\n     options = {\"members\": None}\n",
  "sympy__sympy-15346": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex cce4836..1fd465e 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     symbols, sin, simplify, cos, trigsimp, rad, tan, exptrigsimp,sinh,\n     cosh, diff, cot, Subs, exp, tanh, exp, S, integrate, I,Matrix,\n@@ -358,6 +359,34 @@ def test_issue_2827_trigsimp_methods():\n     assert exptrigsimp(eq) == eq\n \n \n+def test_issue_15129_trigsimp_methods():\n+    # Test issue where sin/cos/Rational operations were not simplifying as expected\n+\n+    # Define the test matrices\n+    t1 = Matrix([sin(Rational(1, 50)), cos(Rational(1, 50)), 0])\n+    t2 = Matrix([sin(Rational(1, 25)), cos(Rational(1, 25)), 0])\n+    t3 = Matrix([cos(Rational(1, 25)), sin(Rational(1, 25)), 0])\n+\n+    # Calculate dot products\n+    r1 = t1.dot(t2)\n+    r2 = t1.dot(t3)\n+\n+    # Assert simplification works as expected\n+    assert trigsimp(r1) == cos(S(1)/50)\n+    assert trigsimp(r2) == sin(S(3)/50)\n+\n+    # Ensure 'simplify()' applies to trigonometric identities with Rational numbers\n+    r3 = sin(Rational(1, 50))*sin(Rational(1, 25)) + cos(Rational(1, 50))*cos(Rational(1, 25))\n+    assert simplify(r3) == cos(S(1)/50)\n+\n+    # Test using acos to ensure expressions involving acos are correctly simplified\n+    acos_r3 = acos(r3)\n+    assert acos_r3.simplify() == S(1)/50\n+    \n+    # Test with trigsimp directly\n+    assert trigsimp(acos(r3)) == S(1)/50\n+\n+\n def test_exptrigsimp():\n     def valid(a, b):\n         from sympy.utilities.randtest import verify_numerically as tn\n",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..32731b0 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4862,8 +4862,25 @@ k = \u2500\u2500\u2500\u2500\u2500                                \\n\\\n     assert pretty(expr) == ascii_str\n     assert upretty(expr) == ucode_str\n \n+def test_sum_pretty_print_alignment():\n+    from sympy import Sum, oo, pprint\n+    from sympy.abc import x\n \n-def test_units():\n+    expr = Sum(x, (x, 1, oo)) + 3\n+    # The expected output with correct alignment:\n+    expected_output = \\\n+    u(\"\"\"\\\n+      \u221e  \\n\\\n+     ___ \\n\\\n+     \u2572   \\n\\\n+      \u2572  x\\n\\\n+      \u2571  + 3\\n\\\n+     \u2571   \\n\\\n+     \u203e\u203e\u203e  \\n\\\n+    x = 1\\\n+    \"\"\")\n+    \n+    assert upretty(expr) == expected_output\n     expr = joule\n     ascii_str1 = \\\n \"\"\"\\\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex b2b6202..383454a 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -704,8 +704,29 @@ def test_uniq():\n     assert list(uniq([2, 3, 2, 4, [2], [1], [2], [3], [1]])) == \\\n         [2, 3, 4, [2], [1], [3]]\n \n+def test_uniq_modification_error():\n+    from sympy.utilities.iterables import uniq\n+    from sympy.testing.pytest import raises\n \n-def test_kbins():\n+    # Test with a simple list of integers\n+    f = [1, 2, 3, 4, 5]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Test with a list of strings\n+    f = list('sympy')\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Test with a list of tuples\n+    f = [(1, 2), (3, 4), (1, 2)]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Test with a list of lists\n+    f = [[1, 2], [3, 4], [1, 2]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Test with a list already containing duplicate elements\n+    f = [1, 1, 2, 2, 3, 3]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n     assert len(list(kbins('1123', 2, ordered=1))) == 24\n     assert len(list(kbins('1123', 2, ordered=11))) == 36\n     assert len(list(kbins('1123', 2, ordered=10))) == 10\n",
  "django__django-11797": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 7beeac3..4437aca 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -1,3 +1,4 @@\n+\n import collections.abc\n from datetime import datetime\n from math import ceil\n@@ -5,6 +6,7 @@ from operator import attrgetter\n \n from django.core.exceptions import FieldError\n from django.db import connection\n+from django.db.models import Max\n from django.db.models.expressions import Exists, OuterRef\n from django.db.models.functions import Substr\n from django.test import TestCase, skipUnlessDBFeature\n",
  "django__django-15320": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 35f7f03..f47929c 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -537,7 +537,25 @@ class BasicExpressionsTests(TestCase):\n             qs.query.annotations['small_company'],\n         )\n \n-    def test_in_subquery(self):\n+    def test_subquery_sql_issue(self):\n+        # Test to verify Subquery.as_sql() generates valid SQL by default\n+        from django.db import connection\n+        from django.db.models import Subquery\n+        from myapp.models import Employee  # Replace with actual app and model\n+\n+        employees = Employee.objects.all()\n+        # Ensure Subquery automatically marks `subquery` attribute to True\n+        employees_subquery = Subquery(employees)\n+        self.assertIs(employees_subquery.query.subquery, True)\n+        self.assertIs(employees.query.subquery, False)\n+        \n+        # Get SQL compiler for this connection\n+        compiler = employees_subquery.query.get_compiler(connection=connection)\n+        \n+        # Generate SQL and assert correctness\n+        sql, _ = employees_subquery.as_sql(compiler, connection)\n+        self.assertIn('(SELECT', sql)\n+        self.assertTrue(sql.endswith(')'), \"SQL should properly construct subquery with parentheses\")\n         # This is a contrived test (and you really wouldn't write this query),\n         # but it is a succinct way to test the __in=Subquery() construct.\n         small_companies = Company.objects.filter(num_employees__lt=200).values('pk')\n",
  "django__django-15819": "diff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py\nindex 0ecd041..5f36caf 100644\n--- a/tests/inspectdb/tests.py\n+++ b/tests/inspectdb/tests.py\n@@ -434,7 +434,32 @@ class InspectDBTestCase(TestCase):\n         self.assertIn(\"# The error was:\", output)\n \n \n+from django.core.management import call_command\n+from django.test import TransactionTestCase\n+from io import StringIO\n+from unittest import mock\n+\n class InspectDBTransactionalTests(TransactionTestCase):\n+\n+    def test_same_model_relations_related_name(self):\n+        \"\"\"\n+        Test that inspectdb generates a unique related_name for fields\n+        referencing the same model to avoid reverse accessor clashes.\n+        \"\"\"\n+        out = StringIO()\n+\n+        # Mocking the SQL introspection to return specific tables.\n+        with mock.patch(\n+            \"django.db.connection.introspection.get_table_list\",\n+            return_value=[TableInfo(name=\"inspectdb_people\", type=\"t\")],\n+        ):\n+            call_command(\"inspectdb\", stdout=out)\n+\n+        output = out.getvalue()\n+        self.assertIn(\n+            \"parent = models.ForeignKey('self', models.CASCADE, related_name='people_set')\",\n+            output,\n+        )\n     available_apps = [\"inspectdb\"]\n \n     def test_include_views(self):\n",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..6c0aa1e 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -28,7 +29,34 @@ class ExistingRelatedInstancesTests(TestCase):\n             name=\"T1 Pool 1/3 Style\", pool=cls.p1, another_pool=cls.p3\n         )\n \n-    def test_foreign_key(self):\n+    def test_wrong_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation('pool__tournament__pool'),\n+                ).select_related('tournament_pool')\n+            )\n+            self.assertEqual(p[0].pool.tournament, p[0].tournament_pool.tournament)\n+\n+    def test_multilevel_reverse_fk_cyclic_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation(\"pool__tournament__pool\"),\n+                ).select_related(\"tournament_pool\", \"tournament_pool__tournament\")\n+            )\n+            self.assertEqual(p[0].tournament_pool.tournament, p[0].pool.tournament)\n+\n+    def test_multilevel_reverse_fk_select_related(self):\n+        with self.assertNumQueries(2):\n+            p = list(\n+                Tournament.objects.filter(id=self.t2.id)\n+                .annotate(\n+                    style=FilteredRelation(\"pool__another_style\"),\n+                )\n+                .select_related(\"style\")\n+            )\n+            self.assertEqual(p[0].style.another_pool, self.p3)\n         with self.assertNumQueries(2):\n             tournament = Tournament.objects.get(pk=self.t1.pk)\n             pool = tournament.pool_set.all()[0]\n@@ -163,4 +191,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex ad1a5e1..749acf8 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1,3 +1,26 @@\n+\n+def test_unpickle_dpi_m1_mac():\n+    fig = Figure(dpi=200)\n+    for _ in range(5):\n+        fig, dpi = dump_load_get_dpi(fig)\n+        assert dpi == 200, f\"Expected DPI 200 after unpickling, got {dpi}\"\n+\n+def dump_load_get_dpi(fig):\n+    # Use in-memory binary streams instead of file system\n+    blob = io.BytesIO()\n+    pickle.dump(fig, blob)\n+    blob.seek(0)\n+    fig2 = pickle.load(blob)\n+    return fig2, fig2.dpi\n+\n+# Maintain the original test patch\n+def test_unpickle_with_device_pixel_ratio():\n+    fig = Figure(dpi=42)\n+    fig.canvas._set_device_pixel_ratio(7)\n+    assert fig.dpi == 42 * 7\n+    fig2 = pickle.loads(pickle.dumps(fig))\n+    assert fig2.dpi == 42\n+\n import copy\n from datetime import datetime\n import io\n@@ -13,6 +36,8 @@ from PIL import Image\n \n import matplotlib as mpl\n from matplotlib import gridspec, rcParams\n+import pickle\n+from matplotlib.figure import Figure\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n from matplotlib.axes import Axes\n from matplotlib.figure import Figure, FigureBase\n",
  "mwaskom__seaborn-2848": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 5a5e126..48351f7 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -1,3 +1,4 @@\n+\n from itertools import product\n import numpy as np\n import matplotlib as mpl\n@@ -10,6 +11,7 @@ from numpy.testing import assert_array_equal\n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n \n+import seaborn as sns\n from seaborn.relational import (\n     _RelationalPlotter,\n     _LinePlotter,\n@@ -1623,6 +1625,23 @@ class TestScatterPlotter(SharedAxesLevelTests, Helpers):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n+    def test_pairgrid_with_hue_in_map(self):\n+        # Test `PairGrid` with `hue` assigned in `map` method for categorical hue\n+        iris = sns.load_dataset(\"iris\")\n+        g = sns.PairGrid(iris, y_vars=[\"sepal_length\", \"sepal_width\"], x_vars=[\"petal_length\", \"petal_width\"])\n+        \n+        # This should not raise any error\n+        try:\n+            g.map(sns.scatterplot, hue=iris[\"species\"])\n+        except Exception as e:\n+            self.fail(f\"PairGrid.map raised an exception with hue: {e}\")\n+        \n+        # Ensure a regression plot works without hue differentiation for regression\n+        try:\n+            g.map(sns.regplot, scatter=False)\n+        except Exception as e:\n+            self.fail(f\"PairGrid.map with regplot without scatter raised an exception: {e}\")\n+\n     def test_linewidths(self, long_df):\n \n         f, ax = plt.subplots()\n",
  "pytest-dev__pytest-5413": "diff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 226bfb9..aead4ec 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -333,6 +333,8 @@ def test_excinfo_exconly():\n     assert msg.endswith(\"world\")\n \n \n+import pytest\n+\n def test_excinfo_repr():\n     excinfo = pytest.raises(ValueError, h)\n     s = repr(excinfo)\n@@ -347,7 +349,27 @@ def test_excinfo_str():\n     assert len(s.split(\":\")) >= 3  # on windows it's 4\n \n \n-def test_excinfo_for_later():\n+def test_raises_str_behavior():\n+    # Testing the behavior of pytest.raises with str\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\"A\\nB\\nC\")\n+    \n+    # Check that str(excinfo) does not return the message directly\n+    excinfo_str = str(excinfo)\n+    assert \"LookupError\" in excinfo_str\n+    assert \"A\\nB\\nC\" not in excinfo_str  # The full message isn't directly within excinfo\n+    \n+    # Check that str(excinfo.value) returns the full message\n+    excinfo_value_str = str(excinfo.value)\n+    assert excinfo_value_str == \"A\\nB\\nC\"\n+\n+def test_raises_exconly():\n+    # Additional test to check exconly() method\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\"A\\nB\\nC\")\n+    \n+    exconly_str = excinfo.exconly()\n+    assert exconly_str == \"LookupError: A\\nB\\nC\"\n     e = ExceptionInfo.for_later()\n     assert \"for raises\" in repr(e)\n     assert \"for raises\" in str(e)\n",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..76953f9 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -405,6 +405,12 @@ class TestCustomConftests:\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n \n+    def test_collect_only_short_option(self, testdir):\n+        testdir.makepyfile(\"def test_example(): pass\")\n+        result = testdir.runpytest(\"-C\")\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_example*\"])\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+\n     def test_pytest_collect_file_from_sister_dir(self, testdir):\n         sub1 = testdir.mkpydir(\"sub1\")\n         sub2 = testdir.mkpydir(\"sub2\")\n@@ -434,6 +440,12 @@ class TestCustomConftests:\n         p.copy(sub1.join(p.basename))\n         p.copy(sub2.join(p.basename))\n         result = testdir.runpytest(\"--collect-only\")\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+\n+    def test_collect_only_short_option(self, testdir):\n+        testdir.makepyfile(\"def test_example(): pass\")\n+        result = testdir.runpytest(\"-C\")\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_example*\"])\n         result.stdout.fnmatch_lines([\"*MyModule1*\", \"*MyModule2*\", \"*test_x*\"])\n \n \n",
  "sphinx-doc__sphinx-10451": "diff --git a/tests/roots/test-ext-autodoc/target/typehints.py b/tests/roots/test-ext-autodoc/target/typehints.py\nindex 100ea06..74aee7d 100644\n--- a/tests/roots/test-ext-autodoc/target/typehints.py\n+++ b/tests/roots/test-ext-autodoc/target/typehints.py\n@@ -94,8 +94,14 @@ def missing_attr(c,\n class _ClassWithDocumentedInit:\n     \"\"\"Class docstring.\"\"\"\n \n-    def __init__(self, x: int) -> None:\n+    def __init__(self, x: int, *args: int, **kwargs: int) -> None:\n+        \"\"\"Init docstring.\n+        \n+        :param x: Some integer\n+        :param args: Some integer\n+        :param kwargs: Some integer\n+        \"\"\"\n         \"\"\"Init docstring.\n \n         :param x: Some integer\n-        \"\"\"\n+        \"\"\"\n",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..71e1eb0 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -83,8 +83,38 @@ def test_Identity():\n     assert transpose(In) == In\n     assert In.inverse() == In\n     assert In.conjugate() == In\n+from sympy import MatrixSymbol, Symbol, Sum, symbols, refine, Identity\n+from sympy.assumptions import assuming\n+from sympy.assumptions.assume import global_assumptions\n+from sympy import Q as Query\n+\n+def test_sum_identity_matrix():\n+    # Symbolic test: Ensure the sum of the elements in an identity matrix is 'n'\n+    n = Symbol('n', integer=True, positive=True)\n+    i, j = symbols('i j', integer=True)\n+    M = MatrixSymbol('M', n, n)\n+\n+    with assuming(Query.orthogonal(M)):\n+        e = refine((M.T * M).doit())\n+\n+    # Assert sum of diagonal elements is n\n+    sum_diag = Sum(e[i, i], (i, 0, n-1)).doit()\n+    assert sum_diag == n\n+\n+    # This should assert the total sum as 'n'\n+    total_sum = Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit()\n+    assert total_sum == n\n+\n+def test_numeric_identity_sum():\n+    # Numeric test: Test with a concrete Identity matrix n=3\n+    n = 3\n+    In = Identity(n)\n+\n+    sum_diag_numeric = Sum(In[i, i], (i, 0, n-1)).doit()\n+    assert sum_diag_numeric == n\n \n-def test_Identity_doit():\n+    total_sum_numeric = Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).doit()\n+    assert total_sum_numeric == n\n     Inn = Identity(Add(n, n, evaluate=False))\n     assert isinstance(Inn.rows, Add)\n     assert Inn.doit() == Identity(2*n)\n",
  "sympy__sympy-20049": "diff --git a/sympy/physics/vector/point.py b/sympy/physics/vector/point.py\nindex b711aa3..ae86cb1 100644\n--- a/sympy/physics/vector/point.py\n+++ b/sympy/physics/vector/point.py\n@@ -486,15 +486,41 @@ class Point(object):\n         5*N.x + 10*q'*B.y\n \n         \"\"\"\n-\n-        _check_frame(outframe)\n-        _check_frame(fixedframe)\n-        self._check_point(otherpoint)\n-        dist = self.pos_from(otherpoint)\n-        v = otherpoint.vel(outframe)\n-        omega = fixedframe.ang_vel_in(outframe)\n-        self.set_vel(outframe, v + (omega ^ dist))\n-        return self.vel(outframe)\n+from sympy import symbols\n+from sympy import dynamicsymbols\n+from sympy.physics.vector import ReferenceFrame, Point\n+from sympy.testing.pytest import raises\n+\n+def test_issue_velocity_calculation():\n+    t = symbols('t')\n+    q = dynamicsymbols('q')\n+    N = ReferenceFrame('N')\n+    A = ReferenceFrame('A')\n+    \n+    # Define Points\n+    P = Point('P')\n+    Q = Point('Q')\n+    R = Point('R')\n+    \n+    # Define Position\n+    Q.set_pos(P, q * N.x + 2 * q * N.y)\n+    R.set_pos(Q, q * N.y)\n+    \n+    # Set P velocity in N\n+    P.set_vel(N, q.diff(t) * N.x)\n+\n+    # Now ensure Q velocity in N gets appropriately calculated\n+    assert Q.vel(N) == (q.diff(t)) * N.x + 2 * q.diff(t) * N.y\n+    \n+    # Set A as another frame, orient it to N\n+    A.orient(N, 'Axis', (q, N.z))\n+    \n+    # Set R velocity in Q\n+    R.set_vel(Q, q.diff(t) * A.y)\n+    \n+    # Check R velocity in N considering orientation\n+    expected_velocity = (q.diff(t)) * N.x + (2 * q.diff(t) + q.diff(t) * A.y).express(N)\n+    assert R.vel(N).simplify() == expected_velocity.simplify()\n \n     def vel(self, frame):\n         \"\"\"The velocity Vector of this Point in the ReferenceFrame.\n",
  "sympy__sympy-21612": "diff --git a/sympy/parsing/tests/test_latex.py b/sympy/parsing/tests/test_latex.py\nindex b252985..0246de9 100644\n--- a/sympy/parsing/tests/test_latex.py\n+++ b/sympy/parsing/tests/test_latex.py\n@@ -245,6 +245,13 @@ GOOD_PAIRS = [\n     (r\"5^0 - 4^0\", _Add(_Pow(5, 0), _Mul(-1, _Pow(4, 0)))),\n ]\n \n+def test_fraction_parsing_issue():\n+    from sympy.parsing.latex import parse_latex\n+    expr_str = '\\\\frac{\\\\frac{a^3+b}{c}}{\\\\frac{1}{c^2}}'\n+    expected = ((a**3 + b)/c)/(1/(c**2))\n+    result = parse_latex(expr_str)\n+    assert result == expected, f\"Expected {expected} but got {result}\"\n+\n \n def test_parseable():\n     from sympy.parsing.latex import parse_latex\n"
}