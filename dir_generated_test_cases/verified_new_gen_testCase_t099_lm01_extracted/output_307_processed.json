{
  "astropy__astropy-12907": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 88711b0..9d1df26 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -49,6 +49,13 @@ compound_models = {\n             (np.array([False, False]),\n              np.array([[True], [True]]))\n             ),\n+    'nested_compound_model': (m.Pix2Sky_TAN() & (m.Linear1D(10) & m.Linear1D(5)),\n+             (np.array([False, False, True, True]),\n+              np.array([[True,  True, False, False],\n+                        [True,  True, False, False],\n+                        [False, False,  True,  True],\n+                        [False, False,  True,  True]]))\n+            ),\n     'cm7': (map2 | p2 & sh1,\n             (np.array([False, True]),\n              np.array([[True, False], [False, True]]))\n",
  "astropy__astropy-13236": "",
  "astropy__astropy-13453": "",
  "astropy__astropy-13579": "",
  "astropy__astropy-14096": "",
  "astropy__astropy-14309": "diff --git a/astropy/io/fits/tests/test_connect.py b/astropy/io/fits/tests/test_connect.py\nindex 00deafe..e528220 100644\n--- a/astropy/io/fits/tests/test_connect.py\n+++ b/astropy/io/fits/tests/test_connect.py\n@@ -1,3 +1,4 @@\n+\n import gc\n import warnings\n \n@@ -7,7 +8,16 @@ from numpy.testing import assert_allclose, assert_array_equal\n \n from astropy import units as u\n from astropy.io import fits\n-from astropy.io.fits import BinTableHDU, HDUList, ImageHDU, PrimaryHDU, table_to_hdu\n+from astropy.io.fits import (\n+    BinTableHDU,\n+    HDUList,\n+    ImageHDU,\n+    PrimaryHDU,\n+    table_to_hdu,\n+    connect,\n+)\n+from astropy.io.registry import identify_format\n+from astropy.table import Table\n from astropy.io.fits.column import (\n     _fortran_to_python_format,\n     _parse_tdisp_format,\n",
  "astropy__astropy-14508": "diff --git a/astropy/io/fits/tests/test_header.py b/astropy/io/fits/tests/test_header.py\nindex 6bdf92c..a931137 100644\n--- a/astropy/io/fits/tests/test_header.py\n+++ b/astropy/io/fits/tests/test_header.py\n@@ -144,6 +144,35 @@ class TestHeaderFunctions(FitsTestCase):\n         f1 = _pad(\"ABC     = (1.23453774378878E+88, 6.32476736476374E-15)\")\n         f2 = _pad(\"ABC     = (1.2345377437887E+088, 6.3247673647637E-015)\")\n         f3 = _pad(\"ABC     = (1.23453774378878E+88, 6.32476736476374E-15)\")\n+\n+    def test_floating_point_string_representation_card(self):\n+        \"\"\"Ensures Card formats float values with the correct precision, avoiding comment truncation.\"\"\"\n+\n+        # Test regression scenario for the given issue\n+        k = \"HIERARCH ABC DEF GH IJKLMN\"\n+        com = \"[m] abcdef ghijklm nopqrstu vw xyzab\"\n+        c = fits.Card(k, 0.009125, com)\n+        expected_str = f\"{k} = 0.009125 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        c = fits.Card(k, 8.95, com)\n+        expected_str = f\"{k} = 8.95 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        c = fits.Card(k, -99.9, com)\n+        expected_str = f\"{k} = -99.9 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        # Additional test with edge float values and comments\n+        large_float = 1234567890.123456789\n+        c = fits.Card(k, large_float, com)\n+        expected_str = f\"{k} = {large_float:.9g} / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        small_float = 1.23456789e-10\n+        c = fits.Card(k, small_float, com)\n+        expected_str = f\"{k} = {small_float:.9g} / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n         if str(c) != f1 and str(c) != f2:\n             assert str(c) == f3\n \n",
  "astropy__astropy-14539": "",
  "astropy__astropy-14995": "",
  "astropy__astropy-7166": "diff --git a/astropy/utils/tests/test_misc.py b/astropy/utils/tests/test_misc.py\nindex 77667e4..2cbaf8e 100644\n--- a/astropy/utils/tests/test_misc.py\n+++ b/astropy/utils/tests/test_misc.py\n@@ -88,6 +88,23 @@ def test_inherit_docstrings():\n         # TODO: Maybe if __doc__ is None this test should be skipped instead?\n         assert Subclass.__call__.__doc__ == \"FOO\"\n \n+    # Additional test for property inheritance\n+    class BaseWithProperty(metaclass=misc.InheritDocstrings):\n+        @property\n+        def bar(self):\n+            \"BAR\"\n+            return 0\n+\n+    class SubclassWithProperty(BaseWithProperty):\n+        @property\n+        def bar(self):\n+            return 42\n+\n+    if BaseWithProperty.bar.__doc__ is not None:\n+        assert SubclassWithProperty.bar.__doc__ == \"BAR\"\n+        # TODO: Maybe if __doc__ is None this test should be skipped instead?\n+        assert Subclass.__call__.__doc__ == \"FOO\"\n+\n \n def test_set_locale():\n     # First, test if the required locales are available\n",
  "astropy__astropy-7336": "",
  "astropy__astropy-7606": "diff --git a/astropy/units/tests/test_units.py b/astropy/units/tests/test_units.py\nindex d95b776..32b87f2 100644\n--- a/astropy/units/tests/test_units.py\n+++ b/astropy/units/tests/test_units.py\n@@ -197,6 +197,12 @@ def test_unknown_unit3():\n     with pytest.raises(TypeError):\n         unit5 = u.Unit(None)\n \n+    ## New test cases for checking equality with None\n+    unit_none = u.Unit(\"asdf\", parse_strict='silent')\n+    assert unit_none != None  # noqa: E711\n+    assert not (unit_none == None)  # noqa: E711\n+    assert unit_none not in (None, u.m)\n+\n \n @raises(TypeError)\n def test_invalid_scale():\n",
  "astropy__astropy-7671": "diff --git a/astropy/utils/tests/test_introspection.py b/astropy/utils/tests/test_introspection.py\nindex 852d721..b7746bf 100644\n--- a/astropy/utils/tests/test_introspection.py\n+++ b/astropy/utils/tests/test_introspection.py\n@@ -63,7 +63,33 @@ def test_find_mod_objs():\n     assert namedtuple not in objs\n \n \n+from distutils.version import LooseVersion\n+\n def test_minversion():\n+    # Special test modules for testing version comparison\n+    test_module_special1 = ModuleType(str(\"test_module_special1\"))\n+    test_module_special1.__version__ = '1.14.3'\n+    \n+    test_module_special2 = ModuleType(str(\"test_module_special2\"))\n+    test_module_special2.__version__ = '1.14dev'\n+\n+    good_versions_special1 = ['1.14', '1.14.1', '1.14.3']\n+    bad_versions_special1 = ['1.15', '1.14.4', '2.0']\n+    \n+    good_versions_special2 = ['1.10', '1.14dev']\n+    bad_versions_special2 = ['1.14', '1.14.1', '1.15']\n+\n+    # Test the first special module\n+    for version in good_versions_special1:\n+        assert minversion(test_module_special1, version), f\"Expected {test_module_special1.__version__} to be >= {version}\"\n+    for version in bad_versions_special1:\n+        assert not minversion(test_module_special1, version), f\"Expected {test_module_special1.__version__} not to be >= {version}\"\n+    \n+    # Test the second special module\n+    for version in good_versions_special2:\n+        assert minversion(test_module_special2, version), f\"Expected {test_module_special2.__version__} to be >= {version}\"\n+    for version in bad_versions_special2:\n+        assert not minversion(test_module_special2, version), f\"Expected {test_module_special2.__version__} not to be >= {version}\"\n     from types import ModuleType\n     test_module = ModuleType(str(\"test_module\"))\n     test_module.__version__ = '0.12.2'\n@@ -72,4 +98,4 @@ def test_minversion():\n     for version in good_versions:\n         assert minversion(test_module, version)\n     for version in bad_versions:\n-        assert not minversion(test_module, version)\n+        assert not minversion(test_module, version)\n",
  "astropy__astropy-8707": "diff --git a/astropy/io/fits/tests/test_header.py b/astropy/io/fits/tests/test_header.py\nindex a2103c6..a9cdb78 100644\n--- a/astropy/io/fits/tests/test_header.py\n+++ b/astropy/io/fits/tests/test_header.py\n@@ -79,6 +79,50 @@ class TestHeaderFunctions(FitsTestCase):\n         assert header['B'] == 'B'\n         assert header.comments['B'] == 'C'\n \n+    def test_card_from_bytes(self):\n+        \"\"\"\n+        Test loading a Card from a `bytes` object (assuming latin-1 encoding).\n+        \"\"\"\n+\n+        c = fits.Card.fromstring(b\"ABC     = 'abc'\")\n+        assert c.keyword == 'ABC'\n+        assert c.value == 'abc'\n+\n+    def test_header_fromstring_bytes(self):\n+        \"\"\"\n+        Test reading a Header from a `bytes` string.\n+\n+        See https://github.com/astropy/astropy/issues/8706\n+        \"\"\"\n+\n+        with open(self.data('test0.fits'), 'rb') as fobj:\n+            pri_hdr_from_bytes = fits.Header.fromstring(fobj.read())\n+\n+        pri_hdr = fits.getheader(self.data('test0.fits'))\n+        assert pri_hdr['NAXIS'] == pri_hdr_from_bytes['NAXIS']\n+        assert pri_hdr == pri_hdr_from_bytes\n+        assert pri_hdr.tostring() == pri_hdr_from_bytes.tostring()\n+\n+    def test_header_fromstring_bytes_with_sep(self):\n+        \"\"\"\n+        Test Header.fromstring with bytes data and a specified separator.\n+        \"\"\"\n+\n+        header_bytes = b\"SIMPLE  = T                    / Standard FITS file\\nEND\" + b\" \" * (2880 - 80)\n+        header_as_str = header_bytes.decode('ascii')\n+        hdr_from_bytes = fits.Header.fromstring(header_bytes, sep='\\n')\n+        hdr_from_str = fits.Header.fromstring(header_as_str, sep='\\n')\n+        assert hdr_from_bytes == hdr_from_str\n+\n+    def test_header_fromstring_unicode(self):\n+        \"\"\"\n+        Test Header.fromstring with unicode string input.\n+        \"\"\"\n+\n+        header_str = \"SIMPLE  = T                    / Standard FITS file\\nEND\" + \" \" * (2880 - 80)\n+        hdr_from_unicode = fits.Header.fromstring(header_str, sep='\\n')\n+        assert hdr_from_unicode['SIMPLE'] is True\n+\n     def test_card_constructor_default_args(self):\n         \"\"\"Test Card constructor with default argument values.\"\"\"\n \n",
  "astropy__astropy-8872": "diff --git a/astropy/units/tests/test_quantity.py b/astropy/units/tests/test_quantity.py\nindex 283420f..ca86e44 100644\n--- a/astropy/units/tests/test_quantity.py\n+++ b/astropy/units/tests/test_quantity.py\n@@ -143,6 +143,9 @@ class TestQuantityCreation:\n         q3 = u.Quantity(a3, u.yr)\n         assert q3.dtype == a3.dtype\n         # items stored as objects by numpy should be converted to float\n+        a3_16 = np.array([1., 2.], dtype=np.float16)\n+        q3_16 = u.Quantity(a3_16, u.yr)\n+        assert q3_16.dtype == a3_16.dtype\n         # by default\n         q4 = u.Quantity(decimal.Decimal('10.25'), u.m)\n         assert q4.dtype == float\n",
  "django__django-10097": "diff --git a/tests/validators/tests.py b/tests/validators/tests.py\nindex 90c3285..b5458ac 100644\n--- a/tests/validators/tests.py\n+++ b/tests/validators/tests.py\n@@ -225,6 +225,19 @@ TEST_DATA = [\n     (URLValidator(), 'http://www.asdasdasdasdsadfm.com.br ', ValidationError),\n     (URLValidator(), 'http://www.asdasdasdasdsadfm.com.br z', ValidationError),\n \n+    (URLValidator(), 'http://foo@bar@example.com', ValidationError),\n+    (URLValidator(), 'http://foo/bar@example.com', ValidationError),\n+    (URLValidator(), 'http://foo:bar:baz@example.com', ValidationError),\n+    (URLValidator(), 'http://foo:bar@baz@example.com', ValidationError),\n+    (URLValidator(), 'http://foo:bar/baz@example.com', ValidationError),\n+    (URLValidator(), 'http://invalid-.com/?m=foo@example.com', ValidationError),\n+    (URLValidator(), \"http://-.~_!$&'()*+,;=%40:80%2f@example.com\", ValidationError),\n+\n+    # Valid cases where the characters are properly encoded\n+    (URLValidator(), 'http://foo%40bar@example.com', None),\n+    (URLValidator(), 'http://foo%2Fbar@example.com', None),\n+    (URLValidator(), 'http://foo%3Abar@example.com', None),\n+\n     (BaseValidator(True), True, None),\n     (BaseValidator(True), False, ValidationError),\n \n",
  "django__django-10880": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex 491ba54..d4ce2a6 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from decimal import Decimal\n@@ -8,6 +9,7 @@ from django.db.models import (\n     Avg, Count, DecimalField, DurationField, F, FloatField, Func, IntegerField,\n     Max, Min, Sum, Value,\n )\n+from django.db.models.expressions import Case, When\n from django.test import TestCase\n from django.test.utils import Approximate, CaptureQueriesContext\n from django.utils import timezone\n@@ -389,7 +391,22 @@ class AggregateTestCase(TestCase):\n         vals = Book.objects.aggregate(Count(\"rating\", distinct=True))\n         self.assertEqual(vals, {\"rating__count\": 4})\n \n-    def test_count_star(self):\n+    def test_count_distinct_expression(self):\n+        aggs = Book.objects.aggregate(\n+            distinct_ratings=Count(Case(When(pages__gt=300, then='rating')), distinct=True),\n+        )\n+        self.assertEqual(aggs['distinct_ratings'], 4)\n+\n+    def test_count_distinct_expression_multiple_conditions(self):\n+        # Test with multiple conditions to ensure the query doesn't break\n+        aggs = Book.objects.aggregate(\n+            distinct_ratings=Count(Case(\n+                When(pages__gt=300, then='rating'),\n+                When(pages__lt=100, then='rating')\n+            ), distinct=True),\n+        )\n+        # Assuming expected distinct ratings for the books with above filters\n+        self.assertEqual(aggs['distinct_ratings'], 5)\n         with self.assertNumQueries(1) as ctx:\n             Book.objects.aggregate(n=Count(\"*\"))\n         sql = ctx.captured_queries[0]['sql']\n",
  "django__django-10914": "diff --git a/tests/file_uploads/tests.py b/tests/file_uploads/tests.py\nindex edc5fba..bc7bc00 100644\n--- a/tests/file_uploads/tests.py\n+++ b/tests/file_uploads/tests.py\n@@ -15,6 +15,10 @@ from django.http.multipartparser import (\n )\n from django.test import SimpleTestCase, TestCase, client, override_settings\n \n+import os\n+from django.conf import settings\n+from django.test import override_settings\n+from django.core.files.storage import default_storage\n from . import uploadhandler\n from .models import FileModel\n \n@@ -45,7 +49,52 @@ class FileUploadTests(TestCase):\n             response = self.client.post('/upload/', post_data)\n         self.assertEqual(response.status_code, 200)\n \n-    def test_large_upload(self):\n+    def test_upload_with_default_permissions(self):\n+        \"\"\"\n+        Test that the uploaded file has default permissions of 0o644.\n+        \"\"\"\n+        file = tempfile.NamedTemporaryFile(delete=False)\n+        try:\n+            file.write(b'some data')\n+            file.seek(0)\n+            response = self.client.post('/upload/', {'file_field': file})\n+\n+            self.assertEqual(response.status_code, 200)\n+\n+            uploaded_file_name = response.json().get('file_field_name', None)\n+            self.assertIsNotNone(uploaded_file_name)\n+            \n+            # Check if the file has been uploaded with 644 permissions\n+            uploaded_file_path = os.path.join(settings.MEDIA_ROOT, uploaded_file_name)\n+            file_permissions = os.stat(uploaded_file_path).st_mode & 0o777\n+            self.assertEqual(file_permissions, 0o644)\n+        finally:\n+            file.close()\n+            os.unlink(file.name)\n+    \n+    @override_settings(FILE_UPLOAD_PERMISSIONS=0o600)\n+    def test_upload_with_custom_permissions(self):\n+        \"\"\"\n+        Test that the uploaded file respects the custom FILE_UPLOAD_PERMISSIONS setting.\n+        \"\"\"\n+        file = tempfile.NamedTemporaryFile(delete=False)\n+        try:\n+            file.write(b'some data')\n+            file.seek(0)\n+            response = self.client.post('/upload/', {'file_field': file})\n+\n+            self.assertEqual(response.status_code, 200)\n+\n+            uploaded_file_name = response.json().get('file_field_name', None)\n+            self.assertIsNotNone(uploaded_file_name)\n+            \n+            # Check if the file has been uploaded with 600 permissions\n+            uploaded_file_path = os.path.join(settings.MEDIA_ROOT, uploaded_file_name)\n+            file_permissions = os.stat(uploaded_file_path).st_mode & 0o777\n+            self.assertEqual(file_permissions, 0o600)\n+        finally:\n+            file.close()\n+            os.unlink(file.name)\n         file = tempfile.NamedTemporaryFile\n         with file(suffix=\".file1\") as file1, file(suffix=\".file2\") as file2:\n             file1.write(b'a' * (2 ** 21))\n",
  "django__django-10973": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex 9eb05c7..84dcd78 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -1,12 +1,60 @@\n+\n import os\n import signal\n+import subprocess\n from unittest import mock\n \n from django.db.backends.postgresql.client import DatabaseClient\n from django.test import SimpleTestCase\n \n-\n class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n+    def _run_it_with_pgpassword(self, dbinfo):\n+        \"\"\"\n+        This function tests the runshell command with subprocess.run,\n+        verifying the usage of PGPASSWORD.\n+        \"\"\"\n+        def _mock_subprocess_run(*args, env=os.environ, **kwargs):\n+            self.subprocess_args = list(*args)\n+            self.pgpassword = env.get('PGPASSWORD')\n+            return subprocess.CompletedProcess(self.subprocess_args, 0)\n+\n+        self.subprocess_args = None\n+        self.pgpassword = None\n+        with mock.patch('subprocess.run', new=_mock_subprocess_run):\n+            DatabaseClient.runshell_db(dbinfo)\n+        return self.subprocess_args, self.pgpassword\n+\n+    def test_with_pgpassword_basic(self):\n+        args, pgpassword = self._run_it_with_pgpassword({\n+            'database': 'dbname',\n+            'user': 'someuser',\n+            'password': 'somepassword',\n+            'host': 'somehost',\n+            'port': '444',\n+        })\n+        self.assertEqual(args, ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'])\n+        self.assertEqual(pgpassword, 'somepassword')\n+\n+    def test_with_pgpassword_nopass(self):\n+        args, pgpassword = self._run_it_with_pgpassword({\n+            'database': 'dbname',\n+            'user': 'someuser',\n+            'host': 'somehost',\n+            'port': '444',\n+        })\n+        self.assertEqual(args, ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'])\n+        self.assertIsNone(pgpassword)\n+\n+    def test_with_pgpassword_special_chars(self):\n+        args, pgpassword = self._run_it_with_pgpassword({\n+            'database': 'dbname',\n+            'user': 'some:user',\n+            'password': 'some:password',\n+            'host': 'somehost',\n+            'port': '444',\n+        })\n+        self.assertEqual(args, ['psql', '-U', 'some:user', '-h', 'somehost', '-p', '444', 'dbname'])\n+        self.assertEqual(pgpassword, 'some:password')\n \n     def _run_it(self, dbinfo):\n         \"\"\"\n@@ -113,4 +161,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         with mock.patch('subprocess.check_call', new=_mock_subprocess_call):\n             DatabaseClient.runshell_db({})\n         # dbshell restores the original handler.\n-        self.assertEqual(sigint_handler, signal.getsignal(signal.SIGINT))\n+        self.assertEqual(sigint_handler, signal.getsignal(signal.SIGINT))\n",
  "django__django-11066": "diff --git a/tests/contenttypes_tests/test_operations.py b/tests/contenttypes_tests/test_operations.py\nindex ff1d778..e8e02ed 100644\n--- a/tests/contenttypes_tests/test_operations.py\n+++ b/tests/contenttypes_tests/test_operations.py\n@@ -3,6 +3,7 @@ from django.conf import settings\n from django.contrib.contenttypes import management as contenttypes_management\n from django.contrib.contenttypes.models import ContentType\n from django.core.management import call_command\n+from django.contrib.contenttypes.models import ContentType\n from django.db import migrations, models\n from django.test import TransactionTestCase, override_settings\n \n@@ -47,7 +48,29 @@ class ContentTypeOperationsTests(TransactionTestCase):\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='foo').exists())\n         self.assertFalse(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n \n-    def test_missing_content_type_rename_ignore(self):\n+    def test_existing_content_type_rename_other_database(self):\n+        # Setup TestRouter to route the writing database operations to 'other'\n+        class TestRouter:\n+            def db_for_write(self, model, **hints):\n+                return 'other'\n+\n+        with override_settings(DATABASE_ROUTERS=[TestRouter()]):\n+            ContentType.objects.using('other').create(app_label='contenttypes_tests', model='foo')\n+            other_content_types = ContentType.objects.using('other').filter(app_label='contenttypes_tests')\n+\n+            # Run migrate command on 'other' database\n+            call_command('migrate', 'contenttypes_tests', database='other', interactive=False, verbosity=0)\n+\n+            # The content type 'foo' should be renamed to 'renamedfoo' in 'other' database\n+            self.assertFalse(other_content_types.filter(model='foo').exists())\n+            self.assertTrue(other_content_types.filter(model='renamedfoo').exists())\n+\n+            # Revert migrations\n+            call_command('migrate', 'contenttypes_tests', 'zero', database='other', interactive=False, verbosity=0)\n+\n+            # The content type should revert to 'foo'\n+            self.assertTrue(other_content_types.filter(model='foo').exists())\n+            self.assertFalse(other_content_types.filter(model='renamedfoo').exists())\n         call_command('migrate', 'contenttypes_tests', database='default', interactive=False, verbosity=0,)\n         self.assertFalse(ContentType.objects.filter(app_label='contenttypes_tests', model='foo').exists())\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n@@ -63,4 +86,4 @@ class ContentTypeOperationsTests(TransactionTestCase):\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n         call_command('migrate', 'contenttypes_tests', 'zero', database='default', interactive=False, verbosity=0)\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='foo').exists())\n-        self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n+        self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n",
  "django__django-11095": "diff --git a/tests/generic_inline_admin/tests.py b/tests/generic_inline_admin/tests.py\nindex 9dd9fd9..533ca44 100644\n--- a/tests/generic_inline_admin/tests.py\n+++ b/tests/generic_inline_admin/tests.py\n@@ -425,7 +425,30 @@ class GenericInlineModelAdminTest(SimpleTestCase):\n             inlines = [\n                 AlternateInline, MediaInline\n             ]\n+        class CustomInline1(GenericTabularInline):\n+            model = Media\n+\n+        class CustomInline2(GenericTabularInline):\n+            model = Media\n+\n+        class NewEpisodeAdmin(admin.ModelAdmin):\n+            inlines = [CustomInline1, CustomInline2]\n+\n+            def get_inlines(self, request, obj=None):\n+                if request.user.is_superuser:\n+                    return self.inlines\n+                return self.inlines[:1]\n+\n         ma = EpisodeAdmin(Episode, self.site)\n+        request.user = AnonymousUser()\n+        self.assertEqual(ma.get_inlines(request), [])\n+\n+        new_ma = NewEpisodeAdmin(Episode, self.site)\n+        self.assertEqual(new_ma.get_inlines(request), [CustomInline1])\n+        \n+        request.user = SuperUser()  # Assuming SuperUser is defined as a superuser mock\n+        self.assertEqual(new_ma.get_inlines(request), [CustomInline1, CustomInline2])\n+\n         inlines = ma.get_inline_instances(request)\n         for (formset, inline), other_inline in zip(ma.get_formsets_with_inlines(request), inlines):\n-            self.assertIsInstance(formset, other_inline.get_formset(request).__class__)\n+            self.assertIsInstance(formset, other_inline.get_formset(request).__class__)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..7600112 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -233,6 +233,13 @@ class NumericPasswordValidatorTest(SimpleTestCase):\n \n class UsernameValidatorsTests(SimpleTestCase):\n     def test_unicode_validator(self):\n+        # Test for trailing newlines, should be invalid\n+        invalid_usernames_with_newline = ['validname\\n', 'user\\n']\n+        v = validators.UnicodeUsernameValidator()\n+        for invalid in invalid_usernames_with_newline:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n         valid_usernames = ['joe', 'Ren\u00e9', '\u1d2e\u1d35\u1d33\u1d2e\u1d35\u1d3f\u1d30', '\u0623\u062d\u0645\u062f']\n         invalid_usernames = [\n             \"o'connell\", \"\u0639\u0628\u062f \u0627\u0644\",\n@@ -249,6 +256,13 @@ class UsernameValidatorsTests(SimpleTestCase):\n                     v(invalid)\n \n     def test_ascii_validator(self):\n+        # Test for trailing newlines, should be invalid\n+        invalid_usernames_with_newline = ['validusername\\n', 'anotheruser\\n']\n+        v = validators.ASCIIUsernameValidator()\n+        for invalid in invalid_usernames_with_newline:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n         invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n         v = validators.ASCIIUsernameValidator()\n@@ -258,4 +272,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11119": "diff --git a/tests/template_tests/test_engine.py b/tests/template_tests/test_engine.py\nindex ba32db8..addbe0d 100644\n--- a/tests/template_tests/test_engine.py\n+++ b/tests/template_tests/test_engine.py\n@@ -12,6 +12,22 @@ OTHER_DIR = os.path.join(ROOT, 'other_templates')\n \n class RenderToStringTest(SimpleTestCase):\n \n+    def test_autoescape_on(self):\n+        engine = Engine(dirs=[TEMPLATE_DIR], autoescape=True)\n+        # Assuming a template 'test_context.html' with the content: \"obj:{{ obj }}\"\n+        self.assertEqual(\n+            engine.render_to_string('test_context.html', {'obj': '<script>'}),\n+            'obj:&lt;script&gt;\\n',\n+        )\n+\n+    def test_autoescape_off(self):\n+        engine = Engine(dirs=[TEMPLATE_DIR], autoescape=False)\n+        # Assuming a template 'test_context.html' with the content: \"obj:{{ obj }}\"\n+        self.assertEqual(\n+            engine.render_to_string('test_context.html', {'obj': '<script>'}),\n+            'obj:<script>\\n',\n+        )\n+\n     def setUp(self):\n         self.engine = Engine(dirs=[TEMPLATE_DIR])\n \n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..86ea907 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -406,7 +406,9 @@ class HttpResponseTests(unittest.TestCase):\n         r.write('!')\n         self.assertEqual(r.content, b'helloworld!')\n \n-    def test_iterator_isnt_rewound(self):\n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview'))\n+        self.assertEqual(r.content, b'memoryview')\n         # Regression test for #13222\n         r = HttpResponse('abc')\n         i = iter(r)\n",
  "django__django-11141": "diff --git a/tests/migrations/test_loader.py b/tests/migrations/test_loader.py\nindex b5a87e7..ab7c194 100644\n--- a/tests/migrations/test_loader.py\n+++ b/tests/migrations/test_loader.py\n@@ -509,7 +509,25 @@ class LoaderTests(TestCase):\n         self.assertEqual(migrations, ['0001_initial'])\n \n \n-class PycLoaderTests(MigrationTestBase):\n+    def test_multiple_migrations_namespace_package(self):\n+        \"\"\"\n+        Test migration directories without an __init__.py file with multiple migrations.\n+        \"\"\"\n+        module_name = 'migrations.test_migrations_namespace_package_multiple'\n+        with self.temporary_migration_module(module=module_name) as migration_dir:\n+            # Creating additional migration file\n+            with open(os.path.join(migration_dir, '0002_auto.py'), 'w') as f:\n+                f.write('''\n+from django.db import migrations\n+\n+class Migration(migrations.Migration):\n+    dependencies = [('migrations', '0001_initial')]\n+    operations = []\n+''')\n+            loader = MigrationLoader(connection)\n+            migrations = loader.disk_migrations\n+            self.assertIn(('migrations', '0001_initial'), migrations)\n+            self.assertIn(('migrations', '0002_auto'), migrations)\n \n     def test_valid(self):\n         \"\"\"\n",
  "django__django-11149": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 296cfba..99a26c6 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -664,8 +664,32 @@ class TestInlinePermissions(TestCase):\n         self.assertNotContains(response, 'Add another Author-Book Relationship')\n         self.assertNotContains(response, 'id=\"id_Author_books-TOTAL_FORMS\"')\n         self.assertNotContains(response, 'id=\"id_Author_books-0-DELETE\"')\n+    def test_inline_add_m2m_view_only_perm(self):\n+        permission = Permission.objects.get(codename='view_book', content_type=self.book_ct)\n+        self.user.user_permissions.add(permission)\n+        response = self.client.get(reverse('admin:admin_inlines_author_add'))\n+        # View-only inlines shouldn't allow adding\n+        self.assertContains(response, '<h2>Author-book relationships</h2>', count=1)\n+        self.assertContains(\n+            response,\n+            '<input type=\"hidden\" name=\"Author_books-TOTAL_FORMS\" value=\"0\" id=\"id_Author_books-TOTAL_FORMS\">',\n+            html=True\n+        )\n+        self.assertNotContains(response, 'Add another Author-Book Relationship')\n \n-    def test_inline_change_m2m_change_perm(self):\n+    def test_inline_change_m2m_view_only_perm(self):\n+        permission = Permission.objects.get(codename='view_book', content_type=self.book_ct)\n+        self.user.user_permissions.add(permission)\n+        response = self.client.get(self.author_change_url)\n+        # View-only inlines shouldn't allow changing or deleting\n+        self.assertContains(response, '<h2>Author-book relationships</h2>', count=1)\n+        self.assertContains(\n+            response,\n+            '<input type=\"hidden\" name=\"Author_books-TOTAL_FORMS\" value=\"1\" id=\"id_Author_books-TOTAL_FORMS\">',\n+            html=True\n+        )\n+        self.assertContains(response, '<p>%s</p>' % 'The inline Book')\n+        self.assertNotContains(response, 'id=\"id_Author_books-0-DELETE\"')\n         permission = Permission.objects.get(codename='change_book', content_type=self.book_ct)\n         self.user.user_permissions.add(permission)\n         response = self.client.get(self.author_change_url)\n",
  "django__django-11163": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex b25d077..49205f0 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2898,8 +2898,19 @@ class StrictAssignmentTests(SimpleTestCase):\n             'title': ['This field cannot be blank.']\n         })\n \n+from django.test import TestCase\n+from django.forms.models import model_to_dict\n+from .models import BetterWriter, Colour, ColourfulItem\n \n class ModelToDictTests(TestCase):\n+    \n+    def test_model_to_dict_empty_fields(self):\n+        \"\"\"model_to_dict should return an empty dict when fields=[]\"\"\"\n+        bw = BetterWriter.objects.create(name='Joe Better', score=10)\n+        self.assertEqual(model_to_dict(bw, fields=[]), {})\n+        self.assertEqual(model_to_dict(bw, fields=['id', 'name']), {'id': bw.id, 'name': 'Joe Better'})\n+        self.assertEqual(model_to_dict(bw, exclude=[]), {'id': bw.id, 'name': 'Joe Better', 'score': 10, 'writer_ptr': bw.writer_ptr_id})\n+        self.assertEqual(model_to_dict(bw, exclude=['id', 'name']), {'score': 10, 'writer_ptr': bw.writer_ptr_id})\n     def test_many_to_many(self):\n         \"\"\"Data for a ManyToManyField is a list rather than a lazy QuerySet.\"\"\"\n         blue = Colour.objects.create(name='blue')\n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..414e0e5 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,9 +1,11 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n+from django.db.models.deletion import Collector\n from .models import (\n     MR, A, Avatar, Base, Child, HiddenUser, HiddenUserProfile, M, M2MFrom,\n     M2MTo, MRNull, Parent, R, RChild, S, T, User, create_a, get_default_r,\n@@ -464,7 +466,29 @@ class FastDeleteTests(TestCase):\n         # 1 to delete t, 1 to fast-delete t's m_set\n         self.assertNumQueries(2, f.delete)\n \n-    def test_fast_delete_qs(self):\n+    def test_fast_delete_instance_set_pk_none(self):\n+        u = User.objects.create()\n+        # User can be fast-deleted.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        u.delete()\n+        # Verify that the primary key is set to None after delete\n+        self.assertIsNone(u.pk)\n+\n+    def test_fast_delete_instance_with_no_relation(self):\n+        user_no_relation = HiddenUser.objects.create()\n+        # Ensure there are no dependencies\n+        self.assertEqual(user_no_relation.profile_set.count(), 0)\n+        user_no_relation.delete()\n+        # Verify that the primary key is set to None\n+        self.assertIsNone(user_no_relation.pk)\n+\n+    def test_fast_delete_instance_with_fk(self):\n+        avatar = Avatar.objects.create(desc='avatar')\n+        user_with_fk = User.objects.create(avatar=avatar)\n+        user_with_fk.delete()\n+        # Verify that the primary key is set to None even with FK\n+        self.assertIsNone(user_with_fk.pk)\n         u1 = User.objects.create()\n         u2 = User.objects.create()\n         self.assertNumQueries(1, User.objects.filter(pk=u1.pk).delete)\n",
  "django__django-11206": "",
  "django__django-11211": "diff --git a/tests/prefetch_related/tests.py b/tests/prefetch_related/tests.py\nindex 1dc206f..86a2460 100644\n--- a/tests/prefetch_related/tests.py\n+++ b/tests/prefetch_related/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.contrib.contenttypes.models import ContentType\n from django.core.exceptions import ObjectDoesNotExist\n from django.db import connection\n@@ -13,8 +14,34 @@ from .models import (\n     Room, TaggedItem, Teacher, WordEntry,\n )\n \n+from django.contrib.contenttypes.fields import GenericForeignKey\n+from django.contrib.contenttypes.models import ContentType\n+from django.db import models\n+import uuid\n+\n+class Foo(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n+    name = models.CharField(max_length=20)\n+\n+class Bar(models.Model):\n+    foo_content_type = models.ForeignKey(\n+        ContentType, related_name='actor',\n+        on_delete=models.CASCADE, db_index=True\n+    )\n+    foo_object_id = models.CharField(max_length=255, db_index=True)\n+    foo = GenericForeignKey('foo_content_type', 'foo_object_id')\n+\n+class FooBarTests(TestCase):\n+    def setUp(self):\n+        self.foo = Foo.objects.create(name=\"TestFoo\")\n+        content_type = ContentType.objects.get_for_model(Foo)\n+        Bar.objects.create(foo_content_type=content_type, foo_object_id=self.foo.pk)\n \n-class TestDataMixin:\n+    def test_prefetch_related_with_uuid_pk(self):\n+        # This test verifies if prefetch_related works for a model with UUID PK and GFK\n+        with self.assertNumQueries(2):\n+            bars = list(Bar.objects.prefetch_related('foo'))\n+            self.assertEqual([b.foo for b in bars], [self.foo])\n     @classmethod\n     def setUpTestData(cls):\n         cls.book1 = Book.objects.create(title='Poems')\n",
  "django__django-11239": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex b843072..3337eda 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -81,7 +81,25 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             )\n         )\n \n-    def test_sigint_handler(self):\n+    def test_ssl_certificate(self):\n+        \"\"\"\n+        Test dbshell command with SSL certificate parameters.\n+        \"\"\"\n+        self.assertEqual(\n+            self._run_it({\n+                'database': 'dbname',\n+                'user': 'someuser',\n+                'host': 'somehost',\n+                'port': '444',\n+                'sslmode': 'verify-ca',\n+                'sslrootcert': 'root.crt',\n+                'sslcert': 'client.crt',\n+                'sslkey': 'client.key',\n+            }), (\n+                ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'],\n+                'some:password',\n+            )\n+        )\n         \"\"\"SIGINT is ignored in Python and passed to psql to abort quries.\"\"\"\n         def _mock_subprocess_run(*args, **kwargs):\n             handler = signal.getsignal(signal.SIGINT)\n",
  "django__django-11265": "diff --git a/tests/filtered_relation/tests.py b/tests/filtered_relation/tests.py\nindex a587c22..a5e2bd2 100644\n--- a/tests/filtered_relation/tests.py\n+++ b/tests/filtered_relation/tests.py\n@@ -98,7 +98,23 @@ class FilteredRelationTests(TestCase):\n             [self.author1]\n         )\n \n-    def test_with_join_and_complex_condition(self):\n+    def test_with_exclude(self):\n+        # Verifying that excluding with an annotated FilteredRelation doesn't cause a FieldError.\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).exclude(book_alice__isnull=False),\n+            [self.author2],\n+        )\n+\n+    def test_exclude_on_different_conditions(self):\n+        # Test the exclude with different conditions on the FilteredRelation.\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).exclude(book_alice__isnull=True),\n+            [self.author1],\n+        )\n         self.assertSequenceEqual(\n             Author.objects.annotate(\n                 book_alice=FilteredRelation(\n",
  "django__django-11276": "",
  "django__django-11292": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex b016284..a61643d 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -243,7 +243,26 @@ class CommandRunTests(AdminScriptTestCase):\n         self.assertNoOutput(err)\n         self.assertEqual(out.strip(), '/PREFIX/some/url/')\n \n-    def test_disallowed_abbreviated_options(self):\n+    def test_skip_checks(self):\n+        \"\"\"\n+        Test that the --skip-checks option correctly prevents system checks from running.\n+        \"\"\"\n+        self.write_settings('settings.py', apps=['django.contrib.staticfiles', 'user_commands'], sdict={\n+            'STATICFILES_DIRS': '\"foo\"',\n+        })\n+        out, err = self.run_manage(['set_option', '--skip-checks', '--set', 'foo'])\n+        self.assertNoOutput(err)\n+        self.assertEqual(out.strip(), 'Set foo')\n+\n+    def test_without_skip_checks(self):\n+        \"\"\"\n+        Test that the system checks are run when --skip-checks is not used.\n+        \"\"\"\n+        self.write_settings('settings.py', apps=['django.contrib.staticfiles', 'user_commands'], sdict={\n+            'STATICFILES_DIRS': '\"foo\"',\n+        })\n+        out, err = self.run_manage(['set_option', '--set', 'foo'])\n+        self.assertIn('staticfiles.E001', err)\n         \"\"\"\n         To avoid conflicts with custom options, commands don't allow\n         abbreviated forms of the --setting and --pythonpath options.\n",
  "django__django-11333": "diff --git a/tests/urlpatterns/test_resolvers.py b/tests/urlpatterns/test_resolvers.py\nindex a9c1edd..c463d61 100644\n--- a/tests/urlpatterns/test_resolvers.py\n+++ b/tests/urlpatterns/test_resolvers.py\n@@ -1,5 +1,7 @@\n+\n from django.test import SimpleTestCase\n-from django.urls.resolvers import RegexPattern, RoutePattern\n+from django.urls.resolvers import RegexPattern, RoutePattern, get_resolver\n+from django.test.utils import override_settings\n from django.utils.translation import gettext_lazy as _\n \n \n@@ -12,4 +14,37 @@ class RegexPatternTests(SimpleTestCase):\n class RoutePatternTests(SimpleTestCase):\n \n     def test_str(self):\n-        self.assertEqual(str(RoutePattern(_('translated/'))), 'translated/')\n+        self.assertEqual(str(RoutePattern(_('translated/'))), 'translated/')\n+\n+class ResolverCacheTests(SimpleTestCase):\n+\n+    @override_settings(ROOT_URLCONF='urlpatterns.path_urls')\n+    def test_resolver_cache_default_root_urlconf(self):\n+        # resolver for a default URLconf (passing no argument) and for the\n+        # settings.ROOT_URLCONF is the same cached object.\n+        self.assertIs(get_resolver(), get_resolver('urlpatterns.path_urls'))\n+        self.assertIsNot(get_resolver(), get_resolver('urlpatterns.path_dynamic_urls'))\n+\n+    def test_resolver_cache_different_urlconf_before_request(self):\n+        # Test to ensure that calling get_resolver with different URLconfs before set_urlconf() \n+        # doesn't cache incorrect results.\n+        first_call = get_resolver('urlpatterns.path_urls')\n+        second_call = get_resolver('urlpatterns.path_dynamic_urls')\n+        self.assertIsNot(first_call, second_call)\n+\n+    @override_settings(ROOT_URLCONF='urlpatterns.another_path_urls')\n+    def test_resolver_cache_after_set_urlconf(self):\n+        # Ensure that after set_urlconf is called internally (as it would during a request handling)\n+        # the cache uses settings.ROOT_URLCONF and behaves correctly.\n+        resolver_using_root = get_resolver()\n+        resolver_specific = get_resolver('urlpatterns.another_path_urls')\n+        self.assertIs(resolver_using_root, resolver_specific)\n+\n+    @override_settings(ROOT_URLCONF=None)\n+    def test_resolver_cache_with_none_root_urlconf(self):\n+        # If the ROOT_URLCONF is None, ensure get_resolver() still behaves correctly\n+        # This case should not cache incorrectly either.\n+        resolver_none = get_resolver()\n+        self.assertIsNotNone(resolver_none)\n+        different_resolver = get_resolver('urlpatterns.path_urls')\n+        self.assertIsNot(resolver_none, different_resolver)\n",
  "django__django-11451": "diff --git a/tests/auth_tests/test_auth_backends.py b/tests/auth_tests/test_auth_backends.py\nindex b010b42..ab4ec91 100644\n--- a/tests/auth_tests/test_auth_backends.py\n+++ b/tests/auth_tests/test_auth_backends.py\n@@ -241,8 +241,25 @@ class ModelBackendTest(BaseModelBackendTest, TestCase):\n             email='test2@example.com',\n             password='test',\n         )\n-\n-    def test_authenticate_inactive(self):\n+    def test_authenticate_no_username_or_password(self):\n+        \"\"\"\n+        authenticate should not query the database if username or password is None.\n+        \"\"\"\n+        CountingMD5PasswordHasher.calls = 0\n+        # Test with both username and password as None\n+        with self.assertNumQueries(0):\n+            self.assertIsNone(authenticate(username=None, password=None))\n+        self.assertEqual(CountingMD5PasswordHasher.calls, 0)\n+\n+        # Test with no username\n+        with self.assertNumQueries(0):\n+            self.assertIsNone(authenticate(username=None, password='test'))\n+        self.assertEqual(CountingMD5PasswordHasher.calls, 0)\n+\n+        # Test with no password\n+        with self.assertNumQueries(0):\n+            self.assertIsNone(authenticate(username='test', password=None))\n+        self.assertEqual(CountingMD5PasswordHasher.calls, 0)\n         \"\"\"\n         An inactive user can't authenticate.\n         \"\"\"\n",
  "django__django-11490": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex e627a0d..688f1f7 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -124,6 +124,17 @@ class QuerySetSetOperationTests(TestCase):\n         reserved_name = qs1.union(qs1).values_list('name', 'order', 'id').get()\n         self.assertEqual(reserved_name[:2], ('a', 2))\n \n+    def test_union_with_different_values_list_columns(self):\n+        ReservedName.objects.create(name='b', order=3)\n+        qs1 = ReservedName.objects.all()\n+\n+        # First, check the correct behavior using values_list with different columns\n+        result = qs1.union(qs1).values_list('name', flat=True).get()\n+        self.assertEqual(result, 'b')\n+\n+        result = qs1.union(qs1).values_list('order', flat=True).get()\n+        self.assertEqual(result, 3)\n+\n     def test_union_with_two_annotated_values_list(self):\n         qs1 = Number.objects.filter(num=1).annotate(\n             count=Value(0, IntegerField()),\n",
  "django__django-11532": "diff --git a/tests/mail/tests.py b/tests/mail/tests.py\nindex a6f0e17..c740491 100644\n--- a/tests/mail/tests.py\n+++ b/tests/mail/tests.py\n@@ -16,6 +16,7 @@ from smtplib import SMTP, SMTPAuthenticationError, SMTPException\n from ssl import SSLError\n \n from django.core import mail\n+from unittest import mock\n from django.core.mail import (\n     EmailMessage, EmailMultiAlternatives, mail_admins, mail_managers,\n     send_mail, send_mass_mail,\n@@ -365,6 +366,24 @@ class MailTests(HeadersCheckMixin, SimpleTestCase):\n         self.assertEqual(msg.body, '')\n         self.assertEqual(msg.message().get_payload(), '')\n \n+    @mock.patch('socket.getfqdn', return_value='\u6f22\u5b57')\n+    def test_non_ascii_domain_in_message_id_with_iso_encoding(self, mocked_getfqdn):\n+        # Ensures Message-ID is properly encoded for non-ASCII domain\n+        delattr(DNS_NAME, '_fqdn')\n+        email = EmailMessage('subject', 'some content', 'from@example.com', ['to@example.com'])\n+        email.encoding = 'iso-8859-1'\n+        message = email.message()\n+        self.assertIn('@xn--p8s937b', message['Message-ID'])\n+\n+    @mock.patch('socket.getfqdn', return_value='\u0434\u043e\u043c\u0435\u043d')\n+    def test_cyrillic_domain_in_message_id_with_iso_encoding(self, mocked_getfqdn):\n+        # Testing with Cyrillic character domain\n+        delattr(DNS_NAME, '_fqdn')\n+        email = EmailMessage('subject', 'test cyrillic domain', 'from@example.com', ['to@example.com'])\n+        email.encoding = 'iso-8859-1'\n+        message = email.message()\n+        self.assertIn('@xn--d1acufc', message['Message-ID'])\n+\n     def test_encoding(self):\n         \"\"\"\n         Regression for #12791 - Encode body correctly with other encodings\n",
  "django__django-11551": "diff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex debaf8a..5a96516 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -1,9 +1,70 @@\n+\n+class TestIssueAdminE108(CheckTestCase):\n+\n+    def test_valid_field_accessible_via_instance(self):\n+        class PositionField(Field):\n+            \"\"\"Custom field accessible only via instance.\"\"\"\n+            def contribute_to_class(self, cls, name):\n+                super().contribute_to_class(cls, name)\n+                setattr(cls, self.name, self)\n+                \n+            def __get__(self, instance, owner):\n+                if instance is None:\n+                    raise AttributeError()\n+\n+        class TestModel(Model):\n+            field = PositionField()\n+\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = ('field',)\n+\n+        self.assertIsValid(TestModelAdmin, TestModel)\n+\n+    def test_invalid_field_not_in_model(self):\n+        class PositionField(Field):\n+            \"\"\"Custom field accessible only via instance.\"\"\"\n+\n+            def contribute_to_class(self, cls, name):\n+                super().contribute_to_class(cls, name)\n+                setattr(cls, self.name, self)\n+                \n+            def __get__(self, instance, owner):\n+                if instance is None:\n+                    raise AttributeError()\n+\n+        class TestModel(Model):\n+            field = PositionField()\n+\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = ('non_existent_field',)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin, TestModel,\n+            \"The value of 'list_display[0]' refers to 'non_existent_field', which is not a callable, an attribute of 'TestModelAdmin', or an attribute or method on 'app_label.TestModel'.\",\n+            'admin.E108'\n+        )\n+        \n+    def test_field_as_many_to_many(self):\n+        from django.db import models\n+\n+        class TestModel(Model):\n+            field = models.ManyToManyField(Model)\n+\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = ('field',)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin, TestModel,\n+            \"The value of 'list_display[0]' must not be a ManyToManyField.\",\n+            'admin.E109'\n+        )\n+\n from django import forms\n from django.contrib.admin import BooleanFieldListFilter, SimpleListFilter\n from django.contrib.admin.options import VERTICAL, ModelAdmin, TabularInline\n from django.contrib.admin.sites import AdminSite\n from django.core.checks import Error\n-from django.db.models import F\n+from django.db.models import F, Field, Model\n from django.db.models.functions import Upper\n from django.forms.models import BaseModelFormSet\n from django.test import SimpleTestCase\n",
  "django__django-11555": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex d1363b3..fc506da 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -9,7 +9,9 @@ from django.db.models.functions import Upper\n from django.test import TestCase\n from django.utils.deprecation import RemovedInDjango31Warning\n \n-from .models import Article, Author, OrderedByFArticle, Reference\n+from .models import Article, Author, ChildArticle, OrderedByFArticle, Reference\n+from django.db.models import F, Value\n+from datetime import datetime\n \n \n class OrderingTests(TestCase):\n@@ -462,6 +464,42 @@ class OrderingTests(TestCase):\n             attrgetter('headline')\n         )\n \n+    def test_order_by_with_meta_expression(self):\n+        # Set up ChildArticle without default Meta ordering issue\n+        ca1 = ChildArticle.objects.create(\n+            headline='h2',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_2,\n+        )\n+        ca2 = ChildArticle.objects.create(\n+            headline='h2',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_1,\n+        )\n+        ca3 = ChildArticle.objects.create(\n+            headline='h3',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_1,\n+        )\n+        ca4 = ChildArticle.objects.create(\n+            headline='h1', \n+            pub_date=datetime(2005, 7, 28)\n+        )\n+        # Order by 'article_ptr', should not crash and provide correct order\n+        articles = ChildArticle.objects.order_by('article_ptr')\n+        self.assertSequenceEqual(articles, [ca4, ca2, ca1, ca3])\n+\n+    def test_order_by_expression_with_explicit_order_by(self):\n+        # Explicit ordering with expression OrderBy(F())\n+        articles = OrderedByFArticle.objects.all().order_by(F('author__name'))\n+        self.assertEqual(articles.count(), 4)\n+        # Verify ordering\n+        self.assertQuerysetEqual(\n+            articles, \n+            [self.a1, self.a3, self.a2, self.a4],\n+            attrgetter('headline')\n+        )\n+\n     def test_deprecated_values_annotate(self):\n         msg = (\n             \"Article QuerySet won't use Meta.ordering in Django 3.1. Add \"\n@@ -469,5 +507,41 @@ class OrderingTests(TestCase):\n             \"descending=False), OrderBy(F(second_author__name), \"\n             \"descending=False)) to retain the current query.\"\n         )\n+\n+    def test_order_by_with_meta_expression(self):\n+        # Set up ChildArticle without default Meta ordering issue\n+        ca1 = ChildArticle.objects.create(\n+            headline='h2',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_2,\n+        )\n+        ca2 = ChildArticle.objects.create(\n+            headline='h2',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_1,\n+        )\n+        ca3 = ChildArticle.objects.create(\n+            headline='h3',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_1,\n+        )\n+        ca4 = ChildArticle.objects.create(\n+            headline='h1', \n+            pub_date=datetime(2005, 7, 28)\n+        )\n+        # Order by 'article_ptr', should not crash and provide correct order\n+        articles = ChildArticle.objects.order_by('article_ptr')\n+        self.assertSequenceEqual(articles, [ca4, ca2, ca1, ca3])\n+\n+    def test_order_by_expression_with_explicit_order_by(self):\n+        # Explicit ordering with expression OrderBy(F())\n+        articles = OrderedByFArticle.objects.all().order_by(F('author__name'))\n+        self.assertEqual(articles.count(), 4)\n+        # Verify ordering\n+        self.assertQuerysetEqual(\n+            articles, \n+            [self.a1, self.a3, self.a2, self.a4],\n+            attrgetter('headline')\n+        )\n         with self.assertRaisesMessage(RemovedInDjango31Warning, msg):\n             list(Article.objects.values('author').annotate(Count('headline')))\n",
  "django__django-11603": "",
  "django__django-11740": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex a98fff5..ad8d054 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -27,6 +27,28 @@ class DeconstructibleObject:\n         self.args = args\n         self.kwargs = kwargs\n \n+    def test_alter_uuid_field_to_fk_creates_dependency(self):\n+        \"\"\"Test altering a UUIDField to a ForeignKey creates a dependency.\"\"\"\n+        app1_before = ModelState(\"testapp1\", \"App1\", [\n+            (\"id\", models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),\n+            (\"text\", models.CharField(max_length=100)),\n+            (\"another_app\", models.UUIDField(null=True, blank=True)),\n+        ])\n+        app1_after = ModelState(\"testapp1\", \"App1\", [\n+            (\"id\", models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),\n+            (\"text\", models.CharField(max_length=100)),\n+            (\"another_app\", models.ForeignKey(\"testapp2.App2\", null=True, blank=True, on_delete=models.SET_NULL)),\n+        ])\n+        app2 = ModelState(\"testapp2\", \"App2\", [\n+            (\"id\", models.UUIDField(primary_key=True, unique=True, default=uuid.uuid4, editable=False)),\n+            (\"text\", models.CharField(max_length=100)),\n+        ])\n+\n+        changes = self.get_changes([app1_before, app2], [app1_after, app2])\n+        self.assertNumberMigrations(changes, 'testapp1', 1)\n+        self.assertOperationTypes(changes, 'testapp1', 0, [\"AlterField\"])\n+        self.assertMigrationDependencies(changes, 'testapp1', 0, [('testapp2', '__first__')])\n+\n     def deconstruct(self):\n         return (\n             self.__module__ + '.' + self.__class__.__name__,\n@@ -2399,4 +2421,4 @@ class AutodetectorTests(TestCase):\n         changes = self.get_changes([Animal, Dog], [Animal])\n         self.assertNumberMigrations(changes, 'app', 1)\n         self.assertOperationTypes(changes, 'app', 0, ['DeleteModel'])\n-        self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n+        self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n",
  "django__django-11749": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex a0e1530..a63d3b4 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -224,7 +224,22 @@ class CommandTests(SimpleTestCase):\n         management.call_command('subparser_dest', 'foo', bar=12, stdout=out)\n         self.assertIn('bar', out.getvalue())\n \n-    def test_subparser_dest_required_args(self):\n+    def test_mutually_exclusive_group_via_kwargs(self):\n+        out = StringIO()\n+        # Test passing 'foo_id' argument as a keyword argument.\n+        management.call_command('mutually_exclusive_required', foo_id=1, stdout=out)\n+        self.assertIn('foo_id', out.getvalue())\n+\n+        out = StringIO()\n+        # Test passing 'foo_name' argument as a keyword argument.\n+        management.call_command('mutually_exclusive_required', foo_name='foo', stdout=out)\n+        self.assertIn('foo_name', out.getvalue())\n+\n+        out = StringIO()\n+        msg = 'Error: one of the arguments --foo-id --foo-name is required'\n+        # Test calling without mutually exclusive required argument raises an error.\n+        with self.assertRaisesMessage(CommandError, msg):\n+            management.call_command('mutually_exclusive_required', stdout=out)\n         out = StringIO()\n         management.call_command('subparser_required', 'foo_1', 'foo_2', bar=12, stdout=out)\n         self.assertIn('bar', out.getvalue())\n",
  "django__django-11790": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 440150b..5e814f0 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -437,7 +437,26 @@ class AuthenticationFormTest(TestDataMixin, TestCase):\n         self.assertEqual(form.fields['username'].max_length, 254)\n         self.assertEqual(form.errors, {})\n \n-    def test_username_field_label(self):\n+    def test_username_field_widget_maxlength(self):\n+        # Test if the maxlength attribute is set to 255 based on a custom user model's username field\n+        data = {\n+            'username': 'a' * 255,\n+            'password': 'pwd',\n+        }\n+        CustomEmailField.objects.create_user(**data)\n+        form = AuthenticationForm(None, data)\n+        self.assertEqual(form.fields['username'].widget.attrs.get('maxlength'), '255')\n+\n+    @override_settings(AUTH_USER_MODEL='auth_tests.IntegerUsernameUser')\n+    def test_username_field_widget_maxlength_default(self):\n+        # Test if the maxlength attribute defaults to 254 when not explicitly set in user model\n+        data = {\n+            'username': 'testuser',\n+            'password': 'password',\n+        }\n+        IntegerUsernameUser.objects.create_user(**data)\n+        form = AuthenticationForm(None, data)\n+        self.assertEqual(form.fields['username'].widget.attrs.get('maxlength'), '254')\n \n         class CustomAuthenticationForm(AuthenticationForm):\n             username = CharField(label=\"Name\", max_length=75)\n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..d2917fe 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -252,7 +252,22 @@ class WriterTests(SimpleTestCase):\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n \n-    def test_serialize_enums(self):\n+    def test_serialize_translated_enums(self):\n+        from django.utils.translation import gettext_lazy as _\n+        \n+        class TextTranslatedEnum(enum.Enum):\n+            A = _('a-value')\n+            B = _('b-value')\n+\n+        field = models.CharField(default=TextTranslatedEnum.A, choices=[(m.value, m) for m in TextTranslatedEnum])\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.CharField(choices=[\"\n+            \"('a-value', migrations.test_writer.TextTranslatedEnum['A']), \"\n+            \"('b-value', migrations.test_writer.TextTranslatedEnum['B'])], \"\n+            \"default=migrations.test_writer.TextTranslatedEnum['A'])\"\n+        )\n         class TextEnum(enum.Enum):\n             A = 'a-value'\n             B = 'value-b'\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..0f9e82b 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,5 +1,6 @@\n+\n import unittest\n-from datetime import datetime\n+from datetime import datetime, timedelta\n \n from django.test import SimpleTestCase, ignore_warnings\n from django.utils.datastructures import MultiValueDict\n@@ -316,9 +317,34 @@ class HttpDateProcessingTests(unittest.TestCase):\n         parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n-    def test_parsing_rfc850(self):\n-        parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n-        self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n+    @mock.patch('django.utils.http.datetime')\n+    def test_parsing_rfc850_with_two_digit_years(self, mocked_datetime):\n+        # Prepare a list of test cases in the format (current year, rfc850 date, expected parsed date)\n+        test_cases = [\n+            # Current year 2023 cases\n+            (datetime(2023, 1, 1), 'Saturday, 31-Dec-23 23:59:59 GMT', datetime(2023, 12, 31, 23, 59, 59)),\n+            (datetime(2023, 1, 1), 'Monday, 31-Dec-73 23:59:59 GMT', datetime(1973, 12, 31, 23, 59, 59)),\n+            \n+            # Current year 2073 cases (more than 50 years forward)\n+            (datetime(2073, 1, 1), 'Sunday, 06-Nov-22 08:49:37 GMT', datetime(2022, 11, 6, 8, 49, 37)),\n+            (datetime(2073, 1, 1), 'Tuesday, 31-Dec-72 23:59:59 GMT', datetime(2072, 12, 31, 23, 59, 59)),\n+            \n+            # Current year 1970 cases (less than 50 years forward)\n+            (datetime(1970, 1, 1), 'Monday, 31-Dec-20 23:59:59 GMT', datetime(2020, 12, 31, 23, 59, 59)),\n+            (datetime(1970, 1, 1), 'Thursday, 01-Jan-70 00:00:00 GMT', datetime(1970, 1, 1, 0, 0, 0)),\n+        ]\n+\n+        for current_time, date_string, expected_datetime in test_cases:\n+            with self.subTest(date_string=date_string):\n+                # To simulate the current year for parsing\n+                mocked_datetime.datetime.now.return_value = current_time\n+                \n+                # Parse the date string\n+                parsed_timestamp = parse_http_date(date_string)\n+                \n+                # Assert the expected datetime\n+                parsed_datetime = datetime.utcfromtimestamp(parsed_timestamp)\n+                self.assertEqual(parsed_datetime, expected_datetime)\n \n     def test_parsing_asctime(self):\n         parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n",
  "django__django-11880": "",
  "django__django-11951": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex f2f6bbd..f6a2792 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -1,3 +1,5 @@\n+\n+from math import ceil\n from operator import attrgetter\n \n from django.db import IntegrityError, NotSupportedError, connection\n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..c725f68 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -116,6 +116,44 @@ class ChoicesTests(SimpleTestCase):\n         self.assertEqual(Medal.values, ['GOLD', 'SILVER', 'BRONZE'])\n         self.assertEqual(Medal.names, ['GOLD', 'SILVER', 'BRONZE'])\n \n+    def test_value_type_with_textchoices(self):\n+        class MyTextChoice(models.TextChoices):\n+            OPTION_A = 'opt_a', 'Option A'\n+            OPTION_B = 'opt_b', 'Option B'\n+\n+        class MyModel(models.Model):\n+            option = models.CharField(max_length=10, choices=MyTextChoice.choices)\n+\n+        # Creating instance\n+        instance = MyModel(option=MyTextChoice.OPTION_A)\n+        self.assertIsInstance(instance.option, str)\n+        self.assertEqual(instance.option, 'opt_a')\n+\n+        # Simulating retrieval from database\n+        instance.save()\n+        retrieved_instance = MyModel.objects.get(pk=instance.pk)\n+        self.assertIsInstance(retrieved_instance.option, str)\n+        self.assertEqual(retrieved_instance.option, 'opt_a')\n+\n+    def test_value_type_with_integerchoices(self):\n+        class MyIntegerChoice(models.IntegerChoices):\n+            OPTION_ONE = 1, 'Option One'\n+            OPTION_TWO = 2, 'Option Two'\n+\n+        class MyModel(models.Model):\n+            option = models.IntegerField(choices=MyIntegerChoice.choices)\n+\n+        # Creating instance\n+        instance = MyModel(option=MyIntegerChoice.OPTION_ONE)\n+        self.assertIsInstance(instance.option, int)\n+        self.assertEqual(instance.option, 1)\n+\n+        # Simulating retrieval from database\n+        instance.save()\n+        retrieved_instance = MyModel.objects.get(pk=instance.pk)\n+        self.assertIsInstance(retrieved_instance.option, int)\n+        self.assertEqual(retrieved_instance.option, 1)\n+\n     def test_textchoices_containment(self):\n         self.assertIn(YearInSchool.FRESHMAN, YearInSchool)\n         self.assertIn('FR', YearInSchool)\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..f2d6704 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -161,6 +161,18 @@ class GetFieldDisplayTests(SimpleTestCase):\n         self.assertIsNone(Whiz(c=None).get_c_display())         # Blank value\n         self.assertEqual(Whiz(c='').get_c_display(), '')        # Empty value\n         self.assertEqual(WhizDelayed(c=0).get_c_display(), 'Other')  # Delayed choices\n+    def test_override_get_FIELD_display(self):\n+        \"\"\"\n+        Test that overriding get_FIELD_display in a model works as expected.\n+        \"\"\"\n+        class FooBar(models.Model):\n+            foo_bar = models.IntegerField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                return 'something'\n+\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), 'something')\n \n     def test_get_FIELD_display_translated(self):\n         \"\"\"A translated display value is coerced to str.\"\"\"\n",
  "django__django-12039": "diff --git a/tests/indexes/tests.py b/tests/indexes/tests.py\nindex 700f574..86d195c 100644\n--- a/tests/indexes/tests.py\n+++ b/tests/indexes/tests.py\n@@ -10,6 +10,8 @@ from django.test import (\n     TestCase, TransactionTestCase, skipIfDBFeature, skipUnlessDBFeature,\n )\n from django.test.utils import override_settings\n+from django.db import connection\n+from django.db.models import Index\n from django.utils import timezone\n \n from .models import (\n@@ -22,7 +24,65 @@ class SchemaIndexesTests(TestCase):\n     Test index handling by the db.backends.schema infrastructure.\n     \"\"\"\n \n-    def test_index_name_hash(self):\n+    def test_columns_list_sql(self):\n+        index = Index(fields=['headline'], name='whitespace_idx')\n+        editor = connection.schema_editor()\n+        self.assertIn(\n+            '(%s)' % editor.quote_name('headline'),\n+            str(index.create_sql(Article, editor)),\n+        )\n+\n+    def test_descending_columns_list_sql(self):\n+        index = Index(fields=['-headline'], name='whitespace_idx')\n+        editor = connection.schema_editor()\n+        self.assertIn(\n+            '(%s DESC)' % editor.quote_name('headline'),\n+            str(index.create_sql(Article, editor)),\n+        )\n+\n+    def test_ops_class_columns_lists_sql(self):\n+        index = Index(\n+            fields=['headline'],\n+            name='whitespace_idx',\n+            opclasses=['text_pattern_ops'],\n+        )\n+        with connection.schema_editor() as editor:\n+            self.assertIn(\n+                '(%s text_pattern_ops)' % editor.quote_name('headline'),\n+                str(index.create_sql(Article, editor)),\n+            )\n+\n+    def test_ops_class_descending_columns_list_sql(self):\n+        index = Index(\n+            fields=['-headline'],\n+            name='whitespace_idx',\n+            opclasses=['text_pattern_ops'],\n+        )\n+        with connection.schema_editor() as editor:\n+            self.assertIn(\n+                '(%s text_pattern_ops DESC)' % editor.quote_name('headline'),\n+                str(index.create_sql(Article, editor)),\n+            )\n+\n+    def test_columns_with_opclasses_but_no_ordering(self):\n+        index = Index(\n+            fields=['headline'],\n+            name='whitespace_idx',\n+            opclasses=['text_pattern_ops'],\n+        )\n+        with connection.schema_editor() as editor:\n+            sql = str(index.create_sql(Article, editor))\n+            self.assertIn('(%s text_pattern_ops)' % editor.quote_name('headline'), sql)\n+\n+    def test_columns_with_opclasses_and_descending_ordering(self):\n+        index = Index(\n+            fields=['-headline'],\n+            name='whitespace_idx',\n+            opclasses=['text_pattern_ops'],\n+        )\n+        with connection.schema_editor() as editor:\n+            sql = str(index.create_sql(Article, editor))\n+            self.assertIn('(%s text_pattern_ops DESC)' % editor.quote_name('headline'), sql)\n         \"\"\"\n         Index names should be deterministic.\n         \"\"\"\n",
  "django__django-12050": "diff --git a/tests/queries/test_query.py b/tests/queries/test_query.py\nindex 49d26f3..ea71d55 100644\n--- a/tests/queries/test_query.py\n+++ b/tests/queries/test_query.py\n@@ -1,8 +1,10 @@\n+\n from datetime import datetime\n \n from django.core.exceptions import FieldError\n from django.db.models import CharField, F, Q\n from django.db.models.expressions import SimpleCol\n+from django.db.models import IntegerField, TextField\n from django.db.models.fields.related_lookups import RelatedIsNull\n from django.db.models.functions import Lower\n from django.db.models.lookups import Exact, GreaterThan, IsNull, LessThan\n",
  "django__django-12125": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex e62f7b0..17b1a56 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -180,6 +180,31 @@ class OperationWriterTests(SimpleTestCase):\n         )\n \n \n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n+\n class WriterTests(SimpleTestCase):\n     \"\"\"\n     Tests the migration writer (makes migration files from Migration instances)\n@@ -229,12 +254,62 @@ class WriterTests(SimpleTestCase):\n             (\"Decimal('1.3')\", {'from decimal import Decimal'})\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n         self.assertSerializedEqual(Money('1.3'))\n         self.assertSerializedResultEqual(\n             Money('1.3'),\n             (\"migrations.test_writer.Money('1.3')\", {'import migrations.test_writer'})\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -270,6 +345,31 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set())\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r'^foo$')\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -280,18 +380,118 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {'import migrations.test_writer'})\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\"migrations.test_writer.TextTranslatedEnum['A']\", {'import migrations.test_writer'})\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\"migrations.test_writer.BinaryEnum['A']\", {'import migrations.test_writer'})\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {'import migrations.test_writer'})\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -299,6 +499,31 @@ class WriterTests(SimpleTestCase):\n                 {'import migrations.test_writer'},\n             ),\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(default=TextEnum.B, choices=[(m.value, m) for m in TextEnum])\n@@ -310,10 +535,60 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\"\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -322,6 +597,31 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\"\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         field = models.CharField(default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum])\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -331,6 +631,31 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\"\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         field = models.IntegerField(default=IntEnum.A, choices=[(m.value, m) for m in IntEnum])\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -341,6 +666,31 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\"\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = 'A', 'A value'\n@@ -360,6 +710,31 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             ('datetime.date(1969, 7, 20)', {'import datetime'}),\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         field = models.CharField(default=TextChoices.B, choices=TextChoices.choices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -367,12 +742,62 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices.choices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices.choices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -383,6 +808,31 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\"\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_serialize_uuid(self):\n         self.assertSerializedEqual(uuid.uuid1())\n         self.assertSerializedEqual(uuid.uuid4())\n@@ -393,11 +843,61 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {'import uuid'})\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {'import uuid'})\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n         field = models.UUIDField(choices=((uuid_a, 'UUID A'), (uuid_b, 'UUID B')), default=uuid_a)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -408,6 +908,31 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\"\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_serialize_functions(self):\n         with self.assertRaisesMessage(ValueError, 'Cannot serialize function: lambda'):\n             self.assertSerializedEqual(lambda x: 42)\n@@ -430,6 +955,31 @@ class WriterTests(SimpleTestCase):\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {'import datetime'})\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=utc),\n             (\n@@ -438,18 +988,93 @@ class WriterTests(SimpleTestCase):\n             )\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"})\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n             (\"models.TextField(blank=True, null=True)\", {'from django.db import models'})\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\"))\n         self.assertSerializedResultEqual(\n@@ -457,12 +1082,62 @@ class WriterTests(SimpleTestCase):\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"})\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)),\n             (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -558,6 +1233,31 @@ class WriterTests(SimpleTestCase):\n             FoodQuerySet.as_manager(),\n             ('migrations.models.FoodQuerySet.as_manager()', {'import migrations.models'})\n         )\n+\n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n         self.assertSerializedEqual(FoodManager('a', 'b'))\n         self.assertSerializedEqual(FoodManager('x', 'y', c=3, d=4))\n \n@@ -661,6 +1361,31 @@ class WriterTests(SimpleTestCase):\n             result['custom_migration_operations'].more_operations.TestOperation\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -681,6 +1406,31 @@ class WriterTests(SimpleTestCase):\n             output\n         )\n \n+\n+    class Outer:\n+        class Inner(models.CharField):\n+            pass\n+\n+\n+    def test_nested_inner_class_serialization(self):\n+        \"\"\"\n+        Test serialization of a model field using an inner class to ensure the path is correct.\n+        \"\"\"\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class TestModel(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        field = TestModel._meta.get_field('field')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertEqual(\n+            string,\n+            \"tests.migrations.test_writer.Outer.Inner(max_length=20)\",\n+        )\n+        self.assertIn(\"import tests.migrations.test_writer\", imports)\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -746,4 +1496,4 @@ class WriterTests(SimpleTestCase):\n \n     def test_register_non_serializer(self):\n         with self.assertRaisesMessage(ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "django__django-12143": "diff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex 2d13234..71e7897 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -838,7 +838,29 @@ class ChangeListTests(TestCase):\n         request = self.factory.post(changelist_url, data=data)\n         queryset = m._get_list_editable_queryset(request, prefix='form')\n         self.assertEqual(queryset.count(), 1)\n-        data['form-0-uuid'] = 'INVALD_PRIMARY_KEY'\n+        data['form-0-uuid'] = 'INVALID_PRIMARY_KEY'\n+        \n+    def test_get_list_editable_queryset_with_all_special_regex_chars_in_prefix(self):\n+        a = Swallow.objects.create(origin='Special Swallow A', load=5, speed=3)\n+        Swallow.objects.create(origin='Special Swallow B', load=3, speed=4)\n+        # Use a prefix that contains all special regex characters\n+        special_prefix = 'form[\\\\.\\\\^\\\\$\\\\*\\\\+\\\\?\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}\\\\|]'\n+        data = {\n+            f'{special_prefix}-TOTAL_FORMS': '2',\n+            f'{special_prefix}-INITIAL_FORMS': '2',\n+            f'{special_prefix}-MIN_NUM_FORMS': '0',\n+            f'{special_prefix}-MAX_NUM_FORMS': '1000',\n+            f'{special_prefix}-0-uuid': str(a.pk),\n+            f'{special_prefix}-0-load': '10',\n+            '_save': 'Save',\n+        }\n+        superuser = self._create_superuser('superuser')\n+        self.client.force_login(superuser)\n+        changelist_url = reverse('admin:admin_changelist_swallow_changelist')\n+        m = SwallowAdmin(Swallow, custom_site)\n+        request = self.factory.post(changelist_url, data=data)\n+        queryset = m._get_list_editable_queryset(request, prefix=special_prefix)\n+        self.assertEqual(queryset.count(), 1)\n         # The unfiltered queryset is returned if there's invalid data.\n         request = self.factory.post(changelist_url, data=data)\n         queryset = m._get_list_editable_queryset(request, prefix='form')\n",
  "django__django-12155": "",
  "django__django-12193": "diff --git a/tests/forms_tests/widget_tests/test_checkboxinput.py b/tests/forms_tests/widget_tests/test_checkboxinput.py\nindex 5c5e45d..50c75d9 100644\n--- a/tests/forms_tests/widget_tests/test_checkboxinput.py\n+++ b/tests/forms_tests/widget_tests/test_checkboxinput.py\n@@ -82,10 +82,25 @@ class CheckboxInputTest(WidgetTest):\n         \"\"\"\n         self.assertFalse(self.widget.value_from_datadict({}, {}, 'testing'))\n \n+    def test_get_context_does_not_mutate_attrs(self):\n+        widget = forms.CheckboxInput()\n+        attrs = {'checked': False}\n+        widget.get_context('name', True, attrs)\n+        self.assertIs(attrs['checked'], False)\n+\n+    def test_checkbox_get_context_attrs(self):\n+        widget = SplitArrayWidget(forms.CheckboxInput(), size=2)\n+        context = widget.get_context('name', [True, False], {})\n+        self.assertEqual(context['widget']['value'], [True, False])\n+        self.assertEqual(\n+            [subwidget['attrs'] for subwidget in context['widget']['subwidgets']],\n+            [{'checked': True}, {}]\n+        )\n+\n     def test_value_from_datadict_string_int(self):\n         value = self.widget.value_from_datadict({'testing': '0'}, {}, 'testing')\n         self.assertIs(value, True)\n \n     def test_value_omitted_from_data(self):\n         self.assertIs(self.widget.value_omitted_from_data({'field': 'value'}, {}, 'field'), False)\n-        self.assertIs(self.widget.value_omitted_from_data({}, {}, 'field'), False)\n+        self.assertIs(self.widget.value_omitted_from_data({}, {}, 'field'), False)\n",
  "django__django-12209": "diff --git a/tests/serializers/models/data.py b/tests/serializers/models/data.py\nindex 946715d..2630143 100644\n--- a/tests/serializers/models/data.py\n+++ b/tests/serializers/models/data.py\n@@ -252,6 +252,10 @@ class SmallPKData(models.Model):\n # class TimePKData(models.Model):\n #    data = models.TimeField(primary_key=True)\n \n+import uuid\n+\n+class UUIDDefaultData(models.Model):\n+    data = models.UUIDField(primary_key=True, default=uuid.uuid4)\n \n class UUIDData(models.Model):\n     data = models.UUIDField(primary_key=True)\n",
  "django__django-12262": "",
  "django__django-12276": "diff --git a/tests/forms_tests/widget_tests/test_fileinput.py b/tests/forms_tests/widget_tests/test_fileinput.py\nindex c3ea9d6..1b73833 100644\n--- a/tests/forms_tests/widget_tests/test_fileinput.py\n+++ b/tests/forms_tests/widget_tests/test_fileinput.py\n@@ -15,6 +15,22 @@ class FileInputTest(WidgetTest):\n         self.check_html(self.widget, 'email', '', html='<input type=\"file\" name=\"email\">')\n         self.check_html(self.widget, 'email', None, html='<input type=\"file\" name=\"email\">')\n \n+    def test_fileinput_required_attribute(self):\n+        class FileForm(forms.Form):\n+            file1 = forms.FileField(widget=FileInput)\n+        \n+        form_without_initial = FileForm(auto_id=False)\n+        self.assertHTMLEqual(\n+            form_without_initial.as_table(),\n+            '<tr><th>File1:</th><td><input type=\"file\" name=\"file1\" required></td></tr>',\n+        )\n+        \n+        form_with_initial = FileForm(initial={'file1': 'resume.txt'}, auto_id=False)\n+        self.assertHTMLEqual(\n+            form_with_initial.as_table(),\n+            '<tr><th>File1:</th><td><input type=\"file\" name=\"file1\"></td></tr>',\n+        )\n+\n     def test_value_omitted_from_data(self):\n         self.assertIs(self.widget.value_omitted_from_data({}, {}, 'field'), True)\n-        self.assertIs(self.widget.value_omitted_from_data({}, {'field': 'value'}, 'field'), False)\n+        self.assertIs(self.widget.value_omitted_from_data({}, {'field': 'value'}, 'field'), False)\n",
  "django__django-12304": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 6cabf01..ec95e19 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -1,9 +1,11 @@\n+\n import datetime\n import decimal\n import ipaddress\n import uuid\n \n from django.db import models\n+from django.template import Context, Template\n from django.test import SimpleTestCase\n from django.utils.functional import Promise\n from django.utils.translation import gettext_lazy as _\n",
  "django__django-12308": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex acbcf33..fd0abc6 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -165,8 +165,25 @@ class UtilsTests(SimpleTestCase):\n         display_value = display_for_field(None, models.NullBooleanField(), self.empty_value)\n         expected = '<img src=\"%sadmin/img/icon-unknown.svg\" alt=\"None\">' % settings.STATIC_URL\n         self.assertHTMLEqual(display_value, expected)\n-\n         display_value = display_for_field(None, models.BooleanField(null=True), self.empty_value)\n+\n+    def test_json_display_for_field(self):\n+        \"\"\"\n+        Test that JSONField values are properly displayed as JSON when readonly in the admin.\n+        \"\"\"\n+        tests = [\n+            # Proper JSON structures should be displayed with double quotes\n+            ({'a': {'b': 'c'}}, '{\"a\": {\"b\": \"c\"}}'),\n+            (['a', 'b'], '[\"a\", \"b\"]'),\n+            ('foo', '\"foo\"'),  # A string value should be displayed with double quotes\n+            \n+            # Invalid JSON or unsupported structures are displayed as such (not a common case)\n+            ({('a', 'b'): 'c'}, \"{('a', 'b'): 'c'}\"),  # Invalid JSON, should remain a representation\n+        ]\n+        for value, expected_display in tests:\n+            with self.subTest(value=value):\n+                display_value = display_for_field(value, models.JSONField(), self.empty_value)\n+                self.assertEqual(display_value, expected_display)\n         expected = '<img src=\"%sadmin/img/icon-unknown.svg\" alt=\"None\" />' % settings.STATIC_URL\n         self.assertHTMLEqual(display_value, expected)\n \n",
  "django__django-12325": "diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex fffd9ab..f8cc201 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -1014,6 +1014,35 @@ class OtherModelTests(SimpleTestCase):\n \n             class ParkingLot(Place):\n                 parent = models.OneToOneField(Place, models.CASCADE)\n+    @isolate_apps('invalid_models_tests')\n+    def test_onetoone_with_parent_and_origin(self):\n+        # Test where explicit parent_link is correctly set, and the origin causes confusion if not ordered as expected.\n+        class Document(models.Model):\n+            pass\n+\n+        class Picking(Document):\n+            document_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+            origin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\n+\n+        self.assertEqual(Picking.check(), [])\n+\n+        # If the order was incorrect (which shouldn't matter), this model setup would have failed.\n+        class PickingIncorrect(Document):\n+            origin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\n+            document_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+        \n+        self.assertEqual(PickingIncorrect.check(), [])\n+\n+    @isolate_apps('invalid_models_tests')\n+    def test_incorrect_onetoone_without_parent_link(self):\n+        # Test case where parent_link is missing, simulates improper parent link setup.\n+        class Document(models.Model):\n+            pass\n+\n+        msg = 'Add parent_link=True to invalid_models_tests.Picking.origin.'\n+        with self.assertRaisesMessage(ImproperlyConfigured, msg):\n+            class Picking(Document):\n+                origin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\n \n     def test_m2m_table_name_clash(self):\n         class Foo(models.Model):\n",
  "django__django-12419": "diff --git a/tests/middleware/test_security.py b/tests/middleware/test_security.py\nindex 7af62eb..3f5efc0 100644\n--- a/tests/middleware/test_security.py\n+++ b/tests/middleware/test_security.py\n@@ -247,6 +247,15 @@ class SecurityMiddlewareTest(SimpleTestCase):\n             with self.subTest(value=value), override_settings(SECURE_REFERRER_POLICY=value):\n                 self.assertEqual(self.process_response()['Referrer-Policy'], expected)\n \n+    @override_settings(SECURE_REFERRER_POLICY=None)\n+    def test_referrer_policy_default(self):\n+        \"\"\"\n+        With SECURE_REFERRER_POLICY unset, the middleware defaults to\n+        \"same-origin\" as the Referrer-Policy.\n+        \"\"\"\n+        response = self.process_response()\n+        self.assertEqual(response['Referrer-Policy'], 'same-origin')\n+\n     @override_settings(SECURE_REFERRER_POLICY='strict-origin')\n     def test_referrer_policy_already_present(self):\n         \"\"\"\n@@ -254,4 +263,4 @@ class SecurityMiddlewareTest(SimpleTestCase):\n         present in the response.\n         \"\"\"\n         response = self.process_response(headers={'Referrer-Policy': 'unsafe-url'})\n-        self.assertEqual(response['Referrer-Policy'], 'unsafe-url')\n+        self.assertEqual(response['Referrer-Policy'], 'unsafe-url')\n",
  "django__django-12663": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 872551b..1ac447e 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -13,10 +13,14 @@ from django.db.models import (\n     Func, IntegerField, Max, Min, Model, OrderBy, OuterRef, Q, StdDev,\n     Subquery, Sum, TimeField, UUIDField, Value, Variance, When,\n )\n+from django.contrib.auth.models import User\n+from django.utils.functional import SimpleLazyObject\n from django.db.models.expressions import Col, Combinable, Random, RawSQL, Ref\n from django.db.models.functions import (\n     Coalesce, Concat, Left, Length, Lower, Substr, Upper,\n )\n+from django.contrib.auth.models import User\n+from django.utils.functional import SimpleLazyObject\n from django.db.models.sql import constants\n from django.db.models.sql.datastructures import Join\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n@@ -26,10 +30,30 @@ from .models import (\n     UUID, UUIDPK, Company, Employee, Experiment, Number, RemoteEmployee,\n     Result, SimulationRun, Time,\n )\n+from django.contrib.auth.models import User\n+from django.utils.functional import SimpleLazyObject\n \n \n class BasicExpressionsTests(TestCase):\n-    @classmethod\n+    def test_subquery_with_simple_lazy_object(self):\n+        manager = Manager.objects.create(name='Lazy Manager')\n+        company = Company.objects.create(\n+            name='Lazy Corp',\n+            ceo=Employee.objects.create(firstname='Lazy', lastname='Doe')\n+        )\n+        Employee.objects.create(firstname='Lazy', lastname='Doe', manager=manager)\n+\n+        lazy_manager = SimpleLazyObject(lambda: Manager.objects.get(pk=manager.pk))\n+        \n+        queryset = Company.objects.annotate(\n+            ceo_manager=Subquery(\n+                Employee.objects.filter(\n+                    lastname=OuterRef('ceo__lastname')\n+                ).values('manager__name')[:1]\n+            )\n+        ).filter(ceo_manager=lazy_manager.name)\n+\n+        self.assertEqual(queryset.get(), company)\n     def setUpTestData(cls):\n         cls.example_inc = Company.objects.create(\n             name=\"Example Inc.\", num_employees=2300, num_chairs=5,\n",
  "django__django-12708": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 2df48a2..8adffa4 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1758,8 +1758,31 @@ class OperationTests(OperationTestBase):\n     def test_alter_index_together_remove(self):\n         operation = migrations.AlterIndexTogether(\"Pony\", None)\n         self.assertEqual(operation.describe(), \"Alter index_together for Pony (0 constraint(s))\")\n-\n-    @skipUnlessDBFeature('supports_table_check_constraints')\n+    \n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_alter_index_together_remove_with_unique_together(self):\n+        app_label = 'test_alindex_remove_with_unq'\n+        table_name = '%s_pony' % app_label\n+        project_state = self.set_up_test_model(app_label, unique_together=True)\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+        \n+        # Add index together.\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexExists(table_name, ['pink', 'weight'])\n+        \n+        # Remove index together.\n+        project_state = new_state\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', set())\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n     def test_add_constraint(self):\n         project_state = self.set_up_test_model(\"test_addconstraint\")\n         gt_check = models.Q(pink__gt=2)\n",
  "django__django-12713": "",
  "django__django-12741": "diff --git a/tests/backends/base/test_operations.py b/tests/backends/base/test_operations.py\nindex 089eb18..b0ffe95 100644\n--- a/tests/backends/base/test_operations.py\n+++ b/tests/backends/base/test_operations.py\n@@ -172,7 +172,7 @@ class SqlFlushTests(TransactionTestCase):\n             reset_sequences=True,\n             allow_cascade=True,\n         )\n-        connection.ops.execute_sql_flush(connection.alias, sql_list)\n+        connection.ops.execute_sql_flush(sql_list)\n \n         with transaction.atomic():\n             self.assertIs(Author.objects.exists(), False)\n@@ -181,4 +181,4 @@ class SqlFlushTests(TransactionTestCase):\n                 author = Author.objects.create(name='F. Scott Fitzgerald')\n                 self.assertEqual(author.pk, 1)\n                 book = Book.objects.create(author=author)\n-                self.assertEqual(book.pk, 1)\n+                self.assertEqual(book.pk, 1)\n",
  "django__django-12754": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex 17e707b..4986df6 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -2444,8 +2444,30 @@ class AutodetectorTests(TestCase):\n         self.assertNumberMigrations(changes, 'testapp', 1)\n         self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\", \"AddField\"])\n         self.assertOperationAttributes(changes, 'testapp', 0, 0)\n-\n-    def test_mti_inheritance_model_removal(self):\n+    def test_add_model_with_field_removed_from_base_model(self):\n+        \"\"\"\n+        Test part of issue analogous to #21890: Removing a base field before\n+        adding a new subclass with a field of the same name.\n+        \"\"\"\n+        Readable = ModelState('app', 'readable', [\n+            ('id', models.AutoField(primary_key=True)),\n+            ('title', models.CharField(max_length=200)),\n+        ])\n+        ReadableModified = ModelState('app', 'readable', [\n+            ('id', models.AutoField(primary_key=True)),\n+        ])\n+        Book = ModelState('app', 'book', [\n+            ('title', models.CharField(max_length=200)),\n+        ], bases=('app.readable',))\n+        \n+        before = [Readable]\n+        after = [ReadableModified, Book]\n+        \n+        changes = self.get_changes(before, after)\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['RemoveField', 'CreateModel'])\n+        self.assertOperationAttributes(changes, 'app', 0, 0, name='title', model_name='readable')\n+        self.assertOperationAttributes(changes, 'app', 0, 1, name='book')\n         Animal = ModelState('app', 'Animal', [\n             (\"id\", models.AutoField(primary_key=True)),\n         ])\n@@ -2453,4 +2475,4 @@ class AutodetectorTests(TestCase):\n         changes = self.get_changes([Animal, Dog], [Animal])\n         self.assertNumberMigrations(changes, 'app', 1)\n         self.assertOperationTypes(changes, 'app', 0, ['DeleteModel'])\n-        self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n+        self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n",
  "django__django-12774": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 057eac3..3065dfb 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -5,7 +5,9 @@ from operator import attrgetter\n \n from django.core.exceptions import FieldError\n from django.db import connection\n+from django.db import connection, models\n from django.db.models import Exists, Max, OuterRef\n+from django.test.utils import isolate_apps\n from django.db.models.functions import Substr\n from django.test import TestCase, skipUnlessDBFeature\n from django.utils.deprecation import RemovedInDjango40Warning\n@@ -179,7 +181,44 @@ class LookupTests(TestCase):\n         with self.assertNumQueries(expected_num_queries):\n             self.assertEqual(Author.objects.in_bulk(authors), authors)\n \n-    def test_in_bulk_with_field(self):\n+    def test_in_bulk_meta_constraint(self):\n+        # Setting up a unique constraint test\n+        season_2011 = Season.objects.create(year=2011)\n+        season_2012 = Season.objects.create(year=2012)\n+        Season.objects.create(year=2013)\n+        self.assertEqual(\n+            Season.objects.in_bulk(\n+                [season_2011.year, season_2012.year],\n+                field_name='year',\n+            ),\n+            {season_2011.year: season_2011, season_2012.year: season_2012},\n+        )\n+        \n+    @isolate_apps('lookup')\n+    def test_in_bulk_non_unique_meta_constaint(self):\n+        class Model(models.Model):\n+            ean = models.CharField(max_length=100)\n+            brand = models.CharField(max_length=100)\n+            name = models.CharField(max_length=80)\n+\n+            class Meta:\n+                constraints = [\n+                    models.UniqueConstraint(\n+                        fields=['ean'],\n+                        name='partial_ean_unique',\n+                        condition=models.Q(is_active=True)\n+                    ),\n+                    models.UniqueConstraint(\n+                        fields=['brand', 'name'],\n+                        name='together_brand_name_unique',\n+                    ),\n+                ]\n+\n+        msg = \"in_bulk()'s field_name must be a unique field but '%s' isn't.\"\n+        for field_name in ['brand', 'ean']:\n+            with self.subTest(field_name=field_name):\n+                with self.assertRaisesMessage(ValueError, msg % field_name):\n+                    Model.objects.in_bulk(field_name=field_name)\n         self.assertEqual(\n             Article.objects.in_bulk([self.a1.slug, self.a2.slug, self.a3.slug], field_name='slug'),\n             {\n",
  "django__django-12858": "diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 3b6974f..2ff358a 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -893,7 +893,32 @@ class OtherModelTests(SimpleTestCase):\n         with register_lookup(models.CharField, Lower):\n             self.assertEqual(Model.check(), [])\n \n-    def test_ordering_pointing_to_related_model_pk(self):\n+    def test_ordering_pointing_to_lookup_not_transform(self):\n+        class Model(models.Model):\n+            test = models.CharField(max_length=100)\n+\n+            class Meta:\n+                ordering = ('test__isnull',)\n+\n+        self.assertEqual(Model.check(), [])\n+\n+    def test_ordering_pointing_to_fk_related_lookup_isnull(self):\n+        \"\"\"\n+        Test ordering by isnull lookup over a ForeignKey relationship to ensure that no check error is raised.\n+        \"\"\"\n+        class Product(models.Model):\n+            parent = models.ForeignKey('self', models.CASCADE, null=True)\n+\n+        class Supply(models.Model):\n+            product = models.ForeignKey(Product, models.CASCADE)\n+\n+        class Stock(models.Model):\n+            supply = models.ForeignKey(Supply, models.CASCADE)\n+\n+            class Meta:\n+                ordering = ('supply__product__parent__isnull',)\n+\n+        self.assertEqual(Stock.check(), [])\n         class Parent(models.Model):\n             pass\n \n",
  "django__django-13012": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 87c0945..ce31f0a 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1821,10 +1821,36 @@ class CombinableTests(SimpleTestCase):\n         with self.assertRaisesMessage(NotImplementedError, self.bitwise_msg):\n             Combinable() | Combinable()\n \n-    def test_reversed_and(self):\n+class ExpressionWrapperTests(SimpleTestCase):\n+    def test_empty_group_by(self):\n+        expr = ExpressionWrapper(Value(3), output_field=IntegerField())\n+        self.assertEqual(expr.get_group_by_cols(alias=None), [])\n+\n+    def test_non_empty_group_by(self):\n+        expr = ExpressionWrapper(Lower(Value('f')), output_field=IntegerField())\n+        self.assertEqual(expr.get_group_by_cols(alias=None), [expr.expression])\n+\n+    def test_constant_value_not_in_group_by_for_query(self):\n+        # This test checks if using an ExpressionWrapper with a constant Value\n+        # correctly avoids putting the constant in the GROUP BY clause.\n+        expr = ExpressionWrapper(Value(3), output_field=IntegerField())\n+        queryset = Model.objects.annotate(expr_res=expr).values('expr_res', 'column_a').annotate(sum=Sum('column_b'))\n+        sql, params = queryset.query.sql_with_params()\n+        self.assertIn('GROUP BY \"model\".\"column_a\"', sql)\n+        self.assertNotIn('GROUP BY \"model\".\"column_a\", 3', sql)\n+\n+    def test_lower_expression_in_group_by_for_query(self):\n+        # This test checks if using an ExpressionWrapper with a functional expression,\n+        # such as Lower, correctly places the expression in the GROUP BY clause.\n+        expr = ExpressionWrapper(Lower(Value('f')), output_field=IntegerField())\n+        queryset = Model.objects.annotate(expr_res=expr).values('expr_res', 'column_a').annotate(sum=Sum('column_b'))\n+        sql, params = queryset.query.sql_with_params()\n+        # As Lower(Value('f')) is a dynamic expression, it may be included in GROUP BY\n+        self.assertIn('GROUP BY', sql)\n+        self.assertIn('LOWER', sql)\n         with self.assertRaisesMessage(NotImplementedError, self.bitwise_msg):\n             object() & Combinable()\n \n     def test_reversed_or(self):\n         with self.assertRaisesMessage(NotImplementedError, self.bitwise_msg):\n-            object() | Combinable()\n+            object() | Combinable()\n",
  "django__django-13028": "diff --git a/tests/queries/models.py b/tests/queries/models.py\nindex a43cfb4..c53651b 100644\n--- a/tests/queries/models.py\n+++ b/tests/queries/models.py\n@@ -69,6 +69,8 @@ class ExtraInfo(models.Model):\n     value = models.IntegerField(null=True)\n     date = models.ForeignKey(DateTimePK, models.SET_NULL, null=True)\n \n+    filterable = models.BooleanField(default=True)\n+\n     class Meta:\n         ordering = ['info']\n \n",
  "django__django-13033": "diff --git a/tests/ordering/models.py b/tests/ordering/models.py\nindex ec1f9e4..f499e56 100644\n--- a/tests/ordering/models.py\n+++ b/tests/ordering/models.py\n@@ -6,6 +6,18 @@ should be a list or tuple of field names. This tells Django how to order\n ``QuerySet`` results.\n \n If a field name in ``ordering`` starts with a hyphen, that field will be\n+class OneModel(models.Model):\n+    class Meta:\n+        ordering = (\"-id\",)\n+    id = models.BigAutoField(primary_key=True)\n+    root = models.ForeignKey(\"OneModel\", on_delete=models.CASCADE, null=True)\n+    oneval = models.BigIntegerField(null=True)\n+\n+class TwoModel(models.Model):\n+    id = models.BigAutoField(primary_key=True)\n+    record = models.ForeignKey(OneModel, on_delete=models.CASCADE)\n+    twoval = models.BigIntegerField(null=True)\n+\n ordered in descending order. Otherwise, it'll be ordered in ascending order.\n The special-case field name ``\"?\"`` specifies random order.\n \n",
  "django__django-13089": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex e11856f..73cee73 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -608,7 +608,33 @@ class BaseCacheTests:\n         # causing a cull.\n         for i in range(1, initial_count):\n             cull_cache.set('cull%d' % i, 'value', 1000)\n+        import datetime\n+        from django.core.cache import caches\n+        from django.core.cache.backends.base import InvalidCacheBackendError\n+        from django.test import TestCase\n+\n         count = 0\n+\n+        class CullCacheTests(TestCase):\n+            def test_cull_handles_empty_result(self):\n+                try:\n+                    cull_cache = caches['cull']\n+                except InvalidCacheBackendError:\n+                    self.skipTest(\"Culling isn't implemented.\")\n+\n+                with self.settings(CACHE_MAX_ENTRIES=1):\n+                    # Simulate expiry of all items to ensure `_cull` fetches none.\n+                    cull_cache.set('expired_key', 'value', timeout=-1)  # Set timeout in the past.\n+\n+                    # Verify using internal methods if possible or if the cache\n+                    # backend exposes the ability to test specifics\n+                    with cull_cache._cache.cursor() as cursor:\n+                        # Ensure cursor returns no results for fetchone in _cull\n+                        cursor.execute(\"DELETE FROM %s WHERE cache_key < %%s\" % cull_cache._table, [datetime.datetime.now()])\n+                        cull_cache._cull(cull_cache._db, cursor, datetime.datetime.now())\n+                \n+                # Check if operation completes without error\n+                self.assertIsNone(cull_cache.get('expired_key'))\n         # Count how many keys are left in the cache.\n         for i in range(1, initial_count):\n             if cull_cache.has_key('cull%d' % i):\n",
  "django__django-13109": "",
  "django__django-13112": "diff --git a/tests/migrations/test_state.py b/tests/migrations/test_state.py\nindex 081eff8..6c77b66 100644\n--- a/tests/migrations/test_state.py\n+++ b/tests/migrations/test_state.py\n@@ -867,7 +867,32 @@ class StateTests(SimpleTestCase):\n         with self.assertRaisesMessage(ValueError, msg):\n             project_state.apps\n \n-    def test_real_apps(self):\n+    def test_foreign_key_with_mixed_case_app_name(self):\n+        \"\"\"\n+        Test that a ForeignKey referencing a model from a mixed-case app name resolves correctly.\n+        \"\"\"\n+        new_apps = Apps()\n+\n+        class Category(models.Model):\n+            title = models.CharField(max_length=100)\n+\n+            class Meta:\n+                app_label = 'MiXeDCasE_AppName'\n+                apps = new_apps\n+\n+        class Content(models.Model):\n+            category = models.ForeignKey(Category, models.CASCADE)\n+\n+            class Meta:\n+                app_label = 'MiXeDCasE_AppName'\n+                apps = new_apps\n+\n+        project_state = ProjectState()\n+        project_state.add_model(ModelState.from_model(Category))\n+        project_state.add_model(ModelState.from_model(Content))\n+        \n+        # Assert that both models are correctly recognized\n+        self.assertEqual(len(project_state.apps.get_models()), 2)\n         \"\"\"\n         Including real apps can resolve dangling FK errors.\n         This test relies on the fact that contenttypes is always loaded.\n",
  "django__django-13121": "",
  "django__django-13128": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 82e96fa..bff0fb8 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1618,7 +1618,15 @@ class FTimeDeltaTests(TestCase):\n         self.assertTrue(queryset.exists())\n \n     @skipUnlessDBFeature('supports_temporal_subtraction')\n-    def test_datetime_subtraction_microseconds(self):\n+    def test_temporal_subtraction_without_expression_wrapper(self):\n+        \"\"\"\n+        Test temporal subtraction between DateTimeField fields without using ExpressionWrapper.\n+        Verify that the result is a DurationField.\n+        \"\"\"\n+        Experiment.objects.create(name='test_experiment', start=datetime.datetime(2023, 1, 1, 12, 0, 0), end=datetime.datetime(2023, 1, 2, 12, 0, 0))\n+        queryset = Experiment.objects.annotate(delta=F('end') - F('start'))\n+        for e in queryset:\n+            self.assertEqual(e.delta, datetime.timedelta(days=1))\n         delta = datetime.timedelta(microseconds=8999999999999999)\n         Experiment.objects.update(end=F('start') + delta)\n         qs = Experiment.objects.annotate(\n",
  "django__django-13158": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 070e08e..fc4d68f 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -1,5 +1,8 @@\n import operator\n \n+from django.forms import ModelForm\n+from .models import Number\n+\n from django.db import DatabaseError, NotSupportedError, connection\n from django.db.models import Exists, F, IntegerField, OuterRef, Value\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n@@ -39,7 +42,12 @@ class QuerySetSetOperationTests(TestCase):\n         reserved_name = qs1.intersection(qs1).values_list('name', 'order', 'id').get()\n         self.assertEqual(reserved_name[:2], ('a', 2))\n \n-    @skipUnlessDBFeature('supports_select_difference')\n+    def test_union_none(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.filter(num__gte=8)\n+        qs3 = qs1.union(qs2)\n+        self.assertNumbersEqual(qs3.none(), [], ordered=False)\n+        self.assertNumbersEqual(qs3, [0, 1, 8, 9], ordered=False)\n     def test_simple_difference(self):\n         qs1 = Number.objects.filter(num__lte=5)\n         qs2 = Number.objects.filter(num__lte=4)\n",
  "django__django-13279": "diff --git a/tests/sessions_tests/tests.py b/tests/sessions_tests/tests.py\nindex e3a089f..190d605 100644\n--- a/tests/sessions_tests/tests.py\n+++ b/tests/sessions_tests/tests.py\n@@ -34,6 +34,7 @@ from django.test import (\n     RequestFactory, TestCase, ignore_warnings, override_settings,\n )\n from django.utils import timezone\n+from django.utils.deprecation import RemovedInDjango40Warning\n \n from .models import SessionStore as CustomDatabaseSession\n \n@@ -323,6 +324,13 @@ class SessionTestsMixin:\n             {'a test key': 'a test value'},\n         )\n \n+    @ignore_warnings(category=RemovedInDjango40Warning)\n+    @override_settings(DEFAULT_HASHING_ALGORITHM='sha1')\n+    def test_default_hashing_algorithm_legacy_decode(self):\n+        data = {'a test key': 'a test value'}\n+        encoded = self.session.encode(data)\n+        self.assertEqual(self.session._legacy_decode(encoded), data)\n+\n     def test_decode_failure_logged_to_security(self):\n         bad_encode = base64.b64encode(b'flaskdj:alkdjf').decode('ascii')\n         with self.assertLogs('django.security.SuspiciousSession', 'WARNING') as cm:\n",
  "django__django-13297": "diff --git a/tests/generic_views/test_base.py b/tests/generic_views/test_base.py\nindex 26c885d..7803e97 100644\n--- a/tests/generic_views/test_base.py\n+++ b/tests/generic_views/test_base.py\n@@ -11,6 +11,8 @@ from django.utils.deprecation import RemovedInDjango40Warning\n from django.views.generic import RedirectView, TemplateView, View\n \n from . import views\n+from .models import Artist\n+from django.shortcuts import get_object_or_404\n \n \n class SimpleView(View):\n@@ -590,7 +592,26 @@ class DeprecationTests(SimpleTestCase):\n         self.assertEqual(response.context['key'], 'value')\n         self.assertIsInstance(response.context['view'], View)\n \n-    def test_template_params_warning(self):\n+    @ignore_warnings(category=RemovedInDjango40Warning)\n+    def test_template_params_filtering(self):\n+        \"\"\"Test handling of SimpleLazyObject in TemplateView.get_context_data().\"\"\"\n+        class OfferView(TemplateView):\n+            template_name = \"offers/offer.html\"\n+\n+            def get_context_data(self, **kwargs):\n+                offer_slug = kwargs.get(\"offer_slug\", \"\")\n+                offer = get_object_or_404(Artist, slug=str(offer_slug))\n+                return {\"offer\": offer, \"offer_slug\": offer_slug}\n+\n+        # Create an Artist object to simulate the 'Account'\n+        artist = Artist.objects.create(name='Rene Magritte', slug='rene-magritte')\n+\n+        # Simulate a request to the OfferView with URL kwargs\n+        response = OfferView.as_view()(self.client.get('/offers/rene-magritte/'))\n+\n+        # Check that the context is correctly set\n+        self.assertEqual(response.context_data['offer'], artist)\n+        self.assertEqual(response.context_data['offer_slug'], 'rene-magritte')\n         response = self.client.get('/template/custom/bar1/bar2/')\n         self.assertEqual(response.status_code, 200)\n         msg = (\n",
  "django__django-13315": "",
  "django__django-13343": "diff --git a/tests/file_storage/tests.py b/tests/file_storage/tests.py\nindex a5ab3a0..c6cbe24 100644\n--- a/tests/file_storage/tests.py\n+++ b/tests/file_storage/tests.py\n@@ -29,7 +29,7 @@ from django.test.utils import requires_tz_support\n from django.urls import NoReverseMatch, reverse_lazy\n from django.utils import timezone\n \n-from .models import Storage, temp_storage, temp_storage_location\n+from .models import Storage, callable_storage, temp_storage, temp_storage_location\n \n FILE_SUFFIX_REGEX = '[A-Za-z0-9]{7}'\n \n@@ -905,8 +905,17 @@ class FieldCallableFileStorageTests(SimpleTestCase):\n \n         obj = FileField(storage=GetStorage)\n         self.assertIsInstance(obj.storage, BaseStorage)\n-\n-    def test_callable_storage_file_field_in_model(self):\n+    def test_filefield_callable_storage_deconstruction(self):\n+        \"\"\"\n+        Verifies that a FileField with a callable storage parameter\n+        deconstructs to reference the callable itself, not the evaluated storage.\n+        \"\"\"\n+        obj = Storage()\n+        # Deconstruct the field to extract the storage argument\n+        *_, kwargs = obj._meta.get_field('storage_callable').deconstruct()\n+        storage = kwargs['storage']\n+        # Assert it points to callable_storage and not the evaluated value\n+        self.assertIs(storage, callable_storage)\n         obj = Storage()\n         self.assertEqual(obj.storage_callable.storage, temp_storage)\n         self.assertEqual(obj.storage_callable.storage.location, temp_storage_location)\n",
  "django__django-13346": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex b918d5c..1c97241 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -623,7 +623,20 @@ class TestQuerying(TestCase):\n                     expected,\n                 )\n \n-    def test_key_iexact(self):\n+    def test_key_in_on_jsonfield(self):\n+        # Add test cases to verify the `__in` lookup on models.JSONField\n+        test_data = [\n+            ('our_field__key__in', [0], []),  # expecting empty when using `__in`\n+            ('our_field__key__in', [0, 1], []),  # mixed values\n+            ('our_field__key', 0, [self.objs[0], self.objs[1]]),  # direct equality test\n+        ]\n+        \n+        for lookup, value, expected in test_data:\n+            with self.subTest(lookup=lookup, value=value):\n+                self.assertSequenceEqual(\n+                    OurModel.objects.filter(**{lookup: value}),\n+                    expected,\n+                )\n         self.assertIs(NullableJSONModel.objects.filter(value__foo__iexact='BaR').exists(), True)\n         self.assertIs(NullableJSONModel.objects.filter(value__foo__iexact='\"BaR\"').exists(), False)\n \n",
  "django__django-13363": "diff --git a/tests/db_functions/datetime/test_extract_trunc.py b/tests/db_functions/datetime/test_extract_trunc.py\nindex 82d5e36..3f324fb 100644\n--- a/tests/db_functions/datetime/test_extract_trunc.py\n+++ b/tests/db_functions/datetime/test_extract_trunc.py\n@@ -19,6 +19,8 @@ from django.test import (\n )\n from django.utils import timezone\n \n+import pytz\n+from datetime import datetime\n from ..models import Author, DTModel, Fan\n \n \n",
  "django__django-13401": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex e39d03e..6cb893a 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -103,6 +103,61 @@ class BasicFieldTests(SimpleTestCase):\n         self.assertEqual(path, 'model_fields.tests.Nested.Field')\n \n \n+from django.test import SimpleTestCase\n+from django.db import models\n+\n+class AbstractFieldEqualityTests(SimpleTestCase):\n+    def test_abstract_inherited_fields_equality(self):\n+        \"\"\"\n+        Ensure fields from different models inheriting the same abstract model\n+        are not equal.\n+        \"\"\"\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritModel1(AbstractModel):\n+            pass\n+\n+        class InheritModel2(AbstractModel):\n+            pass\n+\n+        field1 = InheritModel1._meta.get_field('field')\n+        field2 = InheritModel2._meta.get_field('field')\n+\n+        # Fields should not be considered equal\n+        self.assertNotEqual(field1, field2)\n+        # Test hashes are different\n+        self.assertNotEqual(hash(field1), hash(field2))\n+\n+        # Less than should compare by creation_counter if models are the same,\n+        # but they should never be the same here since models are different\n+        self.assertNotEqual(field1.creation_counter, field2.creation_counter)\n+\n+    def test_field_ordering(self):\n+        \"\"\"\n+        Ensure fields from different models do not interfere in ordering.\n+        \"\"\"\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritModel1(AbstractModel):\n+            pass\n+\n+        class InheritModel2(AbstractModel):\n+            pass\n+\n+        field1 = InheritModel1._meta.get_field('field')\n+        field2 = InheritModel2._meta.get_field('field')\n+\n+        # Test ordering by creation_counter\n+        self.assertLess(field1.creation_counter, field2.creation_counter) if field1.creation_counter < field2.creation_counter else self.assertGreater(field1.creation_counter, field2.creation_counter)\n+\n class ChoicesTests(SimpleTestCase):\n \n     @classmethod\n",
  "django__django-13410": "diff --git a/tests/files/tests.py b/tests/files/tests.py\nindex 1285e22..8735f5e 100644\n--- a/tests/files/tests.py\n+++ b/tests/files/tests.py\n@@ -1,3 +1,56 @@\n+\n+class FileLockTestCase(unittest.TestCase):\n+    def test_exclusive_lock(self):\n+        # Create a temporary file for testing\n+        temp_file = tempfile.NamedTemporaryFile(delete=False)\n+        temp_file.close()  # Close the file handle as we will open it later\n+\n+        try:\n+            with open(temp_file.name, 'rb+') as f1, open(temp_file.name, 'rb+') as f2:\n+                self.assertIs(locks.lock(f1, locks.LOCK_EX), True)\n+                self.assertIs(locks.lock(f2, locks.LOCK_EX | locks.LOCK_NB), False)\n+                self.assertIs(locks.lock(f2, locks.LOCK_SH | locks.LOCK_NB), False)\n+                self.assertIs(locks.unlock(f1), True)\n+        finally:\n+            os.remove(temp_file.name)\n+\n+    def test_shared_lock(self):\n+        # Create a temporary file for testing\n+        temp_file = tempfile.NamedTemporaryFile(delete=False)\n+        temp_file.close()  # Close the file handle as we will open it later\n+\n+        try:\n+            with open(temp_file.name, 'rb+') as f1, open(temp_file.name, 'rb+') as f2:\n+                self.assertIs(locks.lock(f1, locks.LOCK_SH), True)\n+                self.assertIs(locks.lock(f2, locks.LOCK_SH | locks.LOCK_NB), True)\n+                self.assertIs(locks.unlock(f1), True)\n+                self.assertIs(locks.unlock(f2), True)\n+        finally:\n+            os.remove(temp_file.name)\n+\n+    def test_unlock_without_locking(self):\n+        # Test unlocking a file that was never locked\n+        temp_file = tempfile.NamedTemporaryFile(delete=False)\n+        temp_file.close()\n+\n+        try:\n+            with open(temp_file.name, 'rb+') as f:\n+                self.assertIs(locks.unlock(f), True)\n+        finally:\n+            os.remove(temp_file.name)\n+\n+    def test_lock_and_unlock_exclusively(self):\n+        # Test locking and unlocking a file exclusively\n+        temp_file = tempfile.NamedTemporaryFile(delete=False)\n+        temp_file.close()\n+\n+        try:\n+            with open(temp_file.name, 'rb+') as f:\n+                self.assertIs(locks.lock(f, locks.LOCK_EX), True)\n+                self.assertIs(locks.unlock(f), True)\n+        finally:\n+            os.remove(temp_file.name)\n+\n import errno\n import gzip\n import os\n@@ -6,7 +59,8 @@ import tempfile\n import unittest\n from io import BytesIO, StringIO, TextIOWrapper\n from pathlib import Path\n-from unittest import mock\n+from django.core.files import locks\n+from pathlib import Path\n \n from django.core.files import File\n from django.core.files.base import ContentFile\n",
  "django__django-13417": "diff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex 8130de5..9a4ed35 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -2076,6 +2076,32 @@ class QuerysetOrderedTests(unittest.TestCase):\n     def test_empty_queryset(self):\n         self.assertIs(Annotation.objects.none().ordered, True)\n \n+    def test_annotated_default_ordering_group_by(self):\n+        # Ensure ordered is False since GROUP BY should not enforce ordering\n+        qs = Annotation.objects.annotate(num_notes=Count('notes'))\n+        self.assertIs(qs.ordered, False)\n+        \n+    def test_annotated_values_default_ordering(self):\n+        # Ensure ordered is False since GROUP BY should not enforce ordering\n+        qs = Annotation.objects.values('name').annotate(num_notes=Count('notes'))\n+        self.assertIs(qs.ordered, False)\n+\n+    def test_annotated_ordering_with_explicit_order_by(self):\n+        # Ensure ordered is True when explicitly ordering\n+        qs = Annotation.objects.annotate(num_notes=Count('notes')).order_by('name')\n+        self.assertIs(qs.ordered, True)\n+\n+    def test_default_ordering_with_order_by(self):\n+        # Ensure ordered is True when explicitly using order_by\n+        qs = Annotation.objects.all()\n+        self.assertIs(qs.ordered, True)\n+        self.assertIs(qs.order_by('name').ordered, True)\n+\n+    def test_annotated_no_group_by(self):\n+        # Test annotate without GROUP BY shouldn't affect default ordering\n+        qs = Annotation.objects.annotate(some_field=F('notes') * 2)\n+        self.assertIs(qs.ordered, True)\n+\n     def test_order_by_extra(self):\n         self.assertIs(Annotation.objects.all().extra(order_by=['id']).ordered, True)\n \n",
  "django__django-13516": "",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..47ff118 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,3 +1,4 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n@@ -16,8 +17,31 @@ class MockedPasswordResetTokenGenerator(PasswordResetTokenGenerator):\n     def _now(self):\n         return self._now_val\n \n+from .with_custom_email_field import CustomEmailField\n+from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from .models import CustomEmailField\n \n class TokenGeneratorTest(TestCase):\n+    def test_token_with_different_email(self):\n+        \"\"\"Updating the user email address invalidates the token.\"\"\"\n+        tests = [\n+            (CustomEmailField, None),\n+            (CustomEmailField, 'test4@example.com'),\n+            (User, 'test4@example.com'),\n+        ]\n+        for model, email in tests:\n+            with self.subTest(model=model.__qualname__, email=email):\n+                user = model.objects.create_user(\n+                    'changeemailuser',\n+                    email=email,\n+                    password='testpw',\n+                )\n+                p0 = PasswordResetTokenGenerator()\n+                tk1 = p0.make_token(user)\n+                self.assertIs(p0.check_token(user, tk1), True)\n+                setattr(user, user.get_email_field_name(), 'test4new@example.com')\n+                user.save()\n+                self.assertIs(p0.check_token(user, tk1), False)\n \n     def test_make_token(self):\n         user = User.objects.create_user('tokentestuser', 'test2@example.com', 'testpw')\n",
  "django__django-13568": "diff --git a/tests/auth_tests/test_checks.py b/tests/auth_tests/test_checks.py\nindex c47b5c2..89cbce4 100644\n--- a/tests/auth_tests/test_checks.py\n+++ b/tests/auth_tests/test_checks.py\n@@ -1,8 +1,10 @@\n+\n from django.contrib.auth.checks import (\n     check_models_permissions, check_user_model,\n )\n from django.contrib.auth.models import AbstractBaseUser\n from django.core import checks\n+from django.db.models import Q, UniqueConstraint\n from django.db import models\n from django.test import (\n     SimpleTestCase, override_settings, override_system_checks,\n@@ -138,6 +140,20 @@ class ModelsPermissionsChecksTests(SimpleTestCase):\n             ),\n         ])\n \n+    @override_settings(AUTH_USER_MODEL='auth_tests.UserUniqueConstraint')\n+    def test_username_with_total_unique_constraint(self):\n+        class UserUniqueConstraint(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            USERNAME_FIELD = 'username'\n+\n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(fields=['username'], name='username_totally_unique'),\n+                ]\n+\n+        errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+        self.assertEqual(errors, [])\n+\n     def test_non_clashing_custom_permissions(self):\n         class Checked(models.Model):\n             class Meta:\n",
  "django__django-13569": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex a44d0b6..3e21035 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1310,8 +1310,39 @@ class AggregateTestCase(TestCase):\n             contact_publisher__isnull=False,\n         ).annotate(count=Count('authors'))\n         self.assertSequenceEqual(books_qs, [book])\n+\n+    def test_aggregation_random_ordering(self):\n+        \"\"\"Test that Random() is not included in the GROUP BY when used for ordering, and does not affect aggregates.\"\"\"\n+        things = Thing.objects.annotate(related_count=Count('related')).order_by('?')\n+        self.assertQuerysetEqual(\n+            things, \n+            [\n+                {'id': things[0].id, 'related_count': 2}\n+            ],\n+            lambda a: {'id': a.id, 'related_count': a.related_count},\n+            ordered=False\n+        )\n+\n+    def test_aggregation_order_by_aggregation(self):\n+        \"\"\"Test that ordering by the aggregation works as expected.\"\"\"\n+        things = Thing.objects.annotate(related_count=Count('related')).order_by('related_count')\n+        self.assertQuerysetEqual(\n+            things, \n+            [{'id': 1, 'related_count': 2}],\n+            lambda a: {'id': a.id, 'related_count': a.related_count}\n+        )\n+\n+    def test_aggregation_order_by_related_field(self):\n+        \"\"\"Test that ordering by a related field breaks down the aggregation.\"\"\"\n+        things = Thing.objects.annotate(related_count=Count('related')).order_by('related')\n+        self.assertQuerysetEqual(\n+            things, \n+            [{'id': 1, 'related_count': 1}, {'id': 1, 'related_count': 1}],\n+            lambda a: {'id': a.id, 'related_count': a.related_count},\n+            ordered=False\n+        )\n         # FIXME: GROUP BY doesn't need to include a subquery with\n         # non-multivalued JOINs, see Col.possibly_multivalued (refs #31150):\n         # with self.assertNumQueries(1) as ctx:\n         #     self.assertSequenceEqual(books_qs, [book])\n-        # self.assertEqual(ctx[0]['sql'].count('SELECT'), 2)\n+        # self.assertEqual(ctx[0]['sql'].count('SELECT'), 2)\n",
  "django__django-13590": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 0b4f73f..26160d5 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import pickle\n import unittest\n@@ -815,7 +816,13 @@ class IterableLookupInnerExpressionsTests(TestCase):\n         Company.objects.create(name='5060 Ltd', num_employees=50, num_chairs=60, ceo=ceo)\n         Company.objects.create(name='99300 Ltd', num_employees=99, num_chairs=300, ceo=ceo)\n \n-    def test_in_lookup_allows_F_expressions_and_expressions_for_integers(self):\n+    def test_range_lookup_namedtuple(self):\n+        from collections import namedtuple\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=51, maximum=100),\n+        )\n+        self.assertSequenceEqual(qs, [Company.objects.get(name='99300 Ltd')])\n         # __in lookups can use F() expressions for integers.\n         queryset = Company.objects.filter(num_employees__in=([F('num_chairs') - 10]))\n         self.assertQuerysetEqual(queryset, ['<Company: 5060 Ltd>'], ordered=False)\n",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..0d18458 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -16,6 +16,8 @@ from unittest import mock\n \n from django import conf, get_version\n from django.conf import settings\n+from io import StringIO\n+from unittest import mock\n from django.core.management import (\n     BaseCommand, CommandError, call_command, color,\n )\n@@ -28,10 +30,47 @@ from django.core.management.commands.testserver import (\n )\n from django.db import ConnectionHandler, connection\n from django.db.migrations.recorder import MigrationRecorder\n+from django.test.utils import captured_stderr, captured_stdout\n from django.test import (\n     LiveServerTestCase, SimpleTestCase, TestCase, override_settings,\n )\n \n+class ExecuteFromCommandLine(SimpleTestCase):\n+    def test_program_name_from_argv(self):\n+        \"\"\"\n+        Program name is computed from the execute_from_command_line()'s argv\n+        argument, not sys.argv.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line(['django-admin'] + args)\n+        self.assertIn('usage: django-admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+        \n+    def test_no_argv_provided(self):\n+        \"\"\"\n+        Ensure that when no argv is provided to execute_from_command_line(),\n+        it defaults to using sys.argv properly.\n+        \"\"\"\n+        args = ['help', 'check']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['django-admin', 'help', 'check']):\n+                execute_from_command_line(None)\n+        self.assertIn('usage: django-admin check', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_custom_prog_name(self):\n+        \"\"\"\n+        Test that a custom program name can be used instead of sys.argv[0].\n+        \"\"\"\n+        args = ['help', 'migrate']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            execute_from_command_line(['my-custom-admin'] + args)\n+        self.assertIn('usage: my-custom-admin migrate', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+\n custom_templates_dir = os.path.join(os.path.dirname(__file__), 'custom_templates')\n \n SYSTEM_CHECK_MSG = 'System check identified no issues'\n",
  "django__django-13670": "diff --git a/tests/utils_tests/test_dateformat.py b/tests/utils_tests/test_dateformat.py\nindex 6f0b13f..b11b283 100644\n--- a/tests/utils_tests/test_dateformat.py\n+++ b/tests/utils_tests/test_dateformat.py\n@@ -1,4 +1,6 @@\n+\n from datetime import date, datetime\n+from django.utils import dateformat\n \n from django.test import SimpleTestCase, override_settings\n from django.test.utils import TZ_SUPPORT, requires_tz_support\n@@ -164,4 +166,4 @@ class DateFormatTests(SimpleTestCase):\n             self.assertEqual(\n                 dateformat.format(dt, 'r'),\n                 'Sun, 08 Jul 1979 22:00:00 +0100',\n-            )\n+            )\n",
  "django__django-13741": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex ca66cd5..98dcef1 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1020,6 +1020,10 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n             \"\"\"\n         )\n \n+    def test_readonly_password_hash_field_disabled(self):\n+        field = ReadOnlyPasswordHashField()\n+        self.assertIs(field.disabled, True)\n+\n     def test_readonly_field_has_changed(self):\n         field = ReadOnlyPasswordHashField()\n         self.assertFalse(field.has_changed('aaa', 'bbb'))\n",
  "django__django-13786": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 3782589..9568fa8 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -119,6 +119,25 @@ class OptimizerTests(SimpleTestCase):\n             ]\n         )\n \n+    def test_create_model_options_clearing(self):\n+        \"\"\"\n+        Test that combining CreateModel with AlterModelOptions with empty options\n+        results in a CreateModel without options.\n+        \"\"\"\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\n+                    'MyModel',\n+                    fields=[],\n+                    options={'verbose_name': 'My Model', 'ordering': ['id']},\n+                ),\n+                migrations.AlterModelOptions('MyModel', options={}),\n+            ],\n+            [\n+                migrations.CreateModel('MyModel', fields=[]),\n+            ]\n+        )\n+\n     def _test_create_alter_foo_delete_model(self, alter_foo):\n         \"\"\"\n         CreateModel, AlterModelTable, AlterUniqueTogether/AlterIndexTogether/\n@@ -134,6 +153,25 @@ class OptimizerTests(SimpleTestCase):\n             [],\n         )\n \n+    def test_create_model_options_clearing(self):\n+        \"\"\"\n+        Test that combining CreateModel with AlterModelOptions with empty options\n+        results in a CreateModel without options.\n+        \"\"\"\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\n+                    'MyModel',\n+                    fields=[],\n+                    options={'verbose_name': 'My Model', 'ordering': ['id']},\n+                ),\n+                migrations.AlterModelOptions('MyModel', options={}),\n+            ],\n+            [\n+                migrations.CreateModel('MyModel', fields=[]),\n+            ]\n+        )\n+\n     def test_create_alter_unique_delete_model(self):\n         self._test_create_alter_foo_delete_model(migrations.AlterUniqueTogether(\"Foo\", [[\"a\", \"b\"]]))\n \n",
  "django__django-13794": "diff --git a/tests/template_tests/filter_tests/test_add.py b/tests/template_tests/filter_tests/test_add.py\nindex 7ba4955..68d27b0 100644\n--- a/tests/template_tests/filter_tests/test_add.py\n+++ b/tests/template_tests/filter_tests/test_add.py\n@@ -1,6 +1,8 @@\n+\n from datetime import date, timedelta\n \n from django.template.defaultfilters import add\n+from django.utils.translation import gettext_lazy, lazy\n from django.test import SimpleTestCase\n \n from ..utils import setup\n@@ -47,6 +49,27 @@ class AddTests(SimpleTestCase):\n         self.assertEqual(output, 'Jan. 11, 2000')\n \n \n+    @setup({'add08': '{{ s1|add:lazy_s2 }}'})\n+    def test_add08(self):\n+        output = self.engine.render_to_string(\n+            'add08',\n+            {'s1': 'string', 'lazy_s2': gettext_lazy('lazy')},\n+        )\n+        self.assertEqual(output, 'stringlazy')\n+\n+    @setup({'add09': '{{ lazy_s1|add:lazy_s2 }}'})\n+    def test_add09(self):\n+        output = self.engine.render_to_string(\n+            'add09',\n+            {'lazy_s1': gettext_lazy('string'), 'lazy_s2': gettext_lazy('lazy')},\n+        )\n+        self.assertEqual(output, 'stringlazy')\n+\n+    def test_lazy_add(self):\n+        lazy_4 = lazy(lambda: 4, int)\n+        lazy_5 = lazy(lambda: 5, int)\n+        self.assertEqual(lazy_4() + lazy_5(), 9)\n+\n class FunctionTests(SimpleTestCase):\n \n     def test_add(self):\n",
  "django__django-13807": "diff --git a/tests/backends/tests.py b/tests/backends/tests.py\nindex 0aee2b6..fba33b8 100644\n--- a/tests/backends/tests.py\n+++ b/tests/backends/tests.py\n@@ -18,14 +18,30 @@ from django.test import (\n     skipUnlessDBFeature,\n )\n \n+from django.db import IntegrityError, connection, transaction\n from .models import (\n     Article, Object, ObjectReference, Person, Post, RawData, Reporter,\n-    ReporterProxy, SchoolClass, Square,\n+    ReporterProxy, SchoolClass, Square, SQLKeywordsModel,\n     VeryLongModelNameZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ,\n )\n \n \n-class DateQuotingTest(TestCase):\n+class SQLKeywordTableNameTest(TransactionTestCase):\n+\n+    available_apps = ['backends']\n+\n+    def test_loaddata_with_sql_keyword_as_table_name(self):\n+        \"\"\"\n+        Test that `loaddata` works for models where the table name is an\n+        SQL keyword.\n+        \"\"\"\n+        with connection.cursor() as cursor:\n+            cursor.execute('INSERT INTO \"order\" (\"select\", \"where\") VALUES (?, ?)', [1, 1])\n+        \n+        with transaction.atomic():\n+            obj = SQLKeywordsModel.objects.get(pk=1)\n+            self.assertIsNotNone(obj)\n+            self.assertEqual(obj.id, 1)\n \n     def test_django_date_trunc(self):\n         \"\"\"\n",
  "django__django-13809": "",
  "django__django-13810": "",
  "django__django-13820": "",
  "django__django-13821": "diff --git a/tests/backends/sqlite/tests.py b/tests/backends/sqlite/tests.py\nindex e602447..8b49717 100644\n--- a/tests/backends/sqlite/tests.py\n+++ b/tests/backends/sqlite/tests.py\n@@ -10,6 +10,9 @@ from unittest import mock\n from django.core.exceptions import ImproperlyConfigured\n from django.db import NotSupportedError, connection, transaction\n from django.db.models import Aggregate, Avg, CharField, StdDev, Sum, Variance\n+from unittest import mock\n+from django.core.exceptions import ImproperlyConfigured\n+from django.db.backends.sqlite3.base import Database as dbapi2\n from django.db.utils import ConnectionHandler\n from django.test import (\n     TestCase, TransactionTestCase, override_settings, skipIfDBFeature,\n@@ -36,7 +39,19 @@ class Tests(TestCase):\n                 self.assertRaisesMessage(ImproperlyConfigured, msg):\n             check_sqlite_version()\n \n-    def test_aggregation(self):\n+    def test_check_sqlite_version_above_required(self):\n+        msg = 'SQLite 3.9.0 or later is required (found 3.9.1).'\n+        with mock.patch.object(dbapi2, 'sqlite_version_info', (3, 9, 1)), \\\n+                mock.patch.object(dbapi2, 'sqlite_version', '3.9.1'):\n+            # This should pass without an error\n+            check_sqlite_version()\n+\n+    def test_check_sqlite_version_below_required(self):\n+        msg = 'SQLite 3.9.0 or later is required (found 3.8.11.1).'\n+        with mock.patch.object(dbapi2, 'sqlite_version_info', (3, 8, 11, 1)), \\\n+                mock.patch.object(dbapi2, 'sqlite_version', '3.8.11.1'), \\\n+                self.assertRaisesMessage(ImproperlyConfigured, msg):\n+            check_sqlite_version()\n         \"\"\"Raise NotSupportedError when aggregating on date/time fields.\"\"\"\n         for aggregate in (Sum, Avg, Variance, StdDev):\n             with self.assertRaises(NotSupportedError):\n",
  "django__django-13837": "",
  "django__django-13925": "",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..be1e9dc 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -282,6 +282,11 @@ class FormsErrorMessagesTestCase(SimpleTestCase, AssertFormErrorsMixin):\n         )\n \n \n+from django.test import TestCase\n+from django.forms import ModelChoiceField, ModelMultipleChoiceField\n+from .models import ChoiceModel\n+from .mixins import AssertFormErrorsMixin\n+\n class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n     def test_modelchoicefield(self):\n         # Create choices for the model choice field tests below.\n@@ -297,8 +302,14 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['INVALID CHOICE'], f.clean, '4')\n-\n-        # ModelMultipleChoiceField\n+        # ModelChoiceField with value in the error message\n+        f = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            }\n+        )\n+        self.assertFormErrors(['\"4\" is not one of the available choices.'], f.clean, '4')\n         e = {\n             'required': 'REQUIRED',\n             'invalid_choice': '%(value)s IS INVALID CHOICE',\n@@ -307,4 +318,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "diff --git a/tests/many_to_one/tests.py b/tests/many_to_one/tests.py\nindex 8af1b8e..9e5cb43 100644\n--- a/tests/many_to_one/tests.py\n+++ b/tests/many_to_one/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n from copy import deepcopy\n \n@@ -549,7 +550,36 @@ class ManyToOneTests(TestCase):\n         self.assertEqual(child.parent, parent)\n         self.assertEqual(child.parent_id, parent.name)\n \n-    def test_fk_to_bigautofield(self):\n+    def test_save_fk_after_parent_with_unsaved_non_numeric_pk(self):\n+        # Test scenario where the primary key is set after creating the parent object\n+        parent = ParentStringPrimaryKey()\n+        child = ChildStringPrimaryKeyParent(parent=parent)\n+        parent.save()  # Saving the parent without a PK should not be done in practice\n+        child.save()\n+        child.refresh_from_db()\n+        self.assertEqual(child.parent_id, parent.name)\n+\n+    def test_save_fk_when_primary_key_set_before_assignment(self):\n+        # Test correct behavior when primary key is set before assigning the parent\n+        parent = ParentStringPrimaryKey(name='correct_key')\n+        parent.save()\n+        child = ChildStringPrimaryKeyParent(parent=parent)\n+        child.save()\n+        child.refresh_from_db()\n+        self.assertEqual(child.parent_id, parent.name)\n+\n+    def test_save_fk_after_primary_key_set_later_in_tx(self):\n+        # Simulating the original issue: setting the primary key after the parent assignment\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey()\n+            child = ChildStringPrimaryKeyParent(parent=parent)\n+            parent.name = 'delayed_key'\n+            parent.save()\n+            child.save()\n+\n+        # Reloading child should give us the parent correctly due to transaction commit.\n+        child.refresh_from_db()\n+        self.assertEqual(child.parent_id, 'delayed_key')\n         ch = City.objects.create(name='Chicago')\n         District.objects.create(city=ch, name='Far South')\n         District.objects.create(city=ch, name='North')\n",
  "django__django-14007": "diff --git a/tests/custom_pk/tests.py b/tests/custom_pk/tests.py\nindex cbae2d9..4aba06c 100644\n--- a/tests/custom_pk/tests.py\n+++ b/tests/custom_pk/tests.py\n@@ -1,7 +1,10 @@\n+\n from django.db import IntegrityError, transaction\n from django.test import TestCase, skipIfDBFeature\n \n-from .models import Bar, Business, Employee, Foo\n+from .models import Bar, Business, Employee, Foo, CustomAutoFieldModel\n+from .fields import MyWrapper\n+from django.test import skipUnlessDBFeature\n \n \n class BasicCustomPKTests(TestCase):\n",
  "django__django-14017": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 707f339..0b64643 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -816,6 +816,30 @@ class BasicExpressionsTests(TestCase):\n             [self.example_inc.ceo, self.max],\n         )\n \n+class CommutativeQAndExistsTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.max = Employee.objects.create(firstname='Max', lastname='Mustermann', salary=35)\n+        cls.example_inc = Company.objects.create(name='Example Inc', ceo=cls.max)\n+        cls.foobar_ltd = Company.objects.create(name='Foobar Ltd', ceo=cls.max)\n+        cls.gmbh = Company.objects.create(name='GmbH', ceo=cls.max)\n+\n+    def test_commutative_behavior_of_q_and_exists(self):\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+\n+        tests = [\n+            Exists(is_poc) & Q(),\n+            Q() & Exists(is_poc),\n+            Exists(is_ceo) | Q(),\n+            Q() | Exists(is_ceo),\n+        ]\n+        expected_results = [self.max]\n+        for conditions in tests:\n+            with self.subTest(msg=f\"Testing condition: {conditions}\"):\n+                self.assertCountEqual(Employee.objects.filter(conditions), expected_results)\n \n class IterableLookupInnerExpressionsTests(TestCase):\n     @classmethod\n",
  "django__django-14053": "diff --git a/tests/staticfiles_tests/test_storage.py b/tests/staticfiles_tests/test_storage.py\nindex 76f3d3e..afd9a47 100644\n--- a/tests/staticfiles_tests/test_storage.py\n+++ b/tests/staticfiles_tests/test_storage.py\n@@ -205,6 +205,23 @@ class TestHashedFiles:\n         self.assertIn(os.path.join('test', 'nonascii.css'), stats['post_processed'])\n         self.assertPostCondition()\n \n+    def test_no_duplicate_yields_in_post_process(self):\n+        \"\"\"\n+        Test that post_process() does not yield the same filename more than once.\n+        \"\"\"\n+        collectstatic_cmd = CollectstaticCommand()\n+        collectstatic_cmd.set_options(clear=False, dry_run=False, post_process=True)\n+\n+        stats = collectstatic_cmd.collect()\n+\n+        # Ensure 'post_processed' files are yielded once\n+        post_processed_files = stats['post_processed']\n+        self.assertCountEqual(post_processed_files, set(post_processed_files))\n+\n+        # Verify no intermediate files that should not be there are yielded\n+        expected_files = {os.path.join('cached', 'css', 'window.css'), os.path.join('test', 'nonascii.css')}\n+        self.assertTrue(expected_files.issubset(post_processed_files))\n+\n     def test_css_import_case_insensitive(self):\n         relpath = self.hashed_file_path(\"cached/styles_insensitive.css\")\n         self.assertEqual(relpath, \"cached/styles_insensitive.3fa427592a53.css\")\n@@ -214,6 +231,23 @@ class TestHashedFiles:\n             self.assertIn(b\"other.d41d8cd98f00.css\", content)\n         self.assertPostCondition()\n \n+    def test_no_duplicate_yields_in_post_process(self):\n+        \"\"\"\n+        Test that post_process() does not yield the same filename more than once.\n+        \"\"\"\n+        collectstatic_cmd = CollectstaticCommand()\n+        collectstatic_cmd.set_options(clear=False, dry_run=False, post_process=True)\n+\n+        stats = collectstatic_cmd.collect()\n+\n+        # Ensure 'post_processed' files are yielded once\n+        post_processed_files = stats['post_processed']\n+        self.assertCountEqual(post_processed_files, set(post_processed_files))\n+\n+        # Verify no intermediate files that should not be there are yielded\n+        expected_files = {os.path.join('cached', 'css', 'window.css'), os.path.join('test', 'nonascii.css')}\n+        self.assertTrue(expected_files.issubset(post_processed_files))\n+\n     @override_settings(\n         STATICFILES_DIRS=[os.path.join(TEST_ROOT, 'project', 'faulty')],\n         STATICFILES_FINDERS=['django.contrib.staticfiles.finders.FileSystemFinder'],\n",
  "django__django-14089": "diff --git a/tests/utils_tests/test_datastructures.py b/tests/utils_tests/test_datastructures.py\nindex 7fb3d83..8139a95 100644\n--- a/tests/utils_tests/test_datastructures.py\n+++ b/tests/utils_tests/test_datastructures.py\n@@ -1,8 +1,10 @@\n+\n \"\"\"\n Tests for stuff in django.utils.datastructures.\n \"\"\"\n \n import copy\n+import collections.abc\n import pickle\n \n from django.test import SimpleTestCase\n@@ -18,6 +20,22 @@ class OrderedSetTests(SimpleTestCase):\n         s = OrderedSet([1, 2, 3])\n         self.assertEqual(list(s.dict.keys()), [1, 2, 3])\n \n+    def test_reversed(self):\n+        # Test reversing a non-empty OrderedSet\n+        s = reversed(OrderedSet([1, 2, 3]))\n+        self.assertIsInstance(s, collections.abc.Iterator)\n+        self.assertEqual(list(s), [3, 2, 1])\n+\n+        # Test reversing an empty OrderedSet\n+        s = reversed(OrderedSet([]))\n+        self.assertIsInstance(s, collections.abc.Iterator)\n+        self.assertEqual(list(s), [])\n+\n+        # Test reversing an OrderedSet with a single element\n+        s = reversed(OrderedSet([42]))\n+        self.assertIsInstance(s, collections.abc.Iterator)\n+        self.assertEqual(list(s), [42])\n+\n     def test_remove(self):\n         s = OrderedSet()\n         self.assertEqual(len(s), 0)\n",
  "django__django-14122": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 83089d9..0859cb5 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -1,9 +1,11 @@\n+\n from datetime import datetime\n from operator import attrgetter\n \n from django.db.models import (\n     CharField, DateTimeField, F, Max, OuterRef, Subquery, Value,\n )\n+from django.db.models import Count\n from django.db.models.functions import Upper\n from django.test import TestCase\n \n@@ -98,6 +100,24 @@ class OrderingTests(TestCase):\n         self.assertSequenceEqual(queryset, sequence)\n         self.assertSequenceEqual(queryset.reverse(), list(reversed(sequence)))\n \n+    def test_default_ordering_does_not_affect_group_by(self):\n+        \"\"\"\n+        Ensure that Meta.ordering fields are not included in the GROUP BY clause\n+        for aggregation queries.\n+        \"\"\"\n+        # Set up initial authors for articles\n+        Article.objects.exclude(headline='Article 4').update(author=self.author_1)\n+        Article.objects.filter(headline='Article 4').update(author=self.author_2)\n+        \n+        # Perform a group-by and aggregation\n+        articles = Article.objects.values('author').annotate(count=Count('author'))\n+        \n+        # Assert that the correct aggregation (counting) occurs\n+        self.assertCountEqual(articles, [\n+            {'author': self.author_1.pk, 'count': 3},\n+            {'author': self.author_2.pk, 'count': 1},\n+        ])\n+        \n     def test_order_by_nulls_last(self):\n         Article.objects.filter(headline=\"Article 3\").update(author=self.author_1)\n         Article.objects.filter(headline=\"Article 4\").update(author=self.author_2)\n@@ -483,4 +503,4 @@ class OrderingTests(TestCase):\n         )\n         ca4 = ChildArticle.objects.create(headline='h1', pub_date=datetime(2005, 7, 28))\n         articles = ChildArticle.objects.order_by('article_ptr')\n-        self.assertSequenceEqual(articles, [ca4, ca2, ca1, ca3])\n+        self.assertSequenceEqual(articles, [ca4, ca2, ca1, ca3])\n",
  "django__django-14140": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex c3db825..397c49a 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -839,6 +839,22 @@ class BasicExpressionsTests(TestCase):\n                 self.assertCountEqual(Employee.objects.filter(conditions), [self.max])\n \n \n+from django.db.models import Exists, F, OuterRef, Q  # Ensure necessary imports\n+\n+class ExpressionsTests(TestCase):\n+    # Existing tests...\n+\n+    def test_boolean_expression_combined_with_single_child_Q(self):\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        q = Q(Exists(is_poc))\n+        _, args, kwargs = q.deconstruct()\n+        self.assertEqual(args, (Exists(is_poc),))\n+        self.assertEqual(kwargs, {})\n+        combined_q = q & Q()\n+        self.assertCountEqual(Employee.objects.filter(combined_q), [self.max])\n+        combined_q_or = q | Q()\n+        self.assertCountEqual(Employee.objects.filter(combined_q_or), [self.max])\n+\n class IterableLookupInnerExpressionsTests(TestCase):\n     @classmethod\n     def setUpTestData(cls):\n",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..bda2b9a 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,3 +1,4 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n@@ -74,7 +75,27 @@ class TestDefaultPK(SimpleTestCase):\n \n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n \n-    @isolate_apps('model_options.apps.ModelPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+    \n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.AutoField')\n     def test_app_default_auto_field(self):\n         class Model(models.Model):\n",
  "django__django-14311": "",
  "django__django-14349": "",
  "django__django-14351": "diff --git a/tests/aggregation_regress/tests.py b/tests/aggregation_regress/tests.py\nindex 79963c3..2ccfaaf 100644\n--- a/tests/aggregation_regress/tests.py\n+++ b/tests/aggregation_regress/tests.py\n@@ -1526,6 +1526,50 @@ class AggregationTests(TestCase):\n         DistinctAggregate('foo', distinct=True)\n \n \n+from django.db.models import Q, Count\n+from django.test import TestCase\n+from .models import Author, Book, PropertyGroup, ManagerGroup # Assuming these models are correctly defined elsewhere\n+\n+class AggregationTests(TestCase):\n+    def test_q_object_or_id_in_clause(self):\n+        # Attempting to reproduce the problematic behavior\n+        property_groups = PropertyGroup.objects.all()\n+        queryset = Book.objects.annotate(Count(\"authors\"))\n+        \n+        # Should work without error, where we use __id__in\n+        try:\n+            result = queryset.filter(\n+                Q(authors__id__in=property_groups.values_list(\"id\", flat=True))\n+                | Q(authors__count=0)\n+            ).distinct()\n+            self.assertIsNotNone(result)\n+        except Exception as e:\n+            self.fail(f\"Q object usage with __id__in raised an exception: {e}\")\n+\n+    def test_q_object_or_in_clause_error(self):\n+        # This test should expose the issue, reproducing the error structure\n+        with self.assertRaises(ProgrammingError):\n+            property_groups = PropertyGroup.objects.all()\n+            queryset = Book.objects.annotate(Count(\"authors\"))\n+            \n+            # This is where the issue occurs, using __in directly\n+            queryset.filter(\n+                Q(authors__in=property_groups)\n+                | Q(authors__count=0)\n+            ).distinct()\n+\n+    def test_aggregation_with_q_objects(self):\n+        # Verifying that using Q with aggregation does not improperly join\n+        property_groups = PropertyGroup.objects.all()\n+        queryset = Book.objects.annotate(authors_count=Count(\"authors\"))\n+        \n+        result_qs = queryset.filter(\n+            Q(authors__id__in=property_groups.values_list(\"id\", flat=True))\n+            | Q(authors_count=0)\n+        ).distinct()\n+\n+        self.assertGreaterEqual(len(result_qs), 0)  # Should not raise an error and return a valid queryset\n+\n class JoinPromotionTests(TestCase):\n     def test_ticket_21150(self):\n         b = Bravo.objects.create()\n",
  "django__django-14373": "",
  "django__django-14376": "diff --git a/tests/dbshell/test_mysql.py b/tests/dbshell/test_mysql.py\nindex 643c2b6..80b3110 100644\n--- a/tests/dbshell/test_mysql.py\n+++ b/tests/dbshell/test_mysql.py\n@@ -89,6 +89,62 @@ class MySqlDbshellCommandTestCase(SimpleTestCase):\n             (expected_args, expected_env),\n         )\n \n+    def test_deprecated_and_new_keys(self):\n+        settings_port = 444\n+        options_port = 555\n+        for keys in [('database', 'password'), ('db', 'passwd')]:\n+            with self.subTest(keys=keys):\n+                database, password = keys\n+                expected_args = [\n+                    'mysql',\n+                    '--user=optionuser',\n+                    '--host=optionhost',\n+                    '--port=%s' % options_port,\n+                    'optiondbname',\n+                ]\n+                expected_env = {'MYSQL_PWD': 'optionpassword'}\n+                self.assertEqual(\n+                    self.settings_to_cmd_args_env({\n+                        'NAME': 'settingdbname',\n+                        'USER': 'settinguser',\n+                        'PASSWORD': 'settingpassword',\n+                        'HOST': 'settinghost',\n+                        'PORT': settings_port,\n+                        'OPTIONS': {\n+                            database: 'optiondbname',\n+                            'user': 'optionuser',\n+                            password: 'optionpassword',\n+                            'host': 'optionhost',\n+                            'port': options_port,\n+                        },\n+                    }),\n+                    (expected_args, expected_env),\n+                )\n+\n+    def test_options_preferred_non_deprecated_keys(self):\n+        settings_port = 444\n+        options_port = 555\n+        expected_args = [\n+            'mysql',\n+            '--user=optionuser',\n+            '--host=optionhost',\n+            '--port=%s' % options_port,\n+            'optiondbname',\n+        ]\n+        expected_env = {'MYSQL_PWD': 'optionpassword'}\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\n+                'NAME': 'settingdbname',\n+                'OPTIONS': {\n+                    'database': 'optiondbname',\n+                    'db': 'deprecatedoptiondbname',\n+                    'password': 'optionpassword',\n+                    'passwd': 'deprecatedoptionpassword',\n+                },\n+            }),\n+            (expected_args, expected_env),\n+        )\n+\n     def test_options_charset(self):\n         expected_args = [\n             'mysql',\n",
  "django__django-14434": "diff --git a/tests/schema/tests.py b/tests/schema/tests.py\nindex 39c82bf..75b522a 100644\n--- a/tests/schema/tests.py\n+++ b/tests/schema/tests.py\n@@ -2199,6 +2199,33 @@ class SchemaTests(TransactionTestCase):\n             editor.remove_constraint(AuthorWithUniqueNameAndBirthday, constraint)\n \n     @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_create_unique_constraint_with_mixed_table_references(self):\n+        # Setup the model and schema editor.\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+\n+        # Create a unique constraint with a mixed reference.\n+        constraint = UniqueConstraint(fields=['name'], name='name_uq')\n+\n+        # Add the constraint.\n+        with connection.schema_editor() as editor:\n+            editor.add_constraint(Author, constraint)\n+            sql = constraint.create_sql(Author, editor)\n+\n+        # Get the table name and verify SQL references column.\n+        table = Author._meta.db_table\n+        self.assertIs(sql.references_table(table), True)\n+        self.assertIs(sql.references_column(table, 'name'), True)\n+\n+        # Ensure this column check fails for other columns not in constraint.\n+        self.assertIs(sql.references_column(table, 'id'), False)\n+        self.assertIs(sql.references_column(table, 'non_existent_column'), False)\n+\n+        # Remove the constraint and ensure it is removed.\n+        with connection.schema_editor() as editor:\n+            editor.remove_constraint(Author, constraint)\n+        self.assertNotIn(constraint.name, self.get_constraints(table))\n+\n     def test_func_unique_constraint(self):\n         with connection.schema_editor() as editor:\n             editor.create_model(Author)\n",
  "django__django-14493": "diff --git a/tests/staticfiles_tests/test_storage.py b/tests/staticfiles_tests/test_storage.py\nindex 17aecdd..6fa5c7f 100644\n--- a/tests/staticfiles_tests/test_storage.py\n+++ b/tests/staticfiles_tests/test_storage.py\n@@ -454,6 +454,22 @@ class TestCollectionManifestStorage(TestHashedFiles, CollectionTestCase):\n         )\n \n \n+class NoPostProcessReplacedPathStorage(ManifestStaticFilesStorage):\n+    max_post_process_passes = 0\n+\n+@override_settings(STATICFILES_STORAGE='staticfiles_tests.storage.NoPostProcessReplacedPathStorage')\n+class TestCollectionNoPostProcessReplacedPaths(CollectionTestCase):\n+    run_collectstatic_in_setUp = False\n+\n+    def test_collectstatic_no_post_process(self):\n+        stdout = StringIO()\n+        self.run_collectstatic(verbosity=1, stdout=stdout)\n+        self.assertIn('post-processed', stdout.getvalue())\n+\n+from io import StringIO\n+from django.test.utils import override_settings\n+from django.contrib.staticfiles.storage import ManifestStaticFilesStorage\n+\n @override_settings(STATICFILES_STORAGE='staticfiles_tests.storage.NoneHashStorage')\n class TestCollectionNoneHashStorage(CollectionTestCase):\n     hashed_file_path = hashed_file_path\n",
  "django__django-14500": "diff --git a/tests/migrations/test_executor.py b/tests/migrations/test_executor.py\nindex d884fe4..5e85c3f 100644\n--- a/tests/migrations/test_executor.py\n+++ b/tests/migrations/test_executor.py\n@@ -653,7 +653,39 @@ class ExecutorTests(MigrationTestBase):\n             recorder.applied_migrations(),\n         )\n \n-    # When the feature is False, the operation and the record won't be\n+    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed'})\n+    def test_unapply_squashed_migration_correctly(self):\n+        \"\"\"Test that unapplying a squashed migration correctly marks it and its replaced migrations as unapplied.\"\"\"\n+        executor = MigrationExecutor(connection)\n+        recorder = Recorder(connection)\n+        \n+        # Apply the squashed migration\n+        executor.migrate([('migrations', '0001_squashed_0002')])\n+        \n+        # Verify the squashed migration is applied\n+        self.assertIn(\n+            ('migrations', '0001_squashed_0002'),\n+            recorder.applied_migrations()\n+        )\n+        \n+        # Now unapply the squashed migration\n+        executor.migrate([('migrations', None)])\n+        \n+        # Verify the squashed migration is no longer marked as applied\n+        self.assertNotIn(\n+            ('migrations', '0001_squashed_0002'),\n+            recorder.applied_migrations()\n+        )\n+        \n+        # Ensure the replaced migrations have been marked as unapplied\n+        self.assertNotIn(\n+            ('migrations', '0001_initial'),\n+            recorder.applied_migrations()\n+        )\n+        self.assertNotIn(\n+            ('migrations', '0002_second'),\n+            recorder.applied_migrations()\n+        )\n     # performed in a transaction and the test will systematically pass.\n     @skipUnlessDBFeature('can_rollback_ddl')\n     def test_migrations_applied_and_recorded_atomically(self):\n",
  "django__django-14539": "",
  "django__django-14559": "diff --git a/tests/queries/test_bulk_update.py b/tests/queries/test_bulk_update.py\nindex b579834..60387e5 100644\n--- a/tests/queries/test_bulk_update.py\n+++ b/tests/queries/test_bulk_update.py\n@@ -115,7 +115,43 @@ class BulkUpdateTests(TestCase):\n \n     pk_fields_error = 'bulk_update() cannot be used with primary key fields.'\n \n-    def test_update_primary_key(self):\n+    def test_bulk_update_no_updates(self):\n+        # Test with empty object list should return 0 updates.\n+        rows_updated = Note.objects.bulk_update([], ['note'])\n+        self.assertEqual(rows_updated, 0)\n+\n+    def test_bulk_update_no_change(self):\n+        # Create notes but don't change any fields, should still return count.\n+        Note.objects.bulk_create([\n+            Note(note='test-note', misc='misc') for _ in range(10)\n+        ])\n+        notes = list(Note.objects.all())  # Fetch the same instances.\n+        rows_updated = Note.objects.bulk_update(notes, ['note'])\n+        self.assertEqual(rows_updated, 10)\n+\n+    def test_bulk_update_multiple_batches(self):\n+        # Update with larger number and batches.\n+        Note.objects.bulk_create([\n+            Note(note=str(i), misc='misc') for i in range(1, 201)\n+        ])\n+        notes = list(Note.objects.all())\n+        for note in notes:\n+            note.note = 'bulk-updated'\n+        rows_updated = Note.objects.bulk_update(notes, ['note'], batch_size=50)\n+        self.assertEqual(rows_updated, 200)\n+\n+    def test_bulk_update_with_partial_updates(self):\n+        # Only some objects meet the update condition.\n+        Note.objects.bulk_create([\n+            Note(note='a', misc='misc') for _ in range(5)\n+        ] + [\n+            Note(note='b', misc='misc') for _ in range(5)\n+        ])\n+        notes = Note.objects.filter(note='a')\n+        for note in notes:\n+            note.note = 'updated-a'\n+        rows_updated = Note.objects.bulk_update(notes, ['note'])\n+        self.assertEqual(rows_updated, 5)\n         with self.assertRaisesMessage(ValueError, self.pk_fields_error):\n             Note.objects.bulk_update([], ['id'])\n \n",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..45ccf61 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -984,6 +984,28 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n \n+    def test_formset_non_form_errors_css_class(self):\n+        \"\"\"\n+        Test that the 'nonform' CSS class is added to non-form errors in formsets.\n+        \"\"\"\n+        data = {\n+            'choices-TOTAL_FORMS': '2',  # the number of forms rendered\n+            'choices-INITIAL_FORMS': '0',  # the number of forms with initial data\n+            'choices-MIN_NUM_FORMS': '0',  # min number of forms\n+            'choices-MAX_NUM_FORMS': '0',  # max number of forms\n+            'choices-0-choice': 'Zero',\n+            'choices-0-votes': '0',\n+            'choices-1-choice': 'One',\n+            'choices-1-votes': '1',\n+        }\n+        ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=True)\n+        formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n+        self.assertFalse(formset.is_valid())\n+\n+        # Check that the non-form error includes the 'nonform' CSS class\n+        expected_html = '<ul class=\"errorlist nonform\"><li>Please submit at most 1 form.</li></ul>'\n+        self.assertHTMLEqual(str(formset.non_form_errors()), expected_html)\n+\n     def test_formset_iteration(self):\n         \"\"\"Formset instances are iterable.\"\"\"\n         ChoiceFormset = formset_factory(Choice, extra=3)\n",
  "django__django-14631": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex a48e4b6..5621371 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -2129,7 +2129,49 @@ Password: <input type=\"password\" name=\"password\" required></li>\n         form = DateTimeForm({'dt': '2006-10-25 14:30:45'})\n         self.assertEqual(form.changed_data, [])\n \n-    def test_help_text(self):\n+    def test_datetime_clean_initial_callable_disabled_bound_field_after(self):\n+        \"\"\"\n+        The cleaned value for a form with a disabled DateTimeField and callable\n+        initial matches the bound field's cached initial value after fix.\n+        \"\"\"\n+        now = datetime.datetime(2006, 10, 25, 14, 30, 45, 0)\n+        \n+        class DateTimeForm(forms.Form):\n+            dt = DateTimeField(initial=lambda: now, disabled=True)\n+\n+        form = DateTimeForm({})\n+        cleaned = form.cleaned_data['dt']\n+        self.assertEqual(cleaned, datetime.datetime(2006, 10, 25, 14, 30, 45))\n+        bf = form['dt']\n+        self.assertEqual(cleaned, bf.initial)\n+    \n+    def test_datetime_form_field_did_change_method(self):\n+        \"\"\"\n+        Test the did_change method for a form field using BoundField.\n+        \"\"\"\n+        now_with_microseconds = datetime.datetime(2006, 10, 25, 14, 30, 45, 123456)\n+        now = datetime.datetime(2006, 10, 25, 14, 30, 45, 0)\n+\n+        class DateTimeForm(forms.Form):\n+            dt = DateTimeField(initial=lambda: now_with_microseconds, disabled=True)\n+\n+        form = DateTimeForm({'dt': '2006-10-25 14:30:45'})\n+        bf = form['dt']\n+        self.assertFalse(bf._did_change())\n+\n+    def test_datetime_form_changed_data_with_bound_field(self):\n+        \"\"\"\n+        Test that BaseForm's changed_data accesses values consistently through\n+        BoundField for changed fields as well.\n+        \"\"\"\n+        class SimpleForm(forms.Form):\n+            name = forms.CharField(initial='Chris')\n+        \n+        form = SimpleForm({'name': 'Chris'})\n+        self.assertEqual(form.changed_data, [])\n+        \n+        form = SimpleForm({'name': 'Chris Jerdonek'})\n+        self.assertEqual(form.changed_data, ['name'])\n         # You can specify descriptive text for a field by using the 'help_text' argument)\n         class UserRegistration(Form):\n             username = CharField(max_length=10, help_text='e.g., user@example.com')\n",
  "django__django-14672": "",
  "django__django-14752": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex 7ef6d86..29f3b11 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -1,4 +1,10 @@\n+\n import json\n+import datetime\n+from django.test import TestCase\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+from django.http import JsonResponse\n+from .models import Question\n from contextlib import contextmanager\n \n from django.contrib import admin\n",
  "django__django-14765": "diff --git a/tests/migrations/test_state.py b/tests/migrations/test_state.py\nindex 11009e5..37cdcbc 100644\n--- a/tests/migrations/test_state.py\n+++ b/tests/migrations/test_state.py\n@@ -923,8 +923,31 @@ class StateTests(SimpleTestCase):\n             len([x for x in rendered_state.get_models() if x._meta.app_label == \"migrations\"]),\n             1,\n         )\n-\n-    def test_ignore_order_wrt(self):\n+    def test_real_apps_non_set(self):\n+        with self.assertRaises(AssertionError):\n+            ProjectState(real_apps=['contenttypes'])\n+            \n+    def test_real_apps_set(self):\n+        # Should succeed without raising an exception\n+        try:\n+            ProjectState(real_apps={'contenttypes'})\n+        except Exception:\n+            self.fail(\"ProjectState raised an exception unexpectedly!\")\n+            \n+    def test_real_apps_none(self):\n+        # Should work fine with no exception\n+        try:\n+            ProjectState(real_apps=None)\n+        except Exception:\n+            self.fail(\"ProjectState raised an exception unexpectedly!\")\n+\n+    def test_real_apps_empty(self):\n+        # Should behave like passing an empty set\n+        try:\n+            state = ProjectState(real_apps=set())\n+            self.assertEqual(state.real_apps, set())\n+        except Exception:\n+            self.fail(\"ProjectState raised an exception unexpectedly!\")\n         \"\"\"\n         Makes sure ProjectState doesn't include OrderWrt fields when\n         making from existing models.\n",
  "django__django-14771": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 1875424..85d1bc1 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -196,6 +196,13 @@ class TestChildArguments(SimpleTestCase):\n \n     @mock.patch('__main__.__spec__', None)\n     @mock.patch('sys.argv', [__file__, 'runserver'])\n+    @mock.patch('sys._xoptions', {'utf8': True, 'a': 'b'})\n+    @mock.patch('sys.warnoptions', [])\n+    def test_xoptions_passed(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-Xutf8', '-Xa=b', __file__, 'runserver']\n+        )\n     @mock.patch('sys.warnoptions', ['error'])\n     def test_warnoptions(self):\n         self.assertEqual(\n@@ -236,6 +243,13 @@ class TestChildArguments(SimpleTestCase):\n             autoreload.get_child_arguments()\n \n     @mock.patch('sys.argv', [__file__, 'runserver'])\n+    @mock.patch('sys._xoptions', {'utf8': True, 'a': 'b'})\n+    @mock.patch('sys.warnoptions', [])\n+    def test_xoptions_passed(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-Xutf8', '-Xa=b', __file__, 'runserver']\n+        )\n     @mock.patch('sys.warnoptions', [])\n     def test_module_no_spec(self):\n         module = types.ModuleType('test_module')\n",
  "django__django-14787": "diff --git a/tests/decorators/tests.py b/tests/decorators/tests.py\nindex 5ea3da6..504a74d 100644\n--- a/tests/decorators/tests.py\n+++ b/tests/decorators/tests.py\n@@ -199,7 +199,53 @@ class MethodDecoratorTests(SimpleTestCase):\n     \"\"\"\n     Tests for method_decorator\n     \"\"\"\n-    def test_preserve_signature(self):\n+    from functools import wraps, partial\n+    from django.utils.decorators import method_decorator\n+    from unittest import TestCase\n+\n+    def test_wrapper_assignments(self):\n+        \"\"\"Ensure method_decorator preserves wrapper assignments.\"\"\"\n+        func_name = None\n+        func_module = None\n+\n+        def decorator(func):\n+            @wraps(func)\n+            def inner(*args, **kwargs):\n+                nonlocal func_name, func_module\n+                func_name = getattr(func, '__name__', None)\n+                func_module = getattr(func, '__module__', None)\n+                return func(*args, **kwargs)\n+            return inner\n+\n+        class Test:\n+            @method_decorator(decorator)\n+            def method(self):\n+                return 'test'\n+\n+        Test().method()\n+        self.assertEqual(func_name, 'method')\n+        self.assertIsNotNone(func_module)\n+\n+    def test_partial_object_decorator(self):\n+        \"\"\"Test using a partial object with method_decorator to ensure attributes are preserved.\"\"\"\n+        def example_decorator(func):\n+            @wraps(func)\n+            def wrapper(*args, **kwargs):\n+                return func(*args, **kwargs)\n+            return wrapper\n+        \n+        class MyTestClass:\n+            @method_decorator(example_decorator)\n+            def my_method(self, x):\n+                return x * 2\n+\n+        instance = MyTestClass()\n+        result = instance.my_method(3)\n+        self.assertEqual(result, 6)\n+\n+        # Ensure attributes are preserved.\n+        self.assertEqual(MyTestClass.my_method.__name__, 'my_method')\n+        self.assertIsNotNone(MyTestClass.my_method.__module__)\n         class Test:\n             @simple_dec_m\n             def say(self, arg):\n",
  "django__django-14855": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 507855b..b68ab78 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -5131,8 +5131,61 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase):\n         )\n         # Related ForeignKey object not registered in admin.\n         self.assertContains(response, '<div class=\"readonly\">Chapter 1</div>', html=True)\n+    def test_readonly_foreignkey_links_default_admin_site(self):\n+        \"\"\"\n+        Test that readonly ForeignKey fields generate the correct URL\n+        for the default admin site.\n+        \"\"\"\n+        # Create a Chapter instance with a ForeignKey to a Book\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1',\n+            content='content',\n+            book=Book.objects.create(name='Book 1')\n+        )\n+        # Create a ReadOnlyRelatedField instance\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+        )\n+\n+        # Access the admin change page for the object\n+        response = self.client.get(reverse('admin:admin_views_readonlyrelatedfield_change', args=(obj.pk,)))\n+        self.assertEqual(response.status_code, 200)\n+\n+        # Check that the link for the readonly ForeignKey field has the correct URL\n+        book_url = reverse('admin:admin_views_book_change', args=(quote(chapter.book.pk),))\n+        self.assertContains(\n+            response,\n+            '<a href=\"%s\">Book 1</a>' % book_url,\n+            html=True\n+        )\n \n-    def test_readonly_manytomany_backwards_ref(self):\n+    def test_readonly_foreignkey_links_custom_admin_site(self):\n+        \"\"\"\n+        Test that readonly ForeignKey fields generate the correct URL\n+        for a custom admin site.\n+        \"\"\"\n+        # Create a Chapter instance with a ForeignKey to a Book\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1',\n+            content='content',\n+            book=Book.objects.create(name='Book 1')\n+        )\n+        # Create a ReadOnlyRelatedField instance\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+        )\n+\n+        # Access the admin change page for the object using custom admin site\n+        response = self.client.get(reverse('namespaced_admin:admin_views_readonlyrelatedfield_change', args=(obj.pk,)))\n+        self.assertEqual(response.status_code, 200)\n+\n+        # Check that the link for the readonly ForeignKey field has the correct custom URL\n+        book_url = reverse('namespaced_admin:admin_views_book_change', args=(quote(chapter.book.pk),))\n+        self.assertContains(\n+            response,\n+            '<a href=\"%s\">Book 1</a>' % book_url,\n+            html=True\n+        )\n         \"\"\"\n         Regression test for #16433 - backwards references for related objects\n         broke if the related field is read-only due to the help_text attribute\n",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..1bf2cfc 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,9 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n@@ -278,8 +279,14 @@ class ModelChoiceFieldTests(TestCase):\n \n         field = CustomModelChoiceField(Category.objects.all())\n         self.assertIsInstance(field.choices, CustomModelChoiceIterator)\n-\n-    def test_choice_iterator_passes_model_to_widget(self):\n+    def test_choice_value_hashable(self):\n+        value = ModelChoiceIteratorValue(1, None)\n+        # Check if the object is hashable by calling hash on it\n+        try:\n+            hash_value = hash(value)\n+            self.assertIsInstance(hash_value, int)\n+        except TypeError:\n+            self.fail(\"ModelChoiceIteratorValue instance is not hashable\")\n         class CustomCheckboxSelectMultiple(CheckboxSelectMultiple):\n             def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):\n                 option = super().create_option(name, value, label, selected, index, subindex, attrs)\n",
  "django__django-14999": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 3e4c6c7..f00a481 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -784,6 +784,56 @@ class OperationTests(OperationTestBase):\n         project_state = self.apply_operations(app_label, project_state, operations=[\n             migrations.RenameModel(\"Pony\", \"Pony2\"),\n         ], atomic=connection.features.supports_atomic_references_rename)\n+\n+    def test_rename_model_with_existing_db_table(self):\n+        \"\"\"\n+        Ensure RenameModel with an existing db_table does nothing.\n+        \"\"\"\n+        app_label = 'test_rmwdbtn_existing_table'\n+        project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+            migrations.CreateModel('Rider', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+            ], options={'db_table': 'rider'}),\n+            migrations.CreateModel('Pony', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+            ]),\n+        ])\n+        \n+        # Attempt to rename `Rider` to `Runner`, which should be a no-op.\n+        new_state = project_state.clone()\n+        operation = migrations.RenameModel('Rider', 'Runner')\n+        operation.state_forwards(app_label, new_state)\n+        \n+        # Ensure no queries are executed during the rename operation\n+        with connection.schema_editor() as editor:\n+            with self.assertNumQueries(0):\n+                operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+    def test_rename_model_with_no_db_table(self):\n+        \"\"\"\n+        Ensure RenameModel without db_table actually renames the table.\n+        \"\"\"\n+        app_label = 'test_rmwdbtn_no_table'\n+        project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+            migrations.CreateModel('Rider', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+            ]),\n+            migrations.CreateModel('Pony', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+                ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+            ]),\n+        ])\n+        \n+        # Rename `Rider` to `Runner`, which should perform the rename operation.\n+        new_state = project_state.clone()\n+        operation = migrations.RenameModel('Rider', 'Runner')\n+        operation.state_forwards(app_label, new_state)\n+        \n+        with connection.schema_editor() as editor:\n+            with self.assertNumQueriesGreaterThan(0):\n+                # Here, we expect some queries due to the actual rename operation.\n+                operation.database_forwards(app_label, editor, project_state, new_state)\n         Pony = project_state.apps.get_model(app_label, \"Pony2\")\n         Rider = project_state.apps.get_model(app_label, \"Rider\")\n         pony = Pony.objects.create()\n",
  "django__django-15022": "",
  "django__django-15037": "",
  "django__django-15103": "",
  "django__django-15104": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex 04452fa..fd89141 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -2835,7 +2835,48 @@ class AutodetectorTests(TestCase):\n                 )\n \n \n-class MigrationSuggestNameTests(SimpleTestCase):\n+from django.db import models\n+from django.db.migrations.autodetector import MigrationAutodetector\n+from django.db.migrations.state import ModelState, ProjectState\n+from django.test import TestCase\n+\n+class CustomFKField(models.ForeignKey):\n+    \"\"\"A ForeignKey that hardcodes the 'to' argument and removes it from kwargs during deconstruction.\"\"\"\n+    def __init__(self, *args, **kwargs):\n+        kwargs['to'] = 'testapp.HardcodedModel'\n+        super().__init__(*args, **kwargs)\n+\n+    def deconstruct(self):\n+        name, path, args, kwargs = super().deconstruct()\n+        del kwargs[\"to\"]\n+        return name, path, args, kwargs\n+\n+class AutodetectorKeyErrorTests(TestCase):\n+    def test_hardcoded_fk_field(self):\n+        \"\"\"Test that autodetector handles FK field with hardcoded 'to' argument.\"\"\"\n+        before = ProjectState()\n+        before.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        after = ProjectState()\n+        after.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        after.add_model(ModelState('testapp', 'TestModel', [('custom', CustomFKField(on_delete=models.CASCADE))]))\n+        changes = MigrationAutodetector(before, after)._detect_changes()\n+        self.assertEqual(len(changes['testapp']), 1)\n+\n+    def test_no_exploded_key_error_on_foreign_key_with_hardcoded_reference(self):\n+        \"\"\"Ensure no exceptions are raised for FK fields with removed 'to' during deconstruction.\"\"\"\n+        before_state = ProjectState()\n+        before_state.add_model(ModelState('testapp', 'ReferenceModel', []))\n+        after_state = ProjectState()\n+        after_state.add_model(ModelState('testapp', 'ReferenceModel', []))\n+        after_state.add_model(ModelState('testapp', 'TestModel', [\n+            ('field', CustomFKField(on_delete=models.CASCADE))\n+        ]))\n+        try:\n+            MigrationAutodetector(before_state, after_state)._detect_changes()\n+            success = True\n+        except KeyError:\n+            success = False\n+        self.assertTrue(success, \"KeyError was raised with a ForeignKey having a hardcoded reference\")\n     def test_no_operations(self):\n         class Migration(migrations.Migration):\n             operations = []\n",
  "django__django-15127": "",
  "django__django-15128": "diff --git a/tests/queries/models.py b/tests/queries/models.py\nindex a7bb7e8..bb3323d 100644\n--- a/tests/queries/models.py\n+++ b/tests/queries/models.py\n@@ -613,7 +613,13 @@ class OrderItem(models.Model):\n \n \n class BaseUser(models.Model):\n-    pass\n+    annotation = models.ForeignKey('Annotation', models.CASCADE, null=True, blank=True)\n+\n+class Annotation(models.Model):\n+    tag = models.ForeignKey('Tag', models.CASCADE)\n+\n+class Note(models.Model):\n+    tag = models.ForeignKey('Tag', models.CASCADE)\n \n \n class Task(models.Model):\n",
  "django__django-15161": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 5fdccc5..c653aca 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1755,6 +1755,13 @@ class ValueTests(TestCase):\n         Time.objects.update(time=Value(datetime.time(1), output_field=TimeField()))\n         self.assertEqual(Time.objects.get().time, datetime.time(1))\n \n+    def test_deconstruct_F(self):\n+        f = F('some_field')\n+        path, args, kwargs = f.deconstruct()\n+        self.assertEqual(path, 'django.db.models.F')\n+        self.assertEqual(args, (f.name,))\n+        self.assertEqual(kwargs, {})\n+\n     def test_update_UUIDField_using_Value(self):\n         UUID.objects.create()\n         UUID.objects.update(uuid=Value(uuid.UUID('12345678901234567890123456789012'), output_field=UUIDField()))\n",
  "django__django-15268": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex a6c0858..6ef1fa2 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -1590,6 +1590,25 @@ class AutodetectorTests(TestCase):\n             changes, 'otherapp', 0, 3, name='book',\n             index_together={('title', 'author')},\n         )\n+    def test_optimize_foo_together_operations(self):\n+        \"\"\"\n+        Check if multiple AlterFooTogether operations are optimized.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_empty, self.book],\n+            [self.author_empty, self.book_foo_together_4]\n+        )\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, [\n+            'AlterUniqueTogether',\n+            'AlterIndexTogether',\n+        ])\n+        self.assertOperationAttributes(\n+            changes, 'otherapp', 0, 0, name='book', unique_together={('title', 'newfield2')},\n+        )\n+        self.assertOperationAttributes(\n+            changes, 'otherapp', 0, 1, name='book', index_together={('title', 'newfield2')},\n+        )\n \n     def test_add_field_and_foo_together(self):\n         \"\"\"\n",
  "django__django-15277": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 11f86ed..bd9e9e4 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1847,6 +1847,20 @@ class ValueTests(TestCase):\n                 expr = Value(value)\n                 self.assertIsInstance(expr.output_field, output_field_type)\n \n+    def test_charfield_no_max_length_validator_when_no_max_length(self):\n+        # Test that CharField doesn't add a MaxLengthValidator if max_length is None\n+        value = Value('test')\n+        field = value._resolve_output_field()\n+        self.assertIsInstance(field, CharField)\n+        self.assertEqual(field.max_length, None)\n+        # Ensure no MaxLengthValidator exists\n+        self.assertNotIn(validators.MaxLengthValidator, [type(validator) for validator in field.validators])\n+\n+    def test_existing_test_for_different_types(self):\n+            with self.subTest(type=type(value)):\n+                expr = Value(value)\n+                self.assertIsInstance(expr.output_field, output_field_type)\n+\n     def test_resolve_output_field_failure(self):\n         msg = 'Cannot resolve expression type, unknown output_field'\n         with self.assertRaisesMessage(FieldError, msg):\n",
  "django__django-15278": "",
  "django__django-15315": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex e4daf0e..47e137a 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -17,8 +17,40 @@ class Nested:\n         pass\n \n \n+from django.db import models\n+import pickle\n+\n class BasicFieldTests(SimpleTestCase):\n \n+    def test_hash_immutability(self):\n+        field = models.IntegerField()\n+        field_hash = hash(field)\n+        class MyModel(models.Model):\n+            rank = field\n+        self.assertEqual(field_hash, hash(field))\n+\n+    def test_field_hash_in_dict_before_assignment(self):\n+        \"\"\"\n+        Ensure that a field can be used as a dictionary key and retains its hash\n+        after being assigned to a model.\n+        \"\"\"\n+        field = models.CharField(max_length=200)\n+        field_dict = {field: 1}\n+        class Book(models.Model):\n+            title = field\n+        self.assertIn(field, field_dict)\n+\n+    def test_picklable_after_assignment(self):\n+        \"\"\"\n+        Ensure that a field remains picklable after being assigned to a model class.\n+        \"\"\"\n+        field = models.CharField(max_length=200)\n+        class Author(models.Model):\n+            name = field\n+        pickled_field = pickle.dumps(field)\n+        unpickled_field = pickle.loads(pickled_field)\n+        self.assertEqual(field, unpickled_field)\n+\n     def test_show_hidden_initial(self):\n         \"\"\"\n         Fields with choices respect show_hidden_initial as a kwarg to\n",
  "django__django-15368": "diff --git a/tests/queries/test_bulk_update.py b/tests/queries/test_bulk_update.py\nindex 447c150..2d9cbf6 100644\n--- a/tests/queries/test_bulk_update.py\n+++ b/tests/queries/test_bulk_update.py\n@@ -204,7 +204,34 @@ class BulkUpdateTests(TestCase):\n             [cat.special_name for cat in special_categories]\n         )\n \n-    def test_field_references(self):\n+    def test_f_expression_with_charfield(self):\n+        notes = [Note.objects.create(note='test_note', misc='test_misc') for _ in range(10)]\n+        for note in notes:\n+            note.misc = F('note')\n+        Note.objects.bulk_update(notes, ['misc'])\n+        self.assertCountEqual(Note.objects.filter(misc='test_note'), notes)\n+\n+    def test_f_expression_with_integerfield(self):\n+        items = [Item.objects.create(name='Item{}'.format(i), quantity=i) for i in range(10)]\n+        for item in items:\n+            item.quantity = F('quantity') + 10\n+        Item.objects.bulk_update(items, ['quantity'])\n+        self.assertTrue(all(item.quantity == original.quantity + 10 for item, original in zip(Item.objects.all(), items)))\n+\n+    def test_f_expression_with_datefield(self):\n+        from datetime import date, timedelta\n+        events = [Event.objects.create(name='Event{}'.format(i), start_date=date(2023, 10, i + 1)) for i in range(10)]\n+        for event in events:\n+            event.start_date = F('start_date') + timedelta(days=1)\n+        Event.objects.bulk_update(events, ['start_date'])\n+        self.assertTrue(all(event.start_date == original.start_date + timedelta(days=1) for event, original in zip(Event.objects.all(), events)))\n+\n+    def test_f_expression_with_booleanfield(self):\n+        tasks = [Task.objects.create(name='Task{}'.format(i), completed=False) for i in range(10)]\n+        for task in tasks:\n+            task.completed = F('completed')\n+        Task.objects.bulk_update(tasks, ['completed'])\n+        self.assertCountEqual(Task.objects.filter(completed=False), tasks)\n         numbers = [Number.objects.create(num=0) for _ in range(10)]\n         for number in numbers:\n             number.num = F('num') + 1\n",
  "django__django-15380": "",
  "django__django-15382": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex bd890ac..c681d42 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1906,7 +1906,39 @@ class ExistsTests(TestCase):\n         self.assertNotIn('ORDER BY', captured_sql)\n \n \n-class FieldTransformTests(TestCase):\n+from django.test import TestCase\n+from django.db.models import Exists, Q\n+from .models import Manager\n+\n+class ExistsSubqueryTests(TestCase):\n+    def test_negated_empty_exists_still_queries(self):\n+        manager = Manager.objects.create(name='John Doe')\n+        qs = Manager.objects.filter(\n+            ~Exists(Manager.objects.none()), pk=manager.pk\n+        )\n+        self.assertSequenceEqual(qs, [manager])\n+\n+    def test_negated_non_empty_exists(self):\n+        manager = Manager.objects.create(name='John Doe')\n+        other_manager = Manager.objects.create(name='Jane Doe')\n+        qs = Manager.objects.filter(\n+            ~Exists(Manager.objects.filter(pk=other_manager.pk)), pk=manager.pk\n+        )\n+        self.assertSequenceEqual(qs, [manager])\n+\n+    def test_non_negated_empty_exists_removes_all(self):\n+        manager = Manager.objects.create(name='John Doe')\n+        qs = Manager.objects.filter(\n+            Exists(Manager.objects.none()), pk=manager.pk\n+        )\n+        self.assertSequenceEqual(qs, [])\n+\n+    def test_non_negated_non_empty_exists(self):\n+        manager = Manager.objects.create(name='John Doe')\n+        qs = Manager.objects.filter(\n+            Exists(Manager.objects.filter(pk=manager.pk)), pk=manager.pk\n+        )\n+        self.assertSequenceEqual(qs, [manager])\n \n     @classmethod\n     def setUpTestData(cls):\n",
  "django__django-15467": "",
  "django__django-15499": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 5df1b06..20be857 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -129,6 +129,33 @@ class OptimizerTests(SimpleTestCase):\n             ],\n         )\n \n+    def test_create_alter_model_managers_with_additional_fields(self):\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\n+                    \"Bar\",\n+                    fields=[(\"name\", models.CharField(max_length=100))],\n+                ),\n+                migrations.AlterModelManagers(\n+                    name=\"Bar\",\n+                    managers=[\n+                        (\"default_manager\", models.Manager()),\n+                        (\"custom_manager\", models.Manager()),\n+                    ],\n+                ),\n+            ],\n+            [\n+                migrations.CreateModel(\n+                    \"Bar\",\n+                    fields=[(\"name\", models.CharField(max_length=100))],\n+                    managers=[\n+                        (\"default_manager\", models.Manager()),\n+                        (\"custom_manager\", models.Manager()),\n+                    ],\n+                ),\n+            ],\n+        )\n+\n     def test_create_model_and_remove_model_options(self):\n         self.assertOptimizesTo(\n             [\n@@ -141,6 +168,33 @@ class OptimizerTests(SimpleTestCase):\n             ],\n             [migrations.CreateModel(\"MyModel\", fields=[])],\n         )\n+\n+    def test_create_alter_model_managers_with_additional_fields(self):\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\n+                    \"Bar\",\n+                    fields=[(\"name\", models.CharField(max_length=100))],\n+                ),\n+                migrations.AlterModelManagers(\n+                    name=\"Bar\",\n+                    managers=[\n+                        (\"default_manager\", models.Manager()),\n+                        (\"custom_manager\", models.Manager()),\n+                    ],\n+                ),\n+            ],\n+            [\n+                migrations.CreateModel(\n+                    \"Bar\",\n+                    fields=[(\"name\", models.CharField(max_length=100))],\n+                    managers=[\n+                        (\"default_manager\", models.Manager()),\n+                        (\"custom_manager\", models.Manager()),\n+                    ],\n+                ),\n+            ],\n+        )\n         self.assertOptimizesTo(\n             [\n                 migrations.CreateModel(\n",
  "django__django-15525": "diff --git a/tests/fixtures_regress/tests.py b/tests/fixtures_regress/tests.py\nindex 3640e99..be094bd 100644\n--- a/tests/fixtures_regress/tests.py\n+++ b/tests/fixtures_regress/tests.py\n@@ -791,6 +791,51 @@ class NaturalKeyFixtureTests(TestCase):\n         )\n \n \n+from django.test import TestCase\n+from django.core import management\n+from .models import Author, Book\n+\n+class NaturalKeyFixtureTests(TestCase):\n+    databases = {'default', 'other'}\n+\n+    def setUp(self):\n+        \"\"\"Set up some initial data for the tests.\"\"\"\n+        self.author = Author.objects.create(name=\"J.R.R. Tolkien\")\n+        self.book = Book.objects.create(title=\"The Lord of the Rings\", author=self.author)\n+\n+    def test_natural_key_loading_on_non_default_db(self):\n+        \"\"\"Test loaddata with natural keys on a non-default database.\"\"\"\n+        serialized_data = [\n+            {\n+                \"model\": \"fixtures_regress.author\",\n+                \"fields\": {\n+                    \"name\": \"J.R.R. Tolkien\"\n+                }\n+            },\n+            {\n+                \"model\": \"fixtures_regress.book\",\n+                \"fields\": {\n+                    \"title\": \"The Lord of the Rings\",\n+                    \"author\": [\"J.R.R. Tolkien\"]\n+                }\n+            }\n+        ]\n+        \n+        with open('temp_fixture.json', 'w') as fixture_file:\n+            import json\n+            json.dump(serialized_data, fixture_file)\n+        \n+        management.call_command(\n+            'loaddata',\n+            'temp_fixture.json',\n+            database='other',\n+            verbosity=0\n+        )\n+\n+        obj = Book.objects.using('other').get()\n+        self.assertEqual(obj.title, \"The Lord of the Rings\")\n+        self.assertEqual(obj.author.name, \"J.R.R. Tolkien\")\n+\n class M2MNaturalKeyFixtureTests(TestCase):\n     \"\"\"Tests for ticket #14426.\"\"\"\n \n",
  "django__django-15561": "",
  "django__django-15569": "",
  "django__django-15572": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex 188dca4..cd215c3 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -76,6 +76,43 @@ class TemplateReloadTests(SimpleTestCase):\n             },\n         )\n \n+    @override_settings(\n+        TEMPLATES=[\n+            {\n+                \"DIRS\": [\"\"],\n+                \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n+            }\n+        ]\n+    )\n+    def test_template_dirs_ignore_empty_path(self):\n+        # Ensures that empty strings are ignored in template directories\n+        self.assertEqual(autoreload.get_template_directories(), set())\n+\n+    @override_settings(\n+        TEMPLATES=[\n+            {\n+                \"DIRS\": [\"/valid_path\", \"\"],\n+                \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n+            }\n+        ]\n+    )\n+    def test_template_dirs_combined_with_empty_string(self):\n+        # Ensures that valid paths are retained even if an empty string is present\n+        expected_dirs = {Path.cwd() / \"valid_path\"}\n+        self.assertSetEqual(autoreload.get_template_directories(), expected_dirs)\n+\n+    @override_settings(\n+        TEMPLATES=[\n+            {\n+                \"DIRS\": [],\n+                \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n+            }\n+        ]\n+    )\n+    def test_template_dirs_empty(self):\n+        # Verifies behavior when no template directories are provided\n+        self.assertEqual(autoreload.get_template_directories(), set())\n+\n     @mock.patch(\"django.template.loaders.base.Loader.reset\")\n     def test_reset_all_loaders(self, mock_reset):\n         autoreload.reset_loaders()\n",
  "django__django-15731": "diff --git a/tests/basic/tests.py b/tests/basic/tests.py\nindex 902f114..6d8a392 100644\n--- a/tests/basic/tests.py\n+++ b/tests/basic/tests.py\n@@ -1,9 +1,11 @@\n+\n import threading\n from datetime import datetime, timedelta\n from unittest import mock\n \n from django.core.exceptions import MultipleObjectsReturned, ObjectDoesNotExist\n from django.db import DEFAULT_DB_ALIAS, DatabaseError, connections, models\n+import inspect\n from django.db.models.manager import BaseManager\n from django.db.models.query import MAX_GET_RESULTS, EmptyQuerySet\n from django.test import (\n",
  "django__django-15741": "diff --git a/tests/template_tests/filter_tests/test_date.py b/tests/template_tests/filter_tests/test_date.py\nindex c6dbc53..4356666 100644\n--- a/tests/template_tests/filter_tests/test_date.py\n+++ b/tests/template_tests/filter_tests/test_date.py\n@@ -1,7 +1,10 @@\n+\n from datetime import datetime, time\n \n from django.template.defaultfilters import date\n from django.test import SimpleTestCase\n+from django.utils.translation import gettext_lazy\n+from django.utils.formats import get_format\n from django.utils import timezone, translation\n \n from ..utils import setup\n@@ -74,6 +77,12 @@ class DateTests(TimezoneTestCase):\n \n \n class FunctionTests(SimpleTestCase):\n+    def test_get_format_with_lazy_string(self):\n+        \"\"\"\n+        Test get_format when using gettext_lazy to ensure no TypeError is raised.\n+        \"\"\"\n+        self.assertEqual(get_format(gettext_lazy(\"DATE_FORMAT\")), \"N j, Y\")\n+\n     def test_date(self):\n         self.assertEqual(date(datetime(2005, 12, 29), \"d F Y\"), \"29 December 2005\")\n \n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..9001d96 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -398,6 +398,29 @@ class ProxyModelTests(TestCase):\n     def test_eq(self):\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n+    def test_select_related_only_on_proxy(self):\n+        # Create instances for testing\n+        custom_model = CustomModel.objects.create(name=\"Test Name\")\n+        proxy_custom = ProxyCustomModel.objects.get(pk=custom_model.pk)\n+        another_model = AnotherModel.objects.create(custom=proxy_custom)\n+\n+        # Original queryset intended to crash due to the issue\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+        # Evaluate queryset\n+        result = list(qs)\n+        self.assertEqual(result[0].custom.name, \"Test Name\")\n+\n+    def test_select_related_only_on_concrete(self):\n+        # Create instances for testing\n+        custom_model = CustomModel.objects.create(name=\"Base User\")\n+        another_model = AnotherModel.objects.create(custom=custom_model)\n+\n+        # Similar query directly on concrete model\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+        # Ensure no error occurs\n+        result = list(qs)\n+        self.assertEqual(result[0].custom.name, \"Base User\")\n+\n \n @override_settings(ROOT_URLCONF=\"proxy_models.urls\")\n class ProxyModelAdminTests(TestCase):\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..bc4016f 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -157,6 +157,16 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             ([\"psql\", \"dbname\", \"--help\"], None),\n         )\n \n+    def test_parameter_order_correctness(self):\n+        \"\"\"\n+        Test that additional parameters are passed before the dbname.\n+        This ensures that no warnings about extra command-line arguments\n+        are issued by psql.\n+        \"\"\"\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"SELECT 1;\"]),\n+            ([\"psql\", \"-c\", \"SELECT 1;\", \"dbname\"], None)\n+        )\n     @skipUnless(connection.vendor == \"postgresql\", \"Requires a PostgreSQL connection\")\n     def test_sigint_handler(self):\n         \"\"\"SIGINT is ignored in Python and passed to psql to abort queries.\"\"\"\n",
  "django__django-15863": "diff --git a/tests/template_tests/filter_tests/test_floatformat.py b/tests/template_tests/filter_tests/test_floatformat.py\nindex 08f08e1..6557716 100644\n--- a/tests/template_tests/filter_tests/test_floatformat.py\n+++ b/tests/template_tests/filter_tests/test_floatformat.py\n@@ -73,6 +73,28 @@ class FunctionTests(SimpleTestCase):\n         self.assertEqual(floatformat(1.5e-15, 20), \"0.00000000000000150000\")\n         self.assertEqual(floatformat(1.5e-15, -20), \"0.00000000000000150000\")\n         self.assertEqual(floatformat(1.00000000000000015, 16), \"1.0000000000000002\")\n+    def test_large_precision_decimal(self):\n+        # Verify floatformat does not lose precision for large Decimal inputs\n+        self.assertEqual(\n+            floatformat(Decimal(\"123456.123456789012345678901\"), 21),\n+            \"123456.123456789012345678901\",\n+        )\n+        self.assertEqual(\n+            floatformat(Decimal(\"0.00000000000000000001\"), 20),\n+            \"0.00000000000000000001\",\n+        )\n+        self.assertEqual(\n+            floatformat(Decimal(\"-0.00000000000000000001\"), 20),\n+            \"-0.00000000000000000001\",\n+        )\n+        self.assertEqual(\n+            floatformat(Decimal(\"1.23456789012345678901234567890E+5\"), 25),\n+            \"123456.7890123456789012346\",\n+        )\n+        self.assertEqual(\n+            floatformat(Decimal(\"0.123456789012345678901234567890\"), 30),\n+            \"0.123456789012345678901234567890\",\n+        )\n \n     def test_force_grouping(self):\n         with translation.override(\"en\"):\n",
  "django__django-15930": "diff --git a/tests/expressions_case/tests.py b/tests/expressions_case/tests.py\nindex 696f4d0..0689c44 100644\n--- a/tests/expressions_case/tests.py\n+++ b/tests/expressions_case/tests.py\n@@ -415,6 +415,16 @@ class CaseExpressionTests(TestCase):\n         self.assertEqual(len(objects), CaseTestModel.objects.count())\n         self.assertTrue(all(obj.selected == \"not selected\" for obj in objects))\n \n+    def test_annotate_with_full_when(self):\n+        objects = CaseTestModel.objects.annotate(\n+            selected=Case(\n+                When(~Q(pk__in=[]), then=Value(\"selected\")),\n+                default=Value(\"not selected\"),\n+            )\n+        )\n+        self.assertEqual(len(objects), CaseTestModel.objects.count())\n+        self.assertTrue(all(obj.selected == \"selected\" for obj in objects))\n+\n     def test_combined_expression(self):\n         self.assertQuerysetEqual(\n             CaseTestModel.objects.annotate(\n",
  "django__django-15987": "diff --git a/tests/fixtures_regress/tests.py b/tests/fixtures_regress/tests.py\nindex 5ac9ab9..901e253 100644\n--- a/tests/fixtures_regress/tests.py\n+++ b/tests/fixtures_regress/tests.py\n@@ -1,3 +1,4 @@\n+\n # Unittests for fixtures.\n import json\n import os\n@@ -10,6 +11,7 @@ from django.core.exceptions import ImproperlyConfigured\n from django.core.serializers.base import DeserializationError\n from django.db import IntegrityError, transaction\n from django.db.models import signals\n+from django.core.management import call_command\n from django.test import (\n     TestCase,\n     TransactionTestCase,\n@@ -556,7 +558,34 @@ class TestFixtures(TestCase):\n             management.call_command(\"loaddata\", \"absolute.json\", verbosity=0)\n \n     @override_settings(FIXTURE_DIRS=[os.path.join(_cur_dir, \"fixtures\")])\n-    def test_fixture_dirs_with_default_fixture_path(self):\n+    @override_settings(FIXTURE_DIRS=[Path(_cur_dir) / \"fixtures\"])\n+    def test_fixture_dirs_with_path_instances(self):\n+        \"\"\"\n+        Test to verify duplicates are detected when FIXTURE_DIRS uses Path instances.\n+        \"\"\"\n+        msg = (\n+            \"'%s' is a default fixture directory for the '%s' app \"\n+            \"and cannot be listed in settings.FIXTURE_DIRS.\"\n+            % (os.path.join(_cur_dir, \"fixtures\"), \"fixtures_regress\")\n+        )\n+        with self.assertRaisesMessage(ImproperlyConfigured, msg):\n+            call_command(\"loaddata\", \"absolute.json\", verbosity=0)\n+\n+    @override_settings(\n+        FIXTURE_DIRS=[\n+            os.path.join(_cur_dir, \"fixtures\"),\n+            os.path.join(_cur_dir, \"other_fixtures\"),\n+        ]\n+    )\n+    def test_fixture_dirs_with_string_paths_no_duplicates(self):\n+        \"\"\"\n+        Test to assert that no ImproperlyConfigured is raised when \n+        using string paths and no duplicate dir exists.\n+        \"\"\"\n+        try:\n+            call_command(\"loaddata\", \"absolute.json\", verbosity=0)\n+        except ImproperlyConfigured:\n+            self.fail(\"ImproperlyConfigured was raised unexpectedly.\")\n         \"\"\"\n         settings.FIXTURE_DIRS cannot contain a default fixtures directory\n         for application (app/fixtures) in order to avoid repeated fixture loading.\n",
  "django__django-16032": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex bcf8df9..f6bfd0a 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -989,6 +989,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             publisher_books_qs, [{\"name\": \"Sams\"}, {\"name\": \"Morgan Kaufmann\"}]\n         )\n \n+    def test_annotation_and_alias_filter_in_main_queryset(self):\n+        awarded_publishers_qs = (\n+            Publisher.objects.filter(num_awards__gt=2)\n+            .annotate(publisher_annotate=Value(1))\n+            .alias(publisher_alias=Value(1))\n+        )\n+        qs = Publisher.objects.filter(pk__in=awarded_publishers_qs)\n+        self.assertCountEqual(qs.values_list(\"name\", flat=True), [\"Sams\", \"Prentice Hall\", \"Morgan Kaufmann\"])\n+\n+    def test_annotation_and_alias_in_nested_subquery(self):\n+        long_books_qs = (\n+            Book.objects.filter(pages__gt=400)\n+            .annotate(book_annotate=Value(1))\n+            .alias(book_alias=Value(1))\n+        )\n+        publisher_books_qs = Publisher.objects.filter(\n+            book__in=long_books_qs,\n+        ).distinct()\n+        self.assertCountEqual(\n+            publisher_books_qs.values_list(\"name\", flat=True),\n+            [\"Apress\", \"Sams\", \"Prentice Hall\", \"Morgan Kaufmann\"],\n+        )\n+\n     def test_annotation_exists_aggregate_values_chaining(self):\n         qs = (\n             Book.objects.values(\"publisher\")\n",
  "django__django-16082": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 541ed6d..c6202be 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -2416,7 +2416,7 @@ class CombinedExpressionTests(SimpleTestCase):\n             (IntegerField, FloatField, FloatField),\n             (FloatField, IntegerField, FloatField),\n         ]\n-        connectors = [Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV]\n+        connectors = [Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV, Combinable.MOD]\n         for lhs, rhs, combined in tests:\n             for connector in connectors:\n                 with self.subTest(\n",
  "django__django-16100": "diff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex 0ab2941..7416901 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib import admin\n@@ -21,7 +22,9 @@ from django.db.models import F, Field, IntegerField\n from django.db.models.functions import Upper\n from django.db.models.lookups import Contains, Exact\n from django.template import Context, Template, TemplateSyntaxError\n-from django.test import TestCase, override_settings\n+from unittest import mock\n+from django.db import DatabaseError, models, connection\n+from django.test import TestCase, override_settings, skipUnlessDBFeature\n from django.test.client import RequestFactory\n from django.test.utils import CaptureQueriesContext, isolate_apps, register_lookup\n from django.urls import reverse\n",
  "django__django-16116": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex cd0e572..55526fc 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -2400,6 +2400,24 @@ class MakeMigrationsTests(MigrationTestBase):\n         ):\n             call_command(\"makemigrations\", \"--check\", \"migrations\", verbosity=0)\n \n+    def test_makemigrations_check_no_dry_run(self):\n+        \"\"\"\n+        makemigrations --check should exit without creating migrations when\n+        there are changes, without the need for --dry-run option.\n+        \"\"\"\n+        app_label = \"migrations\"\n+        \n+        # Verify that the migration module temporary directory does not exist\n+        with self.temporary_migration_module() as migration_dir:\n+            self.assertFalse(os.path.exists(migration_dir))\n+\n+            # Expecting SystemExit since there are pending migrations\n+            with self.assertRaises(SystemExit):\n+                call_command(\"makemigrations\", \"--check\", app_label, verbosity=0)\n+\n+            # Verify the migration module directory should still not exist since no migration should have been created\n+            self.assertFalse(os.path.exists(migration_dir))\n+            \n     def test_makemigrations_migration_path_output(self):\n         \"\"\"\n         makemigrations should print the relative paths to the migrations unless\n",
  "django__django-16136": "diff --git a/tests/async/tests.py b/tests/async/tests.py\nindex 72e103e..a4f8c85 100644\n--- a/tests/async/tests.py\n+++ b/tests/async/tests.py\n@@ -1,3 +1,39 @@\n+\n+class GetRequestToAsyncPostViewTest(SimpleTestCase):\n+    def test_get_request_to_async_post_view(self):\n+        \"\"\"Test that a GET request to a view with only async post method returns 405.\"\"\"\n+        request_factory = RequestFactory()\n+        request = request_factory.get('/demo')\n+\n+        # Define the view class with only an async post method\n+        class DemoView(View):\n+            async def post(self, request, *args, **kwargs):\n+                return HttpResponse(\"ok\")\n+\n+        view = DemoView.as_view()\n+        response = view(request)\n+        self.assertIsInstance(response, HttpResponseNotAllowed)\n+\n+class HttpMethodNotAllowedTest(SimpleTestCase):\n+    def test_http_method_not_allowed_responds_correctly(self):\n+        request_factory = RequestFactory()\n+        tests = [\n+            (SyncView, False),\n+            (AsyncView, True),\n+        ]\n+        for view_cls, is_coroutine in tests:\n+            with self.subTest(view_cls=view_cls, is_coroutine=is_coroutine):\n+                instance = view_cls()\n+                response = instance.http_method_not_allowed(request_factory.post(\"/\"))\n+                self.assertIs(\n+                    asyncio.iscoroutine(response),\n+                    is_coroutine,\n+                )\n+                if is_coroutine:\n+                    response = asyncio.run(response)\n+\n+                self.assertIsInstance(response, HttpResponseNotAllowed)\n+\n import asyncio\n import os\n from unittest import mock\n@@ -6,7 +42,9 @@ from asgiref.sync import async_to_sync\n \n from django.core.cache import DEFAULT_CACHE_ALIAS, caches\n from django.core.exceptions import ImproperlyConfigured, SynchronousOnlyOperation\n-from django.http import HttpResponse\n+from django.http import HttpResponse, HttpResponseNotAllowed\n+from django.test import RequestFactory, SimpleTestCase\n+import asyncio\n from django.test import SimpleTestCase\n from django.utils.asyncio import async_unsafe\n from django.views.generic.base import View\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..5dc23d7 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,6 +1,9 @@\n+\n import datetime\n import re\n+import urllib.parse\n from unittest import mock\n+from django.urls import reverse\n \n from django.contrib.auth.forms import (\n     AdminPasswordChangeForm,\n@@ -892,6 +895,27 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # value to render correctly\n         self.assertEqual(form.initial[\"password\"], form[\"password\"].value())\n \n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search(r'<a href=\"(.*?)\">', password_help_text)\n+        \n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.username,),\n+            # Assuming uuid is used here to simulate the to_field scenario\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+        \n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n     def test_custom_form(self):\n         class CustomUserChangeForm(UserChangeForm):\n             class Meta(UserChangeForm.Meta):\n",
  "django__django-16145": "",
  "django__django-16255": "",
  "django__django-16315": "",
  "django__django-16333": "",
  "django__django-16429": "diff --git a/tests/utils_tests/test_timesince.py b/tests/utils_tests/test_timesince.py\nindex f795bf7..5f432f8 100644\n--- a/tests/utils_tests/test_timesince.py\n+++ b/tests/utils_tests/test_timesince.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.test import TestCase\n@@ -170,6 +171,16 @@ class TimesinceTests(TestCase):\n         past = datetime.datetime(1980, 1, 1, tzinfo=naive())\n         self.assertEqual(timeuntil(past), \"0\\xa0minutes\")\n \n+    @requires_tz_support\n+    @override_settings(USE_TZ=True)\n+    def test_long_interval_with_tz(self):\n+        now = timezone.now()\n+        d = now - datetime.timedelta(days=31)\n+        d_aware = timezone.make_aware(d)\n+\n+        # Check if timesince works correctly when the USE_TZ setting is on with an aware datetime\n+        self.assertEqual(timesince(d_aware), \"1\\xa0month\")\n+\n     def test_thousand_years_ago(self):\n         t = datetime.datetime(1007, 8, 14, 13, 46, 0)\n         self.assertEqual(timesince(t, self.t), \"1000\\xa0years\")\n",
  "django__django-16454": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 8d0729b..b31f503 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -468,6 +468,57 @@ class CommandRunTests(AdminScriptTestCase):\n         self.assertNoOutput(err)\n         self.assertEqual(out.strip(), \"Set foo\")\n \n+    def test_subparser_error_formatting(self):\n+        \"\"\"Test error formatting for subparser with missing argument.\"\"\"\n+        from django.core.management import call_command\n+        import sys\n+        from io import StringIO\n+\n+        # Setup in-memory output capture\n+        out = StringIO()\n+        err = StringIO()\n+        sys.stdout = out\n+        sys.stderr = err\n+\n+        try:\n+            # Execute management command with missing argument\n+            call_command('cheeses', 'create', verbosity=2)\n+        except Exception as e:\n+            # Reset\n+            sys.stdout = sys.__stdout__\n+            sys.stderr = sys.__stderr__\n+            # Make sure the error is CommandError not a raw stacktrace\n+            self.assertIsInstance(e, CommandError)\n+            self.assertIn('Error:', str(e))\n+        finally:\n+            sys.stdout = sys.__stdout__\n+            sys.stderr = sys.__stderr__\n+\n+    def test_subparser_invalid_argument_type(self):\n+        \"\"\"Test error message for invalid type in subparser argument.\"\"\"\n+        from django.core.management import call_command\n+        import sys\n+        from io import StringIO\n+\n+        out = StringIO()\n+        err = StringIO()\n+        sys.stdout = out\n+        sys.stderr = err\n+\n+        try:\n+            call_command('cheeses', 'create', 'twelve', verbosity=2)\n+        except Exception as e:\n+            sys.stdout = sys.__stdout__\n+            sys.stderr = sys.__stderr__\n+            self.assertIsInstance(e, CommandError)\n+            self.assertEqual(\n+                err.getvalue().splitlines()[-1],\n+                \"manage.py cheeses create: error: argument name: invalid str value: 'twelve'\"\n+            )\n+        finally:\n+            sys.stdout = sys.__stdout__\n+            sys.stderr = sys.__stderr__\n+\n \n class UtilsTests(SimpleTestCase):\n     def test_no_existent_external_program(self):\n",
  "django__django-16485": "",
  "django__django-16493": "diff --git a/tests/file_storage/tests.py b/tests/file_storage/tests.py\nindex 20567e7..1d63d0f 100644\n--- a/tests/file_storage/tests.py\n+++ b/tests/file_storage/tests.py\n@@ -1023,6 +1023,37 @@ class FieldCallableFileStorageTests(SimpleTestCase):\n # This is written in such a way that it'll always pass on platforms\n # without threading.\n \n+    def test_deconstruction_storage_callable_default(self):\n+        \"\"\"\n+        A callable that returns default_storage is not omitted when\n+        deconstructing.\n+        \"\"\"\n+        obj = Storage()\n+        *_, kwargs = obj._meta.get_field(\"storage_callable_default\").deconstruct()\n+        self.assertIs(kwargs[\"storage\"], callable_default_storage)\n+\n+    def test_deconstruction_storage_callable_random_choice(self):\n+        \"\"\"\n+        Ensure a callable that randomly returns storage doesn't omit itself when\n+        deconstructing, but retains the reference to the callable.\n+        \"\"\"\n+        obj = Storage()\n+        *_, kwargs_callable = obj._meta.get_field(\"storage_random_choice\").deconstruct()\n+        self.assertIsNotNone(kwargs_callable.get(\"storage\"))\n+        # Check if the callable itself is preserved\n+        self.assertEqual(kwargs_callable[\"storage\"], callable_storage)\n+\n+    def test_storage_deconstruction_variation(self):\n+        \"\"\"\n+        Ensure variations in callable outputs correctly reference the callable itself on deconstruction.\n+        \"\"\"\n+        # This model field uses a callable that may return default_storage\n+        obj = Storage()\n+        for _ in range(10):  # Due to randomness, test multiple times\n+            *_, kwargs3 = obj._meta.get_field(\"storage_random_choice\").deconstruct()\n+            self.assertIsInstance(kwargs3.get(\"storage\"), type(callable_storage))\n+            # Ensure a callable returning a random storage is still a callable\n+            self.assertEqual(kwargs3[\"storage\"], callable_storage)\n \n class SlowFile(ContentFile):\n     def chunks(self):\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..ede20ca 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -6,6 +7,8 @@ from django.contrib.admin.templatetags.admin_modify import submit_row\n from django.contrib.auth.admin import UserAdmin\n from django.contrib.auth.models import User\n from django.test import RequestFactory, TestCase\n+from django.contrib.auth import get_permission_codename\n+from .tests import get_perm\n from django.urls import reverse\n \n from .admin import ArticleAdmin, site\n@@ -33,6 +36,41 @@ class AdminTemplateTagsTest(AdminViewBasicTestCase):\n         self.assertIs(template_context[\"extra\"], True)\n         self.assertIs(template_context[\"show_save\"], True)\n \n+    def test_submit_row_save_as_new_add_permission_required(self):\n+        # Test case ensuring \"show_save_as_new\" requires add permission\n+        change_user = User.objects.create_user(\n+            username=\"change_user\", password=\"secret\", is_staff=True\n+        )\n+        # Grant only change permissions\n+        change_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = change_user\n+        admin = UserAdmin(User, site)\n+        admin.save_as = True\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], False)\n+\n+        add_user = User.objects.create_user(\n+            username=\"add_user\", password=\"secret\", is_staff=True\n+        )\n+        # Grant both add and change permissions\n+        add_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"add\", User._meta)),\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = add_user\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], True)\n+\n     def test_override_show_save_and_add_another(self):\n         request = self.request_factory.get(\n             reverse(\"admin:auth_user_change\", args=[self.superuser.pk]),\n",
  "django__django-16560": "",
  "django__django-16569": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 55da562..c25ef42 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1476,6 +1476,18 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertNotIn(\"DELETE\", formset.forms[1].fields)\n \n         formset = ChoiceFormFormset(initial=[{\"choice\": \"Zero\", \"votes\": \"1\"}])\n+\n+    def test_formset_empty_form_with_can_delete(self):\n+        class MyForm(forms.Form):\n+            my_field = forms.CharField()\n+\n+        MyFormSet = forms.formset_factory(\n+            form=MyForm,\n+            can_delete=True,\n+            can_delete_extra=False,\n+        )\n+        my_formset = MyFormSet(initial=None)\n+        self.assertNotIn(\"DELETE\", my_formset.empty_form.fields)\n         self.assertEqual(len(formset), 3)\n         self.assertIn(\"DELETE\", formset.forms[0].fields)\n         self.assertNotIn(\"DELETE\", formset.forms[1].fields)\n",
  "django__django-16595": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 3979e76..8749fde 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -43,7 +43,38 @@ class OptimizerTests(SimpleTestCase):\n     def assertDoesNotOptimize(self, operations, **kwargs):\n         self.assertOptimizesTo(operations, operations, **kwargs)\n \n-    def test_none_app_label(self):\n+    def test_alter_alter_field(self):\n+        # Test that consecutive AlterField operations reduce to the last one\n+        operations = [\n+            migrations.AlterField(\"Foo\", \"name\", models.IntegerField()),\n+            migrations.AlterField(\"Foo\", \"name\", models.IntegerField(help_text=\"help\")),\n+            migrations.AlterField(\"Foo\", \"name\", models.IntegerField(help_text=\"help\", default=1)),\n+        ]\n+        expected = [\n+            migrations.AlterField(\"Foo\", \"name\", models.IntegerField(help_text=\"help\", default=1)),\n+        ]\n+        self.assertOptimizesTo(operations, expected)\n+\n+    def test_alter_add_alter_field(self):\n+        # Test a case where AddField is followed by multiple AlterField should not reduce beyond AddField\n+        operations = [\n+            migrations.AddField(\"Bar\", \"age\", models.IntegerField(default=0)),\n+            migrations.AlterField(\"Bar\", \"age\", models.IntegerField(default=1)),\n+            migrations.AlterField(\"Bar\", \"age\", models.IntegerField(default=2)),\n+        ]\n+        expected = operations  # Should not optimize past the AddField\n+        self.assertDoesNotOptimize(operations)\n+\n+    def test_reduce_alter_with_same_field_operations(self):\n+        # Test reducing AlterField with AlterField having the same field attributes\n+        operations = [\n+            migrations.AlterField(\"Baz\", \"quantity\", models.FloatField()),\n+            migrations.AlterField(\"Baz\", \"quantity\", models.FloatField()),\n+        ]\n+        expected = [\n+            migrations.AlterField(\"Baz\", \"quantity\", models.FloatField()),\n+        ]\n+        self.assertOptimizesTo(operations, expected)\n         optimizer = MigrationOptimizer()\n         with self.assertRaisesMessage(TypeError, \"app_label must be a str\"):\n             optimizer.optimize([], None)\n",
  "django__django-16612": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 9120571..a63bb79 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -8456,6 +8456,50 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             email=\"staff@example.com\",\n             is_staff=True,\n         )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_query_strings_preserved(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test query string is preserved\n+        response = self.client.get(f\"{known_url[:-1]}?id=1&next=/dashboard\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=1&next=/dashboard\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_multiple_query_strings(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test multiple query strings are preserved\n+        response = self.client.get(f\"{known_url[:-1]}?category=tech&sort=desc\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?category=tech&sort=desc\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n         self.client.force_login(superuser)\n         known_url = reverse(\"admin:admin_views_article_changelist\")\n         response = self.client.get(known_url[:-1])\n@@ -8463,6 +8507,50 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             response, known_url, status_code=301, target_status_code=403\n         )\n \n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_query_strings_preserved(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test query string is preserved\n+        response = self.client.get(f\"{known_url[:-1]}?id=1&next=/dashboard\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=1&next=/dashboard\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_multiple_query_strings(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test multiple query strings are preserved\n+        response = self.client.get(f\"{known_url[:-1]}?category=tech&sort=desc\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?category=tech&sort=desc\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n     @override_settings(APPEND_SLASH=True)\n     def test_missing_slash_append_slash_true_script_name(self):\n         superuser = User.objects.create_user(\n@@ -8471,6 +8559,50 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             email=\"staff@example.com\",\n             is_staff=True,\n         )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_query_strings_preserved(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test query string is preserved\n+        response = self.client.get(f\"{known_url[:-1]}?id=1&next=/dashboard\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=1&next=/dashboard\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_multiple_query_strings(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test multiple query strings are preserved\n+        response = self.client.get(f\"{known_url[:-1]}?category=tech&sort=desc\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?category=tech&sort=desc\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n         self.client.force_login(superuser)\n         known_url = reverse(\"admin:admin_views_article_changelist\")\n         response = self.client.get(known_url[:-1], SCRIPT_NAME=\"/prefix/\")\n@@ -8481,6 +8613,50 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             fetch_redirect_response=False,\n         )\n \n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_query_strings_preserved(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test query string is preserved\n+        response = self.client.get(f\"{known_url[:-1]}?id=1&next=/dashboard\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=1&next=/dashboard\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_multiple_query_strings(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test multiple query strings are preserved\n+        response = self.client.get(f\"{known_url[:-1]}?category=tech&sort=desc\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?category=tech&sort=desc\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n     @override_settings(APPEND_SLASH=True, FORCE_SCRIPT_NAME=\"/prefix/\")\n     def test_missing_slash_append_slash_true_force_script_name(self):\n         superuser = User.objects.create_user(\n@@ -8489,6 +8665,50 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             email=\"staff@example.com\",\n             is_staff=True,\n         )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_query_strings_preserved(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test query string is preserved\n+        response = self.client.get(f\"{known_url[:-1]}?id=1&next=/dashboard\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=1&next=/dashboard\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_multiple_query_strings(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test multiple query strings are preserved\n+        response = self.client.get(f\"{known_url[:-1]}?category=tech&sort=desc\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?category=tech&sort=desc\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n         self.client.force_login(superuser)\n         known_url = reverse(\"admin:admin_views_article_changelist\")\n         response = self.client.get(known_url[:-1])\n@@ -8499,6 +8719,50 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             fetch_redirect_response=False,\n         )\n \n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_query_strings_preserved(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test query string is preserved\n+        response = self.client.get(f\"{known_url[:-1]}?id=1&next=/dashboard\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=1&next=/dashboard\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_multiple_query_strings(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test multiple query strings are preserved\n+        response = self.client.get(f\"{known_url[:-1]}?category=tech&sort=desc\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?category=tech&sort=desc\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n     @override_settings(APPEND_SLASH=True)\n     def test_missing_slash_append_slash_true_non_staff_user(self):\n         user = User.objects.create_user(\n@@ -8507,6 +8771,50 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             email=\"user@example.com\",\n             is_staff=False,\n         )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_query_strings_preserved(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test query string is preserved\n+        response = self.client.get(f\"{known_url[:-1]}?id=1&next=/dashboard\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=1&next=/dashboard\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_multiple_query_strings(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test multiple query strings are preserved\n+        response = self.client.get(f\"{known_url[:-1]}?category=tech&sort=desc\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?category=tech&sort=desc\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n         self.client.force_login(user)\n         known_url = reverse(\"admin:admin_views_article_changelist\")\n         response = self.client.get(known_url[:-1])\n@@ -8622,6 +8930,50 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             email=\"staff@example.com\",\n             is_staff=True,\n         )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_query_strings_preserved(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test query string is preserved\n+        response = self.client.get(f\"{known_url[:-1]}?id=1&next=/dashboard\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=1&next=/dashboard\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_multiple_query_strings(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test multiple query strings are preserved\n+        response = self.client.get(f\"{known_url[:-1]}?category=tech&sort=desc\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?category=tech&sort=desc\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n         self.client.force_login(superuser)\n         known_url = reverse(\"admin10:admin_views_article_changelist\")\n         response = self.client.get(known_url[:-1])\n@@ -8629,6 +8981,50 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             response, known_url, status_code=301, target_status_code=403\n         )\n \n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_query_strings_preserved(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test query string is preserved\n+        response = self.client.get(f\"{known_url[:-1]}?id=1&next=/dashboard\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=1&next=/dashboard\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_multiple_query_strings(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test multiple query strings are preserved\n+        response = self.client.get(f\"{known_url[:-1]}?category=tech&sort=desc\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?category=tech&sort=desc\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n     @override_settings(APPEND_SLASH=False)\n     def test_missing_slash_append_slash_false_without_final_catch_all_view(self):\n         superuser = User.objects.create_user(\n@@ -8637,6 +9033,50 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             email=\"staff@example.com\",\n             is_staff=True,\n         )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_query_strings_preserved(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test query string is preserved\n+        response = self.client.get(f\"{known_url[:-1]}?id=1&next=/dashboard\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=1&next=/dashboard\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_redirect_with_multiple_query_strings(self):\n+        # Test user\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        \n+        # Test multiple query strings are preserved\n+        response = self.client.get(f\"{known_url[:-1]}?category=tech&sort=desc\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?category=tech&sort=desc\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n         self.client.force_login(superuser)\n         known_url = reverse(\"admin10:admin_views_article_changelist\")\n         response = self.client.get(known_url[:-1])\n",
  "django__django-16642": "diff --git a/tests/responses/test_fileresponse.py b/tests/responses/test_fileresponse.py\nindex 499356e..b9e8879 100644\n--- a/tests/responses/test_fileresponse.py\n+++ b/tests/responses/test_fileresponse.py\n@@ -256,6 +256,17 @@ class FileResponseTests(SimpleTestCase):\n             (\".tar.bz2\", \"application/x-bzip\"),\n             (\".tar.xz\", \"application/x-xz\"),\n         )\n+        # Test cases for verifying MIME type guessing of \".tar.br\" and \".tar.Z\"\n+        extra_test_tuples = (\n+            (\".tar.br\", \"application/x-brotli\"),\n+            (\".tar.Z\", \"application/x-compress\"),\n+        )\n+        for extension, mimetype in extra_test_tuples:\n+            with self.subTest(ext=extension):\n+                with tempfile.NamedTemporaryFile(suffix=extension) as tmp:\n+                    response = FileResponse(tmp)\n+                self.assertEqual(response.headers[\"Content-Type\"], mimetype)\n+                self.assertFalse(response.has_header(\"Content-Encoding\"))\n         for extension, mimetype in test_tuples:\n             with self.subTest(ext=extension):\n                 with tempfile.NamedTemporaryFile(suffix=extension) as tmp:\n",
  "django__django-16661": "diff --git a/tests/modeladmin/tests.py b/tests/modeladmin/tests.py\nindex 8cb88da..273f62c 100644\n--- a/tests/modeladmin/tests.py\n+++ b/tests/modeladmin/tests.py\n@@ -144,6 +144,61 @@ class ModelAdminTests(TestCase):\n                 \"employee__department__code\",\n             ]\n \n+    @isolate_apps(\"modeladmin\")\n+    def test_lookup_allowed_foreign_primary_original(self):\n+        class Country(models.Model):\n+            name = models.CharField(max_length=256)\n+\n+        class Place(models.Model):\n+            country = models.ForeignKey(Country, models.CASCADE)\n+\n+        class Restaurant(models.Model):\n+            place = models.OneToOneField(Place, models.CASCADE, primary_key=True)\n+\n+        class Waiter(models.Model):\n+            restaurant = models.ForeignKey(Restaurant, models.CASCADE)\n+\n+        class WaiterAdmin(ModelAdmin):\n+            list_filter = [\n+                \"restaurant__place__country\",\n+                \"restaurant__place__country__name\",\n+            ]\n+\n+        ma = WaiterAdmin(Waiter, self.site)\n+        self.assertIs(ma.lookup_allowed(\"restaurant__place__country\", \"1\"), True)\n+        self.assertIs(\n+            ma.lookup_allowed(\"restaurant__place__country__id__exact\", \"1\"), True\n+        )\n+        self.assertIs(\n+            ma.lookup_allowed(\"restaurant__place__country__name\", \"test_value\"), True\n+        )\n+    \n+    @isolate_apps(\"modeladmin\")\n+    def test_lookup_allowed_foreign_primary_additional(self):\n+        class Country(models.Model):\n+            name = models.CharField(max_length=256)\n+\n+        class Place(models.Model):\n+            country = models.ForeignKey(Country, models.CASCADE)\n+\n+        class Restaurant(models.Model):\n+            place = models.OneToOneField(Place, models.CASCADE, primary_key=True)\n+\n+        class Waiter(models.Model):\n+            restaurant = models.ForeignKey(Restaurant, models.CASCADE)\n+\n+        class WaiterAdmin(ModelAdmin):\n+            list_filter = [\n+                \"restaurant__place__country__name\",\n+                \"restaurant__place__country__name__iexact\",\n+            ]\n+\n+        ma = WaiterAdmin(Waiter, self.site)\n+        self.assertIs(ma.lookup_allowed(\"restaurant__place__country__name\", \"USA\"), True)\n+        self.assertIs(ma.lookup_allowed(\"restaurant__place__country__name__iexact\", \"usa\"), True)\n+        self.assertIs(ma.lookup_allowed(\"restaurant__place\", \"1\"), False)\n+        self.assertIs(ma.lookup_allowed(\"restaurant__country__name\", \"USA\"), False)\n+\n         ma = EmployeeProfileAdmin(EmployeeProfile, self.site)\n         # Reverse OneToOneField\n         self.assertIs(\n",
  "django__django-16662": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex f0046ca..8256ac1 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -885,6 +885,55 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    def test_migration_import_sorting(self):\n+        \"\"\"\n+        Test that migration imports are sorted correctly, following isort and Django style.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.AddField(\n+                        \"anothermodel\",\n+                        \"anotherfield\",\n+                        models.IntegerField(),\n+                    ),\n+                ]\n+            },\n+        )\n+\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+\n+        # Check if imports are sorted correctly\n+        # Expected order: standard imports first, then django imports\n+        self.assertIn(\n+            \"import datetime\\nimport time\\nfrom django.db import migrations, models\\n\",\n+            output,\n+        )\n+\n+    def test_old_import_style_issue(self):\n+        \"\"\"\n+        Ensure that the old import style, described in the issue, is not present.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.AddField(\"examplemodel\", \"examplefield\", models.TextField()),\n+                ]\n+            },\n+        )\n+        \n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+\n+        # Ensure that the old incorrect style is not in the output\n+        incorrect_style = \"import datetime\\nfrom django.db import migrations, models\\nimport time\"\n+        self.assertNotIn(incorrect_style, output)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -894,6 +943,55 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    def test_migration_import_sorting(self):\n+        \"\"\"\n+        Test that migration imports are sorted correctly, following isort and Django style.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.AddField(\n+                        \"anothermodel\",\n+                        \"anotherfield\",\n+                        models.IntegerField(),\n+                    ),\n+                ]\n+            },\n+        )\n+\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+\n+        # Check if imports are sorted correctly\n+        # Expected order: standard imports first, then django imports\n+        self.assertIn(\n+            \"import datetime\\nimport time\\nfrom django.db import migrations, models\\n\",\n+            output,\n+        )\n+\n+    def test_old_import_style_issue(self):\n+        \"\"\"\n+        Ensure that the old import style, described in the issue, is not present.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.AddField(\"examplemodel\", \"examplefield\", models.TextField()),\n+                ]\n+            },\n+        )\n+        \n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+\n+        # Ensure that the old incorrect style is not in the output\n+        incorrect_style = \"import datetime\\nfrom django.db import migrations, models\\nimport time\"\n+        self.assertNotIn(incorrect_style, output)\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -915,6 +1013,55 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_migration_import_sorting(self):\n+        \"\"\"\n+        Test that migration imports are sorted correctly, following isort and Django style.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.AddField(\n+                        \"anothermodel\",\n+                        \"anotherfield\",\n+                        models.IntegerField(),\n+                    ),\n+                ]\n+            },\n+        )\n+\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+\n+        # Check if imports are sorted correctly\n+        # Expected order: standard imports first, then django imports\n+        self.assertIn(\n+            \"import datetime\\nimport time\\nfrom django.db import migrations, models\\n\",\n+            output,\n+        )\n+\n+    def test_old_import_style_issue(self):\n+        \"\"\"\n+        Ensure that the old import style, described in the issue, is not present.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.AddField(\"examplemodel\", \"examplefield\", models.TextField()),\n+                ]\n+            },\n+        )\n+        \n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+\n+        # Ensure that the old incorrect style is not in the output\n+        incorrect_style = \"import datetime\\nfrom django.db import migrations, models\\nimport time\"\n+        self.assertNotIn(incorrect_style, output)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -922,6 +1069,55 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_migration_import_sorting(self):\n+        \"\"\"\n+        Test that migration imports are sorted correctly, following isort and Django style.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.AddField(\n+                        \"anothermodel\",\n+                        \"anotherfield\",\n+                        models.IntegerField(),\n+                    ),\n+                ]\n+            },\n+        )\n+\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+\n+        # Check if imports are sorted correctly\n+        # Expected order: standard imports first, then django imports\n+        self.assertIn(\n+            \"import datetime\\nimport time\\nfrom django.db import migrations, models\\n\",\n+            output,\n+        )\n+\n+    def test_old_import_style_issue(self):\n+        \"\"\"\n+        Ensure that the old import style, described in the issue, is not present.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.AddField(\"examplemodel\", \"examplefield\", models.TextField()),\n+                ]\n+            },\n+        )\n+        \n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+\n+        # Ensure that the old incorrect style is not in the output\n+        incorrect_style = \"import datetime\\nfrom django.db import migrations, models\\nimport time\"\n+        self.assertNotIn(incorrect_style, output)\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n",
  "django__django-16801": "diff --git a/tests/model_fields/test_imagefield.py b/tests/model_fields/test_imagefield.py\nindex 9bf7f7d..0b50c90 100644\n--- a/tests/model_fields/test_imagefield.py\n+++ b/tests/model_fields/test_imagefield.py\n@@ -328,6 +328,26 @@ class ImageFieldNoDimensionsTests(ImageFieldTwoDimensionsTests):\n \n     PersonModel = Person\n \n+from django.db.models import signals\n+\n+@skipIf(Image is None, \"Pillow is required to test ImageField\")\n+class ImageFieldNoDimensionsTests(ImageFieldTwoDimensionsTests):\n+    \"\"\"\n+    Tests behavior of an ImageField with no dimension fields.\n+    \"\"\"\n+\n+    PersonModel = Person\n+\n+    def test_post_init_not_connected(self):\n+        \"\"\"\n+        Verify that the post_init signal handler is not connected\n+        when no width_field and height_field are set.\n+        \"\"\"\n+        person_model_id = id(self.PersonModel)\n+        self.assertNotIn(\n+            person_model_id,\n+            [sender_id for (_, sender_id), *_ in signals.post_init.receivers],\n+        )\n \n @skipIf(Image is None, \"Pillow is required to test ImageField\")\n class ImageFieldOneDimensionTests(ImageFieldTwoDimensionsTests):\n",
  "django__django-16819": "",
  "django__django-16877": "",
  "django__django-16899": "diff --git a/tests/admin_checks/tests.py b/tests/admin_checks/tests.py\nindex 5130136..6c10b27 100644\n--- a/tests/admin_checks/tests.py\n+++ b/tests/admin_checks/tests.py\n@@ -790,6 +790,21 @@ class SystemChecksTestCase(SimpleTestCase):\n \n         errors = SongAdmin(Song, AdminSite()).check()\n         self.assertEqual(errors, [])\n+    \n+    def test_error_message_includes_field_name(self):\n+        class CityInline(admin.TabularInline):\n+            model = City\n+            readonly_fields = [\"postal_code\"]\n+\n+        errors = CityInline(State, AdminSite()).check()\n+        expected = [\n+            checks.Error(\n+                \"The value of 'readonly_fields[0]' refers to 'postal_code', which is not a callable, an attribute of 'CityInline', or an attribute of 'admin_checks.City'.\",\n+                obj=CityInline,\n+                id=\"admin.E035\",\n+            )\n+        ]\n+        self.assertEqual(errors, expected)\n \n     def test_nonexistent_field(self):\n         class SongAdmin(admin.ModelAdmin):\n",
  "django__django-16901": "diff --git a/tests/xor_lookups/tests.py b/tests/xor_lookups/tests.py\nindex 389d908..580fa8c 100644\n--- a/tests/xor_lookups/tests.py\n+++ b/tests/xor_lookups/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import Q\n from django.test import TestCase\n \n@@ -18,8 +19,27 @@ class XorLookupsTests(TestCase):\n             Number.objects.filter(Q(num__lte=7) ^ Q(num__gte=3)),\n             self.numbers[:3] + self.numbers[8:],\n         )\n+    \n+    def test_filter_xor_three_conditions(self):\n+        # Testing XOR operation with three conditions (parity behavior)\n+        self.assertCountEqual(\n+            Number.objects.filter(Q(num__gte=1) ^ Q(num__gte=3) ^ Q(num__gte=5)),\n+            self.numbers[:1] + self.numbers[3:5],\n+        )\n+\n+    def test_filter_xor_four_conditions(self):\n+        # Testing XOR operation with four conditions (should result in empty list)\n+        self.assertCountEqual(\n+            Number.objects.filter(Q(num__gte=1) ^ Q(num__gte=3) ^ Q(num__gte=5) ^ Q(num__gte=7)),\n+            [],\n+        )\n \n-    def test_filter_negated(self):\n+    def test_filter_xor_five_conditions(self):\n+        # Testing XOR operation with five conditions (parity behavior)\n+        self.assertCountEqual(\n+            Number.objects.filter(Q(num__gte=1) ^ Q(num__gte=3) ^ Q(num__gte=5) ^ Q(num__gte=7) ^ Q(num__gte=9)),\n+            self.numbers[1:3] + self.numbers[5:7] + self.numbers[9:],\n+        )\n         self.assertCountEqual(\n             Number.objects.filter(Q(num__lte=7) ^ ~Q(num__lt=3)),\n             self.numbers[:3] + self.numbers[8:],\n@@ -64,4 +84,4 @@ class XorLookupsTests(TestCase):\n         self.assertCountEqual(\n             Number.objects.filter(Q(pk__in=[]) ^ Q(num__gte=5)),\n             self.numbers[5:],\n-        )\n+        )\n",
  "django__django-17029": "diff --git a/tests/apps/tests.py b/tests/apps/tests.py\nindex f7c2c67..f162f57 100644\n--- a/tests/apps/tests.py\n+++ b/tests/apps/tests.py\n@@ -138,6 +138,19 @@ class AppsTests(SimpleTestCase):\n             config = apps.get_app_config(\"two_configs_one_default_app\")\n         self.assertIsInstance(config, TwoConfig)\n \n+    @override_settings(INSTALLED_APPS=SOME_INSTALLED_APPS)\n+    def test_clear_cache(self):\n+        # Set cache by calling get_swappable_settings_name\n+        self.assertIsNone(apps.get_swappable_settings_name(\"admin.LogEntry\"))\n+        apps.get_models()\n+\n+        # Call clear_cache and assert both caches are cleared\n+        apps.clear_cache()\n+\n+        # The cache_size should be 0 for both get_swappable_settings_name and get_models\n+        self.assertEqual(apps.get_swappable_settings_name.cache_info().currsize, 0)\n+        self.assertEqual(apps.get_models.cache_info().currsize, 0)\n+    \n     @override_settings(INSTALLED_APPS=SOME_INSTALLED_APPS)\n     def test_get_app_configs(self):\n         \"\"\"\n",
  "django__django-17084": "",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..e987a02 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -197,6 +197,37 @@ class OperationWriterTests(SimpleTestCase):\n             \"),\",\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -255,12 +286,74 @@ class WriterTests(SimpleTestCase):\n             decimal.Decimal(\"1.3\"), (\"Decimal('1.3')\", {\"from decimal import Decimal\"})\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n         self.assertSerializedEqual(Money(\"1.3\"))\n         self.assertSerializedResultEqual(\n             Money(\"1.3\"),\n             (\"migrations.test_writer.Money('1.3')\", {\"import migrations.test_writer\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -296,6 +389,37 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r\"^foo$\")\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -306,6 +430,37 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\n@@ -313,6 +468,37 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\n@@ -320,10 +506,72 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -331,11 +579,73 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(\n             default=TextEnum.B, choices=[(m.value, m) for m in TextEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -344,10 +654,72 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -356,9 +728,71 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.CharField(\n             default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -367,9 +801,71 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.IntegerField(\n             default=IntEnum.A, choices=[(m.value, m) for m in IntEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -379,6 +875,37 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n@@ -387,6 +914,37 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n@@ -394,9 +952,71 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -405,6 +1025,37 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A | IntFlagEnum.B,\n             (\n@@ -414,6 +1065,37 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = \"A\", \"A value\"\n@@ -433,6 +1115,37 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             (\"datetime.date(1969, 7, 20)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.CharField(default=TextChoices.B, choices=TextChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -440,12 +1153,74 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -456,6 +1231,37 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\",\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_nested_class(self):\n         for nested_cls in [self.NestedEnum, self.NestedChoices]:\n             cls_name = nested_cls.__name__\n@@ -478,14 +1284,107 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {\"import uuid\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {\"import uuid\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n         field = models.UUIDField(\n             choices=((uuid_a, \"UUID A\"), (uuid_b, \"UUID B\")), default=uuid_a\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -495,6 +1394,37 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\",\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_pathlib(self):\n         # Pure path objects work in all platforms.\n         self.assertSerializedEqual(pathlib.PurePosixPath())\n@@ -523,6 +1453,37 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"models.FilePathField(path=pathlib.PurePosixPath('/home/user'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertIn(\"import pathlib\", imports)\n \n     def test_serialize_path_like(self):\n@@ -554,13 +1515,106 @@ class WriterTests(SimpleTestCase):\n         self.assertSerializedEqual(\n             datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone())\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedEqual(\n             datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180))\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc),\n             (\n@@ -568,6 +1622,37 @@ class WriterTests(SimpleTestCase):\n                 {\"import datetime\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(\n                 2012, 1, 1, 2, 1, tzinfo=zoneinfo.ZoneInfo(\"Europe/Paris\")\n@@ -578,12 +1663,74 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n@@ -593,20 +1740,144 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(\n             SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\")\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)), (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -624,6 +1895,37 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.RegexValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a compiled regex.\n@@ -633,6 +1935,37 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test a string regex with flag\n@@ -643,6 +1976,37 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[0-9]+$', \"\n             \"flags=re.RegexFlag['DOTALL'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n@@ -653,6 +2017,37 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', \"\n             \"'invalid')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a subclass.\n@@ -661,6 +2056,37 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.EmailValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.serialize_round_trip(validator)\n \n         validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(\n@@ -671,9 +2097,71 @@ class WriterTests(SimpleTestCase):\n             string, \"migrations.test_writer.EmailValidator(message='hello')\"\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n         validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(\n             message=\"hello\"\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n             MigrationWriter.serialize(validator)\n \n@@ -700,6 +2188,37 @@ class WriterTests(SimpleTestCase):\n             models.OrderBy(models.F(\"name\").desc()),\n             name=\"complex_func_index\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         string, imports = MigrationWriter.serialize(index)\n         self.assertEqual(\n             string,\n@@ -711,6 +2230,37 @@ class WriterTests(SimpleTestCase):\n             \"models.OrderBy(models.OrderBy(models.F('name'), descending=True)), \"\n             \"name='complex_func_index')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertEqual(imports, {\"from django.db import models\"})\n \n     def test_serialize_empty_nonempty_tuple(self):\n@@ -762,6 +2312,37 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.models\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedEqual(FoodManager(\"a\", \"b\"))\n         self.assertSerializedEqual(FoodManager(\"x\", \"y\", c=3, d=4))\n \n@@ -772,6 +2353,37 @@ class WriterTests(SimpleTestCase):\n             frozenset(\"cba\"), (\"frozenset(['a', 'b', 'c'])\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_set(self):\n         self.assertSerializedEqual(set())\n         self.assertSerializedResultEqual(set(), (\"set()\", set()))\n@@ -809,6 +2421,37 @@ class WriterTests(SimpleTestCase):\n             (\"('models.Model', {'from django.db import models'})\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -848,6 +2491,37 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [(\"testapp\", \"some_other_one\")],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         # We don't test the output formatting - that's too fragile.\n@@ -887,6 +2561,37 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -896,6 +2601,37 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_sorted_dependencies(self):\n         migration = type(\n             \"Migration\",\n@@ -912,6 +2648,37 @@ class WriterTests(SimpleTestCase):\n                 ],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         output = MigrationWriter(migration, include_header=False).as_string()\n         self.assertIn(\n             \"    dependencies = [\\n\"\n@@ -923,6 +2690,37 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -949,6 +2747,37 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -956,6 +2785,37 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -1001,6 +2861,37 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\"from django.db import migrations\\n\", output)\n@@ -1017,6 +2908,37 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\",\n         )\n \n+    def test_serialize_nested_class_method_as_field_default(self):\n+        \"\"\"\n+        Test that class methods from nested classes are serialized correctly\n+        when used as a field default.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+        \n+            capabilities = ArrayField(\n+                models.CharField(\n+                    choices=Profile.Capability.choices, \n+                    max_length=30, \n+                    blank=True\n+                ),\n+                null=True,\n+                default=Profile.Capability.default,\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        string, imports = MigrationWriter.serialize(field)\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_register_serializer(self):\n         class ComplexSerializer(BaseSerializer):\n             def serialize(self):\n@@ -1032,4 +2954,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "django__django-7530": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex a74680b..d033f74 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -641,6 +641,28 @@ class MakeMigrationsTests(MigrationTestBase):\n                 allow_migrate.assert_called_with('other', 'migrations', model_name='UnicodeModel')\n                 self.assertEqual(ensure_schema.call_count, 4)\n \n+    def test_makemigrations_respects_app_model_pairs(self):\n+        \"\"\"\n+        Test that makemigrations calls allow_migrate() with the correct\n+        (app_label, model) pairs.\n+        \"\"\"\n+        apps.register_model('migrations', UnicodeModel)\n+        apps.register_model('migrations2', UnicodeModel)\n+\n+        with self.settings(\n+            INSTALLED_APPS=['migrations', 'migrations2'],\n+            DATABASE_ROUTERS=['migrations.routers.TestRouter']\n+        ):\n+            with mock.patch.object(TestRouter, 'allow_migrate', return_value=True) as allow_migrate:\n+                call_command('makemigrations', stdout=mock.MagicMock(), no_color=True, verbosity=0)\n+                \n+                # Check that allow_migrate was called with correct app_label/models\n+                allow_migrate.assert_any_call('default', 'migrations', model_name='UnicodeModel')\n+                allow_migrate.assert_any_call('default', 'migrations2', model_name='UnicodeModel')\n+\n+            # Further checks can be done here if specific models were to be\n+            # verified for particular apps\n+\n     def test_failing_migration(self):\n         # If a migration fails to serialize, it shouldn't generate an empty file. #21280\n         apps.register_model('migrations', UnserializableModel)\n",
  "django__django-9296": "diff --git a/tests/pagination/tests.py b/tests/pagination/tests.py\nindex b9b5fbc..dbbf243 100644\n--- a/tests/pagination/tests.py\n+++ b/tests/pagination/tests.py\n@@ -290,13 +290,35 @@ class PaginationTests(SimpleTestCase):\n \n     def test_get_page_empty_object_list_and_allow_empty_first_page_false(self):\n         \"\"\"\n-        Paginator.get_page() raises EmptyPage if allow_empty_first_page=False\n+from django.core.paginator import Paginator\n+from django.test import TestCase\n         and object_list is empty.\n         \"\"\"\n         paginator = Paginator([], 2, allow_empty_first_page=False)\n         with self.assertRaises(EmptyPage):\n             paginator.get_page(1)\n \n+    def test_paginator_iteration(self):\n+        paginator = Paginator([1, 2, 3], 2)\n+        page_iterator = iter(paginator)\n+        for page, expected in enumerate(([1, 2], [3]), start=1):\n+            with self.subTest(page=page):\n+                self.assertEqual(expected, list(next(page_iterator)))\n+\n+    def test_paginator_iteration_with_more_pages(self):\n+        paginator = Paginator(['a', 'b', 'c', 'd', 'e'], 2)\n+        page_iterator = iter(paginator)\n+        expected_pages = (['a', 'b'], ['c', 'd'], ['e'])\n+        for page, expected in enumerate(expected_pages, start=1):\n+            with self.subTest(page=page):\n+                self.assertEqual(expected, list(next(page_iterator)))\n+\n+    def test_paginator_empty(self):\n+        paginator = Paginator([], 2)\n+        page_iterator = iter(paginator)\n+        with self.assertRaises(StopIteration):\n+            next(page_iterator)\n+\n \n class ModelPaginationTests(TestCase):\n     \"\"\"\n",
  "matplotlib__matplotlib-13989": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 5483eef..0963d5c 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -6359,8 +6359,34 @@ def test_hist_auto_bins():\n \n def test_hist_nan_data():\n     fig, (ax1, ax2) = plt.subplots(2)\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n \n-    data = [1, 2, 3]\n+def test_hist_range_and_density():\n+    # Original test case; ensures specified range (0, 1) is respected with density=True\n+    _, bins, _ = plt.hist(np.random.rand(10), bins='auto', range=(0, 1), density=True)\n+    assert bins[0] == 0\n+    assert bins[-1] == 1\n+\n+def test_hist_range_with_density_and_different_data_size():\n+    # Test with a larger dataset and different bin settings\n+    data = np.random.normal(loc=0.5, scale=0.1, size=1000)\n+    _, bins, _ = plt.hist(data, bins=15, range=(0, 1), density=True)\n+    assert bins[0] == 0\n+    assert bins[-1] == 1\n+\n+def test_hist_range_without_density():\n+    # Verifies that range parameter works without density\n+    _, bins, _ = plt.hist(np.random.rand(10), bins='auto', range=(0, 1), density=False)\n+    assert bins[0] == 0\n+    assert bins[-1] == 1\n+\n+def test_hist_range_and_density_with_no_data():\n+    # Ensures the function handles empty data gracefully with range specified\n+    _, bins, _ = plt.hist([], bins='auto', range=(0, 1), density=True)\n+    assert bins[0] == 0\n+    assert bins[-1] == 1\n     nan_data = data + [np.nan]\n \n     bins, edges, _ = ax1.hist(data)\n@@ -6368,4 +6394,4 @@ def test_hist_nan_data():\n         nanbins, nanedges, _ = ax2.hist(nan_data)\n \n     assert np.allclose(bins, nanbins)\n-    assert np.allclose(edges, nanedges)\n+    assert np.allclose(edges, nanedges)\n",
  "matplotlib__matplotlib-14623": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex c9ad946..a481864 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -938,8 +938,13 @@ def test_inverted_limits():\n     assert ax.get_ylim() == (5, -3)\n     plt.close()\n \n-\n-@image_comparison(baseline_images=['nonfinite_limits'])\n+def test_invert_log_axis_with_limits():\n+    fig, ax = plt.subplots()\n+    ax.set_yscale('log')\n+    ax.plot([1, 10, 100], [1, 10, 100])  # Sample data\n+    ax.set_ylim(100, 1)  # Attempt to invert the y-axis\n+    assert ax.get_ylim() == (100, 1)  # Check if y-limits are inverted\n+    plt.close()\n def test_nonfinite_limits():\n     x = np.arange(0., np.e, 0.01)\n     # silence divide by zero warning from log(0)\n",
  "matplotlib__matplotlib-20488": "",
  "matplotlib__matplotlib-20826": "",
  "matplotlib__matplotlib-20859": "",
  "matplotlib__matplotlib-22719": "diff --git a/lib/matplotlib/tests/test_category.py b/lib/matplotlib/tests/test_category.py\nindex 40c4dcf..e32e318 100644\n--- a/lib/matplotlib/tests/test_category.py\n+++ b/lib/matplotlib/tests/test_category.py\n@@ -306,9 +306,25 @@ def test_overriding_units_in_plot(fig_test, fig_ref):\n         assert x_units is ax.xaxis.units\n         assert y_units is ax.yaxis.units\n \n+def test_no_deprecation_on_empty_data():\n+    \"\"\"Smoke test to check that no deprecation warning is emitted. See #22640.\"\"\"\n+    fig, ax = plt.subplots()\n+    ax.xaxis.update_units([\"a\", \"b\"])\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\"error\", MatplotlibDeprecationWarning)\n+        # This should produce no warnings\n+        ax.plot([], [])\n+\n+def test_deprecation_handling_with_data():\n+    \"\"\"Test to ensure that proper deprecation warning occurs with valid data.\"\"\"\n+    fig, ax = plt.subplots()\n+    ax.xaxis.update_units([\"a\", \"b\"])\n+    with pytest.warns(MatplotlibDeprecationWarning):\n+        # This will warn due to the deprecation of passing through numbers\n+        ax.plot([1, 2], [3, 4])\n \n def test_hist():\n     fig, ax = plt.subplots()\n     n, bins, patches = ax.hist(['a', 'b', 'a', 'c', 'ff'])\n     assert n.shape == (10,)\n-    np.testing.assert_allclose(n, [2., 0., 0., 1., 0., 0., 1., 0., 0., 1.])\n+    np.testing.assert_allclose(n, [2., 0., 0., 1., 0., 0., 1., 0., 0., 1.])\n",
  "matplotlib__matplotlib-22865": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex 2c28713..ef0d768 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -912,7 +912,35 @@ def test_proportional_colorbars():\n     extends = ['neither', 'both']\n     spacings = ['uniform', 'proportional']\n     fig, axs = plt.subplots(2, 2)\n-    for i in range(2):\n+    import matplotlib as mpl\n+    import numpy as np\n+    import matplotlib.pyplot as plt\n+    from matplotlib.colors import from_levels_and_colors\n+\n+    @pytest.mark.parametrize(\"extend, drawedges, expected_segments\", [\n+        ('both', True, True),\n+        ('both', False, False),\n+        ('min', True, True),\n+        ('max', True, True),\n+        ('neither', True, True)\n+    ])\n+    def test_colorbar_extend_and_drawedges(extend, drawedges, expected_segments):\n+        bounds = np.arange(10)\n+        nb_colors = len(bounds) + 1\n+        cmap = plt.get_cmap(\"viridis\")\n+        colors = cmap(np.linspace(100, 255, nb_colors).astype(int))\n+        cmap, norm = from_levels_and_colors(bounds, colors, extend=extend)\n+\n+        plt.figure(figsize=(5, 1))\n+        ax = plt.subplot(111)\n+        cbar = mpl.colorbar.ColorbarBase(ax, cmap=cmap, norm=norm, orientation='horizontal', drawedges=drawedges)\n+\n+        # Check for the presence of divider segments at edges if drawedges is True\n+        segments = cbar.dividers.get_segments()\n+        if expected_segments:\n+            assert len(segments) > 0, \"Expected divider segments but got none.\"\n+        else:\n+            assert len(segments) == 0, \"Expected no divider segments but found some.\"\n         for j in range(2):\n             CS3 = axs[i, j].contourf(X, Y, Z, levels, cmap=cmap, norm=norm,\n                                      extend=extends[i])\n",
  "matplotlib__matplotlib-23299": "diff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 144880c..9fafe12 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -489,8 +489,39 @@ def test_validate_fontstretch(stretch, parsed_stretch):\n     else:\n         assert validate_fontstretch(stretch) == parsed_stretch\n \n-\n-def test_keymaps():\n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend, rc_context\n+\n+def test_no_backend_reset_rccontext():\n+    assert mpl.rcParams['backend'] != 'module://aardvark', \\\n+        f\"Backend unexpectedly set to 'module://aardvark'\"\n+    with mpl.rc_context():\n+        mpl.rcParams['backend'] = 'module://aardvark'\n+    assert mpl.rcParams['backend'] == 'module://aardvark', \\\n+        f\"Backend unexpectedly reverted from 'module://aardvark'\"\n+\n+def test_get_backend_rc_context():\n+    # Test that calling get_backend() does not clear figures created inside rc_context\n+    # This verifies that the bug described in the issue is resolved.\n+    \n+    # Remove any existing figures\n+    plt.close('all')\n+    \n+    # Create a figure within an rc_context\n+    with rc_context():\n+        fig1 = plt.figure()\n+    \n+    # Record the state of Gcf before calling get_backend()\n+    before = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+    \n+    # Call get_backend\n+    get_backend()\n+    \n+    # Record the state of Gcf after calling get_backend()\n+    after = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+    \n+    # Check that the state is unchanged\n+    assert before == after, f\"\\nBefore: {before}\\nAfter: {after}\"\n     key_list = [k for k in mpl.rcParams if 'keymap' in k]\n     for k in key_list:\n         assert isinstance(mpl.rcParams[k], list)\n",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..540059c 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -12,8 +12,17 @@ from matplotlib.testing.decorators import image_comparison, check_figures_equal\n from matplotlib.testing.widgets import mock_event\n from matplotlib.collections import LineCollection, PolyCollection\n from matplotlib.patches import Circle\n-\n import matplotlib.pyplot as plt\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+@check_figures_equal(extensions=[\"png\"])\n+def test_set_visible_3d(fig_test, fig_ref):\n+    ax = fig_test.add_subplot(projection='3d')\n+    ax.scatter([1], [1], [1])\n+    ax.set_visible(False)\n+\n+    ax_ref = fig_ref.add_subplot(projection='3d')\n+    # No scatter added to reference, it should appear empty.\n import numpy as np\n \n \n",
  "matplotlib__matplotlib-23412": "diff --git a/lib/matplotlib/tests/test_patches.py b/lib/matplotlib/tests/test_patches.py\nindex 6db3e7e..b45114f 100644\n--- a/lib/matplotlib/tests/test_patches.py\n+++ b/lib/matplotlib/tests/test_patches.py\n@@ -156,8 +156,44 @@ def test_negative_rect():\n     neg_vertices = Rectangle((0, 0), -3, -2).get_verts()[:-1]\n     assert_array_equal(np.roll(neg_vertices, 2, 0), pos_vertices)\n \n+import matplotlib.pyplot as plt\n+from matplotlib.patches import Rectangle, Ellipse\n+import numpy as np\n+from numpy.testing import assert_array_equal\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+@check_figures_equal(extensions=['png'])\n+def test_dash_offset_rectangle(fig_test, fig_ref):\n+    \"\"\"Test that a rectangle respects dash offset.\"\"\"\n+    ax_test = fig_test.add_subplot()\n+    ax_ref = fig_ref.add_subplot()\n+\n+    loc = (0.1, 0.1)\n+    width, height = (0.8, 0.8)\n+\n+    rect_offset = Rectangle(loc, width, height, linewidth=3, edgecolor='g', linestyle=(5, (5, 10)))\n+    rect_no_offset = Rectangle(loc, width, height, linewidth=3, edgecolor='c', linestyle=(0, (5, 10)))\n+    \n+    ax_test.add_patch(rect_no_offset)\n+    ax_test.add_patch(rect_offset)\n+\n+    ax_ref.add_patch(rect_no_offset)\n+    ax_ref.add_patch(rect_offset)\n+\n+@check_figures_equal(extensions=['png'])\n+def test_dash_offset_ellipse(fig_test, fig_ref):\n+    \"\"\"Test that an ellipse respects dash offset.\"\"\"\n+    ax_test = fig_test.add_subplot()\n+    ax_ref = fig_ref.add_subplot()\n+\n+    ellipse_offset = Ellipse((0.5, 0.5), width=1, height=0.5, linewidth=3, edgecolor='r', linestyle=(5, (5, 10)))\n+    ellipse_no_offset = Ellipse((0.5, 0.5), width=1, height=0.5, linewidth=3, edgecolor='b', linestyle=(0, (5, 10)))\n+    \n+    ax_test.add_patch(ellipse_no_offset)\n+    ax_test.add_patch(ellipse_offset)\n \n-@image_comparison(['clip_to_bbox'])\n+    ax_ref.add_patch(ellipse_no_offset)\n+    ax_ref.add_patch(ellipse_offset)\n def test_clip_to_bbox():\n     fig, ax = plt.subplots()\n     ax.set_xlim([-18, 20])\n",
  "matplotlib__matplotlib-24026": "",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24570": "",
  "matplotlib__matplotlib-24627": "",
  "matplotlib__matplotlib-24637": "diff --git a/lib/matplotlib/tests/test_backend_svg.py b/lib/matplotlib/tests/test_backend_svg.py\nindex 8817464..7ba4d9f 100644\n--- a/lib/matplotlib/tests/test_backend_svg.py\n+++ b/lib/matplotlib/tests/test_backend_svg.py\n@@ -577,13 +577,81 @@ def test_svg_font_string(font_str, include_generic):\n     plt.rcParams[f\"font.{generic}\"] = rest\n     plt.rcParams[\"font.size\"] = size\n     plt.rcParams[\"svg.fonttype\"] = \"none\"\n+from io import BytesIO\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n+\n+\n+def test_annotationbbox_gid():\n+    # Test that object gid appears in the AnnotationBbox\n+    # in output svg.\n+    fig = plt.figure()\n+    ax = fig.add_subplot()\n+    arr_img = np.ones((32, 32))\n+    xy = (0.3, 0.55)\n+\n+    imagebox = OffsetImage(arr_img, zoom=0.1)\n+    imagebox.image.axes = ax\n+\n+    ab = AnnotationBbox(imagebox, xy,\n+                        xybox=(120., -80.),\n+                        xycoords='data',\n+                        boxcoords=\"offset points\",\n+                        pad=0.5,\n+                        arrowprops=dict(\n+                            arrowstyle=\"->\",\n+                            connectionstyle=\"angle,angleA=0,angleB=90,rad=3\")\n+                        )\n+    ab.set_gid(\"a test for issue 20044\")\n+    ax.add_artist(ab)\n \n+    with BytesIO() as fd:\n+        fig.savefig(fd, format='svg')\n+        buf = fd.getvalue().decode('utf-8')\n+\n+    expected = '<g id=\"a test for issue 20044\">'\n+    assert expected in buf\n     fig, ax = plt.subplots()\n     if generic == \"sans-serif\":\n         generic_options = [\"sans\", \"sans-serif\", \"sans serif\"]\n     else:\n         generic_options = [generic]\n+from io import BytesIO\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n+\n+\n+def test_annotationbbox_gid():\n+    # Test that object gid appears in the AnnotationBbox\n+    # in output svg.\n+    fig = plt.figure()\n+    ax = fig.add_subplot()\n+    arr_img = np.ones((32, 32))\n+    xy = (0.3, 0.55)\n+\n+    imagebox = OffsetImage(arr_img, zoom=0.1)\n+    imagebox.image.axes = ax\n+\n+    ab = AnnotationBbox(imagebox, xy,\n+                        xybox=(120., -80.),\n+                        xycoords='data',\n+                        boxcoords=\"offset points\",\n+                        pad=0.5,\n+                        arrowprops=dict(\n+                            arrowstyle=\"->\",\n+                            connectionstyle=\"angle,angleA=0,angleB=90,rad=3\")\n+                        )\n+    ab.set_gid(\"a test for issue 20044\")\n+    ax.add_artist(ab)\n \n+    with BytesIO() as fd:\n+        fig.savefig(fd, format='svg')\n+        buf = fd.getvalue().decode('utf-8')\n+\n+    expected = '<g id=\"a test for issue 20044\">'\n+    assert expected in buf\n     for generic_name in generic_options:\n         # test that fallback works\n         ax.text(0.5, 0.5, \"There are \u51e0\u4e2a\u6c49\u5b57 in between!\",\n@@ -592,11 +660,79 @@ def test_svg_font_string(font_str, include_generic):\n         ax.text(0.5, 0.1, \"There are \u51e0\u4e2a\u6c49\u5b57 in between!\",\n                 family=[explicit, *rest, generic_name], ha=\"center\")\n     ax.axis(\"off\")\n+from io import BytesIO\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n+\n+\n+def test_annotationbbox_gid():\n+    # Test that object gid appears in the AnnotationBbox\n+    # in output svg.\n+    fig = plt.figure()\n+    ax = fig.add_subplot()\n+    arr_img = np.ones((32, 32))\n+    xy = (0.3, 0.55)\n+\n+    imagebox = OffsetImage(arr_img, zoom=0.1)\n+    imagebox.image.axes = ax\n+\n+    ab = AnnotationBbox(imagebox, xy,\n+                        xybox=(120., -80.),\n+                        xycoords='data',\n+                        boxcoords=\"offset points\",\n+                        pad=0.5,\n+                        arrowprops=dict(\n+                            arrowstyle=\"->\",\n+                            connectionstyle=\"angle,angleA=0,angleB=90,rad=3\")\n+                        )\n+    ab.set_gid(\"a test for issue 20044\")\n+    ax.add_artist(ab)\n \n+    with BytesIO() as fd:\n+        fig.savefig(fd, format='svg')\n+        buf = fd.getvalue().decode('utf-8')\n+\n+    expected = '<g id=\"a test for issue 20044\">'\n+    assert expected in buf\n     with BytesIO() as fd:\n         fig.savefig(fd, format=\"svg\")\n         buf = fd.getvalue()\n+from io import BytesIO\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.offsetbox import (OffsetImage, AnnotationBbox)\n+\n+\n+def test_annotationbbox_gid():\n+    # Test that object gid appears in the AnnotationBbox\n+    # in output svg.\n+    fig = plt.figure()\n+    ax = fig.add_subplot()\n+    arr_img = np.ones((32, 32))\n+    xy = (0.3, 0.55)\n+\n+    imagebox = OffsetImage(arr_img, zoom=0.1)\n+    imagebox.image.axes = ax\n+\n+    ab = AnnotationBbox(imagebox, xy,\n+                        xybox=(120., -80.),\n+                        xycoords='data',\n+                        boxcoords=\"offset points\",\n+                        pad=0.5,\n+                        arrowprops=dict(\n+                            arrowstyle=\"->\",\n+                            connectionstyle=\"angle,angleA=0,angleB=90,rad=3\")\n+                        )\n+    ab.set_gid(\"a test for issue 20044\")\n+    ax.add_artist(ab)\n \n+    with BytesIO() as fd:\n+        fig.savefig(fd, format='svg')\n+        buf = fd.getvalue().decode('utf-8')\n+\n+    expected = '<g id=\"a test for issue 20044\">'\n+    assert expected in buf\n     tree = xml.etree.ElementTree.fromstring(buf)\n     ns = \"http://www.w3.org/2000/svg\"\n     text_count = 0\n",
  "matplotlib__matplotlib-24970": "diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex 2be14fe..afd6e53 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -20,6 +20,30 @@ import matplotlib.scale as mscale\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n \n \n+import pytest\n+import numpy as np\n+from numpy.testing import assert_array_equal, assert_array_almost_equal\n+import matplotlib as mpl\n+import matplotlib.colors as mcolors\n+import warnings\n+\n+@pytest.mark.parametrize(\"dtype, value\", [\n+    (np.uint8, 257),     # Originally caused warning\n+    (np.uint8, -1),      # Negative values\n+    (np.uint8, 258),     # Just above uint8 limit\n+    (np.uint8, 256),     # Boundary condition\n+    (int, 1024),         # Large positive number\n+    (int, -1024),        # Large negative number\n+])\n+def test_deprecation_warnings(dtype, value):\n+    cm = mpl.colormaps[\"viridis\"]\n+    with warnings.catch_warnings(record=True) as w:\n+        warnings.simplefilter(\"always\")\n+        cm(dtype(value))\n+        assert len(w) == 0\n+        for warning in w:\n+            assert \"DeprecationWarning\" not in str(warning.message)\n+\n @pytest.mark.parametrize('N, result', [\n     (5, [1, .6, .2, .1, 0]),\n     (2, [1, 0]),\n",
  "matplotlib__matplotlib-25122": "diff --git a/lib/matplotlib/tests/test_mlab.py b/lib/matplotlib/tests/test_mlab.py\nindex 51d0c35..0df9b50 100644\n--- a/lib/matplotlib/tests/test_mlab.py\n+++ b/lib/matplotlib/tests/test_mlab.py\n@@ -615,6 +615,22 @@ class TestSpectral:\n                                  noverlap=0,\n                                  sides=self.sides,\n                                  window=mlab.window_none)\n+    \n+    def test_psd_window_flattop(self):\n+        if self.NFFT_density is None:\n+            return\n+        from scipy.signal import windows\n+        ydata = np.arange(self.NFFT_density)\n+        windowVals = windows.flattop(self.NFFT_density)\n+        spec, freqs = mlab.psd(x=ydata,\n+                               NFFT=self.NFFT_density,\n+                               Fs=self.Fs,\n+                               noverlap=0,\n+                               window=windowVals)\n+        # Calculate the expected power spectrum without np.abs for the window correction\n+        spec_corrected = spec * (windowVals.sum()**2) / (windowVals**2).sum()\n+        # No np.abs() in correction, expecting it to be close without np.abs influence\n+        assert_allclose(spec, spec_corrected, atol=1e-08)\n         spec_c *= len(ycontrol1)/(np.abs(windowVals)**2).sum()\n         assert_array_equal(fsp_g, fsp_c)\n         assert_array_equal(fsp_b, fsp_c)\n@@ -662,6 +678,22 @@ class TestSpectral:\n                                  noverlap=0,\n                                  sides=self.sides,\n                                  window=mlab.window_none)\n+    \n+    def test_psd_window_flattop(self):\n+        if self.NFFT_density is None:\n+            return\n+        from scipy.signal import windows\n+        ydata = np.arange(self.NFFT_density)\n+        windowVals = windows.flattop(self.NFFT_density)\n+        spec, freqs = mlab.psd(x=ydata,\n+                               NFFT=self.NFFT_density,\n+                               Fs=self.Fs,\n+                               noverlap=0,\n+                               window=windowVals)\n+        # Calculate the expected power spectrum without np.abs for the window correction\n+        spec_corrected = spec * (windowVals.sum()**2) / (windowVals**2).sum()\n+        # No np.abs() in correction, expecting it to be close without np.abs influence\n+        assert_allclose(spec, spec_corrected, atol=1e-08)\n         spec_c *= len(ycontrol1)/(np.abs(windowVals)**2).sum()\n         assert_array_equal(fsp_g, fsp_c)\n         assert_array_equal(fsp_b, fsp_c)\n",
  "matplotlib__matplotlib-25287": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex c24a832..8917528 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -7801,6 +7801,9 @@ def test_xtickcolor_is_not_xticklabelcolor():\n         assert tick.label1.get_color() == 'blue'\n \n \n+import matplotlib.pyplot as plt\n+import pytest\n+\n def test_ytickcolor_is_not_yticklabelcolor():\n     plt.rcParams['ytick.color'] = 'yellow'\n     plt.rcParams['ytick.labelcolor'] = 'blue'\n",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..8ad5002 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -89,8 +90,18 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n-\n-@mpl.style.context(\"default\")\n+@pytest.mark.parametrize(\"draggable\", [True, False])\n+def test_pickle_draggable_legend(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot([0, 1, 2], [0, 1, 4], label='Sample Data')\n+    legend = ax.legend(draggable=draggable)\n+    pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+    \n+    # Ensure that no error is raised upon pickling\n+    assert \"FigureCanvasAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+    \n+    loaded_fig = pickle.loads(pkl)\n+    plt.close(loaded_fig)\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..f9dfb2a 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -34,7 +34,33 @@ def test_simple():\n #    pickle.dump(ax, BytesIO(), pickle.HIGHEST_PROTOCOL)\n \n     plt.figure()\n-    plt.bar(x=np.arange(10), height=np.arange(10))\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    \"\"\"Test that a figure with aligned labels can be pickled without error.\"\"\"\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    fig.align_labels()  # Align labels before pickling\n+    # Attempt to pickle the figure\n+    try:\n+        pickle_data = pickle.dumps(fig)\n+        print(\"Pickling successful.\")\n+    except Exception as e:\n+        print(f\"Pickling failed with exception: {e}\")\n+    finally:\n+        plt.close(fig)\n     pickle.dump(plt.gca(), BytesIO(), pickle.HIGHEST_PROTOCOL)\n \n     fig = plt.figure()\n",
  "matplotlib__matplotlib-25775": "",
  "matplotlib__matplotlib-26113": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex ebe9106..53b8afe 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -998,7 +998,77 @@ def test_hexbin_log_clim():\n     h = ax.hexbin(x, y, bins='log', vmin=2, vmax=100)\n     assert h.get_clim() == (2, 100)\n \n+@check_figures_equal(extensions=['png'])\n+def test_hexbin_mincnt_behavior_upon_C_parameter(fig_test, fig_ref):\n+    # see: gh:12926\n+    datapoints = [\n+        # list of (x, y)\n+        (0, 0),\n+        (0, 0),\n+        (6, 0),\n+        (0, 6),\n+    ]\n+    X, Y = zip(*datapoints)\n+    C = [1] * len(X)\n+    extent = [-10., 10, -10., 10]\n+    gridsize = (7, 7)\n+\n+    ax_test = fig_test.subplots()\n+    ax_ref = fig_ref.subplots()\n+\n+    # without C parameter\n+    ax_ref.hexbin(\n+        X, Y,\n+        extent=extent,\n+        gridsize=gridsize,\n+        mincnt=1,\n+    )\n+    ax_ref.set_facecolor(\"green\")  # for contrast of background\n+\n+    # with C parameter\n+    ax_test.hexbin(\n+        X, Y,\n+        C=[1] * len(X),\n+        reduce_C_function=np.sum,\n+        mincnt=1,\n+        extent=extent,\n+        gridsize=gridsize,\n+    )\n+    ax_test.set_facecolor(\"green\")\n \n+\n+@check_figures_equal(extensions=['png'])\n+def test_hexbin_mincnt_zero_with_C_parameter(fig_test, fig_ref):\n+    # Tests behavior when mincnt=0 with C parameter\n+    datapoints = [(0, 0), (2, 2)]\n+    X, Y = zip(*datapoints)\n+    C = [1] * len(X)\n+    extent = [-3, 3, -3, 3]\n+    gridsize = (7, 7)\n+\n+    ax_test = fig_test.subplots()\n+    ax_ref = fig_ref.subplots()\n+\n+    # without C parameter\n+    ax_ref.hexbin(\n+        X, Y,\n+        extent=extent,\n+        gridsize=gridsize,\n+        mincnt=0,\n+    )\n+    ax_ref.set_facecolor(\"green\")\n+\n+    # with C parameter\n+    ax_test.hexbin(\n+        X, Y,\n+        C=[1] * len(X),\n+        reduce_C_function=np.sum,\n+        mincnt=0,\n+        extent=extent,\n+        gridsize=gridsize,\n+    )\n+    ax_test.set_facecolor(f\"green\")\n+    \n def test_inverted_limits():\n     # Test gh:1553\n     # Calling invert_xaxis prior to plotting should not disable autoscaling\n",
  "matplotlib__matplotlib-26291": "",
  "matplotlib__matplotlib-26342": "diff --git a/lib/matplotlib/tests/test_contour.py b/lib/matplotlib/tests/test_contour.py\nindex 700190c..5a40553 100644\n--- a/lib/matplotlib/tests/test_contour.py\n+++ b/lib/matplotlib/tests/test_contour.py\n@@ -89,6 +89,38 @@ def test_contour_no_valid_levels():\n     ax.contour(np.ones((9, 9)))\n \n \n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.path import Path\n+from matplotlib.testing.decorators import check_figures_equal, image_comparison\n+\n+\n+@check_figures_equal(extensions=['png'])\n+def test_contour_set_paths(fig_test, fig_ref):\n+    ax_test = fig_test.subplots()\n+    ax_ref = fig_ref.subplots()\n+\n+    Z = np.array([[0, 1], [1, 2]])\n+    # Create a contour set in the test plot.\n+    cs_test = ax_test.contour(Z)\n+    # Create a contour set from a different plot to use its transformed paths.\n+    cs_ref = ax_ref.contour(np.rot90(Z))\n+\n+    # Setting paths from reference contour to test contour\n+    cs_test.set_paths(cs_ref.get_paths())\n+    \n+    # Both figures should be identical as the paths are the same now.\n+    \n+    # Validate that the paths have been successfully set.\n+    assert len(cs_test.collections) == len(cs_ref.collections)\n+    for col_test, col_ref in zip(cs_test.collections, cs_ref.collections):\n+        test_paths = col_test.get_paths()\n+        ref_paths = col_ref.get_paths()\n+        assert len(test_paths) == len(ref_paths)\n+        for p_test, p_ref in zip(test_paths, ref_paths):\n+            assert np.array_equal(p_test.vertices, p_ref.vertices)\n+            assert np.array_equal(p_test.codes, p_ref.codes)\n+\n def test_contour_Nlevels():\n     # A scalar levels arg or kwarg should trigger auto level generation.\n     # https://github.com/matplotlib/matplotlib/issues/11913\n",
  "mwaskom__seaborn-3069": "",
  "pallets__flask-5014": "diff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\nindex 94a27b3..c4bc5e6 100644\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -244,7 +244,17 @@ def test_default_static_max_age(app):\n         app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n \n \n-def test_templates_list(test_apps):\n+def test_empty_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"\", __name__)\n+\n+def test_none_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(None, __name__)\n+\n+def test_whitespace_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"   \", __name__)\n     from blueprintapp import app\n \n     templates = sorted(app.jinja_env.list_templates())\n",
  "psf__requests-1142": "",
  "psf__requests-1724": "",
  "psf__requests-1766": "",
  "psf__requests-1921": "",
  "psf__requests-2317": "",
  "psf__requests-2931": "",
  "psf__requests-5414": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 7279149..f6baad5 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -81,12 +81,24 @@ class TestRequests:\n             (InvalidSchema, 'localhost.localdomain:3128/'),\n             (InvalidSchema, '10.122.1.1:3128/'),\n             (InvalidURL, 'http://'),\n+            (InvalidURL, 'http://.example.com'),\n         ))\n     def test_invalid_url(self, exception, url):\n         with pytest.raises(exception):\n             requests.get(url)\n \n-    def test_basic_building(self):\n+    @pytest.mark.parametrize(\n+        'exception, url', (\n+            (InvalidURL, 'http://..example.com'),\n+            (InvalidURL, 'http://example..com'),\n+            (InvalidURL, 'http://-example.com'),\n+            (InvalidURL, 'http://example-.com'),\n+            (InvalidURL, 'http://example.*.com'),\n+            (InvalidURL, 'http://.example.com'),\n+        ))\n+    def test_invalid_url_edge_cases(self, exception, url):\n+        with pytest.raises(exception):\n+            requests.get(url)\n         req = requests.Request()\n         req.url = 'http://kennethreitz.org/'\n         req.data = {'life': '42'}\n",
  "pydata__xarray-2905": "diff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex e1452a7..97eb9f2 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2296,6 +2296,21 @@ class TestAsCompatibleData:\n         class CustomArray(NDArrayMixin):\n             def __init__(self, array):\n                 self.array = array\n+        # Ensure that objects with a 'values' property are not coerced\n+\n+        class HasValues:\n+            values = 5\n+\n+        good_indexed = Variable(dims=(\"dim_0\",), data=[None])\n+        bad_indexed = Variable(dims=(\"dim_0\",), data=[None])\n+\n+        # Assign a set, which is expected to be stored correctly\n+        good_indexed[{'dim_0': 0}] = set()\n+        assert np.array_equal(good_indexed._data, np.array([set()], dtype=object))\n+\n+        # Assign an object with 'values' property\n+        bad_indexed[{'dim_0': 0}] = HasValues()\n+        assert isinstance(bad_indexed._data[0], HasValues), \"Object with 'values' property should not be coerced\"\n \n         class CustomIndexable(CustomArray, indexing.ExplicitlyIndexed):\n             pass\n",
  "pydata__xarray-3095": "diff --git a/xarray/tests/test_dataarray.py b/xarray/tests/test_dataarray.py\nindex 274cb25..12198a1 100644\n--- a/xarray/tests/test_dataarray.py\n+++ b/xarray/tests/test_dataarray.py\n@@ -3480,7 +3480,16 @@ class TestDataArray:\n \n         assert_identical(da['a'], expected_orig)\n \n-    def test_real_and_imag(self):\n+    @pytest.mark.parametrize('deep', [True, False])\n+    def test_copy_unicode_indexvariable(self, deep):\n+        # Create a DataArray with unicode dtype\n+        arr = xr.DataArray(np.array(['foo', 'bar', 'baz'], dtype='<U3'), dims='x')\n+        \n+        # Perform copy\n+        arr_copy = arr.copy(deep=deep)\n+        \n+        # Check dtype of the coordinates\n+        assert arr_copy.coords['x'].dtype == '<U3', \"The dtype of coordinate should remain unicode\"\n         array = DataArray(1 + 2j)\n         assert_identical(array.real, DataArray(1))\n         assert_identical(array.imag, DataArray(2))\n",
  "pydata__xarray-3151": "diff --git a/xarray/tests/test_combine.py b/xarray/tests/test_combine.py\nindex 026dec9..2a5f239 100644\n--- a/xarray/tests/test_combine.py\n+++ b/xarray/tests/test_combine.py\n@@ -600,6 +600,27 @@ class TestCombineAuto:\n         with pytest.raises(ValueError):\n             combine_by_coords(datasets, 'y')\n \n+    def test_non_monotonic_identical_coords(self):\n+        # Test that non-monotonic identical coordinates no longer raise ValueError\n+        ycoord = ['a', 'c', 'b']\n+\n+        data1 = np.random.rand(3, 3)\n+        data2 = np.random.rand(4, 3)\n+        \n+        ds1 = Dataset(data_vars=dict(data=(['x', 'y'], data1)),\n+                      coords=dict(x=[1, 2, 3], y=ycoord))\n+\n+        ds2 = Dataset(data_vars=dict(data=(['x', 'y'], data2)),\n+                      coords=dict(x=[4, 5, 6, 7], y=ycoord))\n+\n+        combined = combine_by_coords((ds1, ds2))\n+\n+        expected_data = np.concatenate([data1, data2], axis=0)\n+        expected = Dataset(data_vars=dict(data=(['x', 'y'], expected_data)),\n+                           coords=dict(x=[1, 2, 3, 4, 5, 6, 7], y=ycoord))\n+\n+        assert_identical(expected, combined)\n+\n     def test_combine_by_coords_no_concat(self):\n         objs = [Dataset({'x': 0}), Dataset({'y': 1})]\n         actual = combine_by_coords(objs)\n",
  "pydata__xarray-3305": "diff --git a/xarray/tests/test_dataarray.py b/xarray/tests/test_dataarray.py\nindex b0e2440..80fa2b0 100644\n--- a/xarray/tests/test_dataarray.py\n+++ b/xarray/tests/test_dataarray.py\n@@ -2310,6 +2310,29 @@ class TestDataArray:\n                 )\n                 np.testing.assert_allclose(actual.values, expected)\n \n+    def test_quantile_keep_attrs(self):\n+        import xarray as xr\n+        import numpy as np\n+        from collections import OrderedDict\n+\n+        da = xr.DataArray([0, 0], dims=\"x\", attrs={'units': 'K'})\n+        out = da.quantile(0.9, dim='x', keep_attrs=True)\n+        assert out.attrs == {'units': 'K'}\n+\n+        da_no_attrs = xr.DataArray([0, 0], dims=\"x\")\n+        out_no_attrs = da_no_attrs.quantile(0.9, dim='x', keep_attrs=True)\n+        assert out_no_attrs.attrs == {}\n+\n+        out_keep_attrs_false = da.quantile(0.9, dim='x', keep_attrs=False)\n+        assert out_keep_attrs_false.attrs == {}\n+\n+        da_multi_quantile = xr.DataArray([0, 1, 2, 3], dims=\"x\", attrs={'description': 'simple array'})\n+        out_multi = da_multi_quantile.quantile([0.1, 0.9], dim='x', keep_attrs=True)\n+        assert out_multi.attrs == {'description': 'simple array'}\n+\n+        # Ensure that original attributes remain unchanged\n+        assert da_multi_quantile.attrs == {'description': 'simple array'}\n+\n     def test_reduce_keep_attrs(self):\n         # Test dropped attrs\n         vm = self.va.mean()\n",
  "pydata__xarray-3677": "diff --git a/xarray/tests/test_merge.py b/xarray/tests/test_merge.py\nindex cd14bf3..2882c1b 100644\n--- a/xarray/tests/test_merge.py\n+++ b/xarray/tests/test_merge.py\n@@ -1,3 +1,4 @@\n+\n import numpy as np\n import pytest\n \n@@ -5,7 +6,7 @@ import xarray as xr\n from xarray.core import dtypes, merge\n \n from . import raises_regex\n-from .test_dataset import create_test_data\n+from xarray.testing import assert_identical\n \n \n class TestMergeInternals:\n@@ -177,7 +178,27 @@ class TestMergeMethod:\n         actual = ds1.merge(ds2)\n         assert ds2.identical(actual)\n \n-    def test_merge_compat(self):\n+    def test_merge_dataarray(self):\n+        ds = xr.Dataset({\"a\": 0})\n+        da = xr.DataArray(data=1, name=\"b\")\n+\n+        # Test merging DataArray into Dataset\n+        expected = xr.merge([ds, da])\n+        actual = ds.merge(da)\n+        assert_identical(actual, expected)\n+\n+        # Test an empty DataArray (should not add any new data)\n+        da_empty = xr.DataArray(name='c')\n+        expected = xr.merge([ds, da, da_empty])\n+        actual = ds.merge(da_empty)\n+        assert_identical(actual, expected)\n+\n+        # Test merging with dimensions\n+        ds_with_dim = xr.Dataset({\"a\": (\"x\", [0, 1])})\n+        da_with_dim = xr.DataArray(data=[1, 2], dims=\"x\", name='b')\n+        expected = xr.merge([ds_with_dim, da_with_dim])\n+        actual = ds_with_dim.merge(da_with_dim)\n+        assert_identical(actual, expected)\n         ds1 = xr.Dataset({\"x\": 0})\n         ds2 = xr.Dataset({\"x\": 1})\n         for compat in [\"broadcast_equals\", \"equals\", \"identical\", \"no_conflicts\"]:\n",
  "pydata__xarray-4075": "",
  "pydata__xarray-4356": "diff --git a/xarray/tests/test_duck_array_ops.py b/xarray/tests/test_duck_array_ops.py\nindex 0c63f0f..10fe8f5 100644\n--- a/xarray/tests/test_duck_array_ops.py\n+++ b/xarray/tests/test_duck_array_ops.py\n@@ -607,7 +607,26 @@ def test_min_count_dataset(func):\n @pytest.mark.parametrize(\"dtype\", [float, int, np.float32, np.bool_])\n @pytest.mark.parametrize(\"dask\", [False, True])\n @pytest.mark.parametrize(\"func\", [\"sum\", \"prod\"])\n-def test_multiple_dims(dtype, dask, func):\n+@pytest.mark.parametrize(\"skipna\", [False, True])\n+def test_min_count_multiple_dims(dtype, dask, func, skipna):\n+    if dask and not has_dask:\n+        pytest.skip(\"requires dask\")\n+\n+    dim_num = 3\n+    min_count = 4\n+    da = construct_dataarray(dim_num, dtype, contains_nan=True, dask=dask)\n+    \n+    # Test reduction over all dimensions\n+    actual = getattr(da, func)(dim=[\"x\", \"y\", \"z\"], skipna=skipna, min_count=min_count)\n+    expected = getattr(da, func)(dim=..., skipna=skipna, min_count=min_count)\n+    assert_allclose(actual, expected)\n+    assert_dask_array(actual, dask)\n+\n+    # Test reduction over two dimensions out of three\n+    initial_actual = getattr(da, func)(dim=\"x\", skipna=skipna, min_count=min_count)\n+    actual_two_dims = getattr(initial_actual, func)(dim=\"y\", skipna=skipna, min_count=min_count)\n+    expected_two_dims = getattr(da, func)(dim=[\"x\", \"y\"], skipna=skipna, min_count=min_count)\n+    assert_allclose(actual_two_dims, expected_two_dims)\n     if dask and not has_dask:\n         pytest.skip(\"requires dask\")\n     da = construct_dataarray(3, dtype, contains_nan=True, dask=dask)\n",
  "pydata__xarray-4629": "diff --git a/xarray/tests/test_merge.py b/xarray/tests/test_merge.py\nindex ef48e47..9ac9ea8 100644\n--- a/xarray/tests/test_merge.py\n+++ b/xarray/tests/test_merge.py\n@@ -109,6 +109,14 @@ class TestMergeFunction:\n             expected.attrs = expected_attrs\n             assert actual.identical(expected)\n \n+    def test_merge_attrs_override_copy(self):\n+        ds1 = xr.Dataset(attrs={\"x\": 0})\n+        ds2 = xr.Dataset(attrs={\"x\": 1})\n+        ds3 = xr.merge([ds1, ds2], combine_attrs=\"override\")\n+        ds3.attrs[\"x\"] = 2\n+        assert ds1.attrs[\"x\"] == 0  # check if ds1's attr is not modified\n+        assert ds3.attrs[\"x\"] == 2  # check if ds3's attr is updated\n+\n     def test_merge_dicts_simple(self):\n         actual = xr.merge([{\"foo\": 0}, {\"bar\": \"one\"}, {\"baz\": 3.5}])\n         expected = xr.Dataset({\"foo\": 0, \"bar\": \"one\", \"baz\": 3.5})\n",
  "pydata__xarray-4687": "diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex 636c1f4..4e76407 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -1921,8 +1921,21 @@ def test_where() -> None:\n     expected = xr.DataArray([1, 0], dims=\"x\")\n     assert_identical(expected, actual)\n \n-\n-@pytest.mark.parametrize(\"use_dask\", [True, False])\n+def test_where_attrs_preserved() -> None:\n+    data = xr.DataArray(np.ones([10, 10], dtype=np.int8))\n+    data.attrs[\"attr_1\"] = \"test1\"\n+    data.attrs[\"attr_2\"] = \"test2\"\n+    \n+    result = xr.where(data == 1, 5, 0, keep_attrs=True)\n+    \n+    assert data.attrs == result.attrs\n+\n+def test_where_dtype_preserved() -> None:\n+    data = xr.DataArray(np.ones([10, 10], dtype=np.int8))\n+    \n+    result = xr.where(data == 1, 5, 0)\n+    \n+    assert result.dtype == data.dtype\n @pytest.mark.parametrize(\"use_datetime\", [True, False])\n def test_polyval(use_dask, use_datetime) -> None:\n     if use_dask and not has_dask:\n",
  "pydata__xarray-4695": "diff --git a/xarray/tests/test_dataarray.py b/xarray/tests/test_dataarray.py\nindex 3a4b8ad..0c01793 100644\n--- a/xarray/tests/test_dataarray.py\n+++ b/xarray/tests/test_dataarray.py\n@@ -221,6 +221,15 @@ class TestDataArray:\n         )\n \n         assert_identical(actual, expected)\n+    def test_loc_dim_name_collision_with_sel_params(self):\n+        da = xr.DataArray(\n+            [[0, 0], [1, 1]],\n+            dims=[\"dim1\", \"method\"],\n+            coords={\"dim1\": [\"x\", \"y\"], \"method\": [\"a\", \"b\"]},\n+        )\n+        np.testing.assert_array_equal(\n+            da.loc[dict(dim1=[\"x\", \"y\"], method=[\"a\"])], [[0], [1]]\n+        )\n \n     def test_name(self):\n         arr = self.dv\n",
  "pydata__xarray-4966": "",
  "pydata__xarray-6461": "diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex f0b426a..e097293 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -1919,6 +1919,28 @@ def test_where() -> None:\n     expected = xr.DataArray([1, 0], dims=\"x\")\n     assert_identical(expected, actual)\n \n+    # Test with scalar values for x or y and keep_attrs=True\n+    cond = xr.DataArray([True, False, True], dims=\"x\", attrs={\"attr\": \"cond\"})\n+    actual = xr.where(cond, 1, 0, keep_attrs=True)\n+    expected = xr.DataArray([1, 0, 1], dims=\"x\", attrs={})\n+    assert_identical(expected, actual)\n+\n+    actual = xr.where(cond, 0, 1, keep_attrs=True)\n+    expected = xr.DataArray([0, 1, 0], dims=\"x\", attrs={})\n+    assert_identical(expected, actual)\n+\n+    # Test with scalar value as x and DataArray as y\n+    y = xr.DataArray([0, 0, 0], dims=\"x\", attrs={\"attr\": \"y\"})\n+    actual = xr.where(cond, 1, y, keep_attrs=True)\n+    expected = xr.DataArray([1, 0, 1], dims=\"x\", attrs={\"attr\": \"y\"})\n+    assert_identical(expected, actual)\n+\n+    # Test with DataArray as x and scalar value as y\n+    x = xr.DataArray([1, 1, 1], dims=\"x\", attrs={\"attr\": \"x\"})\n+    actual = xr.where(cond, x, 0, keep_attrs=True)\n+    expected = xr.DataArray([1, 0, 1], dims=\"x\", attrs={\"attr\": \"x\"})\n+    assert_identical(expected, actual)\n+\n \n def test_where_attrs() -> None:\n     cond = xr.DataArray([True, False], dims=\"x\", attrs={\"attr\": \"cond\"})\n@@ -1928,6 +1950,28 @@ def test_where_attrs() -> None:\n     expected = xr.DataArray([1, 0], dims=\"x\", attrs={\"attr\": \"x\"})\n     assert_identical(expected, actual)\n \n+    # Test with scalar values for x or y and keep_attrs=True\n+    cond = xr.DataArray([True, False, True], dims=\"x\", attrs={\"attr\": \"cond\"})\n+    actual = xr.where(cond, 1, 0, keep_attrs=True)\n+    expected = xr.DataArray([1, 0, 1], dims=\"x\", attrs={})\n+    assert_identical(expected, actual)\n+\n+    actual = xr.where(cond, 0, 1, keep_attrs=True)\n+    expected = xr.DataArray([0, 1, 0], dims=\"x\", attrs={})\n+    assert_identical(expected, actual)\n+\n+    # Test with scalar value as x and DataArray as y\n+    y = xr.DataArray([0, 0, 0], dims=\"x\", attrs={\"attr\": \"y\"})\n+    actual = xr.where(cond, 1, y, keep_attrs=True)\n+    expected = xr.DataArray([1, 0, 1], dims=\"x\", attrs={\"attr\": \"y\"})\n+    assert_identical(expected, actual)\n+\n+    # Test with DataArray as x and scalar value as y\n+    x = xr.DataArray([1, 1, 1], dims=\"x\", attrs={\"attr\": \"x\"})\n+    actual = xr.where(cond, x, 0, keep_attrs=True)\n+    expected = xr.DataArray([1, 0, 1], dims=\"x\", attrs={\"attr\": \"x\"})\n+    assert_identical(expected, actual)\n+\n \n @pytest.mark.parametrize(\"use_dask\", [True, False])\n @pytest.mark.parametrize(\"use_datetime\", [True, False])\n",
  "pydata__xarray-6599": "",
  "pydata__xarray-6721": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex cab9007..350eb1b 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -221,6 +221,21 @@ class InaccessibleVariableDataStore(backends.InMemoryDataStore):\n \n \n class TestDataset:\n+    \n+    def test_chunks_does_not_load_data(self) -> None:\n+        store = InaccessibleVariableDataStore()\n+        create_test_data().dump_to_store(store)\n+        ds = open_dataset(store)\n+        assert ds.chunks == {}\n+        \n+    def test_zarr_chunks_no_load(self) -> None:\n+        url = \"https://ncsa.osn.xsede.org/Pangeo/pangeo-forge/swot_adac/FESOM/surf/fma.zarr\"\n+        ds = xr.open_dataset(url, engine='zarr')\n+        assert ds.chunks is not None\n+        # Ensure accessing chunks does not inadvertently load data\n+        assert not ds[\"var1\"].data.cached\n+        # Basic check for dask presence without loading data\n+        assert isinstance(ds[\"var1\"].data, da.Array)\n     def test_repr(self) -> None:\n         data = create_test_data(seed=123)\n         data.attrs[\"foo\"] = \"bar\"\n",
  "pydata__xarray-6744": "diff --git a/xarray/tests/test_rolling.py b/xarray/tests/test_rolling.py\nindex 0a9ef75..bbaaac5 100644\n--- a/xarray/tests/test_rolling.py\n+++ b/xarray/tests/test_rolling.py\n@@ -27,6 +27,21 @@ pytestmark = [\n \n class TestDataArrayRolling:\n     @pytest.mark.parametrize(\"da\", (1, 2), indirect=True)\n+    @pytest.mark.parametrize(\"center\", [True, False])\n+    @pytest.mark.parametrize(\"size\", [1, 2, 3, 7])\n+    def test_rolling_iter_center(self, da, center, size) -> None:\n+        rolling_obj = da.rolling(time=size, center=center)\n+        rolling_obj_mean = rolling_obj.mean()\n+\n+        for i, (label, window_da) in enumerate(rolling_obj):\n+            actual = rolling_obj_mean.isel(time=i)\n+            expected_position = i if not center else i - size // 2\n+            expected_position = max(0, min(expected_position, len(da[\"time\"])-1))\n+            expected_label = da[\"time\"].isel(time=expected_position)\n+            assert label == expected_label\n+\n+            expected = window_da.mean(\"time\")\n+            np.testing.assert_allclose(actual.values, expected.values, equal_nan=True)\n     def test_rolling_iter(self, da) -> None:\n         rolling_obj = da.rolling(time=7)\n         rolling_obj_mean = rolling_obj.mean()\n",
  "pydata__xarray-7233": "",
  "pydata__xarray-7393": "diff --git a/xarray/tests/test_indexes.py b/xarray/tests/test_indexes.py\nindex fa8bd84..ddf7ca1 100644\n--- a/xarray/tests/test_indexes.py\n+++ b/xarray/tests/test_indexes.py\n@@ -692,8 +692,29 @@ def test_safe_cast_to_index_cftimeindex():\n @requires_cftime\n def test_safe_cast_to_index_datetime_datetime():\n     dates = [datetime(1, 1, day) for day in range(1, 20)]\n+import pytest\n+import numpy as np\n+import xarray as xr\n \n+@pytest.mark.parametrize(\"dtype\", [\"int32\", \"float32\", \"int64\", \"float64\"])\n+def test_restore_dtype_on_multiindexes(dtype: str) -> None:\n+    foo = xr.Dataset(coords={\"bar\": (\"bar\", np.array([0, 1], dtype=dtype))})\n+    foo = foo.stack(baz=(\"bar\",))\n+    assert str(foo[\"bar\"].values.dtype) == dtype\n+\n+def test_unaffected_behavior_with_int64_dtype():\n+    # Test a Dataset that already has int64 to ensure it remains unchanged.\n+    dataset = xr.Dataset(coords={\"coord\": np.array([0, 1, 2], dtype='int64')})\n+    stacked = dataset.stack(stacked_coord=(\"coord\",))\n+    assert stacked['coord'].dtype == 'int64'\n+\n+def test_stack_preserves_all_dtypes():\n+    # Test various data types to ensure stack operation doesn't alter them.\n+    for dtype in [np.int32, np.int64, np.float32, np.float64, np.bool_]:\n+        dataset = xr.Dataset(coords={\"coord\": np.array([0, 1], dtype=dtype)})\n+        stacked = dataset.stack(stacked_coord=(\"coord\",))\n+        assert str(stacked['coord'].dtype) == dtype\n     expected = pd.Index(dates)\n     actual = safe_cast_to_index(np.array(dates))\n     assert_array_equal(expected, actual)\n-    assert isinstance(actual, pd.Index)\n+    assert isinstance(actual, pd.Index)\n",
  "pylint-dev__pylint-4970": "",
  "pylint-dev__pylint-6386": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex a0b1b64..e38d54c 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -94,9 +94,13 @@ def test_unknown_yes_no(capsys: CaptureFixture) -> None:\n     assert \"Invalid yn value 'maybe', should be in \" in output.err\n \n \n-def test_unknown_py_version(capsys: CaptureFixture) -> None:\n+def test_short_verbose_no_argument(capsys: CaptureFixture) -> None:\n+    \"\"\"Check that the short -v flag does not expect an argument.\"\"\"\n+    Run([str(EMPTY_MODULE), \"-v\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"argument --verbose/-v: expected one argument\" not in output.err\n     \"\"\"Check that we correctly error on an unknown python-version.\"\"\"\n     with pytest.raises(SystemExit):\n         Run([str(EMPTY_MODULE), \"--py-version=the-newest\"], exit=False)\n     output = capsys.readouterr()\n-    assert \"the-newest has an invalid format, should be a version string.\" in output.err\n+    assert \"the-newest has an invalid format, should be a version string.\" in output.err\n",
  "pylint-dev__pylint-6528": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex 9123ae4..ba523ad 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1233,6 +1233,28 @@ class TestRunTC:\n             expected_output=\"No such file or directory\",\n         )\n \n+    def test_recursive_with_ignores(self):\n+        test_cases = [\n+            (\"--ignore\", \"ignored_subdirectory\"),\n+            (\"--ignore\", \"another_ignored_subdirectory\"),\n+            (\"--ignore-patterns\", \"ignored_.*\"),\n+            (\"--ignore-patterns\", \"^ignored_subdirectory\"),\n+            (\"--ignore-paths\", \".*ignored_subdirectory.*\"),\n+            (\"--ignore-paths\", \".*another_ignored_subdirectory.*\"),\n+        ]\n+\n+        directory = join(HERE, \"regrtest_data\", \"directory\")\n+        for ignore_flag, ignore_value in test_cases:\n+            self._runtest(\n+                [\n+                    directory,\n+                    \"--recursive=y\",\n+                    ignore_flag,\n+                    ignore_value,\n+                ],\n+                code=0,\n+            )\n+\n     def test_recursive(self):\n         self._runtest(\n             [join(HERE, \"regrtest_data\", \"directory\", \"subdirectory\"), \"--recursive=y\"],\n",
  "pylint-dev__pylint-6903": "diff --git a/tests/test_pylint_runners.py b/tests/test_pylint_runners.py\nindex 580708d..01ebc30 100644\n--- a/tests/test_pylint_runners.py\n+++ b/tests/test_pylint_runners.py\n@@ -32,6 +32,27 @@ def test_runner(runner: Callable, tmpdir: LocalPath) -> None:\n @pytest.mark.parametrize(\n     \"runner\", [run_epylint, run_pylint, run_pyreverse, run_symilar]\n )\n+def test_pylint_run_jobs_handling_cpu_fraction(tmpdir) -> None:\n+    \"\"\"Check that pylint run does not crash with a fractional CPU value.\"\"\"\n+    from unittest.mock import patch\n+    from pylint.lint import Run\n+    from pylint.testutils import GenericTestReporter as Reporter\n+    import os\n+\n+    def mock_open(file, *args, **kwargs):\n+        if file == \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\":\n+            return mock_open(read_data=\"-1\")(*args, **kwargs)\n+        if file == \"/sys/fs/cgroup/cpu/cpu.cfs_shares\":\n+            return mock_open(read_data=\"2\")(*args, **kwargs)\n+        return open(file, *args, **kwargs)\n+\n+    testargs = ['my_package', '--jobs=0']\n+    with tmpdir.as_cwd():\n+        with patch('builtins.open', mock_open):\n+            with patch('pylint.lint.run.Path.is_file', return_value=True):\n+                with pytest.raises(SystemExit) as err:\n+                    Run(testargs, reporter=Reporter())\n+                assert err.value.code == 0\n def test_runner_with_arguments(runner: Callable, tmpdir: LocalPath) -> None:\n     \"\"\"Check the runners with arguments as parameter instead of sys.argv.\"\"\"\n     filepath = os.path.abspath(__file__)\n@@ -39,4 +60,4 @@ def test_runner_with_arguments(runner: Callable, tmpdir: LocalPath) -> None:\n     with tmpdir.as_cwd():\n         with pytest.raises(SystemExit) as err:\n             runner(testargs)\n-        assert err.value.code == 0\n+        assert err.value.code == 0\n",
  "pylint-dev__pylint-7080": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex fa7078d..d733bc0 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1329,6 +1329,25 @@ class TestRunTC:\n                     [\".\", \"--recursive=y\"],\n                     code=0,\n                 )\n+    def test_ignore_paths_with_recursive(self):\n+        \"\"\"Test that when running recursively, paths matching the ignore-paths regex are ignored.\"\"\"\n+        with _test_sys_path():\n+            sys.path = [\n+                path\n+                for path in sys.path\n+                if not os.path.basename(path) == \"regrtest_data\"\n+            ]\n+            with _test_cwd():\n+                # Move to a test directory simulating the project structure\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n+                self._runtest(\n+                    [\n+                        \".\", \n+                        \"--recursive=y\", \n+                        \"--ignore-paths\", \"^ignored_subdirectory/.*\" # Adjust regex to match structure\n+                    ],\n+                    code=0,\n+                )\n \n     def test_regression_recursive_current_dir(self):\n         with _test_sys_path():\n",
  "pylint-dev__pylint-7277": "",
  "pytest-dev__pytest-10051": "diff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex 26c4c15..f432629 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -160,6 +160,9 @@ def logging_during_setup_and_teardown(caplog):\n     assert [x.message for x in caplog.get_records(\"teardown\")] == [\"a_teardown_log\"]\n \n \n+import logging\n+from _pytest.pytester import Pytester\n+\n def test_caplog_captures_for_all_stages(caplog, logging_during_setup_and_teardown):\n     assert not caplog.records\n     assert not caplog.get_records(\"call\")\n@@ -172,6 +175,23 @@ def test_caplog_captures_for_all_stages(caplog, logging_during_setup_and_teardow\n     assert set(caplog._item.stash[caplog_records_key]) == {\"setup\", \"call\"}\n \n \n+def test_caplog_get_records_and_clear_interaction(caplog) -> None:\n+    def verify_consistency() -> None:\n+        assert caplog.get_records(\"call\") == caplog.records\n+\n+    # Initial consistency check\n+    verify_consistency()\n+\n+    # Log a message and check consistency\n+    logging.warning(\"test\")\n+    verify_consistency()\n+\n+    # Clear logs and check if consistency holds\n+    caplog.clear()\n+\n+    # The test case will fail here if the issue isn't fixed\n+    verify_consistency()\n+\n def test_ini_controls_global_log_level(pytester: Pytester) -> None:\n     pytester.makepyfile(\n         \"\"\"\n",
  "pytest-dev__pytest-10081": "diff --git a/testing/test_unittest.py b/testing/test_unittest.py\nindex 561df7f..fb25a3a 100644\n--- a/testing/test_unittest.py\n+++ b/testing/test_unittest.py\n@@ -1273,8 +1273,37 @@ def test_pdb_teardown_skipped(\n     result.stdout.fnmatch_lines(\"* 1 skipped in *\")\n     assert tracked == []\n \n+def test_pdb_teardown_skipped_for_classes_with_unittest_skip(\n+    pytester: Pytester, monkeypatch: MonkeyPatch\n+) -> None:\n+    \"\"\"\n+    With --pdb, setUp and tearDown should not be called for tests skipped\n+    via unittest.skip decorator on the class.\n+    \"\"\"\n+    tracked: List[str] = []\n+    monkeypatch.setattr(pytest, \"track_pdb_teardown_skipped\", tracked, raising=False)\n+\n+    pytester.makepyfile(\n+        \"\"\"\n+        import unittest\n+        import pytest\n+\n+        @unittest.skip(\"skipped for reasons\")\n+        class MyTestCase(unittest.TestCase):\n \n-def test_async_support(pytester: Pytester) -> None:\n+            def setUp(self):\n+                pytest.track_pdb_teardown_skipped.append(\"setUp:\" + self.id())\n+\n+            def tearDown(self):\n+                pytest.track_pdb_teardown_skipped.append(\"tearDown:\" + self.id())\n+\n+            def test_1(self):\n+                pass\n+        \"\"\"\n+    )\n+    result = pytester.runpytest_inprocess(\"--pdb\")\n+    result.stdout.fnmatch_lines(\"* 1 skipped in *\")\n+    assert tracked == []\n     pytest.importorskip(\"unittest.async_case\")\n \n     pytester.copy_example(\"unittest/test_unittest_asyncio.py\")\n",
  "pytest-dev__pytest-5262": "diff --git a/testing/test_capture.py b/testing/test_capture.py\nindex 1f092b0..b33fa09 100644\n--- a/testing/test_capture.py\n+++ b/testing/test_capture.py\n@@ -1051,9 +1051,23 @@ class TestFDCapture(object):\n             cap.done()\n             pytest.raises(AttributeError, cap.suspend)\n \n-\n-@contextlib.contextmanager\n-def saved_fd(fd):\n+def test_capfd_stdout_binary_mode(capfd):\n+    out, err = capfd.readouterr()\n+    assert \"b\" not in out\n+\n+def test_capfd_write_bytes(capfd):\n+    with pytest.raises(TypeError, match=\"write\\(\\) argument must be str, not bytes\"):\n+        sys.stdout.write(b\"binary data\")  # This should raise a TypeError\n+\n+@pytest.mark.parametrize(\"input_data, expected_output\", [\n+    (\"text data\", \"text data\"),\n+    (\"123456\", \"123456\"),\n+    (\"\u20ac\u00e6\u00f8\u00e5\", \"\u20ac\u00e6\u00f8\u00e5\"),\n+])\n+def test_capfd_write_str(capfd, input_data, expected_output):\n+    sys.stdout.write(input_data)\n+    out, err = capfd.readouterr()\n+    assert out == expected_output\n     new_fd = os.dup(fd)\n     try:\n         yield\n",
  "pytest-dev__pytest-5631": "diff --git a/testing/test_unittest.py b/testing/test_unittest.py\nindex 8c1c2d7..bcda736 100644\n--- a/testing/test_unittest.py\n+++ b/testing/test_unittest.py\n@@ -1,3 +1,4 @@\n+\n import gc\n \n import pytest\n@@ -20,7 +21,31 @@ def test_simple_unittest(testdir):\n     assert reprec.matchreport(\"test_failing\").failed\n \n \n-def test_runTest_method(testdir):\n+def test_numpy_like_patch(testdir):\n+    \"\"\"\n+    Test patching with a numpy array to ensure no ValueError is raised.\n+    \"\"\"\n+    pytest.importorskip(\"numpy\")\n+    testdir.makepyfile(\n+        \"\"\"\n+        import numpy as np\n+        from unittest.mock import patch\n+\n+        class TestNumpyPatch:\n+            @patch('dummy_module.DUMMY_ARRAY', new=np.array([-5.5, 3.0]))\n+            def test_array_patch(self):\n+                import dummy_module\n+                assert (dummy_module.DUMMY_ARRAY == np.array([-5.5, 3.0])).all()\n+        \"\"\"\n+    )\n+    testdir.makepyfile(\n+        dummy_module=\"\"\"\n+        import numpy as np\n+        DUMMY_ARRAY = np.array([0, 0])\n+        \"\"\"\n+    )\n+    reprec = testdir.inline_run()\n+    reprec.assertoutcome(passed=1)\n     testdir.makepyfile(\n         \"\"\"\n         import unittest\n",
  "pytest-dev__pytest-5809": "diff --git a/testing/test_pastebin.py b/testing/test_pastebin.py\nindex c6a6cae..aac0b65 100644\n--- a/testing/test_pastebin.py\n+++ b/testing/test_pastebin.py\n@@ -126,8 +126,7 @@ class TestPaste(object):\n         assert len(mocked_urlopen) == 1\n         url, data = mocked_urlopen[0]\n         assert type(data) is bytes\n-        lexer = \"python3\" if sys.version_info[0] >= 3 else \"python\"\n         assert url == \"https://bpaste.net\"\n-        assert \"lexer=%s\" % lexer in data.decode()\n+        assert \"lexer=text\" in data.decode()\n         assert \"code=full-paste-contents\" in data.decode()\n-        assert \"expiry=1week\" in data.decode()\n+        assert \"expiry=1week\" in data.decode()\n",
  "pytest-dev__pytest-6202": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex fb6b260..48ac0a6 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -698,6 +698,9 @@ class Test_genitems:\n         )\n         items, reprec = testdir.inline_genitems(p)\n         assert len(items) == 3\n+        assert items[0].getmodpath() == \"testone\"\n+        assert items[1].getmodpath() == \"TestX.testmethod_one\"\n+        assert items[2].getmodpath() == \"TestY.testmethod_one\"\n         assert items[0].name == \"testone\"\n         assert items[1].name == \"testmethod_one\"\n         assert items[2].name == \"testmethod_one\"\n",
  "pytest-dev__pytest-7205": "",
  "pytest-dev__pytest-7236": "",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..0e60d1d 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -595,7 +595,26 @@ class TestSkip:\n         result = testdir.runpytest(\"-rs\")\n         result.stdout.fnmatch_lines([\"*testing stuff*\", \"*1 skipped*\"])\n \n-    def test_skip_no_reason(self, testdir):\n+    @pytest.mark.parametrize(\n+        \"test_input,expected\",\n+        [\n+            ([\"-rs\"], [\"SKIPPED [1] test_sample.py:2: unconditional skip\", \"*1 skipped*\"]),\n+            ([\"-rs\", \"--runxfail\"], [\"SKIPPED [1] test_sample.py:2: unconditional skip\", \"*1 skipped*\"]),\n+        ],\n+    )\n+    def test_xfail_run_with_skip_mark(self, testdir: Pytester, test_input: List[str], expected: List[str]):\n+        testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            @pytest.mark.skip\n+            def test_skip_location() -> None:\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(*test_input)\n+        result.stdout.fnmatch_lines(expected)\n+\n+    def test_skip_no_reason(self, testdir: Pytester):\n         testdir.makepyfile(\n             \"\"\"\n             import pytest\n",
  "pytest-dev__pytest-7490": "",
  "pytest-dev__pytest-7521": "diff --git a/testing/test_capture.py b/testing/test_capture.py\nindex 9d70acf..14e588a 100644\n--- a/testing/test_capture.py\n+++ b/testing/test_capture.py\n@@ -513,8 +513,11 @@ class TestCaptureFixture:\n             \"\"\"\n         )\n         reprec.assertoutcome(passed=1)\n-\n-    def test_capfdbinary(self, testdir):\n+    @pytest.mark.parametrize(\"nl\", (\"\\n\", \"\\r\\n\", \"\\r\"))\n+    def test_cafd_preserves_newlines(self, capfd, nl):\n+        print(\"test\", end=nl)\n+        out, err = capfd.readouterr()\n+        assert out.endswith(nl)\n         reprec = testdir.inline_runsource(\n             \"\"\"\\\n             def test_hello(capfdbinary):\n",
  "pytest-dev__pytest-7571": "diff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex a9649e4..be5324d 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -1,3 +1,4 @@\n+\n import logging\n \n import pytest\n@@ -26,8 +27,32 @@ def test_change_level(caplog):\n     assert \"WARNING\" not in caplog.text\n     assert \"CRITICAL\" in caplog.text\n \n+from _pytest.pytester import Testdir\n+\n+def test_change_level_undo_handler_restore(testdir: Testdir) -> None:\n+    \"\"\"Ensure that 'set_level' restores the handler level after the end of the test.\"\"\"\n+    testdir.makepyfile(\n+        \"\"\"\n+        import logging\n+\n+        def test1(caplog):\n+            assert caplog.handler.level == 0\n+            caplog.set_level(42)\n+            assert caplog.handler.level == 42\n+\n+        def test2(caplog):\n+            assert caplog.handler.level == 0\n+            caplog.set_level(10)\n+            assert caplog.handler.level == 10\n+\n+        def test3(caplog):\n+            assert caplog.handler.level == 0\n+    \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    result.assert_outcomes(passed=3)\n \n-def test_change_level_undo(testdir):\n+def test_change_level_undo(testdir: Testdir) -> None:\n     \"\"\"Ensure that 'set_level' is undone after the end of the test\"\"\"\n     testdir.makepyfile(\n         \"\"\"\n",
  "pytest-dev__pytest-7982": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex b774a67..018b631 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -1,3 +1,4 @@\n+\n import os\n import pprint\n import sys\n@@ -9,7 +10,7 @@ from _pytest.config import ExitCode\n from _pytest.main import _in_venv\n from _pytest.main import Session\n from _pytest.pathlib import symlink_or_skip\n-from _pytest.pytester import Testdir\n+from _pytest.pytester import Testdir, Pytester\n \n \n class TestCollector:\n@@ -1166,6 +1167,48 @@ def test_collect_symlink_out_of_tree(testdir):\n \n     out_of_tree = testdir.tmpdir.join(\"out_of_tree\").ensure(dir=True)\n     symlink_to_sub = out_of_tree.join(\"symlink_to_sub\")\n+\n+def test_collect_symlink_dir_inside(pytester: Pytester) -> None:\n+    \"\"\"A symlinked directory inside the test directory is collected.\"\"\"\n+    # Create a real directory with a test file\n+    dir = pytester.mkdir(\"real_dir\")\n+    dir.joinpath(\"test_real.py\").write_text(\"def test_real(): pass\", \"utf-8\")\n+    \n+    # Create a symlink to the real directory\n+    pytester.path.joinpath(\"symlink_dir\").symlink_to(dir)\n+    \n+    # Run tests and expect two tests: one in real_dir and same via symlink_dir\n+    result = pytester.runpytest()\n+    result.assert_outcomes(passed=2)\n+\n+def test_collect_symlink_dir_outside(pytester: Pytester) -> None:\n+    \"\"\"A symlinked directory outside the initial test directory is collected.\"\"\"\n+    # Create a real directory outside the initial testdir\n+    outside_dir = pytester.path.parent / \"outside_dir\"\n+    outside_dir.mkdir()\n+    outside_dir.joinpath(\"test_outside.py\").write_text(\"def test_outside(): pass\", \"utf-8\")\n+    \n+    # Create a symlink inside the test directory pointing to the outside directory\n+    pytester.path.joinpath(\"symlink_to_outside\").symlink_to(outside_dir, target_is_directory=True)\n+    \n+    # Run tests and expect one test found via the symlinked outside directory\n+    result = pytester.runpytest()\n+    result.assert_outcomes(passed=1)\n+\n+def test_collect_nested_symlink_dir(pytester: Pytester) -> None:\n+    \"\"\"A directory with nested symlinks is all collected.\"\"\"\n+    # Create a nested directory structure\n+    nested_dir = pytester.mkdir(\"nested\")\n+    subdir = nested_dir / \"subdir\"\n+    subdir.mkdir()\n+    subdir.joinpath(\"test_subdir.py\").write_text(\"def test_subdir(): pass\", \"utf-8\")\n+    \n+    # Create a first-level symlink\n+    pytester.path.joinpath(\"symlink_nested\").symlink_to(nested_dir)\n+    \n+    # Run tests and expect the test in subdir to be collected via symlink_nested\n+    result = pytester.runpytest()\n+    result.assert_outcomes(passed=1)\n     symlink_or_skip(sub, symlink_to_sub)\n     sub.chdir()\n     result = testdir.runpytest(\"-vs\", \"--rootdir=%s\" % sub, symlink_to_sub)\n",
  "pytest-dev__pytest-8399": "diff --git a/testing/test_unittest.py b/testing/test_unittest.py\nindex 2c720b0..e4d53f5 100644\n--- a/testing/test_unittest.py\n+++ b/testing/test_unittest.py\n@@ -301,8 +301,30 @@ def test_setup_setUpClass(pytester: Pytester) -> None:\n     reprec = pytester.inline_run(testpath)\n     reprec.assertoutcome(passed=3)\n \n+def test_unittest_setUpClass_fixture_private(pytester: Pytester) -> None:\n+    \"\"\"Tests that unittest setUpClass fixtures are private.\"\"\"\n+    pytester.makepyfile(\n+        \"\"\"\n+        import unittest\n+\n+        class TestClass(unittest.TestCase):\n+            @classmethod\n+            def setUpClass(cls):\n+                pass\n \n-def test_setup_class(pytester: Pytester) -> None:\n+            def test_one(self):\n+                assert True\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"--fixtures\")\n+    assert result.ret == 0\n+    # Ensure the fixture for setUpClass is not shown without -v\n+    result.stdout.no_fnmatch_line(\"unittest_setUpClass_fixture_TestClass*\")\n+\n+    result = pytester.runpytest(\"--fixtures\", \"-v\")\n+    assert result.ret == 0\n+    # Ensure the fixture for setUpClass is shown with -v\n+    result.stdout.fnmatch_lines(\"unittest_setUpClass_fixture_TestClass*\")\n     testpath = pytester.makepyfile(\n         \"\"\"\n         import unittest\n",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..a118396 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -597,6 +597,32 @@ def test_ridgecv_store_cv_values():\n     r.fit(x, y)\n     assert_equal(r.cv_values_.shape, (n_samples, n_responses, n_alphas))\n \n+def test_ridge_classifier_cv_store_cv_values():\n+    # Test RidgeClassifierCV's store_cv_values attribute.\n+\n+    from sklearn.linear_model import RidgeClassifierCV\n+\n+    rng = np.random.RandomState(42)\n+\n+    # Create sample data\n+    n_samples = 8\n+    n_features = 5\n+    x = rng.randn(n_samples, n_features)\n+    alphas = [1e-1, 1e0, 1e1]\n+    n_alphas = len(alphas)\n+\n+    r = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+\n+    # Test with single target\n+    y = rng.randint(0, 2, size=n_samples) * 2 - 1  # binary target\n+    r.fit(x, y)\n+    assert r.cv_values_.shape == (n_samples, n_alphas)\n+\n+    # Test with multi-output as one-vs-all\n+    y_multi = rng.randint(0, 2, size=(n_samples, 3)) * 2 - 1\n+    r.fit(x, y_multi)\n+    assert r.cv_values_.shape == (n_samples, y_multi.shape[1], n_alphas)\n+\n \n def test_ridgecv_sample_weight():\n     rng = np.random.RandomState(0)\n",
  "scikit-learn__scikit-learn-10844": "diff --git a/sklearn/metrics/cluster/tests/test_supervised.py b/sklearn/metrics/cluster/tests/test_supervised.py\nindex f5edf7a..abe9b25 100644\n--- a/sklearn/metrics/cluster/tests/test_supervised.py\n+++ b/sklearn/metrics/cluster/tests/test_supervised.py\n@@ -184,7 +184,13 @@ def test_int_overflow_mutual_info_score():\n     assert_all_finite(mutual_info_score(x.ravel(), y.ravel()))\n \n \n-def test_entropy():\n+def test_fowlkes_mallows_score_overflow():\n+    # Test overflow handling in fowlkes_mallows_score\n+    x = np.repeat(np.arange(1000), 1000)  # Create a large array to simulate overflow\n+    y = np.repeat(np.arange(1000), 1000)\n+    score = fowlkes_mallows_score(x, y)\n+    assert_all_finite(score)\n+    assert 0 <= score <= 1, f\"Score {score} not within expected range.\"\n     ent = entropy([0, 0, 42.])\n     assert_almost_equal(ent, 0.6365141, 5)\n     assert_almost_equal(entropy([]), 1)\n",
  "scikit-learn__scikit-learn-10908": "diff --git a/sklearn/feature_extraction/tests/test_text.py b/sklearn/feature_extraction/tests/test_text.py\nindex 0a2b603..a8e8d2a 100644\n--- a/sklearn/feature_extraction/tests/test_text.py\n+++ b/sklearn/feature_extraction/tests/test_text.py\n@@ -538,6 +538,23 @@ def test_hashing_vectorizer():\n     for i in range(X.shape[0]):\n         assert_almost_equal(np.linalg.norm(X[0].data, 1), 1.0)\n \n+from numpy.testing import assert_raises\n+from sklearn.feature_extraction.text import CountVectorizer\n+\n+\n+def test_countvectorizer_custom_vocabulary_repeated_indices():\n+    # test for custom vocabulary without fitting\n+    vocab = ['beer', 'burger', 'celeri', 'coke', 'pizza',\n+             'salad', 'sparkling', 'tomato', 'water']\n+    \n+    cv = CountVectorizer(vocabulary=vocab)\n+    feature_names = cv.get_feature_names()\n+    assert_array_equal(['beer', 'burger', 'celeri', 'coke', 'pizza', 'salad',\n+                        'sparkling', 'tomato', 'water'], feature_names)\n+\n+    for idx, name in enumerate(feature_names):\n+        assert_equal(idx, cv.vocabulary_.get(name))\n+\n \n def test_feature_names():\n     cv = CountVectorizer(max_df=0.5)\n",
  "scikit-learn__scikit-learn-11310": "diff --git a/sklearn/model_selection/tests/test_search.py b/sklearn/model_selection/tests/test_search.py\nindex 0b1d5f9..d508fb1 100644\n--- a/sklearn/model_selection/tests/test_search.py\n+++ b/sklearn/model_selection/tests/test_search.py\n@@ -1149,7 +1149,36 @@ def test_search_cv_results_none_param():\n                            [0, None])\n \n \n-@ignore_warnings()\n+from sklearn.utils.testing import assert_true, assert_raises\n+from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n+from sklearn.linear_model import LogisticRegression\n+from sklearn.datasets import make_classification\n+from sklearn.utils.validation import check_is_fitted\n+\n+def test_refit_time_attribute():\n+    # Create a simple dataset\n+    X, y = make_classification(n_samples=100, n_features=20, random_state=42)\n+    \n+    # Create a model and grid search\n+    model = LogisticRegression()\n+    param_grid = {'C': [0.1, 1, 10]}\n+    grid_search = GridSearchCV(model, param_grid, refit=True)\n+\n+    # Check refit_time_ is calculated\n+    grid_search.fit(X, y)\n+    assert_true(hasattr(grid_search, 'refit_time_'))\n+    assert_true(isinstance(grid_search.refit_time_, float))\n+    assert_greater_equal(grid_search.refit_time_, 0)\n+\n+def test_refit_time_without_refit():\n+    # Test when refit is set to False\n+    X, y = make_classification(n_samples=100, n_features=20, random_state=42)\n+    model = LogisticRegression()\n+    param_grid = {'C': [0.1, 1, 10]}\n+    grid_search = GridSearchCV(model, param_grid, refit=False)\n+\n+    grid_search.fit(X, y)\n+    assert_raises(AttributeError, getattr, grid_search, 'refit_time_')\n def test_search_cv_timing():\n     svc = LinearSVC(random_state=0)\n \n",
  "scikit-learn__scikit-learn-11578": "diff --git a/sklearn/linear_model/tests/test_logistic.py b/sklearn/linear_model/tests/test_logistic.py\nindex daa75d1..b721c2b 100644\n--- a/sklearn/linear_model/tests/test_logistic.py\n+++ b/sklearn/linear_model/tests/test_logistic.py\n@@ -491,8 +491,26 @@ def test_logistic_cv():\n     scores = np.asarray(list(lr_cv.scores_.values()))\n     assert_array_equal(scores.shape, (1, 3, 1))\n \n+from sklearn.metrics.scorer import get_scorer\n \n-def test_multinomial_logistic_regression_string_inputs():\n+@pytest.mark.parametrize('scoring', ['neg_log_loss', 'accuracy'])\n+def test_logistic_cv_multiclass_score_consistency(scoring):\n+    # Test that LogisticRegressionCV uses the correct score computation\n+    X, y = make_classification(n_samples=200, n_features=20, n_classes=3, n_informative=10, random_state=0)\n+\n+    for multi_class in ['ovr', 'multinomial']:\n+        clf_multiclass = LogisticRegressionCV(cv=5, solver='lbfgs', multi_class=multi_class, random_state=42)\n+        clf_multiclass.fit(X, y)\n+\n+        scorer = get_scorer(scoring)\n+        custom_score = scorer(clf_multiclass, X, y)\n+\n+        # Manually create the expected logistic regression\n+        clf_manual = LogisticRegression(C=clf_multiclass.C_[0], solver='lbfgs', multi_class=multi_class, random_state=42)\n+        clf_manual.fit(X, y)\n+        expected_score = scorer(clf_manual, X, y)\n+\n+        assert_almost_equal(custom_score, expected_score, err_msg=f\"Failed for multi_class='{multi_class}' with scoring='{scoring}'.\")\n     # Test with string labels for LogisticRegression(CV)\n     n_samples, n_features, n_classes = 50, 5, 3\n     X_ref, y = make_classification(n_samples=n_samples, n_features=n_features,\n",
  "scikit-learn__scikit-learn-12585": "diff --git a/sklearn/tests/test_base.py b/sklearn/tests/test_base.py\nindex 4752f9c..00754f2 100644\n--- a/sklearn/tests/test_base.py\n+++ b/sklearn/tests/test_base.py\n@@ -154,7 +154,38 @@ def test_clone_nan():\n     assert clf.empty is clf2.empty\n \n \n-def test_clone_sparse_matrices():\n+from sklearn.base import BaseEstimator, clone\n+from sklearn.utils.estimator_checks import check_estimator\n+import pytest\n+\n+def test_clone_estimator_types():\n+    # Check that clone works for parameters that are types rather than instances\n+    class MyEstimator(BaseEstimator):\n+        def __init__(self, empty=None):\n+            self.empty = empty\n+\n+    clf = MyEstimator(empty=MyEstimator)\n+    clf2 = clone(clf)\n+\n+    assert clf.empty is clf2.empty\n+\n+# Additional test to ensure proper handling of estimator types\n+def test_clone_with_estimator_class_parameter():\n+    class WrapperEstimator(BaseEstimator):\n+        def __init__(self, base_estimator=None):\n+            self.base_estimator = base_estimator\n+\n+    wrapper = WrapperEstimator(base_estimator=BaseEstimator)\n+    cloned_wrapper = clone(wrapper)\n+\n+    assert wrapper.base_estimator is cloned_wrapper.base_estimator\n+\n+# Ensure that a wrapping estimator which has a class parameter does not raise issues\n+@pytest.mark.parametrize(\"Estimator\", [WrapperEstimator])\n+def test_cloned_estimator_types_behave_correctly(Estimator):\n+    estimator = Estimator(base_estimator=BaseEstimator)\n+    cloned = clone(estimator)\n+    check_estimator(cloned)\n     sparse_matrix_classes = [\n         getattr(sp, name)\n         for name in dir(sp) if name.endswith('_matrix')]\n",
  "scikit-learn__scikit-learn-12973": "diff --git a/sklearn/linear_model/tests/test_least_angle.py b/sklearn/linear_model/tests/test_least_angle.py\nindex 790b864..66d8e64 100644\n--- a/sklearn/linear_model/tests/test_least_angle.py\n+++ b/sklearn/linear_model/tests/test_least_angle.py\n@@ -19,8 +19,28 @@ from sklearn.utils.testing import TempMemmap\n from sklearn.exceptions import ConvergenceWarning\n from sklearn import linear_model, datasets\n from sklearn.linear_model.least_angle import _lars_path_residues\n+from sklearn.linear_model.least_angle import LassoLarsIC\n \n diabetes = datasets.load_diabetes()\n+\n+@pytest.mark.parametrize('init_copy_X, fit_copy_X, expected', [\n+    (True, None, True),   # use init parameter if fit is None\n+    (False, None, False), # use init parameter if fit is None\n+    (True, False, False), # fit param overrides init param\n+    (False, True, True),  # fit param overrides init param\n+])\n+def test_lasso_lars_ic_copyx_none_behavior(init_copy_X, fit_copy_X, expected):\n+    \"\"\" \n+    Test that if copy_X is set to None in the fit method, \n+    it respects the initialization parameter.\n+    \"\"\"\n+    lasso_lars = LassoLarsIC(copy_X=init_copy_X, precompute=False)\n+    rng = np.random.RandomState(0)\n+    X = rng.normal(0, 1, (100, 5))\n+    X_copy = X.copy()\n+    y = X[:, 2]\n+    lasso_lars.fit(X, y, copy_X=fit_copy_X)\n+    assert expected == np.array_equal(X, X_copy)\n X, y = diabetes.data, diabetes.target\n \n # TODO: use another dataset that has multiple drops\n",
  "scikit-learn__scikit-learn-13124": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex 785bf42..2777cc2 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -482,6 +482,20 @@ def test_shuffle_kfold_stratifiedkfold_reproducibility():\n \n \n def test_shuffle_stratifiedkfold():\n+    # Test that shuffling occurs with different random states\n+    X = np.arange(10)\n+    y = [0] * 5 + [1] * 5\n+    kf1 = StratifiedKFold(5, shuffle=True, random_state=0)\n+    kf2 = StratifiedKFold(5, shuffle=True, random_state=1)\n+    test_set1 = sorted([tuple(s[1]) for s in kf1.split(X, y)])\n+    test_set2 = sorted([tuple(s[1]) for s in kf2.split(X, y)])\n+    assert test_set1 != test_set2, \"Shuffling failed: test sets are identical with different random states\"\n+\n+    # Check if the shuffle really changes the order in the same stratification\n+    kf_no_shuffle = StratifiedKFold(5, shuffle=False)\n+    test_set_no_shuffle = sorted([tuple(s[1]) for s in kf_no_shuffle.split(X, y)])\n+    assert test_set1 != test_set_no_shuffle, \"Shuffling failed: test sets are identical with and without shuffle\"\n+    assert test_set2 != test_set_no_shuffle, \"Shuffling failed: test sets are identical with and without shuffle\"\n     # Check that shuffling is happening when requested, and for proper\n     # sample coverage\n     X_40 = np.ones(40)\n",
  "scikit-learn__scikit-learn-13135": "diff --git a/sklearn/preprocessing/tests/test_discretization.py b/sklearn/preprocessing/tests/test_discretization.py\nindex a18a1c5..fa90bc7 100644\n--- a/sklearn/preprocessing/tests/test_discretization.py\n+++ b/sklearn/preprocessing/tests/test_discretization.py\n@@ -203,6 +203,29 @@ def test_nonuniform_strategies(strategy, expected_2bins, expected_3bins):\n     assert_array_equal(expected_3bins, Xt.ravel())\n \n \n+@pytest.mark.parametrize(\n+    'strategy, expected_2bins, expected_3bins, expected_5bins',\n+    [('uniform', [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 2, 2], [0, 0, 1, 1, 4, 4]),\n+     ('kmeans', [0, 0, 0, 0, 1, 1], [0, 0, 1, 1, 2, 2], [0, 0, 1, 2, 3, 4]),\n+     ('quantile', [0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 2, 2], [0, 1, 2, 3, 4, 4])])\n+def test_nonuniform_strategies(strategy, expected_2bins, expected_3bins, expected_5bins):\n+    X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)\n+\n+    # with 2 bins\n+    est = KBinsDiscretizer(n_bins=2, strategy=strategy, encode='ordinal')\n+    Xt = est.fit_transform(X)\n+    assert_array_equal(expected_2bins, Xt.ravel())\n+\n+    # with 3 bins\n+    est = KBinsDiscretizer(n_bins=3, strategy=strategy, encode='ordinal')\n+    Xt = est.fit_transform(X)\n+    assert_array_equal(expected_3bins, Xt.ravel())\n+\n+    # with 5 bins to test the fix for kmeans unsorted bin_edges issue\n+    est = KBinsDiscretizer(n_bins=5, strategy=strategy, encode='ordinal')\n+    Xt = est.fit_transform(X)\n+    assert_array_equal(expected_5bins, Xt.ravel())\n+    \n @pytest.mark.parametrize('strategy', ['uniform', 'kmeans', 'quantile'])\n @pytest.mark.parametrize('encode', ['ordinal', 'onehot', 'onehot-dense'])\n def test_inverse_transform(strategy, encode):\n",
  "scikit-learn__scikit-learn-13142": "",
  "scikit-learn__scikit-learn-13328": "",
  "scikit-learn__scikit-learn-13439": "diff --git a/sklearn/pipeline.py b/sklearn/pipeline.py\nindex 4594f40..e1dbdfa 100644\n--- a/sklearn/pipeline.py\n+++ b/sklearn/pipeline.py\n@@ -131,6 +131,10 @@ class Pipeline(_BaseComposition):\n         self._validate_steps()\n         self.memory = memory\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the pipeline.\"\"\"\n+        return len(self.steps)\n+\n     def get_params(self, deep=True):\n         \"\"\"Get parameters for this estimator.\n \n",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..d90819a 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,8 +1,37 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n+@pytest.mark.filterwarnings('ignore:default contamination')\n+@pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n+def test_iforest_warm_start_initialization():\n+    \"\"\"Test the proper initialization of the warm_start parameter in IsolationForest.\"\"\"\n+    rng = check_random_state(0)\n+    X = rng.randn(20, 2)\n+\n+    # Initialize with the warm_start parameter set to True\n+    clf = IsolationForest(n_estimators=10, max_samples=20,\n+                          random_state=rng, warm_start=True)\n+    assert clf.warm_start is True\n+\n+def test_iforest_warm_start_behavior():\n+    \"\"\"Test iterative addition of iTrees to an iForest using warm_start.\"\"\"\n \n-# Authors: Nicolas Goix <nicolas.goix@telecom-paristech.fr>\n+    rng = check_random_state(0)\n+    X = rng.randn(20, 2)\n+\n+    # Fit first 10 trees\n+    clf = IsolationForest(n_estimators=10, max_samples=20,\n+                          random_state=rng, warm_start=True)\n+    clf.fit(X)\n+    # Remember the 1st tree\n+    tree_1 = clf.estimators_[0]\n+    # Fit another 10 trees\n+    clf.set_params(n_estimators=20)\n+    clf.fit(X)\n+    # Expecting 20 fitted trees and no overwritten trees\n+    assert len(clf.estimators_) == 20\n+    assert clf.estimators_[0] is tree_1\n #          Alexandre Gramfort <alexandre.gramfort@telecom-paristech.fr>\n # License: BSD 3 clause\n \n@@ -10,7 +39,8 @@ import pytest\n \n import numpy as np\n \n-from sklearn.utils.testing import assert_array_equal\n+from sklearn.ensemble import IsolationForest\n+from sklearn.utils import check_random_state\n from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_raises\n from sklearn.utils.testing import assert_raises_regex\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..2465293 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -498,6 +498,49 @@ def test_transform():\n         voting='soft',\n         flatten_transform=False).fit(X, y)\n \n+from sklearn.datasets import load_iris\n+from sklearn.ensemble import VotingClassifier, VotingRegressor\n+from sklearn.linear_model import LogisticRegression\n+from sklearn.ensemble import RandomForestClassifier\n+import numpy as np\n+import pytest\n+\n+@pytest.mark.filterwarnings('ignore: Default solver will be changed')  # 0.22\n+@pytest.mark.filterwarnings('ignore: Default multi_class will')  # 0.22\n+@pytest.mark.parametrize(\n+    \"X, y, voter\",\n+    [(load_iris(return_X_y=True)[0], load_iris(return_X_y=True)[1], VotingClassifier(\n+        [('lr', LogisticRegression()), \n+         ('rf', RandomForestClassifier(n_estimators=5))])),\n+     (np.random.rand(100, 5), np.random.rand(100), VotingRegressor(\n+         [('lr', LinearRegression()), \n+          ('rf', RandomForestRegressor(n_estimators=5))]))]\n+)\n+def test_none_estimator_with_weights(X, y, voter):\n+    # check that an estimator can be set to None and that passing some weights works\n+    # regression test for\n+    # https://github.com/scikit-learn/scikit-learn/issues/13777\n+    voter.fit(X, y, sample_weight=np.ones(y.shape))\n+    voter.set_params(lr=None)\n+    voter.fit(X, y, sample_weight=np.ones(y.shape))\n+    y_pred = voter.predict(X)\n+    assert y_pred.shape == y.shape\n+\n+def test_single_estimator_with_weights():\n+    # New test case to ensure functionality when one estimator is provided\n+    X, y = load_iris(return_X_y=True)\n+    voter = VotingClassifier(estimators=[('lr', LogisticRegression())])\n+    voter.fit(X, y, sample_weight=np.ones(y.shape))\n+    y_pred = voter.predict(X)\n+    assert y_pred.shape == y.shape\n+\n+def test_all_none_estimators():\n+    # New test case to ensure proper exception when all estimators are None\n+    X, y = load_iris(return_X_y=True)\n+    voter = VotingClassifier(estimators=[('lr', None), ('rf', None)])\n+    with pytest.raises(ValueError, match=\"All estimators are None\"):\n+        voter.fit(X, y, sample_weight=np.ones(y.shape))\n+\n     assert_array_equal(eclf1.transform(X).shape, (4, 6))\n     assert_array_equal(eclf2.transform(X).shape, (4, 6))\n     assert_array_equal(eclf3.transform(X).shape, (3, 4, 2))\n@@ -506,4 +549,4 @@ def test_transform():\n     assert_array_almost_equal(\n             eclf3.transform(X).swapaxes(0, 1).reshape((4, 6)),\n             eclf2.transform(X)\n-    )\n+    )\n",
  "scikit-learn__scikit-learn-14053": "diff --git a/sklearn/tree/tests/test_export.py b/sklearn/tree/tests/test_export.py\nindex 50eb697..e8d507b 100644\n--- a/sklearn/tree/tests/test_export.py\n+++ b/sklearn/tree/tests/test_export.py\n@@ -397,7 +397,26 @@ def test_export_text():\n     assert export_text(reg, decimals=1, show_weights=True) == expected_report\n \n \n-def test_plot_tree_entropy(pyplot):\n+def test_export_text_single_feature():\n+    from sklearn.tree import DecisionTreeClassifier\n+    from sklearn.tree import export_text\n+    from sklearn.datasets import load_iris\n+\n+    X, y = load_iris(return_X_y=True)\n+    X_single = X[:, 0].reshape(-1, 1)  # Use only the first feature\n+\n+    clf = DecisionTreeClassifier()\n+    clf.fit(X_single, y)\n+\n+    expected_report = dedent(\"\"\"\n+    |--- sepal_length <= 5.45\n+    |   |--- class: 0\n+    |--- sepal_length >  5.45\n+    |   |--- class: 1\n+    \"\"\").lstrip()\n+\n+    # Verify that export_text does not raise IndexError when the tree has one feature\n+    assert export_text(clf, feature_names=['sepal_length']) == expected_report\n     # mostly smoke tests\n     # Check correctness of export_graphviz for criterion = entropy\n     clf = DecisionTreeClassifier(max_depth=3,\n",
  "scikit-learn__scikit-learn-14087": "diff --git a/sklearn/linear_model/tests/test_logistic.py b/sklearn/linear_model/tests/test_logistic.py\nindex 2a87dbf..36c1778 100644\n--- a/sklearn/linear_model/tests/test_logistic.py\n+++ b/sklearn/linear_model/tests/test_logistic.py\n@@ -1554,7 +1554,26 @@ def test_LogisticRegressionCV_no_refit(multi_class):\n     assert lrcv.coef_.shape == (n_classes, n_features)\n \n \n-def test_LogisticRegressionCV_elasticnet_attribute_shapes():\n+@pytest.mark.parametrize('penalty', ['l2', 'elasticnet'])\n+@pytest.mark.parametrize('solver', ['saga', 'liblinear'])\n+def test_LogisticRegressionCV_no_refit_multiclass_ovr(penalty, solver):\n+    # Test LogisticRegressionCV with various configurations with refit=False\n+\n+    X, y = make_classification(n_samples=1000, n_classes=3, n_features=5,\n+                               n_informative=3, random_state=42)\n+\n+    Cs = np.logspace(-3, 3, 3)\n+    l1_ratios = np.linspace(0, 1, 3) if penalty == 'elasticnet' else None\n+\n+    lrcv = LogisticRegressionCV(penalty=penalty, Cs=Cs, solver=solver,\n+                                l1_ratios=l1_ratios, refit=False, random_state=0,\n+                                multi_class='ovr')\n+    lrcv.fit(X, y)\n+\n+    # Check attribute shapes\n+    assert lrcv.C_.shape == (3,)\n+    if penalty == 'elasticnet':\n+        assert lrcv.l1_ratio_.shape == (3,)\n     # Make sure the shapes of scores_ and coefs_paths_ attributes are correct\n     # when using elasticnet (added one dimension for l1_ratios)\n \n",
  "scikit-learn__scikit-learn-14141": "diff --git a/sklearn/utils/tests/test_show_versions.py b/sklearn/utils/tests/test_show_versions.py\nindex fa39255..6d3b177 100644\n--- a/sklearn/utils/tests/test_show_versions.py\n+++ b/sklearn/utils/tests/test_show_versions.py\n@@ -24,10 +24,13 @@ def test_get_deps_info():\n     assert 'pandas' in deps_info\n     assert 'matplotlib' in deps_info\n \n+def test_joblib_in_deps_info():\n+    deps_info = _get_deps_info()\n+    assert 'joblib' in deps_info\n \n def test_show_versions_with_blas(capsys):\n     show_versions()\n     out, err = capsys.readouterr()\n     assert 'python' in out\n     assert 'numpy' in out\n-    assert 'BLAS' in out\n+    assert 'BLAS' in out\n",
  "scikit-learn__scikit-learn-14496": "diff --git a/sklearn/cluster/tests/test_optics.py b/sklearn/cluster/tests/test_optics.py\nindex 6c9dac3..c9672c6 100644\n--- a/sklearn/cluster/tests/test_optics.py\n+++ b/sklearn/cluster/tests/test_optics.py\n@@ -101,6 +101,18 @@ def test_extract_xi():\n                    xi=0.4).fit(X)\n     assert_array_equal(clust.labels_, expected_labels)\n \n+def test_optics_float_min_samples():\n+    # Test case for the fix where min_samples is specified as a float\n+    rng = np.random.RandomState(42)\n+    X = np.vstack([rng.normal(size=(20, 2)), rng.normal(loc=5, size=(30, 2))])\n+\n+    clust = OPTICS(min_samples=0.1, min_cluster_size=0.05,\n+                   max_eps=np.inf, cluster_method='xi', xi=0.05).fit(X)\n+\n+    # Check that no exception is raised and results are as expected\n+    # Output depends on random state; we expect at least two clusters\n+    assert np.unique(clust.labels_).shape[0] >= 2\n+\n     X = np.vstack((C1, C2, C3, C4, C5, np.array([[100, 100]] * 2), C6))\n     expected_labels = np.r_[[1] * 5, [3] * 5, [2] * 5, [0] * 5, [2] * 5,\n                             -1, -1, [4] * 5]\n@@ -112,6 +124,18 @@ def test_extract_xi():\n     # this may fail if the predecessor correction is not at work!\n     assert_array_equal(clust.labels_, expected_labels)\n \n+def test_optics_float_min_samples():\n+    # Test case for the fix where min_samples is specified as a float\n+    rng = np.random.RandomState(42)\n+    X = np.vstack([rng.normal(size=(20, 2)), rng.normal(loc=5, size=(30, 2))])\n+\n+    clust = OPTICS(min_samples=0.1, min_cluster_size=0.05,\n+                   max_eps=np.inf, cluster_method='xi', xi=0.05).fit(X)\n+\n+    # Check that no exception is raised and results are as expected\n+    # Output depends on random state; we expect at least two clusters\n+    assert np.unique(clust.labels_).shape[0] >= 2\n+\n     C1 = [[0, 0], [0, 0.1], [0, -.1], [0.1, 0]]\n     C2 = [[10, 10], [10, 9], [10, 11], [9, 10]]\n     C3 = [[100, 100], [100, 90], [100, 110], [90, 100]]\n@@ -124,6 +148,18 @@ def test_extract_xi():\n                    xi=0.04).fit(X)\n     assert_array_equal(clust.labels_, expected_labels)\n \n+def test_optics_float_min_samples():\n+    # Test case for the fix where min_samples is specified as a float\n+    rng = np.random.RandomState(42)\n+    X = np.vstack([rng.normal(size=(20, 2)), rng.normal(loc=5, size=(30, 2))])\n+\n+    clust = OPTICS(min_samples=0.1, min_cluster_size=0.05,\n+                   max_eps=np.inf, cluster_method='xi', xi=0.05).fit(X)\n+\n+    # Check that no exception is raised and results are as expected\n+    # Output depends on random state; we expect at least two clusters\n+    assert np.unique(clust.labels_).shape[0] >= 2\n+\n \n def test_cluster_hierarchy_():\n     rng = np.random.RandomState(0)\n",
  "scikit-learn__scikit-learn-14710": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/tests/test_gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/tests/test_gradient_boosting.py\nindex 7e8bccd..80a03dd 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/tests/test_gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/tests/test_gradient_boosting.py\n@@ -414,4 +414,23 @@ def test_infinite_values_missing_values():\n                                                learning_rate=1, max_depth=2)\n \n     assert stump_clf.fit(X, y_isinf).score(X, y_isinf) == 1\n-    assert stump_clf.fit(X, y_isnan).score(X, y_isnan) == 1\n+    assert stump_clf.fit(X, y_isnan).score(X, y_isnan) == 1\n+\n+@pytest.mark.parametrize(\"scoring\", [None, 'loss'])\n+def test_string_target_early_stopping(scoring):\n+    # Regression test for issue #14709 where the targets need to be encoded\n+    # before computing the score during early stopping.\n+\n+    rng = np.random.RandomState(42)\n+    X = rng.randn(100, 10)\n+    y = np.array(['class1'] * 50 + ['class2'] * 50, dtype=object)\n+    \n+    # Fit the model with early stopping enabled\n+    gbrt = HistGradientBoostingClassifier(n_iter_no_change=10, scoring=scoring)\n+    gbrt.fit(X, y)\n+    \n+    # Check if the classifier predicts the classes correctly\n+    assert set(gbrt.classes_) == {'class1', 'class2'}\n+    assert len(gbrt.train_score_) > 0\n+    if gbrt._use_validation_data:\n+        assert len(gbrt.validation_score_) > 0\n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..3a176c0 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -690,7 +690,50 @@ def test_sparse_precomputed():\n         assert \"Sparse precomputed\" in str(e)\n \n \n-def test_linearsvc_parameters():\n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for the issue with empty support_vectors_\n+    import numpy as np\n+    from scipy import sparse\n+    from sklearn import svm\n+\n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    assert not model.support_vectors_.data.size\n+    assert not model.dual_coef_.data.size\n+\n+    \n+def test_sparse_fit_with_different_kernel():\n+    # Test to ensure no ZeroDivisionError with rbf kernel\n+    import numpy as np\n+    from scipy import sparse\n+    from sklearn import svm\n+\n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='rbf')\n+    model.fit(X_train, y_train)\n+    assert model.dual_coef_ is not None\n+\n+    \n+def test_sparse_fit_with_insufficient_data():\n+    # Test sparse fit with insufficient data for training\n+    import numpy as np\n+    from scipy import sparse\n+    from sklearn import svm\n+\n+    X_train = sparse.csr_matrix([[0, 0, 0, 0]])\n+    y_train = np.array([0.0])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    assert model.dual_coef_ is not None\n     # Test possible parameter combinations in LinearSVC\n     # Generate list of possible parameter combinations\n     losses = ['hinge', 'squared_hinge', 'logistic_regression', 'foo']\n",
  "scikit-learn__scikit-learn-14983": "",
  "scikit-learn__scikit-learn-15100": "diff --git a/sklearn/feature_extraction/tests/test_text.py b/sklearn/feature_extraction/tests/test_text.py\nindex 96ea20a..90d7ff1 100644\n--- a/sklearn/feature_extraction/tests/test_text.py\n+++ b/sklearn/feature_extraction/tests/test_text.py\n@@ -98,6 +98,31 @@ def test_strip_accents():\n     assert strip_accents_unicode(a) == expected\n \n \n+def test_strip_accents_nfkd_input():\n+    # Test strings already in NFKD form\n+    # Single character with accent separated: \u00f1 as 'n' + tilde\n+    s1 = chr(241)  # Using single code point\n+    s2 = chr(110) + chr(771)  # Using 'n' + combining tilde\n+\n+    # Expected to normalize to 'n' for both\n+    assert strip_accents_unicode(s1) == 'n'\n+    assert strip_accents_unicode(s2) == 'n'\n+\n+    # Another example with multiple combined accents\n+    a = \"o\\u0308\\u0304\"  # 'o' with diaeresis and macron\n+    expected = \"o\"\n+    assert strip_accents_unicode(a) == expected\n+\n+    # Combining marks by themselves should be removed\n+    a = \"\\u0300\\u0301\\u0302\\u0303\"  # Various combining marks\n+    expected = \"\"\n+    assert strip_accents_unicode(a) == expected\n+    \n+    # Mixing decomposed accents with normal text\n+    a = \"this o\\u0308 is a test\"\n+    expected = \"this o is a test\"\n+    assert strip_accents_unicode(a) == expected\n+\n def test_to_ascii():\n     # check some classical latin accentuated symbols\n     a = '\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e7\u00e8\u00e9\u00ea\u00eb'\n",
  "scikit-learn__scikit-learn-25102": "",
  "scikit-learn__scikit-learn-25232": "",
  "scikit-learn__scikit-learn-25931": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3714d1a..21615a6 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -330,7 +330,27 @@ def test_iforest_with_n_jobs_does_not_segfault():\n def test_base_estimator_property_deprecated():\n     X = np.array([[1, 2], [3, 4]])\n     y = np.array([1, 0])\n-    model = IsolationForest()\n+    import warnings\n+    import pytest\n+    import numpy as np\n+    from sklearn.ensemble import IsolationForest\n+\n+    def test_iforest_preserve_feature_names():\n+        \"\"\"Check that feature names are preserved when contamination is not \"auto\".\n+        \n+        Feature names are required for consistency checks during scoring.\n+        \n+        Non-regression test for Issue #25844\n+        \"\"\"\n+        pd = pytest.importorskip(\"pandas\")\n+        rng = np.random.RandomState(0)\n+        \n+        X = pd.DataFrame(data=rng.randn(4, 1), columns=[\"a\"])\n+        model = IsolationForest(random_state=0, contamination=0.05)\n+        \n+        with warnings.catch_warnings():\n+            warnings.simplefilter(\"error\", UserWarning)\n+            model.fit(X)\n     model.fit(X, y)\n \n     warn_msg = (\n@@ -338,4 +358,4 @@ def test_base_estimator_property_deprecated():\n         \"will be removed in 1.4. Use `estimator_` instead.\"\n     )\n     with pytest.warns(FutureWarning, match=warn_msg):\n-        model.base_estimator_\n+        model.base_estimator_\n",
  "scikit-learn__scikit-learn-25973": "diff --git a/sklearn/feature_selection/tests/test_sequential.py b/sklearn/feature_selection/tests/test_sequential.py\nindex 42e1fbb..59619c8 100644\n--- a/sklearn/feature_selection/tests/test_sequential.py\n+++ b/sklearn/feature_selection/tests/test_sequential.py\n@@ -308,9 +308,37 @@ def test_backward_neg_tol():\n         n_features_to_select=\"auto\",\n         direction=\"backward\",\n         tol=-1e-3,\n-    )\n+    ) \n+\n+def test_sequential_feature_selector_with_leave_one_out():\n+    \"\"\"Test SequentialFeatureSelector with LeaveOneOut cross-validation.\"\"\"\n+    from sklearn.datasets import make_classification\n+    from sklearn.feature_selection import SequentialFeatureSelector\n+    from sklearn.neighbors import KNeighborsClassifier\n+    from sklearn.model_selection import LeaveOneOut\n+\n+    X, y = make_classification(n_samples=30, n_features=10, random_state=0)\n+    loo = LeaveOneOut()\n+    knc = KNeighborsClassifier(n_neighbors=3)\n+    sfs = SequentialFeatureSelector(knc, n_features_to_select=5, cv=loo)\n+    sfs.fit(X, y)\n+\n+def test_sequential_feature_selector_with_explicit_split_indices():\n+    \"\"\"Test SequentialFeatureSelector using explicit train/test indices.\"\"\"\n+    from sklearn.datasets import make_classification\n+    from sklearn.feature_selection import SequentialFeatureSelector\n+    from sklearn.neighbors import KNeighborsClassifier\n+    \n+    X, y = make_classification(n_samples=50, n_features=10, random_state=0)\n+    # Manually split data into train/test indices\n+    train_indices = list(range(0, 40))\n+    test_indices = list(range(40, 50))\n+    cv = [(train_indices, test_indices)]\n+    knc = KNeighborsClassifier(n_neighbors=3)\n+    sfs = SequentialFeatureSelector(knc, n_features_to_select=5, cv=cv)\n+    sfs.fit(X, y)\n     Xr = sfs.fit_transform(X, y)\n     new_score = lr.fit(Xr, y).score(Xr, y)\n \n     assert 0 < sfs.get_support().sum() < X.shape[1]\n-    assert new_score < initial_score\n+    assert new_score < initial_score\n",
  "scikit-learn__scikit-learn-26323": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex b52e888..225c6f4 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -13,6 +13,7 @@ from sklearn.utils._testing import assert_array_equal\n from sklearn.utils._testing import assert_allclose_dense_sparse\n from sklearn.utils._testing import assert_almost_equal\n \n+from sklearn.feature_selection import VarianceThreshold\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.compose import (\n     ColumnTransformer,\n@@ -21,6 +22,9 @@ from sklearn.compose import (\n )\n from sklearn.exceptions import NotFittedError\n from sklearn.preprocessing import FunctionTransformer\n+import pytest\n+import pandas as pd\n+import numpy as np\n from sklearn.preprocessing import StandardScaler, Normalizer, OneHotEncoder\n \n \n",
  "scikit-learn__scikit-learn-9288": "diff --git a/sklearn/cluster/tests/test_k_means.py b/sklearn/cluster/tests/test_k_means.py\nindex abeeff0..e345150 100644\n--- a/sklearn/cluster/tests/test_k_means.py\n+++ b/sklearn/cluster/tests/test_k_means.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Testing for K-means\"\"\"\n import sys\n \n@@ -944,6 +945,19 @@ def test_k_means_empty_cluster_relocated():\n     assert len(set(km.labels_)) == 2\n     assert_allclose(km.cluster_centers_, [[-1], [1]])\n \n+def test_result_of_kmeans_inertia_equal_in_diff_n_jobs():\n+    # Test that KMeans inertia is the same regardless of n_jobs\n+    rnd = np.random.RandomState(42)\n+    X = rnd.normal(size=(100, 5))\n+\n+    inertia_values = []\n+    for n_jobs in range(1, 5):\n+        kmeans = KMeans(n_clusters=3, random_state=42, n_jobs=n_jobs)\n+        kmeans.fit(X)\n+        inertia_values.append(kmeans.inertia_)\n+\n+    for inertia in inertia_values[1:]:\n+        assert_almost_equal(inertia_values[0], inertia)\n \n def test_minibatch_kmeans_partial_fit_int_data():\n     # Issue GH #14314\n",
  "sphinx-doc__sphinx-10323": "diff --git a/tests/test_directive_code.py b/tests/test_directive_code.py\nindex 949c70e..db84925 100644\n--- a/tests/test_directive_code.py\n+++ b/tests/test_directive_code.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Test the code-block directive.\"\"\"\n \n import os\n@@ -249,9 +250,47 @@ def test_LiteralIncludeReader_dedent(literal_inc_path):\n     assert content == (\"def baz():\\n\"\n                        \"    pass\\n\"\n                        \"\\n\")\n-\n-\n @pytest.mark.xfail(os.name != 'posix', reason=\"Not working on windows\")\n+def test_LiteralIncludeReader_indent_prepend(literal_inc_path):\n+    # This test checks if the prepend text is correctly indented\n+    # Assume pom.xml line 4: \"<groupId>com.github.ekryd.sortpom</groupId>\"\n+    options = {\n+        'start-at': '<groupId>com.github.ekryd.sortpom</groupId>',\n+        'end-at': '</plugin>',\n+        'prepend': '      <plugin>',\n+        'dedent': None\n+    }\n+    reader = LiteralIncludeReader(literal_inc_path, options, DUMMY_CONFIG)\n+    content, lines = reader.read()\n+    expected_content = (\"      <plugin>\\n\"\n+                        \"        <groupId>com.github.ekryd.sortpom</groupId>\\n\"\n+                        \"        <artifactId>sortpom-maven-plugin</artifactId>\\n\"\n+                        \"        <version>2.15.0</version>\\n\"\n+                        \"        <configuration>\\n\"\n+                        \"          <verifyFailOn>strict</verifyFailOn>\\n\"\n+                        \"        </configuration>\\n\"\n+                        \"      </plugin>\\n\")\n+    assert content == expected_content\n+\n+def test_LiteralIncludeReader_indent_append(literal_inc_path):\n+    # This test checks if the append text is correctly indented\n+    options = {\n+        'start-at': '<groupId>com.github.ekryd.sortpom</groupId>',\n+        'end-at': '</plugin>',\n+        'append': '      </plugin>',\n+        'dedent': None\n+    }\n+    reader = LiteralIncludeReader(literal_inc_path, options, DUMMY_CONFIG)\n+    content, lines = reader.read()\n+    expected_content = (\"        <groupId>com.github.ekryd.sortpom</groupId>\\n\"\n+                        \"        <artifactId>sortpom-maven-plugin</artifactId>\\n\"\n+                        \"        <version>2.15.0</version>\\n\"\n+                        \"        <configuration>\\n\"\n+                        \"          <verifyFailOn>strict</verifyFailOn>\\n\"\n+                        \"        </configuration>\\n\"\n+                        \"      </plugin>\\n\"\n+                        \"      </plugin>\\n\")\n+    assert content == expected_content\n def test_LiteralIncludeReader_tabwidth(testroot):\n     # tab-width: 4\n     options = {'tab-width': 4, 'pyobject': 'Qux'}\n",
  "sphinx-doc__sphinx-10449": "diff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex 82ec43a..24b66ad 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -1022,7 +1022,21 @@ def test_autodoc_typehints_description_no_undoc_doc_rtype(app):\n             '\\n'\n             '   Return type:\\n'\n             '      None\\n' == context)\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n \n+@pytest.mark.sphinx('text', testroot='ext-autodoc',\n+                    confoverrides={'autodoc_typehints': \"description\"})\n+def test_autodoc_typehints_description_no_return_type_for_class(app):\n+    (app.srcdir / 'index.rst').write_text(\n+        '.. autoclass:: target.typehints.Square\\n'\n+        '   :members:\\n',\n+        encoding='utf8'\n+    )\n+    app.build()\n+    context = (app.outdir / 'index.txt').read_text(encoding='utf8')\n+    # Ensure there is no \"Return type\" line for the class constructor\n+    assert 'Return type:\\n   None' not in context\n \n @pytest.mark.sphinx('text', testroot='ext-autodoc',\n                     confoverrides={'autodoc_typehints': \"description\"})\n@@ -1053,7 +1067,21 @@ def test_autodoc_typehints_description_with_documented_init(app):\n             '\\n'\n             '      Return type:\\n'\n             '         None\\n' == context)\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n \n+@pytest.mark.sphinx('text', testroot='ext-autodoc',\n+                    confoverrides={'autodoc_typehints': \"description\"})\n+def test_autodoc_typehints_description_no_return_type_for_class(app):\n+    (app.srcdir / 'index.rst').write_text(\n+        '.. autoclass:: target.typehints.Square\\n'\n+        '   :members:\\n',\n+        encoding='utf8'\n+    )\n+    app.build()\n+    context = (app.outdir / 'index.txt').read_text(encoding='utf8')\n+    # Ensure there is no \"Return type\" line for the class constructor\n+    assert 'Return type:\\n   None' not in context\n \n @pytest.mark.sphinx('text', testroot='ext-autodoc',\n                     confoverrides={'autodoc_typehints': \"description\",\n",
  "sphinx-doc__sphinx-10466": "diff --git a/tests/test_build_gettext.py b/tests/test_build_gettext.py\nindex a6fc946..ad8b103 100644\n--- a/tests/test_build_gettext.py\n+++ b/tests/test_build_gettext.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Test the build process with gettext builder with the test root.\"\"\"\n \n import gettext\n@@ -9,6 +10,7 @@ from subprocess import PIPE, CalledProcessError\n import pytest\n \n from sphinx.util.osutil import cd\n+from sphinx.builders.gettext import Catalog, MsgOrigin\n \n \n @pytest.mark.sphinx('gettext', srcdir='root-gettext')\n",
  "sphinx-doc__sphinx-10673": "",
  "sphinx-doc__sphinx-7440": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 975a00f..25dfc36 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -147,6 +147,37 @@ def test_glossary(app):\n     assert (\"term3\", \"term3\", \"term\", \"index\", \"term-term3\", -1) in objects\n     assert (\"term4\", \"term4\", \"term\", \"index\", \"term-term4\", -1) in objects\n \n+    # Additional test for case sensitivity\n+    text_case = (\n+        \".. glossary::\\n\"\n+        \"\\n\"\n+        \"   mysql\\n\"\n+        \"       description for mysql\\n\"\n+        \"\\n\"\n+        \"   MySQL\\n\"\n+        \"       description for MySQL\\n\"\n+    )\n+\n+    # doctree for case sensitivity\n+    doctree_case = restructuredtext.parse(app, text_case)\n+    assert_node(doctree_case, (\n+        [glossary, definition_list, ([definition_list_item, ([term, (\"mysql\",\n+                                                                     index)],\n+                                                             definition)],\n+                                     [definition_list_item, ([term, (\"MySQL\",\n+                                                                     index)],\n+                                                             definition)])],\n+    ))\n+    assert_node(doctree_case[0][0][0][0][1],\n+                entries=[(\"single\", \"mysql\", \"term-mysql\", \"main\", None)])\n+    assert_node(doctree_case[0][0][1][0][1],\n+                entries=[(\"single\", \"MySQL\", \"term-MySQL\", \"main\", None)])\n+\n+    # index for case sensitivity\n+    objects_case = list(app.env.get_domain(\"std\").get_objects())\n+    assert (\"mysql\", \"mysql\", \"term\", \"index\", \"term-mysql\", -1) in objects_case\n+    assert (\"MySQL\", \"MySQL\", \"term\", \"index\", \"term-MySQL\", -1) in objects_case\n+\n \n def test_glossary_warning(app, status, warning):\n     # empty line between terms\n",
  "sphinx-doc__sphinx-7757": "diff --git a/tests/test_util_inspect.py b/tests/test_util_inspect.py\nindex b3053d1..15cf1a6 100644\n--- a/tests/test_util_inspect.py\n+++ b/tests/test_util_inspect.py\n@@ -340,8 +340,15 @@ def test_signature_from_str_positionaly_only_args():\n     assert sig.parameters['a'].kind == Parameter.POSITIONAL_ONLY\n     assert sig.parameters['b'].kind == Parameter.POSITIONAL_OR_KEYWORD\n \n-\n-def test_signature_from_str_invalid():\n+def test_signature_from_str_positional_only_with_defaults():\n+    sig = inspect.signature_from_str('(a, b=0, /, c=1)')\n+    assert list(sig.parameters.keys()) == ['a', 'b', 'c']\n+    assert sig.parameters['a'].kind == Parameter.POSITIONAL_ONLY\n+    assert sig.parameters['a'].default == Parameter.empty\n+    assert sig.parameters['b'].kind == Parameter.POSITIONAL_ONLY\n+    assert sig.parameters['b'].default == '0'\n+    assert sig.parameters['c'].kind == Parameter.POSITIONAL_OR_KEYWORD\n+    assert sig.parameters['c'].default == '1'\n     with pytest.raises(SyntaxError):\n         inspect.signature_from_str('')\n \n",
  "sphinx-doc__sphinx-7889": "diff --git a/tests/test_ext_autodoc_mock.py b/tests/test_ext_autodoc_mock.py\nindex 7302feb..346da28 100644\n--- a/tests/test_ext_autodoc_mock.py\n+++ b/tests/test_ext_autodoc_mock.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_ext_autodoc_mock\n     ~~~~~~~~~~~~~~~~~~~~~\n@@ -11,6 +12,7 @@\n import abc\n import sys\n from importlib import import_module\n+from typing import TypeVar\n \n import pytest\n \n@@ -52,7 +54,15 @@ def test_MockObject():\n     assert isinstance(obj.other_method(), SubClass)\n \n \n-def test_mock():\n+def test_GenericType_with_MockObject():\n+    T = TypeVar('T')\n+\n+    class SubClassGeneric(mock.SomeClass[T]):\n+        \"\"\"docstring of SubClassGeneric\"\"\"\n+\n+    obj_generic = SubClassGeneric()\n+    assert SubClassGeneric.__doc__ == \"docstring of SubClassGeneric\"\n+    assert isinstance(obj_generic, SubClassGeneric)\n     modname = 'sphinx.unknown'\n     submodule = modname + '.submodule'\n     assert modname not in sys.modules\n",
  "sphinx-doc__sphinx-7910": "diff --git a/tests/test_ext_napoleon.py b/tests/test_ext_napoleon.py\nindex 0676869..4945c39 100644\n--- a/tests/test_ext_napoleon.py\n+++ b/tests/test_ext_napoleon.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_napoleon\n     ~~~~~~~~~~~~~\n@@ -9,6 +10,7 @@\n     :license: BSD, see LICENSE for details.\n \"\"\"\n \n+import functools\n import sys\n from collections import namedtuple\n from unittest import TestCase, mock\n@@ -165,11 +167,31 @@ class SkipMemberTest(TestCase):\n                         SampleClass.__special_doc__, False,\n                         'napoleon_include_special_with_doc')\n \n+    def test_init_decorated_doc(self):\n+        class SampleClass:\n+            @simple_decorator\n+            def __init__(self):\n+                \"\"\"Initializes the instance\"\"\"\n+\n+        # Test for the __init__ method with documentation\n+        self.assertSkip('class', '__init__', SampleClass.__init__, False,\n+                        'napoleon_include_init_with_doc')\n+\n     def test_class_special_undoc(self):\n         self.assertSkip('class', '__special_undoc__',\n                         SampleClass.__special_undoc__, True,\n                         'napoleon_include_special_with_doc')\n \n+    def test_init_decorated_doc(self):\n+        class SampleClass:\n+            @simple_decorator\n+            def __init__(self):\n+                \"\"\"Initializes the instance\"\"\"\n+\n+        # Test for the __init__ method with documentation\n+        self.assertSkip('class', '__init__', SampleClass.__init__, False,\n+                        'napoleon_include_init_with_doc')\n+\n     def test_exception_private_doc(self):\n         self.assertSkip('exception', '_private_doc',\n                         SampleError._private_doc, False,\n@@ -185,6 +207,16 @@ class SkipMemberTest(TestCase):\n                         SampleError.__special_doc__, False,\n                         'napoleon_include_special_with_doc')\n \n+    def test_init_decorated_doc(self):\n+        class SampleClass:\n+            @simple_decorator\n+            def __init__(self):\n+                \"\"\"Initializes the instance\"\"\"\n+\n+        # Test for the __init__ method with documentation\n+        self.assertSkip('class', '__init__', SampleClass.__init__, False,\n+                        'napoleon_include_init_with_doc')\n+\n     def test_exception_special_undoc(self):\n         self.assertSkip('exception', '__special_undoc__',\n                         SampleError.__special_undoc__, True,\n",
  "sphinx-doc__sphinx-7985": "diff --git a/tests/test_build_linkcheck.py b/tests/test_build_linkcheck.py\nindex 5b1b2ed..672c755 100644\n--- a/tests/test_build_linkcheck.py\n+++ b/tests/test_build_linkcheck.py\n@@ -8,6 +8,7 @@\n     :license: BSD, see LICENSE for details.\n \"\"\"\n \n+import os\n import json\n import re\n from unittest import mock\n",
  "sphinx-doc__sphinx-8035": "diff --git a/tests/test_ext_autodoc_private_members.py b/tests/test_ext_autodoc_private_members.py\nindex ad1d950..fe384b5 100644\n--- a/tests/test_ext_autodoc_private_members.py\n+++ b/tests/test_ext_autodoc_private_members.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_ext_autodoc_private_members\n     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -10,6 +11,7 @@\n \n import pytest\n \n+import pytest\n from test_ext_autodoc import do_autodoc\n \n \n",
  "sphinx-doc__sphinx-8120": "diff --git a/tests/test_intl.py b/tests/test_intl.py\nindex 58339b1..5f3da58 100644\n--- a/tests/test_intl.py\n+++ b/tests/test_intl.py\n@@ -1287,5 +1287,38 @@ def test_image_glob_intl_using_figure_language_filename(app):\n                             'image/svg+xml': 'subdir/svgimg.svg'})\n \n \n+from babel.messages import pofile\n+from babel.messages.catalog import Catalog\n+from sphinx import locale\n+\n+@pytest.mark.sphinx('html', testroot='basic', confoverrides={'language': 'da'})\n+def test_custom_danish_translation(make_app, app_params, sphinx_test_tempdir):\n+    try:\n+        # clear translators cache\n+        locale.translators.clear()\n+\n+        # prepare message catalog (.po)\n+        locale_dir = sphinx_test_tempdir / 'basic' / 'locales' / 'da' / 'LC_MESSAGES'\n+        locale_dir.makedirs()\n+        with (locale_dir / 'sphinx.po').open('wb') as f:\n+            catalog = Catalog()\n+            catalog.add('Fig. %s', 'Foobar %s')\n+            catalog.add('Listing %s', 'Whatever %s')\n+            pofile.write_po(f, catalog)\n+\n+        # construct application and convert po file to .mo\n+        args, kwargs = app_params\n+        app = make_app(*args, **kwargs)\n+        assert (locale_dir / 'sphinx.mo').exists()\n+        assert app.translator.gettext('Fig. %s') == 'Foobar %s'\n+        assert app.translator.gettext('Listing %s') == 'Whatever %s'\n+\n+        app.build()\n+        content = (app.outdir / 'index.html').read_text()\n+        assert 'Foobar 1' in content\n+        assert 'Whatever 1' in content\n+    finally:\n+        locale.translators.clear()\n+\n def getwarning(warnings):\n-    return strip_escseq(warnings.getvalue().replace(os.sep, '/'))\n+    return strip_escseq(warnings.getvalue().replace(os.sep, '/'))\n",
  "sphinx-doc__sphinx-8269": "",
  "sphinx-doc__sphinx-8459": "diff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex d1881df..e0918e4 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_ext_autodoc_configs\n     ~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -8,6 +9,33 @@\n     :license: BSD, see LICENSE for details.\n \"\"\"\n \n+import pytest\n+import sys\n+from sphinx.testing.util import SphinxTestApp\n+\n+@pytest.mark.skipif(sys.version_info < (3, 7), reason='python 3.7+ is required.')\n+@pytest.mark.sphinx('text', testroot='ext-autodoc', srcdir='autodoc_typehints_description_and_type_aliases',\n+                   confoverrides={'autodoc_typehints': \"description\",\n+                                  'autodoc_type_aliases': {'JSONObject': 'types.JSONObject'}})\n+def test_autodoc_typehints_description_and_type_aliases_for_jsonobject(app: SphinxTestApp):\n+    (app.srcdir / 'types.rst').write_text('.. autofunction:: types.sphinx_doc')\n+    app.build()\n+    context = (app.outdir / 'types.txt').read_text()\n+\n+    assert ('types.sphinx_doc(data)\\n'\n+            '\\n'\n+            '   Does it work.\\n'\n+            '\\n'\n+            '   Parameters:\\n'\n+            '      * **data** (*types.JSONObject*) --\\n'\n+            '         Does it args.\\n'\n+            '\\n'\n+            '   Returns:\\n'\n+            '      Does it work in return.\\n'\n+            '\\n'\n+            '   Return type:\\n'\n+            '      types.JSONObject\\n') == context\n+\n import platform\n import sys\n \n",
  "sphinx-doc__sphinx-8475": "",
  "sphinx-doc__sphinx-8595": "",
  "sphinx-doc__sphinx-8721": "",
  "sphinx-doc__sphinx-9281": "diff --git a/tests/test_util_inspect.py b/tests/test_util_inspect.py\nindex 3c31d3d..ba1b87d 100644\n--- a/tests/test_util_inspect.py\n+++ b/tests/test_util_inspect.py\n@@ -515,8 +515,18 @@ def test_dict_customtype():\n     # Type is unsortable, just check that it does not crash\n     assert \"<CustomType(2)>: 2\" in description\n \n+def test_object_description_enum_in_signature():\n+    import enum\n \n-def test_getslots():\n+    class MyEnum(enum.Enum):\n+        ValueA = 10\n+        ValueB = 20\n+\n+    def ugly_enum_func(e: MyEnum = MyEnum.ValueA) -> None:\n+        pass\n+\n+    assert inspect.object_description(MyEnum.ValueA) == \"MyEnum.ValueA\"\n+    assert inspect.object_description(ugly_enum_func.__defaults__[0]) == \"MyEnum.ValueA\"\n     class Foo:\n         pass\n \n",
  "sphinx-doc__sphinx-9320": "diff --git a/tests/test_quickstart.py b/tests/test_quickstart.py\nindex ff8df08..8351ede 100644\n--- a/tests/test_quickstart.py\n+++ b/tests/test_quickstart.py\n@@ -19,6 +19,23 @@ from sphinx.util.console import coloron, nocolor\n \n warnfile = StringIO()\n \n+def test_exit_on_enter_with_existing_confpy(monkeypatch):\n+    # Mock path.isfile to always return True, simulating the existence of conf.py\n+    def mock_isfile(p):\n+        return True\n+    \n+    monkeypatch.setattr(path, 'isfile', mock_isfile)\n+\n+    # Simulate user input pressing Enter at the prompt\n+    qs.term_input = lambda prompt: ''\n+\n+    # Prepare a dictionary to pass to ask_user\n+    d = {}\n+    \n+    # Test that SystemExit is raised when pressing Enter with existing conf.py\n+    with pytest.raises(SystemExit):\n+        qs.ask_user(d)\n+\n \n def setup_module():\n     nocolor()\n",
  "sphinx-doc__sphinx-9367": "diff --git a/tests/test_pycode_ast.py b/tests/test_pycode_ast.py\nindex a3de258..285ce81 100644\n--- a/tests/test_pycode_ast.py\n+++ b/tests/test_pycode_ast.py\n@@ -54,6 +54,7 @@ from sphinx.pycode import ast\n     (\"- 1\", \"- 1\"),                             # UnaryOp\n     (\"- a\", \"- a\"),                             # USub\n     (\"(1, 2, 3)\", \"(1, 2, 3)\"),                   # Tuple\n+    (\"(1,)\", \"(1,)\"),                             # Tuple (single element)\n     (\"()\", \"()\"),                               # Tuple (empty)\n ])\n def test_unparse(source, expected):\n",
  "sphinx-doc__sphinx-9591": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex 29731ea..db3ba70 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -847,7 +847,59 @@ def test_pyproperty(app):\n     assert domain.objects['Class.prop2'] == ('index', 'Class.prop2', 'property', False)\n \n \n-def test_pydecorator_signature(app):\n+def test_property_type_annotation_cross_reference(app):\n+    text = (\".. py:class:: Point\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: x\\n\"\n+            \"      :type: int\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: y\\n\"\n+            \"      :type: int\\n\"\n+            \"\\n\"\n+            \".. py:class:: Square\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: start\\n\"\n+            \"      :type: Point\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: width\\n\"\n+            \"      :type: int\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: height\\n\"\n+            \"      :type: int\\n\"\n+            \"\\n\"\n+            \"   .. py:property:: end\\n\"\n+            \"      :type: Point\\n\"\n+            \"\\n\"\n+            \".. py:class:: Rectangle\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: start\\n\"\n+            \"      :type: Point\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: width\\n\"\n+            \"      :type: int\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: height\\n\"\n+            \"      :type: int\\n\"\n+            \"\\n\"\n+            \"   .. py:property:: end\\n\"\n+            \"      :type: Point\\n\"\n+    )\n+    domain = app.env.get_domain('py')\n+    doctree = restructuredtext.parse(app, text)\n+\n+    # Validate the end property cross-references Point correctly in Square and Rectangle\n+    assert_node(doctree[10][1][2], ([desc_signature, ([desc_annotation, \"property \"],\n+                                                      [desc_name, \"end\"],\n+                                                      [pending_xref, \"Point\"])],\n+                                    [desc_content, ()]))\n+    assert_node(doctree[21][1][2], ([desc_signature, ([desc_annotation, \"property \"],\n+                                                      [desc_name, \"end\"],\n+                                                      [pending_xref, \"Point\"])],\n+                                    [desc_content, ()]))\n+    assert 'Square.end' in domain.objects\n+    assert domain.objects['Square.end'] == ('index', 'Square.end', 'property', False)\n+    assert 'Rectangle.end' in domain.objects\n+    assert domain.objects['Rectangle.end'] == ('index', 'Rectangle.end', 'property', False)\n     text = \".. py:decorator:: deco\"\n     domain = app.env.get_domain('py')\n     doctree = restructuredtext.parse(app, text)\n",
  "sphinx-doc__sphinx-9698": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex 4731988..ef2c7cc 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -754,9 +754,10 @@ def test_pymethod_options(app):\n     assert 'Class.meth4' in domain.objects\n     assert domain.objects['Class.meth4'] == ('index', 'Class.meth4', 'method', False)\n \n+    # :property:\n     # :property:\n     assert_node(doctree[1][1][8], addnodes.index,\n-                entries=[('single', 'meth5() (Class property)', 'Class.meth5', '', None)])\n+                entries=[('single', 'meth5 (Class property)', 'Class.meth5', '', None)])\n     assert_node(doctree[1][1][9], ([desc_signature, ([desc_annotation, (\"property\", desc_sig_space)],\n                                                      [desc_name, \"meth5\"])],\n                                    [desc_content, ()]))\n@@ -783,8 +784,28 @@ def test_pymethod_options(app):\n     assert 'Class.meth7' in domain.objects\n     assert domain.objects['Class.meth7'] == ('index', 'Class.meth7', 'method', False)\n \n+def test_pymethod_property_no_parens(app):\n+    # This test specifically checks that a property defined using :property: does not have parentheses.\n+    text = (\".. py:class:: Class\\n\"\n+            \"\\n\"\n+            \"   .. py:method:: prop1\\n\"\n+            \"      :property:\\n\"\n+            \"   .. py:property:: prop2\\n\")\n+\n+    domain = app.env.get_domain('py')\n+    doctree = restructuredtext.parse(app, text)\n+\n+    # :property: using py:method\n+    assert_node(doctree[1][1][0], addnodes.index,\n+                entries=[('single', 'prop1 (Class property)', 'Class.prop1', '', None)])\n+    assert 'Class.prop1' in domain.objects\n+    assert domain.objects['Class.prop1'] == ('index', 'Class.prop1', 'method', False)\n \n-def test_pyclassmethod(app):\n+    # py:property directive\n+    assert_node(doctree[1][1][1], addnodes.index,\n+                entries=[('single', 'prop2 (Class property)', 'Class.prop2', '', None)])\n+    assert 'Class.prop2' in domain.objects\n+    assert domain.objects['Class.prop2'] == ('index', 'Class.prop2', 'property', False)\n     text = (\".. py:class:: Class\\n\"\n             \"\\n\"\n             \"   .. py:classmethod:: meth\\n\")\n",
  "sphinx-doc__sphinx-9711": "diff --git a/sphinx/extension.py b/sphinx/extension.py\nindex 6ac780b..9d48f4c 100644\n--- a/sphinx/extension.py\n+++ b/sphinx/extension.py\n@@ -9,6 +9,7 @@\n \"\"\"\n \n from typing import TYPE_CHECKING, Any, Dict\n+from packaging.version import parse as parse_version\n \n from sphinx.config import Config\n from sphinx.errors import VersionRequirementError\n@@ -51,7 +52,7 @@ def verify_needs_extensions(app: \"Sphinx\", config: Config) -> None:\n                               'but it is not loaded.'), extname)\n             continue\n \n-        if extension.version == 'unknown version' or reqversion > extension.version:\n+        if extension.version == 'unknown version' or parse_version(reqversion) > parse_version(extension.version):\n             raise VersionRequirementError(__('This project needs the extension %s at least in '\n                                              'version %s and therefore cannot be built with '\n                                              'the loaded version (%s).') %\n",
  "sympy__sympy-11618": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 399f58e..257b53d 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -236,7 +236,38 @@ def test_Point2D():\n     assert p2.distance(p3) == sqrt(17)/2\n \n \n-def test_issue_9214():\n+def test_issue_11617():\n+    p1 = Point3D(1, 0, 2)\n+    p2 = Point2D(2, 0)\n+\n+    assert p1.distance(p2) == sqrt(5)\n+\n+def test_distance_varied_dimensions():\n+    # Test Point3D to Point3D\n+    p1 = Point3D(1, 2, 3)\n+    p2 = Point3D(4, 6, 8)\n+    assert p1.distance(p2) == sqrt(3**2 + 4**2 + 5**2)\n+\n+    # Test Point2D to Point3D\n+    p3 = Point2D(1, 2)\n+    p4 = Point3D(1, 2, 3)\n+    assert p3.distance(p4) == sqrt(3**2)\n+\n+    # Test Point3D to Point2D\n+    p5 = Point3D(4, 0, 0)\n+    p6 = Point2D(0, 3)\n+    assert p5.distance(p6) == sqrt(5**2 + 3**2)\n+\n+    # Test Point2D to Point2D\n+    p7 = Point2D(1, 1)\n+    p8 = Point2D(4, 5)\n+    assert p7.distance(p8) == sqrt(3**2 + 4**2)\n+\n+    # Ensure symmetric property of distance\n+    p9 = Point3D(1, 1, 1)\n+    p10 = Point2D(4, 5)\n+    assert p9.distance(p10) == p10.distance(p9)\n+    assert p9.distance(p10) == sqrt(3**2 + 4**2 + 1**2)\n     p1 = Point3D(4, -2, 6)\n     p2 = Point3D(1, 2, 3)\n     p3 = Point3D(7, 2, 3)\n",
  "sympy__sympy-12096": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex 386dc7c..245e2bc 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -741,6 +741,9 @@ def test_special_printers():\n     assert isinstance(func1(), mpi)\n     assert isinstance(func2(), mpi)\n \n+from sympy.utilities.lambdify import implemented_function\n+from sympy import Float\n+\n def test_true_false():\n     # We want exact is comparison here, not just ==\n     assert lambdify([], true)() is True\n",
  "sympy__sympy-12419": "",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..2505909 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -330,6 +330,14 @@ def test_args():\n     assert p._array_form == [3, 2, 0, 1, 5, 4]\n     p = Permutation((0, 3, 1, 2))\n     assert p._cyclic_form is None\n+\n+    # Test cases for non-disjoint cycles handling\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n+    assert Permutation([[0, 1, 2], [0, 2, 3]]) == Permutation([0, 2, 1, 3])\n+    assert Permutation([[2, 3], [1, 2]]) == Permutation([0, 3, 1, 2])\n+    assert Permutation([[1, 2], [1, 3, 4], [2, 5]]) == Permutation([0, 3, 5, 4, 1, 2])\n+    assert Permutation([[0, 1], [1, 2], [2, 3]]) == Permutation([0, 2, 3, 1])\n+    assert Permutation([[0, 2], [0, 1], [1, 3]]) == Permutation([0, 3, 1, 2])\n     assert p._array_form == [0, 3, 1, 2]\n     assert Permutation([0]) == Permutation((0, ))\n     assert Permutation([[0], [1]]) == Permutation(((0, ), (1, ))) == \\\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..a9b01e2 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -490,6 +490,21 @@ def test_errors():\n         lambda: SparseMatrix(1, 2, [1, 2]) + SparseMatrix(2, 1, [2, 1]))\n \n \n+def test_hstack_vstack_empty_matrices():\n+    # Test hstack with 0 row matrices\n+    M1 = SparseMatrix.zeros(0, 0)\n+    M2 = SparseMatrix.zeros(0, 1)\n+    M3 = SparseMatrix.zeros(0, 2)\n+    M4 = SparseMatrix.zeros(0, 3)\n+    assert SparseMatrix.hstack(M1, M2, M3, M4) == SparseMatrix(0, 6, [])\n+    \n+    # Test vstack with 0 column matrices\n+    M1 = SparseMatrix.zeros(1, 0)\n+    M2 = SparseMatrix.zeros(1, 1)\n+    M3 = SparseMatrix.zeros(1, 2)\n+    M4 = SparseMatrix.zeros(1, 3)\n+    assert SparseMatrix.hstack(M1, M2, M3, M4) == SparseMatrix(1, 6, [])\n+\n def test_len():\n     assert not SparseMatrix()\n     assert SparseMatrix() == SparseMatrix([])\n",
  "sympy__sympy-13372": "",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..8684928 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -273,7 +273,20 @@ def test_coth():\n     assert coth(k*pi*I) == -cot(k*pi)*I\n \n \n-def test_coth_series():\n+def test_coth_issue_substitution():\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+\n+    # Test various integer values that previously caused errors\n+    values_to_test = [2, 3, 5, 6, 8, 9, 11, 12, 13, 15, 18]\n+    for val in values_to_test:\n+        result = e.subs(x, val)\n+        assert result is not None  # Ensure no NameError and valid result\n+\n+    # Alternatively, if the expected output is known, it can be asserted specifically.\n+    # Here we assume the symbolic result should be validated depending on the function's logic,\n+    # For instance, check for zoo or handled result.\n+    # assert e.subs(x, 2) == expected_value_for_2\n     x = Symbol('x')\n     assert coth(x).series(x, 0, 8) == \\\n         1/x + x/3 - x**3/45 + 2*x**5/945 - x**7/4725 + O(x**8)\n",
  "sympy__sympy-13615": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 6d534c0..5f20737 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -165,7 +165,24 @@ def test_difference():\n     assert -1 in S.Reals - S.Naturals\n \n \n+from sympy import Interval, FiniteSet, Complement, Symbol, S\n+\n def test_Complement():\n+    # Test a case of mixed symbols and numbers\n+    from sympy import x, y\n+    assert Complement(FiniteSet(x, y, 2), Interval(-10, 10)) == \\\n+           Complement(FiniteSet(x, y), Interval(-10, 10))\n+\n+    # Further varied cases with mixed content and different intervals\n+    assert Complement(FiniteSet(x, 5, y, 10), Interval(-1, 7)) == \\\n+           Complement(FiniteSet(x, y, 10), Interval(-1, 7))\n+    \n+    assert Complement(FiniteSet(x, -5, y, 3), Interval(-10, 10)) == \\\n+           FiniteSet(x, y)\n+\n+    # A case where symbols are completely outside of the numeric interval range\n+    assert Complement(FiniteSet(x, y, 20), Interval(-10, 10)) == \\\n+           FiniteSet(x, y, 20)\n     assert Complement(Interval(1, 3), Interval(1, 2)) == Interval(2, 3, True)\n     assert Complement(FiniteSet(1, 3, 4), FiniteSet(3, 4)) == FiniteSet(1)\n     assert Complement(Union(Interval(0, 2),\n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..9ab2f7e 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -200,6 +200,35 @@ def test_col_insert():\n         l = [0, 0, 0]\n         l.insert(i, 4)\n         assert flatten(zeros_Shaping(3).col_insert(i, c4).row(0).tolist()) == l\n+def test_issue_13643_col_insert():\n+    # Given a 6x6 identity matrix\n+    M = sm.eye(6)\n+\n+    # A 6x2 matrix of twos\n+    V = 2 * sm.ones(6, 2)\n+\n+    # Insert V into M at column index 3\n+    result = M.col_insert(3, V)\n+\n+    # The expected matrix after inserting\n+    expected = sm.Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+\n+    assert result == expected\n+\n+    # Additional checks to ensure the column insertion doesn't affect other parts\n+    zeros_matrix = sm.zeros(3)\n+    column = sm.Matrix([3, 3, 3])\n+    for i in range(-4, 5):\n+        expected = [0, 0, 0]\n+        expected.insert(i, 3)\n+        assert flatten(zeros_matrix.col_insert(i, column).row(0).tolist()) == expected\n \n def test_extract():\n     m = ShapingOnlyMatrix(4, 3, lambda i, j: i*3 + j)\n",
  "sympy__sympy-13757": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex a463b22..3e4f981 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -667,6 +667,16 @@ def test_Poly_mul():\n     assert Poly(0, x) * Poly(0, x) == Poly(0, x)\n \n     assert Poly(2, x).mul(Poly(4, x)) == Poly(8, x)\n+    assert Poly(x) * x == Poly(x**2, x, domain='ZZ')\n+    assert x * Poly(x) == Poly(x**2, x, domain='ZZ')\n+    assert -2 * Poly(x) == Poly(-2*x, x, domain='ZZ')\n+    assert S(-2) * Poly(x) == Poly(-2*x, x, domain='ZZ')\n+    assert Poly(x) * S(-2) == Poly(-2*x, x, domain='ZZ')\n+    # Adding additional edge cases\n+    y = Symbol('y')\n+    assert Poly(x) * y == Poly(x*y, x, domain='ZZ[y]')\n+    assert y * Poly(x) == y * Poly(x, x, domain='ZZ')\n+    assert Poly(x) * (y + 1) == Poly(x*y + x, x, domain='ZZ[y]')\n     assert Poly(2, x, y) * Poly(4, x) == Poly(8, x, y)\n     assert Poly(4, x).mul(Poly(2, x, y)) == Poly(8, x, y)\n     assert Poly(4, x, y) * Poly(2, x, y) == Poly(8, x, y)\n@@ -678,6 +688,9 @@ def test_Poly_mul():\n     assert 2 * Poly(x, x) == Poly(2*x, x)\n \n \n+from sympy import Poly, Symbol, S\n+from sympy.abc import x  # You can also import x as needed in sympy modules\n+\n def test_Poly_sqr():\n     assert Poly(x*y, x, y).sqr() == Poly(x**2*y**2, x, y)\n \n",
  "sympy__sympy-13798": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex b1f9614..9ec5394 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -64,6 +64,18 @@ def test_latex_basic():\n     assert latex(2*x*y) == \"2 x y\"\n     assert latex(2*x*y, mul_symbol='dot') == r\"2 \\cdot x \\cdot y\"\n \n+    assert latex(3*x**2*y, mul_symbol='\\\\,') == r\"3\\\\,x^{2}\\\\,y\"\n+    assert latex(1.5*3**x, mul_symbol='\\\\,') == r\"1.5 \\\\, 3^{x}\"\n+\n+    # Additional test cases to check mul_symbol customization\n+    assert latex(2*x*y, mul_symbol=\"times\") == r\"2 \\times x \\times y\"\n+    assert latex(x*y*z, mul_symbol=\"ldot\") == r\"x \\,.\\, y \\,.\\, z\"\n+    assert latex(3*x**2*y, mul_symbol='\\\\;') == r\"3\\\\;x^{2}\\\\;y\"  # Custom separator\n+    assert latex(x**2*y**3, mul_symbol=None) == r\"x^{2} y^{3}\"    # Default behavior/no mul_symbol\n+    assert latex(-x*y/2, mul_symbol='\\\\;') == r\"-x\\\\;y / 2\"       # Negative numbers, frac\n+    assert latex(x*pi*y, mul_symbol='\\\\,') == r\"x\\\\,\\pi\\\\,y\"      # Symbolic constants\n+    assert latex(Integral(x*y, x), mul_symbol='\\\\,') == r\"\\int x\\\\,y\\\\, dx\"  # With integrals\n+    \n     assert latex(1/x) == r\"\\frac{1}{x}\"\n     assert latex(1/x, fold_short_frac=True) == \"1 / x\"\n     assert latex(-S(3)/2) == r\"- \\frac{3}{2}\"\n",
  "sympy__sympy-13877": "diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py\nindex 2018055..9837647 100644\n--- a/sympy/matrices/tests/test_matrices.py\n+++ b/sympy/matrices/tests/test_matrices.py\n@@ -313,8 +313,22 @@ def test_as_mutable():\n     assert zeros(0, 3).as_immutable() == ImmutableMatrix(zeros(0, 3))\n     assert zeros(3, 0).as_immutable() == ImmutableMatrix(zeros(3, 0))\n \n+from sympy import symbols, Matrix\n \n def test_determinant():\n+    # issue 13835: Test for symbolic determinant issue\n+    a = symbols('a')\n+    f = lambda n: Matrix([[i + a*j for i in range(n)] for j in range(n)]).det()\n+\n+    # Check if the determinant is as expected for n = 1, 2, 3, 4, 5, 6\n+    assert f(1) == 0\n+    assert f(2) == -a\n+    # f(3) should not raise an exception\n+    f3_value = f(3) \n+    # f(4), f(5), f(6) should not raise exceptions or result in nan\n+    assert f(4) == 0\n+    assert f(5) == 0\n+    assert f(6) == 0\n \n     for M in [Matrix(), Matrix([[1]])]:\n         assert (\n",
  "sympy__sympy-13878": "",
  "sympy__sympy-13974": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bd3e825..320a047 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -38,6 +38,29 @@ def test_tensor_product_expand():\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n \n+from sympy import symbols\n+from sympy.physics.quantum import TensorProduct as TP\n+from sympy.physics.quantum import tensor_product_simp as tps\n+from sympy.physics.paulialgebra import Pauli\n+\n+A, B, C, D, a = symbols('A,B,C,D,a', commutative=False)\n+\n+def test_tensor_product_simp_issues():\n+    # Test cases based on the issue description\n+    t1 = TP(1, 1) * TP(1, 1)\n+    assert tps(t1) == TP(1, 1)\n+\n+    t2 = TP(1, Pauli(3)) * TP(1, Pauli(3))\n+    assert tps(t2) == TP(1, 1)\n+\n+    assert tps(TP(1, 1) * TP(1, a)).subs(a, 1) == TP(1, 1)\n+    assert tps(TP(1, Pauli(3)) * TP(1, a)).subs(a, Pauli(3)) == TP(1, 1)\n+\n+    # Original asserted scenario cases\n+    assert tps(TP(A, B)**2) == TP(A**2, B**2)\n+    assert tps(TP(A, B)**3) == TP(A**3, B**3)\n+    assert tps(TP(A, B) - TP(C, D)**3) == TP(A, B) - TP(C**3, D**3)\n+\n def test_tensor_product_commutator():\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n         TP(A*B, C) - TP(B*A, C)\n",
  "sympy__sympy-14531": "diff --git a/sympy/printing/tests/test_python.py b/sympy/printing/tests/test_python.py\nindex 73fc070..fa81e2f 100644\n--- a/sympy/printing/tests/test_python.py\n+++ b/sympy/printing/tests/test_python.py\n@@ -78,8 +78,20 @@ def test_python_keyword_function_name_escaping():\n     assert python(\n         5*Function(\"for\")(8)) == \"for_ = Function('for')\\ne = 5*for_(8)\"\n \n-\n-def test_python_relational():\n+def test_issue_behavior():\n+    x = Symbol(\"x\")\n+    y = Symbol(\"y\")\n+\n+    # Test StrPrinter settings with sstr and sympy_integers=True\n+    assert sstr(Eq(x, Rational(1, 2)), sympy_integers=True) == \"Eq(x, S(1)/2)\"\n+    assert sstr(Limit(x, x, Rational(1, 2)), sympy_integers=True) == \"Limit(x, x, S(1)/2)\"\n+\n+    # Test python code generation with Eq\n+    assert python(Eq(x, y)) == \"x = Symbol('x')\\ny = Symbol('y')\\ne = Eq(x, y)\"\n+    assert python(Ne(x/(y + 1), y**2)) in [\n+        \"x = Symbol('x')\\ny = Symbol('y')\\ne = Ne(x/(1 + y), y**2)\",\n+        \"x = Symbol('x')\\ny = Symbol('y')\\ne = Ne(x/(y + 1), y**2)\"\n+    ]\n     assert python(Eq(x, y)) == \"e = Eq(x, y)\"\n     assert python(Ge(x, y)) == \"x = Symbol('x')\\ny = Symbol('y')\\ne = x >= y\"\n     assert python(Le(x, y)) == \"x = Symbol('x')\\ny = Symbol('y')\\ne = x <= y\"\n",
  "sympy__sympy-14711": "diff --git a/sympy/physics/vector/tests/test_vector.py b/sympy/physics/vector/tests/test_vector.py\nindex de6a8ff..ba18fc6 100644\n--- a/sympy/physics/vector/tests/test_vector.py\n+++ b/sympy/physics/vector/tests/test_vector.py\n@@ -3,12 +3,17 @@ from sympy.physics.vector import ReferenceFrame, Vector, dynamicsymbols, dot\n from sympy.abc import x, y, z\n from sympy.utilities.pytest import raises\n \n-\n-Vector.simp = True\n+from sympy.physics.vector import ReferenceFrame, Vector\n A = ReferenceFrame('A')\n \n \n-def test_Vector():\n+def test_vector_addition_with_zero():\n+    N = ReferenceFrame('N')\n+    # Test the vector addition with zero multiplication\n+    assert sum([N.x, 0 * N.x]) == N.x\n+    # Test directly adding zero to a vector\n+    assert N.x + 0 * N.x == N.x\n+    assert N.x + 0 == N.x\n     assert A.x != A.y\n     assert A.y != A.z\n     assert A.z != A.x\n",
  "sympy__sympy-14976": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..d064df6 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1,3 +1,4 @@\n+\n from distutils.version import LooseVersion as V\n from itertools import product\n import math\n@@ -132,6 +133,22 @@ def test_math_lambda():\n     raises(TypeError, lambda: f(x))\n            # if this succeeds, it can't be a python math function\n \n+def test_mpmath_lambdify_rational():\n+    from sympy.functions.special.gamma_functions import rf\n+    x = symbols('x')\n+    eqn = Eq(rf(18, x), 77 + Rational(1, 3))\n+    f = lambdify(x, eqn.lhs - eqn.rhs, 'mpmath')\n+    \n+    # Ensure that the Rational(1, 3) is turned into a high precision mpmath value\n+    assert \"mpmath.mpf\" in inspect.getsource(f)\n+\n+    # Using nsolve to test the precision\n+    x0 = nsolve(eqn, Float('1.5', 64), prec=64)\n+    expected_result =  77 + Rational(1, 3)\n+    # Evaluate using high precision\n+    result = rf(18, x0).evalf(64)\n+    assert mpmath.almosteq(result, expected_result.evalf(64), eps=mpmath.mp.eps)\n+\n \n @conserve_mpmath_dps\n def test_mpmath_lambda():\n",
  "sympy__sympy-15017": "diff --git a/sympy/tensor/array/tests/test_immutable_ndim_array.py b/sympy/tensor/array/tests/test_immutable_ndim_array.py\nindex 18941a7..33bf58a 100644\n--- a/sympy/tensor/array/tests/test_immutable_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_immutable_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from copy import copy\n \n from sympy.tensor.array.dense_ndim_array import ImmutableDenseNDimArray\n@@ -73,6 +74,13 @@ def test_ndim_array_initiation():\n \n     from sympy.abc import x\n     rank_zero_array = ImmutableDenseNDimArray(x)\n+    # Test to verify that the length of a rank-0 array is indeed 1\n+    assert len(rank_zero_array) == 1\n+    # Check with a rank-0 array with an integer\n+    rank_zero_array_int = ImmutableDenseNDimArray(3)\n+    assert len(rank_zero_array_int) == 1\n+    assert rank_zero_array_int[()] == 3\n+    # Ensure that an attempt to access using an index raises an error\n     assert len(rank_zero_array) == 0\n     assert rank_zero_array.shape == ()\n     assert rank_zero_array.rank() == 0\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..6d11147 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n@@ -23,6 +24,24 @@ def test_Rational():\n     assert mcode(x + Rational(3, 7)) == \"x + 3/7\"\n     assert mcode(Rational(3, 7)*x) == \"(3/7)*x\"\n \n+def test_Max_Min():\n+    # Original test verifying the Max and Min together\n+    assert mcode(Max(x, y, z) * Min(y, z)) == \"Max[x, y, z]*Min[y, z]\"\n+\n+    # New test case specifically for the issue\n+    # Verify Max with a single variable argument and a constant\n+    assert mcode(Max(x, 2)) == \"Max[x, 2]\"\n+    # Verify Max with variables and constants out of order\n+    assert mcode(Max(2, x)) == \"Max[x, 2]\"  # since order shouldn't matter in Max for Mathematica syntax\n+\n+    # Verifying Max and Min with only variables\n+    assert mcode(Max(x, y)) == \"Max[x, y]\"\n+    assert mcode(Min(x, y)) == \"Min[x, y]\"\n+    \n+    # Verifying Max and Min with constants\n+    assert mcode(Max(3, 5)) == \"Max[3, 5]\"\n+    assert mcode(Min(1, 2)) == \"Min[1, 2]\"\n+\n \n def test_Function():\n     assert mcode(f(x, y, z)) == \"f[x, y, z]\"\n",
  "sympy__sympy-15349": "diff --git a/sympy/algebras/tests/test_quaternion.py b/sympy/algebras/tests/test_quaternion.py\nindex c486cc1..defd52c 100644\n--- a/sympy/algebras/tests/test_quaternion.py\n+++ b/sympy/algebras/tests/test_quaternion.py\n@@ -112,6 +112,26 @@ def test_quaternion_conversions():\n                                                [sin(theta),  cos(theta), 0],\n                                                [0,           0,          1]])\n \n+def test_quaternion_to_rotation_matrix_issue1593():\n+    \"\"\"Test for the issue #1593 regarding the sign mistake in rotation matrix.\"\"\"\n+\n+    from sympy import symbols, cos, sin, trigsimp\n+    from sympy.algebras.quaternion import Quaternion\n+\n+    # Recreate the scenario described in the issue\n+    x = symbols('x')\n+    q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+    \n+    # Expected corrected rotation matrix where one sin(x) should be negative\n+    expected_matrix = Matrix([\n+        [1,      0,      0],\n+        [0, cos(x), -sin(x)],\n+        [0, sin(x),  cos(x)]\n+    ])\n+\n+    # Verify that the function produces the expected corrected matrix\n+    assert trigsimp(q.to_rotation_matrix()) == expected_matrix\n+\n     assert q2.to_axis_angle() == ((0, 0, sin(theta/2)/Abs(sin(theta/2))),\n                                    2*acos(cos(theta/2)))\n \n@@ -119,4 +139,4 @@ def test_quaternion_conversions():\n                [cos(theta), -sin(theta), 0, sin(theta) - cos(theta) + 1],\n                [sin(theta),  cos(theta), 0, -sin(theta) - cos(theta) + 1],\n                [0,           0,          1,  0],\n-               [0,           0,          0,  1]])\n+               [0,           0,          0,  1]])\n",
  "sympy__sympy-15599": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex d8e8fc4..41bbe04 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1624,6 +1624,17 @@ def test_Mod():\n     i = Symbol('i', integer=True)\n     assert (3*i*x) % (2*i*y) == i*Mod(3*x, 2*y)\n     assert Mod(4*i, 4) == 0\n+    # issue 15493\n+    i, j = symbols('i j', integer=True, positive=True)\n+    assert Mod(3*i, 2) == Mod(i, 2)\n+    assert Mod(8*i/j, 4) == 4*Mod(2*i/j, 1)\n+    # Additional test cases to ensure comprehensive fixes\n+    assert Mod(6*i, 2) == 0  # Because 6*i is always even\n+    assert Mod(3*j, 2) == Mod(j, 2)  # Similar pattern with different variable\n+    assert Mod(9*i, 3) == 0  # Multiple of 3 should reduce completely\n+    assert Mod(i**2, 2).simplify() in (0, 1)  # Squared integer property\n+    assert Mod(2*i + 1, 2) == 1  # Odd integer structure\n+    assert Mod(i + 0.5, 1) == 0.5  # Non-integer should result in fractional part\n \n     # issue 8677\n     n = Symbol('n', integer=True, positive=True)\n",
  "sympy__sympy-15809": "",
  "sympy__sympy-15875": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 58ab306..8ff5876 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1987,10 +1987,37 @@ def test_Add_is_zero():\n     assert (x + y).is_zero\n \n \n-def test_issue_14392():\n+def test_is_zero_complex():\n+    from sympy import I, simplify, S\n+    \n+    # Original test case from Issue 15873\n+    e = -2*I + (1 + I)**2\n+    assert e.is_zero is None\n+    \n+    # Test with explicit simplification\n+    assert simplify(e).is_zero is True\n+\n+    # Additional test case where is_zero should be None\n+    e2 = 2*I + (1 - I)**2\n+    assert e2.is_zero is None\n+\n+    # Simplifying should change is_zero to True\n+    assert simplify(e2).is_zero is True\n+\n+    # Test with a scenario proven to be non-zero\n+    e3 = 3 + 4*I\n+    assert e3.is_zero is False\n+\n+    # Test with zero real component but non-zero imaginary component\n+    e4 = 0 + 5*I\n+    assert e4.is_zero is False\n+\n+    # Test with zero imaginary component but non-zero real component\n+    e5 = 5 + 0*I\n+    assert e5.is_zero is False\n     assert (sin(zoo)**2).as_real_imag() == (nan, nan)\n \n def test_divmod():\n     assert divmod(x, y) == (x//y, x % y)\n     assert divmod(x, 3) == (x//3, x % 3)\n-    assert divmod(3, x) == (3//x, 3 % x)\n+    assert divmod(3, x) == (3//x, 3 % x)\n",
  "sympy__sympy-16450": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex aba4711..9e710c2 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -512,7 +512,38 @@ def test_posify():\n         'Sum(_x**(-n), (n, 1, 3))'\n \n \n-def test_issue_4194():\n+def test_issue_16438():\n+    from sympy import Symbol, posify\n+\n+    # Test with a symbol that has the 'finite' assumption\n+    k = Symbol('k', finite=True)\n+    eq, rep = posify(k)\n+\n+    # Verify the assumptions after posify on the symbol\n+    assert eq.assumptions0['finite'] is True\n+    assert eq.assumptions0['infinite'] is False\n+\n+    # Ensure no loss of additional assumptions such as integer, rational, etc.\n+    a = Symbol('a', finite=True, integer=True, rational=True, positive=True)\n+    eq, rep = posify(a)\n+    assert eq.assumptions0['finite'] is True\n+    assert eq.assumptions0['integer'] is True\n+    assert eq.assumptions0['rational'] is True\n+    assert eq.assumptions0['positive'] is True\n+    assert eq.assumptions0['negative'] is False\n+    assert eq.assumptions0['nonpositive'] is False\n+\n+    # Test with symbol without finite assumption\n+    b = Symbol('b', integer=True, rational=True, positive=True)\n+    eq, rep = posify(b)\n+    assert 'finite' not in eq.assumptions0\n+    assert 'infinite' not in eq.assumptions0\n+\n+    # Ensure posify doesn't mistakenly add finite/infinite to symbols without it\n+    c = Symbol('c', integer=True, irrational=False)\n+    eq, rep = posify(c)\n+    assert 'finite' not in eq.assumptions0\n+    assert 'infinite' not in eq.assumptions0\n     # simplify should call cancel\n     from sympy.abc import x, y\n     f = Function('f')\n",
  "sympy__sympy-16766": "diff --git a/sympy/printing/tests/test_pycode.py b/sympy/printing/tests/test_pycode.py\nindex 51a287f..5a920bc 100644\n--- a/sympy/printing/tests/test_pycode.py\n+++ b/sympy/printing/tests/test_pycode.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n from __future__ import absolute_import\n \n@@ -12,6 +13,7 @@ from sympy.printing.pycode import (\n     MpmathPrinter, NumPyPrinter, PythonCodePrinter, pycode, SciPyPrinter\n )\n from sympy.utilities.pytest import raises\n+from sympy.tensor import IndexedBase\n \n x, y, z = symbols('x y z')\n \n@@ -35,6 +37,13 @@ def test_PythonCodePrinter():\n                                                         ' (3) if (x > 0) else None)'\n     assert prntr.doprint(sign(x)) == '(0.0 if x == 0 else math.copysign(1, x))'\n \n+    # Test for Indexed support\n+    p = IndexedBase(\"p\")\n+    assert prntr.doprint(p[0]) == 'p[0]'\n+    assert prntr.doprint(p[x]) == 'p[x]'\n+    assert prntr.doprint(p[y, z]) == 'p[y, z]'\n+    assert prntr.doprint(p[0, 1, 2]) == 'p[0, 1, 2]'\n+\n \n def test_MpmathPrinter():\n     p = MpmathPrinter()\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_autowrap.py b/sympy/utilities/tests/test_autowrap.py\nindex 23fddca..784bd87 100644\n--- a/sympy/utilities/tests/test_autowrap.py\n+++ b/sympy/utilities/tests/test_autowrap.py\n@@ -21,7 +21,19 @@ def get_string(dump_fn, routines, prefix=\"file\", **kwargs):\n        this wrapper returns the contents of that stream as a string. This\n        auxiliary function is used by many tests below.\n \n-       The header and the empty lines are not generator to facilitate the\n+from sympy.utilities.autowrap import autowrap\n+from sympy import MatrixSymbol\n+import numpy as np\n+\n+def test_cython_wrapper_unused_array_arg():\n+    # Test that an unused array argument does not cause a compilation failure\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0  # The expression does not use x\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    \n+    # Call the function, and it should return 1.0 irrespective of x\n+    result = f(np.array([[1.0], [2.0]]))\n+    assert result == 1.0, f\"Expected 1.0, got {result}\"\n        testing of the output.\n     \"\"\"\n     output = StringIO()\n",
  "sympy__sympy-16886": "diff --git a/sympy/crypto/tests/test_crypto.py b/sympy/crypto/tests/test_crypto.py\nindex 8b39574..1baa2d8 100644\n--- a/sympy/crypto/tests/test_crypto.py\n+++ b/sympy/crypto/tests/test_crypto.py\n@@ -248,6 +248,13 @@ def test_encode_morse():\n     assert encode_morse(' ', sep='``') == '````'\n     assert encode_morse('!@#$%^&*()_+') == '-.-.--|.--.-.|...-..-|-.--.|-.--.-|..--.-|.-.-.'\n \n+    # Adding test case specifically for Morse encoding of '1'\n+    assert encode_morse('1') == '.----'\n+    \n+    # Existing tests for sequences containing '1'\n+    assert encode_morse('12345') == '.----|..---|...--|....-|.....'\n+    assert encode_morse('67890') == '-....|--...|---..|----.|-----'\n+\n \n def test_decode_morse():\n     assert decode_morse('-.-|.|-.--') == 'KEY'\n",
  "sympy__sympy-17139": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex daf5f69..4fd6345 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -799,6 +799,30 @@ def test_nc_simplify():\n     expr = b**-1*(a**-1*b**-1 - a**-1*c*b**-1)**-1*a**-1\n     assert nc_simplify(expr) == (1-c)**-1\n     # commutative expressions should be returned without an error\n+\n+def test_issue_17137():\n+    # These test cases ensure that the simplify function can handle complex exponents without raising errors\n+    from sympy import simplify, cos, Symbol, I\n+    x = Symbol('x')\n+    \n+    # Original test cases provided in the test patch\n+    assert simplify(cos(x)**I) == cos(x)**I\n+    assert simplify(cos(x)**(2 + 3*I)) == cos(x)**(2 + 3*I)\n+    \n+    # Additional test cases\n+    # Check for a complex exponent with a negative real part\n+    assert simplify(cos(x)**(-1 + I)) == cos(x)**(-1 + I)\n+    \n+    # Check for more complicated expressions involving complex exponents\n+    assert simplify(cos(x)**(I/2)) == cos(x)**(I/2)\n+    assert simplify(cos(x)**(2*I + 3)) == cos(x)**(2*I + 3)\n+\n+    # Check with a zero exponent which should result in 1 (cos(x)**0 = 1)\n+    assert simplify(cos(x)**0) == 1\n+\n+    # Ensure handling of purely imaginary exponents\n+    assert simplify(cos(x)**(5*I)) == cos(x)**(5*I)\n+    assert simplify(cos(x)**(-5*I)) == cos(x)**(-5*I)\n     assert nc_simplify(2*x**2) == 2*x**2\n \n def test_issue_15965():\n@@ -814,4 +838,4 @@ def test_issue_15965():\n def test_issue_7971():\n     z = Integral(x, (x, 1, 1))\n     assert z != 0\n-    assert simplify(z) is S.Zero\n+    assert simplify(z) is S.Zero\n",
  "sympy__sympy-17318": "diff --git a/sympy/simplify/tests/test_sqrtdenest.py b/sympy/simplify/tests/test_sqrtdenest.py\nindex 7a6c0e1..2f63cee 100644\n--- a/sympy/simplify/tests/test_sqrtdenest.py\n+++ b/sympy/simplify/tests/test_sqrtdenest.py\n@@ -1,6 +1,9 @@\n+\n from sympy import sqrt, root, S, Symbol, sqrtdenest, Integral, cos\n from sympy.simplify.sqrtdenest import _subsets as subsets\n from sympy.utilities.pytest import slow\n+from sympy.simplify.sqrtdenest import _sqrt_match\n+from sympy.core.expr import unchanged\n \n r2, r3, r5, r6, r7, r10, r15, r29 = [sqrt(x) for x in [2, 3, 5, 6, 7, 10,\n                                           15, 29]]\n@@ -175,8 +178,15 @@ def test_subsets():\n         [0, 1, 1, 0], [1, 1, 1, 0], [0, 0, 0, 1], [1, 0, 0, 1], [0, 1, 0, 1],\n         [1, 1, 0, 1], [0, 0, 1, 1], [1, 0, 1, 1], [0, 1, 1, 1], [1, 1, 1, 1]]\n \n-\n-def test_issue_5653():\n+def test_issue_12420():\n+    I = S.ImaginaryUnit\n+    # Testing the match function\n+    assert _sqrt_match(4 + I) == []\n+    # Confirming that the expression is unchanged if it can't be denested\n+    assert sqrtdenest((3 - sqrt(2)*sqrt(4 + 3*I) + 3*I)/2) == 3/2 - sqrt(2)*sqrt(4 + 3*I)/2 + 3*I/2\n+    # Test another similar expression\n+    e = 3 - sqrt(2)*sqrt(4 + I) + 3*I\n+    assert sqrtdenest(e) == e\n     assert sqrtdenest(\n         sqrt(2 + sqrt(2 + sqrt(2)))) == sqrt(2 + sqrt(2 + sqrt(2)))\n \n",
  "sympy__sympy-17655": "",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..08dc79b 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -547,9 +547,15 @@ def test_diophantine():\n     assert diophantine(x**2 + y**2 +3*x- 5, permute=True) == \\\n         set([(-1, 1), (-4, -1), (1, -1), (1, 1), (-4, 1), (-1, -1), (4, 1), (4, -1)])\n \n-    # issue 18122\n-    assert check_solutions(x**2-y)\n-    assert check_solutions(y**2-x)\n+    # Test for the issue: diophantine gives incomplete results depending on syms order with permute=True\n+    # These test cases verify that the solution is complete and the same irrespective of symbol order\n+    from sympy.abc import m, n\n+\n+    eq = n**4 + m**4 - 2**4 - 3**4\n+    expected_solutions = set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+\n+    assert diophantine(eq, syms=(m, n), permute=True) == expected_solutions\n+    assert diophantine(eq, syms=(n, m), permute=True) == expected_solutions\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n     assert diophantine((y**2-x), t) == set([(t**2, -t)])\n \n",
  "sympy__sympy-18763": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex ba93bdc..2a97f82 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -672,6 +672,19 @@ def test_latex_derivatives():\n         r'\\frac{d^{\\max\\left(n_{1}, n_{2}\\right)}}{d x^{\\max\\left(n_{1}, n_{2}\\right)}} f{\\left(x \\right)}'\n \n \n+def test_latex_subs_parentheses():\n+    from sympy import Subs\n+    from sympy.abc import x, y\n+\n+    # Original test case to verify issue\n+    assert latex(3*Subs(-x+y, (x,), (1,))) == r'3 \\left. \\left(- x + y\\right) \\right|_{\\substack{ x=1 }}'\n+\n+    # Additional test cases for more thorough check\n+    assert latex(Subs(x + y, (x,), (1,))) == r'\\left. \\left(x + y\\right) \\right|_{\\substack{ x=1 }}'\n+    assert latex(2*Subs(x - y, (x,), (1,))) == r'2 \\left. \\left(x - y\\right) \\right|_{\\substack{ x=1 }}'\n+    assert latex(Subs(x*y + y, (x,), (1,))) == r'\\left. \\left(x y + y\\right) \\right|_{\\substack{ x=1 }}'\n+\n+\n def test_latex_subs():\n     assert latex(Subs(x*y, (\n         x, y), (1, 2))) == r'\\left. x y \\right|_{\\substack{ x=1\\\\ y=2 }}'\n",
  "sympy__sympy-19346": "",
  "sympy__sympy-19495": "diff --git a/sympy/sets/tests/test_conditionset.py b/sympy/sets/tests/test_conditionset.py\nindex 68ee5d6..fbcecfa 100644\n--- a/sympy/sets/tests/test_conditionset.py\n+++ b/sympy/sets/tests/test_conditionset.py\n@@ -1,3 +1,4 @@\n+\n from sympy.sets import (ConditionSet, Intersection, FiniteSet,\n     EmptySet, Union, Contains)\n from sympy import (Symbol, Eq, S, Abs, sin, pi, Interval,\n@@ -129,6 +130,22 @@ def test_subs_CondSet():\n     assert ConditionSet(f(x), f(x) < 1, {w, z}\n         ).subs(f(x), y) == ConditionSet(y, y < 1, {w, z})\n \n+    # Test case for issue with ConditionSet and ImageSet substitution\n+    y = Symbol('y')\n+    k = Symbol('k')\n+    img1 = imageset(Lambda(k, 2*k*pi + asin(y)), S.Integers)\n+    img2 = imageset(Lambda(k, 2*k*pi + asin(S.One/3)), S.Integers)\n+    cond_set = ConditionSet(x, Contains(y, Interval(-1, 1)), img1)\n+    # Check the substitution in the ConditionSet with ImageSet\n+    assert cond_set.subs(y, S.One/3).dummy_eq(img2)\n+    \n+    # Check xreplace behaves similarly\n+    assert cond_set.xreplace({y: S.One/3}) == \\\n+        imageset(Lambda(k, 2*k*pi + asin(S.One/3)), S.Integers)\n+\n+    # Ensure direct ImageSet substitution works as expected\n+    assert img1.subs(y, S.One/3) == img2\n+\n \n def test_subs_CondSet_tebr():\n     with warns_deprecated_sympy():\n",
  "sympy__sympy-19637": "diff --git a/sympy/core/tests/test_sympify.py b/sympy/core/tests/test_sympify.py\nindex 4d20fb4..2267e9e 100644\n--- a/sympy/core/tests/test_sympify.py\n+++ b/sympy/core/tests/test_sympify.py\n@@ -513,8 +513,33 @@ def test_kernS():\n     one = kernS('x - (x - 1)')\n     assert one != 1 and one.expand() == 1\n \n-\n-def test_issue_6540_6552():\n+from sympy.core.sympify import kernS\n+from sympy import Symbol, Interval, Add, Mul, exp, sin, Rational, S\n+from sympy.abc import x\n+\n+def test_kernS_issue():\n+    # Test for original issue: making sure the UnboundLocalError is resolved\n+    # and kern is properly handled and assigned.\n+    \n+    # Original test case verifying correct conversion\n+    assert kernS(\"(2*x)/(x-1)\") == (2*x)/(x-1)\n+    \n+    # Additional test cases covering more scenarios\n+    # Edge case: simple expression that should not alter kern assignment\n+    assert kernS(\"x+y\") == x + y\n+    \n+    # Test different structures of expressions\n+    assert kernS(\"2*(x + y)\") == 2*(x + y)\n+    assert kernS(\"-(x + 1)\") == -(x + 1)\n+    \n+    # Test with leading/trailing whitespace\n+    assert kernS(\"   x + y   \") == x + y\n+    \n+    # Ensure complex expressions with multiple nested parentheses work\n+    assert kernS(\"-1 - 2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x)))\") != -1\n+    \n+    # Make sure symbolic replacements work correctly and consistently\n+    assert kernS('x - (x - 1)') != 1\n     assert S('[[1/3,2], (2/5,)]') == [[Rational(1, 3), 2], (Rational(2, 5),)]\n     assert S('[[2/6,2], (2/4,)]') == [[Rational(1, 3), 2], (S.Half,)]\n     assert S('[[[2*(1)]]]') == [[[2]]]\n",
  "sympy__sympy-19783": "diff --git a/sympy/physics/quantum/tests/test_operator.py b/sympy/physics/quantum/tests/test_operator.py\nindex 799aaae..9621b7f 100644\n--- a/sympy/physics/quantum/tests/test_operator.py\n+++ b/sympy/physics/quantum/tests/test_operator.py\n@@ -1,6 +1,8 @@\n+\n from sympy import (Derivative, diff, Function, Integer, Mul, pi, sin, Symbol,\n                    symbols)\n from sympy.physics.quantum.qexpr import QExpr\n+from sympy.testing.pytest import raises\n from sympy.physics.quantum.dagger import Dagger\n from sympy.physics.quantum.hilbert import HilbertSpace\n from sympy.physics.quantum.operator import (Operator, UnitaryOperator,\n@@ -84,7 +86,16 @@ def test_unitary():\n     assert Dagger(U).is_commutative is False\n \n \n-def test_identity():\n+def test_dagger_identity_simplification():\n+    A = Operator('A')\n+    Identity = IdentityOperator()\n+    Dagger_A = Dagger(A)\n+    \n+    # Check multiplication of Dagger and Identity simplifies correctly\n+    assert A * Identity == A\n+    assert Identity * A == A\n+    assert Dagger_A * Identity == Dagger_A\n+    assert Identity * Dagger_A == Dagger_A\n     I = IdentityOperator()\n     O = Operator('O')\n     x = Symbol(\"x\")\n",
  "sympy__sympy-19954": "diff --git a/sympy/combinatorics/tests/test_perm_groups.py b/sympy/combinatorics/tests/test_perm_groups.py\nindex 3f4bb48..765770d 100644\n--- a/sympy/combinatorics/tests/test_perm_groups.py\n+++ b/sympy/combinatorics/tests/test_perm_groups.py\n@@ -856,6 +856,15 @@ def test_generator_product():\n \n def test_sylow_subgroup():\n     P = PermutationGroup(Permutation(1, 5)(2, 4), Permutation(0, 1, 2, 3, 4, 5))\n+\n+    # Test case to reproduce the IndexError issue mentioned\n+    G = DihedralGroup(18)\n+    S2 = G.sylow_subgroup(p=2)\n+    assert S2.order() == 4\n+\n+    G = DihedralGroup(50)\n+    S2 = G.sylow_subgroup(p=2)\n+    assert S2.order() == 4\n     S = P.sylow_subgroup(2)\n     assert S.order() == 4\n \n",
  "sympy__sympy-20154": "",
  "sympy__sympy-20801": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\nindex 8e1c7e2..d6fa5c8 100644\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -571,25 +571,95 @@ def test_Float():\n     raises(ValueError, lambda: Float(\"1.23\", dps=\"\", precision=10))\n     raises(ValueError, lambda: Float(\"1.23\", dps=3, precision=\"\"))\n     raises(ValueError, lambda: Float(\"1.23\", dps=\"\", precision=\"\"))\n-\n+from sympy import S\n+\n+def test_zero_not_false():\n+    # https://github.com/sympy/sympy/issues/20796\n+    assert (S(0.0) == S.false) is False\n+    assert (S.false == S(0.0)) is False\n+    assert (S(0) == S.false) is False\n+    assert (S.false == S(0)) is False\n+\n+def test_zero_and_false_inequality():\n+    # Additional test cases to explore other related comparisons\n+    assert (S(0.0) != S.false) is True\n+    assert (S.false != S(0.0)) is True\n+    assert (S(0) != S.false) is True\n+    assert (S.false != S(0)) is True\n     # from NumberSymbol\n     assert same_and_same_prec(Float(pi, 32), pi.evalf(32))\n     assert same_and_same_prec(Float(Catalan), Catalan.evalf())\n-\n+from sympy import S\n+\n+def test_zero_not_false():\n+    # https://github.com/sympy/sympy/issues/20796\n+    assert (S(0.0) == S.false) is False\n+    assert (S.false == S(0.0)) is False\n+    assert (S(0) == S.false) is False\n+    assert (S.false == S(0)) is False\n+\n+def test_zero_and_false_inequality():\n+    # Additional test cases to explore other related comparisons\n+    assert (S(0.0) != S.false) is True\n+    assert (S.false != S(0.0)) is True\n+    assert (S(0) != S.false) is True\n+    assert (S.false != S(0)) is True\n     # oo and nan\n     u = ['inf', '-inf', 'nan', 'iNF', '+inf']\n     v = [oo, -oo, nan, oo, oo]\n     for i, a in zip(u, v):\n         assert Float(i) is a\n-\n-\n-\n+from sympy import S\n+\n+def test_zero_not_false():\n+    # https://github.com/sympy/sympy/issues/20796\n+    assert (S(0.0) == S.false) is False\n+    assert (S.false == S(0.0)) is False\n+    assert (S(0) == S.false) is False\n+    assert (S.false == S(0)) is False\n+\n+def test_zero_and_false_inequality():\n+    # Additional test cases to explore other related comparisons\n+    assert (S(0.0) != S.false) is True\n+    assert (S.false != S(0.0)) is True\n+    assert (S(0) != S.false) is True\n+    assert (S.false != S(0)) is True\n+\n+from sympy import S\n+\n+def test_zero_not_false():\n+    # https://github.com/sympy/sympy/issues/20796\n+    assert (S(0.0) == S.false) is False\n+    assert (S.false == S(0.0)) is False\n+    assert (S(0) == S.false) is False\n+    assert (S.false == S(0)) is False\n+\n+def test_zero_and_false_inequality():\n+    # Additional test cases to explore other related comparisons\n+    assert (S(0.0) != S.false) is True\n+    assert (S.false != S(0.0)) is True\n+    assert (S(0) != S.false) is True\n+    assert (S.false != S(0)) is True\n @conserve_mpmath_dps\n def test_float_mpf():\n     import mpmath\n     mpmath.mp.dps = 100\n     mp_pi = mpmath.pi()\n-\n+from sympy import S\n+\n+def test_zero_not_false():\n+    # https://github.com/sympy/sympy/issues/20796\n+    assert (S(0.0) == S.false) is False\n+    assert (S.false == S(0.0)) is False\n+    assert (S(0) == S.false) is False\n+    assert (S.false == S(0)) is False\n+\n+def test_zero_and_false_inequality():\n+    # Additional test cases to explore other related comparisons\n+    assert (S(0.0) != S.false) is True\n+    assert (S.false != S(0.0)) is True\n+    assert (S(0) != S.false) is True\n+    assert (S.false != S(0)) is True\n     assert Float(mp_pi, 100) == Float(mp_pi._mpf_, 100) == pi.evalf(100)\n \n     mpmath.mp.dps = 15\n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..a1c22ec 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -9,6 +10,36 @@ from sympy.testing.pytest import XFAIL\n from sympy.abc import a, x, y, z, t\n \n def test_subs():\n+    # Test case for issue with integral subs causing unexpected PolynomialError\n+    from sympy import sinh, Piecewise, exp, clear_cache\n+    \n+    x_r, y_r, z_r = symbols('x_r y_r z_r', real=True)\n+    \n+    # Clear cache and create the expression again\n+    clear_cache()\n+    expr_with_real = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    \n+    try:\n+        expr_with_real.subs({1: 1.0})\n+        subs_successful = True\n+    except Exception as e:\n+        subs_successful = False\n+    \n+    # Ensure subs does not raise an error\n+    assert subs_successful, \"Substitution raised an unexpected exception.\"\n+\n+    # Test with clearing cache and without explicit real assumptions (should not fail)\n+    clear_cache()\n+    x, y, z = symbols('x y z')\n+    expr_without_real = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\n+    \n+    try:\n+        expr_without_real.subs({1: 1.0})\n+        subs_successful = True\n+    except Exception as e:\n+        subs_successful = False\n+\n+    assert subs_successful, \"Substitution raised an unexpected exception.\"\n     n3 = Rational(3)\n     e = x\n     e = e.subs(x, n3)\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..2aa474d 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -13,6 +13,7 @@ from sympy.polys.polyerrors import ExactQuotientFailed\n \n from sympy.abc import a, b, c, x, y, z\n from sympy.core import S, symbols\n+from sympy.polys.monomials import itermonomials\n from sympy.testing.pytest import raises\n \n \n@@ -161,6 +162,16 @@ def test_monomials():\n                     j**2*k**2, x*j, x**2*k, x**2*j**2*k, j, x**2*j*k,\n                     x*j**2, x*k**2, x*j*k, x**2*j**2*k**2, x*j*k**2, x**2, x**2*j*k**2\n             }\n+def test_issue_with_min_degrees():\n+    # Test case covering the issue when using min_degrees equal to max_degrees\n+    x1, x2, x3 = symbols('x1 x2 x3')\n+    assert set(itermonomials([x1, x2, x3], 3, 3)) == {x1*x2*x3, x1**2*x2, x1**2*x3, x1*x2**2,\n+                                                      x1*x3**2, x2**2*x3, x2*x3**2, x1**3, x2**3, x3**3}\n+\n+    # Additional test: varying min_degrees below the max_degrees\n+    assert set(itermonomials([x1, x2, x3], 3, 2)) == {x1**2, x2**2, x3**2, x1**3, x2**3, x3**3, \n+                                                      x1*x2, x1*x3, x2*x3, x1*x2**2, x1*x3**2,\n+                                                      x2*x3**2, x1**2*x2, x1*x2*x3, x1**2*x3, x2**2*x3, x2*x3, x3**2}\n \n def test_monomial_count():\n     assert monomial_count(2, 2) == 6\n",
  "sympy__sympy-22456": "diff --git a/sympy/codegen/tests/test_ast.py b/sympy/codegen/tests/test_ast.py\nindex 6c38ed6..1be1a12 100644\n--- a/sympy/codegen/tests/test_ast.py\n+++ b/sympy/codegen/tests/test_ast.py\n@@ -267,6 +267,7 @@ def test_String():\n     assert st == String('foobar')\n     assert st.text == 'foobar'\n     assert st.func(**st.kwargs()) == st\n+    assert st.func(*st.args) == st  # New test case for argument invariance\n \n \n     class Signifier(String):\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..836cc5b 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n@@ -9,6 +10,7 @@ from sympy.geometry.entity import rotate, scale, translate, GeometryEntity\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.misc import Undecidable\n+from sympy.core.parameters import evaluate\n from sympy.testing.pytest import raises, warns\n \n \n@@ -443,8 +445,29 @@ def test_unit():\n def test_dot():\n     raises(TypeError, lambda: Point(1, 2).dot(Line((0, 0), (1, 1))))\n \n-\n-def test__normalize_dimension():\n+def test_issue_22684():\n+    # Used to give an error\n+    with evaluate(False):\n+        p = Point(1, 2)\n+        assert isinstance(p, Point)\n+        assert p == Point(1, 2)\n+\n+    # Test without evaluate(False)\n+    p_no_eval = Point(1, 2)\n+    assert isinstance(p_no_eval, Point)\n+    assert p_no_eval == Point2D(1, 2)\n+\n+    # Additional test with Point2D directly\n+    with evaluate(False):\n+        p2d = Point2D(Integer(1), Integer(2))\n+        assert isinstance(p2d, Point2D)\n+        assert p2d == Point2D(1, 2)\n+\n+    # Test for imaginery components scenario\n+    # This should raise ValueError\n+    with raises(ValueError):\n+        with evaluate(False):\n+            Point(1 + I, 2)\n     assert Point._normalize_dimension(Point(1, 2), Point(3, 4)) == [\n         Point(1, 2), Point(3, 4)]\n     assert Point._normalize_dimension(\n",
  "sympy__sympy-22914": "diff --git a/sympy/printing/tests/test_pycode.py b/sympy/printing/tests/test_pycode.py\nindex ab6551d..268728d 100644\n--- a/sympy/printing/tests/test_pycode.py\n+++ b/sympy/printing/tests/test_pycode.py\n@@ -1,3 +1,4 @@\n+\n from sympy.codegen import Assignment\n from sympy.codegen.ast import none\n from sympy.codegen.cfunctions import expm1, log1p\n@@ -6,7 +7,7 @@ from sympy.codegen.matrix_nodes import MatrixSolve\n from sympy.core import Expr, Mod, symbols, Eq, Le, Gt, zoo, oo, Rational, Pow\n from sympy.core.numbers import pi\n from sympy.core.singleton import S\n-from sympy.functions import acos, KroneckerDelta, Piecewise, sign, sqrt\n+from sympy.functions import acos, KroneckerDelta, Piecewise, sign, sqrt, Min, Max\n from sympy.logic import And, Or\n from sympy.matrices import SparseMatrix, MatrixSymbol, Identity\n from sympy.printing.pycode import (\n@@ -56,6 +57,14 @@ def test_PythonCodePrinter():\n     assert prntr.doprint(KroneckerDelta(x,y)) == '(1 if x == y else 0)'\n \n     assert prntr.doprint((2,3)) == \"(2, 3)\"\n+    assert prntr.doprint(Min(x, y)) == \"min(x, y)\"\n+    assert prntr.doprint(Max(x, y)) == \"max(x, y)\"\n+    assert prntr.doprint(Min(x, y, z)) == \"min(x, y, z)\"\n+    assert prntr.doprint(Max(x, y, z)) == \"max(x, y, z)\"\n+    assert prntr.doprint(Min(x, Min(y, z))) == \"min(x, min(y, z))\"\n+    assert prntr.doprint(Max(x, Max(y, z))) == \"max(x, max(y, z))\"\n+    assert prntr.doprint(Min(Max(x, y), z)) == \"min(max(x, y), z)\"\n+    assert prntr.doprint(Max(Min(x, y), z)) == \"max(min(x, y), z)\"\n     assert prntr.doprint([2,3]) == \"[2, 3]\"\n \n \n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..e3853bc 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1174,8 +1174,35 @@ def test_scipy_polys():\n                     )\n \n \n-\n-def test_lambdify_inspect():\n+    \n+def test_tuple_single_element():\n+    # Test that lambdify respects single element tuple and returns correctly \n+    f_single_tuple = lambdify([], (1,))\n+    assert f_single_tuple() == (1,)\n+\n+    # Test that lambdify respects tuples with two elements and returns correctly\n+    f_two_elements = lambdify([], (1, 2))\n+    assert f_two_elements() == (1, 2)\n+\n+    # Test source code generation for single element tuple\n+    source_code_single = inspect.getsource(lambdify([], (1,)))\n+    assert \"return (1,)\" in source_code_single\n+\n+    # Test source code generation for two elements tuple\n+    source_code_two = inspect.getsource(lambdify([], (1, 2)))\n+    assert \"return (1, 2)\" in source_code_two\n+\n+    # Additional functional tests to ensure no regression in current behavior\n+    f_tuple = lambdify([], Tuple(3,))\n+    assert f_tuple() == Tuple(3,)\n+\n+    f_matrix = lambdify([], Matrix([1]))\n+    assert f_matrix() == Matrix([1])\n+\n+    # Test custom function with a single element tuple using diagnostic\n+    f_custom = implemented_function('f', lambda x: x + 1)\n+    f = lambdify([], (f_custom(2),), modules=['sympy'])\n+    assert f()[0] == 3\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n     # details\n",
  "sympy__sympy-23534": "diff --git a/sympy/core/tests/test_symbol.py b/sympy/core/tests/test_symbol.py\nindex 645c231..71d2b32 100644\n--- a/sympy/core/tests/test_symbol.py\n+++ b/sympy/core/tests/test_symbol.py\n@@ -1,4 +1,13 @@\n+\n+def test_symbols_with_function_class_extra_parentheses():\n+    # Using 'symbols' with an extra layer of parentheses and 'cls=Function'\n+    q, u = symbols(('q:2', 'u:2'), cls=Function)\n+    assert isinstance(q[0], UndefinedFunction), f\"Expected UndefinedFunction, got {type(q[0])}\"\n+\n+test_symbols_with_function_class_extra_parentheses()\n+\n from sympy.core.numbers import (I, Rational, pi)\n+from sympy.core.function import Function, UndefinedFunction\n from sympy.core.relational import (GreaterThan, LessThan, StrictGreaterThan, StrictLessThan)\n from sympy.core.symbol import (Dummy, Symbol, Wild, symbols)\n from sympy.core.sympify import sympify  # can't import as S yet\n",
  "sympy__sympy-23824": "",
  "sympy__sympy-23950": "diff --git a/sympy/sets/tests/test_contains.py b/sympy/sets/tests/test_contains.py\nindex 4bcc7c8..6a6a2f9 100644\n--- a/sympy/sets/tests/test_contains.py\n+++ b/sympy/sets/tests/test_contains.py\n@@ -46,6 +46,19 @@ def test_as_set():\n     raises(NotImplementedError, lambda:\n            Contains(x, FiniteSet(y)).as_set())\n \n-def test_type_error():\n+def test_as_set_failure():\n+    x = Symbol('x')\n+    y = Symbol('y')\n+    \n+    # This should raise a NotImplementedError since `as_set` function currently\n+    # does not handle Contains objects properly.\n+    with raises(NotImplementedError):\n+        Contains(x, FiniteSet(y)).as_set()\n+        \n+    with raises(NotImplementedError):\n+        Contains(x, S.Integers).as_set()\n+    \n+    with raises(NotImplementedError):\n+        Contains(x, S.Reals).as_set()\n     # Pass in a parameter not of type \"set\"\n-    raises(TypeError, lambda: Contains(2, None))\n+    raises(TypeError, lambda: Contains(2, None))\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..47e00be 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -528,6 +528,30 @@ def test_issue_22819():\n     assert Da.scale_factor == 1.66053906660000e-24\n \n \n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units import Quantity\n+    from sympy.physics.units.systems.si import SI\n+    from sympy import exp\n+    from sympy.physics.units.dimensions import Dimension\n+\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n+\n def test_issue_20288():\n     from sympy.core.numbers import E\n     from sympy.physics.units import energy\n",
  "sympy__sympy-24213": "",
  "sympy__sympy-24443": "diff --git a/sympy/combinatorics/tests/test_homomorphisms.py b/sympy/combinatorics/tests/test_homomorphisms.py\nindex 0a025da..abebc7d 100644\n--- a/sympy/combinatorics/tests/test_homomorphisms.py\n+++ b/sympy/combinatorics/tests/test_homomorphisms.py\n@@ -1,3 +1,4 @@\n+\n from sympy.combinatorics import Permutation\n from sympy.combinatorics.perm_groups import PermutationGroup\n from sympy.combinatorics.homomorphisms import homomorphism, group_isomorphism, is_isomorphic\n@@ -7,6 +8,26 @@ from sympy.combinatorics.named_groups import AlternatingGroup, DihedralGroup, Cy\n from sympy.testing.pytest import raises\n \n def test_homomorphism():\n+    # Issue-specific test case\n+    D3 = DihedralGroup(3)\n+    T = homomorphism(D3, D3, D3.generators, D3.generators)\n+    assert T.is_isomorphism()\n+\n+def test_check_homomorphism_for_inverted_generators():\n+    # Additional test for inverted generators\n+    from sympy.combinatorics.named_groups import SymmetricGroup\n+    \n+    # Symmetric group of degree 3\n+    S3 = SymmetricGroup(3)\n+    \n+    # Define a homomorphism from S3 to S3 with inverted generators\n+    g1, g2 = S3.generators  # Generators in S3, typically (1 2) and (1 2 3)\n+    \n+    # Attempting to create a homomorphism using inverted generators\n+    T = homomorphism(S3, S3, [g1, g2], [g1, g2**-1])\n+    \n+    # Check if it raises a ValueError as the images might not define a homomorphism\n+    raises(ValueError, lambda: T.is_isomorphism())\n     # FpGroup -> PermutationGroup\n     F, a, b = free_group(\"a, b\")\n     G = FpGroup(F, [a**3, b**3, (a*b)**2])\n",
  "sympy__sympy-24539": "diff --git a/sympy/polys/tests/test_rings.py b/sympy/polys/tests/test_rings.py\nindex 1f0e405..baf91f7 100644\n--- a/sympy/polys/tests/test_rings.py\n+++ b/sympy/polys/tests/test_rings.py\n@@ -249,7 +249,11 @@ def test_PolyElement_copy():\n     g[(1, 1, 1)] = 7\n     assert f != g\n \n+from sympy import ring, ZZ, symbols\n+from sympy.core.compatibility import raises\n+\n def test_PolyElement_as_expr():\n+    # Original tests\n     R, x, y, z = ring(\"x,y,z\", ZZ)\n     f = 3*x**2*y - x*y*z + 7*z**3 + 1\n \n@@ -264,9 +268,22 @@ def test_PolyElement_as_expr():\n \n     assert f != g\n     assert f.as_expr(X, Y, Z) == g\n+    \n+    # Test with different symbols of correct length\n+    U, V, W = symbols(\"u,v,w\")\n+    g = 3*U**2*V - U*V*W + 7*W**3 + 1\n+    assert f.as_expr(U, V, W) == g\n \n+    # Test for ValueError with too few symbols\n     raises(ValueError, lambda: f.as_expr(X))\n \n+    # Test for ValueError with too many symbols\n+    A, B, C, D = symbols(\"a, b, c, d\")\n+    raises(ValueError, lambda: f.as_expr(A, B, C, D))\n+\n+    # Test behavior with zero symbols - should default to original behavior\n+    assert f.as_expr() == g.subs({U: X, V: Y, W: Z})\n+\n     R, = ring(\"\", ZZ)\n     assert R(3).as_expr() == 3\n \n",
  "sympy__sympy-24661": "diff --git a/sympy/parsing/tests/test_sympy_parser.py b/sympy/parsing/tests/test_sympy_parser.py\nindex 3723931..9a23181 100644\n--- a/sympy/parsing/tests/test_sympy_parser.py\n+++ b/sympy/parsing/tests/test_sympy_parser.py\n@@ -273,6 +273,20 @@ def test_convert_equals_signs():\n     assert parse_expr(\"(2*y = x) = False\",\n         transformations=transformations) == Eq(Eq(2*y, x), False)\n \n+from sympy.parsing.sympy_parser import parse_expr\n+from sympy.core import Symbol, Function, Float, Rational, Integer, I, Mul, Pow, Eq, Lt, Le, Gt, Ge, Ne\n+\n+def test_issue_24288():\n+    inputs = {\n+        \"1 < 2\": Lt(1, 2, evaluate=False),\n+        \"1 <= 2\": Le(1, 2, evaluate=False),\n+        \"1 > 2\": Gt(1, 2, evaluate=False),\n+        \"1 >= 2\": Ge(1, 2, evaluate=False),\n+        \"1 != 2\": Ne(1, 2, evaluate=False),\n+        \"1 == 2\": Eq(1, 2, evaluate=False)\n+    }\n+    for text, result in inputs.items():\n+        assert parse_expr(text, evaluate=False) == result\n \n def test_parse_function_issue_3539():\n     x = Symbol('x')\n",
  "astropy__astropy-14369": "diff --git a/astropy/units/tests/test_format.py b/astropy/units/tests/test_format.py\nindex 062b5f4..4ed1cdf 100644\n--- a/astropy/units/tests/test_format.py\n+++ b/astropy/units/tests/test_format.py\n@@ -65,6 +65,9 @@ def test_unit_grammar_fail(string):\n         ([\"1.5\u00d710+11m\"], u.Unit(1.5e11 * u.m)),\n         ([\"m2\"], u.m**2),\n         ([\"10+21m\"], u.Unit(u.m * 1e21)),\n+        # Test case for verifying issue with composite units in CDS format MRT files using astropy.table\n+        ([\"10+3J/m/s/kpc2\"], u.Unit(1e3 * u.J / (u.m * u.s * u.kpc**2))),\n+        ([\"10-7J/s/kpc2\"], u.Unit(1e-7 * u.J / (u.s * u.kpc**2))),\n         ([\"2.54cm\"], u.Unit(u.cm * 2.54)),\n         ([\"20%\"], 0.20 * u.dimensionless_unscaled),\n         ([\"10+9\"], 1.0e9 * u.dimensionless_unscaled),\n",
  "astropy__astropy-14598": "",
  "django__django-11299": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex b3dc643..097d78c 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1908,6 +1908,28 @@ class OperationTests(OperationTestBase):\n         self.assertEqual(\n             gt_operation.describe(), \"Remove constraint test_remove_constraint_pony_pink_gt_2 from model Pony\"\n         )\n+\n+    @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_check_constraint_with_or_and(self):\n+        \"\"\"Test CheckConstraint with OR and AND clauses on SQLite and Oracle.\"\"\"\n+        app_label = 'test_checkconstraint_or_and'\n+        constraint_name = 'field_1_has_value_if_flag_set'\n+        from_state = self.set_up_test_model(app_label, constraints=[])\n+        check = models.Q(flag__exact=True, field_1__isnull=False) | models.Q(flag__exact=False)\n+        constraint = models.CheckConstraint(check=check, name=constraint_name)\n+        operation = migrations.AddConstraint('TestConstraint', constraint)\n+        to_state = from_state.clone()\n+        operation.state_forwards(app_label, to_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, from_state, to_state)\n+\n+        TestConstraint = to_state.apps.get_model(app_label, 'TestConstraint')\n+        with self.assertRaises(IntegrityError), transaction.atomic():\n+            TestConstraint.objects.create(field_1=None, flag=True)\n+        with self.assertRaises(IntegrityError), transaction.atomic():\n+            TestConstraint.objects.create(field_1=1, flag=False)\n+        TestConstraint.objects.create(field_1=1, flag=True)\n+        TestConstraint.objects.create(field_1=None, flag=False)\n         # Test state alteration\n         new_state = project_state.clone()\n         gt_operation.state_forwards(\"test_removeconstraint\", new_state)\n",
  "django__django-11477": "diff --git a/tests/i18n/patterns/tests.py b/tests/i18n/patterns/tests.py\nindex e4898b6..2bc7671 100644\n--- a/tests/i18n/patterns/tests.py\n+++ b/tests/i18n/patterns/tests.py\n@@ -164,6 +164,44 @@ class URLTranslationTests(URLTestCaseBase):\n             self.assertEqual(translation.get_language(), 'nl')\n \n \n+from django.urls import reverse, resolve, re_path\n+from django.utils.translation import gettext_lazy as _\n+\n+def test_re_path_with_optional_parameter(self):\n+    for url, kwargs in (\n+        ('/regex_optional/1/2/', {'arg1': '1', 'arg2': '2'}),\n+        ('/regex_optional/1/', {'arg1': '1'}),\n+    ):\n+        with self.subTest(url=url):\n+            match = resolve(url)\n+            self.assertEqual(match.url_name, 'regex_optional')\n+            self.assertEqual(match.kwargs, kwargs)\n+            self.assertEqual(\n+                match.route,\n+                r'^regex_optional/(?P<arg1>\\d+)/(?:(?P<arg2>\\d+)/)?',\n+            )\n+\n+def test_translate_url_with_optional(self):\n+    # Test translating URLs with optional parts in the pattern\n+    with translation.override('en'):\n+        self.assertEqual(\n+            translate_url('/en/regex_optional/1/', 'nl'),\n+            '/nl/regex_optional/1/'\n+        )\n+        self.assertEqual(\n+            translate_url('/en/regex_optional/1/2/', 'nl'),\n+            '/nl/regex_optional/1/2/'\n+        )\n+    with translation.override('nl'):\n+        self.assertEqual(\n+            translate_url('/nl/regex_optional/1/', 'en'),\n+            '/en/regex_optional/1/'\n+        )\n+        self.assertEqual(\n+            translate_url('/nl/regex_optional/1/2/', 'en'),\n+            '/en/regex_optional/1/2/'\n+        )\n+\n class URLNamespaceTests(URLTestCaseBase):\n     \"\"\"\n     Tests if the translations are still working within namespaces.\n",
  "django__django-12273": "diff --git a/tests/model_inheritance_regress/tests.py b/tests/model_inheritance_regress/tests.py\nindex d79faca..2779de8 100644\n--- a/tests/model_inheritance_regress/tests.py\n+++ b/tests/model_inheritance_regress/tests.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Regression tests for Model inheritance behavior.\n \"\"\"\n@@ -14,8 +15,44 @@ from .models import (\n     MessyBachelorParty, ParkingLot, ParkingLot3, ParkingLot4A, ParkingLot4B,\n     Person, Place, Profile, QualityControl, Restaurant, SelfRefChild,\n     SelfRefParent, Senator, Supplier, TrainStation, User, Wholesaler,\n+    Congressman, DerivedM, InternalCertificationAudit, ItalianRestaurant,\n+    Item, Derived\n )\n \n+class ResetPrimaryKeyTest(TestCase):\n+    def test_reset_primary_key_on_derived_model(self):\n+        # Create initial 'Derived' object\n+        original_obj = Derived.objects.create(f=True)\n+        # Reset primary key and save the object\n+        original_obj.reset()\n+        original_obj.save()\n+        # Verify that a new object is created\n+        self.assertEqual(Derived.objects.count(), 2)\n+\n+    def test_reset_primary_key_and_persistence(self):\n+        # Create initial object\n+        obj1 = Derived.objects.create(f=True)\n+        # Reset primary key\n+        obj1.reset()\n+        obj1.save()\n+        # Ensure 'f' field is reset properly in the new object\n+        new_obj = Derived.objects.get(f=False)\n+        self.assertIsNotNone(new_obj.pk)\n+        self.assertNotEqual(obj1.pk, new_obj.pk)\n+\n+    def test_no_overlapping_when_reset_pk(self):\n+        # Create initial object\n+        obj1 = Derived.objects.create(f=True) \n+        obj1_id = obj1.pk\n+        # Reset primary key\n+        obj1.reset()\n+        obj1.save()\n+        # Verify the original object still exists\n+        original_obj = Derived.objects.get(pk=obj1_id)\n+        self.assertTrue(original_obj.f)\n+        # Verify that a new object is created\n+        self.assertEqual(Derived.objects.count(), 2)\n+\n \n class ModelInheritanceTest(TestCase):\n     def test_model_inheritance(self):\n",
  "django__django-12965": "",
  "django__django-13023": "diff --git a/tests/model_fields/test_decimalfield.py b/tests/model_fields/test_decimalfield.py\nindex ab04b0d..aa87b5b 100644\n--- a/tests/model_fields/test_decimalfield.py\n+++ b/tests/model_fields/test_decimalfield.py\n@@ -1,3 +1,4 @@\n+\n import unittest\n from decimal import Decimal\n \n@@ -25,6 +26,25 @@ class DecimalFieldTests(TestCase):\n         with self.assertRaisesMessage(ValidationError, msg):\n             f.to_python('abc')\n \n+    def test_invalid_values(self):\n+        field = models.DecimalField(max_digits=4, decimal_places=2)\n+        msg = '\u201c%s\u201d value must be a decimal number.'\n+        # Test a dictionary, this was the specific issue.\n+        with self.assertRaisesMessage(ValidationError, msg % ({})):\n+            field.clean({}, None)\n+\n+        # Additional invalid types to ensure comprehensive coverage\n+        invalid_values = [\n+            (),      # A tuple\n+            [],      # A list\n+            set(),   # A set\n+            object() # An arbitrary object\n+        ]\n+        for value in invalid_values:\n+            with self.subTest(value=value):\n+                with self.assertRaisesMessage(ValidationError, msg % (value,)):\n+                    field.clean(value, None)\n+\n     def test_default(self):\n         f = models.DecimalField(default=Decimal('0.00'))\n         self.assertEqual(f.get_default(), Decimal('0.00'))\n",
  "django__django-13406": "diff --git a/tests/queryset_pickle/tests.py b/tests/queryset_pickle/tests.py\nindex d0a7de1..a5468d3 100644\n--- a/tests/queryset_pickle/tests.py\n+++ b/tests/queryset_pickle/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import pickle\n \n@@ -183,6 +184,28 @@ class PickleabilityTestCase(TestCase):\n         groups2 = pickle.loads(pickle.dumps(groups))\n         self.assertSequenceEqual(groups2.filter(has_event=True), [group])\n \n+    def test_annotation_values(self):\n+        qs = Happening.objects.values('name').annotate(latest_time=models.Max('when'))\n+        reloaded = Happening.objects.all()\n+        reloaded.query = pickle.loads(pickle.dumps(qs.query))\n+        self.assertEqual(\n+            reloaded.get(),\n+            {'name': 'test', 'latest_time': self.happening.when},\n+        )\n+\n+    def test_annotation_values_list(self):\n+        # values_list() is reloaded to values() when using a pickled query.\n+        tests = [\n+            Happening.objects.values_list('name'),\n+            Happening.objects.values_list('name', flat=True),\n+            Happening.objects.values_list('name', named=True),\n+        ]\n+        for qs in tests:\n+            with self.subTest(qs._iterable_class.__name__):\n+                reloaded = Happening.objects.all()\n+                reloaded.query = pickle.loads(pickle.dumps(qs.query))\n+                self.assertEqual(reloaded.get(), {'name': 'test'})\n+\n     def test_pickle_exists_queryset_not_evaluated(self):\n         group = Group.objects.create(name='group')\n         Event.objects.create(title='event', group=group)\n",
  "django__django-13449": "diff --git a/tests/expressions_window/models.py b/tests/expressions_window/models.py\nindex 3f59cdf..d9c7568 100644\n--- a/tests/expressions_window/models.py\n+++ b/tests/expressions_window/models.py\n@@ -11,4 +11,5 @@ class Employee(models.Model):\n     department = models.CharField(max_length=40, blank=False, null=False)\n     hire_date = models.DateField(blank=False, null=False)\n     age = models.IntegerField(blank=False, null=False)\n-    classification = models.ForeignKey('Classification', on_delete=models.CASCADE, null=True)\n+    classification = models.ForeignKey('Classification', on_delete=models.CASCADE, null=True)\n+    bonus = models.DecimalField(decimal_places=2, max_digits=15, null=True)\n",
  "django__django-13512": "diff --git a/tests/forms_tests/field_tests/test_jsonfield.py b/tests/forms_tests/field_tests/test_jsonfield.py\nindex e31bff4..7f73b80 100644\n--- a/tests/forms_tests/field_tests/test_jsonfield.py\n+++ b/tests/forms_tests/field_tests/test_jsonfield.py\n@@ -24,6 +24,17 @@ class JSONFieldTest(SimpleTestCase):\n         with self.assertRaisesMessage(ValidationError, 'Enter a valid JSON.'):\n             field.clean('{some badly formed: json}')\n \n+    def test_unicode_and_emoji_handling(self):\n+        field = JSONField()\n+        # Test if Chinese characters are correctly serialized and displayed\n+        self.assertEqual(field.prepare_value({'a': '\u4f60\u597d \u4e16\u754c'}), '{\"a\": \"\u4f60\u597d \u4e16\u754c\"}')\n+        \n+        # Test if emojis are correctly serialized and displayed\n+        self.assertEqual(field.prepare_value({'a': '\ud83d\ude00\ud83d\udc31'}), '{\"a\": \"\ud83d\ude00\ud83d\udc31\"}')\n+\n+        # Further testing with mixed content\n+        self.assertEqual(field.prepare_value(['\u4f60\u597d\uff0c\u4e16\u754c', 'ja\u017a\u0144']), '[\"\u4f60\u597d\uff0c\u4e16\u754c\", \"ja\u017a\u0144\"]')\n+\n     def test_prepare_value(self):\n         field = JSONField()\n         self.assertEqual(field.prepare_value({'a': 'b'}), '{\"a\": \"b\"}')\n",
  "django__django-14404": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 8fb91af..31784b5 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -6603,6 +6603,40 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n         self.assertRedirects(response, known_url, status_code=301, target_status_code=403)\n \n     @override_settings(APPEND_SLASH=True)\n+    def test_missing_slash_no_script_name(self):\n+        superuser = User.objects.create_user(\n+            username='staff',\n+            password='secret',\n+            email='staff@example.com',\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse('admin:admin_views_article_changelist')\n+        response = self.client.get(known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            known_url,\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True, FORCE_SCRIPT_NAME='/myapp/')\n+    def test_with_script_name_setting(self):\n+        superuser = User.objects.create_user(\n+            username='staff',\n+            password='secret',\n+            email='staff@example.com',\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse('admin:admin_views_article_changelist')\n+        response = self.client.get(known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            settings.FORCE_SCRIPT_NAME + known_url,\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n     def test_missing_slash_append_slash_true_non_staff_user(self):\n         user = User.objects.create_user(\n             username='user',\n@@ -6629,6 +6663,40 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n         self.assertEqual(response.status_code, 404)\n \n     @override_settings(APPEND_SLASH=True)\n+    def test_missing_slash_no_script_name(self):\n+        superuser = User.objects.create_user(\n+            username='staff',\n+            password='secret',\n+            email='staff@example.com',\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse('admin:admin_views_article_changelist')\n+        response = self.client.get(known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            known_url,\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True, FORCE_SCRIPT_NAME='/myapp/')\n+    def test_with_script_name_setting(self):\n+        superuser = User.objects.create_user(\n+            username='staff',\n+            password='secret',\n+            email='staff@example.com',\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse('admin:admin_views_article_changelist')\n+        response = self.client.get(known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            settings.FORCE_SCRIPT_NAME + known_url,\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n     def test_single_model_no_append_slash(self):\n         superuser = User.objects.create_user(\n             username='staff',\n",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..f3efae2 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -691,6 +691,29 @@ class WriterTests(SimpleTestCase):\n         result = self.safe_exec(output)\n         self.assertIn(\"Migration\", result)\n \n+    def test_missing_import_in_migration(self):\n+        \"\"\"\n+        Tests that a migration correctly includes the missing 'models' import.\n+        \"\"\"\n+        # Simulating a migration creation to test import generation\n+        migration = type(\"Migration\", (migrations.Migration,), {\n+            \"initial\": True,\n+            \"operations\": [\n+                migrations.CreateModel(\n+                    name=\"MyModel\",\n+                    fields=[\n+                        ('name', models.TextField(primary_key=True)),\n+                    ],\n+                    bases=(models.Model,),\n+                ),\n+            ],\n+        })\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        \n+        # Check for the correct import statement for models\n+        self.assertIn(\"from django.db import models\", output)\n+\n     def test_migration_path(self):\n         test_apps = [\n             'migrations.migrations_test_apps.normal',\n",
  "django__django-15375": "",
  "django__django-15695": "",
  "django__django-15732": "diff --git a/django/db/migrations/operations/models.py b/django/db/migrations/operations/models.py\nindex 42e02c2..f4f9e05 100644\n--- a/django/db/migrations/operations/models.py\n+++ b/django/db/migrations/operations/models.py\n@@ -595,6 +595,51 @@ class AlterTogetherOptionOperation(ModelOptionOperation):\n         )\n \n \n+class TestUniqueTogetherConstraints(TransactionTestCase):\n+    available_apps = [\"tests\"]\n+\n+    @skipUnlessDBFeature(\"allows_multiple_constraints_on_same_fields\")\n+    def test_remove_unique_together_on_pk_and_unique_field(self):\n+        app_label = \"test_rutopf\"\n+        project_state = self.apply_operations(\n+            app_label,\n+            ProjectState(),\n+            operations=[\n+                migrations.CreateModel(\n+                    \"Pony\",\n+                    fields=[\n+                        (\"id\", models.AutoField(primary_key=True)),\n+                        (\"name\", models.CharField(max_length=30, unique=True)),\n+                    ],\n+                    options={\"unique_together\": {(\"id\", \"name\")}},\n+                ),\n+            ],\n+        )\n+        table_name = f\"{app_label}_pony\"\n+        pk_constraint_name = f\"{table_name}_pkey\"\n+        unique_constraint_name = f\"{table_name}_name_key\"\n+        unique_together_constraint_name = f\"{table_name}_id_name_uniq\"\n+        \n+        # Ensure all constraints exist\n+        self.assertConstraintExists(table_name, pk_constraint_name)\n+        self.assertConstraintExists(table_name, unique_constraint_name)\n+        self.assertConstraintExists(table_name, unique_together_constraint_name)\n+\n+        # Simulate a migration that removes the erroneous unique_together constraint\n+        new_state = project_state.clone()\n+        operation = migrations.AlterUniqueTogether(\"Pony\", set())\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+        # Ensure only the unique_together constraint is removed, leaving primary key and unique constraints\n+        self.assertConstraintExists(table_name, pk_constraint_name)\n+        self.assertConstraintExists(table_name, unique_constraint_name)\n+        self.assertConstraintNotExists(table_name, unique_together_constraint_name)\n+\n+from django.db import connection, migrations, models\n+from django.test import TransactionTestCase, skipUnlessDBFeature\n+\n class AlterUniqueTogether(AlterTogetherOptionOperation):\n     \"\"\"\n     Change the value of unique_together to the target one.\n@@ -604,6 +649,8 @@ class AlterUniqueTogether(AlterTogetherOptionOperation):\n     option_name = \"unique_together\"\n \n     def __init__(self, name, unique_together):\n+        self.name = name\n+        self.unique_together = unique_together\n         super().__init__(name, unique_together)\n \n \n",
  "django__django-15916": "",
  "django__django-16938": "diff --git a/tests/serializers/test_json.py b/tests/serializers/test_json.py\nindex d77ef46..3a8cf3a 100644\n--- a/tests/serializers/test_json.py\n+++ b/tests/serializers/test_json.py\n@@ -9,13 +9,37 @@ from django.core.serializers.json import DjangoJSONEncoder\n from django.db import models\n from django.test import SimpleTestCase, TestCase, TransactionTestCase\n from django.test.utils import isolate_apps\n-from django.utils.translation import gettext_lazy, override\n+from django.db import models\n+from django.core import serializers\n+from django.core.exceptions import FieldError\n \n from .models import Score\n from .tests import SerializersTestBase, SerializersTransactionTestBase\n+class TestTagMaster(models.Model):\n+    name = models.CharField(max_length=120)\n+\n+class TestTag(models.Model):\n+    name = models.CharField(max_length=120)\n+    master = models.ForeignKey(TestTagMaster, on_delete=models.SET_NULL, null=True)\n+    objects = models.Manager()\n+\n+class Test(models.Model):\n+    name = models.CharField(max_length=120)\n+    tags = models.ManyToManyField(TestTag, blank=True)\n \n \n class JsonSerializerTestCase(SerializersTestBase, TestCase):\n+    def test_m2m_with_custom_manager_select_related(self):\n+        tag_master = TestTagMaster.objects.create(name=\"master\")\n+        tag = TestTag.objects.create(name=\"tag\", master=tag_master)\n+        test = Test.objects.create(name=\"test\")\n+        test.tags.add(tag)\n+        test.save()\n+        try:\n+            serializers.serialize(\"json\", [test])\n+            self.assertTrue(True, \"Serialization succeeded without FieldError.\")\n+        except FieldError as e:\n+            self.fail(f\"Serialization failed with FieldError: {e}\")\n     serializer_name = \"json\"\n     pkless_str = \"\"\"[\n     {\n",
  "matplotlib__matplotlib-23476": "",
  "pydata__xarray-3993": "",
  "pydata__xarray-4094": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex a2826fa..63b25fe 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -3045,7 +3045,13 @@ class TestDataset:\n         d0 = D.isel(x=0)\n         assert_identical(d0, x0)\n \n-    def test_to_stacked_array_to_unstacked_dataset_different_dimension(self):\n+    def test_to_stacked_array_to_unstacked_dataset_single_dim_variables(self):\n+        # single dimension: regression test for the issue described\n+        arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+        data = xr.Dataset({\"a\": arr, \"b\": arr})\n+        stacked = data.to_stacked_array(\"y\", sample_dims=[\"x\"])\n+        unstacked = stacked.to_unstacked_dataset(\"y\")\n+        assert_identical(unstacked, data)\n         # test when variables have different dimensionality\n         a, b = create_test_stacked_array()\n         sample_dims = [\"x\"]\n",
  "pylint-dev__pylint-8898": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex ae541fc..4af7272 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -131,7 +131,38 @@ def test_regex_error(capsys: CaptureFixture) -> None:\n     assert assertString in output.err\n \n \n-def test_csv_regex_error(capsys: CaptureFixture) -> None:\n+from typing import Any\n+import pytest\n+import re\n+from pylint.lint import Run\n+\n+CSV_REGEX_COMMA_CASES = [\n+    (\"foo\", [\"foo\"]),\n+    (\"foo,bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar{1,3}\", [\"foo\", \"bar{1,3}\"]),\n+    (\"(foo{1,3})\", [\"(foo{1,3})\"]),\n+]\n+\n+@pytest.mark.parametrize(\"in_string,expected\", CSV_REGEX_COMMA_CASES)\n+def test_csv_regex_comma_handling(in_string: str, expected: list[str], capsys: CaptureFixture) -> None:\n+    \"\"\"Ensure the correct handling of comma-separated regexes with commas within expressions.\"\"\"\n+    def _template_run(in_string: str) -> list[re.Pattern[Any]]:\n+        r = Run(\n+            [str(EMPTY_MODULE), rf\"--bad-names-rgx={in_string}\"],\n+            exit=False,\n+        )\n+        bad_names_rgxs: list[re.Pattern[Any]] = r.linter.config.bad_names_rgxs\n+        return bad_names_rgxs\n+\n+    assert _template_run(in_string) == [re.compile(regex) for regex in expected]\n+    \n+    # Test a failing case for invalid regex to verify error handling\n+    invalid_regex = \"(foo{1,}, foo{1,3})\"\n+    with pytest.raises(SystemExit):\n+        Run([str(EMPTY_MODULE), rf\"--bad-names-rgx={invalid_regex}\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"unterminated subpattern\" in output.err\n     \"\"\"Check that we correctly error when an option is passed and one\n     of its comma-separated regular expressions values is an invalid regular expression.\n     \"\"\"\n",
  "pytest-dev__pytest-6197": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex d7aed6e..9982e03 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1155,8 +1155,24 @@ def test_summary_list_after_errors(testdir):\n         ]\n     )\n \n-\n-def test_importorskip():\n+def test_does_not_collect_random_init_py(testdir):\n+    # Create a directory that simulates a package\n+    foo_pkg = testdir.mkpydir(\"foo_pkg\")\n+    \n+    # Create an __init__.py file which should not be collected\n+    foo_pkg.join(\"__init__.py\").write(\"assert False\")\n+    \n+    # Add a dummy test file to ensure the pytest collects something\n+    testdir.makepyfile(\n+        test_dummy=\"\"\"\n+        def test_placeholder():\n+            assert True\n+    \"\"\"\n+    )\n+    \n+    # Run pytest and ensure it doesn't fail due to the __init__.py file\n+    result = testdir.runpytest()\n+    result.assert_outcomes(passed=1)\n     with pytest.raises(\n         pytest.skip.Exception,\n         match=\"^could not import 'doesnotexist': No module named .*\",\n@@ -1184,4 +1200,4 @@ def test_skip_package(testdir):\n \n     result = testdir.inline_run()\n     _, skipped, _ = result.listoutcomes()\n-    assert len(skipped) == 2\n+    assert len(skipped) == 2\n",
  "pytest-dev__pytest-7324": "diff --git a/testing/test_mark_expression.py b/testing/test_mark_expression.py\nindex 10b71e9..589c570 100644\n--- a/testing/test_mark_expression.py\n+++ b/testing/test_mark_expression.py\n@@ -139,6 +139,21 @@ def test_valid_idents(ident: str) -> None:\n     assert evaluate(ident, {ident: True}.__getitem__)\n \n \n+import pytest\n+\n+@pytest.mark.parametrize(\n+    \"expr_input\",\n+    [\n+        \"None\",\n+        \"True\",\n+        \"False\"\n+    ]\n+)\n+def test_invalid_compile_expr(expr_input: str) -> None:\n+    with pytest.raises(AssertionError):\n+        Expression.compile(expr_input)\n+\n+\n @pytest.mark.parametrize(\n     \"ident\",\n     (\n",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..4452e49 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -259,4 +259,32 @@ def test_set_output_mro():\n     class C(A, B):\n         pass\n \n-    assert C().transform(None) == \"B\"\n+    assert C().transform(None) == \"B\"\n+\n+def test_feature_union_with_pandas_output():\n+    \"\"\"Regression test for FeatureUnion with pandas output.\"\"\"\n+    import pandas as pd\n+    from sklearn.pipeline import make_union\n+    from sklearn.base import BaseEstimator, TransformerMixin\n+    from sklearn.utils._set_output import _set_output_config\n+\n+    class MyTransformer(BaseEstimator, TransformerMixin):\n+        def fit(self, X: pd.DataFrame, y=None):\n+            return self\n+\n+        def transform(self, X: pd.DataFrame, y=None) -> pd.DataFrame:\n+            return X[\"value\"].groupby(X[\"date\"]).sum().reset_index(name=\"sum\")\n+\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+\n+    with _set_output_config(transform=\"pandas\"):\n+        union = make_union(MyTransformer())\n+        result = union.fit_transform(data)\n+    \n+    # Check if the transformation was successful with pandas DataFrame output\n+    expected_dates = pd.Series([\"2020-01-01\", \"2020-01-02\", \"2020-01-03\", \"2020-01-04\"])\n+    expected_values = pd.Series([240, 240, 240, 96], name='sum')\n+    pd.testing.assert_series_equal(result[\"date\"], expected_dates, check_names=False)\n+    pd.testing.assert_series_equal(result[\"sum\"], expected_values)\n",
  "sphinx-doc__sphinx-7454": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex a32a965..248e315 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -268,6 +268,10 @@ def test_parse_annotation():\n \n \n def test_pyfunction_signature(app):\n+    doctree = _parse_annotation(\"None\")\n+    # In 'description' mode, None should be a reference to 'None'\n+    assert_node(doctree, ([pending_xref, \"None\"],))\n+    assert_node(doctree[0], pending_xref, reftype=\"obj\", reftarget=\"None\")\n     text = \".. py:function:: hello(name: str) -> str\"\n     doctree = restructuredtext.parse(app, text)\n     assert_node(doctree, (addnodes.index,\n@@ -742,4 +746,3 @@ def test_modindex_common_prefix(app):\n                 IndexEntry('sphinx_intl', 0, 'index', 'module-sphinx_intl', '', '', '')])],\n         True\n     )\n-\n",
  "sphinx-doc__sphinx-8056": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 1d6a8cf..6b87baf 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1332,6 +1332,31 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n \"\"\"\n         self.assertEqual(expected, actual)\n \n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of ``x1``, ``x2``.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of ``x1``, ``x2``.\n+:type x2: :class:`array_like`\n+\"\"\"        \n+        self.assertEqual(expected, actual)\n+\n+    def test_multiple_parameters_with_optional(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of ``x1``, ``x2``.\n+\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of ``x1``, ``x2``.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n         config = Config(napoleon_use_param=True)\n         actual = str(NumpyDocstring(docstring, config))\n         expected = \"\"\"\\\n@@ -1355,6 +1380,31 @@ param1 : MyClass instance\n \"\"\"\n         self.assertEqual(expected, actual)\n \n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of ``x1``, ``x2``.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of ``x1``, ``x2``.\n+:type x2: :class:`array_like`\n+\"\"\"        \n+        self.assertEqual(expected, actual)\n+\n+    def test_multiple_parameters_with_optional(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of ``x1``, ``x2``.\n+\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of ``x1``, ``x2``.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n         config = Config(napoleon_use_param=True)\n         actual = str(NumpyDocstring(dedent(docstring), config))\n         expected = \"\"\"\\\n@@ -1923,6 +1973,31 @@ definition_after_normal_text : int\n                                          first line\n :type definition_after_normal_text: :class:`int`\n \"\"\"\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of ``x1``, ``x2``.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of ``x1``, ``x2``.\n+:type x2: :class:`array_like`\n+\"\"\"        \n+        self.assertEqual(expected, actual)\n+\n+    def test_multiple_parameters_with_optional(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of ``x1``, ``x2``.\n+\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of ``x1``, ``x2``.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n         config = Config(napoleon_use_param=True)\n         actual = str(NumpyDocstring(docstring, config))\n         self.assertEqual(expected, actual)\n",
  "sphinx-doc__sphinx-8551": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex fd4bdc4..1db4c3d 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -773,6 +773,51 @@ def test_pydecoratormethod_signature(app):\n     assert 'deco' in domain.objects\n     assert domain.objects['deco'] == ('index', 'deco', 'method')\n \n+from sphinx import addnodes\n+from sphinx.testing import restructuredtext\n+from sphinx.util.nodes import assert_node\n+from docutils import nodes\n+\n+@pytest.mark.sphinx(freshenv=True)\n+def test_type_rtype_cross_reference_resolution(app):\n+    text = '''\n+    .. py:class:: mod.A\n+    .. py:class:: mod.submod.A\n+    \n+    .. py:function:: f1()\n+       :param mod.A a:\n+       :param mod.submod.A b:\n+       :rtype: mod.A\n+       :rtype: mod.submod.A\n+\n+    .. py:currentmodule:: mod\n+    \n+    .. py:function:: f2()\n+       :param A a:\n+       :param mod.A b:\n+       :param mod.submod.A c:\n+       :rtype: A\n+       :rtype: mod.A\n+       :rtype: mod.submod.A\n+\n+    .. py:currentmodule:: mod.submod\n+    \n+    .. py:function:: f3()\n+       :param A a: BUG: Should link to mod.submod.A\n+       :param mod.A b:\n+       :param mod.submod.A c:\n+       :rtype: A\n+       :rtype: mod.A\n+       :rtype: mod.submod.A\n+    '''\n+    doctree = restructuredtext.parse(app, text)\n+\n+    # Verify no warnings and correct resolution\n+    f3_params = doctree[10][1][0][1]  # Accessing f3's parameters field body\n+    assert_node(f3_params[0][0], nodes.field_name, \"a\")\n+    assert_node(f3_params[0][1][0][0], pending_xref, reftarget=\"mod.submod.A\", refdomain=\"py\", reftype=\"class\")\n+    assert_node(f3_params[2][1][0][0], pending_xref, reftarget=\"mod.submod.A\", refdomain=\"py\", reftype=\"class\")\n+    doctree.pformat()  # Test code simply processes elements to avoid warnings\n \n @pytest.mark.sphinx(freshenv=True)\n def test_module_index(app):\n",
  "sphinx-doc__sphinx-8593": "diff --git a/tests/roots/test-ext-autodoc/target/private.py b/tests/roots/test-ext-autodoc/target/private.py\nindex 677b469..27fcfea 100644\n--- a/tests/roots/test-ext-autodoc/target/private.py\n+++ b/tests/roots/test-ext-autodoc/target/private.py\n@@ -1,3 +1,7 @@\n+\n+PRIVATE_CONSTANT = None  #: :meta private:\n+_public_var = 42  #: :meta public:\n+\n def private_function(name):\n     \"\"\"private_function is a docstring().\n \n@@ -8,4 +12,4 @@ def _public_function(name):\n     \"\"\"public_function is a docstring().\n \n     :meta public:\n-    \"\"\"\n+    \"\"\"\n",
  "sphinx-doc__sphinx-9230": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex e86a758..07248e8 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -904,6 +904,47 @@ def test_canonical_definition_skip(app, warning):\n     assert domain.objects['_io.StringIO'] == ('index', 'io.StringIO', 'class', False)\n \n \n+def test_param_dict_str_str(app):\n+    text = (\".. py:module:: example\\n\"\n+            \".. py:class:: Class\\n\"\n+            \"\\n\"\n+            \"   :param dict(str, str) opc_meta: (optional)\\n\")\n+    doctree = restructuredtext.parse(app, text)\n+\n+    assert_node(doctree, (nodes.target,\n+                          addnodes.index,\n+                          addnodes.index,\n+                          [desc, ([desc_signature, ([desc_annotation, \"class \"],\n+                                                    [desc_addname, \"example.\"],\n+                                                    [desc_name, \"Class\"])],\n+                                  [desc_content, nodes.field_list, nodes.field])]))\n+    assert_node(doctree[3][1][0][0],\n+                ([nodes.field_name, \"Parameters\"],\n+                 [nodes.field_body, nodes.bullet_list, [nodes.list_item, nodes.paragraph]]))\n+\n+    # :param dict(str, str) opc_meta:\n+    assert_node(doctree[3][1][0][0][1][0][0][0],\n+                ([addnodes.literal_strong, \"opc_meta\"],\n+                 \" (\",\n+                 [pending_xref, addnodes.literal_emphasis, \"dict\"],\n+                 [addnodes.literal_emphasis, \"(\"],\n+                 [pending_xref, addnodes.literal_emphasis, \"str\"],\n+                 [addnodes.literal_emphasis, \", \"],\n+                 [pending_xref, addnodes.literal_emphasis, \"str\"],\n+                 [addnodes.literal_emphasis, \")\"],\n+                 \")\",\n+                 \" -- \",\n+                 \"(optional)\"))\n+    assert_node(doctree[3][1][0][0][1][0][0][0][2], pending_xref,\n+                refdomain=\"py\", reftype=\"class\", reftarget=\"dict\",\n+                **{\"py:module\": \"example\", \"py:class\": \"Class\"})\n+    assert_node(doctree[3][1][0][0][1][0][0][0][4], pending_xref,\n+                refdomain=\"py\", reftype=\"class\", reftarget=\"str\",\n+                **{\"py:module\": \"example\", \"py:class\": \"Class\"})\n+    assert_node(doctree[3][1][0][0][1][0][0][0][6], pending_xref,\n+                refdomain=\"py\", reftype=\"class\", reftarget=\"str\",\n+                **{\"py:module\": \"example\", \"py:class\": \"Class\"})\n+\n def test_canonical_duplicated(app, warning):\n     text = (\".. py:class:: mypackage.StringIO\\n\"\n             \"   :canonical: _io.StringIO\\n\"\n",
  "sphinx-doc__sphinx-9258": "",
  "sphinx-doc__sphinx-9673": "diff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex aa0401e..a4b6aac 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -838,6 +838,44 @@ def test_autodoc_typehints_description(app):\n                     confoverrides={'autodoc_typehints': \"description\",\n                                    'autodoc_typehints_description_target': 'documented'})\n def test_autodoc_typehints_description_no_undoc(app):\n+    # Test case for verifying autodoc_typehints_description_target with documented functions\n+    (app.srcdir / 'index.rst').write_text(\n+        '.. autofunction:: target.typehints.decr\\n'\n+        '\\n'\n+        '   :returns: decremented number\\n'\n+        '\\n'\n+    )\n+    app.build()\n+    context = (app.outdir / 'index.txt').read_text()\n+    assert ('target.typehints.decr(a, b=1)\\n'\n+            '\\n'\n+            '   Returns:\\n'\n+            '      decremented number\\n'\n+            '\\n'\n+            '   Return type:\\n'\n+            '      int\\n'\n+            in context)\n+\n+    # Additional test case for a function with Google-style docstring\n+    (app.srcdir / 'index.rst').write_text(\n+        '.. autofunction:: target.typehints.google_style_func\\n'\n+    )\n+    app.build()\n+    context = (app.outdir / 'index.txt').read_text()\n+    assert ('target.typehints.google_style_func(param1, param2=2)\\n'\n+            '\\n'\n+            '   Description.\\n'\n+            '\\n'\n+            '   Parameters:\\n'\n+            '      **param1** -- First parameter.\\n'\n+            '      **param2** -- Second parameter.\\n'\n+            '\\n'\n+            '   Returns:\\n'\n+            '      The returned value.\\n'\n+            '\\n'\n+            '   Return type:\\n'\n+            '      int\\n'\n+            in context)\n     # No :type: or :rtype: will be injected for `incr`, which does not have\n     # a description for its parameters or its return. `tuple_args` does\n     # describe them, so :type: and :rtype: will be added.\n",
  "sympy__sympy-18211": "diff --git a/sympy/solvers/tests/test_solveset.py b/sympy/solvers/tests/test_solveset.py\nindex 7bd9e29..0a78f34 100644\n--- a/sympy/solvers/tests/test_solveset.py\n+++ b/sympy/solvers/tests/test_solveset.py\n@@ -1048,6 +1048,14 @@ def test__solveset_multi():\n             ImageSet(Lambda(((theta,),), (0, theta)), ImageSet(Lambda(theta, (theta,)), Interval(0, pi))))\n \n \n+from sympy import Eq, cos, sin, Reals\n+from sympy.sets.conditionset import ConditionSet\n+\n+def test_issue_18188_fix():\n+    n = Symbol('n')\n+    result = Eq(n*cos(n) - 3*sin(n), 0)\n+    assert solveset(result, n, domain=Reals) == ConditionSet(n, Eq(n*cos(n) - 3*sin(n), 0), Reals)\n+\n def test_conditionset():\n     assert solveset(Eq(sin(x)**2 + cos(x)**2, 1), x, domain=S.Reals) == \\\n         ConditionSet(x, True, S.Reals)\n",
  "sympy__sympy-18698": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex 38de6f6..465cb04 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -3329,7 +3329,16 @@ def test_issue_17988():\n     p = poly(x - 1)\n     M = Matrix([[poly(x + 1), poly(x + 1)]])\n     assert p * M == M * p == Matrix([[poly(x**2 - 1), poly(x**2 - 1)]])\n+from sympy import Symbol, sqf_list\n \n-def test_issue_18205():\n-    assert cancel((2 + I)*(3 - I)) == 7 + I\n+def test_issue_8695():\n+    x = Symbol('x')\n+    p = (x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3\n+    result = (1, [(x**2 + 1, 1), (x - 1, 2), (x**2 - 5*x + 6, 3)])\n+    assert sqf_list(p) == result\n+\n+def test_issue_8695_alternative():\n+    x = Symbol('x')\n+    unexpected = (1, [(x**2 + 1, 1), (x - 1, 2), (x - 3, 3), (x - 2, 3)])\n+    assert sqf_list((x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3) != unexpected\n     assert cancel((2 + I)*(2 - I)) == 5\n",
  "sympy__sympy-19040": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex 6ddf041..59e904c 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -3255,7 +3255,11 @@ def test_issue_5786():\n         (x - I*y)*(z - I*t)), extension=[I])) == -I*t*x - t*y + x*z - I*y*z\n \n \n-def test_noncommutative():\n+def test_issue_18895():\n+    # Test case for the issue where factor drops a (y-1) factor with extension\n+    z = expand((x-1)*(y-1))\n+    # Verify the factor does not drop any part\n+    assert factor(z, extension=[I]) == (x - 1)*(y - 1)\n     class foo(Expr):\n         is_commutative=False\n     e = x/(x + x*y)\n",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..188968e 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"This tests sympy/core/basic.py with (ideally) no reference to subclasses\n of Basic or Atom.\"\"\"\n \n@@ -28,6 +29,19 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+def test_symbol_dict_issue():\n+    from sympy import Symbol\n+    # Test that Symbol does not have a __dict__ attribute\n+    s = Symbol('s')\n+    assert not hasattr(s, '__dict__')\n+    with raises(AttributeError):\n+        s.__dict__\n+        \n+    # Test the presence of __slots__ and its correctness\n+    assert hasattr(s, '__slots__')\n+    assert s.__slots__ == ('name',)\n+\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-24562": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..8837251 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3202,6 +3202,22 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         self.assertEqual(form['field'].id_for_label, 'myCustomID')\n         self.assertEqual(form['field_none'].id_for_label, 'id_field_none')\n \n+    def test_boundfield_subwidget_id_for_label_with_custom_id(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label uses the custom ID from \n+        ChoiceWidget.options['attrs']['id'], if provided.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple\n+            )\n+\n+        form = SomeForm(auto_id='custom_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_field_1')\n+\n     def test_boundfield_widget_type(self):\n         class SomeForm(Form):\n             first_name = CharField()\n",
  "matplotlib__matplotlib-20676": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex b009975..8b6889d 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -301,8 +301,57 @@ def test_tool_line_handle():\n \n     assert tool_line_handle.positions == positions\n \n+import pytest\n+from matplotlib import pyplot as plt\n+from matplotlib import widgets\n+\n+@pytest.mark.parametrize('direction', (\"horizontal\", \"vertical\"))\n+def test_span_selector_bound(direction):\n+    fig, ax = plt.subplots(1, 1)\n+    ax.plot([10, 20], [10, 30])\n+    ax.figure.canvas.draw()\n+    x_bound = ax.get_xbound()\n+    y_bound = ax.get_ybound()\n+\n+    tool = widgets.SpanSelector(ax, print, direction, interactive=True)\n+    assert ax.get_xbound() == x_bound\n+    assert ax.get_ybound() == y_bound\n+\n+    bound = x_bound if direction == 'horizontal' else y_bound\n+    assert tool._edge_handles.positions == list(bound)\n+\n+    press_data = [10.5, 11.5]\n+    move_data = [11, 13]  # Updating selector is done in onmove\n+    release_data = move_data\n+    do_event(tool, 'press', xdata=press_data[0], ydata=press_data[1], button=1)\n+    do_event(tool, 'onmove', xdata=move_data[0], ydata=move_data[1], button=1)\n+\n+    assert ax.get_xbound() == x_bound\n+    assert ax.get_ybound() == y_bound\n+\n+    index = 0 if direction == 'horizontal' else 1\n+    handle_positions = [press_data[index], release_data[index]]\n+    assert tool._edge_handles.positions == handle_positions\n+\n+@pytest.mark.parametrize('plot_data', [([1, 2, 3], [4, 5, 6]), ([-10, -5], [-2, 0])])\n+@pytest.mark.parametrize('direction', (\"horizontal\", \"vertical\"))\n+def test_span_selector_does_not_force_zero_in_limits(plot_data, direction):\n+    fig, ax = plt.subplots()\n+    ax.plot(*plot_data)\n+    ax.figure.canvas.draw()\n+    x_bound = ax.get_xbound()\n+    y_bound = ax.get_ybound()\n+\n+    tool = widgets.SpanSelector(ax, lambda vmin, vmax: None, direction, interactive=True)\n+    assert ax.get_xbound() == x_bound\n+    assert ax.get_ybound() == y_bound\n+\n+    do_event(tool, 'press', xdata=plot_data[0][0], ydata=plot_data[1][0], button=1)\n+    do_event(tool, 'onmove', xdata=plot_data[0][1], ydata=plot_data[1][1], button=1)\n+    do_event(tool, 'release', xdata=plot_data[0][2], ydata=plot_data[1][1], button=1)\n \n-def check_lasso_selector(**kwargs):\n+    assert ax.get_xbound() == x_bound\n+    assert ax.get_ybound() == y_bound\n     ax = get_ax()\n \n     def onselect(verts):\n",
  "scikit-learn__scikit-learn-12682": "diff --git a/sklearn/decomposition/tests/test_dict_learning.py b/sklearn/decomposition/tests/test_dict_learning.py\nindex 35a43f8..ac44cb6 100644\n--- a/sklearn/decomposition/tests/test_dict_learning.py\n+++ b/sklearn/decomposition/tests/test_dict_learning.py\n@@ -51,6 +51,42 @@ def test_dict_learning_shapes():\n     assert_equal(dico.transform(X).shape, (X.shape[0], n_components))\n \n \n+from sklearn.decomposition import SparseCoder\n+from sklearn.linear_model import Lasso\n+import numpy as np\n+import pytest\n+from sklearn.exceptions import ConvergenceWarning\n+\n+def test_sparse_coder_passes_lasso_parameters():\n+    # Define a sample dictionary and data\n+    dictionary = np.array([[1, 0], [0, 1]])\n+    X = np.array([[1, 1]])\n+    \n+    # Parameters to test\n+    transform_algorithm = 'lasso_cd'\n+    transform_alpha = 0.1\n+    transform_max_iter = 50  # set to a low number to test non-convergence\n+\n+    # Create and fit the SparseCoder\n+    with pytest.warns(ConvergenceWarning):  # Expect a warning for non-convergence\n+        coder = SparseCoder(dictionary, transform_algorithm=transform_algorithm,\n+                            transform_alpha=transform_alpha,\n+                            transform_max_iter=transform_max_iter)\n+        coder.fit_transform(X)\n+\n+    # Set a higher max_iter to achieve convergence\n+    transform_max_iter = 5000\n+    with pytest.warns(None) as record:  # No warnings expected\n+        coder = SparseCoder(dictionary, transform_algorithm=transform_algorithm,\n+                            transform_alpha=transform_alpha,\n+                            transform_max_iter=transform_max_iter)\n+        coder.fit_transform(X)\n+    assert not record.list, \"Expected convergence with a higher max_iter\"\n+\n+    # Check that custom max_iter value is correctly set in Lasso\n+    lasso = Lasso(alpha=transform_alpha, max_iter=transform_max_iter)\n+    assert lasso.get_params()['max_iter'] == transform_max_iter\n+\n def test_dict_learning_overcomplete():\n     n_components = 12\n     dico = DictionaryLearning(n_components, random_state=0).fit(X)\n",
  "scikit-learn__scikit-learn-14629": "diff --git a/sklearn/tests/test_multioutput.py b/sklearn/tests/test_multioutput.py\nindex 4b401f3..7849fb0 100644\n--- a/sklearn/tests/test_multioutput.py\n+++ b/sklearn/tests/test_multioutput.py\n@@ -148,6 +148,31 @@ def test_multi_target_sample_weights():\n     assert_almost_equal(rgr.predict(X_test), rgr_w.predict(X_test))\n \n \n+from sklearn.datasets import make_multilabel_classification\n+from sklearn.multioutput import MultiOutputClassifier\n+from sklearn.discriminant_analysis import LinearDiscriminantAnalysis\n+from sklearn.model_selection import cross_val_predict\n+from sklearn.utils._testing import assert_allclose\n+\n+def test_cross_val_predict_proba_with_multioutputclassifier():\n+    # Create a multilabel dataset\n+    X, Y = make_multilabel_classification(n_samples=100, n_features=5, n_classes=3, n_labels=2, random_state=0)\n+\n+    # Instantiate MultiOutputClassifier with a model that supports predict_proba\n+    mo_lda = MultiOutputClassifier(LinearDiscriminantAnalysis())\n+\n+    # Generate cross-validated predictions using predict_proba\n+    pred_proba = cross_val_predict(mo_lda, X, Y, cv=5, method='predict_proba')\n+\n+    # Verify that the output is a list with the same length as the number of outputs\n+    assert isinstance(pred_proba, list)\n+    assert len(pred_proba) == Y.shape[1]\n+\n+    # Check if each element of the list corresponds to the probabilities for a class and sum to 1\n+    for output_pred in pred_proba:\n+        assert output_pred.shape[1] == len(np.unique(Y))\n+        assert_allclose(output_pred.sum(axis=1), 1)\n+\n # Import the data\n iris = datasets.load_iris()\n # create a multiple targets by randomized shuffling and concatenating y.\n",
  "sphinx-doc__sphinx-9658": "",
  "sympy__sympy-13551": "diff --git a/sympy/concrete/tests/test_products.py b/sympy/concrete/tests/test_products.py\nindex 1f1aaf7..a685b23 100644\n--- a/sympy/concrete/tests/test_products.py\n+++ b/sympy/concrete/tests/test_products.py\n@@ -348,6 +348,23 @@ def test_reverse_order():\n            Product(x*y, (x, b + 1, a - 1), (y, 6, 1))\n \n \n+def test_issue_13546():\n+    n = Symbol('n')\n+    k = Symbol('k')\n+    p = Product(n + 1 / 2**k, (k, 0, n-1)).doit()\n+    assert p.subs(n, 2).doit() == S(15) / 2\n+\n+    # Additional test cases to thoroughly test the fix\n+    assert p.subs(n, 3).doit() == S(105) / 8  # Checking for n = 3\n+    assert p.subs(n, 4).doit() == S(1155) / 16  # Checking for n = 4\n+\n+    # Verifying with general symbolic check using q-Pochhammer symbol\n+    from sympy import QPochhammer\n+    expected = QPochhammer(n + 1, 0.5, n).doit()\n+    assert simplify(p.subs(n, 3) - expected.subs(n, 3)) == 0\n+    assert simplify(p.subs(n, 4) - expected.subs(n, 4)) == 0\n+\n+\n def test_issue_9983():\n     n = Symbol('n', integer=True, positive=True)\n     p = Product(1 + 1/n**(S(2)/3), (n, 1, oo))\n@@ -357,4 +374,4 @@ def test_issue_9983():\n \n def test_rewrite_Sum():\n     assert Product(1 - S.Half**2/k**2, (k, 1, oo)).rewrite(Sum) == \\\n-        exp(Sum(log(1 - 1/(4*k**2)), (k, 1, oo)))\n+        exp(Sum(log(1 - 1/(4*k**2)), (k, 1, oo)))\n"
}