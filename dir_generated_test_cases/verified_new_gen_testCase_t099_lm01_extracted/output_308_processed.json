{
  "astropy__astropy-12907": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 88711b0..2f2a1af 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -49,6 +49,12 @@ compound_models = {\n             (np.array([False, False]),\n              np.array([[True], [True]]))\n             ),\n+    'cm_nested': (m.Pix2Sky_TAN() & (m.Linear1D(10) & m.Linear1D(5)),\n+                  (np.array([False, False, True, True]),\n+                   np.array([[True,   True,  False, False],\n+                             [True,   True,  False, False],\n+                             [False, False, True,  False],\n+                             [False, False, False, True]]))),\n     'cm7': (map2 | p2 & sh1,\n             (np.array([False, True]),\n              np.array([[True, False], [False, True]]))\n",
  "astropy__astropy-13236": "",
  "astropy__astropy-13453": "",
  "astropy__astropy-13579": "",
  "astropy__astropy-14096": "",
  "astropy__astropy-14309": "",
  "astropy__astropy-14508": "diff --git a/astropy/io/fits/tests/test_header.py b/astropy/io/fits/tests/test_header.py\nindex 6bdf92c..44c0bfe 100644\n--- a/astropy/io/fits/tests/test_header.py\n+++ b/astropy/io/fits/tests/test_header.py\n@@ -127,6 +127,27 @@ class TestHeaderFunctions(FitsTestCase):\n         c = fits.Card(\"long_int\", -467374636747637647347374734737437)\n         assert str(c) == _pad(\"LONG_INT= -467374636747637647347374734737437\")\n \n+    def test_floating_point_string_representation_card(self):\n+        \"\"\"\n+        Ensures Card formats float values with the correct precision, avoiding\n+        comment truncation\n+        \n+        Regression test for https://github.com/astropy/astropy/issues/14507\n+        \"\"\"\n+        k = \"HIERARCH ABC DEF GH IJKLMN\"\n+        com = \"[m] abcdef ghijklm nopqrstu vw xyzab\"\n+        c = fits.Card(k, 0.009125, com)\n+        expected_str = f\"{k} = 0.009125 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        c = fits.Card(k, 8.95, com)\n+        expected_str = f\"{k} = 8.95 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        c = fits.Card(k, -99.9, com)\n+        expected_str = f\"{k} = -99.9 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n     def test_floating_point_value_card(self):\n         \"\"\"Test Card constructor with floating point value\"\"\"\n \n",
  "astropy__astropy-14539": "diff --git a/astropy/io/fits/tests/test_diff.py b/astropy/io/fits/tests/test_diff.py\nindex 9bf4897..a243ba4 100644\n--- a/astropy/io/fits/tests/test_diff.py\n+++ b/astropy/io/fits/tests/test_diff.py\n@@ -539,7 +539,16 @@ class TestDiff(FitsTestCase):\n         and dimensions.\n         \"\"\"\n \n-        ca1 = Column(\"A\", format=\"L\", array=[True, False])\n+    def test_identical_vla_files(self):\n+        \"\"\"Test identicality of two files containing VLAs.\"\"\"\n+        col = Column('a', format='QD', array=[[0], [0, 0]])\n+        hdu1 = BinTableHDU.from_columns([col])\n+        hdu2 = BinTableHDU.from_columns([col])\n+\n+        diff = TableDataDiff(hdu1.data, hdu2.data)\n+        assert diff.identical\n+        assert diff.diff_total == 0\n+        assert diff.diff_ratio == 0.0\n         ca2 = Column(\"B\", format=\"X\", array=[[0], [1]])\n         ca3 = Column(\"C\", format=\"4I\", dim=\"(2, 2)\", array=[[0, 1, 2, 3], [4, 5, 6, 7]])\n         ca4 = Column(\"D\", format=\"J\", bscale=2.0, array=[0.0, 2.0])\n",
  "astropy__astropy-14995": "",
  "astropy__astropy-7166": "diff --git a/astropy/utils/tests/test_misc.py b/astropy/utils/tests/test_misc.py\nindex 77667e4..ecf9851 100644\n--- a/astropy/utils/tests/test_misc.py\n+++ b/astropy/utils/tests/test_misc.py\n@@ -88,8 +88,20 @@ def test_inherit_docstrings():\n         # TODO: Maybe if __doc__ is None this test should be skipped instead?\n         assert Subclass.__call__.__doc__ == \"FOO\"\n \n+    # Test for property docstring inheritance\n+    class BaseProperty(metaclass=misc.InheritDocstrings):\n+        @property\n+        def bar(self):\n+            \"\"\"BAR\"\"\"\n+            pass\n+\n+    class SubclassProperty(BaseProperty):\n+        @property\n+        def bar(self):\n+            return 42\n \n-def test_set_locale():\n+    if BaseProperty.bar.__doc__ is not None:\n+        assert SubclassProperty.bar.__doc__ == \"BAR\"\n     # First, test if the required locales are available\n     current = locale.setlocale(locale.LC_ALL)\n     try:\n",
  "astropy__astropy-7336": "",
  "astropy__astropy-7606": "diff --git a/astropy/units/tests/test_units.py b/astropy/units/tests/test_units.py\nindex d95b776..de52aea 100644\n--- a/astropy/units/tests/test_units.py\n+++ b/astropy/units/tests/test_units.py\n@@ -172,7 +172,23 @@ def test_multiple_solidus():\n         u.Unit(\"m/s/kg\", format=\"vounit\")\n \n \n-def test_unknown_unit3():\n+import pytest\n+from astropy import units as u\n+\n+def test_unit_equality_with_none():\n+    # Create an UnrecognizedUnit with 'parse_strict' set to 'silent'\n+    unit = u.Unit('asdf', parse_strict='silent')\n+\n+    # Verify that the unit does not equal None (no TypeError should be raised)\n+    assert unit != None  # noqa\n+    assert not (unit == None)  # This ensures the equality operator returns False\n+\n+    # Verify the unit is not in a collection containing None\n+    assert unit not in (None, u.m)\n+\n+    # Verify that a None object is not equal to the unit and vice versa\n+    assert not (None == unit)\n+    assert None != unit\n     unit = u.Unit(\"FOO\", parse_strict='silent')\n     assert isinstance(unit, u.UnrecognizedUnit)\n     assert unit.name == \"FOO\"\n",
  "astropy__astropy-7671": "diff --git a/astropy/utils/tests/test_introspection.py b/astropy/utils/tests/test_introspection.py\nindex 852d721..fbd50a2 100644\n--- a/astropy/utils/tests/test_introspection.py\n+++ b/astropy/utils/tests/test_introspection.py\n@@ -62,8 +62,36 @@ def test_find_mod_objs():\n     assert 'collections.namedtuple' not in fqns\n     assert namedtuple not in objs\n \n+from astropy.utils import minversion\n+from types import ModuleType\n+from distutils.version import LooseVersion\n \n def test_minversion():\n+    test_module = ModuleType(str(\"test_module\"))\n+    test_module.__version__ = '1.14.3'\n+    \n+    # Original test cases\n+    good_versions = ['0.12', '0.12.1', '0.12.0.dev', '0.12dev']\n+    bad_versions = ['1', '1.2rc1']\n+    for version in good_versions:\n+        assert minversion(test_module, version)\n+    for version in bad_versions:\n+        assert not minversion(test_module, version)\n+\n+    # New test cases\n+    # These specifically test the issue raised with LooseVersion\n+    good_versions_extended = ['1.14dev', '1.13', '1.14.2', '1.14.','1.14.0']\n+    bad_versions_extended = ['1.14.4', '1.15', '2.0']\n+\n+    for version in good_versions_extended:\n+        assert minversion(test_module, version), f\"{test_module.__version__} should be >= {version}\"\n+        \n+    for version in bad_versions_extended:\n+        assert not minversion(test_module, version), f\"{test_module.__version__} should not be >= {version}\"\n+        \n+    # Directly test LooseVersion comparison (related to the issue described)\n+    assert LooseVersion('1.14.3') >= LooseVersion('1.14dev')\n+    assert LooseVersion('1.14') < LooseVersion('1.14dev')\n     from types import ModuleType\n     test_module = ModuleType(str(\"test_module\"))\n     test_module.__version__ = '0.12.2'\n@@ -72,4 +100,4 @@ def test_minversion():\n     for version in good_versions:\n         assert minversion(test_module, version)\n     for version in bad_versions:\n-        assert not minversion(test_module, version)\n+        assert not minversion(test_module, version)\n",
  "astropy__astropy-8707": "diff --git a/astropy/io/fits/tests/test_header.py b/astropy/io/fits/tests/test_header.py\nindex a2103c6..2419282 100644\n--- a/astropy/io/fits/tests/test_header.py\n+++ b/astropy/io/fits/tests/test_header.py\n@@ -79,6 +79,31 @@ class TestHeaderFunctions(FitsTestCase):\n         assert header['B'] == 'B'\n         assert header.comments['B'] == 'C'\n \n+    def test_card_from_bytes_latin1(self):\n+        \"\"\"Test loading a Card from a `bytes` object with Latin-1 encoded content.\"\"\"\n+        \n+        c = fits.Card.fromstring(b\"TEST    = 'latin1 encoded content'\")\n+        assert c.keyword == 'TEST'\n+        assert c.value == 'latin1 encoded content'\n+\n+    def test_header_fromstring_bytes_with_sep(self):\n+        \"\"\"Test reading a Header from a `bytes` string with a separator.\"\"\"\n+        \n+        header_data = b\"NAXIS   = 2                                                                      \" \\\n+                      b\"\\nEND                                                                             \"\n+        header = fits.Header.fromstring(header_data, sep='\\n')\n+        \n+        assert header['NAXIS'] == 2\n+        assert len(header) == 1  # should contain only one card\n+\n+    def test_header_fromstring_bytes_with_invalid_end(self):\n+        \"\"\"Test Header.fromstring with a bytes input missing the END card.\"\"\"\n+\n+        header_data = b\"NAXIS   = 0                                                                      \"\n+        # This should raise an exception because it's an incomplete header\n+        with pytest.raises(ValueError):\n+            fits.Header.fromstring(header_data)\n+\n     def test_card_constructor_default_args(self):\n         \"\"\"Test Card constructor with default argument values.\"\"\"\n \n",
  "astropy__astropy-8872": "diff --git a/astropy/units/tests/test_quantity.py b/astropy/units/tests/test_quantity.py\nindex 283420f..c417ede 100644\n--- a/astropy/units/tests/test_quantity.py\n+++ b/astropy/units/tests/test_quantity.py\n@@ -149,6 +149,31 @@ class TestQuantityCreation:\n \n         q5 = u.Quantity(decimal.Decimal('10.25'), u.m, dtype=object)\n         assert q5.dtype == object\n+    def test_float_dtype_preservation(self):\n+        \"\"\"Test that np.float16, np.float32, and other floating-point dtypes are preserved when creating quantities.\"\"\"\n+        a_float16 = np.float16(1.0)\n+        q_float16 = u.Quantity(a_float16, u.m)\n+        assert q_float16.dtype == np.dtype(np.float16), f\"Expected dtype float16, got {q_float16.dtype}\"\n+\n+        a_float32 = np.float32(1.0)\n+        q_float32 = u.Quantity(a_float32, u.m)\n+        assert q_float32.dtype == np.dtype(np.float32), f\"Expected dtype float32, got {q_float32.dtype}\"\n+\n+        a_float64 = np.float64(1.0)\n+        q_float64 = u.Quantity(a_float64, u.m)\n+        assert q_float64.dtype == np.dtype(np.float64), f\"Expected dtype float64, got {q_float64.dtype}\"\n+\n+        # Depending on platform support, np.float128 might not be available.\n+        # If np.float128 is available, test for it; otherwise, skip this step.\n+        if hasattr(np, \"float128\"):\n+            a_float128 = np.float128(1.0)\n+            q_float128 = u.Quantity(a_float128, u.m)\n+            assert q_float128.dtype == np.dtype(np.float128), f\"Expected dtype float128, got {q_float128.dtype}\"\n+\n+        # Testing np.float_ which is typically an alias for np.float64\n+        a_float_ = np.float_(1.0)\n+        q_float_ = u.Quantity(a_float_, u.m)\n+        assert q_float_.dtype == np.dtype(np.float_), f\"Expected dtype float_, got {q_float_.dtype}\"\n \n     def test_copy(self):\n \n",
  "django__django-10097": "diff --git a/tests/validators/tests.py b/tests/validators/tests.py\nindex 90c3285..efdcf38 100644\n--- a/tests/validators/tests.py\n+++ b/tests/validators/tests.py\n@@ -217,6 +217,21 @@ TEST_DATA = [\n     (URLValidator(EXTENDED_SCHEMES), 'git://example.com/', None),\n     (URLValidator(EXTENDED_SCHEMES), 'git+ssh://git@github.com/example/hg-git.git', None),\n \n+    # Invalid URLs with unencoded characters in userinfo\n+    (URLValidator(), 'http://foo@bar@example.com', ValidationError),\n+    (URLValidator(), 'http://foo:bar:baz@example.com', ValidationError),\n+    (URLValidator(), 'http://user:pass@host.com/path?query#fragment', None),  # Valid with encoded '@'\n+    (URLValidator(), 'http://user:pass@host.com:8080', None),  # Valid with encoded '@'\n+    (URLValidator(), 'http://foo:bar/baz@example.com', ValidationError),\n+    (URLValidator(), \"http://invalid-.com/?m=foo@example.com\", ValidationError),\n+    (URLValidator(), \"http://-.~_!$&'()*+,;=%40:80%2f@example.com\", ValidationError),\n+\n+    # Valid URL examples to ensure proper behavior\n+    (URLValidator(), 'http://username:password@example.com', ValidationError),  # ':' not encoded\n+    (URLValidator(), 'http://user%40name:pass%2Fword@example.com', None),  # Encoded '@' and '/'\n+    (URLValidator(), 'http://example.com', None),  # Simple valid URL\n+    (URLValidator(), 'https://username:password@subdomain.example.com/', ValidationError),  # ':' not encoded\n+\n     (URLValidator(EXTENDED_SCHEMES), 'git://-invalid.com', ValidationError),\n     # Trailing newlines not accepted\n     (URLValidator(), 'http://www.djangoproject.com/\\n', ValidationError),\n",
  "django__django-10880": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex 491ba54..c475c75 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1,8 +1,10 @@\n+\n import datetime\n import re\n from decimal import Decimal\n \n from django.core.exceptions import FieldError\n+from django.db.models.expressions import Case, When\n from django.db import connection\n from django.db.models import (\n     Avg, Count, DecimalField, DurationField, F, FloatField, Func, IntegerField,\n@@ -389,7 +391,30 @@ class AggregateTestCase(TestCase):\n         vals = Book.objects.aggregate(Count(\"rating\", distinct=True))\n         self.assertEqual(vals, {\"rating__count\": 4})\n \n-    def test_count_star(self):\n+    \n+    def test_count_distinct_expression(self):\n+        # Test for correct behavior of distinct counting with a condition\n+        aggs = Book.objects.aggregate(\n+            distinct_ratings=Count(Case(When(pages__gt=300, then='rating')), distinct=True),\n+        )\n+        # Assuming the current data setup expects 4 distinct ratings for books with pages > 300\n+        self.assertEqual(aggs['distinct_ratings'], 4)\n+\n+    def test_count_distinct_without_case(self):\n+        # Test distinct counting without a Case condition\n+        aggs = Book.objects.aggregate(\n+            distinct_ratings=Count('rating', distinct=True),\n+        )\n+        # Assuming data has 4 distinct ratings\n+        self.assertEqual(aggs['distinct_ratings'], 4)\n+        \n+    def test_count_case_without_distinct(self):\n+        # Test conditional counting without distinct\n+        aggs = Book.objects.aggregate(\n+            case_ratings=Count(Case(When(pages__gt=300, then='rating'))),\n+        )\n+        # Assuming the current data setup expects 4 total ratings for books with pages > 300\n+        self.assertEqual(aggs['case_ratings'], 6)\n         with self.assertNumQueries(1) as ctx:\n             Book.objects.aggregate(n=Count(\"*\"))\n         sql = ctx.captured_queries[0]['sql']\n",
  "django__django-10914": "",
  "django__django-10973": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex 9eb05c7..c274c1b 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -1,7 +1,9 @@\n+\n import os\n import signal\n from unittest import mock\n \n+import subprocess\n from django.db.backends.postgresql.client import DatabaseClient\n from django.test import SimpleTestCase\n \n@@ -56,7 +58,26 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             )\n         )\n \n-    def test_column(self):\n+    def test_subprocess_run_with_pgpassword(self):\n+        \"\"\"\n+        Test that subprocess.run is called with the correct PGPASSWORD environment variable set.\n+        \"\"\"\n+        dbinfo = {\n+            'database': 'dbname',\n+            'user': 'someuser',\n+            'password': 'correctpassword',\n+            'host': 'localhost',\n+            'port': '5432',\n+        }\n+        expected_args = ['psql', '-U', 'someuser', '-h', 'localhost', '-p', '5432', 'dbname']\n+        \n+        def _mock_subprocess_run(*args, env=None, **kwargs):\n+            self.assertEqual(args[0], expected_args)\n+            self.assertEqual(env.get('PGPASSWORD'), 'correctpassword')\n+            return subprocess.CompletedProcess(args, 0)\n+        \n+        with mock.patch('subprocess.run', new=_mock_subprocess_run):\n+            DatabaseClient.runshell_db(dbinfo)\n         self.assertEqual(\n             self._run_it({\n                 'database': 'dbname',\n@@ -113,4 +134,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         with mock.patch('subprocess.check_call', new=_mock_subprocess_call):\n             DatabaseClient.runshell_db({})\n         # dbshell restores the original handler.\n-        self.assertEqual(sigint_handler, signal.getsignal(signal.SIGINT))\n+        self.assertEqual(sigint_handler, signal.getsignal(signal.SIGINT))\n",
  "django__django-11066": "diff --git a/tests/contenttypes_tests/test_operations.py b/tests/contenttypes_tests/test_operations.py\nindex ff1d778..d3c5ef3 100644\n--- a/tests/contenttypes_tests/test_operations.py\n+++ b/tests/contenttypes_tests/test_operations.py\n@@ -2,6 +2,8 @@ from django.apps.registry import apps\n from django.conf import settings\n from django.contrib.contenttypes import management as contenttypes_management\n from django.contrib.contenttypes.models import ContentType\n+from django.apps import apps\n+from django.contrib.contenttypes.models import ContentType\n from django.core.management import call_command\n from django.db import migrations, models\n from django.test import TransactionTestCase, override_settings\n@@ -38,6 +40,27 @@ class ContentTypeOperationsTests(TransactionTestCase):\n                     self.assertEqual(next_operation.old_model, operation.old_name_lower)\n                     self.assertEqual(next_operation.new_model, operation.new_name_lower)\n \n+    def test_existing_content_type_rename_other_database(self):\n+        ContentType.objects.using('other').create(app_label='contenttypes_tests', model='foo')\n+        other_content_types = ContentType.objects.using('other').filter(app_label='contenttypes_tests')\n+        call_command('migrate', 'contenttypes_tests', database='other', interactive=False, verbosity=0)\n+        self.assertFalse(other_content_types.filter(model='foo').exists())\n+        self.assertTrue(other_content_types.filter(model='renamedfoo').exists())\n+        call_command('migrate', 'contenttypes_tests', 'zero', database='other', interactive=False, verbosity=0)\n+        self.assertTrue(other_content_types.filter(model='foo').exists())\n+        self.assertFalse(other_content_types.filter(model='renamedfoo').exists())\n+\n+    def test_content_type_rename_correct_db_usage(self):\n+        with override_settings(DATABASE_ROUTERS=[self.TestRouter()]):\n+            ContentType.objects.using('other').create(app_label='contenttypes_tests', model='foo')\n+            other_content_types = ContentType.objects.using('other').filter(app_label='contenttypes_tests')\n+            call_command('migrate', 'contenttypes_tests', database='other', interactive=False, verbosity=0)\n+            self.assertFalse(other_content_types.filter(model='foo').exists())\n+            self.assertTrue(other_content_types.filter(model='renamedfoo').exists())\n+            call_command('migrate', 'contenttypes_tests', 'zero', database='other', interactive=False, verbosity=0)\n+            self.assertTrue(other_content_types.filter(model='foo').exists())\n+            self.assertFalse(other_content_types.filter(model='renamedfoo').exists())\n+\n     def test_existing_content_type_rename(self):\n         ContentType.objects.create(app_label='contenttypes_tests', model='foo')\n         call_command('migrate', 'contenttypes_tests', database='default', interactive=False, verbosity=0,)\n@@ -63,4 +86,4 @@ class ContentTypeOperationsTests(TransactionTestCase):\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n         call_command('migrate', 'contenttypes_tests', 'zero', database='default', interactive=False, verbosity=0)\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='foo').exists())\n-        self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n+        self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n",
  "django__django-11095": "diff --git a/tests/generic_inline_admin/tests.py b/tests/generic_inline_admin/tests.py\nindex 9dd9fd9..69e99c1 100644\n--- a/tests/generic_inline_admin/tests.py\n+++ b/tests/generic_inline_admin/tests.py\n@@ -428,4 +428,41 @@ class GenericInlineModelAdminTest(SimpleTestCase):\n         ma = EpisodeAdmin(Episode, self.site)\n         inlines = ma.get_inline_instances(request)\n         for (formset, inline), other_inline in zip(ma.get_formsets_with_inlines(request), inlines):\n-            self.assertIsInstance(formset, other_inline.get_formset(request).__class__)\n+            self.assertIsInstance(formset, other_inline.get_formset(request).__class__)\n+\n+    def test_get_inlines_method(self):\n+        class CustomInline(GenericTabularInline):\n+            model = Media\n+\n+        class SimpleInline(GenericTabularInline):\n+            model = Media\n+\n+        class CustomEpisodeAdmin(admin.ModelAdmin):\n+            inlines = (CustomInline, SimpleInline)\n+\n+            def get_inlines(self, request, obj=None):\n+                if hasattr(request, 'name'):\n+                    if request.name == 'custom':\n+                        return self.inlines[:1]  # Return only CustomInline\n+                    elif request.name == 'simple':\n+                        return self.inlines[1:]  # Return only SimpleInline\n+                return []  # Return no inlines by default\n+            \n+        request = type('Request', (object,), {})()\n+        admin_instance = CustomEpisodeAdmin(Episode, self.site)\n+\n+        # Test default behavior with no 'name' attribute\n+        self.assertEqual(admin_instance.get_inlines(request, None), [])\n+        self.assertEqual(admin_instance.get_inline_instances(request), [])\n+\n+        # Test with 'name' attribute set to 'custom'\n+        request.name = 'custom'\n+        self.assertEqual(admin_instance.get_inlines(request, None), (CustomInline,))\n+        self.assertEqual(len(admin_instance.get_inline_instances(request)), 1)\n+        self.assertIsInstance(admin_instance.get_inline_instances(request)[0], CustomInline)\n+\n+        # Test with 'name' attribute set to 'simple'\n+        request.name = 'simple'\n+        self.assertEqual(admin_instance.get_inlines(request, None), (SimpleInline,))\n+        self.assertEqual(len(admin_instance.get_inline_instances(request)), 1)\n+        self.assertIsInstance(admin_instance.get_inline_instances(request)[0], SimpleInline)\n",
  "django__django-11099": "",
  "django__django-11119": "diff --git a/tests/template_tests/test_engine.py b/tests/template_tests/test_engine.py\nindex ba32db8..9f8e616 100644\n--- a/tests/template_tests/test_engine.py\n+++ b/tests/template_tests/test_engine.py\n@@ -12,6 +12,29 @@ OTHER_DIR = os.path.join(ROOT, 'other_templates')\n \n class RenderToStringTest(SimpleTestCase):\n \n+    def test_autoescape_off(self):\n+        engine = Engine(dirs=[TEMPLATE_DIR], autoescape=False)\n+        self.assertEqual(\n+            engine.render_to_string('test_context.html', {'obj': '<script>'}),\n+            'obj:<script>\\n',\n+        )\n+\n+    def test_autoescape_on(self):\n+        engine = Engine(dirs=[TEMPLATE_DIR], autoescape=True)\n+        # It should escape the '<script>' string to '&lt;script&gt;'\n+        self.assertEqual(\n+            engine.render_to_string('test_context.html', {'obj': '<script>'}),\n+            'obj:&lt;script&gt;\\n',\n+        )\n+\n+    def test_autoescape_default(self):\n+        # Default autoescape should be True in most templates\n+        engine = Engine(dirs=[TEMPLATE_DIR])\n+        self.assertEqual(\n+            engine.render_to_string('test_context.html', {'obj': '<test>'}),\n+            'obj:&lt;test&gt;\\n',\n+        )\n+\n     def setUp(self):\n         self.engine = Engine(dirs=[TEMPLATE_DIR])\n \n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..fdb1904 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -417,7 +417,9 @@ class HttpResponseTests(unittest.TestCase):\n         r = HttpResponse(lazystr('helloworld'))\n         self.assertEqual(r.content, b'helloworld')\n \n-    def test_file_interface(self):\n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview content'))\n+        self.assertEqual(r.content, b'memoryview content')\n         r = HttpResponse()\n         r.write(b\"hello\")\n         self.assertEqual(r.tell(), 5)\n",
  "django__django-11141": "",
  "django__django-11149": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 296cfba..64097fa 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -622,6 +622,13 @@ class TestInlinePermissions(TestCase):\n         self.assertNotContains(response, 'Add another Inner2')\n         self.assertNotContains(response, 'id=\"id_inner2_set-TOTAL_FORMS\"')\n \n+    def test_inline_add_view_m2m_no_permissions(self):\n+        # Verify that no permissions exist by default for MM relationships\n+        response = self.client.get(reverse('admin:admin_inlines_author_add'))\n+        # No view permission on books, so no inline\n+        self.assertNotContains(response, '<h2>Author-book relationships</h2>')\n+        self.assertNotContains(response, 'Add another Author-Book Relationship')\n+\n     def test_inline_change_m2m_noperm(self):\n         response = self.client.get(self.author_change_url)\n         # No change permission on books, so no inline\n@@ -636,6 +643,19 @@ class TestInlinePermissions(TestCase):\n         self.assertNotContains(response, 'Add another Inner2')\n         self.assertNotContains(response, 'id=\"id_inner2_set-TOTAL_FORMS\"')\n \n+    def test_inline_view_only_m2m_view_perm(self):\n+        # Add view_book permission, simulate view-only permission scenario\n+        permission = Permission.objects.get(codename='view_book', content_type=self.book_ct)\n+        self.user.user_permissions.add(permission)\n+        response = self.client.get(self.author_change_url)\n+        # View-only permissions should restrict add/change/delete\n+        self.assertContains(response, '<h2>Author-book relationships</h2>')\n+        # Ensure we have view-only permissions\n+        self.assertIs(response.context['inline_admin_formset'].has_view_permission, True)\n+        self.assertIs(response.context['inline_admin_formset'].has_add_permission, False)\n+        self.assertIs(response.context['inline_admin_formset'].has_change_permission, False)\n+        self.assertIs(response.context['inline_admin_formset'].has_delete_permission, False)\n+        \n     def test_inline_add_m2m_add_perm(self):\n         permission = Permission.objects.get(codename='add_book', content_type=self.book_ct)\n         self.user.user_permissions.add(permission)\n",
  "django__django-11163": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex b25d077..e7cd9b0 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2900,7 +2900,31 @@ class StrictAssignmentTests(SimpleTestCase):\n \n \n class ModelToDictTests(TestCase):\n-    def test_many_to_many(self):\n+    def test_model_to_dict_with_empty_fields_list(self):\n+        bw = BetterWriter.objects.create(name='Joe Better', score=10)\n+        # Test when fields is an empty list, it should return an empty dict\n+        self.assertEqual(model_to_dict(bw, fields=[]), {})\n+\n+    def test_model_to_dict_with_specific_fields(self):\n+        bw = BetterWriter.objects.create(name='Joe Better', score=10)\n+        # Test when fields are specified, only those fields are returned\n+        self.assertEqual(\n+            sorted(model_to_dict(bw, fields=['id', 'name'])), \n+            ['id', 'name']\n+        )\n+\n+    def test_model_to_dict_with_excluded_fields(self):\n+        bw = BetterWriter.objects.create(name='Joe Better', score=10)\n+        # Test when exclude is an empty list, all fields should be returned\n+        self.assertEqual(\n+            sorted(model_to_dict(bw, exclude=[])),\n+            ['id', 'name', 'score', 'writer_ptr']\n+        )\n+        # Test when certain fields are excluded\n+        self.assertEqual(\n+            sorted(model_to_dict(bw, exclude=['id', 'name'])), \n+            ['score', 'writer_ptr']\n+        )\n         \"\"\"Data for a ManyToManyField is a list rather than a lazy QuerySet.\"\"\"\n         blue = Colour.objects.create(name='blue')\n         red = Colour.objects.create(name='red')\n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..0aaf954 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,3 +1,4 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n@@ -471,7 +472,14 @@ class FastDeleteTests(TestCase):\n         self.assertEqual(User.objects.count(), 1)\n         self.assertTrue(User.objects.filter(pk=u2.pk).exists())\n \n-    def test_fast_delete_joined_qs(self):\n+    def test_fast_delete_instance_set_pk_none(self):\n+        from django.db.models.deletion import Collector  # Ensure import exists\n+        u = User.objects.create()\n+        # Ensure the user can be fast-deleted\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        u.delete()\n+        self.assertIsNone(u.pk)\n         a = Avatar.objects.create(desc='a')\n         User.objects.create(avatar=a)\n         u2 = User.objects.create()\n",
  "django__django-11206": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 5fc4bdd..53cdf0e 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -95,6 +95,10 @@ class TestNumberFormat(SimpleTestCase):\n             ('1e-11', 8, '0.00000000'),\n             ('1' + ('0' * 300), 3, '1.000e+300'),\n             ('0.{}1234'.format('0' * 299), 3, '1.234e-300'),\n+            ('0.{}1'.format('0' * 199), 2, '0.00'),  # Test for very small number with 200 zeros\n+            ('0.{}1'.format('0' * 200), 2, '0.00'),  # Test edge case of exactly 200 zeros with decimal_pos\n+            ('1e-200', 2, '0.00'),  # Direct test case from issue description\n+            ('1e-199', 2, '0.00'),  # Direct test case from issue description, smaller than threshold\n         ]\n         for value, decimal_pos, expected_value in tests:\n             with self.subTest(value=value):\n",
  "django__django-11211": "",
  "django__django-11239": "",
  "django__django-11265": "diff --git a/tests/filtered_relation/tests.py b/tests/filtered_relation/tests.py\nindex a587c22..6eaac26 100644\n--- a/tests/filtered_relation/tests.py\n+++ b/tests/filtered_relation/tests.py\n@@ -82,6 +82,37 @@ class FilteredRelationTests(TestCase):\n                     (self.book4, self.author1),\n                 ], lambda x: (x, x.author_join))\n \n+    def test_with_exclude(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).exclude(book_alice__isnull=False),\n+            [self.author2]\n+        )\n+\n+    def test_exclude_with_nonexistent_books(self):\n+        # Additional test case for an Author with no matching books at all.\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_bob=FilteredRelation('book', condition=Q(book__title__iexact='poem by bob')),\n+            ).exclude(book_bob__isnull=False),\n+            [self.author1, self.author2]\n+        )\n+\n+    def test_exclude_with_multiple_conditions(self):\n+        # Additional test case using multiple conditions\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation(\n+                    'book', condition=Q(\n+                        Q(book__title__iexact='poem by alice') |\n+                        Q(book__state=Book.RENTED)\n+                    ),\n+                ),\n+            ).exclude(book_alice__isnull=False),\n+            [self.author2]\n+        )\n+\n     def test_without_join(self):\n         self.assertSequenceEqual(\n             Author.objects.annotate(\n",
  "django__django-11276": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex 4051a05..4771491 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -27,7 +27,7 @@ class TestUtilsHtml(SimpleTestCase):\n             ('<', '&lt;'),\n             ('>', '&gt;'),\n             ('\"', '&quot;'),\n-            (\"'\", '&#39;'),\n+            (\"'\", '&#x27;'),\n         )\n         # Substitution patterns for testing the above items.\n         patterns = (\"%s\", \"asdf%sfdsa\", \"%s1\", \"1%sb\")\n",
  "django__django-11292": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex b016284..3fd6f73 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -243,6 +243,28 @@ class CommandRunTests(AdminScriptTestCase):\n         self.assertNoOutput(err)\n         self.assertEqual(out.strip(), '/PREFIX/some/url/')\n \n+    def test_skip_checks(self):\n+        \"\"\"\n+        Test that the --skip-checks option allows running commands without system checks.\n+        \"\"\"\n+        self.write_settings('settings.py', apps=['django.contrib.staticfiles', 'user_commands'], sdict={\n+            # Setup a scenario that would usually trigger a check failure\n+            'STATICFILES_DIRS': '\"foo\"',\n+        })\n+        out, err = self.run_manage(['set_option', '--skip-checks', '--set', 'foo'])\n+        self.assertNoOutput(err)\n+        self.assertEqual(out.strip(), 'Set foo')\n+\n+    def test_skip_checks_not_present(self):\n+        \"\"\"\n+        Test that without --skip-checks, the command should fail due to system checks.\n+        \"\"\"\n+        self.write_settings('settings.py', apps=['django.contrib.staticfiles', 'user_commands'], sdict={\n+            'STATICFILES_DIRS': '\"foo\"',\n+        })\n+        with self.assertRaises(CommandError):\n+            self.run_manage(['set_option', '--set', 'foo'])\n+\n     def test_disallowed_abbreviated_options(self):\n         \"\"\"\n         To avoid conflicts with custom options, commands don't allow\n@@ -254,6 +276,8 @@ class CommandRunTests(AdminScriptTestCase):\n         self.assertEqual(out.strip(), 'Set foo')\n \n \n+from django.core.management import CommandError\n+\n class UtilsTests(SimpleTestCase):\n \n     def test_no_existent_external_program(self):\n",
  "django__django-11333": "",
  "django__django-11451": "diff --git a/tests/auth_tests/test_auth_backends.py b/tests/auth_tests/test_auth_backends.py\nindex b010b42..f5d564b 100644\n--- a/tests/auth_tests/test_auth_backends.py\n+++ b/tests/auth_tests/test_auth_backends.py\n@@ -227,6 +227,18 @@ class BaseModelBackendTest:\n         self.assertEqual(CountingMD5PasswordHasher.calls, 1)\n \n \n+from django.test import TestCase, override_settings\n+from django.contrib.auth import authenticate, get_user_model\n+\n+class CountingMD5PasswordHasher:\n+    calls = 0\n+\n+    @classmethod\n+    def set_password(cls, password):\n+        cls.calls += 1\n+\n+User = get_user_model()\n+\n class ModelBackendTest(BaseModelBackendTest, TestCase):\n     \"\"\"\n     Tests for the ModelBackend using the default User model.\n@@ -242,7 +254,21 @@ class ModelBackendTest(BaseModelBackendTest, TestCase):\n             password='test',\n         )\n \n-    def test_authenticate_inactive(self):\n+    def test_authentication_without_credentials(self):\n+        \"\"\"\n+        Test to ensure that authenticate does not hit the database nor call the password hasher\n+        when username or password is None.\n+        \"\"\"\n+        CountingMD5PasswordHasher.calls = 0\n+        for credentials in (\n+            {},\n+            {'username': getattr(self.user, self.UserModel.USERNAME_FIELD)},\n+            {'password': 'test'},\n+        ):\n+            with self.subTest(credentials=credentials):\n+                with self.assertNumQueries(0):\n+                    authenticate(**credentials)\n+                self.assertEqual(CountingMD5PasswordHasher.calls, 0)\n         \"\"\"\n         An inactive user can't authenticate.\n         \"\"\"\n",
  "django__django-11490": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex e627a0d..12591e5 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -124,6 +124,24 @@ class QuerySetSetOperationTests(TestCase):\n         reserved_name = qs1.union(qs1).values_list('name', 'order', 'id').get()\n         self.assertEqual(reserved_name[:2], ('a', 2))\n \n+    def test_union_with_variable_columns(self):\n+        ReservedName.objects.create(name='a', order=2, id=1)\n+        qs1 = ReservedName.objects.all()\n+        \n+        # Test altering columns using values()\n+        reserved_name = qs1.union(qs1).values('order').get()\n+        self.assertEqual(reserved_name['order'], 2)\n+        \n+        reserved_name = qs1.union(qs1).values('name').get()\n+        self.assertEqual(reserved_name['name'], 'a')\n+\n+        # Test altering columns using values_list()\n+        reserved_name = qs1.union(qs1).values_list('order', flat=True).get()\n+        self.assertEqual(reserved_name, 2)\n+        \n+        reserved_name = qs1.union(qs1).values_list('name', flat=True).get()\n+        self.assertEqual(reserved_name, 'a')\n+\n     def test_union_with_two_annotated_values_list(self):\n         qs1 = Number.objects.filter(num=1).annotate(\n             count=Value(0, IntegerField()),\n",
  "django__django-11532": "diff --git a/tests/mail/tests.py b/tests/mail/tests.py\nindex a6f0e17..3d1aa9a 100644\n--- a/tests/mail/tests.py\n+++ b/tests/mail/tests.py\n@@ -10,6 +10,7 @@ import threading\n from email import charset, message_from_binary_file, message_from_bytes\n from email.header import Header\n from email.mime.text import MIMEText\n+from unittest import mock\n from email.utils import parseaddr\n from io import StringIO\n from smtplib import SMTP, SMTPAuthenticationError, SMTPException\n@@ -360,7 +361,12 @@ class MailTests(HeadersCheckMixin, SimpleTestCase):\n         msg.attach('example.txt', 'Text file content', 'text/plain')\n         self.assertIn(html_content, msg.message().as_string())\n \n-    def test_none_body(self):\n+    @mock.patch('django.core.mail.message.DNS_NAME', '\u6f22\u5b57')\n+    def test_non_ascii_dns_non_unicode_email(self, mocked_getfqdn):\n+        delattr(mail.message.DNS_NAME, '_fqdn')\n+        email = EmailMessage('subject', 'content', 'from@example.com', ['to@example.com'])\n+        email.encoding = 'iso-8859-1'\n+        self.assertIn('@xn--p8s937b>', email.message()['Message-ID'])\n         msg = EmailMessage('subject', None, 'from@example.com', ['to@example.com'])\n         self.assertEqual(msg.body, '')\n         self.assertEqual(msg.message().get_payload(), '')\n",
  "django__django-11551": "diff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex debaf8a..5c0180d 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -1,9 +1,10 @@\n+\n from django import forms\n from django.contrib.admin import BooleanFieldListFilter, SimpleListFilter\n from django.contrib.admin.options import VERTICAL, ModelAdmin, TabularInline\n from django.contrib.admin.sites import AdminSite\n from django.core.checks import Error\n-from django.db.models import F\n+from django.db.models import F, Field, Model\n from django.db.models.functions import Upper\n from django.forms.models import BaseModelFormSet\n from django.test import SimpleTestCase\n@@ -12,6 +13,69 @@ from .models import (\n     Band, Song, User, ValidationTestInlineModel, ValidationTestModel,\n )\n \n+class ListDisplayValidationTests(CheckTestCase):\n+\n+    def test_valid_field_accessible_via_instance(self):\n+        class PositionField(Field):\n+            \"\"\"Custom field accessible only via instance.\"\"\"\n+            def contribute_to_class(self, cls, name):\n+                super().contribute_to_class(cls, name)\n+                setattr(cls, self.name, self)\n+\n+            def __get__(self, instance, owner):\n+                if instance is None:\n+                    raise AttributeError()\n+\n+        class TestModel(Model):\n+            field = PositionField()\n+\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = ('field',)\n+\n+        self.assertIsValid(TestModelAdmin, TestModel)\n+\n+    def test_invalid_field_no_attr(self):\n+        class PositionField(Field):\n+            \"\"\"Custom field accessible only via instance.\"\"\"\n+            def contribute_to_class(self, cls, name):\n+                super().contribute_to_class(cls, name)\n+                setattr(cls, self.name, self)\n+\n+            def __get__(self, instance, owner):\n+                if instance is None:\n+                    raise AttributeError()\n+\n+        class TestModel(Model):\n+            field = PositionField()\n+\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = ('non_existent_field',)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin, TestModel,\n+            \"The value of 'list_display[0]' refers to 'non_existent_field', \"\n+            \"which is not a callable, an attribute of 'TestModelAdmin', \"\n+            \"or an attribute or method on 'app_label.TestModel'.\",\n+            'admin.E108'\n+        )\n+\n+    def test_many_to_many_field(self):\n+        class ManyToManyFieldMock(Field):\n+            \"\"\"Mock ManyToManyField.\"\"\"\n+            pass\n+\n+        class TestModel(Model):\n+            many_to_many_field = ManyToManyFieldMock()\n+\n+        class TestModelAdmin(ModelAdmin):\n+            list_display = ('many_to_many_field',)\n+\n+        self.assertIsInvalid(\n+            TestModelAdmin, TestModel,\n+            \"The value of 'list_display[0]' must not be a ManyToManyField.\",\n+            'admin.E109'\n+        )\n+\n \n class CheckTestCase(SimpleTestCase):\n \n",
  "django__django-11555": "",
  "django__django-11603": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex 2b8f813..d3c9c5e 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -405,9 +405,45 @@ class AggregateTestCase(TestCase):\n \n     def test_non_grouped_annotation_not_in_group_by(self):\n         \"\"\"\n+    \n+    def test_avg_distinct(self):\n+        result = Book.objects.aggregate(average=Avg('rating', distinct=True))\n+        self.assertEqual(result['average'], 4.125)\n+\n+    def test_sum_distinct(self):\n+        result = Book.objects.aggregate(total=Sum('rating', distinct=True))\n+        self.assertEqual(result['total'], 16.5)\n+\n+    def test_min_distinct(self):\n+        # Although pointless to have DISTINCT with MIN, ensure no error occurs\n+        result = Book.objects.aggregate(minimum=Min('rating', distinct=True))\n+        self.assertEqual(result['minimum'], 3.0)  # Assuming 3.0 is the minimum rating in the test data set.\n+\n+    def test_max_distinct(self):\n+        # Although pointless to have DISTINCT with MAX, ensure no error occurs\n+        result = Book.objects.aggregate(maximum=Max('rating', distinct=True))\n+        self.assertEqual(result['maximum'], 5.0)  # Assuming 5.0 is the maximum rating in the test data set.\n         An annotation not included in values() before an aggregate should be\n         excluded from the group by clause.\n         \"\"\"\n+    \n+    def test_avg_distinct(self):\n+        result = Book.objects.aggregate(average=Avg('rating', distinct=True))\n+        self.assertEqual(result['average'], 4.125)\n+\n+    def test_sum_distinct(self):\n+        result = Book.objects.aggregate(total=Sum('rating', distinct=True))\n+        self.assertEqual(result['total'], 16.5)\n+\n+    def test_min_distinct(self):\n+        # Although pointless to have DISTINCT with MIN, ensure no error occurs\n+        result = Book.objects.aggregate(minimum=Min('rating', distinct=True))\n+        self.assertEqual(result['minimum'], 3.0)  # Assuming 3.0 is the minimum rating in the test data set.\n+\n+    def test_max_distinct(self):\n+        # Although pointless to have DISTINCT with MAX, ensure no error occurs\n+        result = Book.objects.aggregate(maximum=Max('rating', distinct=True))\n+        self.assertEqual(result['maximum'], 5.0)  # Assuming 5.0 is the maximum rating in the test data set.\n         qs = (\n             Book.objects.annotate(xprice=F('price')).filter(rating=4.0).values('rating')\n                 .annotate(count=Count('publisher_id', distinct=True)).values('count', 'rating').order_by('count')\n",
  "django__django-11740": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex a98fff5..c331f6a 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -584,8 +584,40 @@ class AutodetectorTests(TestCase):\n             self.make_project_state(after_states),\n             questioner,\n         )._detect_changes()\n+    def test_alter_uuid_field_to_fk_with_dependency(self):\n+        \"\"\"\n+        Test that altering a UUID field to a ForeignKey field creates the dependencies correctly.\n+        \"\"\"\n+        # Initial state with UUID field\n+        before = [\n+            ModelState(\"testapp1\", \"App1\", [\n+                (\"id\", models.UUIDField(primary_key=True)),\n+                (\"text\", models.CharField(max_length=100)),\n+                (\"another_app\", models.UUIDField(null=True, blank=True)),\n+            ]),\n+            ModelState(\"testapp2\", \"App2\", [\n+                (\"id\", models.UUIDField(primary_key=True)),\n+                (\"text\", models.CharField(max_length=100)),\n+            ])\n+        ]\n \n-    def test_arrange_for_graph(self):\n+        # State after changing UUID field to ForeignKey\n+        after = [\n+            ModelState(\"testapp1\", \"App1\", [\n+                (\"id\", models.UUIDField(primary_key=True)),\n+                (\"text\", models.CharField(max_length=100)),\n+                (\"another_app\", models.ForeignKey(\"testapp2.App2\", null=True, blank=True, on_delete=models.SET_NULL)),\n+            ]),\n+            ModelState(\"testapp2\", \"App2\", [\n+                (\"id\", models.UUIDField(primary_key=True)),\n+                (\"text\", models.CharField(max_length=100)),\n+            ])\n+        ]\n+\n+        changes = self.get_changes(before, after)\n+        self.assertNumberMigrations(changes, 'testapp1', 1)\n+        self.assertOperationTypes(changes, 'testapp1', 0, [\"AlterField\"])\n+        self.assertMigrationDependencies(changes, 'testapp1', 0, [(\"testapp2\", \"__first__\")])\n         \"\"\"Tests auto-naming of migrations for graph matching.\"\"\"\n         # Make a fake graph\n         graph = MigrationGraph()\n@@ -2399,4 +2431,4 @@ class AutodetectorTests(TestCase):\n         changes = self.get_changes([Animal, Dog], [Animal])\n         self.assertNumberMigrations(changes, 'app', 1)\n         self.assertOperationTypes(changes, 'app', 0, ['DeleteModel'])\n-        self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n+        self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n",
  "django__django-11749": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex a0e1530..61cb677 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -224,7 +224,38 @@ class CommandTests(SimpleTestCase):\n         management.call_command('subparser_dest', 'foo', bar=12, stdout=out)\n         self.assertIn('bar', out.getvalue())\n \n-    def test_subparser_dest_required_args(self):\n+    def test_mutually_exclusive_group_with_kwargs(self):\n+        # Test mutually exclusive group with kwargs\n+        from django.core.management import BaseCommand\n+\n+        class MyCommand(BaseCommand):\n+            def add_arguments(self, parser):\n+                group = parser.add_mutually_exclusive_group(required=True)\n+                group.add_argument('--shop-id', nargs='?', type=int, default=None, dest='shop_id')\n+                group.add_argument('--shop', nargs='?', type=str, default=None, dest='shop_name')\n+\n+            def handle(self, *args, **options):\n+                if options['shop_id'] is not None:\n+                    self.stdout.write('shop_id')\n+                elif options['shop_name'] is not None:\n+                    self.stdout.write('shop_name')\n+\n+        out = io.StringIO()\n+\n+        # This should not raise an error\n+        management.call_command(MyCommand(), shop_id=1, stdout=out)\n+        self.assertIn('shop_id', out.getvalue())\n+\n+        out = io.StringIO()\n+        # This should not raise an error.\n+        management.call_command(MyCommand(), shop_name='SuperShop', stdout=out)\n+        self.assertIn('shop_name', out.getvalue())\n+\n+        out = io.StringIO()\n+        # This should raise an error since neither argument is provided\n+        with self.assertRaises(CommandError) as context:\n+            management.call_command(MyCommand(), stdout=out)\n+        self.assertIn('one of the arguments --shop-id --shop is required', str(context.exception))\n         out = StringIO()\n         management.call_command('subparser_required', 'foo_1', 'foo_2', bar=12, stdout=out)\n         self.assertIn('bar', out.getvalue())\n",
  "django__django-11790": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 440150b..544b6e2 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -414,6 +414,8 @@ class AuthenticationFormTest(TestDataMixin, TestCase):\n \n     @override_settings(AUTH_USER_MODEL='auth_tests.CustomEmailField')\n     def test_username_field_max_length_matches_user_model(self):\n+        form = AuthenticationForm()\n+        self.assertEqual(form.fields['username'].widget.attrs.get('maxlength'), 255)\n         self.assertEqual(CustomEmailField._meta.get_field('username').max_length, 255)\n         data = {\n             'username': 'u' * 255,\n@@ -437,6 +439,18 @@ class AuthenticationFormTest(TestDataMixin, TestCase):\n         self.assertEqual(form.fields['username'].max_length, 254)\n         self.assertEqual(form.errors, {})\n \n+    def test_username_field_max_length_defaults_to_254_in_widget(self):\n+        with override_settings(AUTH_USER_MODEL='auth_tests.IntegerUsernameUser'):\n+            form = AuthenticationForm()\n+            self.assertEqual(form.fields['username'].widget.attrs.get('maxlength'), 254)\n+\n+    def test_custom_username_field_max_length(self):\n+        class CustomAuthenticationForm(AuthenticationForm):\n+            username = forms.CharField(max_length=100)\n+\n+        form = CustomAuthenticationForm()\n+        self.assertEqual(form.fields['username'].widget.attrs.get('maxlength'), 100)\n+\n     def test_username_field_label(self):\n \n         class CustomAuthenticationForm(AuthenticationForm):\n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..fad21a6 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -247,7 +247,23 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set())\n         )\n \n-    def test_serialize_lazy_objects(self):\n+    def test_enum_translation_issue(self):\n+        from django.utils.translation import gettext_lazy as _\n+\n+        class Status(enum.Enum):\n+            GOOD = _('Good')\n+            BAD = _('Bad')\n+\n+        field = models.CharField(default=Status.GOOD, choices=[(m.name, m) for m in Status])\n+        string = MigrationWriter.serialize(field)[0]\n+\n+        self.assertEqual(\n+            string,\n+            \"models.CharField(choices=[\"\n+            \"('GOOD', migrations.test_writer.Status['GOOD']), \"\n+            \"('BAD', migrations.test_writer.Status['BAD'])], \"\n+            \"default=migrations.test_writer.Status['GOOD'])\"\n+        )\n         pattern = re.compile(r'^foo$')\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..522da4e 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,3 +1,4 @@\n+\n import unittest\n from datetime import datetime\n \n@@ -307,11 +308,37 @@ class ETagProcessingTests(unittest.TestCase):\n         self.assertEqual(quote_etag('W/\"etag\"'), 'W/\"etag\"')  # quoted, weak\n \n \n+from unittest import mock\n+\n class HttpDateProcessingTests(unittest.TestCase):\n     def test_http_date(self):\n         t = 1167616461.0\n         self.assertEqual(http_date(t), 'Mon, 01 Jan 2007 01:54:21 GMT')\n \n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850_two_digit_year(self, mocked_datetime):\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+        utcnow_1 = datetime(2019, 11, 6, 8, 49, 37)\n+        utcnow_2 = datetime(2020, 11, 6, 8, 49, 37)\n+        utcnow_3 = datetime(2048, 11, 6, 8, 49, 37)\n+        tests = (\n+            (utcnow_1, 'Tuesday, 31-Dec-69 08:49:37 GMT', datetime(1969, 12, 31, 8, 49, 37)),\n+            (utcnow_1, 'Tuesday, 10-Nov-70 08:49:37 GMT', datetime(1970, 11, 10, 8, 49, 37)),\n+            (utcnow_1, 'Sunday, 06-Nov-94 08:49:37 GMT', datetime(1994, 11, 6, 8, 49, 37)),\n+            (utcnow_2, 'Wednesday, 31-Dec-70 08:49:37 GMT', datetime(1970, 12, 31, 8, 49, 37)),\n+            (utcnow_2, 'Friday, 31-Dec-71 08:49:37 GMT', datetime(1971, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Sunday, 31-Dec-00 08:49:37 GMT', datetime(2000, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Friday, 31-Dec-99 08:49:37 GMT', datetime(1999, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Saturday, 31-Dec-49 08:49:37 GMT', datetime(2049, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Saturday, 31-Dec-50 08:49:37 GMT', datetime(1950, 12, 31, 8, 49, 37)),\n+        )\n+        for utcnow, rfc850str, expected_date in tests:\n+            with self.subTest(rfc850str=rfc850str):\n+                mocked_datetime.utcnow.return_value = utcnow\n+                parsed = parse_http_date(rfc850str)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n+\n     def test_parsing_rfc1123(self):\n         parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n",
  "django__django-11880": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 95afc0d..348c1c5 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3672,7 +3672,37 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n             '<input type=\"hidden\" name=\"data\" id=\"id_data\"></td></tr>'\n         )\n \n-    def test_field_named_data(self):\n+import copy\n+from django.forms import CharField, Form\n+from django.test import SimpleTestCase\n+\n+class FieldDeepCopyTests(SimpleTestCase):\n+    def test_field_deep_copy_error_messages(self):\n+        class CustomCharField(CharField):\n+            def __init__(self, **kwargs):\n+                kwargs['error_messages'] = {'invalid': 'Form custom error message.'}\n+                super().__init__(**kwargs)\n+\n+        field = CustomCharField()\n+        field_copy = copy.deepcopy(field)\n+        self.assertIsInstance(field_copy, CustomCharField)\n+        self.assertIsNot(field_copy.error_messages, field.error_messages)\n+        self.assertEqual(field_copy.error_messages, field.error_messages)\n+\n+    def test_modifying_error_messages_on_copied_field(self):\n+        class CustomCharField(CharField):\n+            def __init__(self, **kwargs):\n+                kwargs['invalid'] = 'Original error message.'\n+                super().__init__(**kwargs)\n+\n+        field = CustomCharField(error_messages={'invalid': 'Original error message.'})\n+        field_copy = copy.deepcopy(field)\n+        field_copy.error_messages['invalid'] = 'Modified error message.'\n+        \n+        # Original field should remain unchanged\n+        self.assertEqual(field.error_messages['invalid'], 'Original error message.')\n+        # Copied field should have the modified error message\n+        self.assertEqual(field_copy.error_messages['invalid'], 'Modified error message.')\n         class DataForm(Form):\n             data = CharField(max_length=10)\n \n",
  "django__django-11951": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex f2f6bbd..f6a2792 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -1,3 +1,5 @@\n+\n+from math import ceil\n from operator import attrgetter\n \n from django.db import IntegrityError, NotSupportedError, connection\n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..454462c 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -32,6 +32,44 @@ class Vehicle(models.IntegerChoices):\n     __empty__ = _('(Unknown)')\n \n \n+from django.test import TestCase\n+from django.db import models\n+\n+class CustomIntegerChoices(models.IntegerChoices):\n+    CHOICE_ONE = 1, 'One'\n+    CHOICE_TWO = 2, 'Two'\n+\n+class CustomIntegerModel(models.Model):\n+    number = models.IntegerField(choices=CustomIntegerChoices.choices)\n+\n+class CustomTextChoices(models.TextChoices):\n+    CHOICE_A = 'A', 'Choice A'\n+    CHOICE_B = 'B', 'Choice B'\n+\n+class CustomTextModel(models.Model):\n+    letter = models.CharField(max_length=1, choices=CustomTextChoices.choices)\n+\n+\n+class TestChoiceFieldBehaviors(TestCase):\n+\n+    def test_integerchoices_model(self):\n+        instance = CustomIntegerModel.objects.create(number=CustomIntegerChoices.CHOICE_ONE)\n+        self.assertIsInstance(instance.number, int)\n+        self.assertEqual(str(instance.number), str(CustomIntegerChoices.CHOICE_ONE))\n+\n+        instance.refresh_from_db()\n+        self.assertIsInstance(instance.number, int)\n+        self.assertEqual(str(instance.number), str(CustomIntegerChoices.CHOICE_ONE))\n+\n+    def test_textchoices_model(self):\n+        instance = CustomTextModel.objects.create(letter=CustomTextChoices.CHOICE_A)\n+        self.assertIsInstance(instance.letter, str)\n+        self.assertEqual(str(instance.letter), CustomTextChoices.CHOICE_A)\n+\n+        instance.refresh_from_db()\n+        self.assertIsInstance(instance.letter, str)\n+        self.assertEqual(str(instance.letter), CustomTextChoices.CHOICE_A)\n+\n class Gender(models.TextChoices):\n     MALE = 'M'\n     FEMALE = 'F'\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..6ac3e47 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -138,14 +138,20 @@ class ChoicesTests(SimpleTestCase):\n \n     def test_formfield(self):\n         no_choices_formfield = self.no_choices.formfield()\n-        self.assertIsInstance(no_choices_formfield, forms.IntegerField)\n-        fields = (\n-            self.empty_choices, self.with_choices, self.empty_choices_bool,\n-            self.empty_choices_text,\n-        )\n-        for field in fields:\n-            with self.subTest(field=field):\n-                self.assertIsInstance(field.formfield(), forms.ChoiceField)\n+# Since SimpleTestCase is already imported, we can directly use it for our test\n+from django.db import models\n+\n+class TestModelFieldDisplay(SimpleTestCase):\n+\n+    def test_overriding_get_FIELD_display(self):\n+        class FooBar(models.Model):\n+            foo_bar = models.CharField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                return 'something'\n+\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), 'something')\n \n \n class GetFieldDisplayTests(SimpleTestCase):\n",
  "django__django-12039": "diff --git a/tests/indexes/tests.py b/tests/indexes/tests.py\nindex 700f574..45ceab0 100644\n--- a/tests/indexes/tests.py\n+++ b/tests/indexes/tests.py\n@@ -9,6 +9,8 @@ from django.db.models.query_utils import Q\n from django.test import (\n     TestCase, TransactionTestCase, skipIfDBFeature, skipUnlessDBFeature,\n )\n+from django.db.models import Index\n+from django.db import connection\n from django.test.utils import override_settings\n from django.utils import timezone\n \n@@ -22,7 +24,45 @@ class SchemaIndexesTests(TestCase):\n     Test index handling by the db.backends.schema infrastructure.\n     \"\"\"\n \n-    def test_index_name_hash(self):\n+    def test_columns_list_sql(self):\n+        index = Index(fields=['headline'], name='whitespace_idx')\n+        editor = connection.schema_editor()\n+        self.assertIn(\n+            '(%s)' % editor.quote_name('headline'),\n+            str(index.create_sql(Article, editor)),\n+        )\n+\n+    def test_descending_columns_list_sql(self):\n+        index = Index(fields=['-headline'], name='whitespace_idx')\n+        editor = connection.schema_editor()\n+        self.assertIn(\n+            '(%s DESC)' % editor.quote_name('headline'),\n+            str(index.create_sql(Article, editor)),\n+        )\n+\n+    def test_ops_class_columns_lists_sql(self):\n+        index = Index(\n+            fields=['headline'],\n+            name='whitespace_idx',\n+            opclasses=['text_pattern_ops'],\n+        )\n+        with connection.schema_editor() as editor:\n+            self.assertIn(\n+                '(%s text_pattern_ops)' % editor.quote_name('headline'),\n+                str(index.create_sql(Article, editor)),\n+            )\n+\n+    def test_ops_class_descending_columns_list_sql(self):\n+        index = Index(\n+            fields=['-headline'],\n+            name='whitespace_idx',\n+            opclasses=['text_pattern_ops'],\n+        )\n+        with connection.schema_editor() as editor:\n+            self.assertIn(\n+                '(%s text_pattern_ops DESC)' % editor.quote_name('headline'),\n+                str(index.create_sql(Article, editor)),\n+            )\n         \"\"\"\n         Index names should be deterministic.\n         \"\"\"\n",
  "django__django-12050": "diff --git a/tests/queries/test_query.py b/tests/queries/test_query.py\nindex 49d26f3..1175681 100644\n--- a/tests/queries/test_query.py\n+++ b/tests/queries/test_query.py\n@@ -1,8 +1,10 @@\n+\n from datetime import datetime\n \n from django.core.exceptions import FieldError\n from django.db.models import CharField, F, Q\n from django.db.models.expressions import SimpleCol\n+from django.db.models.sql.datastructures import Col\n from django.db.models.fields.related_lookups import RelatedIsNull\n from django.db.models.functions import Lower\n from django.db.models.lookups import Exact, GreaterThan, IsNull, LessThan\n@@ -107,6 +109,13 @@ class TestQuery(SimpleTestCase):\n         self.assertIsInstance(b_isnull.lhs, SimpleCol)\n         self.assertEqual(b_isnull.lhs.target, ObjectC._meta.get_field('objectb'))\n \n+    def test_iterable_lookup_value(self):\n+        query = Query(Item)\n+        where = query.build_where(Q(name=['a', 'b']))\n+        name_exact = where.children[0]\n+        self.assertIsInstance(name_exact, Exact)\n+        self.assertEqual(name_exact.rhs, ['a', 'b'])  # Ensure it matches list, not tuple\n+\n     def test_clone_select_related(self):\n         query = Query(Item)\n         query.add_select_related(['creator'])\n",
  "django__django-12125": "",
  "django__django-12143": "diff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex 2d13234..62d72c8 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -837,11 +837,57 @@ class ChangeListTests(TestCase):\n         m = SwallowAdmin(Swallow, custom_site)\n         request = self.factory.post(changelist_url, data=data)\n         queryset = m._get_list_editable_queryset(request, prefix='form')\n+\n+    def test_get_list_editable_queryset_with_special_chars_in_prefix(self):\n+        \"\"\"\n+        Test handling of special regex characters in formset prefix.\n+        \"\"\"\n+        a = Swallow.objects.create(origin='Swallow C', load=5, speed=3)\n+        Swallow.objects.create(origin='Swallow D', load=3, speed=4)\n+        data = {\n+            'form$special[chars]-TOTAL_FORMS': '2',\n+            'form$special[chars]-INITIAL_FORMS': '2',\n+            'form$special[chars]-MIN_NUM_FORMS': '0',\n+            'form$special[chars]-MAX_NUM_FORMS': '1000',\n+            'form$special[chars]-0-uuid': str(a.pk),\n+            'form$special[chars]-0-load': '15',\n+            '_save': 'Save',\n+        }\n+        superuser = self._create_superuser('superuser')\n+        self.client.force_login(superuser)\n+        changelist_url = reverse('admin:admin_changelist_swallow_changelist')\n+        m = SwallowAdmin(Swallow, custom_site)\n+        request = self.factory.post(changelist_url, data=data)\n+        queryset = m._get_list_editable_queryset(request, prefix='form$special[chars]')\n+        self.assertEqual(queryset.count(), 1)\n         self.assertEqual(queryset.count(), 1)\n         data['form-0-uuid'] = 'INVALD_PRIMARY_KEY'\n         # The unfiltered queryset is returned if there's invalid data.\n         request = self.factory.post(changelist_url, data=data)\n         queryset = m._get_list_editable_queryset(request, prefix='form')\n+\n+    def test_get_list_editable_queryset_with_special_chars_in_prefix(self):\n+        \"\"\"\n+        Test handling of special regex characters in formset prefix.\n+        \"\"\"\n+        a = Swallow.objects.create(origin='Swallow C', load=5, speed=3)\n+        Swallow.objects.create(origin='Swallow D', load=3, speed=4)\n+        data = {\n+            'form$special[chars]-TOTAL_FORMS': '2',\n+            'form$special[chars]-INITIAL_FORMS': '2',\n+            'form$special[chars]-MIN_NUM_FORMS': '0',\n+            'form$special[chars]-MAX_NUM_FORMS': '1000',\n+            'form$special[chars]-0-uuid': str(a.pk),\n+            'form$special[chars]-0-load': '15',\n+            '_save': 'Save',\n+        }\n+        superuser = self._create_superuser('superuser')\n+        self.client.force_login(superuser)\n+        changelist_url = reverse('admin:admin_changelist_swallow_changelist')\n+        m = SwallowAdmin(Swallow, custom_site)\n+        request = self.factory.post(changelist_url, data=data)\n+        queryset = m._get_list_editable_queryset(request, prefix='form$special[chars]')\n+        self.assertEqual(queryset.count(), 1)\n         self.assertEqual(queryset.count(), 2)\n \n     def test_changelist_view_list_editable_changed_objects_uses_filter(self):\n",
  "django__django-12155": "diff --git a/tests/admin_docs/test_utils.py b/tests/admin_docs/test_utils.py\nindex 6cae16b..3b2b6de 100644\n--- a/tests/admin_docs/test_utils.py\n+++ b/tests/admin_docs/test_utils.py\n@@ -1,3 +1,4 @@\n+\n import unittest\n \n from django.contrib.admindocs.utils import (\n@@ -94,8 +95,32 @@ class TestUtils(AdminDocsSimpleTestCase):\n         header = 'should be h3...\\n\\nHeader\\n------\\n'\n         output = parse_rst(header, 'header')\n         self.assertIn('<h3>Header</h3>', output)\n+    def test_parse_docstring_no_leading_line_feed(self):\n+        \"\"\"\n+        Test parse_docstring with docstring starting on the first line.\n+        \"\"\"\n+        title, body, _ = parse_docstring('firstline\\n\\n    second line')\n+        with captured_stderr() as stderr:\n+            self.assertEqual(parse_rst(title, ''), '<p>firstline</p>\\n')\n+            self.assertEqual(parse_rst(body, ''), '<p>second line</p>\\n')\n+        self.assertEqual(stderr.getvalue(), '')\n \n-    def test_parse_rst(self):\n+    def test_trim_docstring(self):\n+        \"\"\"\n+        Test correct trimming of docstring starting on the first line\n+        with no leading empty line.\n+        \"\"\"\n+        docstring = \"Title\\n\\n    This is a sample description.\\n\\n    It has multiple lines.\"\n+        expected_trimmed = \"Title\\n\\nThis is a sample description.\\n\\nIt has multiple lines.\"\n+        self.assertEqual(trim_docstring(docstring), expected_trimmed)\n+\n+    def test_trim_docstring_with_leading_empty_line(self):\n+        \"\"\"\n+        Test trimming of docstring with a leading empty line.\n+        \"\"\"\n+        docstring = \"\\nTitle\\n\\n    This is a sample description.\"\n+        expected_trimmed = \"Title\\n\\nThis is a sample description.\"\n+        self.assertEqual(trim_docstring(docstring), expected_trimmed)\n         \"\"\"\n         parse_rst() should use `cmsreference` as the default role.\n         \"\"\"\n",
  "django__django-12193": "diff --git a/tests/postgres_tests/test_array.py b/tests/postgres_tests/test_array.py\nindex 6228cbc..47b313f 100644\n--- a/tests/postgres_tests/test_array.py\n+++ b/tests/postgres_tests/test_array.py\n@@ -1103,6 +1103,24 @@ class TestSplitFormWidget(PostgreSQLWidgetTestCase):\n             }\n         )\n \n+    def test_split_array_field_checkbox_initial_data(self):\n+        widget = SplitArrayWidget(forms.CheckboxInput(), size=4)\n+        context = widget.get_context('name', [True, False, True, False])\n+        subwidgets = context['widget']['subwidgets']\n+        self.assertEqual(\n+            [subwidget['attrs'].get('checked', False) for subwidget in subwidgets],\n+            [True, False, True, False]\n+        )\n+\n+    def test_split_array_field_checkbox_initial_empty(self):\n+        widget = SplitArrayWidget(forms.CheckboxInput(), size=3)\n+        context = widget.get_context('name', [])\n+        subwidgets = context['widget']['subwidgets']\n+        self.assertEqual(\n+            [subwidget['attrs'].get('checked', False) for subwidget in subwidgets],\n+            [False, False, False]\n+        )\n+\n     def test_render(self):\n         self.check_html(\n             SplitArrayWidget(forms.TextInput(), size=2), 'array', None,\n",
  "django__django-12209": "diff --git a/tests/serializers/test_data.py b/tests/serializers/test_data.py\nindex abbb3ab..c3c4d55 100644\n--- a/tests/serializers/test_data.py\n+++ b/tests/serializers/test_data.py\n@@ -14,6 +14,37 @@ from django.core import serializers\n from django.db import connection, models\n from django.test import TestCase\n \n+class UUIDFieldDefaultTest(TestCase):\n+    \n+    def test_save_with_explicit_pk(self):\n+        # Create a Sample instance so that it gets an id with a default value\n+        s0 = Sample.objects.create(name=\"Initial\")\n+        \n+        # Create another instance using the same pk\n+        s1 = Sample(pk=s0.pk, name=\"Test 1\")\n+        s1.save()\n+\n+        # There should only be one entry with the initial pk\n+        self.assertEqual(Sample.objects.filter(pk=s0.pk).count(), 1)\n+        # And its name should have been updated\n+        s0.refresh_from_db()\n+        self.assertEqual(s0.name, \"Test 1\")\n+\n+    def test_save_with_no_default_pk(self):\n+        # Create a Sample instance without relying on the default uuid4\n+        manual_uuid = uuid.uuid4()\n+        s0 = Sample.objects.create(pk=manual_uuid, name=\"Initial\")\n+\n+        # Create another instance using the same pk manually set\n+        s1 = Sample(pk=manual_uuid, name=\"Test 2\")\n+        s1.save()\n+\n+        # There should only be one entry with the manually set pk\n+        self.assertEqual(Sample.objects.filter(pk=manual_uuid).count(), 1)\n+        # And its name should have been updated\n+        s0.refresh_from_db()\n+        self.assertEqual(s0.name, \"Test 2\")\n+\n from .models import (\n     Anchor, AutoNowDateTimeData, BigIntegerData, BinaryData, BooleanData,\n     BooleanPKData, CharData, CharPKData, DateData, DatePKData, DateTimeData,\n@@ -28,7 +59,9 @@ from .models import (\n     PositiveSmallIntegerPKData, SlugData, SlugPKData, SmallData, SmallPKData,\n     Tag, TextData, TimeData, UniqueAnchor, UUIDData,\n )\n-from .tests import register_tests\n+import uuid\n+from django.test import TestCase\n+from .models import Sample\n \n # A set of functions that can be used to recreate\n # test data objects of various kinds.\n",
  "django__django-12262": "diff --git a/tests/template_tests/test_custom.py b/tests/template_tests/test_custom.py\nindex 8a8c535..f340e1c 100644\n--- a/tests/template_tests/test_custom.py\n+++ b/tests/template_tests/test_custom.py\n@@ -77,6 +77,12 @@ class SimpleTagTests(TagTestCase):\n                 'simple_only_unlimited_args - Expected result: 37, 42, 56, 89'),\n             ('{% load custom %}{% simple_unlimited_args_kwargs 37 40|add:2 56 eggs=\"scrambled\" four=1|add:3 %}',\n                 'simple_unlimited_args_kwargs - Expected result: 37, 42, 56 / eggs=scrambled, four=4'),\n+            # New error test case to ensure the correct error message is raised for duplicate keyword arguments\n+            (\"'hi' received multiple values for keyword argument 'greeting'\",\n+                '{% load custom %}{% hi greeting=\"hi\" greeting=\"hello\" %}'),\n+            # New test cases to ensure the custom template tags handle keyword-only arguments with defaults correctly\n+            ('{% load custom %}{% hello greeting=\"hi\" %}', 'hi world'),\n+            ('{% load custom %}{% hello %}', 'hello world'),\n         ]\n \n         for entry in templates:\n@@ -86,6 +92,22 @@ class SimpleTagTests(TagTestCase):\n         for entry in templates:\n             t = self.engine.from_string(\"%s as var %%}Result: {{ var }}\" % entry[0][0:-2])\n             self.assertEqual(t.render(c), \"Result: %s\" % entry[1])\n+        \n+        for entry in errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(entry[1])\n+\n+        for entry in errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(\"%s as var %%}\" % entry[1][0:-2])\n+\n+        for entry in templates:\n+            t = self.engine.from_string(entry[0])\n+            self.assertEqual(t.render(c), entry[1])\n+\n+        for entry in templates:\n+            t = self.engine.from_string(\"%s as var %%}Result: {{ var }}\" % entry[0][0:-2])\n+            self.assertEqual(t.render(c), \"Result: %s\" % entry[1])\n \n     def test_simple_tag_errors(self):\n         errors = [\n@@ -101,8 +123,30 @@ class SimpleTagTests(TagTestCase):\n                 '{% load custom %}{% simple_unlimited_args_kwargs 37 40|add:2 eggs=\"scrambled\" 56 four=1|add:3 %}'),\n             (\"'simple_unlimited_args_kwargs' received multiple values for keyword argument 'eggs'\",\n                 '{% load custom %}{% simple_unlimited_args_kwargs 37 eggs=\"scrambled\" eggs=\"scrambled\" %}'),\n+            # New error test case to ensure the correct error message is raised for duplicate keyword arguments\n+            (\"'hi' received multiple values for keyword argument 'greeting'\",\n+                '{% load custom %}{% hi greeting=\"hi\" greeting=\"hello\" %}'),\n+            # New test cases to ensure the custom template tags handle keyword-only arguments with defaults correctly\n+            ('{% load custom %}{% hello greeting=\"hi\" %}', 'hi world'),\n+            ('{% load custom %}{% hello %}', 'hello world'),\n         ]\n \n+        for entry in templates:\n+            t = self.engine.from_string(entry[0])\n+            self.assertEqual(t.render(c), entry[1])\n+\n+        for entry in templates:\n+            t = self.engine.from_string(\"%s as var %%}Result: {{ var }}\" % entry[0][0:-2])\n+            self.assertEqual(t.render(c), \"Result: %s\" % entry[1])\n+        \n+        for entry in errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(entry[1])\n+\n+        for entry in errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(\"%s as var %%}\" % entry[1][0:-2])\n+\n         for entry in errors:\n             with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n                 self.engine.from_string(entry[1])\n@@ -190,12 +234,34 @@ class InclusionTagTests(TagTestCase):\n                 'inclusion_only_unlimited_args - Expected result: 37, 42, 56, 89\\n'),\n             ('{% load inclusion %}{% inclusion_unlimited_args_kwargs 37 40|add:2 56 eggs=\"scrambled\" four=1|add:3 %}',\n                 'inclusion_unlimited_args_kwargs - Expected result: 37, 42, 56 / eggs=scrambled, four=4\\n'),\n+            # New error test case to ensure the correct error message is raised for duplicate keyword arguments\n+            (\"'hi' received multiple values for keyword argument 'greeting'\",\n+                '{% load custom %}{% hi greeting=\"hi\" greeting=\"hello\" %}'),\n+            # New test cases to ensure the custom template tags handle keyword-only arguments with defaults correctly\n+            ('{% load custom %}{% hello greeting=\"hi\" %}', 'hi world'),\n+            ('{% load custom %}{% hello %}', 'hello world'),\n         ]\n \n         for entry in templates:\n             t = self.engine.from_string(entry[0])\n             self.assertEqual(t.render(c), entry[1])\n \n+        for entry in templates:\n+            t = self.engine.from_string(\"%s as var %%}Result: {{ var }}\" % entry[0][0:-2])\n+            self.assertEqual(t.render(c), \"Result: %s\" % entry[1])\n+        \n+        for entry in errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(entry[1])\n+\n+        for entry in errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(\"%s as var %%}\" % entry[1][0:-2])\n+\n+        for entry in templates:\n+            t = self.engine.from_string(entry[0])\n+            self.assertEqual(t.render(c), entry[1])\n+\n     def test_inclusion_tag_errors(self):\n         errors = [\n             (\"'inclusion_one_default' received unexpected keyword argument 'three'\",\n",
  "django__django-12276": "diff --git a/tests/forms_tests/widget_tests/test_fileinput.py b/tests/forms_tests/widget_tests/test_fileinput.py\nindex c3ea9d6..1c77929 100644\n--- a/tests/forms_tests/widget_tests/test_fileinput.py\n+++ b/tests/forms_tests/widget_tests/test_fileinput.py\n@@ -14,7 +14,15 @@ class FileInputTest(WidgetTest):\n         self.check_html(self.widget, 'email', 'test@example.com', html='<input type=\"file\" name=\"email\">')\n         self.check_html(self.widget, 'email', '', html='<input type=\"file\" name=\"email\">')\n         self.check_html(self.widget, 'email', None, html='<input type=\"file\" name=\"email\">')\n+    def test_required_attribute_without_initial(self):\n+        widget = FileInput()\n+        self.check_html(widget, 'file1', '', html='<input type=\"file\" name=\"file1\" required>')\n+\n+    def test_required_attribute_with_initial(self):\n+        widget = FileInput()\n+        # Simulate as if `resume.txt` is the initial file set. \n+        self.check_html(widget, 'file1', 'resume.txt', html='<input type=\"file\" name=\"file1\">')\n \n     def test_value_omitted_from_data(self):\n         self.assertIs(self.widget.value_omitted_from_data({}, {}, 'field'), True)\n-        self.assertIs(self.widget.value_omitted_from_data({}, {'field': 'value'}, 'field'), False)\n+        self.assertIs(self.widget.value_omitted_from_data({}, {'field': 'value'}, 'field'), False)\n",
  "django__django-12304": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 6cabf01..e49c6d3 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import decimal\n import ipaddress\n@@ -138,6 +139,19 @@ class ChoicesTests(SimpleTestCase):\n                 ONE = 1, 'X', 'Invalid'\n \n         msg = \"duplicate values found in <enum 'Fruit'>: PINEAPPLE -> APPLE\"\n+\n+    def test_do_not_call_in_templates_enum(self):\n+        template = Template('{% if student.year_in_school == YearInSchool.FRESHMAN %}True{% else %}False{% endif %}')\n+        output = template.render(Context({\n+            'student': Student(year_in_school=YearInSchool.FRESHMAN),\n+            'YearInSchool': YearInSchool\n+        }))\n+        self.assertEqual(output, 'True')\n+\n+    def test_enum_label_and_value_in_templates(self):\n+        template = Template('{{ YearInSchool.FRESHMAN.label }}|{{ YearInSchool.FRESHMAN.value }}')\n+        output = template.render(Context({'YearInSchool': YearInSchool}))\n+        self.assertEqual(output, 'Freshman|1')\n         with self.assertRaisesMessage(ValueError, msg):\n             class Fruit(models.IntegerChoices):\n                 APPLE = 1, 'Apple'\n",
  "django__django-12308": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex acbcf33..2150db5 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -176,7 +176,22 @@ class UtilsTests(SimpleTestCase):\n         display_value = display_for_field(None, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, self.empty_value)\n \n-    def test_number_formats_display_for_field(self):\n+    def test_json_field_display_for_readonly(self):\n+        \"\"\"\n+        Test that JSONField displays correctly in admin when readonly.\n+        \"\"\"\n+        json_tests = [\n+            ({\"foo\": \"bar\"}, '{\"foo\": \"bar\"}'),\n+            ([{\"foo\": \"bar\"}, {\"baz\": \"qux\"}], '[{\"foo\": \"bar\"}, {\"baz\": \"qux\"}]'),\n+            ([], '[]'),\n+            (\"simple string\", '\"simple string\"'),\n+            (123, '123'),\n+            ({\"invalid\": {(\"tuple\",): \"key\"}}, '{\"invalid\": {\"(tuple,)\": \"key\"}}'),  # Note: Correct according to original patch.\n+        ]\n+        for value, expected_display in json_tests:\n+            with self.subTest(value=value):\n+                display_value = display_for_field(value, models.JSONField(), self.empty_value)\n+                self.assertEqual(display_value, expected_display)\n         display_value = display_for_field(12345.6789, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, '12345.6789')\n \n",
  "django__django-12325": "diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex fffd9ab..6fc0cd4 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -999,6 +999,27 @@ class OtherModelTests(SimpleTestCase):\n                 related_name='+',\n             )\n \n+    def test_correct_order_onetoone_with_parent_link(self):\n+        class Document(models.Model):\n+            pass\n+        \n+        class Picking(Document):\n+            document_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+            origin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\n+\n+        errors = Picking.check()\n+        self.assertEqual(errors, [])\n+\n+    def test_incorrect_order_onetoone_with_parent_link(self):\n+        doc_models_msg = \"Add parent_link=True to invalid_models_tests.Picking.origin.\"\n+        with self.assertRaisesMessage(ImproperlyConfigured, doc_models_msg):\n+            class Document(models.Model):\n+                pass\n+        \n+            class Picking(Document):\n+                origin = models.OneToOneField(Document, related_name='picking', on_delete=models.PROTECT)\n+                document_ptr = models.OneToOneField(Document, on_delete=models.CASCADE, parent_link=True, related_name='+')\n+\n         class ShippingMethodPrice(models.Model):\n             method = models.ForeignKey(ShippingMethod, models.CASCADE)\n             to_country = models.ForeignKey(Country, models.CASCADE)\n",
  "django__django-12419": "diff --git a/tests/middleware/test_security.py b/tests/middleware/test_security.py\nindex 7af62eb..437a21d 100644\n--- a/tests/middleware/test_security.py\n+++ b/tests/middleware/test_security.py\n@@ -248,10 +248,24 @@ class SecurityMiddlewareTest(SimpleTestCase):\n                 self.assertEqual(self.process_response()['Referrer-Policy'], expected)\n \n     @override_settings(SECURE_REFERRER_POLICY='strict-origin')\n-    def test_referrer_policy_already_present(self):\n+    @override_settings(SECURE_REFERRER_POLICY='same-origin')\n+    def test_default_referrer_policy(self):\n+        \"\"\"\n+        Ensure that the default SECURE_REFERRER_POLICY is 'same-origin'.\n+        \"\"\"\n+        response = self.process_response()\n+        self.assertEqual(response['Referrer-Policy'], 'same-origin')\n+\n+    @override_settings(SECURE_REFERRER_POLICY=None)\n+    def test_no_referrer_policy_when_none(self):\n+        \"\"\"\n+        Ensure that no Referrer-Policy is set when SECURE_REFERRER_POLICY is None.\n+        \"\"\"\n+        response = self.process_response()\n+        self.assertNotIn('Referrer-Policy', response)\n         \"\"\"\n         The middleware will not override a \"Referrer-Policy\" header already\n         present in the response.\n         \"\"\"\n         response = self.process_response(headers={'Referrer-Policy': 'unsafe-url'})\n-        self.assertEqual(response['Referrer-Policy'], 'unsafe-url')\n+        self.assertEqual(response['Referrer-Policy'], 'unsafe-url')\n",
  "django__django-12663": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 872551b..51d3402 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -13,6 +13,7 @@ from django.db.models import (\n     Func, IntegerField, Max, Min, Model, OrderBy, OuterRef, Q, StdDev,\n     Subquery, Sum, TimeField, UUIDField, Value, Variance, When,\n )\n+from django.utils.functional import SimpleLazyObject\n from django.db.models.expressions import Col, Combinable, Random, RawSQL, Ref\n from django.db.models.functions import (\n     Coalesce, Concat, Left, Length, Lower, Substr, Upper,\n",
  "django__django-12708": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 2df48a2..f1dd9e9 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1756,6 +1756,31 @@ class OperationTests(OperationTestBase):\n         self.assertEqual(definition[2], {'name': \"Pony\", 'index_together': {(\"pink\", \"weight\")}})\n \n     def test_alter_index_together_remove(self):\n+        # Additional test to check removal of index_together while maintaining unique_together\n+        @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+        def test_alter_index_together_remove_maintain_unique(self):\n+            app_label = 'test_alintoremove_wunto'\n+            table_name = '%s_pony' % app_label\n+            project_state = self.set_up_test_model(app_label, unique_together=True)\n+            self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+            \n+            # Add index together.\n+            new_state = project_state.clone()\n+            operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])\n+            operation.state_forwards(app_label, new_state)\n+            with connection.schema_editor() as editor:\n+                operation.database_forwards(app_label, editor, project_state, new_state)\n+            self.assertIndexExists(table_name, ['pink', 'weight'])\n+            \n+            # Remove index together.\n+            project_state = new_state\n+            new_state = project_state.clone()\n+            operation = migrations.AlterIndexTogether('Pony', set())\n+            operation.state_forwards(app_label, new_state)\n+            with connection.schema_editor() as editor:\n+                operation.database_forwards(app_label, editor, project_state, new_state)\n+            self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+            self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n         operation = migrations.AlterIndexTogether(\"Pony\", None)\n         self.assertEqual(operation.describe(), \"Alter index_together for Pony (0 constraint(s))\")\n \n",
  "django__django-12713": "diff --git a/tests/admin_widgets/tests.py b/tests/admin_widgets/tests.py\nindex dc4dadc..828b824 100644\n--- a/tests/admin_widgets/tests.py\n+++ b/tests/admin_widgets/tests.py\n@@ -14,7 +14,7 @@ from django.contrib.admin.tests import AdminSeleniumTestCase\n from django.contrib.auth.models import User\n from django.core.files.storage import default_storage\n from django.core.files.uploadedfile import SimpleUploadedFile\n-from django.db.models import CharField, DateField, DateTimeField, UUIDField\n+from django.db.models import CharField, DateField, DateTimeField, UUIDField, ManyToManyField\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.urls import reverse\n from django.utils import translation\n@@ -138,7 +138,21 @@ class AdminFormfieldForDBFieldTests(SimpleTestCase):\n         self.assertEqual(f2.widget.attrs['maxlength'], '20')\n         self.assertEqual(f2.widget.attrs['size'], '10')\n \n-    def test_formfield_overrides_for_datetime_field(self):\n+    \n+    def test_formfield_overrides_m2m_widget(self):\n+        \"\"\"\n+        The autocomplete_fields, raw_id_fields, filter_vertical, and\n+        filter_horizontal widgets for ManyToManyFields may be overridden by\n+        specifying a widget in formfield_overrides.\n+        \"\"\"\n+        class BandAdmin(admin.ModelAdmin):\n+            filter_horizontal = ['members']\n+            formfield_overrides = {\n+                ManyToManyField: {'widget': forms.CheckboxSelectMultiple},\n+            }\n+        ma = BandAdmin(Band, admin.site)\n+        field = ma.formfield_for_dbfield(Band._meta.get_field('members'), request=None)\n+        self.assertIsInstance(field.widget, forms.CheckboxSelectMultiple)\n         \"\"\"\n         Overriding the widget for DateTimeField doesn't overrides the default\n         form_class for that field (#26449).\n",
  "django__django-12741": "diff --git a/tests/backends/base/test_operations.py b/tests/backends/base/test_operations.py\nindex 089eb18..e52aaf0 100644\n--- a/tests/backends/base/test_operations.py\n+++ b/tests/backends/base/test_operations.py\n@@ -172,7 +172,26 @@ class SqlFlushTests(TransactionTestCase):\n             reset_sequences=True,\n             allow_cascade=True,\n         )\n-        connection.ops.execute_sql_flush(connection.alias, sql_list)\n+        connection.ops.execute_sql_flush(sql_list)\n+\n+        # New test case to verify that the `using` argument is removed\n+        # and inferred correctly from `self.connection.alias`.\n+        with transaction.atomic():\n+            self.assertIs(Author.objects.exists(), False)\n+            self.assertIs(Book.objects.exists(), False)\n+            if connection.features.supports_sequence_reset:\n+                author = Author.objects.create(name='Test Author')\n+                self.assertEqual(author.pk, 1)\n+                book = Book.objects.create(author=author, title='Test Book')\n+                self.assertEqual(book.pk, 1)\n+\n+        # Additional test to ensure behavior is unchanged after method signature change\n+        with transaction.atomic():\n+            self.assertIs(Author.objects.exists(), True)\n+            self.assertIs(Book.objects.exists(), True)\n+            connection.ops.execute_sql_flush(sql_list)\n+            self.assertIs(Author.objects.exists(), False)\n+            self.assertIs(Book.objects.exists(), False)\n \n         with transaction.atomic():\n             self.assertIs(Author.objects.exists(), False)\n@@ -181,4 +200,4 @@ class SqlFlushTests(TransactionTestCase):\n                 author = Author.objects.create(name='F. Scott Fitzgerald')\n                 self.assertEqual(author.pk, 1)\n                 book = Book.objects.create(author=author)\n-                self.assertEqual(book.pk, 1)\n+                self.assertEqual(book.pk, 1)\n",
  "django__django-12754": "",
  "django__django-12774": "",
  "django__django-12858": "diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 3b6974f..ca92270 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -905,6 +905,22 @@ class OtherModelTests(SimpleTestCase):\n \n         self.assertEqual(Child.check(), [])\n \n+    def test_ordering_with_nested_isnull_lookup(self):\n+        class Supply(models.Model):\n+            product = models.ForeignKey('Product', models.CASCADE)\n+\n+        class Product(models.Model):\n+            parent = models.ForeignKey('self', models.CASCADE, null=True)\n+\n+        class Stock(models.Model):\n+            supply = models.ForeignKey(Supply, models.CASCADE)\n+\n+            class Meta:\n+                ordering = ('supply__product__parent__isnull',)\n+\n+        # This should pass if the ordering by nested isnull lookup is fixed.\n+        self.assertEqual(Stock.check(), [])\n+\n     def test_ordering_pointing_to_foreignkey_field(self):\n         class Parent(models.Model):\n             pass\n",
  "django__django-13012": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 87c0945..0f01acd 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1821,10 +1821,24 @@ class CombinableTests(SimpleTestCase):\n         with self.assertRaisesMessage(NotImplementedError, self.bitwise_msg):\n             Combinable() | Combinable()\n \n-    def test_reversed_and(self):\n+    def test_wrapper_with_constant(self):\n+        # Verify that ExpressionWrapper with a constant does not add to GROUP BY\n+        expr = ExpressionWrapper(Value(3), output_field=IntegerField())\n+        model_query = Model.objects.annotate(expr_res=expr).values('expr_res', 'column_a').annotate(sum=Sum('column_b'))\n+        sql, params = model_query.query.sql_with_params()\n+        self.assertNotIn('GROUP BY \"model\".\"column_a\", 3', sql)\n+        self.assertIn('GROUP BY \"model\".\"column_a\"', sql)\n+\n+    def test_wrapper_with_expression(self):\n+        # Verify that ExpressionWrapper with a non-constant expression does affect GROUP BY\n+        expr = ExpressionWrapper(Func(Value('field'), function='LOWER'), output_field=IntegerField())\n+        model_query = Model.objects.annotate(expr_res=expr).values('expr_res', 'column_a').annotate(sum=Sum('column_b'))\n+        sql, params = model_query.query.sql_with_params()\n+        # Check if the non-constant expression is considered in the group by\n+        self.assertIn(expr.expression, model_query.query.group_by)\n         with self.assertRaisesMessage(NotImplementedError, self.bitwise_msg):\n             object() & Combinable()\n \n     def test_reversed_or(self):\n         with self.assertRaisesMessage(NotImplementedError, self.bitwise_msg):\n-            object() | Combinable()\n+            object() | Combinable()\n",
  "django__django-13028": "diff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex 70329a0..cb71f3a 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -1210,8 +1210,35 @@ class Queries1Tests(TestCase):\n             [],\n         )\n \n+from django.test import TestCase\n+from .models import ProductMetaData, ProductMetaDataType, Produit, Plateforme\n+from django.utils import timezone\n \n-class Queries2Tests(TestCase):\n+class ProductMetaDataTests(TestCase):\n+    \n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.plateforme = Plateforme.objects.create(name='Amazon')\n+        cls.produit = Produit.objects.create(name='Laptop')\n+        cls.brand_metadata_type = ProductMetaDataType.objects.create(label='Brand', filterable=False)\n+        cls.other_metadata_type = ProductMetaDataType.objects.create(label='Category', filterable=True)\n+\n+        cls.valid_metadata = ProductMetaData.objects.create(\n+            product=cls.produit, \n+            value='Dark Vador', \n+            marketplace=cls.plateforme, \n+            metadata_type=cls.brand_metadata_type\n+        )\n+    \n+    def test_not_supported_error_with_filterable_false(self):\n+        \"\"\"Test to reproduce NotSupportedError when filterable is False.\"\"\"\n+        with self.assertRaises(django.db.utils.NotSupportedError):\n+            list(ProductMetaData.objects.filter(value=\"Dark Vador\", metadata_type=self.brand_metadata_type))\n+    \n+    def test_filterable_field_respects_query(self):\n+        \"\"\"Test that filter field works properly when filterable is True.\"\"\"\n+        results = list(ProductMetaData.objects.filter(value=\"Dark Vador\", metadata_type=self.other_metadata_type))\n+        self.assertNotIn(self.valid_metadata, results)\n     @classmethod\n     def setUpTestData(cls):\n         Number.objects.create(num=4)\n",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..fc14cfa 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,6 +343,39 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n+    def test_order_by_self_referencing_fk(self):\n+        \"\"\"\n+        Test the ordering using a self-referencing foreign key to ensure it's ordered correctly.\n+        \"\"\"\n+\n+        # Assuming setup for two Author instances\n+        author_1 = Author.objects.create(name=\"Author 1\")\n+        author_2 = Author.objects.create(name=\"Author 2\")\n+\n+        # Creating articles with editors as self-referencing foreign key\n+        article1 = Article.objects.create(headline=\"Article 1\", author=author_1)\n+        article2 = Article.objects.create(headline=\"Article 2\", author=author_2)\n+\n+        # Assigning self-referencing foreign key to authors (e.g., assuming some other relation if needed)\n+        author_1.editor = author_2\n+        author_1.save()\n+        author_2.editor = author_1\n+        author_2.save()\n+\n+        # Test order_by using self-referencing fk field\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor'), \n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline')\n+        )\n+\n+        # Test order by self-referencing fk ID\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'), \n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline')\n+        )\n+\n     def test_order_by_f_expression(self):\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n@@ -353,6 +386,39 @@ class OrderingTests(TestCase):\n             ],\n             attrgetter(\"headline\")\n         )\n+\n+    def test_order_by_self_referencing_fk(self):\n+        \"\"\"\n+        Test the ordering using a self-referencing foreign key to ensure it's ordered correctly.\n+        \"\"\"\n+\n+        # Assuming setup for two Author instances\n+        author_1 = Author.objects.create(name=\"Author 1\")\n+        author_2 = Author.objects.create(name=\"Author 2\")\n+\n+        # Creating articles with editors as self-referencing foreign key\n+        article1 = Article.objects.create(headline=\"Article 1\", author=author_1)\n+        article2 = Article.objects.create(headline=\"Article 2\", author=author_2)\n+\n+        # Assigning self-referencing foreign key to authors (e.g., assuming some other relation if needed)\n+        author_1.editor = author_2\n+        author_1.save()\n+        author_2.editor = author_1\n+        author_2.save()\n+\n+        # Test order_by using self-referencing fk field\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor'), \n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline')\n+        )\n+\n+        # Test order by self-referencing fk ID\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'), \n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline')\n+        )\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline').asc()), [\n                 \"Article 1\",\n",
  "django__django-13089": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex e11856f..0b3b500 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -617,8 +617,29 @@ class BaseCacheTests:\n \n     def test_cull(self):\n         self._perform_cull_test('cull', 50, 29)\n+    def test_cull_handles_empty_result(self):\n+        \"\"\"\n+        Test that _cull method handles cases where no data is returned\n+        from the SQL queries, preventing 'NoneType' object is not subscriptable error.\n+        \"\"\"\n+        try:\n+            cull_cache = caches['cull']\n+        except InvalidCacheBackendError:\n+            self.skipTest(\"Culling isn't implemented.\")\n \n-    def test_zero_cull(self):\n+        old_max_entries = cull_cache._max_entries\n+        cull_cache._max_entries = 0  # Force _cull to consider deletion\n+        try:\n+            # Populate cache with an entry that should be cullable\n+            cull_cache.set('key_should_be_culled', 'value', 1000)\n+            self.assertIs(cull_cache.has_key('key_should_be_culled'), True)\n+            # Force immediate culling, triggering the _cull mechanism\n+            cull_cache._cull('default', cull_cache._get_cursor(), 0)\n+            # Verify the culling does not raise an exception and handles empty result\n+        except Exception as e:\n+            self.fail(f\"_cull raised an exception: {e}\")\n+        finally:\n+            cull_cache._max_entries = old_max_entries\n         self._perform_cull_test('zero_cull', 50, 19)\n \n     def _perform_invalid_key_test(self, key, expected_warning):\n",
  "django__django-13109": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex d60d822..347c49b 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -1645,7 +1645,41 @@ class ModelFormBasicTests(TestCase):\n         obj.full_clean()\n \n \n-class ModelMultipleChoiceFieldTests(TestCase):\n+from django.test import TestCase\n+from django import forms\n+from .models import Article, Writer\n+\n+class TestForeignKeyValidation(TestCase):\n+    def test_foreign_key_uses_default_manager_invalid(self):\n+        # Validate using default manager should fail for archived articles.\n+        class ArticleFormDefaultManager(forms.ModelForm):\n+            class Meta:\n+                model = Article\n+                fields = '__all__'\n+\n+        writer = Writer.objects.create(name='Archived Writer', archived=True)\n+        data = {'title': 'Example Article', 'writer': writer.pk}\n+        form = ArticleFormDefaultManager(data)\n+        self.assertFalse(form.is_valid())\n+        self.assertEqual(form.errors['writer'], ['Select a valid choice. That choice is not one of the available choices.'])\n+\n+    def test_foreign_key_uses_base_manager_valid(self):\n+        # Validate using _base_manager should allow archived articles.\n+        class ArticleFormBaseManager(forms.ModelForm):\n+            class Meta:\n+                model = Article\n+                fields = '__all__'\n+\n+            def __init__(self, *args, **kwargs):\n+                super().__init__(*args, **kwargs)\n+                self.fields['writer'].queryset = Writer._base_manager.all()\n+\n+        writer = Writer.objects.create(name='Archived Writer', archived=True)\n+        data = {'title': 'Example Article', 'writer': writer.pk}\n+        form = ArticleFormBaseManager(data)\n+        self.assertTrue(form.is_valid())\n+        article = form.save()\n+        self.assertEqual(article.writer, writer)\n     @classmethod\n     def setUpTestData(cls):\n         cls.c1 = Category.objects.create(name='Entertainment', slug='entertainment', url='entertainment')\n",
  "django__django-13112": "diff --git a/tests/migrations/test_state.py b/tests/migrations/test_state.py\nindex 081eff8..a52c833 100644\n--- a/tests/migrations/test_state.py\n+++ b/tests/migrations/test_state.py\n@@ -867,7 +867,25 @@ class StateTests(SimpleTestCase):\n         with self.assertRaisesMessage(ValueError, msg):\n             project_state.apps\n \n-    def test_real_apps(self):\n+    def test_reference_mixed_case_app_label_real_model(self):\n+        new_apps = Apps()\n+\n+        class Category(models.Model):\n+            class Meta:\n+                app_label = 'MiXedCase'\n+                apps = new_apps\n+\n+        class Content(models.Model):\n+            category = models.ForeignKey(Category, models.CASCADE)\n+\n+            class Meta:\n+                app_label = 'MiXedCase'\n+                apps = new_apps\n+\n+        project_state = ProjectState()\n+        project_state.add_model(ModelState.from_model(Category))\n+        project_state.add_model(ModelState.from_model(Content))\n+        self.assertEqual(len(project_state.apps.get_models()), 2)\n         \"\"\"\n         Including real apps can resolve dangling FK errors.\n         This test relies on the fact that contenttypes is always loaded.\n",
  "django__django-13121": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex a684d7e..92799df 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1209,6 +1209,38 @@ class ExpressionOperatorTests(TestCase):\n         Number.objects.filter(pk=self.n.pk).update(integer=F('integer') ** 2, float=F('float') ** 1.5)\n         self.assertEqual(Number.objects.get(pk=self.n.pk).integer, 1764)\n         self.assertEqual(Number.objects.get(pk=self.n.pk).float, Approximate(61.02, places=2))\n+    def test_duration_expressions_with_days(self):\n+        \"\"\"Test DurationField expressions involving days.\"\"\"\n+        delta = datetime.timedelta(days=1)\n+        experiments = [\n+            Experiment.objects.create(estimated_time=datetime.timedelta(days=i))\n+            for i in range(3)\n+        ]\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + delta)\n+        for obj in qs:\n+            self.assertEqual(obj.duration, obj.estimated_time + delta)\n+\n+    def test_duration_expressions_with_seconds(self):\n+        \"\"\"Test DurationField expressions involving seconds.\"\"\"\n+        delta = datetime.timedelta(seconds=30)\n+        experiments = [\n+            Experiment.objects.create(estimated_time=datetime.timedelta(seconds=i * 10))\n+            for i in range(3)\n+        ]\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + delta)\n+        for obj in qs:\n+            self.assertEqual(obj.duration, obj.estimated_time + delta)\n+\n+    def test_duration_expressions_negative_delta(self):\n+        \"\"\"Test DurationField expressions with negative timedelta.\"\"\"\n+        delta = datetime.timedelta(seconds=-15)\n+        experiments = [\n+            Experiment.objects.create(estimated_time=datetime.timedelta(seconds=i * 10))\n+            for i in range(3)\n+        ]\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + delta)\n+        for obj in qs:\n+            self.assertEqual(obj.duration, obj.estimated_time + delta)\n \n     @unittest.skipIf(connection.vendor == 'oracle', \"Oracle doesn't support bitwise XOR.\")\n     def test_lefthand_bitwise_xor(self):\n",
  "django__django-13128": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 82e96fa..c0737f7 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1484,7 +1484,21 @@ class FTimeDeltaTests(TestCase):\n         ))\n         self.assertIsNone(queryset.first().shifted)\n \n-    def test_duration_expressions(self):\n+    @skipUnlessDBFeature('supports_temporal_subtraction')\n+    def test_temporal_subtraction_without_expression_wrapper(self):\n+        # Test subtraction between two DateTimeFields without using ExpressionWrapper\n+        # It should correctly annotate duration\n+        queryset = Experiment.objects.annotate(delta=F('end') - F('start'))\n+        \n+        # Assuming we have instances with known delta\n+        expected_deltas = {\n+            'e0': datetime.timedelta(days=5),  # Adjust based on actual deltas\n+            'e1': datetime.timedelta(days=3),  # Sample data\n+            # Add other known outcomes\n+        }\n+        \n+        for experiment in queryset:\n+            self.assertEqual(experiment.delta, expected_deltas.get(experiment.name))\n         for delta in self.deltas:\n             qs = Experiment.objects.annotate(duration=F('estimated_time') + delta)\n             for obj in qs:\n",
  "django__django-13158": "",
  "django__django-13279": "diff --git a/tests/sessions_tests/tests.py b/tests/sessions_tests/tests.py\nindex e3a089f..011bfaf 100644\n--- a/tests/sessions_tests/tests.py\n+++ b/tests/sessions_tests/tests.py\n@@ -34,6 +34,7 @@ from django.test import (\n     RequestFactory, TestCase, ignore_warnings, override_settings,\n )\n from django.utils import timezone\n+from django.utils.deprecation import RemovedInDjango40Warning\n \n from .models import SessionStore as CustomDatabaseSession\n \n@@ -312,7 +313,21 @@ class SessionTestsMixin:\n         self.assertEqual(self.session.decode(encoded), data)\n \n     @override_settings(SECRET_KEY='django_tests_secret_key')\n-    def test_decode_legacy(self):\n+    def test_default_hashing_algorithm_legacy_decode(self):\n+        # Test with 'sha1' to ensure legacy decode works as expected.\n+        with self.settings(DEFAULT_HASHING_ALGORITHM='sha1'):\n+            data = {'a test key': 'a test value'}\n+            encoded = self.session.encode(data)\n+            self.assertEqual(self.session._legacy_decode(encoded), data)\n+\n+    def test_decode_incorrect_hash_algorithm_failure(self):\n+        # Test with an incorrect hash to ensure the decode fails.\n+        with self.settings(DEFAULT_HASHING_ALGORITHM='md5'):\n+            data = {'a test key': 'a test value'}\n+            encoded = self.session.encode(data)\n+            decoded_data = self.session._legacy_decode(encoded)\n+            self.assertNotEqual(decoded_data, data)\n+            self.assertEqual(decoded_data, {})\n         # RemovedInDjango40Warning: pre-Django 3.1 sessions will be invalid.\n         legacy_encoded = (\n             'OWUzNTNmNWQxNTBjOWExZmM4MmQ3NzNhMDRmMjU4NmYwNDUyNGI2NDp7ImEgdGVzd'\n@@ -322,8 +337,12 @@ class SessionTestsMixin:\n             self.session.decode(legacy_encoded),\n             {'a test key': 'a test value'},\n         )\n-\n-    def test_decode_failure_logged_to_security(self):\n+    def test_decode_corrupted_data_logged_to_security(self):\n+        # Ensure corrupted session data logs a security warning.\n+        corrupted_data = base64.b64encode(b'corrupted:data').decode('ascii')\n+        with self.assertLogs('django.security.SuspiciousSession', 'WARNING') as cm:\n+            self.assertEqual({}, self.session.decode(corrupted_data))\n+        self.assertIn('corrupted', cm.output[0])\n         bad_encode = base64.b64encode(b'flaskdj:alkdjf').decode('ascii')\n         with self.assertLogs('django.security.SuspiciousSession', 'WARNING') as cm:\n             self.assertEqual({}, self.session.decode(bad_encode))\n",
  "django__django-13297": "diff --git a/tests/generic_views/test_base.py b/tests/generic_views/test_base.py\nindex 26c885d..ade591f 100644\n--- a/tests/generic_views/test_base.py\n+++ b/tests/generic_views/test_base.py\n@@ -9,6 +9,8 @@ from django.test.utils import require_jinja2\n from django.urls import resolve\n from django.utils.deprecation import RemovedInDjango40Warning\n from django.views.generic import RedirectView, TemplateView, View\n+from django.utils.functional import SimpleLazyObject\n+from .models import Artist\n \n from . import views\n \n@@ -590,7 +592,21 @@ class DeprecationTests(SimpleTestCase):\n         self.assertEqual(response.context['key'], 'value')\n         self.assertIsInstance(response.context['view'], View)\n \n-    def test_template_params_warning(self):\n+    @ignore_warnings(category=RemovedInDjango40Warning)\n+    def test_template_params_filtering(self):\n+        class OfferView(TemplateView):\n+            template_name = 'generic_views/about.html'\n+\n+            def get_context_data(self, **kwargs):\n+                offer_slug = kwargs.get(\"offer_slug\", \"\")\n+                offer = Artist.objects.get(name=str(offer_slug))  # convert to str as per fix\n+                return {\"artist\": offer, \"offer_slug\": offer_slug}\n+\n+        artist = Artist.objects.create(name='Rene Magritte')\n+        # SimpleLazyObject simulating delayed object resolution\n+        lazy_artist_name = SimpleLazyObject(lambda: artist.name)\n+        response = OfferView.as_view()(self.rf.get('/offers/Rene-Magritte/'), offer_slug=lazy_artist_name)\n+        self.assertEqual(response.context_data['artist'], artist)\n         response = self.client.get('/template/custom/bar1/bar2/')\n         self.assertEqual(response.status_code, 200)\n         msg = (\n",
  "django__django-13315": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 64b15bf..1bb6202 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -15,6 +15,8 @@ from django.forms.models import (\n     modelform_factory,\n )\n from django.template import Context, Template\n+from django.test.utils import isolate_apps\n+from .models import StumpJoke, Character\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n \n from .models import (\n@@ -2828,6 +2830,71 @@ class LimitChoicesToTests(TestCase):\n             self.assertEqual(today_callable_dict.call_count, 2)\n             StumpJokeForm()\n             self.assertEqual(today_callable_dict.call_count, 3)\n+class LimitChoicesToDuplicatesTests(TestCase):\n+    def setUp(self):\n+        # Set up characters\n+        self.marley = Character.objects.create(username='Marley', last_action='2023-10-24 00:00:00')\n+        self.threepwood = Character.objects.create(username='Threepwood', last_action='2023-10-24 00:00:00')\n+        \n+        # Create stump jokes\n+        self.joke1 = StumpJoke.objects.create(funny=True, most_recently_fooled=self.threepwood)\n+        self.joke2 = StumpJoke.objects.create(funny=True, most_recently_fooled=self.threepwood)\n+        self.joke3 = StumpJoke.objects.create(funny=True, most_recently_fooled=self.marley)\n+        StumpJoke.objects.create(funny=False, most_recently_fooled=self.marley)\n+        \n+        # Setting up ManyToMany relationships\n+        self.joke1.has_fooled_today.add(self.marley, self.threepwood)\n+        self.joke2.has_fooled_today.add(self.marley)\n+        self.joke3.has_fooled_today.add(self.marley, self.threepwood)\n+\n+    @isolate_apps('model_forms')\n+    def test_limit_choices_to_no_duplicates(self):\n+        class CharacterDetails(models.Model):\n+            character1 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_fk_1',\n+            )\n+            character2 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to={\n+                    'jokes__funny': True,\n+                    'jokes_today__funny': True,\n+                },\n+                related_name='details_fk_2',\n+            )\n+            character3 = models.ManyToManyField(\n+                Character,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_m2m_1',\n+            )\n+\n+        class CharacterDetailsForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetails\n+                fields = '__all__'\n+\n+        form = CharacterDetailsForm()\n+        self.assertCountEqual(\n+            form.fields['character1'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character2'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character3'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n \n \n class FormFieldCallbackTests(SimpleTestCase):\n",
  "django__django-13343": "diff --git a/tests/file_storage/tests.py b/tests/file_storage/tests.py\nindex a5ab3a0..bc21d23 100644\n--- a/tests/file_storage/tests.py\n+++ b/tests/file_storage/tests.py\n@@ -29,7 +29,7 @@ from django.test.utils import requires_tz_support\n from django.urls import NoReverseMatch, reverse_lazy\n from django.utils import timezone\n \n-from .models import Storage, temp_storage, temp_storage_location\n+from .models import Storage, callable_storage, temp_storage, temp_storage_location\n \n FILE_SUFFIX_REGEX = '[A-Za-z0-9]{7}'\n \n@@ -82,6 +82,16 @@ class FileSystemStorageTests(unittest.TestCase):\n         path, args, kwargs = storage.deconstruct()\n         self.assertEqual(kwargs, kwargs_orig)\n \n+    def test_callable_storage_deconstruction_returns_callable(self):\n+        \"\"\"\n+        Test that a FileField with a callable storage is deconstructed correctly.\n+        The deconstructed 'storage' should be the callable, not its result.\n+        \"\"\"\n+        obj = Storage()\n+        *_, kwargs = obj._meta.get_field('storage_callable').deconstruct()\n+        deconstructed_storage = kwargs['storage']\n+        self.assertIs(deconstructed_storage, callable_storage)\n+\n     def test_lazy_base_url_init(self):\n         \"\"\"\n         FileSystemStorage.__init__() shouldn't evaluate base_url.\n",
  "django__django-13346": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex b918d5c..412bbff 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -632,7 +632,27 @@ class TestQuerying(TestCase):\n         self.assertIs(NullableJSONModel.objects.filter(value__foo__contains='ar').exists(), False)\n         self.assertIs(NullableJSONModel.objects.filter(value__foo__contains='bar').exists(), True)\n \n-    def test_key_icontains(self):\n+    def test_key_in_lookup(self):\n+        # This test checks whether __in lookup on key transforms works.\n+        first_filter = {'our_field__key__in': [0]}\n+        first_items = OurModel.objects.filter(**first_filter)\n+        \n+        second_filter = {'our_field__key': 0}\n+        second_items = OurModel.objects.filter(**second_filter)\n+        \n+        # Check if both filters return the same number of items\n+        self.assertEqual(len(first_items), len(second_items))\n+\n+    def test_multivalue_key_in_lookup(self):\n+        # Additional test for multiple values in __in lookup\n+        multi_value_filter = {'our_field__key__in': [0, 1, 2]}\n+        multi_value_items = OurModel.objects.filter(**multi_value_filter)\n+\n+        direct_filter = {'our_field__key': 0}\n+        direct_items = OurModel.objects.filter(**direct_filter)\n+\n+        # Ensures the __in query returns all items that match any of the specified keys\n+        self.assertTrue(len(multi_value_items) >= len(direct_items))\n         self.assertIs(NullableJSONModel.objects.filter(value__foo__icontains='Ar').exists(), True)\n \n     def test_key_startswith(self):\n",
  "django__django-13363": "diff --git a/tests/db_functions/datetime/test_extract_trunc.py b/tests/db_functions/datetime/test_extract_trunc.py\nindex 82d5e36..0ec282a 100644\n--- a/tests/db_functions/datetime/test_extract_trunc.py\n+++ b/tests/db_functions/datetime/test_extract_trunc.py\n@@ -17,7 +17,10 @@ from django.db.models.functions import (\n from django.test import (\n     TestCase, override_settings, skipIfDBFeature, skipUnlessDBFeature,\n )\n+from datetime import datetime\n+import pytz\n from django.utils import timezone\n+from django.db.models import Count\n \n from ..models import Author, DTModel, Fan\n \n@@ -1111,7 +1114,43 @@ class DateFunctionWithTimeZoneTests(DateFunctionTests):\n             self.assertEqual(model.day_melb, 16)\n             self.assertEqual(model.day_utc, 15)\n \n-    def test_trunc_timezone_applied_before_truncation(self):\n+    def test_truncdate_with_tzinfo(self):\n+        # Creating a start datetime\n+        start_datetime = datetime(2023, 10, 28, 15, 45, 30)\n+        start_datetime = timezone.make_aware(start_datetime, is_dst=False)\n+\n+        # Defining timezones\n+        newyork = pytz.timezone('America/New_York')\n+        utc = pytz.UTC\n+\n+        # Creating a model and applying TruncDate with tzinfo\n+        timeslot_model = TimeSlots.objects.create(start_at=start_datetime)\n+        report = TimeSlots.objects.annotate(\n+            start_date_ny=TruncDate('start_at', tzinfo=newyork),\n+            start_date_utc=TruncDate('start_at', tzinfo=utc),\n+        ).values('start_date_ny', 'start_date_utc').annotate(time_count=Count('id')).get()\n+\n+        self.assertEqual(report['start_date_ny'], start_datetime.astimezone(newyork).date())\n+        self.assertEqual(report['start_date_utc'], start_datetime.astimezone(utc).date())\n+\n+    def test_trunctime_with_tzinfo(self):\n+        # Creating a start datetime\n+        start_datetime = datetime(2023, 10, 28, 15, 45, 30)\n+        start_datetime = timezone.make_aware(start_datetime, is_dst=False)\n+\n+        # Defining timezones\n+        newyork = pytz.timezone('America/New_York')\n+        utc = pytz.UTC\n+\n+        # Creating a model and applying TruncTime with tzinfo\n+        timeslot_model = TimeSlots.objects.create(start_at=start_datetime)\n+        report = TimeSlots.objects.annotate(\n+            start_time_ny=TruncTime('start_at', tzinfo=newyork),\n+            start_time_utc=TruncTime('start_at', tzinfo=utc),\n+        ).values('start_time_ny', 'start_time_utc').annotate(time_count=Count('id')).get()\n+\n+        self.assertEqual(report['start_time_ny'], start_datetime.astimezone(newyork).time())\n+        self.assertEqual(report['start_time_utc'], start_datetime.astimezone(utc).time())\n         start_datetime = datetime(2016, 1, 1, 1, 30, 50, 321)\n         end_datetime = datetime(2016, 6, 15, 14, 10, 50, 123)\n         start_datetime = timezone.make_aware(start_datetime, is_dst=False)\n",
  "django__django-13401": "",
  "django__django-13410": "diff --git a/tests/files/tests.py b/tests/files/tests.py\nindex 1285e22..dd160ab 100644\n--- a/tests/files/tests.py\n+++ b/tests/files/tests.py\n@@ -1,3 +1,4 @@\n+\n import errno\n import gzip\n import os\n@@ -8,7 +9,7 @@ from io import BytesIO, StringIO, TextIOWrapper\n from pathlib import Path\n from unittest import mock\n \n-from django.core.files import File\n+from django.core.files import File, locks\n from django.core.files.base import ContentFile\n from django.core.files.move import file_move_safe\n from django.core.files.temp import NamedTemporaryFile\n",
  "django__django-13417": "diff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex 8130de5..e164f69 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -2079,6 +2079,24 @@ class QuerysetOrderedTests(unittest.TestCase):\n     def test_order_by_extra(self):\n         self.assertIs(Annotation.objects.all().extra(order_by=['id']).ordered, True)\n \n+    def test_annotated_default_ordering(self):\n+        qs = Annotation.objects.annotate(num_notes=Count('pk'))\n+        self.assertIs(qs.ordered, False)\n+        self.assertIs(qs.order_by('notes').ordered, True)\n+\n+    def test_annotated_values_default_ordering(self):\n+        qs = Annotation.objects.values('notes').annotate(num_notes=Count('pk'))\n+        self.assertIs(qs.ordered, False)\n+        self.assertIs(qs.order_by('notes').ordered, True)\n+\n+    def test_group_by_without_explicit_ordering(self):\n+        qs = Annotation.objects.annotate(num_notes=Count('notes'))\n+        self.assertIs(qs.ordered, False)\n+\n+    def test_group_by_with_meta_ordering(self):\n+        qs = Annotation.objects.annotate(num_notes=Count('notes')).order_by()\n+        self.assertIs(qs.ordered, False)\n+\n     def test_annotated_ordering(self):\n         qs = Annotation.objects.annotate(num_notes=Count('notes'))\n         self.assertIs(qs.ordered, False)\n",
  "django__django-13516": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 89f7c38..d2f33d8 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -335,6 +335,16 @@ class CommandTests(SimpleTestCase):\n             with self.assertRaisesMessage(TypeError, msg):\n                 management.call_command('subparser_dest', subcommand='foo', bar=12)\n \n+    def test_outputwrapper_flush(self):\n+        \"\"\"\n+        Test that flush is called on stdout which should immediately write the buffer to the output.\n+        \"\"\"\n+        out = StringIO()\n+        with mock.patch.object(out, 'flush') as mocked_flush:\n+            management.call_command('outputwrapper', stdout=out)\n+        self.assertIn('Working...', out.getvalue())\n+        self.assertIs(mocked_flush.called, True)\n+\n     def test_create_parser_kwargs(self):\n         \"\"\"BaseCommand.create_parser() passes kwargs to CommandParser.\"\"\"\n         epilog = 'some epilog text'\n",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..b002195 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,3 +1,4 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n@@ -36,8 +37,30 @@ class TokenGeneratorTest(TestCase):\n         tk1 = p0.make_token(user)\n         tk2 = p0.make_token(user_reload)\n         self.assertEqual(tk1, tk2)\n-\n-    def test_timeout(self):\n+    def test_token_with_different_email(self):\n+        \"\"\"Updating the user email address invalidates the token.\"\"\"\n+        tests = [\n+            (User, 'test4@example.com'),\n+            (CustomEmailField, 'test4@example.com'),\n+            (CustomEmailField, None),\n+        ]\n+        for model, email in tests:\n+            with self.subTest(model=model.__qualname__, email=email):\n+                user = model.objects.create_user(\n+                    username='changeemailuser', \n+                    email=email, \n+                    password='testpw',\n+                )\n+                p0 = PasswordResetTokenGenerator()\n+                tk1 = p0.make_token(user)\n+                self.assertIs(p0.check_token(user, tk1), True)\n+                \n+                # Change the user's email\n+                setattr(user, user.get_email_field_name(), 'test4new@example.com')\n+                user.save()\n+                \n+                # The token should now be invalid\n+                self.assertIs(p0.check_token(user, tk1), False)\n         \"\"\"The token is valid after n seconds, but no greater.\"\"\"\n         # Uses a mocked version of PasswordResetTokenGenerator so we can change\n         # the value of 'now'.\n",
  "django__django-13568": "diff --git a/tests/auth_tests/test_checks.py b/tests/auth_tests/test_checks.py\nindex c47b5c2..8047d62 100644\n--- a/tests/auth_tests/test_checks.py\n+++ b/tests/auth_tests/test_checks.py\n@@ -1,9 +1,11 @@\n+\n from django.contrib.auth.checks import (\n     check_models_permissions, check_user_model,\n )\n from django.contrib.auth.models import AbstractBaseUser\n from django.core import checks\n from django.db import models\n+from django.db.models import Q, UniqueConstraint\n from django.test import (\n     SimpleTestCase, override_settings, override_system_checks,\n )\n@@ -194,7 +196,23 @@ class ModelsPermissionsChecksTests(SimpleTestCase):\n             ),\n         ])\n \n-    def test_custom_permission_name_max_length(self):\n+    @override_settings(AUTH_USER_MODEL='auth_tests.CustomUserWithTotalUniqueConstraint')\n+    def test_username_with_total_unique_constraint(self):\n+        class CustomUserWithTotalUniqueConstraint(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            USERNAME_FIELD = 'username'\n+\n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(fields=['username'], name='user_username_unq'),\n+                ]\n+\n+        # Ensure no errors are returned since the user model passes the constraints check\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n+        with self.settings(AUTHENTICATION_BACKENDS=['my.custom.backend']):\n+            errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+            self.assertEqual(errors, [])\n         custom_permission_name = 'some ridiculously long verbose name that is out of control' * 5\n \n         class Checked(models.Model):\n",
  "django__django-13569": "",
  "django__django-13590": "",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..c994f40 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -14,7 +14,10 @@ import unittest\n from io import StringIO\n from unittest import mock\n \n+import os\n from django import conf, get_version\n+from django.core.management import execute_from_command_line\n+from django.test.utils import captured_stdout, captured_stderr\n from django.conf import settings\n from django.core.management import (\n     BaseCommand, CommandError, call_command, color,\n@@ -37,7 +40,40 @@ custom_templates_dir = os.path.join(os.path.dirname(__file__), 'custom_templates\n SYSTEM_CHECK_MSG = 'System check identified no issues'\n \n \n-class AdminScriptTestCase(SimpleTestCase):\n+class ExecuteFromCommandLine(SimpleTestCase):\n+    def test_program_name_from_argv(self):\n+        \"\"\"\n+        Program name is computed from the execute_from_command_line()'s argv\n+        argument, not sys.argv.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line(['django-admin'] + args)\n+        self.assertIn('usage: django-admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+    \n+    def test_program_name_with_different_prog(self):\n+        \"\"\"\n+        Program name is correctly set when a different prog name is provided in argv.\n+        \"\"\"\n+        args = ['help', 'dbshell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['incorrect-prog'] + args):\n+                execute_from_command_line(['custom-admin'] + args)\n+        self.assertIn('usage: custom-admin dbshell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+    \n+    def test_program_name_with_sys_argv_effects(self):\n+        \"\"\"\n+        Test that changing sys.argv does not affect command execution when custom argv is passed.\n+        \"\"\"\n+        args = ['check']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', ['incorrect-prog'] + args):\n+                execute_from_command_line(['my-admin'] + args)\n+        self.assertIn('usage: my-admin check', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n     def setUp(self):\n         tmpdir = tempfile.TemporaryDirectory()\n         self.addCleanup(tmpdir.cleanup)\n",
  "django__django-13670": "diff --git a/tests/utils_tests/test_dateformat.py b/tests/utils_tests/test_dateformat.py\nindex 6f0b13f..d118406 100644\n--- a/tests/utils_tests/test_dateformat.py\n+++ b/tests/utils_tests/test_dateformat.py\n@@ -1,3 +1,4 @@\n+\n from datetime import date, datetime\n \n from django.test import SimpleTestCase, override_settings\n@@ -112,7 +113,23 @@ class DateFormatTests(SimpleTestCase):\n \n         self.assertEqual(dateformat.format(my_birthday, r'jS \\o\\f F'), '8th of July')\n \n-    def test_futuredates(self):\n+    def test_year_before_1000(self):\n+        tests = [\n+            (476, '76'),\n+            (42, '42'),\n+            (4, '04'),\n+            (999, '99'),\n+            (1000, '00'),\n+            (123, '23'),\n+            (89, '89'),\n+            (9, '09'),\n+        ]\n+        for year, expected_date in tests:\n+            with self.subTest(year=year):\n+                self.assertEqual(\n+                    dateformat.format(datetime(year, 9, 8, 5, 0), 'y'),\n+                    expected_date,\n+                )\n         the_future = datetime(2100, 10, 25, 0, 00)\n         self.assertEqual(dateformat.format(the_future, r'Y'), '2100')\n \n@@ -164,4 +181,4 @@ class DateFormatTests(SimpleTestCase):\n             self.assertEqual(\n                 dateformat.format(dt, 'r'),\n                 'Sun, 08 Jul 1979 22:00:00 +0100',\n-            )\n+            )\n",
  "django__django-13741": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex ca66cd5..d201995 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1024,6 +1024,16 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n         field = ReadOnlyPasswordHashField()\n         self.assertFalse(field.has_changed('aaa', 'bbb'))\n \n+    def test_readonly_password_hash_field_disabled(self):\n+        field = ReadOnlyPasswordHashField()\n+        self.assertIs(field.disabled, True, \"ReadOnlyPasswordHashField should have 'disabled' attribute set to True.\")\n+\n+    def test_readonly_password_hash_field_bound_data(self):\n+        field = ReadOnlyPasswordHashField()\n+        initial_data = 'initial_password_hash'\n+        bound_data = field.bound_data('new_data', initial_data)\n+        self.assertEqual(bound_data, initial_data, \"ReadOnlyPasswordHashField should always return initial data in bound_data.\")\n+\n \n class AdminPasswordChangeFormTest(TestDataMixin, TestCase):\n \n",
  "django__django-13786": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 3782589..7f4e7de 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -119,6 +119,42 @@ class OptimizerTests(SimpleTestCase):\n             ]\n         )\n \n+    def test_create_model_and_alter_model_options_clear(self):\n+        # CreateModel with options and AlterModelOptions to clear those options should result in a CreateModel without those options.\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\n+                    'ClearOptionsModel',\n+                    fields=[],\n+                    options={'verbose_name': 'Clear Me'},\n+                ),\n+                migrations.AlterModelOptions('ClearOptionsModel', options={}),\n+            ],\n+            [\n+                migrations.CreateModel('ClearOptionsModel', fields=[]),\n+            ],\n+        )\n+\n+    def test_create_model_and_alter_model_options_update(self):\n+        # CreateModel followed by AlterModelOptions should maintain only updated options.\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\n+                    'UpdateOptionsModel',\n+                    fields=[],\n+                    options={'verbose_name': 'Old Name', 'db_table': 'old_table'},\n+                ),\n+                migrations.AlterModelOptions('UpdateOptionsModel', options={'verbose_name': 'New Name'}),\n+            ],\n+            [\n+                migrations.CreateModel(\n+                    'UpdateOptionsModel',\n+                    fields=[],\n+                    options={'verbose_name': 'New Name', 'db_table': 'old_table'},  # 'db_table' should remain, 'verbose_name' updated.\n+                ),\n+            ],\n+        )\n+\n     def _test_create_alter_foo_delete_model(self, alter_foo):\n         \"\"\"\n         CreateModel, AlterModelTable, AlterUniqueTogether/AlterIndexTogether/\n@@ -134,6 +170,42 @@ class OptimizerTests(SimpleTestCase):\n             [],\n         )\n \n+    def test_create_model_and_alter_model_options_clear(self):\n+        # CreateModel with options and AlterModelOptions to clear those options should result in a CreateModel without those options.\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\n+                    'ClearOptionsModel',\n+                    fields=[],\n+                    options={'verbose_name': 'Clear Me'},\n+                ),\n+                migrations.AlterModelOptions('ClearOptionsModel', options={}),\n+            ],\n+            [\n+                migrations.CreateModel('ClearOptionsModel', fields=[]),\n+            ],\n+        )\n+\n+    def test_create_model_and_alter_model_options_update(self):\n+        # CreateModel followed by AlterModelOptions should maintain only updated options.\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\n+                    'UpdateOptionsModel',\n+                    fields=[],\n+                    options={'verbose_name': 'Old Name', 'db_table': 'old_table'},\n+                ),\n+                migrations.AlterModelOptions('UpdateOptionsModel', options={'verbose_name': 'New Name'}),\n+            ],\n+            [\n+                migrations.CreateModel(\n+                    'UpdateOptionsModel',\n+                    fields=[],\n+                    options={'verbose_name': 'New Name', 'db_table': 'old_table'},  # 'db_table' should remain, 'verbose_name' updated.\n+                ),\n+            ],\n+        )\n+\n     def test_create_alter_unique_delete_model(self):\n         self._test_create_alter_foo_delete_model(migrations.AlterUniqueTogether(\"Foo\", [[\"a\", \"b\"]]))\n \n",
  "django__django-13794": "diff --git a/tests/template_tests/filter_tests/test_add.py b/tests/template_tests/filter_tests/test_add.py\nindex 7ba4955..72d6d71 100644\n--- a/tests/template_tests/filter_tests/test_add.py\n+++ b/tests/template_tests/filter_tests/test_add.py\n@@ -1,7 +1,9 @@\n+\n from datetime import date, timedelta\n \n from django.template.defaultfilters import add\n from django.test import SimpleTestCase\n+from django.utils.translation import gettext_lazy, lazy\n \n from ..utils import setup\n \n",
  "django__django-13807": "diff --git a/tests/backends/tests.py b/tests/backends/tests.py\nindex 0aee2b6..d850f0b 100644\n--- a/tests/backends/tests.py\n+++ b/tests/backends/tests.py\n@@ -18,6 +18,7 @@ from django.test import (\n     skipUnlessDBFeature,\n )\n \n+from django.db import connection, transaction, IntegrityError\n from .models import (\n     Article, Object, ObjectReference, Person, Post, RawData, Reporter,\n     ReporterProxy, SchoolClass, Square,\n@@ -626,7 +627,24 @@ class FkConstraintsTests(TransactionTestCase):\n             transaction.set_rollback(True)\n \n \n-class ThreadTests(TransactionTestCase):\n+class SQLKeywordTest(TransactionTestCase):\n+\n+    available_apps = ['backends']\n+\n+    def test_check_constraints_sql_keywords(self):\n+        \"\"\"\n+        Test to ensure that loading fixtures from a table with a SQL reserved keyword as the name\n+        does not cause a crash in SQLite.\n+        \"\"\"\n+        with transaction.atomic():\n+            obj = SQLKeywordsModel.objects.create(reporter=Reporter.objects.create(first_name='John', last_name='Doe'))\n+            obj.refresh_from_db()\n+            obj.reporter_id = 30\n+            with connection.constraint_checks_disabled():\n+                obj.save()\n+                with self.assertRaises(IntegrityError):\n+                    connection.check_constraints(table_names=['order'])\n+            transaction.set_rollback(True)\n \n     available_apps = ['backends']\n \n",
  "django__django-13809": "",
  "django__django-13810": "",
  "django__django-13820": "diff --git a/tests/migrations/test_loader.py b/tests/migrations/test_loader.py\nindex 594c01e..386c1c5 100644\n--- a/tests/migrations/test_loader.py\n+++ b/tests/migrations/test_loader.py\n@@ -1,7 +1,9 @@\n+\n import compileall\n import os\n \n from django.db import connection, connections\n+from importlib import import_module\n from django.db.migrations.exceptions import (\n     AmbiguityError, InconsistentMigrationHistory, NodeNotFoundError,\n )\n@@ -512,6 +514,43 @@ class LoaderTests(TestCase):\n         migrations = [name for app, name in loader.disk_migrations if app == 'migrations']\n         self.assertEqual(migrations, [])\n \n+    @override_settings(\n+        MIGRATION_MODULES={'migrations': 'migrations.test_migrations_no_file'},\n+    )\n+    def test_loading_package_with_no_file_attribute(self):\n+        \"\"\"\n+        To support frozen environments, MigrationLoader loads migrations from\n+        regular packages with no __file__ attribute. This test checks whether\n+        migrations can still be loaded under these conditions.\n+        \"\"\"\n+        loader = MigrationLoader(connection)\n+        module_name = 'migrations.test_migrations_no_file'\n+        test_module = import_module(module_name)\n+        # Backup original attributes\n+        module_file = test_module.__file__\n+        module_origin = test_module.__spec__.origin\n+        module_has_location = test_module.__spec__.has_location\n+\n+        try:\n+            # Simulate missing __file__ and spec attributes in frozen environments\n+            delattr(test_module, '__file__')\n+            test_module.__spec__.origin = None\n+            test_module.__spec__.has_location = False\n+\n+            loader.load_disk()\n+            migrations = [\n+                name for app, name in loader.disk_migrations if app == 'migrations'\n+            ]\n+            self.assertCountEqual(migrations, ['0001_initial', '0002_second'])\n+        finally:\n+            # Restore original attributes\n+            if module_file:\n+                test_module.__file__ = module_file\n+            if module_origin is not None:\n+                test_module.__spec__.origin = module_origin\n+            if module_has_location is not None:\n+                test_module.__spec__.has_location = module_has_location\n+\n \n class PycLoaderTests(MigrationTestBase):\n \n",
  "django__django-13821": "diff --git a/tests/backends/sqlite/tests.py b/tests/backends/sqlite/tests.py\nindex e602447..e377221 100644\n--- a/tests/backends/sqlite/tests.py\n+++ b/tests/backends/sqlite/tests.py\n@@ -10,6 +10,9 @@ from unittest import mock\n from django.core.exceptions import ImproperlyConfigured\n from django.db import NotSupportedError, connection, transaction\n from django.db.models import Aggregate, Avg, CharField, StdDev, Sum, Variance\n+from unittest import mock\n+from django.core.exceptions import ImproperlyConfigured\n+from django.db.backends.sqlite3.base import Database as dbapi2\n from django.db.utils import ConnectionHandler\n from django.test import (\n     TestCase, TransactionTestCase, override_settings, skipIfDBFeature,\n@@ -36,7 +39,27 @@ class Tests(TestCase):\n                 self.assertRaisesMessage(ImproperlyConfigured, msg):\n             check_sqlite_version()\n \n-    def test_aggregation(self):\n+    def test_check_sqlite_version_supported(self):\n+        \"\"\"Test that no exception is raised for supported SQLite version.\"\"\"\n+        with mock.patch.object(dbapi2, 'sqlite_version_info', (3, 9, 0)), \\\n+                mock.patch.object(dbapi2, 'sqlite_version', '3.9.0'):\n+            try:\n+                check_sqlite_version()\n+            except ImproperlyConfigured:\n+                self.fail(\"check_sqlite_version() raised ImproperlyConfigured unexpectedly for SQLite 3.9.0\")\n+\n+    def test_check_sqlite_version_unsupported(self):\n+        \"\"\"Test that ImproperlyConfigured is raised for unsupported SQLite versions < 3.9.0.\"\"\"\n+        versions = [\n+            (3, 8, 0),\n+            (3, 8, 11, 1),\n+            (3, 8, 7),\n+        ]\n+        for version in versions:\n+            with mock.patch.object(dbapi2, 'sqlite_version_info', version), \\\n+                    mock.patch.object(dbapi2, 'sqlite_version', '.'.join(map(str, version))), \\\n+                    self.assertRaises(ImproperlyConfigured):\n+                check_sqlite_version()\n         \"\"\"Raise NotSupportedError when aggregating on date/time fields.\"\"\"\n         for aggregate in (Sum, Avg, Variance, StdDev):\n             with self.assertRaises(NotSupportedError):\n",
  "django__django-13837": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 10ffa22..5836a64 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -172,8 +172,14 @@ class TestChildArguments(SimpleTestCase):\n             autoreload.get_child_arguments(),\n             [sys.executable, '-Werror', __file__, 'runserver']\n         )\n-\n+    @mock.patch.dict(sys.modules, {'__main__': test_main})\n+    @mock.patch('sys.argv', [test_main.__file__, 'runserver'])\n     @mock.patch('sys.warnoptions', [])\n+    def test_run_as_non_django_module(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-m', 'utils_tests.test_module', 'runserver']\n+        )\n     def test_exe_fallback(self):\n         with tempfile.TemporaryDirectory() as tmpdir:\n             exe_path = Path(tmpdir) / 'django-admin.exe'\n",
  "django__django-13925": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 6424d89..6a6e977 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -399,19 +399,99 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n             pass\n+        \n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n+    def test_inherited_manual_pk_without_warning(self):\n+        class BaseModel(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class SubModel(BaseModel):\n+            pass\n+\n+        # There should not be any warnings because the primary key is manually set in the base class.\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+        \n+    def test_inherited_manual_pk_with_parent_link_without_warning(self):\n+        class BaseModel(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class SubModelWithLink(BaseModel):\n+            base_ptr = models.OneToOneField(BaseModel, on_delete=models.CASCADE, parent_link=True)\n \n+        # There should not be any warnings because the primary key is manually set in the base class.\n         self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n \n+    def test_subclass_without_manual_primary_key_should_warn(self):\n+        class SomeModel(models.Model):\n+            pass\n+\n+        class OtherModel(SomeModel):\n+            pass\n+        \n+        # Warning should be raised because no primary key is manually specified\n+        self.assertEqual(\n+            checks.run_checks(app_configs=self.apps.get_app_configs()),\n+            [\n+                Warning(\n+                    \"Auto-created primary key used when not defining a primary key type, by default 'django.db.models.AutoField'.\",\n+                    hint=\"Configure the DEFAULT_AUTO_FIELD setting or the CheckDefaultPKConfig.default_auto_field attribute to point to a subclass of AutoField, e.g. 'django.db.models.BigAutoField'.\",\n+                    obj=SomeModel,\n+                    id='models.W042',\n+                ),\n+            ],\n+        )\n+\n     def test_explicit_pk(self):\n         class Model(models.Model):\n             id = models.BigAutoField(primary_key=True)\n+        \n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n \n+    def test_inherited_manual_pk_without_warning(self):\n+        class BaseModel(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class SubModel(BaseModel):\n+            pass\n+\n+        # There should not be any warnings because the primary key is manually set in the base class.\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+        \n+    def test_inherited_manual_pk_with_parent_link_without_warning(self):\n+        class BaseModel(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class SubModelWithLink(BaseModel):\n+            base_ptr = models.OneToOneField(BaseModel, on_delete=models.CASCADE, parent_link=True)\n+\n+        # There should not be any warnings because the primary key is manually set in the base class.\n         self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n \n+    def test_subclass_without_manual_primary_key_should_warn(self):\n+        class SomeModel(models.Model):\n+            pass\n+\n+        class OtherModel(SomeModel):\n+            pass\n+        \n+        # Warning should be raised because no primary key is manually specified\n+        self.assertEqual(\n+            checks.run_checks(app_configs=self.apps.get_app_configs()),\n+            [\n+                Warning(\n+                    \"Auto-created primary key used when not defining a primary key type, by default 'django.db.models.AutoField'.\",\n+                    hint=\"Configure the DEFAULT_AUTO_FIELD setting or the CheckDefaultPKConfig.default_auto_field attribute to point to a subclass of AutoField, e.g. 'django.db.models.BigAutoField'.\",\n+                    obj=SomeModel,\n+                    id='models.W042',\n+                ),\n+            ],\n+        )\n+\n     @isolate_apps('check_framework.apps.CheckPKConfig', kwarg_name='apps')\n     def test_app_default_auto_field(self, apps):\n         class ModelWithPkViaAppConfig(models.Model):\n             class Meta:\n                 app_label = 'check_framework.apps.CheckPKConfig'\n \n-        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n",
  "django__django-13933": "",
  "django__django-13964": "diff --git a/tests/many_to_one/tests.py b/tests/many_to_one/tests.py\nindex 8af1b8e..bd7062e 100644\n--- a/tests/many_to_one/tests.py\n+++ b/tests/many_to_one/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n from copy import deepcopy\n \n@@ -548,8 +549,31 @@ class ManyToOneTests(TestCase):\n         child.refresh_from_db()\n         self.assertEqual(child.parent, parent)\n         self.assertEqual(child.parent_id, parent.name)\n-\n-    def test_fk_to_bigautofield(self):\n+    \n+    def test_set_fk_after_parent_with_non_numeric_pk_set_on_child_with_issue(self):\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey()\n+            child = ChildStringPrimaryKeyParent(parent=parent)\n+            child.parent.name = 'issue'\n+            parent.save()\n+            child.save()\n+            child.refresh_from_db()\n+            self.assertEqual(child.parent.name, 'issue')\n+            self.assertEqual(child.parent_id, 'issue')\n+            # Check for anomaly described in the issue\n+            self.assertFalse(ChildStringPrimaryKeyParent.objects.filter(parent_id=\"\").exists())\n+\n+    def test_set_fk_after_parent_with_non_numeric_pk_set_on_child_resolved(self):\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey(name='resolved')\n+            parent.save()\n+            child = ChildStringPrimaryKeyParent(parent=parent)\n+            child.save()\n+            child.refresh_from_db()\n+            self.assertEqual(child.parent, parent)\n+            self.assertEqual(child.parent_id, parent.name)\n+            # Ensure that the child referencing the parent is correctly resolved\n+            self.assertTrue(ChildStringPrimaryKeyParent.objects.filter(parent=parent).exists())\n         ch = City.objects.create(name='Chicago')\n         District.objects.create(city=ch, name='Far South')\n         District.objects.create(city=ch, name='North')\n",
  "django__django-14007": "diff --git a/tests/custom_pk/tests.py b/tests/custom_pk/tests.py\nindex cbae2d9..69567b6 100644\n--- a/tests/custom_pk/tests.py\n+++ b/tests/custom_pk/tests.py\n@@ -1,7 +1,10 @@\n+\n from django.db import IntegrityError, transaction\n from django.test import TestCase, skipIfDBFeature\n \n-from .models import Bar, Business, Employee, Foo\n+from .models import Bar, Business, Employee, Foo, CustomAutoFieldModel\n+from .fields import MyAutoField, MyWrapperField, MyWrapper\n+from django.test import skipUnlessDBFeature\n \n \n class BasicCustomPKTests(TestCase):\n@@ -220,7 +223,21 @@ class CustomPKTests(TestCase):\n         self.assertEqual(f, new_foo),\n         self.assertEqual(f.bar, new_bar)\n \n-    # SQLite lets objects be saved with an empty primary key, even though an\n+    def test_auto_field_subclass_create(self):\n+        \"\"\"\n+        Test that MyAutoField calls from_db_value on instance creation.\n+        \"\"\"\n+        obj = CustomAutoFieldModel.objects.create()\n+        self.assertIsInstance(obj.id, MyWrapper)\n+\n+    @skipUnlessDBFeature('can_return_rows_from_bulk_insert')\n+    def test_auto_field_subclass_bulk_create(self):\n+        \"\"\"\n+        Test that MyAutoField calls from_db_value on bulk creation.\n+        \"\"\"\n+        obj = CustomAutoFieldModel()\n+        CustomAutoFieldModel.objects.bulk_create([obj])\n+        self.assertIsInstance(obj.id, MyWrapper)\n     # integer is expected. So we can't check for an error being raised in that\n     # case for SQLite. Remove it from the suite for this next bit.\n     @skipIfDBFeature('supports_unspecified_pk')\n",
  "django__django-14017": "",
  "django__django-14053": "diff --git a/tests/staticfiles_tests/test_storage.py b/tests/staticfiles_tests/test_storage.py\nindex 76f3d3e..2ed4f49 100644\n--- a/tests/staticfiles_tests/test_storage.py\n+++ b/tests/staticfiles_tests/test_storage.py\n@@ -203,6 +203,26 @@ class TestHashedFiles:\n         self.assertIn(os.path.join('cached', 'css', 'window.css'), stats['post_processed'])\n         self.assertIn(os.path.join('cached', 'css', 'img', 'window.png'), stats['unmodified'])\n         self.assertIn(os.path.join('test', 'nonascii.css'), stats['post_processed'])\n+        \n+        # No file should be yielded twice.\n+        self.assertCountEqual(stats['post_processed'], set(stats['post_processed']))\n+\n+        # Check that a known file is not duplicated\n+        duplicated_file = os.path.join('admin', 'css', 'base.css')\n+        yield_counts = {name: 0 for name in stats['post_processed']}\n+        for name in stats['post_processed']:\n+            yield_counts[name] += 1\n+        self.assertEqual(yield_counts[duplicated_file], 1)\n+\n+        # Check if any of the entry from paths are yielded more than once\n+        seen_files = {}\n+        for name in stats['post_processed']:\n+            if name not in seen_files:\n+                seen_files[name] = 0\n+            seen_files[name] += 1\n+        \n+        for name, count in seen_files.items():\n+            self.assertEqual(count, 1, f\"The file {name} was post-processed more than once.\")\n         self.assertPostCondition()\n \n     def test_css_import_case_insensitive(self):\n",
  "django__django-14089": "diff --git a/tests/utils_tests/test_datastructures.py b/tests/utils_tests/test_datastructures.py\nindex 7fb3d83..855d539 100644\n--- a/tests/utils_tests/test_datastructures.py\n+++ b/tests/utils_tests/test_datastructures.py\n@@ -1,10 +1,11 @@\n+\n \"\"\"\n Tests for stuff in django.utils.datastructures.\n \"\"\"\n \n import copy\n import pickle\n-\n+import collections.abc\n from django.test import SimpleTestCase\n from django.utils.datastructures import (\n     CaseInsensitiveMapping, DictWrapper, ImmutableList, MultiValueDict,\n@@ -34,6 +35,21 @@ class OrderedSetTests(SimpleTestCase):\n         s.discard(2)\n         self.assertEqual(len(s), 1)\n \n+    def test_reversed(self):\n+        s = reversed(OrderedSet([1, 2, 3]))\n+        self.assertIsInstance(s, collections.abc.Iterator)\n+        self.assertEqual(list(s), [3, 2, 1])\n+\n+    def test_reversed_empty(self):\n+        s = reversed(OrderedSet())\n+        self.assertIsInstance(s, collections.abc.Iterator)\n+        self.assertEqual(list(s), [])\n+\n+    def test_reversed_single_element(self):\n+        s = reversed(OrderedSet([42]))\n+        self.assertIsInstance(s, collections.abc.Iterator)\n+        self.assertEqual(list(s), [42])\n+\n     def test_contains(self):\n         s = OrderedSet()\n         self.assertEqual(len(s), 0)\n",
  "django__django-14122": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 83089d9..23943d5 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -1,9 +1,11 @@\n+\n from datetime import datetime\n from operator import attrgetter\n \n from django.db.models import (\n     CharField, DateTimeField, F, Max, OuterRef, Subquery, Value,\n )\n+from django.db import connection\n from django.db.models.functions import Upper\n from django.test import TestCase\n \n@@ -311,7 +313,21 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n-    def test_order_by_pk(self):\n+    def test_meta_ordering_not_in_group_by(self):\n+        \"\"\"\n+        Ensure that fields in Meta.ordering are not included in the GROUP BY clause.\n+        \"\"\"\n+        with connection.cursor() as cursor:\n+            Article.objects.exclude(headline='Article 4').update(author=self.author_1)\n+            Article.objects.filter(headline='Article 4').update(author=self.author_2)\n+            articles = Article.objects.values('author').annotate(count=Count('author'))\n+            query = str(articles.query)\n+            self.assertNotIn('GROUP BY', query)\n+\n+        with connection.cursor() as cursor:\n+            articles = Article.objects.annotate(max_date=Max('pub_date')).order_by('headline').filter(author__isnull=False).annotate(count=Count('author')).values('author', 'count')\n+            query = str(articles.query)\n+            self.assertNotRegex(query, r'GROUP BY.*headline', \"'headline' should not be in GROUP BY clause when ordering by 'headline' in Meta.\")\n         \"\"\"\n         'pk' works as an ordering option in Meta.\n         \"\"\"\n@@ -483,4 +499,4 @@ class OrderingTests(TestCase):\n         )\n         ca4 = ChildArticle.objects.create(headline='h1', pub_date=datetime(2005, 7, 28))\n         articles = ChildArticle.objects.order_by('article_ptr')\n-        self.assertSequenceEqual(articles, [ca4, ca2, ca1, ca3])\n+        self.assertSequenceEqual(articles, [ca4, ca2, ca1, ca3])\n",
  "django__django-14140": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex c3db825..e65fc87 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -824,7 +824,26 @@ class BasicExpressionsTests(TestCase):\n             [self.example_inc.ceo, self.max],\n         )\n \n-    def test_boolean_expression_combined_with_empty_Q(self):\n+    def test_boolean_expression_combined_with_Exists(self):\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        # Test combining Exists() with logical operators and checking deconstruction\n+        exists_expression = Exists(is_poc)\n+        q = Q(exists_expression)\n+        _, args, kwargs = q.deconstruct()\n+        self.assertEqual(args, (exists_expression,))\n+        self.assertEqual(kwargs, {})\n+\n+        tests = [\n+            exists_expression & Q(),\n+            Q() & exists_expression,\n+            exists_expression | Q(),\n+            Q() | exists_expression,\n+        ]\n+        for conditions in tests:\n+            with self.subTest(conditions):\n+                self.assertCountEqual(Employee.objects.filter(conditions), [self.max])\n         is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n         self.gmbh.point_of_contact = self.max\n         self.gmbh.save()\n",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..acb7177 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,10 +1,32 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n from django.test.utils import isolate_apps\n \n+from django.test import modify_settings\n+\n+class MyBigAutoField(models.BigAutoField):\n+    pass\n+\n+class MySmallAutoField(models.SmallAutoField):\n+    pass\n \n @isolate_apps('model_options')\n+class MyAutoFieldSubclassTests(SimpleTestCase):\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_mybigautofield(self):\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_mysmallautofield(self):\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n class TestDefaultPK(SimpleTestCase):\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.NonexistentAutoField')\n     def test_default_auto_field_setting_nonexistent(self):\n",
  "django__django-14311": "",
  "django__django-14349": "",
  "django__django-14351": "diff --git a/tests/aggregation_regress/tests.py b/tests/aggregation_regress/tests.py\nindex 79963c3..dcfa9d2 100644\n--- a/tests/aggregation_regress/tests.py\n+++ b/tests/aggregation_regress/tests.py\n@@ -1526,7 +1526,34 @@ class AggregationTests(TestCase):\n         DistinctAggregate('foo', distinct=True)\n \n \n-class JoinPromotionTests(TestCase):\n+class QObjectTests(TestCase):\n+    def test_subquery_multi_column_error(self):\n+        property_groups = PropertyGroup.objects.all()  # Assuming some objects exist\n+        queryset = ManagerTicketRatingCumulativeMovingAverage.objects.annotate(Count('agent__property_groups'))\n+        \n+        # This should work without raising an error now\n+        try:\n+            queryset.filter(\n+                Q(agent__property_groups__in=property_groups) |\n+                Q(agent__property_groups__count=0)\n+            ).distinct()\n+        except ProgrammingError as e:\n+            self.fail(f\"Subquery raised an error: {e}\")\n+\n+    def test_working_filter_with_values_list(self):\n+        property_group_ids = PropertyGroup.objects.values_list('id', flat=True)  # Assuming some objects exist\n+        \n+        queryset = ManagerTicketRatingCumulativeMovingAverage.objects.annotate(Count('agent__property_groups'))\n+        \n+        # Test a working case\n+        result = queryset.filter(\n+            Q(agent__property_groups__id__in=property_group_ids) |\n+            Q(agent__property_groups__count=0)\n+        ).distinct()\n+        \n+        # Assert something about result, this is a dummy line\n+        # This should be changed according to what's expected\n+        self.assertTrue(result.exists())\n     def test_ticket_21150(self):\n         b = Bravo.objects.create()\n         c = Charlie.objects.create(bravo=b)\n",
  "django__django-14373": "diff --git a/tests/utils_tests/test_dateformat.py b/tests/utils_tests/test_dateformat.py\nindex 2f7c68b..33dc593 100644\n--- a/tests/utils_tests/test_dateformat.py\n+++ b/tests/utils_tests/test_dateformat.py\n@@ -157,14 +157,19 @@ class DateFormatTests(SimpleTestCase):\n             with self.assertRaisesMessage(TypeError, msg):\n                 dateformat.format(my_birthday, specifier)\n \n-    def test_r_format_with_non_en_locale(self):\n-        # Changing the locale doesn't change the \"r\" format.\n-        dt = datetime(1979, 7, 8, 22, 00)\n-        with translation.override('fr'):\n-            self.assertEqual(\n-                dateformat.format(dt, 'r'),\n-                'Sun, 08 Jul 1979 22:00:00 +0100',\n-            )\n+    from datetime import datetime\n+    from django.utils import dateformat\n+\n+    def test_y_format_year_before_1000(self):\n+        self.assertEqual(dateformat.format(datetime(1, 1, 1), 'Y'), '0001')\n+        self.assertEqual(dateformat.format(datetime(999, 1, 1), 'Y'), '0999')\n+\n+    def test_Y_format_year_before_1000(self):\n+        # Test the transition from 999 to 1000 to ensure correctness\n+        self.assertEqual(dateformat.format(datetime(0, 1, 1), 'Y'), '0000')\n+        self.assertEqual(dateformat.format(datetime(999, 1, 1), 'Y'), '0999')\n+        self.assertEqual(dateformat.format(datetime(1000, 1, 1), 'Y'), '1000')\n+        self.assertEqual(dateformat.format(datetime(2023, 1, 1), 'Y'), '2023')\n \n     def test_year_before_1000(self):\n         tests = [\n",
  "django__django-14376": "diff --git a/tests/dbshell/test_mysql.py b/tests/dbshell/test_mysql.py\nindex 643c2b6..481a543 100644\n--- a/tests/dbshell/test_mysql.py\n+++ b/tests/dbshell/test_mysql.py\n@@ -38,6 +38,40 @@ class MySqlDbshellCommandTestCase(SimpleTestCase):\n             (expected_args, expected_env),\n         )\n \n+    def test_deprecated_and_non_deprecated_key_mix(self):\n+        settings_port = 444\n+        options_port = 555\n+        self.assertNotEqual(settings_port, options_port, 'test pre-req')\n+        expected_args = [\n+            'mysql',\n+            '--user=optionuser',\n+            '--host=optionhost',\n+            '--port=%s' % options_port,\n+            'optiondbname',\n+        ]\n+        expected_env = {'MYSQL_PWD': 'optionpassword'}\n+        \n+        # Mix of deprecated and non-deprecated keys\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\n+                'NAME': 'settingdbname',\n+                'USER': 'settinguser',\n+                'PASSWORD': 'settingpassword',\n+                'HOST': 'settinghost',\n+                'PORT': settings_port,\n+                'OPTIONS': {\n+                    'database': 'optiondbname',\n+                    'db': 'shouldnotuse',\n+                    'password': 'optionpassword',\n+                    'passwd': 'unused',\n+                    'user': 'optionuser',\n+                    'host': 'optionhost',\n+                    'port': options_port,\n+                },\n+            }),\n+            (expected_args, expected_env),\n+        )\n+\n     def test_options_override_settings_proper_values(self):\n         settings_port = 444\n         options_port = 555\n@@ -68,6 +102,40 @@ class MySqlDbshellCommandTestCase(SimpleTestCase):\n             (expected_args, expected_env),\n         )\n \n+    def test_deprecated_and_non_deprecated_key_mix(self):\n+        settings_port = 444\n+        options_port = 555\n+        self.assertNotEqual(settings_port, options_port, 'test pre-req')\n+        expected_args = [\n+            'mysql',\n+            '--user=optionuser',\n+            '--host=optionhost',\n+            '--port=%s' % options_port,\n+            'optiondbname',\n+        ]\n+        expected_env = {'MYSQL_PWD': 'optionpassword'}\n+        \n+        # Mix of deprecated and non-deprecated keys\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\n+                'NAME': 'settingdbname',\n+                'USER': 'settinguser',\n+                'PASSWORD': 'settingpassword',\n+                'HOST': 'settinghost',\n+                'PORT': settings_port,\n+                'OPTIONS': {\n+                    'database': 'optiondbname',\n+                    'db': 'shouldnotuse',\n+                    'password': 'optionpassword',\n+                    'passwd': 'unused',\n+                    'user': 'optionuser',\n+                    'host': 'optionhost',\n+                    'port': options_port,\n+                },\n+            }),\n+            (expected_args, expected_env),\n+        )\n+\n     def test_options_password(self):\n         expected_args = [\n             'mysql',\n@@ -89,6 +157,40 @@ class MySqlDbshellCommandTestCase(SimpleTestCase):\n             (expected_args, expected_env),\n         )\n \n+    def test_deprecated_and_non_deprecated_key_mix(self):\n+        settings_port = 444\n+        options_port = 555\n+        self.assertNotEqual(settings_port, options_port, 'test pre-req')\n+        expected_args = [\n+            'mysql',\n+            '--user=optionuser',\n+            '--host=optionhost',\n+            '--port=%s' % options_port,\n+            'optiondbname',\n+        ]\n+        expected_env = {'MYSQL_PWD': 'optionpassword'}\n+        \n+        # Mix of deprecated and non-deprecated keys\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\n+                'NAME': 'settingdbname',\n+                'USER': 'settinguser',\n+                'PASSWORD': 'settingpassword',\n+                'HOST': 'settinghost',\n+                'PORT': settings_port,\n+                'OPTIONS': {\n+                    'database': 'optiondbname',\n+                    'db': 'shouldnotuse',\n+                    'password': 'optionpassword',\n+                    'passwd': 'unused',\n+                    'user': 'optionuser',\n+                    'host': 'optionhost',\n+                    'port': options_port,\n+                },\n+            }),\n+            (expected_args, expected_env),\n+        )\n+\n     def test_options_charset(self):\n         expected_args = [\n             'mysql',\n",
  "django__django-14434": "diff --git a/tests/schema/tests.py b/tests/schema/tests.py\nindex 39c82bf..a333c32 100644\n--- a/tests/schema/tests.py\n+++ b/tests/schema/tests.py\n@@ -2198,7 +2198,21 @@ class SchemaTests(TransactionTestCase):\n             AuthorWithUniqueNameAndBirthday._meta.constraints = []\n             editor.remove_constraint(AuthorWithUniqueNameAndBirthday, constraint)\n \n-    @skipUnlessDBFeature('supports_expression_indexes')\n+    def test_references_column_with_correct_parameter_type(self):\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        constraint = UniqueConstraint(fields=['name'], name='name_uq')\n+        # Add constraint.\n+        with connection.schema_editor() as editor:\n+            editor.add_constraint(Author, constraint)\n+            sql = constraint.create_sql(Author, editor)\n+        table = Author._meta.db_table\n+        self.assertIs(sql.references_column(table, 'name'), True)\n+        self.assertIs(sql.references_column(table, Author._meta.get_field('name').column), True)\n+        # Remove constraint.\n+        with connection.schema_editor() as editor:\n+            editor.remove_constraint(Author, constraint)\n+        self.assertNotIn(constraint.name, self.get_constraints(table))\n     def test_func_unique_constraint(self):\n         with connection.schema_editor() as editor:\n             editor.create_model(Author)\n",
  "django__django-14493": "",
  "django__django-14500": "diff --git a/tests/migrations/test_executor.py b/tests/migrations/test_executor.py\nindex d884fe4..6196c55 100644\n--- a/tests/migrations/test_executor.py\n+++ b/tests/migrations/test_executor.py\n@@ -653,7 +653,51 @@ class ExecutorTests(MigrationTestBase):\n             recorder.applied_migrations(),\n         )\n \n-    # When the feature is False, the operation and the record won't be\n+    def test_squashed_migration_unapplied(self):\n+        \"\"\"Test that a squashed migration is marked as unapplied when unapplied.\"\"\"\n+        executor = MigrationExecutor(connection)\n+        \n+        # Ensure the squashed migration is applied\n+        executor.migrate([('migrations', '0001_squashed_0002')])\n+        self.assertIn(\n+            ('migrations', '0001_squashed_0002'),\n+            executor.recorder.applied_migrations(),\n+        )\n+        \n+        # Unapply the squashed migration\n+        executor.migrate([('migrations', None)])\n+        \n+        # Check that the squashed migration is marked as unapplied\n+        self.assertNotIn(\n+            ('migrations', '0001_squashed_0002'),\n+            executor.recorder.applied_migrations(),\n+        )\n+    \n+    def test_replaced_migrations_unapplies_squash(self):\n+        \"\"\"Test that unapplying replaced migrations unmarks the squashed one.\"\"\"\n+        executor = MigrationExecutor(connection)\n+        \n+        # Apply individual migrations first\n+        executor.recorder.record_applied('migrations', '0001_initial')\n+        executor.recorder.record_applied('migrations', '0002_second')\n+        \n+        # Apply the squashed migration\n+        executor.migrate([('migrations', '0001_squashed_0002')])\n+        self.assertIn(\n+            ('migrations', '0001_squashed_0002'),\n+            executor.recorder.applied_migrations(),\n+        )\n+        \n+        # Unapply individual replaced migrations\n+        executor.recorder.record_unapplied('migrations', '0001_initial')\n+        executor.recorder.record_unapplied('migrations', '0002_second')\n+        \n+        # Recheck that the squashed migration is now unapplied\n+        executor.migrate([('migrations', None)])\n+        self.assertNotIn(\n+            ('migrations', '0001_squashed_0002'),\n+            executor.recorder.applied_migrations(),\n+        )\n     # performed in a transaction and the test will systematically pass.\n     @skipUnlessDBFeature('can_rollback_ddl')\n     def test_migrations_applied_and_recorded_atomically(self):\n",
  "django__django-14539": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex 23a1e0a..d1e9360 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -256,6 +256,25 @@ class TestUtilsHtml(SimpleTestCase):\n             ),\n             ('foo@example.com', '<a href=\"mailto:foo@example.com\">foo@example.com</a>'),\n         )\n+        # Adding a new test case to verify the resolved issue where `urlize`\n+        # does not handle HTML escaped strings and trailing punctuation correctly.\n+        additional_tests = [\n+            (\n+                'Search for google.com/?q=1&lt! and see.',\n+                'Search for <a href=\"http://google.com/?q=1%3C\">google.com/?q=1&lt</a>! and see.'\n+            ),\n+            (\n+                'Contact us at example.com/contact&lt; now!',\n+                'Contact us at <a href=\"http://example.com/contact%3C\">example.com/contact&lt</a> now!'\n+            ),\n+            (\n+                'Email us at john.doe@company.com.&lt for more info.',\n+                'Email us at <a href=\"mailto:john.doe@company.com\">john.doe@company.com</a>.&lt for more info.'\n+            ),\n+        ]\n+        for value, output in additional_tests:\n+            with self.subTest(value=value):\n+                self.assertEqual(urlize(value), output)\n         for value, output in tests:\n             with self.subTest(value=value):\n                 self.assertEqual(urlize(value), output)\n",
  "django__django-14559": "",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..477ed69 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -316,7 +316,27 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertTrue(formset.is_valid())\n         self.assertEqual([form.cleaned_data for form in formset.forms], [{'votes': 100, 'choice': 'Calexico'}, {}, {}])\n \n-    def test_formset_validate_max_flag(self):\n+    def test_non_form_errors_css_class(self):\n+        \"\"\"\n+        Test that the non-form errors are given the correct CSS class.\n+        \"\"\"\n+        data = {\n+            'choices-TOTAL_FORMS': '2',\n+            'choices-INITIAL_FORMS': '0',\n+            'choices-MIN_NUM_FORMS': '0',\n+            'choices-MAX_NUM_FORMS': '2',\n+            'choices-0-choice': 'Coffee',\n+            'choices-0-votes': '0',\n+            'choices-1-choice': 'Tea',\n+            'choices-1-votes': '1',\n+        }\n+        ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=True)\n+        formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n+        self.assertFalse(formset.is_valid())\n+        self.assertInHTML(\n+            '<ul class=\"errorlist nonform\"><li>Please submit at most 1 form.</li></ul>',\n+            str(formset.non_form_errors())\n+        )\n         \"\"\"\n         If validate_max is set and max_num is less than TOTAL_FORMS in the\n         data, a ValidationError is raised. MAX_NUM_FORMS in the data is\n",
  "django__django-14631": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex a48e4b6..b124101 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -2129,7 +2129,40 @@ Password: <input type=\"password\" name=\"password\" required></li>\n         form = DateTimeForm({'dt': '2006-10-25 14:30:45'})\n         self.assertEqual(form.changed_data, [])\n \n-    def test_help_text(self):\n+    def test_access_via_boundfield_in_clean_fields(self):\n+        now = datetime.datetime(2006, 10, 25, 14, 30, 45)\n+        \n+        class DateTimeForm(forms.Form):\n+            dt = DateTimeField(initial=lambda: now)\n+\n+        form = DateTimeForm({})\n+        form._clean_fields()\n+        cleaned = form.cleaned_data['dt']\n+        \n+        # Access the BoundField and check if initial is correct.\n+        bf = form['dt']\n+        self.assertEqual(cleaned, bf.initial)\n+\n+    def test_access_via_boundfield_in_changed_data(self):\n+        now = datetime.datetime(2006, 10, 25, 14, 30, 45)\n+        \n+        class DateTimeForm(forms.Form):\n+            dt = DateTimeField(initial=lambda: now)\n+\n+        # Simulate a form with default initial data.\n+        form_with_initial = DateTimeForm({'dt': '2006-10-25 14:30:45'})\n+        self.assertEqual(form_with_initial.changed_data, [])\n+        \n+        # Simulate a form with different data to verify change.\n+        form_different = DateTimeForm({'dt': '2006-10-25 14:31:45'})\n+        self.assertIn('dt', form_different.changed_data)\n+\n+        # Check that the BoundField's did_change method respects initial value.\n+        bf_initial = form_with_initial['dt']\n+        self.assertFalse(bf_initial._did_change(now, form_with_initial.fields['dt'].to_python('2006-10-25 14:30:45')))\n+\n+        bf_different = form_different['dt']\n+        self.assertTrue(bf_different._did_change(now, form_different.fields['dt'].to_python('2006-10-25 14:31:45')))\n         # You can specify descriptive text for a field by using the 'help_text' argument)\n         class UserRegistration(Form):\n             username = CharField(max_length=10, help_text='e.g., user@example.com')\n",
  "django__django-14672": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex d9eaabe..fafdf70 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -1,9 +1,70 @@\n from datetime import date, datetime, timedelta\n from operator import attrgetter\n \n+class TestMakeHashableThroughFields(TestCase):\n+    def test_m2m_through_fields_should_be_hashable(self):\n+        class Parent(models.Model):\n+            name = models.CharField(max_length=256)\n+\n+        class ProxyParent(Parent):\n+            class Meta:\n+                proxy = True\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+            many_to_many_field = models.ManyToManyField(\n+                to=Parent,\n+                through=\"ManyToManyModel\",\n+                through_fields=['child', 'parent'],\n+                related_name=\"something\"\n+            )\n+\n+        class ManyToManyModel(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n+            child = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n+            second_child = models.ForeignKey(Child, on_delete=models.CASCADE, null=True, default=None)\n+\n+        # Check the identities are hashable by comparing their hashes\n+        reverse_m2m = Parent._meta.get_field('child').remote_field\n+        inherited_m2m = ProxyParent._meta.get_field('child').remote_field\n+        self.assertEqual(hash(reverse_m2m), hash(inherited_m2m))\n+\n+    def test_field_name_clash_with_m2m_through_for_proxy_models(self):\n+        class Parent(models.Model):\n+            clash_id = models.IntegerField()\n+\n+        class ProxyParent(Parent):\n+            class Meta:\n+                proxy = True\n+\n+        class Child(ProxyParent):\n+            clash = models.ForeignKey('Child', models.CASCADE)\n+\n+        class Model(models.Model):\n+            parents = models.ManyToManyField(\n+                to=ProxyParent,\n+                through='Through',\n+                through_fields=['parent', 'model'],\n+            )\n+\n+        class Through(models.Model):\n+            parent = models.ForeignKey(ProxyParent, models.CASCADE)\n+            model = models.ForeignKey(Model, models.CASCADE)\n+\n+        self.assertEqual(Child.check(), [\n+            Error(\n+                \"The field 'clash' clashes with the field 'clash_id' from \"\n+                \"model 'invalid_models_tests.parent'.\",\n+                obj=Child._meta.get_field('clash'),\n+                id='models.E006',\n+            )\n+        ])\n+\n from django.db import IntegrityError\n from django.test import TestCase\n \n+from django.db import models\n+from django.core.checks import Error\n from .models import (\n     CustomMembership, Employee, Event, Friendship, Group, Ingredient,\n     Invitation, Membership, Person, PersonSelfRefM2M, Recipe, RecipeIngredient,\n",
  "django__django-14752": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex 7ef6d86..752a729 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -1,3 +1,54 @@\n+\n+class AutocompleteJsonSerializeResultViewTests(TestCase):\n+    def setUp(self):\n+        self.factory = RequestFactory()\n+        self.superuser = User.objects.create_superuser(\n+            username='super', password='secret', email='super@example.com'\n+        )\n+        # Define attributes for the view\n+        self.as_view_args = {\"admin_site\": admin.site}\n+        self.url = reverse(\"admin:autocomplete\")  # Replace with actual autocomplete URL\n+        self.opts = {'app_label': 'app', 'model_name': 'model', 'field_name': 'field'}  # Adjust accordingly\n+\n+    def test_serialize_result(self):\n+        class CustomAutocompleteJsonView(AutocompleteJsonView):\n+            def serialize_result(self, obj, to_field_name):\n+                return {\n+                    **super().serialize_result(obj, to_field_name),\n+                    'posted': str(obj.posted),\n+                }\n+\n+        Question.objects.create(question='Question 1', posted=datetime.date(2021, 8, 9))\n+        Question.objects.create(question='Question 2', posted=datetime.date(2021, 8, 7))\n+        request = self.factory.get(self.url, {'term': 'question', **self.opts})\n+        request.user = self.superuser\n+        response = CustomAutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        expected_results = [\n+            {'id': str(q.pk), 'text': q.question, 'posted': str(q.posted)}\n+            for q in Question.objects.order_by('-posted')\n+        ]\n+        self.assertEqual(data['results'], expected_results)\n+        self.assertFalse(data['pagination']['more'])\n+\n+    def test_serialize_result_no_customize_needed(self):\n+        class DefaultAutocompleteJsonView(AutocompleteJsonView):\n+            pass  # No override needed\n+\n+        Question.objects.create(question='Question 3', posted=datetime.date(2021, 8, 6))\n+        request = self.factory.get(self.url, {'term': 'question', **self.opts})\n+        request.user = self.superuser\n+        response = DefaultAutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        expected_results = [\n+            {'id': str(q.pk), 'text': q.question}\n+            for q in Question.objects.all()\n+        ]\n+        self.assertEqual(data['results'], expected_results)\n+        self.assertFalse(data['pagination']['more'])\n+\n import json\n from contextlib import contextmanager\n \n@@ -10,6 +61,9 @@ from django.core.exceptions import PermissionDenied\n from django.http import Http404\n from django.test import RequestFactory, override_settings\n from django.urls import reverse, reverse_lazy\n+import datetime\n+from django.test import TestCase, RequestFactory\n+from .models import Question  # Example model import, adjust as needed\n \n from .admin import AnswerAdmin, QuestionAdmin\n from .models import (\n",
  "django__django-14765": "diff --git a/tests/migrations/test_state.py b/tests/migrations/test_state.py\nindex 11009e5..b838764 100644\n--- a/tests/migrations/test_state.py\n+++ b/tests/migrations/test_state.py\n@@ -914,6 +914,29 @@ class StateTests(SimpleTestCase):\n         project_state.add_model(ModelState.from_model(TestModel))\n         with self.assertRaises(ValueError):\n             project_state.apps\n+        from django.db.migrations.state import ProjectState  # Import the necessary module\n+\n+        def test_real_apps_none(self):\n+            \"\"\"\n+            Test that passing None to `real_apps` sets it to an empty set.\n+            \"\"\"\n+            project_state = ProjectState(real_apps=None)\n+            self.assertEqual(project_state.real_apps, set())\n+\n+        def test_real_apps_empty_set(self):\n+            \"\"\"\n+            Test that passing an empty set to `real_apps` works correctly.\n+            \"\"\"\n+            project_state = ProjectState(real_apps=set())\n+            self.assertEqual(project_state.real_apps, set())\n+\n+        def test_real_apps_as_set(self):\n+            \"\"\"\n+            Test that passing a valid set to `real_apps` is stored correctly.\n+            \"\"\"\n+            apps_set = {'auth', 'contenttypes'}\n+            project_state = ProjectState(real_apps=apps_set)\n+            self.assertEqual(project_state.real_apps, apps_set)\n \n         # If we include the real app it should succeed\n         project_state = ProjectState(real_apps={'contenttypes'})\n",
  "django__django-14771": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 1875424..ab42b5a 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -452,11 +452,30 @@ class TestRaiseLastException(SimpleTestCase):\n             except Exception:\n                 exc_info = sys.exc_info()\n \n-        with mock.patch('django.utils.autoreload._exception', exc_info):\n-            with self.assertRaises(Exception) as cm:\n-                autoreload.raise_last_exception()\n-            self.assertEqual(cm.exception.args[0], 1)\n-            self.assertEqual(cm.exception.__cause__.args[0], 2)\n+    @mock.patch('sys._xoptions', {})\n+    @mock.patch('sys.argv', [__file__, 'runserver'])\n+    @mock.patch('sys.warnoptions', [])\n+    def test_xoptions_empty(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, __file__, 'runserver']\n+        )\n+\n+    @mock.patch('sys._xoptions', {'utf8': True, 'a': 'b'})\n+    @mock.patch('sys.argv', [__file__, 'runserver'])\n+    @mock.patch('sys.warnoptions', [])\n+    def test_xoptions_utf8_and_a_b(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-Xutf8', '-Xa=b', __file__, 'runserver']\n+        )\n+\n+    def test_xoptions_custom(self):\n+        with mock.patch('sys._xoptions', {'custom': 'option'}):\n+            self.assertEqual(\n+                autoreload.get_child_arguments(),\n+                [sys.executable, '-Xcustom=option', __file__, 'runserver']\n+            )\n \n \n class RestartWithReloaderTests(SimpleTestCase):\n",
  "django__django-14787": "",
  "django__django-14855": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 507855b..8fb1b9d 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -5085,6 +5085,37 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase):\n         response = self.client.get(reverse('admin2:auth_user_password_change', args=(su.pk,)))\n         self.assertEqual(response.status_code, 404)\n \n+    def _test_readonly_foreignkey_links(self, admin_site_namespace):\n+        \"\"\"\n+        Helper function to test ForeignKey readonly fields in different admin sites.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1',\n+            content='content',\n+            book=Book.objects.create(name='Book 1'),\n+        )\n+        language = Language.objects.create(iso='_40', name='Test')\n+        response = self.client.get(reverse(f'{admin_site_namespace}:admin_views_chapter_change', args=(chapter.pk,)))\n+        \n+        language_url = reverse(f'{admin_site_namespace}:admin_views_language_change', args=(quote(language.pk),))\n+        self.assertContains(\n+            response,\n+            '<div class=\"readonly\"><a href=\"%s\">_40</a></div>' % language_url,\n+            html=True,\n+        )\n+\n+    def test_readonly_foreignkey_links_default_admin_site(self):\n+        \"\"\"\n+        Test ForeignKey readonly fields in the default admin site.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('admin')\n+\n+    def test_readonly_foreignkey_links_custom_admin_site(self):\n+        \"\"\"\n+        Test ForeignKey readonly fields in a custom admin site.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('namespaced_admin')\n+\n     def test_change_form_renders_correct_null_choice_value(self):\n         \"\"\"\n         Regression test for #17911.\n",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..94f1957 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,9 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n@@ -279,6 +280,26 @@ class ModelChoiceFieldTests(TestCase):\n         field = CustomModelChoiceField(Category.objects.all())\n         self.assertIsInstance(field.choices, CustomModelChoiceIterator)\n \n+    def test_choice_value_hash(self):\n+        # Test hashability of ModelChoiceIteratorValue\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+        value_3 = ModelChoiceIteratorValue(self.c1.pk, None)\n+\n+        # Assert that the hash of a value is based solely on the 'value'\n+        self.assertEqual(hash(value_1), hash(value_3))\n+        self.assertNotEqual(hash(value_1), hash(value_2))\n+\n+        # Assert that ModelChoiceIteratorValue is usable as a dict key\n+        test_dict = {value_1: \"first entry\"}\n+        test_dict[value_3] = \"overwritten entry\"  # this should overwrite due to the same hash\n+        self.assertEqual(len(test_dict), 1)\n+        self.assertEqual(test_dict[value_1], \"overwritten entry\")\n+\n+        # Test contains functionality for dict keys\n+        self.assertIn(value_3, test_dict)\n+        self.assertNotIn(value_2, test_dict)\n+        \n     def test_choice_iterator_passes_model_to_widget(self):\n         class CustomCheckboxSelectMultiple(CheckboxSelectMultiple):\n             def create_option(self, name, value, label, selected, index, subindex=None, attrs=None):\n",
  "django__django-14999": "",
  "django__django-15022": "diff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex e1920cd..063c512 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -144,8 +144,52 @@ class ChangeListTests(TestCase):\n         class GetListSelectRelatedAdmin(admin.ModelAdmin):\n             list_display = ('band', 'player')\n \n-            def get_list_select_related(self, request):\n-                return ('band', 'player')\n+from django.test import TestCase\n+from django.contrib.admin.views.main import SEARCH_VAR\n+from .admin import site as custom_site\n+from .models import Parent, Child\n+from django.db import connection\n+from django.test.utils import CaptureQueriesContext\n+\n+class ClientAdminTest(TestCase):\n+    def setUp(self):\n+        self.superuser = User.objects.create_superuser('admin', 'admin@example.com', 'password')\n+        self.client.force_login(self.superuser)\n+        self.factory = RequestFactory()\n+        \n+    def test_many_search_terms_no_extra_joins(self):\n+        parent = Parent.objects.create(name='ParentName')\n+        Child.objects.create(parent=parent, name='ChildName1')\n+        Child.objects.create(parent=parent, name='ChildName2')\n+        \n+        m = ParentAdmin(Parent, custom_site)\n+        request = self.factory.get('/parent/', data={SEARCH_VAR: 'childname1 ' * 4})\n+        request.user = self.superuser\n+        \n+        cl = m.get_changelist_instance(request)\n+        with CaptureQueriesContext(connection) as context:\n+            object_count = cl.queryset.count()\n+        \n+        self.assertEqual(object_count, 1)\n+        joins_count = context.captured_queries[0]['sql'].count('JOIN')\n+        self.assertLessEqual(joins_count, 1, 'Excessive joins were found in the queryset')\n+        \n+    def test_search_fields_on_related_models(self):\n+        parent = Parent.objects.create(name='ParentName')\n+        Child.objects.create(parent=parent, name='ChildName1', age=10)\n+        Child.objects.create(parent=parent, name='ChildName2', age=12)\n+\n+        m = ParentAdminTwoSearchFields(Parent, custom_site)\n+        request = self.factory.get('/parent/', data={SEARCH_VAR: 'childname2 12'})\n+        request.user = self.superuser\n+        \n+        cl = m.get_changelist_instance(request)\n+        self.assertEqual(cl.queryset.count(), 1)\n+        \n+        request = self.factory.get('/parent/', data={SEARCH_VAR: 'childname1 12'})\n+        request.user = self.superuser\n+        cl = m.get_changelist_instance(request)\n+        self.assertEqual(cl.queryset.count(), 0)\n \n         ia = GetListSelectRelatedAdmin(Invitation, custom_site)\n         request = self.factory.get('/invitation/')\n",
  "django__django-15037": "diff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py\nindex 19402bb..38422e3 100644\n--- a/tests/inspectdb/tests.py\n+++ b/tests/inspectdb/tests.py\n@@ -204,7 +204,20 @@ class InspectDBTestCase(TestCase):\n             output,\n         )\n \n-    def test_digits_column_name_introspection(self):\n+    @skipUnlessDBFeature('can_introspect_foreign_keys')\n+    def test_foreign_key_to_non_primary_unique_field(self):\n+        \"\"\"\n+        Test that a foreign key to a non-primary unique field is correctly introspected.\n+        \"\"\"\n+        out = StringIO()\n+        call_command('inspectdb', 'inspectdb_foreignkeytofield', stdout=out)\n+        output = out.getvalue()\n+\n+        # Checking that the foreign key is correctly pointing to the specific unique field\n+        self.assertIn(\n+            \"to_field_fk = models.ForeignKey('InspectdbPeoplemoredata', models.CASCADE, to_field='people_unique')\",\n+            output,\n+        )\n         \"\"\"Introspection of column names consist/start with digits (#16536/#17676)\"\"\"\n         char_field_type = connection.features.introspected_field_types['CharField']\n         out = StringIO()\n",
  "django__django-15103": "",
  "django__django-15104": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex 04452fa..6a482be 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -2833,9 +2833,52 @@ class AutodetectorTests(TestCase):\n                     MigrationAutodetector.parse_number(migration_name),\n                     expected_number,\n                 )\n+from django.db import models\n+from django.db.migrations.state import ModelState, ProjectState\n+from django.test import SimpleTestCase, TestCase\n+from django.db.migrations.autodetector import MigrationAutodetector\n+\n+class TestAutodetectorWithCustomFKField(TestCase):\n+    def test_add_custom_fk_with_hardcoded_to(self):\n+        class HardcodedForeignKey(models.ForeignKey):\n+            def __init__(self, *args, **kwargs):\n+                kwargs['to'] = 'testapp.Author'\n+                super().__init__(*args, **kwargs)\n+\n+            def deconstruct(self):\n+                name, path, args, kwargs = super().deconstruct()\n+                del kwargs['to']\n+                return name, path, args, kwargs\n+\n+        # Initial state without the model that uses HardcodedForeignKey\n+        before = ProjectState()\n+        before.add_model(ModelState('testapp', 'Author', []))\n+\n+        # New state with the new model added\n+        after = ProjectState()\n+        after.add_model(ModelState('testapp', 'Author', []))\n+        after.add_model(ModelState('testapp', 'Book', [\n+            ('author', HardcodedForeignKey(on_delete=models.CASCADE)),\n+        ]))\n+\n+        # Run the autodetector to ensure there's a migration detected\n+        changes = MigrationAutodetector(before, after)._detect_changes()\n+        self.assertEqual(len(changes['testapp']), 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, ['CreateModel'])\n+        self.assertOperationAttributes(changes, 'testapp', 0, 0, name='Book')\n+\n+    def assertNumberMigrations(self, changes, app_label, number):\n+        self.assertEqual(len(changes.get(app_label, [])), number)\n \n+    def assertOperationTypes(self, changes, app_label, migration_idx, types):\n+        ops = changes[app_label][migration_idx].operations\n+        self.assertEqual([op.__class__.__name__ for op in ops], types)\n \n-class MigrationSuggestNameTests(SimpleTestCase):\n+    def assertOperationAttributes(self, changes, app_label, migration_idx, operation_idx, **attrs):\n+        operation = changes[app_label][migration_idx].operations[operation_idx]\n+        for attr_name, expected_value in attrs.items():\n+            actual_value = getattr(operation, attr_name)\n+            self.assertEqual(actual_value, expected_value)\n     def test_no_operations(self):\n         class Migration(migrations.Migration):\n             operations = []\n",
  "django__django-15127": "diff --git a/tests/messages_tests/base.py b/tests/messages_tests/base.py\nindex 85a7769..d3619e4 100644\n--- a/tests/messages_tests/base.py\n+++ b/tests/messages_tests/base.py\n@@ -1,3 +1,4 @@\n+\n from django.contrib.messages import constants, get_level, set_level, utils\n from django.contrib.messages.api import MessageFailure\n from django.contrib.messages.constants import DEFAULT_LEVELS\n@@ -375,6 +376,34 @@ class BaseTests:\n         constants.ERROR: 'bad',\n         29: 'custom',\n     })\n+\n+    @override_settings_tags(MESSAGE_TAGS={\n+        constants.INFO: 'information',\n+        constants.DEBUG: 'debugging',\n+        constants.WARNING: 'caution',\n+        constants.ERROR: 'critical',\n+        constants.SUCCESS: 'victory',\n+        99: 'custom_tag',\n+    })\n+    def test_override_settings_level_tags_updated(self):\n+        storage = self.get_storage()\n+        storage.level = 0\n+        add_level_messages(storage)\n+        tags = [msg.level_tag for msg in storage]\n+        expected_tags = ['information', 'debugging', 'debug', 'caution', 'critical', 'victory']\n+        \n+        self.assertEqual(tags, expected_tags)\n+        \n+    @override_settings_tags(MESSAGE_TAGS={\n+        constants.DEBUG: 'debug',\n+    })\n+    def test_override_debug_tag_with_empty(self):\n+        storage = self.get_storage()\n+        storage.level = 0\n+        storage.add(constants.DEBUG, 'Test debug message')\n+        tags = [msg.level_tag for msg in storage]\n+        \n+        self.assertEqual(tags, ['debug'])\n     def test_custom_tags(self):\n         storage = self.get_storage()\n         storage.level = 0\n",
  "django__django-15128": "diff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex adde8a6..a5d38cc 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -30,8 +30,30 @@ from .models import (\n     SharedConnection, SimpleCategory, SingleObject, SpecialCategory, Staff,\n     StaffUser, Student, Tag, Task, Teacher, Ticket21203Child,\n     Ticket21203Parent, Ticket23605A, Ticket23605B, Ticket23605C, TvChef, Valid,\n-    X,\n+    X, BaseUser, Task,\n )\n+from django.db.models import Q\n+\n+class ConflictAliasQuerySetTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        tag = Tag.objects.create()\n+        annotation_1 = Annotation.objects.create(tag=tag)\n+        annotation_2 = Annotation.objects.create(tag=tag)\n+        note = annotation_1.notes.create(tag=tag)\n+        cls.base_user_1 = BaseUser.objects.create()\n+        cls.base_user_2 = BaseUser.objects.create()\n+        cls.task = Task.objects.create(\n+            owner=cls.base_user_2, creator=cls.base_user_2, note=note,\n+        )\n+\n+    def test_conflicting_aliases_during_combine(self):\n+        qs1 = self.task.owner.all()\n+        qs2 = BaseUser.objects.filter(\n+            Q(owner__note__tag=self.task.note.tag) |\n+            Q(creator__note__tag=self.task.note.tag)\n+        )\n+        self.assertCountEqual(qs1 | qs2, qs2 | qs1)\n \n \n class Queries1Tests(TestCase):\n",
  "django__django-15161": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 5fdccc5..f8701d6 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1775,6 +1775,20 @@ class ValueTests(TestCase):\n         self.assertEqual(len(kwargs), 1)\n         self.assertEqual(kwargs['output_field'].deconstruct(), CharField().deconstruct())\n \n+    def test_deconstruct_F(self):\n+        f_expr = F('field_name')\n+        path, args, kwargs = f_expr.deconstruct()\n+        self.assertEqual(path, 'django.db.models.F')\n+        self.assertEqual(args, ('field_name',))\n+        self.assertEqual(kwargs, {})\n+\n+    def test_deconstruct_F_with_output_field(self):\n+        f_expr = F('field_name')\n+        path, args, kwargs = f_expr.deconstruct()\n+        self.assertEqual(path, 'django.db.models.F')\n+        self.assertEqual(args, ('field_name',))\n+        self.assertEqual(kwargs, {})\n+\n     def test_repr(self):\n         tests = [\n             (None, 'Value(None)'),\n",
  "django__django-15268": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex a6c0858..a2ad1ce 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -1590,8 +1590,28 @@ class AutodetectorTests(TestCase):\n             changes, 'otherapp', 0, 3, name='book',\n             index_together={('title', 'author')},\n         )\n-\n-    def test_add_field_and_foo_together(self):\n+    def test_optimize_foo_together_operations(self):\n+        \"\"\"\n+        Test that multiple AlterFooTogether operations are optimized into one.\n+        \"\"\"\n+        # Simulating the operations described in the issue\n+        changes = self.get_changes(\n+            [self.author_empty, self.book_foo_together],\n+            [self.author_empty, self.book_foo_together_optimized]\n+        )\n+        \n+        # Verify that the changes reduce operations\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, \"otherapp\", 0, [\n+            'AlterUniqueTogether',\n+            'AlterIndexTogether'\n+        ])\n+        self.assertOperationAttributes(\n+            changes, 'otherapp', 0, 0, name='book', unique_together={('col',)}\n+        )\n+        self.assertOperationAttributes(\n+            changes, 'otherapp', 0, 1, name='book', index_together={('col',)}\n+        )\n         \"\"\"\n         Added fields will be created before using them in index/unique_together.\n         \"\"\"\n",
  "django__django-15277": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 11f86ed..85e04c0 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1842,7 +1842,28 @@ class ValueTests(TestCase):\n             (b'', BinaryField),\n             (uuid.uuid4(), UUIDField),\n         ]\n-        for value, output_field_type in value_types:\n+    def test_output_field_does_not_create_broken_validators(self):\n+        \"\"\"\n+        Ensure that the output field for a given Value doesn't cause creation\n+        of broken validators when using a CharField with no max_length.\n+        \"\"\"\n+        value_types = [\n+            'test string',\n+            True,\n+            123,\n+            3.14,\n+            datetime.date(2020, 1, 1),\n+            datetime.datetime(2020, 1, 1, 12, 0),\n+            datetime.time(12, 0),\n+            datetime.timedelta(days=1),\n+            Decimal('3.14'),\n+            b'test bytes',\n+            uuid.uuid4(),\n+        ]\n+        for value in value_types:\n+            with self.subTest(type=type(value)):\n+                field = Value(value)._resolve_output_field()\n+                field.clean(value, model_instance=None)\n             with self.subTest(type=type(value)):\n                 expr = Value(value)\n                 self.assertIsInstance(expr.output_field, output_field_type)\n",
  "django__django-15278": "diff --git a/tests/schema/tests.py b/tests/schema/tests.py\nindex dd02aee..8b972c0 100644\n--- a/tests/schema/tests.py\n+++ b/tests/schema/tests.py\n@@ -638,6 +638,31 @@ class SchemaTests(TransactionTestCase):\n             editor.add_field(Author, new_field)\n         columns = self.column_classes(Author)\n         # MySQL annoyingly uses the same backend, so it'll come back as one of\n+\n+    def test_add_nullable_onetoone_field_with_unique(self):\n+        \"\"\"\n+        Test that adding a nullable OneToOneField with a unique constraint does not cause an error on SQLite.\n+        \"\"\"\n+        with connection.schema_editor() as editor:\n+            editor.create_model(RefreshToken)\n+            editor.create_model(AccessToken)\n+        \n+        new_field = OneToOneField(\n+            RefreshToken,\n+            on_delete=models.SET_NULL,\n+            null=True,\n+            blank=True,\n+            unique=True,\n+            related_name='refreshed_access_token'\n+        )\n+        new_field.set_attributes_from_name('source_refresh_token')\n+        \n+        with connection.schema_editor() as editor:\n+            editor.add_field(AccessToken, new_field)\n+\n+        columns = self.column_classes(AccessToken)\n+        self.assertIn('source_refresh_token_id', columns)\n+        self.assertTrue(columns['source_refresh_token_id'][1][6])  # Check if the field is nullable\n         # these two types.\n         self.assertIn(columns['bits'][0], (\"BinaryField\", \"TextField\"))\n \n",
  "django__django-15315": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex e4daf0e..7da42e2 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -61,6 +61,19 @@ class BasicFieldTests(SimpleTestCase):\n \n         self.assertEqual(m._meta.get_field('id').verbose_name, 'verbose pk')\n \n+    def test_field_initial_hash_in_dict(self):\n+        \"\"\"\n+        Test that a Field's hash value remains the same when used as a key \n+        in a dictionary, even after assignment to a model class attribute.\n+        \"\"\"\n+        field = models.CharField(max_length=200)\n+        initial_hash = hash(field)\n+        field_dict = {field: 'initial'}\n+        class MyModel(models.Model):\n+            name = field\n+        self.assertEqual(field_dict[field], 'initial')\n+        self.assertEqual(initial_hash, hash(field))\n+      \n     def test_choices_form_class(self):\n         \"\"\"Can supply a custom choices form class to Field.formfield()\"\"\"\n         choices = [('a', 'a')]\n",
  "django__django-15368": "",
  "django__django-15380": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex e2de333..dc8cfb5 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -1048,8 +1048,30 @@ class AutodetectorTests(TestCase):\n             changes, 'app', 0, 1, model_name='bar', old_name='foo',\n             new_name='renamed_foo',\n         )\n-\n-    def test_rename_model(self):\n+        \n+    def test_rename_model_and_field_together(self):\n+        \"\"\"Test renaming a model and a field simultaneously.\"\"\"\n+        changes = self.get_changes(\n+            [self.author_name],\n+            [\n+                ModelState('testapp', 'RenamedAuthor', [\n+                    ('id', models.AutoField(primary_key=True)),\n+                    ('renamed_name', models.CharField(max_length=200)),\n+                ]),\n+            ],\n+            MigrationQuestioner({\n+                'ask_rename_model': True,\n+                'ask_rename': True,\n+            }),\n+        )\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        self.assertOperationTypes(changes, 'testapp', 0, ['RenameModel', 'RenameField'])\n+        self.assertOperationAttributes(\n+            changes, 'testapp', 0, 0, old_name='Author', new_name='RenamedAuthor',\n+        )\n+        self.assertOperationAttributes(\n+            changes, 'testapp', 0, 1, old_name='name', new_name='renamed_name',\n+        )\n         \"\"\"Tests autodetection of renamed models.\"\"\"\n         changes = self.get_changes(\n             [self.author_with_book, self.book],\n",
  "django__django-15382": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex bd890ac..2b6e7f0 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1906,7 +1906,23 @@ class ExistsTests(TestCase):\n         self.assertNotIn('ORDER BY', captured_sql)\n \n \n-class FieldTransformTests(TestCase):\n+from django.test import TestCase\n+from django.db.models import Exists, Q\n+from .models import Manager  # Import your model here; adjust according to your actual model path\n+\n+class IssueTestCase(TestCase):\n+    def test_negated_exists_with_empty_queryset(self):\n+        # Set up test data\n+        manager = Manager.objects.create(name='test')\n+        \n+        # Create a queryset using negated Exists wrapped around an empty queryset\n+        qs = Manager.objects.filter(~Exists(Manager.objects.none()), name='test')\n+        \n+        # Assert that the queryset is not empty and contains the expected object\n+        self.assertSequenceEqual(qs, [manager])\n+        \n+        # Print query for additional logging\n+        print(qs.query)\n \n     @classmethod\n     def setUpTestData(cls):\n",
  "django__django-15467": "",
  "django__django-15499": "",
  "django__django-15525": "diff --git a/tests/fixtures_regress/tests.py b/tests/fixtures_regress/tests.py\nindex 3640e99..de5da4b 100644\n--- a/tests/fixtures_regress/tests.py\n+++ b/tests/fixtures_regress/tests.py\n@@ -779,16 +779,54 @@ class NaturalKeyFixtureTests(TestCase):\n         books = Book.objects.all()\n         self.assertQuerysetEqual(\n             books,\n-            [\n-                \"<Book: Cryptonomicon by Neal Stephenson (available at Amazon, \"\n-                \"Borders)>\",\n-                \"<Book: Ender's Game by Orson Scott Card (available at Collins \"\n-                \"Bookstore)>\",\n-                \"<Book: Permutation City by Greg Egan (available at Angus and \"\n-                \"Robertson)>\",\n-            ],\n-            transform=repr,\n-        )\n+[\n+    \"<Book: Cryptonomicon by Neal Stephenson (available at Amazon, Borders)>\",\n+    \"<Book: Ender's Game by Orson Scott Card (available at Collins Bookstore)>\",\n+    \"<Book: Permutation City by Greg Egan (available at Angus and Robertson)>\",\n+],\n+transform=repr,\n+)\n+\n+class NaturalKeyWithFKDependencyTests(TestCase):\n+    databases = {\"default\", \"other\"}\n+\n+    def setUp(self):\n+        # Set up initial data for the test\n+        Author.objects.using(\"other\").create(name=\"JR Tolkien\")\n+\n+    def test_load_natural_key_data_on_other_database(self):\n+        \"\"\"Loading data with natural keys using FK should work on non-default database.\"\"\"\n+        data = [\n+            {\n+                \"model\": \"fixtures_regress.author\",\n+                \"fields\": {\n+                    \"name\": \"JR Tolkien\"\n+                }\n+            },\n+            {\n+                \"model\": \"fixtures_regress.book\",\n+                \"fields\": {\n+                    \"title\": \"The Ring\",\n+                    \"author\": [\"JR Tolkien\"]\n+                }\n+            }\n+        ]\n+        # Save data as a fixture file to use in the test\n+        with open(\"tmp_fixture.json\", \"w\") as f:\n+            json.dump(data, f)\n+\n+        # Load fixture in the \"other\" database\n+        management.call_command(\"loaddata\", \"tmp_fixture.json\", database=\"other\", verbosity=0)\n+\n+        # Verify that data is loaded correctly\n+        book = Book.objects.using(\"other\").get()\n+        self.assertEqual(book.title, \"The Ring\")\n+        self.assertEqual(book.author.name, \"JR Tolkien\")\n+\n+    def tearDown(self):\n+        # Clean up the database\n+        Book.objects.using(\"other\").all().delete()\n+        Author.objects.using(\"other\").all().delete()\n \n \n class M2MNaturalKeyFixtureTests(TestCase):\n",
  "django__django-15561": "",
  "django__django-15569": "diff --git a/tests/custom_lookups/tests.py b/tests/custom_lookups/tests.py\nindex 74c331a..8866abe 100644\n--- a/tests/custom_lookups/tests.py\n+++ b/tests/custom_lookups/tests.py\n@@ -312,6 +312,20 @@ class LookupTests(TestCase):\n         with register_lookup(models.Field, Exactly):\n             self.assertIsNone(field.get_lookup(\"exactly\"))\n \n+    def test_lookups_cache_clearing_on_unregister(self):\n+        field = Article._meta.get_field(\"author\")\n+\n+        # Register a lookup\n+        with register_lookup(models.ForeignObject, Exactly):\n+            # Ensure the lookup is registered\n+            self.assertIn(\"exactly\", field.get_lookups())\n+\n+        # Unregister the lookup\n+        models.ForeignObject._unregister_lookup(Exactly)\n+\n+        # Lookup cache should be cleared\n+        self.assertNotIn(\"exactly\", field.get_lookups())\n+\n     def test_lookups_caching(self):\n         field = Article._meta.get_field(\"author\")\n \n",
  "django__django-15572": "",
  "django__django-15731": "diff --git a/tests/basic/tests.py b/tests/basic/tests.py\nindex 902f114..6a74574 100644\n--- a/tests/basic/tests.py\n+++ b/tests/basic/tests.py\n@@ -1,3 +1,4 @@\n+\n import threading\n from datetime import datetime, timedelta\n from unittest import mock\n@@ -6,6 +7,7 @@ from django.core.exceptions import MultipleObjectsReturned, ObjectDoesNotExist\n from django.db import DEFAULT_DB_ALIAS, DatabaseError, connections, models\n from django.db.models.manager import BaseManager\n from django.db.models.query import MAX_GET_RESULTS, EmptyQuerySet\n+import inspect\n from django.test import (\n     SimpleTestCase,\n     TestCase,\n",
  "django__django-15741": "diff --git a/tests/template_tests/filter_tests/test_date.py b/tests/template_tests/filter_tests/test_date.py\nindex c6dbc53..f6c6c0e 100644\n--- a/tests/template_tests/filter_tests/test_date.py\n+++ b/tests/template_tests/filter_tests/test_date.py\n@@ -1,6 +1,9 @@\n+\n from datetime import datetime, time\n \n from django.template.defaultfilters import date\n+from django.utils.translation import gettext_lazy\n+from django.utils.formats import get_format\n from django.test import SimpleTestCase\n from django.utils import timezone, translation\n \n@@ -77,6 +80,13 @@ class FunctionTests(SimpleTestCase):\n     def test_date(self):\n         self.assertEqual(date(datetime(2005, 12, 29), \"d F Y\"), \"29 December 2005\")\n \n+    def test_get_format_lazy_string(self):\n+        # Verifying that get_format handles lazy strings without raising an exception\n+        lazy_string = gettext_lazy(\"DATE_FORMAT\")\n+        result = get_format(lazy_string)\n+        # As we specified \"N j, Y\" as a mock expected outcome for the lazy string resolution.\n+        self.assertEqual(result, \"N j, Y\")\n+\n     def test_no_args(self):\n         self.assertEqual(date(\"\"), \"\")\n         self.assertEqual(date(None), \"\")\n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..a545a75 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -383,6 +383,18 @@ class ProxyModelTests(TestCase):\n         )\n \n         # Select related + filter on a related proxy of proxy field\n+\n+    def test_select_related_with_only_on_proxy_model(self):\n+        # Create an instance of ProxyCustomModel through the parent class CustomModel\n+        custom = CustomModel.objects.create(name=\"Test Name\")\n+        # Create an instance of AnotherModel which is related to ProxyCustomModel\n+        another = AnotherModel.objects.create(custom=custom)\n+        \n+        # Using select_related and only on the proxy field\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+        \n+        # Validate fetching works without errors and returns the expected result\n+        self.assertEqual(qs.get().custom.name, \"Test Name\")\n         resp = ProxyImprovement.objects.select_related().get(\n             associated_bug__summary__icontains=\"fix\"\n         )\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..47cfbb9 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -151,12 +151,24 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             ),\n         )\n \n+    def test_parameters_correct_order(self):\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"select * from some_table;\"]),\n+            ([\"psql\", \"-c\", \"select * from some_table;\", \"dbname\"], None),\n+        )\n+\n     def test_parameters(self):\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n             ([\"psql\", \"dbname\", \"--help\"], None),\n         )\n \n+    def test_parameters_correct_order(self):\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"select * from some_table;\"]),\n+            ([\"psql\", \"-c\", \"select * from some_table;\", \"dbname\"], None),\n+        )\n+\n     @skipUnless(connection.vendor == \"postgresql\", \"Requires a PostgreSQL connection\")\n     def test_sigint_handler(self):\n         \"\"\"SIGINT is ignored in Python and passed to psql to abort queries.\"\"\"\n",
  "django__django-15863": "diff --git a/tests/template_tests/filter_tests/test_floatformat.py b/tests/template_tests/filter_tests/test_floatformat.py\nindex 08f08e1..f36f3ba 100644\n--- a/tests/template_tests/filter_tests/test_floatformat.py\n+++ b/tests/template_tests/filter_tests/test_floatformat.py\n@@ -31,6 +31,8 @@ class FloatformatTests(SimpleTestCase):\n         self.assertEqual(output, \"1.4 1.4\")\n \n \n+from decimal import Decimal\n+\n class FunctionTests(SimpleTestCase):\n     def test_inputs(self):\n         self.assertEqual(floatformat(7.7), \"7.7\")\n@@ -74,7 +76,36 @@ class FunctionTests(SimpleTestCase):\n         self.assertEqual(floatformat(1.5e-15, -20), \"0.00000000000000150000\")\n         self.assertEqual(floatformat(1.00000000000000015, 16), \"1.0000000000000002\")\n \n-    def test_force_grouping(self):\n+    def test_decimal_precision(self):\n+        # Test with a decimal number that was previously losing precision\n+        self.assertEqual(\n+            floatformat(Decimal(\"123456.123456789012345678901\"), 21), \n+            \"123456.123456789012345678901\"\n+        )\n+\n+        # Test with less precision needed than provided by the floatformat\n+        self.assertEqual(\n+            floatformat(Decimal(\"789.987654321\"), 9),\n+            \"789.987654321\"\n+        )\n+\n+        # Test with exact precision match\n+        self.assertEqual(\n+            floatformat(Decimal(\"456789.123456\"), 6),\n+            \"456789.123456\"\n+        )\n+\n+        # Test with a decimal where precision requested is less than the number's precision\n+        self.assertEqual(\n+            floatformat(Decimal(\"12345.67890123456789012345\"), 8),\n+            \"12345.67890123\"\n+        )\n+\n+        # Test with a large decimal number\n+        self.assertEqual(\n+            floatformat(Decimal(\"12345678901234567890.12345678901234567890\"), 20),\n+            \"12345678901234567890.12345678901234567890\"\n+        )\n         with translation.override(\"en\"):\n             self.assertEqual(floatformat(10000, \"g\"), \"10,000\")\n             self.assertEqual(floatformat(66666.666, \"1g\"), \"66,666.7\")\n",
  "django__django-15930": "diff --git a/tests/expressions_case/tests.py b/tests/expressions_case/tests.py\nindex 696f4d0..12f07e0 100644\n--- a/tests/expressions_case/tests.py\n+++ b/tests/expressions_case/tests.py\n@@ -404,8 +404,15 @@ class CaseExpressionTests(TestCase):\n             ),\n             [1, 4, 3, 3, 3, 2, 2],\n         )\n-\n-    def test_annotate_with_empty_when(self):\n+    def test_annotate_with_full_when(self):\n+        objects = CaseTestModel.objects.annotate(\n+            selected=Case(\n+                When(~Q(pk__in=[]), then=Value(\"selected\")),\n+                default=Value(\"not selected\"),\n+            )\n+        )\n+        self.assertEqual(len(objects), CaseTestModel.objects.count())\n+        self.assertTrue(all(obj.selected == \"selected\" for obj in objects))\n         objects = CaseTestModel.objects.annotate(\n             selected=Case(\n                 When(pk__in=[], then=Value(\"selected\")),\n",
  "django__django-15987": "diff --git a/tests/fixtures_regress/tests.py b/tests/fixtures_regress/tests.py\nindex 5ac9ab9..cb7313b 100644\n--- a/tests/fixtures_regress/tests.py\n+++ b/tests/fixtures_regress/tests.py\n@@ -1,3 +1,4 @@\n+\n # Unittests for fixtures.\n import json\n import os\n@@ -568,6 +569,7 @@ class TestFixtures(TestCase):\n         )\n         with self.assertRaisesMessage(ImproperlyConfigured, msg):\n             management.call_command(\"loaddata\", \"absolute.json\", verbosity=0)\n+    from django.test import override_settings  # Import override_settings from django.test if not already present\n \n     @override_settings(\n         FIXTURE_DIRS=[\n",
  "django__django-16032": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex bcf8df9..c49f819 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -989,6 +989,53 @@ class NonAggregateAnnotationTestCase(TestCase):\n             publisher_books_qs, [{\"name\": \"Sams\"}, {\"name\": \"Morgan Kaufmann\"}]\n         )\n \n+    def test_annotation_and_alias_filter_in_subquery(self):\n+        long_books_qs = (\n+            Book.objects.filter(\n+                pages__gt=400,\n+            )\n+            .annotate(book_annotate=Value(1))\n+            .alias(book_alias=Value(1))\n+        )\n+        publisher_books_qs = (\n+            Publisher.objects.filter(\n+                book__in=long_books_qs\n+            )\n+            .values(\"name\")\n+        )\n+        self.assertCountEqual(\n+            publisher_books_qs,\n+            [\n+                {\"name\": \"Apress\"},\n+                {\"name\": \"Sams\"},\n+                {\"name\": \"Prentice Hall\"},\n+                {\"name\": \"Morgan Kaufmann\"}\n+            ]\n+        )\n+\n+    def test_annotation_and_alias_filter_in_subquery_variant(self):\n+        short_books_qs = (\n+            Book.objects.filter(\n+                pages__lte=400,\n+            )\n+            .annotate(short_book_annotate=Value(1))\n+            .alias(short_book_alias=Value(1))\n+        )\n+        publisher_books_qs_variant = (\n+            Publisher.objects.filter(\n+                book__in=short_books_qs\n+            )\n+            .values(\"name\")\n+        )\n+        # Example assertion, update with actual expected output.\n+        self.assertCountEqual(\n+            publisher_books_qs_variant,\n+            [\n+                {\"name\": \"O'Reilly\"},\n+                {\"name\": \"Penguin\"},\n+            ]\n+        )\n+\n     def test_annotation_exists_aggregate_values_chaining(self):\n         qs = (\n             Book.objects.values(\"publisher\")\n",
  "django__django-16082": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 541ed6d..c6202be 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -2416,7 +2416,7 @@ class CombinedExpressionTests(SimpleTestCase):\n             (IntegerField, FloatField, FloatField),\n             (FloatField, IntegerField, FloatField),\n         ]\n-        connectors = [Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV]\n+        connectors = [Combinable.ADD, Combinable.SUB, Combinable.MUL, Combinable.DIV, Combinable.MOD]\n         for lhs, rhs, combined in tests:\n             for connector in connectors:\n                 with self.subTest(\n",
  "django__django-16100": "diff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex 0ab2941..f9d863d 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib import admin\n@@ -21,7 +22,10 @@ from django.db.models import F, Field, IntegerField\n from django.db.models.functions import Upper\n from django.db.models.lookups import Contains, Exact\n from django.template import Context, Template, TemplateSyntaxError\n-from django.test import TestCase, override_settings\n+from unittest import mock\n+from django.db import DatabaseError\n+from django.test import TestCase, override_settings, skipUnlessDBFeature\n+from django.urls import reverse\n from django.test.client import RequestFactory\n from django.test.utils import CaptureQueriesContext, isolate_apps, register_lookup\n from django.urls import reverse\n@@ -400,7 +404,52 @@ class ChangeListTests(TestCase):\n         with self.assertRaises(IncorrectLookupParameters):\n             m.get_changelist_instance(request)\n \n-    def test_custom_paginator(self):\n+    @skipUnlessDBFeature(\"supports_transactions\")\n+    def test_list_editable_atomicity(self):\n+        a = Swallow.objects.create(origin=\"Swallow A\", load=4, speed=1)\n+        b = Swallow.objects.create(origin=\"Swallow B\", load=2, speed=2)\n+\n+        self.client.force_login(self.superuser)\n+        changelist_url = reverse(\"admin:admin_changelist_swallow_changelist\")\n+        data = {\n+            \"form-TOTAL_FORMS\": \"2\",\n+            \"form-INITIAL_FORMS\": \"2\",\n+            \"form-MIN_NUM_FORMS\": \"0\",\n+            \"form-MAX_NUM_FORMS\": \"1000\",\n+            \"form-0-uuid\": str(a.pk),\n+            \"form-1-uuid\": str(b.pk),\n+            \"form-0-load\": \"9.0\",\n+            \"form-0-speed\": \"3.0\",\n+            \"form-1-load\": \"5.0\",\n+            \"form-1-speed\": \"1.0\",\n+            \"_save\": \"Save\",\n+        }\n+        with mock.patch(\n+            \"django.contrib.admin.ModelAdmin.log_change\", side_effect=DatabaseError\n+        ):\n+            with self.assertRaises(DatabaseError):\n+                self.client.post(changelist_url, data)\n+        # Original values are preserved.\n+        a.refresh_from_db()\n+        self.assertEqual(a.load, 4)\n+        self.assertEqual(a.speed, 1)\n+        b.refresh_from_db()\n+        self.assertEqual(b.load, 2)\n+        self.assertEqual(b.speed, 2)\n+\n+        with mock.patch(\n+            \"django.contrib.admin.ModelAdmin.log_change\",\n+            side_effect=[None, DatabaseError],\n+        ):\n+            with self.assertRaises(DatabaseError):\n+                self.client.post(changelist_url, data)\n+        # Original values are preserved.\n+        a.refresh_from_db()\n+        self.assertEqual(a.load, 4)\n+        self.assertEqual(a.speed, 1)\n+        b.refresh_from_db()\n+        self.assertEqual(b.load, 2)\n+        self.assertEqual(b.speed, 2)\n         new_parent = Parent.objects.create(name=\"parent\")\n         for i in range(1, 201):\n             Child.objects.create(name=\"name %s\" % i, parent=new_parent)\n",
  "django__django-16116": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex cd0e572..d069cd4 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -2400,6 +2400,18 @@ class MakeMigrationsTests(MigrationTestBase):\n         ):\n             call_command(\"makemigrations\", \"--check\", \"migrations\", verbosity=0)\n \n+    def test_makemigrations_check_no_changes_no_creation(self):\n+        \"\"\"\n+        makemigrations --check should not create migrations and exit\n+        with a non-zero status when there are changes to an app requiring migrations.\n+        \"\"\"\n+        out = io.StringIO()\n+        with self.temporary_migration_module():\n+            with self.assertRaises(SystemExit):\n+                call_command(\"makemigrations\", \"--check\", \"migrations\", verbosity=0, stdout=out)\n+            output = out.getvalue().strip()\n+            self.assertIn(\"No changes detected\", output)\n+\n     def test_makemigrations_migration_path_output(self):\n         \"\"\"\n         makemigrations should print the relative paths to the migrations unless\n",
  "django__django-16136": "diff --git a/tests/async/tests.py b/tests/async/tests.py\nindex 72e103e..d5f7d92 100644\n--- a/tests/async/tests.py\n+++ b/tests/async/tests.py\n@@ -1,3 +1,4 @@\n+\n import asyncio\n import os\n from unittest import mock\n@@ -6,7 +7,9 @@ from asgiref.sync import async_to_sync\n \n from django.core.cache import DEFAULT_CACHE_ALIAS, caches\n from django.core.exceptions import ImproperlyConfigured, SynchronousOnlyOperation\n-from django.http import HttpResponse\n+from django.http import HttpResponse, HttpResponseNotAllowed\n+from django.test import RequestFactory\n+import asyncio\n from django.test import SimpleTestCase\n from django.utils.asyncio import async_unsafe\n from django.views.generic.base import View\n@@ -106,10 +109,50 @@ class ViewTests(SimpleTestCase):\n             (SyncView, False),\n             (AsyncView, True),\n         ]\n+    class SyncView(View):\n+        def get(self, request):\n+            return HttpResponse(\"This is a synchronous view\")\n+\n+        def http_method_not_allowed(self, request, *args, **kwargs):\n+            return HttpResponseNotAllowed()\n+\n+\n+    class AsyncView(View):\n+        async def post(self, request):\n+            return HttpResponse(\"This is an asynchronous view\")\n+\n+    def test_async_view_get_request(self):\n+        \"\"\"\n+        Test that a GET request to an async view having only a POST method\n+        raises no exceptions and returns HttpResponseNotAllowed.\n+        \"\"\"\n+        async_view_instance = self.AsyncView()\n+        request_factory = RequestFactory()\n+        get_request = request_factory.get(\"/demo\")\n+        try:\n+            # Try to get the response\n+            response = async_view_instance.http_method_not_allowed(get_request)\n+            # Check if it's a coroutine and await if necessary\n+            if asyncio.iscoroutine(response):\n+                response = asyncio.run(response)\n+\n+            self.assertIsInstance(response, HttpResponseNotAllowed)\n+        except Exception as e:\n+            self.fail(f\"GET request to async view raised an exception: {e}\")\n+\n+    def test_http_method_not_allowed_responds_correctly(self):\n+        \"\"\"\n+        Test that http_method_not_allowed returns an instance of HttpResponseNotAllowed.\n+        \"\"\"\n+        request_factory = RequestFactory()\n+        tests = [\n+            (self.SyncView, False),\n+            (self.AsyncView, True),\n+        ]\n         for view_cls, is_coroutine in tests:\n             with self.subTest(view_cls=view_cls, is_coroutine=is_coroutine):\n                 instance = view_cls()\n-                response = instance.options(None)\n+                response = instance.http_method_not_allowed(request_factory.post(\"/\"))\n                 self.assertIs(\n                     asyncio.iscoroutine(response),\n                     is_coroutine,\n@@ -117,7 +160,7 @@ class ViewTests(SimpleTestCase):\n                 if is_coroutine:\n                     response = asyncio.run(response)\n \n-                self.assertIsInstance(response, HttpResponse)\n+                self.assertIsInstance(response, HttpResponseNotAllowed)\n \n     def test_base_view_class_is_sync(self):\n         \"\"\"\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..aacd29f 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -892,6 +893,30 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # value to render correctly\n         self.assertEqual(form.initial[\"password\"], form[\"password\"].value())\n \n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field_with_uuid(self):\n+        # Creating a user with a specific uuid\n+        user = User.objects.create_user(username=\"uuidtester\", password=\"password\", email=\"uuidtester@example.com\")\n+        user_uuid = str(user.username)  # or use the actual UUID if stored separately\n+        \n+        # Accessing the UserChangeForm via a different model\u2019s admin with the to_field set\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search(r'<a href=\"(.*?)\">', password_help_text)\n+\n+        # URL to UserChangeForm in admin via to_field (with uuid instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user_uuid,),\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n     def test_custom_form(self):\n         class CustomUserChangeForm(UserChangeForm):\n             class Meta(UserChangeForm.Meta):\n",
  "django__django-16145": "",
  "django__django-16255": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 1469efd..2484c41 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -505,6 +505,30 @@ class HTTPSitemapTests(SitemapTestsBase):\n             \"</urlset>\"\n         )\n         self.assertXMLEqual(index_response.content.decode(), expected_content_index)\n+    \n+    def test_callable_sitemod_no_items_returns_none(self):\n+        response = self.client.get(\"/callable-lastmod-no-items/index.xml\")\n+        # Ensure no Last-Modified header is present since there are no items\n+        self.assertNotIn(\"Last-Modified\", response)\n+\n+        expected_content = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n+        <sitemap><loc>http://example.com/simple/sitemap-callable-lastmod.xml</loc></sitemap>\n+        </sitemapindex>\n+        \"\"\"\n+        self.assertXMLEqual(response.content.decode(), expected_content)\n+\n+    def test_lastmod_not_callable_no_items(self):\n+        response = self.client.get(\"/generic-lastmod/index.xml\")\n+        # This test assumes that we do not raise an exception when lastmod is not callable, and there are no items.\n+        self.assertNotIn(\"Last-Modified\", response)\n+        \n+        expected_content = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n+        <!-- additional sitemap entries -->\n+        </sitemapindex>\n+        \"\"\"\n+        self.assertXMLEqual(response.content.decode(), expected_content)\n         self.assertXMLEqual(sitemap_response.content.decode(), expected_content_sitemap)\n \n \n",
  "django__django-16315": "diff --git a/tests/bulk_create/models.py b/tests/bulk_create/models.py\nindex c5f5c07..7e99864 100644\n--- a/tests/bulk_create/models.py\n+++ b/tests/bulk_create/models.py\n@@ -59,6 +59,10 @@ class Pizzeria(Restaurant):\n     pass\n \n \n+class FieldsWithDbColumns(models.Model):\n+    rank = models.IntegerField(unique=True, db_column=\"rAnK\")\n+    name = models.CharField(max_length=15, null=True, db_column=\"oTheRNaMe\")\n+\n class State(models.Model):\n     two_letter_code = models.CharField(max_length=2, primary_key=True)\n \n",
  "django__django-16333": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 714f137..5556a7d 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n import urllib.parse\n@@ -34,11 +35,40 @@ from .models.custom_user import (\n     ExtensionUser,\n )\n from .models.with_custom_email_field import CustomEmailField\n+from .models.with_many_to_many import CustomUserWithM2M, Organization\n from .models.with_integer_username import IntegerUsernameUser\n from .settings import AUTH_TEMPLATES\n \n \n class TestDataMixin:\n+\n+    def test_custom_form_saves_many_to_many_field(self):\n+        class CustomUserCreationForm(UserCreationForm):\n+            class Meta(UserCreationForm.Meta):\n+                model = CustomUserWithM2M\n+                fields = UserCreationForm.Meta.fields + (\"orgs\",)\n+\n+        organization1 = Organization.objects.create(name=\"organization 1\")\n+        organization2 = Organization.objects.create(name=\"organization 2\")\n+\n+        # Test single organization\n+        data = {\n+            \"username\": \"testclient@example.com\",\n+            \"password1\": \"testclient\",\n+            \"password2\": \"testclient\",\n+            \"orgs\": [str(organization1.pk)],\n+        }\n+        form = CustomUserCreationForm(data)\n+        self.assertTrue(form.is_valid(), \"Form should be valid with correct data.\")\n+        user = form.save(commit=True)\n+        self.assertSequenceEqual(user.orgs.all(), [organization1], \"User should be associated with the correct organization.\")\n+\n+        # Test multiple organizations\n+        data[\"orgs\"] = [organization1.pk, organization2.pk]\n+        form = CustomUserCreationForm(data)\n+        self.assertTrue(form.is_valid(), \"Form should still be valid with multiple organizations.\")\n+        user = form.save(commit=True)\n+        self.assertSequenceEqual(user.orgs.all(), [organization1, organization2], \"User should be associated with both organizations.\")\n     @classmethod\n     def setUpTestData(cls):\n         cls.u1 = User.objects.create_user(\n",
  "django__django-16429": "",
  "django__django-16454": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 8d0729b..e765e31 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -469,6 +469,26 @@ class CommandRunTests(AdminScriptTestCase):\n         self.assertEqual(out.strip(), \"Set foo\")\n \n \n+class SubparserErrorFormattingTests(SimpleTestCase):\n+    def test_missing_subparser(self):\n+        \"\"\"\n+        Test case to verify that invoking the management command without the required subparser\n+        yields an appropriate error message.\n+        \"\"\"\n+        out, err = self.run_manage([\"cheeses\"])\n+        err_lines = err.splitlines()\n+        self.assertIn(\"error: the following arguments are required: {create}\", err_lines[-1])\n+        \n+    def test_missing_argument_in_subparser(self):\n+        \"\"\"\n+        Test case to verify that invoking the subparser without required arguments\n+        yields an appropriate error message.\n+        \"\"\"\n+        out, err = self.run_manage([\"cheeses\", \"create\"])\n+        err_lines = err.splitlines()\n+        self.assertIn(\"error: the following arguments are required: name\", err_lines[-1])\n+\n+\n class UtilsTests(SimpleTestCase):\n     def test_no_existent_external_program(self):\n         msg = \"Error executing a_42_command_that_doesnt_exist_42\"\n",
  "django__django-16485": "",
  "django__django-16493": "diff --git a/tests/file_storage/tests.py b/tests/file_storage/tests.py\nindex 20567e7..c676f81 100644\n--- a/tests/file_storage/tests.py\n+++ b/tests/file_storage/tests.py\n@@ -1018,6 +1018,32 @@ class FieldCallableFileStorageTests(SimpleTestCase):\n         storage = kwargs[\"storage\"]\n         self.assertIs(storage, callable_storage)\n \n+    def test_deconstruction_storage_callable_default(self):\n+        \"\"\"\n+        A callable that returns default_storage is not omitted when\n+        deconstructing.\n+        \"\"\"\n+        obj = Storage()\n+        *_, kwargs = obj._meta.get_field(\"storage_callable_default\").deconstruct()\n+        self.assertIs(kwargs[\"storage\"], callable_default_storage)\n+\n+    def test_deconstruction_callable_storage_random_behavior(self):\n+        \"\"\"\n+        Test to ensure that callable returning random storage includes correct callable\n+        in deconstruction when returning default_storage.\n+        \"\"\"\n+        obj = MyModel()\n+        *_, kwargs = obj._meta.get_field(\"my_file\").deconstruct()\n+        storage_callable = kwargs.get(\"storage\", None)\n+        # It's not straightforward to assert the exact function directly due to random behavior,\n+        # however, we can check the callable's presence and type.\n+        self.assertTrue(callable(storage_callable))\n+        self.assertIn(\n+            storage_callable(),\n+            [default_storage, other_storage],\n+            \"The callable must return either default_storage or other_storage.\",\n+        )\n+\n \n # Tests for a race condition on file saving (#4948).\n # This is written in such a way that it'll always pass on platforms\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..58fa455 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,8 +1,11 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n from django.contrib.admin.templatetags.admin_list import date_hierarchy\n from django.contrib.admin.templatetags.admin_modify import submit_row\n+from django.contrib.auth import get_permission_codename\n+from .tests import get_perm\n from django.contrib.auth.admin import UserAdmin\n from django.contrib.auth.models import User\n from django.test import RequestFactory, TestCase\n@@ -33,6 +36,41 @@ class AdminTemplateTagsTest(AdminViewBasicTestCase):\n         self.assertIs(template_context[\"extra\"], True)\n         self.assertIs(template_context[\"show_save\"], True)\n \n+    def test_submit_row_save_as_new_add_permission_required(self):\n+        \"\"\"Test 'show_save_as_new' requires both add and change permissions.\"\"\"\n+        # User with only change permission\n+        change_user = User.objects.create_user(\n+            username=\"change_user\", password=\"secret\", is_staff=True\n+        )\n+        change_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = change_user\n+        admin = UserAdmin(User, site)\n+        admin.save_as = True\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], False)\n+\n+        # User with both add and change permissions\n+        add_change_user = User.objects.create_user(\n+            username=\"add_change_user\", password=\"secret\", is_staff=True\n+        )\n+        add_change_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"add\", User._meta)),\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = add_change_user\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], True)\n+\n     def test_override_show_save_and_add_another(self):\n         request = self.request_factory.get(\n             reverse(\"admin:auth_user_change\", args=[self.superuser.pk]),\n",
  "django__django-16560": "diff --git a/tests/constraints/tests.py b/tests/constraints/tests.py\nindex 13854a9..52721d7 100644\n--- a/tests/constraints/tests.py\n+++ b/tests/constraints/tests.py\n@@ -237,7 +237,54 @@ class CheckConstraintTests(TestCase):\n         # Valid product.\n         constraint.validate(Product, Product(price=10, discounted_price=5))\n \n-    def test_validate_boolean_expressions(self):\n+    def test_custom_violation_code(self):\n+        # Test for BaseConstraint\n+        constraint = BaseConstraint(\n+            name=\"base_name\",\n+            violation_error_message=\"custom %(name)s message\",\n+            violation_error_code=\"custom_code\"\n+        )\n+        self.assertEqual(constraint.violation_error_code, \"custom_code\")\n+\n+        # Test for CheckConstraint\n+        check = models.Q(price__gt=models.F(\"discounted_price\"))\n+        constraint = models.CheckConstraint(\n+            check=check,\n+            name=\"price\",\n+            violation_error_code=\"code_check\"\n+        )\n+        # Using a mock product to test validation.\n+        invalid_product = Product(price=10, discounted_price=15)\n+        with self.assertRaises(ValidationError) as cm:\n+            constraint.validate(Product, invalid_product)\n+        self.assertEqual(cm.exception.code, \"code_check\")\n+\n+        # Test for UniqueConstraint\n+        uc_constraint = models.UniqueConstraint(\n+            fields=['name'],\n+            name=\"unique_name\",\n+            violation_error_code=\"unique_code\"\n+        )\n+        # Using mock data to test validation.\n+        uc_product1 = UniqueConstraintProduct(name=\"duplicate\")\n+        uc_product1.save()\n+        uc_product2 = UniqueConstraintProduct(name=\"duplicate\")\n+        with self.assertRaises(ValidationError) as cm:\n+            uc_constraint.validate(UniqueConstraintProduct, uc_product2)\n+        self.assertEqual(cm.exception.code, \"unique_code\")\n+\n+        # Test for ExclusionConstraint\n+        exclusion_constraint = models.ExclusionConstraint(\n+            name=\"exclude_constraint\",\n+            expressions=[(F(\"datespan\"), RangeOperators.OVERLAPS)],\n+            violation_error_code=\"exclude_code\"\n+        )\n+        exclusion_test_instance = ExclusionConstraintModel(datespan=(1, 2))\n+        exclusion_constraint.validate(ExclusionConstraintModel, exclusion_test_instance)\n+        overlap_instance = ExclusionConstraintModel(datespan=(2, 3))\n+        with self.assertRaises(ValidationError) as cm:\n+            exclusion_constraint.validate(ExclusionConstraintModel, overlap_instance)\n+        self.assertEqual(cm.exception.code, \"exclude_code\")\n         constraint = models.CheckConstraint(\n             check=models.expressions.ExpressionWrapper(\n                 models.Q(price__gt=500) | models.Q(price__lt=500),\n",
  "django__django-16569": "",
  "django__django-16595": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 3979e76..1c0f279 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -43,7 +43,52 @@ class OptimizerTests(SimpleTestCase):\n     def assertDoesNotOptimize(self, operations, **kwargs):\n         self.assertOptimizesTo(operations, operations, **kwargs)\n \n-    def test_none_app_label(self):\n+    def test_alter_alter_field(self):\n+        self.assertOptimizesTo(\n+            [\n+                migrations.AlterField(\"Foo\", \"name\", models.IntegerField()),\n+                migrations.AlterField(\"Foo\", \"name\", models.IntegerField(help_text=\"help\")),\n+            ],\n+            [\n+                migrations.AlterField(\"Foo\", \"name\", models.IntegerField(help_text=\"help\")),\n+            ],\n+        )\n+\n+    def test_alter_alter_field_with_default(self):\n+        # Further test when default is added\n+        self.assertOptimizesTo(\n+            [\n+                migrations.AlterField(\"Foo\", \"name\", models.IntegerField(help_text=\"help\")),\n+                migrations.AlterField(\"Foo\", \"name\", models.IntegerField(\n+                    help_text=\"help\", \n+                    default=0\n+                )),\n+            ],\n+            [\n+                migrations.AlterField(\"Foo\", \"name\", models.IntegerField(\n+                    help_text=\"help\", \n+                    default=0\n+                )),\n+            ],\n+        )\n+\n+    def test_alter_field_no_optimization_for_different_fields(self):\n+        # Test should not optimize if altering different fields\n+        self.assertDoesNotOptimize(\n+            [\n+                migrations.AlterField(\"Foo\", \"name\", models.IntegerField()),\n+                migrations.AlterField(\"Foo\", \"age\", models.IntegerField()),\n+            ]\n+        )\n+\n+    def test_alter_field_no_optimization_different_model(self):\n+        # Ensure no optimization if model name is different\n+        self.assertDoesNotOptimize(\n+            [\n+                migrations.AlterField(\"Foo\", \"name\", models.IntegerField()),\n+                migrations.AlterField(\"Bar\", \"name\", models.IntegerField()),\n+            ]\n+        )\n         optimizer = MigrationOptimizer()\n         with self.assertRaisesMessage(TypeError, \"app_label must be a str\"):\n             optimizer.optimize([], None)\n",
  "django__django-16612": "",
  "django__django-16642": "diff --git a/tests/responses/test_fileresponse.py b/tests/responses/test_fileresponse.py\nindex 499356e..cb3834b 100644\n--- a/tests/responses/test_fileresponse.py\n+++ b/tests/responses/test_fileresponse.py\n@@ -255,6 +255,8 @@ class FileResponseTests(SimpleTestCase):\n             (\".tar.gz\", \"application/gzip\"),\n             (\".tar.bz2\", \"application/x-bzip\"),\n             (\".tar.xz\", \"application/x-xz\"),\n+            (\".tar.br\", \"application/x-brotli\"),\n+            (\".tar.Z\", \"application/x-compress\"),\n         )\n         for extension, mimetype in test_tuples:\n             with self.subTest(ext=extension):\n@@ -263,7 +265,17 @@ class FileResponseTests(SimpleTestCase):\n                 self.assertEqual(response.headers[\"Content-Type\"], mimetype)\n                 self.assertFalse(response.has_header(\"Content-Encoding\"))\n \n-    def test_unicode_attachment(self):\n+    def test_file_response_br_extension(self):\n+        with tempfile.NamedTemporaryFile(suffix=\".br\") as tmp:\n+            response = FileResponse(tmp)\n+        self.assertEqual(response.headers[\"Content-Type\"], \"application/x-brotli\")\n+        self.assertFalse(response.has_header(\"Content-Encoding\"))\n+\n+    def test_file_response_Z_extension(self):\n+        with tempfile.NamedTemporaryFile(suffix=\".Z\") as tmp:\n+            response = FileResponse(tmp)\n+        self.assertEqual(response.headers[\"Content-Type\"], \"application/x-compress\")\n+        self.assertFalse(response.has_header(\"Content-Encoding\"))\n         response = FileResponse(\n             ContentFile(b\"binary content\", name=\"\u795d\u60a8\u5e73\u5b89.odt\"),\n             as_attachment=True,\n",
  "django__django-16661": "",
  "django__django-16662": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex f0046ca..61b4a57 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -894,9 +894,9 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n-    def test_sorted_imports(self):\n+    def test_import_ordering_with_multiple_imports(self):\n         \"\"\"\n-        #24155 - Tests ordering of imports.\n+        Test that multiple imports are ordered correctly.\n         \"\"\"\n         migration = type(\n             \"Migration\",\n@@ -906,10 +906,32 @@ class WriterTests(SimpleTestCase):\n                     migrations.AddField(\n                         \"mymodel\",\n                         \"myfield\",\n-                        models.DateTimeField(\n-                            default=datetime.datetime(\n-                                2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc\n-                            ),\n+                        models.FloatField(default=time.time),\n+                    ),\n+                ]\n+            },\n+        )\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        self.assertIn(\n+            \"import datetime\\nimport time\\nfrom django.db import migrations, models\\n\",\n+            output,\n+        )\n+        \n+    def test_ordering_with_additional_import(self):\n+        \"\"\"\n+        Test importing of an additional standard library module.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.AddField(\n+                        \"mymodel\",\n+                        \"myfield\",\n+                        models.CharField(\n+                            default=datetime.datetime.now().strftime\n                         ),\n                     ),\n                 ]\n@@ -921,6 +943,27 @@ class WriterTests(SimpleTestCase):\n             \"import datetime\\nfrom django.db import migrations, models\\n\",\n             output,\n         )\n+    def test_import_with_comment(self):\n+        \"\"\"\n+        Test that imports followed by comments are handled correctly.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.RunPython(\n+                        time.time, reverse_code=migrations.RunPython.noop\n+                    ),\n+                ]\n+            },\n+        )\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        self.assertIn(\n+            \"import time\\nfrom django.db import migrations\\n\",\n+            output,\n+        )\n \n     def test_migration_file_header_comments(self):\n         \"\"\"\n",
  "django__django-16801": "diff --git a/tests/model_fields/test_imagefield.py b/tests/model_fields/test_imagefield.py\nindex 9bf7f7d..d190547 100644\n--- a/tests/model_fields/test_imagefield.py\n+++ b/tests/model_fields/test_imagefield.py\n@@ -319,8 +319,38 @@ class ImageFieldTwoDimensionsTests(ImageFieldTestMixin, TestCase):\n         # Dimensions were recalculated, and hence file should have opened.\n         self.assertIs(p.mugshot.was_opened, True)\n \n+from django.db.models import signals\n \n-@skipIf(Image is None, \"Pillow is required to test ImageField\")\n+class ImageFieldSignalTests(TestCase):\n+    \"\"\"\n+    Tests the post_init signal behavior for ImageField with no dimension fields.\n+    \"\"\"\n+\n+    def setUp(self):\n+        # Set up a simple model with an ImageField\n+        self.PersonModel = Person\n+\n+    def test_post_init_not_connected(self):\n+        \"\"\"\n+        Test that the post_init signal is not connected for ImageFields without width and height fields.\n+        \"\"\"\n+        person_model_id = id(self.PersonModel)\n+        connected_senders = [sender_id for (_, sender_id) in signals.post_init.receivers]\n+        self.assertNotIn(\n+            person_model_id,\n+            connected_senders,\n+        )\n+\n+    def test_imagefield_post_init_handler_noop(self):\n+        \"\"\"\n+        Since no width_field or height_field are set, the handler should be a noop.\n+        \"\"\"\n+        # Instantiate a model and trigger the post_init signal\n+        person = self.PersonModel()\n+        signals.post_init.send(sender=self.PersonModel, instance=person)\n+        \n+        # Check if update_dimension_fields is not altering any state\n+        self.assertFalse(hasattr(person, 'width_field') or hasattr(person, 'height_field'))\n class ImageFieldNoDimensionsTests(ImageFieldTwoDimensionsTests):\n     \"\"\"\n     Tests behavior of an ImageField with no dimension fields.\n@@ -328,8 +358,38 @@ class ImageFieldNoDimensionsTests(ImageFieldTwoDimensionsTests):\n \n     PersonModel = Person\n \n+from django.db.models import signals\n \n-@skipIf(Image is None, \"Pillow is required to test ImageField\")\n+class ImageFieldSignalTests(TestCase):\n+    \"\"\"\n+    Tests the post_init signal behavior for ImageField with no dimension fields.\n+    \"\"\"\n+\n+    def setUp(self):\n+        # Set up a simple model with an ImageField\n+        self.PersonModel = Person\n+\n+    def test_post_init_not_connected(self):\n+        \"\"\"\n+        Test that the post_init signal is not connected for ImageFields without width and height fields.\n+        \"\"\"\n+        person_model_id = id(self.PersonModel)\n+        connected_senders = [sender_id for (_, sender_id) in signals.post_init.receivers]\n+        self.assertNotIn(\n+            person_model_id,\n+            connected_senders,\n+        )\n+\n+    def test_imagefield_post_init_handler_noop(self):\n+        \"\"\"\n+        Since no width_field or height_field are set, the handler should be a noop.\n+        \"\"\"\n+        # Instantiate a model and trigger the post_init signal\n+        person = self.PersonModel()\n+        signals.post_init.send(sender=self.PersonModel, instance=person)\n+        \n+        # Check if update_dimension_fields is not altering any state\n+        self.assertFalse(hasattr(person, 'width_field') or hasattr(person, 'height_field'))\n class ImageFieldOneDimensionTests(ImageFieldTwoDimensionsTests):\n     \"\"\"\n     Tests behavior of an ImageField with one dimensions field.\n",
  "django__django-16819": "",
  "django__django-16877": "",
  "django__django-16899": "diff --git a/tests/admin_checks/tests.py b/tests/admin_checks/tests.py\nindex 5130136..97a79fb 100644\n--- a/tests/admin_checks/tests.py\n+++ b/tests/admin_checks/tests.py\n@@ -790,6 +790,21 @@ class SystemChecksTestCase(SimpleTestCase):\n \n         errors = SongAdmin(Song, AdminSite()).check()\n         self.assertEqual(errors, [])\n+    \n+    def test_readonly_field_includes_field_name(self):\n+        class SongAdmin(admin.ModelAdmin):\n+            readonly_fields = (\"nonexistent_field\",)\n+\n+        errors = SongAdmin(Song, AdminSite()).check()\n+        expected = [\n+            checks.Error(\n+                \"The value of 'readonly_fields[0]' refers to 'nonexistent_field', \"\n+                \"which is not a callable, an attribute of 'SongAdmin', or an attribute of 'admin_checks.Song'.\",\n+                obj=SongAdmin,\n+                id=\"admin.E035\",\n+            )\n+        ]\n+        self.assertEqual(errors, expected)\n \n     def test_nonexistent_field(self):\n         class SongAdmin(admin.ModelAdmin):\n",
  "django__django-16901": "",
  "django__django-17029": "diff --git a/tests/apps/tests.py b/tests/apps/tests.py\nindex f7c2c67..bc8abfc 100644\n--- a/tests/apps/tests.py\n+++ b/tests/apps/tests.py\n@@ -24,6 +24,10 @@ SOME_INSTALLED_APPS = [\n     \"django.contrib.staticfiles\",\n ]\n \n+import functools\n+from django.test.utils import override_settings\n+from django.apps import apps\n+\n SOME_INSTALLED_APPS_NAMES = [\n     \"django.contrib.admin\",\n     \"django.contrib.auth\",\n@@ -139,6 +143,28 @@ class AppsTests(SimpleTestCase):\n         self.assertIsInstance(config, TwoConfig)\n \n     @override_settings(INSTALLED_APPS=SOME_INSTALLED_APPS)\n+    def test_clear_swappable_settings_name_cache(self):\n+        \"\"\"\n+        Test if apps.clear_cache() clears the get_swappable_settings_name cache.\n+        \"\"\"\n+        # Manually set the cache by calling the function\n+        apps.get_swappable_settings_name(\"auth.User\")\n+        \n+        # Ensure cache is set\n+        self.assertGreater(\n+            functools._lru_cache_wrapper.cache_info(apps.get_swappable_settings_name).currsize, \n+            0, \n+            \"Cache should be filled after function call.\"\n+        )\n+        \n+        apps.clear_cache()\n+        \n+        # Ensure cache is cleared\n+        self.assertEqual(\n+            functools._lru_cache_wrapper.cache_info(apps.get_swappable_settings_name).currsize, \n+            0, \n+            \"Cache should be cleared after clear_cache call.\"\n+        )\n     def test_get_app_configs(self):\n         \"\"\"\n         Tests apps.get_app_configs().\n@@ -149,6 +175,28 @@ class AppsTests(SimpleTestCase):\n         )\n \n     @override_settings(INSTALLED_APPS=SOME_INSTALLED_APPS)\n+    def test_clear_swappable_settings_name_cache(self):\n+        \"\"\"\n+        Test if apps.clear_cache() clears the get_swappable_settings_name cache.\n+        \"\"\"\n+        # Manually set the cache by calling the function\n+        apps.get_swappable_settings_name(\"auth.User\")\n+        \n+        # Ensure cache is set\n+        self.assertGreater(\n+            functools._lru_cache_wrapper.cache_info(apps.get_swappable_settings_name).currsize, \n+            0, \n+            \"Cache should be filled after function call.\"\n+        )\n+        \n+        apps.clear_cache()\n+        \n+        # Ensure cache is cleared\n+        self.assertEqual(\n+            functools._lru_cache_wrapper.cache_info(apps.get_swappable_settings_name).currsize, \n+            0, \n+            \"Cache should be cleared after clear_cache call.\"\n+        )\n     def test_get_app_config(self):\n         \"\"\"\n         Tests apps.get_app_config().\n@@ -167,6 +215,28 @@ class AppsTests(SimpleTestCase):\n             apps.get_app_config(\"django.contrib.auth\")\n \n     @override_settings(INSTALLED_APPS=SOME_INSTALLED_APPS)\n+    def test_clear_swappable_settings_name_cache(self):\n+        \"\"\"\n+        Test if apps.clear_cache() clears the get_swappable_settings_name cache.\n+        \"\"\"\n+        # Manually set the cache by calling the function\n+        apps.get_swappable_settings_name(\"auth.User\")\n+        \n+        # Ensure cache is set\n+        self.assertGreater(\n+            functools._lru_cache_wrapper.cache_info(apps.get_swappable_settings_name).currsize, \n+            0, \n+            \"Cache should be filled after function call.\"\n+        )\n+        \n+        apps.clear_cache()\n+        \n+        # Ensure cache is cleared\n+        self.assertEqual(\n+            functools._lru_cache_wrapper.cache_info(apps.get_swappable_settings_name).currsize, \n+            0, \n+            \"Cache should be cleared after clear_cache call.\"\n+        )\n     def test_is_installed(self):\n         \"\"\"\n         Tests apps.is_installed().\n@@ -177,6 +247,28 @@ class AppsTests(SimpleTestCase):\n         self.assertIs(apps.is_installed(\"django.contrib.admindocs\"), False)\n \n     @override_settings(INSTALLED_APPS=SOME_INSTALLED_APPS)\n+    def test_clear_swappable_settings_name_cache(self):\n+        \"\"\"\n+        Test if apps.clear_cache() clears the get_swappable_settings_name cache.\n+        \"\"\"\n+        # Manually set the cache by calling the function\n+        apps.get_swappable_settings_name(\"auth.User\")\n+        \n+        # Ensure cache is set\n+        self.assertGreater(\n+            functools._lru_cache_wrapper.cache_info(apps.get_swappable_settings_name).currsize, \n+            0, \n+            \"Cache should be filled after function call.\"\n+        )\n+        \n+        apps.clear_cache()\n+        \n+        # Ensure cache is cleared\n+        self.assertEqual(\n+            functools._lru_cache_wrapper.cache_info(apps.get_swappable_settings_name).currsize, \n+            0, \n+            \"Cache should be cleared after clear_cache call.\"\n+        )\n     def test_get_model(self):\n         \"\"\"\n         Tests apps.get_model().\n",
  "django__django-17084": "",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..efa5de7 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -197,6 +197,29 @@ class OperationWriterTests(SimpleTestCase):\n             \"),\",\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -255,12 +278,58 @@ class WriterTests(SimpleTestCase):\n             decimal.Decimal(\"1.3\"), (\"Decimal('1.3')\", {\"from decimal import Decimal\"})\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n         self.assertSerializedEqual(Money(\"1.3\"))\n         self.assertSerializedResultEqual(\n             Money(\"1.3\"),\n             (\"migrations.test_writer.Money('1.3')\", {\"import migrations.test_writer\"}),\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -296,6 +365,29 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set()),\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r\"^foo$\")\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -306,6 +398,29 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\n@@ -313,6 +428,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\n@@ -320,10 +458,56 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -331,11 +515,57 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(\n             default=TextEnum.B, choices=[(m.value, m) for m in TextEnum]\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -344,10 +574,56 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -356,9 +632,55 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.CharField(\n             default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum]\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -367,9 +689,55 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.IntegerField(\n             default=IntEnum.A, choices=[(m.value, m) for m in IntEnum]\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -379,6 +747,29 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n@@ -387,6 +778,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n@@ -394,9 +808,55 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -405,6 +865,29 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A | IntFlagEnum.B,\n             (\n@@ -414,6 +897,29 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = \"A\", \"A value\"\n@@ -433,6 +939,29 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             (\"datetime.date(1969, 7, 20)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.CharField(default=TextChoices.B, choices=TextChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -440,12 +969,58 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -456,6 +1031,29 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\",\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_nested_class(self):\n         for nested_cls in [self.NestedEnum, self.NestedChoices]:\n             cls_name = nested_cls.__name__\n@@ -478,14 +1076,83 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {\"import uuid\"}),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {\"import uuid\"}),\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n         field = models.UUIDField(\n             choices=((uuid_a, \"UUID A\"), (uuid_b, \"UUID B\")), default=uuid_a\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -495,6 +1162,29 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\",\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_pathlib(self):\n         # Pure path objects work in all platforms.\n         self.assertSerializedEqual(pathlib.PurePosixPath())\n@@ -523,6 +1213,29 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"models.FilePathField(path=pathlib.PurePosixPath('/home/user'))\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertIn(\"import pathlib\", imports)\n \n     def test_serialize_path_like(self):\n@@ -554,13 +1267,82 @@ class WriterTests(SimpleTestCase):\n         self.assertSerializedEqual(\n             datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone())\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedEqual(\n             datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180))\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc),\n             (\n@@ -568,6 +1350,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import datetime\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(\n                 2012, 1, 1, 2, 1, tzinfo=zoneinfo.ZoneInfo(\"Europe/Paris\")\n@@ -578,12 +1383,58 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"}),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n@@ -593,20 +1444,112 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(\n             SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\")\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedResultEqual(\n             SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"}),\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)), (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -624,6 +1567,29 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.RegexValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a compiled regex.\n@@ -633,6 +1599,29 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test a string regex with flag\n@@ -643,6 +1632,29 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[0-9]+$', \"\n             \"flags=re.RegexFlag['DOTALL'])\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n@@ -653,6 +1665,29 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', \"\n             \"'invalid')\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a subclass.\n@@ -661,6 +1696,29 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.EmailValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.serialize_round_trip(validator)\n \n         validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(\n@@ -671,9 +1729,55 @@ class WriterTests(SimpleTestCase):\n             string, \"migrations.test_writer.EmailValidator(message='hello')\"\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n         validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(\n             message=\"hello\"\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n             MigrationWriter.serialize(validator)\n \n@@ -700,6 +1804,29 @@ class WriterTests(SimpleTestCase):\n             models.OrderBy(models.F(\"name\").desc()),\n             name=\"complex_func_index\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         string, imports = MigrationWriter.serialize(index)\n         self.assertEqual(\n             string,\n@@ -711,6 +1838,29 @@ class WriterTests(SimpleTestCase):\n             \"models.OrderBy(models.OrderBy(models.F('name'), descending=True)), \"\n             \"name='complex_func_index')\",\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertEqual(imports, {\"from django.db import models\"})\n \n     def test_serialize_empty_nonempty_tuple(self):\n@@ -762,6 +1912,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.models\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         self.assertSerializedEqual(FoodManager(\"a\", \"b\"))\n         self.assertSerializedEqual(FoodManager(\"x\", \"y\", c=3, d=4))\n \n@@ -772,6 +1945,29 @@ class WriterTests(SimpleTestCase):\n             frozenset(\"cba\"), (\"frozenset(['a', 'b', 'c'])\", set())\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_serialize_set(self):\n         self.assertSerializedEqual(set())\n         self.assertSerializedResultEqual(set(), (\"set()\", set()))\n@@ -809,6 +2005,29 @@ class WriterTests(SimpleTestCase):\n             (\"('models.Model', {'from django.db import models'})\", set()),\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -848,6 +2067,29 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [(\"testapp\", \"some_other_one\")],\n             },\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         # We don't test the output formatting - that's too fragile.\n@@ -887,6 +2129,29 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -896,6 +2161,29 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_sorted_dependencies(self):\n         migration = type(\n             \"Migration\",\n@@ -912,6 +2200,29 @@ class WriterTests(SimpleTestCase):\n                 ],\n             },\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         output = MigrationWriter(migration, include_header=False).as_string()\n         self.assertIn(\n             \"    dependencies = [\\n\"\n@@ -923,6 +2234,29 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -949,6 +2283,29 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -956,6 +2313,29 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -1001,6 +2381,29 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\"from django.db import migrations\\n\", output)\n@@ -1017,6 +2420,29 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\",\n         )\n \n+    def test_serialize_nested_class_field_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = \"BASIC\", \"Basic\"\n+                PROFESSIONAL = \"PROFESSIONAL\", \"Professional\"\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        # Ensuring the full path to the default method is serialized correctly\n+        string = MigrationWriter.serialize(Profile._meta.get_field(\"capabilities\"))[0]\n+        self.assertIn(\n+            \"models.Profile.Capability.default\",\n+            string,\n+        )\n+\n     def test_register_serializer(self):\n         class ComplexSerializer(BaseSerializer):\n             def serialize(self):\n@@ -1032,4 +2458,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "django__django-7530": "",
  "django__django-9296": "diff --git a/tests/pagination/tests.py b/tests/pagination/tests.py\nindex b9b5fbc..d3bf93a 100644\n--- a/tests/pagination/tests.py\n+++ b/tests/pagination/tests.py\n@@ -298,7 +298,36 @@ class PaginationTests(SimpleTestCase):\n             paginator.get_page(1)\n \n \n-class ModelPaginationTests(TestCase):\n+class PaginatorIterationTests(TestCase):\n+    def test_paginator_iteration(self):\n+        paginator = Paginator([1, 2, 3], 2)\n+        page_iterator = iter(paginator)\n+        for page, expected in enumerate(([1, 2], [3]), start=1):\n+            with self.subTest(page=page):\n+                self.assertEqual(expected, list(next(page_iterator)))\n+\n+    def test_empty_list_pagination(self):\n+        paginator = Paginator([], 2)\n+        page_iterator = iter(paginator)\n+        with self.assertRaises(StopIteration):\n+            next(page_iterator)\n+\n+    def test_single_item_pagination(self):\n+        paginator = Paginator([1], 2)\n+        page_iterator = iter(paginator)\n+        with self.subTest(page=1):\n+            self.assertEqual([1], list(next(page_iterator)))\n+        with self.assertRaises(StopIteration):\n+            next(page_iterator)\n+\n+    def test_perfect_division_pagination(self):\n+        paginator = Paginator([1, 2, 3, 4], 2)\n+        page_iterator = iter(paginator)\n+        for page, expected in enumerate(([1, 2], [3, 4]), start=1):\n+            with self.subTest(page=page):\n+                self.assertEqual(expected, list(next(page_iterator)))\n+        with self.assertRaises(StopIteration):\n+            next(page_iterator)\n     \"\"\"\n     Test pagination with Django model instances\n     \"\"\"\n",
  "matplotlib__matplotlib-13989": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 5483eef..4271cad 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -6359,6 +6359,34 @@ def test_hist_auto_bins():\n \n def test_hist_nan_data():\n     fig, (ax1, ax2) = plt.subplots(2)\n+import matplotlib.pyplot as plt\n+import numpy as np\n+\n+def test_hist_range_and_density():\n+    # Original test case\n+    _, bins, _ = plt.hist(np.random.rand(10), \"auto\", range=(0, 1), density=True)\n+    assert bins[0] == 0\n+    assert bins[-1] == 1\n+\n+def test_hist_fixed_range_and_bin_count():\n+    # Test with a fixed bin count\n+    _, bins, _ = plt.hist(np.random.rand(10), bins=5, range=(0, 1), density=True)\n+    assert bins[0] == 0\n+    assert bins[-1] == 1\n+\n+def test_hist_weighed_data():\n+    # Test with weighted data\n+    weights = np.random.rand(10)\n+    _, bins, _ = plt.hist(np.random.rand(10), \"auto\", range=(0, 1), weights=weights, density=True)\n+    assert bins[0] == 0\n+    assert bins[-1] == 1\n+\n+def test_hist_multidimensional_data():\n+    # Test with multidimensional data\n+    data = np.random.rand(2, 10)\n+    _, bins, _ = plt.hist(data, \"auto\", range=(0, 1), density=True)\n+    assert bins[0] == 0\n+    assert bins[-1] == 1\n \n     data = [1, 2, 3]\n     nan_data = data + [np.nan]\n@@ -6368,4 +6396,4 @@ def test_hist_nan_data():\n         nanbins, nanedges, _ = ax2.hist(nan_data)\n \n     assert np.allclose(bins, nanbins)\n-    assert np.allclose(edges, nanedges)\n+    assert np.allclose(edges, nanedges)\n",
  "matplotlib__matplotlib-14623": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex c9ad946..d8ffe9c 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -919,6 +919,13 @@ def test_hexbin_log():\n \n \n def test_inverted_limits():\n+    # Test inverting nonlinear axes using set_yscale.\n+    fig, ax = plt.subplots()\n+    ax.set_yscale(\"log\")\n+    ax.set_ylim(10, 1)\n+    assert ax.get_ylim() == (10, 1)\n+    plt.close()\n+\n     # Test gh:1553\n     # Calling invert_xaxis prior to plotting should not disable autoscaling\n     # while still maintaining the inverted direction\n",
  "matplotlib__matplotlib-20488": "",
  "matplotlib__matplotlib-20826": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 24b5fb5..e40b4c8 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -6960,8 +6960,23 @@ def test_2dcolor_plot(fig_test, fig_ref):\n     axs[3].hist(np.arange(10), color=color.reshape((1, -1)))\n     axs[4].bar(np.arange(10), np.arange(10), color=color.reshape((1, -1)))\n \n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+@check_figures_equal(extensions=['png'])\n+def test_shared_axes_clear(fig_test, fig_ref):\n+    x = np.arange(0.0, 2*np.pi, 0.01)\n+    y = np.sin(x)\n+\n+    axs_ref = fig_ref.subplots(2, 2, sharex=True, sharey=True)\n+    for ax in axs_ref.flat:\n+        ax.plot(x, y)\n \n-def test_shared_axes_retick():\n+    axs_test = fig_test.subplots(2, 2, sharex=True, sharey=True)\n+    for ax in axs_test.flat:\n+        ax.clear()\n+        ax.plot(x, y)\n     fig, axs = plt.subplots(2, 2, sharex='all', sharey='all')\n \n     for ax in axs.flat:\n",
  "matplotlib__matplotlib-20859": "",
  "matplotlib__matplotlib-22719": "diff --git a/lib/matplotlib/tests/test_category.py b/lib/matplotlib/tests/test_category.py\nindex 40c4dcf..772cfbe 100644\n--- a/lib/matplotlib/tests/test_category.py\n+++ b/lib/matplotlib/tests/test_category.py\n@@ -306,9 +306,33 @@ def test_overriding_units_in_plot(fig_test, fig_ref):\n         assert x_units is ax.xaxis.units\n         assert y_units is ax.yaxis.units\n \n+def test_no_deprecation_on_empty_data():\n+    \"\"\"\n+    Verify that no warning is raised when plotting with empty data.\n+    \"\"\"\n+    f, ax = plt.subplots()\n+    ax.xaxis.update_units([\"a\", \"b\"])\n+    ax.plot([], [])\n+\n \n-def test_hist():\n+def test_no_deprecation_convert_units_with_empty_data():\n+    \"\"\"\n+    Verify no deprecation warning is emitted when using convert_xunits with empty data.\n+    \"\"\"\n+    f, ax = plt.subplots()\n+    ax.xaxis.update_units([\"a\", \"b\"])\n+    # Should not raise a warning or error\n+    ax.convert_xunits(np.array([], dtype=float))\n+\n+\n+def test_no_error_on_non_numeric_categories():\n+    \"\"\"\n+    Verify that non-numeric categories work without errors.\n+    \"\"\"\n+    f, ax = plt.subplots()\n+    ax.xaxis.update_units([\"cat1\", \"cat2\"])\n+    ax.plot([], [])\n     fig, ax = plt.subplots()\n     n, bins, patches = ax.hist(['a', 'b', 'a', 'c', 'ff'])\n     assert n.shape == (10,)\n-    np.testing.assert_allclose(n, [2., 0., 0., 1., 0., 0., 1., 0., 0., 1.])\n+    np.testing.assert_allclose(n, [2., 0., 0., 1., 0., 0., 1., 0., 0., 1.])\n",
  "matplotlib__matplotlib-22865": "",
  "matplotlib__matplotlib-23299": "diff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 144880c..bbc9bc0 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -489,12 +489,37 @@ def test_validate_fontstretch(stretch, parsed_stretch):\n     else:\n         assert validate_fontstretch(stretch) == parsed_stretch\n \n+import pytest\n+import matplotlib.pyplot as plt\n+from matplotlib import rc_context, get_backend\n \n def test_keymaps():\n     key_list = [k for k in mpl.rcParams if 'keymap' in k]\n     for k in key_list:\n         assert isinstance(mpl.rcParams[k], list)\n \n+def test_backend_rc_context_figure_persistence():\n+    \"\"\"\n+    Test that calling `get_backend()` does not clear figures\n+    from Gcf.figs if they were created within an rc_context.\n+    \"\"\"\n+\n+    # Create a figure inside rc_context and check Gcf state\n+    with rc_context():\n+        fig1 = plt.figure()\n+        \n+    # Capture Gcf state before calling get_backend\n+    before = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+    \n+    # Call get_backend() and check if Gcf state remains unchanged\n+    get_backend()\n+    after = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+\n+    # Assert Gcf state before and after calling get_backend\n+    assert before == after, '\\nFigures removed from Gcf after calling get_backend:\\n' + before + '\\n' + after\n+\n+    # Clean up created figures\n+    plt.close(fig1)\n \n def test_rcparams_reset_after_fail():\n     # There was previously a bug that meant that if rc_context failed and\n",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..0b74f19 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -14,14 +14,28 @@ from matplotlib.collections import LineCollection, PolyCollection\n from matplotlib.patches import Circle\n \n import matplotlib.pyplot as plt\n+from matplotlib.testing.decorators import check_figures_equal\n import numpy as np\n \n \n mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n-\n-def test_aspect_equal_error():\n+@check_figures_equal(extensions=[\"png\"])\n+def test_set_visible_3d_subplot(fig_test, fig_ref):\n+    ax_test = fig_test.add_subplot(121, projection='3d')\n+    ax_ref = fig_ref.add_subplot(121, projection='3d')\n+    \n+    ax_test.scatter(1, 1, 1)\n+    ax_ref.scatter(1, 1, 1)\n+    \n+    ax_test.set_visible(False)\n+\n+    ax_test2 = fig_test.add_subplot(122, projection='3d')\n+    ax_ref2 = fig_ref.add_subplot(122, projection='3d')\n+\n+    ax_test2.scatter(1, 1, 1, c='r')\n+    ax_ref2.scatter(1, 1, 1, c='r')\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     with pytest.raises(NotImplementedError):\n",
  "matplotlib__matplotlib-23412": "diff --git a/lib/matplotlib/tests/test_patches.py b/lib/matplotlib/tests/test_patches.py\nindex 6db3e7e..9b63ba8 100644\n--- a/lib/matplotlib/tests/test_patches.py\n+++ b/lib/matplotlib/tests/test_patches.py\n@@ -148,8 +148,54 @@ def test_rotate_rect_draw(fig_test, fig_ref):\n     rect_test.set_angle(angle)\n     assert rect_test.get_angle() == angle\n \n+from matplotlib import pyplot as plt\n+from matplotlib.patches import Rectangle\n+import numpy as np\n+import pytest\n+\n+@pytest.mark.parametrize(\"offset,expected_start\", [\n+    (0, 0),\n+    (5, 5),\n+    (10, 10),\n+])\n+def test_rectangle_dash_offset(offset, expected_start):\n+    fig, ax = plt.subplots()\n+    rect = Rectangle((0.1, 0.1), 0.8, 0.8, linewidth=3, edgecolor='b', linestyle=(offset, [6, 6]))\n+    ax.add_patch(rect)\n+    ax.set_xlim(0, 1)\n+    ax.set_ylim(0, 1)\n+    fig.canvas.draw()\n+    \n+    # Check that the path starts with the expected starting offset\n+    assert rect.get_linestyle()[0] == expected_start\n \n-def test_negative_rect():\n+def test_linewidth_consistency_with_offset():\n+    fig, ax = plt.subplots()\n+    rect1 = Rectangle((0.1, 0.1), 0.8, 0.8, linewidth=3, edgecolor='b', linestyle=(0, [6, 6]))\n+    rect2 = Rectangle((0.2, 0.2), 0.6, 0.6, linewidth=5, edgecolor='r', linestyle=(5, [6, 6]))\n+    ax.add_patch(rect1)\n+    ax.add_patch(rect2)\n+    ax.set_xlim(0, 1)\n+    ax.set_ylim(0, 1)\n+    fig.canvas.draw()\n+    \n+    # Check something about linewidths (not exact comparison but ensure distinctive)\n+    assert rect1.get_linewidth() != rect2.get_linewidth()\n+\n+def test_different_patch_shapes_with_offset():\n+    from matplotlib.patches import Ellipse, Polygon\n+    fig, ax = plt.subplots()\n+    ellipse = Ellipse((0.5, 0.5), 0.4, 0.6, edgecolor='g', linestyle=(10, [6, 6]))\n+    polygon = Polygon([[0.1, 0.1], [0.9, 0.1], [0.9, 0.9]], closed=True, edgecolor='r', linestyle=(2, [4, 2]))\n+    ax.add_patch(ellipse)\n+    ax.add_patch(polygon)\n+    ax.set_xlim(0, 1)\n+    ax.set_ylim(0, 1)\n+    fig.canvas.draw()\n+    \n+    # For visually verifying different offsets and geometries (placeholder assertions)\n+    assert ellipse.get_linestyle() == (10, [6, 6])\n+    assert polygon.get_linestyle() == (2, [4, 2])\n     # These two rectangles have the same vertices, but starting from a\n     # different point.  (We also drop the last vertex, which is a duplicate.)\n     pos_vertices = Rectangle((-3, -2), 3, 2).get_verts()[:-1]\n",
  "matplotlib__matplotlib-24026": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex f408084..109ec86 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -2866,8 +2866,27 @@ def test_stackplot():\n     ax.set_xlim((0, 10))\n     ax.set_ylim((0, 70))\n \n-\n-@image_comparison(['stackplot_test_baseline'], remove_text=True)\n+def test_stackplot_color_cycler():\n+    import matplotlib.pyplot as plt\n+    from matplotlib.patches import Rectangle\n+    import numpy as np\n+\n+    fig, ax = plt.subplots()\n+    \n+    # Plot a line with a cycler color\n+    ax.plot([1, 3], [2, 4], color='C0')\n+    \n+    # Add a Rectangle with cycler color\n+    ax.add_patch(Rectangle(xy=(1.5, 1.5), width=0.5, height=0.5, facecolor='C1'))\n+    \n+    # Create a stackplot using colors from the cycler\n+    my_data = np.array([[1, 1, 1], [1, 2, 3], [4, 3, 2]])\n+    ax.stackplot([1, 2, 3], my_data, colors=['C2', 'C3', 'C4'])\n+    \n+    # Assert that cycler colors are correctly applied\n+    assert ax.get_lines()[0].get_color() == 'C0'\n+    for patch, color in zip(ax.patches[1:], ['C1'] + ['C2', 'C3', 'C4']):\n+        assert patch.get_facecolor()[:3] == plt.colors.to_rgb(color)\n def test_stackplot_baseline():\n     np.random.seed(0)\n \n",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24570": "diff --git a/lib/matplotlib/tests/test_offsetbox.py b/lib/matplotlib/tests/test_offsetbox.py\nindex 45f9c04..e7105a1 100644\n--- a/lib/matplotlib/tests/test_offsetbox.py\n+++ b/lib/matplotlib/tests/test_offsetbox.py\n@@ -12,6 +12,7 @@ import matplotlib.lines as mlines\n from matplotlib.backend_bases import MouseButton, MouseEvent\n \n from matplotlib.offsetbox import (\n+    HPacker,\n     AnchoredOffsetbox, AnnotationBbox, AnchoredText, DrawingArea, OffsetBox,\n     OffsetImage, TextArea, _get_packed_offsets)\n \n@@ -327,7 +328,29 @@ def test_zorder():\n     assert OffsetBox(zorder=42).zorder == 42\n \n \n-def test_arrowprops_copied():\n+@pytest.mark.parametrize(\"align, expected_y_height\", [\n+    (\"baseline\", 0),\n+    (\"bottom\", 0),\n+    (\"top\", 30),  # since y2 - y1 = 30 - 10\n+    (\"center\", 10)  # (30 - 10) / 2 = 10\n+])\n+def test_hpacker_alignment(align, expected_y_height):\n+    fig = plt.figure(dpi=72)\n+    x1, y1 = 10, 30\n+    x2, y2 = 20, 60\n+    r1 = DrawingArea(x1, y1)\n+    r2 = DrawingArea(x2, y2)\n+\n+    hpacker = HPacker(children=[r1, r2], pad=0, sep=0, align=align)\n+    renderer = fig.canvas.get_renderer()\n+\n+    *extents, offset_pairs = hpacker.get_extent_offsets(renderer)\n+\n+    # Check that the widths and heights are as expected\n+    assert_allclose((x1 + x2, max(y1, y2), 0, 0), extents)\n+\n+    # Verify internal element placement for y-offset\n+    assert_allclose([(0, expected_y_height), (x1, 0)], offset_pairs)\n     da = DrawingArea(20, 20, 0, 0, clip=True)\n     arrowprops = {\"arrowstyle\": \"->\", \"relpos\": (.3, .7)}\n     ab = AnnotationBbox(da, [.5, .5], xybox=(-0.2, 0.5), xycoords='data',\n",
  "matplotlib__matplotlib-24627": "",
  "matplotlib__matplotlib-24637": "",
  "matplotlib__matplotlib-24970": "diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex 2be14fe..9cf255d 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -20,6 +20,39 @@ import matplotlib.scale as mscale\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n \n \n+import pytest\n+import numpy as np\n+from numpy.testing import assert_array_equal\n+import matplotlib.pyplot as plt\n+import matplotlib as mpl\n+\n+@pytest.mark.parametrize(\"dtype\", [np.uint8, int, np.float16, float])\n+def test_index_dtype(dtype):\n+    # We use subtraction in the indexing, so need to verify that uint8 works\n+    cm = mpl.colormaps[\"viridis\"]\n+    assert_array_equal(cm(dtype(0)), cm(0))\n+\n+def test_out_of_bounds_handling():\n+    # Test that the cmap handles out-of-bounds indices without warning\n+    cmap = plt.get_cmap('viridis')\n+    indices = np.array([-1, 0, 256, 257], dtype=np.int32)\n+    \n+    with np.testing.assert_no_warnings(DeprecationWarning):\n+        result = cmap(indices)\n+        assert result.shape[0] == len(indices)\n+\n+    # Ensure that the results are within expected range even for out-of-bounds\n+    assert np.all(result >= 0) and np.all(result <= 1)\n+\n+def test_empty_array():\n+    # Ensure that empty arrays do not throw any warnings\n+    cmap = plt.get_cmap('viridis')\n+    empty_array = np.empty((0,), dtype=np.uint8)\n+    \n+    with np.testing.assert_no_warnings(DeprecationWarning):\n+        result = cmap(empty_array)\n+        assert result.size == 0\n+\n @pytest.mark.parametrize('N, result', [\n     (5, [1, .6, .2, .1, 0]),\n     (2, [1, 0]),\n",
  "matplotlib__matplotlib-25122": "diff --git a/lib/matplotlib/tests/test_mlab.py b/lib/matplotlib/tests/test_mlab.py\nindex 51d0c35..df4e1e2 100644\n--- a/lib/matplotlib/tests/test_mlab.py\n+++ b/lib/matplotlib/tests/test_mlab.py\n@@ -578,6 +578,29 @@ class TestSpectral:\n         assert_array_equal(fsp_b, fsp_c)\n         assert_allclose(spec_g, spec_c, atol=1e-08)\n         # these should not be almost equal\n+\n+    def test_psd_window_flattop(self):\n+        if self.NFFT_density is None:\n+            return\n+        from scipy import signal\n+        window = signal.windows.flattop(self.NFFT_density_real)\n+        spec, fsp = mlab.psd(x=self.y,\n+                             NFFT=self.NFFT_density,\n+                             Fs=self.Fs,\n+                             noverlap=0,\n+                             sides=self.sides,\n+                             window=window,\n+                             scale_by_freq=True)\n+        spec_ref, fsp_ref = mlab.psd(x=self.y,\n+                                     NFFT=self.NFFT_density,\n+                                     Fs=self.Fs,\n+                                     noverlap=0,\n+                                     sides=self.sides,\n+                                     window=window,\n+                                     scale_by_freq=True)\n+        assert_allclose(spec * window.sum()**2,\n+                        spec_ref * self.Fs * (window**2).sum(),\n+                        atol=1e-08)\n         with pytest.raises(AssertionError):\n             assert_allclose(spec_b, spec_c, atol=1e-08)\n \n@@ -620,6 +643,29 @@ class TestSpectral:\n         assert_array_equal(fsp_b, fsp_c)\n         assert_allclose(spec_g, spec_c, atol=1e-08)\n         # these should not be almost equal\n+\n+    def test_psd_window_flattop(self):\n+        if self.NFFT_density is None:\n+            return\n+        from scipy import signal\n+        window = signal.windows.flattop(self.NFFT_density_real)\n+        spec, fsp = mlab.psd(x=self.y,\n+                             NFFT=self.NFFT_density,\n+                             Fs=self.Fs,\n+                             noverlap=0,\n+                             sides=self.sides,\n+                             window=window,\n+                             scale_by_freq=True)\n+        spec_ref, fsp_ref = mlab.psd(x=self.y,\n+                                     NFFT=self.NFFT_density,\n+                                     Fs=self.Fs,\n+                                     noverlap=0,\n+                                     sides=self.sides,\n+                                     window=window,\n+                                     scale_by_freq=True)\n+        assert_allclose(spec * window.sum()**2,\n+                        spec_ref * self.Fs * (window**2).sum(),\n+                        atol=1e-08)\n         with pytest.raises(AssertionError):\n             assert_allclose(spec_b, spec_c, atol=1e-08)\n \n@@ -667,6 +713,29 @@ class TestSpectral:\n         assert_array_equal(fsp_b, fsp_c)\n         assert_allclose(spec_g, spec_c, atol=1e-08)\n         # these should not be almost equal\n+\n+    def test_psd_window_flattop(self):\n+        if self.NFFT_density is None:\n+            return\n+        from scipy import signal\n+        window = signal.windows.flattop(self.NFFT_density_real)\n+        spec, fsp = mlab.psd(x=self.y,\n+                             NFFT=self.NFFT_density,\n+                             Fs=self.Fs,\n+                             noverlap=0,\n+                             sides=self.sides,\n+                             window=window,\n+                             scale_by_freq=True)\n+        spec_ref, fsp_ref = mlab.psd(x=self.y,\n+                                     NFFT=self.NFFT_density,\n+                                     Fs=self.Fs,\n+                                     noverlap=0,\n+                                     sides=self.sides,\n+                                     window=window,\n+                                     scale_by_freq=True)\n+        assert_allclose(spec * window.sum()**2,\n+                        spec_ref * self.Fs * (window**2).sum(),\n+                        atol=1e-08)\n         with pytest.raises(AssertionError):\n             assert_allclose(spec_b, spec_c, atol=1e-08)\n \n",
  "matplotlib__matplotlib-25287": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex c24a832..8917528 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -7801,6 +7801,9 @@ def test_xtickcolor_is_not_xticklabelcolor():\n         assert tick.label1.get_color() == 'blue'\n \n \n+import matplotlib.pyplot as plt\n+import pytest\n+\n def test_ytickcolor_is_not_yticklabelcolor():\n     plt.rcParams['ytick.color'] = 'yellow'\n     plt.rcParams['ytick.labelcolor'] = 'blue'\n",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..32f18e8 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -89,8 +90,25 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n+import pickletools\n \n @mpl.style.context(\"default\")\n+def test_pickle_draggable_legend():\n+    fig, ax = plt.subplots()\n+    ax.plot([0, 1, 2], [0, 1, 4], label='Quadratic')\n+    leg = ax.legend()\n+    leg.set_draggable(True)  # Enable draggable\n+\n+    # Ensure pickling doesn't contain a direct reference to FigureCanvasAgg\n+    pkl = pickle.dumps(fig, protocol=pickle.HIGHEST_PROTOCOL)\n+    assert \"FigureCanvasAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+    \n+    # Restore the figure from the pickle and check if it draws without error\n+    loaded_fig = pickle.loads(pkl)\n+    loaded_fig.canvas.draw()  # We attempt to draw to ensure full restoration\n+\n+    plt.close(fig)\n+    plt.close(loaded_fig)\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..08e02a9 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -44,6 +44,32 @@ def test_simple():\n     pickle.dump(fig, BytesIO(), pickle.HIGHEST_PROTOCOL)\n \n \n+def test_pickle_figure_with_aligned_labels():\n+    import matplotlib.pyplot as plt\n+    import pickle\n+\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    time=[0,1,2,3,4]\n+    speed=[40000,4300,4500,4700,4800]\n+    acc=[10,11,12,13,14]\n+    ax1.plot(time,speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time,acc)\n+    ax2.set_ylabel('acc')\n+\n+    fig.align_labels()\n+\n+    # Ensure pickling does not raise an error\n+    try:\n+        pickle.dumps(fig)\n+        print(\"Pickling successful\")\n+    except Exception as e:\n+        print(f\"Pickling failed: {e}\")\n+        assert False, \"Pickling raised an exception\"\n+\n+\n def _generate_complete_test_figure(fig_ref):\n     fig_ref.set_size_inches((10, 6))\n     plt.figure(fig_ref)\n",
  "matplotlib__matplotlib-25775": "",
  "matplotlib__matplotlib-26113": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex ebe9106..94de206 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -992,6 +992,10 @@ def test_hexbin_linear():\n               reduce_C_function=np.sum)\n \n \n+from matplotlib.testing.decorators import check_figures_equal\n+import numpy as np\n+import matplotlib.pyplot as plt\n+\n def test_hexbin_log_clim():\n     x, y = np.arange(200).reshape((2, 100))\n     fig, ax = plt.subplots()\n@@ -999,7 +1003,41 @@ def test_hexbin_log_clim():\n     assert h.get_clim() == (2, 100)\n \n \n-def test_inverted_limits():\n+@check_figures_equal(extensions=['png'])\n+def test_hexbin_mincnt_c_parameter_behavior(fig_test, fig_ref):\n+    # Given this specific case of datapoints\n+    datapoints = [\n+        (0, 0), (0, 0),  # two points at the same location\n+        (2, 2),\n+        (4, 4), (4, 4)   # two more points at another location\n+    ]\n+    X, Y = zip(*datapoints)\n+    C = np.array([1, 1, 1, 1, 1])\n+\n+    extent = [-10, 10, -10, 10]\n+    gridsize = (5, 5)\n+\n+    # Reference figure without C parameter, should show all locations with >= 1 point\n+    ax_ref = fig_ref.subplots()\n+    ax_ref.hexbin(\n+        X, Y,\n+        gridsize=gridsize,\n+        extent=extent,\n+        mincnt=1,\n+    )\n+    ax_ref.set_facecolor(\"green\")  # for contrast\n+\n+    # Test figure with C parameter, using mincnt=1, should behave similarly\n+    ax_test = fig_test.subplots()\n+    ax_test.hexbin(\n+        X, Y,\n+        C=C,\n+        reduce_C_function=np.sum,  # summing up the C values\n+        gridsize=gridsize,\n+        extent=extent,\n+        mincnt=1,\n+    )\n+    ax_test.set_facecolor(\"green\")  # for contrast\n     # Test gh:1553\n     # Calling invert_xaxis prior to plotting should not disable autoscaling\n     # while still maintaining the inverted direction\n",
  "matplotlib__matplotlib-26291": "",
  "matplotlib__matplotlib-26342": "diff --git a/lib/matplotlib/tests/test_contour.py b/lib/matplotlib/tests/test_contour.py\nindex 700190c..9bcd75b 100644\n--- a/lib/matplotlib/tests/test_contour.py\n+++ b/lib/matplotlib/tests/test_contour.py\n@@ -89,6 +89,45 @@ def test_contour_no_valid_levels():\n     ax.contour(np.ones((9, 9)))\n \n \n+@pytest.mark.parametrize(\"transformation_function\", [lambda x: x, lambda x: x[::-1]])\n+def test_set_paths_direct_comparison(transformation_function):\n+    fig, ax = plt.subplots()\n+    z = np.array([[0, 1], [1, 2]])\n+    cs = ax.contour(z)\n+\n+    # Creating a transformed version of paths\n+    paths = cs.get_paths()\n+    transformed_paths = [mpath.Path(transformation_function(p.vertices)) for p in paths]\n+\n+    # Set paths using the new method\n+    cs.set_paths(transformed_paths)\n+\n+    # Verify the paths have been set properly\n+    new_paths = cs.get_paths()\n+    for original, new in zip(transformed_paths, new_paths):\n+        assert np.allclose(original.vertices, new.vertices)\n+\n+def test_set_paths_no_change_if_none():\n+    fig, ax = plt.subplots()\n+    z = np.array([[1, 2], [2, 3]])\n+    cs = ax.contour(z)\n+\n+    original_paths = cs.get_paths()\n+    cs.set_paths(None)  # Passing None should leave paths unchanged\n+\n+    new_paths = cs.get_paths()\n+    for original, new in zip(original_paths, new_paths):\n+        assert np.allclose(original.vertices, new.vertices)\n+\n+@pytest.mark.parametrize(\"invalid_path\", [None, \"invalid_string\", 123, [np.array([[0, 0], [1, 1]])]])\n+def test_set_paths_invalid_input(invalid_path):\n+    fig, ax = plt.subplots()\n+    z = np.array([[1, 0], [0, -1]])\n+    cs = ax.contour(z)\n+\n+    with pytest.raises((TypeError, ValueError)):\n+        cs.set_paths(invalid_path)\n+\n def test_contour_Nlevels():\n     # A scalar levels arg or kwarg should trigger auto level generation.\n     # https://github.com/matplotlib/matplotlib/issues/11913\n",
  "mwaskom__seaborn-3069": "diff --git a/tests/_core/test_plot.py b/tests/_core/test_plot.py\nindex 3d202bc..0017cae 100644\n--- a/tests/_core/test_plot.py\n+++ b/tests/_core/test_plot.py\n@@ -655,7 +655,26 @@ class TestPlotting:\n         for sub in p._subplots:\n             assert isinstance(sub[\"ax\"], mpl.axes.Axes)\n \n-    def test_empty(self):\n+    def test_nominal_grid_respects_theme(self):\n+        p = Plot(x=[\"a\", \"b\", \"c\"], y=[1, 2, 3])\n+        sns.set_theme(style=\"whitegrid\")\n+        ax = p.plot()._figure.axes[0]\n+        assert any(x.get_visible() for x in ax.xaxis.get_gridlines())\n+        sns.set_theme(style=\"dark\")\n+        ax = p.plot()._figure.axes[0]\n+        assert not any(x.get_visible() for x in ax.xaxis.get_gridlines())\n+\n+    def test_nominal_interference(self):\n+        # Ensure that limits set on one nominal axis don't affect the other\n+        p = Plot(x=[\"a\", \"b\", \"c\", \"d\"], y=[1, 2, 3, 4])\n+        ax = p.plot()._figure.axes[0]\n+        assert ax.get_xlim() == (-0.5, 3.5)\n+        assert ax.get_ylim() == (4.5, 0.5)\n+\n+        p = Plot(y=[\"a\", \"b\", \"c\", \"d\"], x=[1, 2, 3, 4])\n+        ax = p.plot()._figure.axes[0]\n+        assert ax.get_xlim() == (0.5, 4.5)\n+        assert ax.get_ylim() == (3.5, -0.5)\n \n         m = MockMark()\n         Plot().plot()\n",
  "pallets__flask-5014": "diff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\nindex 94a27b3..5af7f3a 100644\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -244,6 +244,9 @@ def test_default_static_max_age(app):\n         app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n \n \n+import pytest\n+import flask\n+\n def test_templates_list(test_apps):\n     from blueprintapp import app\n \n@@ -251,7 +254,17 @@ def test_templates_list(test_apps):\n     assert templates == [\"admin/index.html\", \"frontend/index.html\"]\n \n \n-def test_dotted_name_not_allowed(app, client):\n+def test_empty_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"\", __name__)\n+\n+def test_none_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(None, __name__)\n+\n+def test_whitespace_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"   \", __name__)\n     with pytest.raises(ValueError):\n         flask.Blueprint(\"app.ui\", __name__)\n \n",
  "psf__requests-1142": "",
  "psf__requests-1724": "diff --git a/requests/api.py b/requests/api.py\nindex 66d7f21..70aa6ca 100644\n--- a/requests/api.py\n+++ b/requests/api.py\n@@ -12,6 +12,33 @@ This module implements the Requests API.\n \"\"\"\n \n from . import sessions\n+import requests\n+import pytest\n+\n+# We'll define an endpoint for testing purposes\n+def httpbin(endpoint):\n+    return f'http://httpbin.org/{endpoint}'\n+\n+# Original test function; we preserve and build upon it\n+def test_unicode_method_name():\n+    files = {'file': open('test_requests.py', 'rb')}\n+    r = requests.request(method=u'POST', url=httpbin('post'), files=files)\n+    assert r.status_code == 200\n+\n+# Additional test case to check if `GET` method as a Unicode string works fine\n+def test_unicode_get_method():\n+    response = requests.request(method=u'GET', url=httpbin('get'))\n+    assert response.status_code == 200\n+\n+# Test with other HTTP methods as unicode strings\n+def test_unicode_put_method():\n+    data = {'key': 'value'}\n+    response = requests.request(method=u'PUT', url=httpbin('put'), data=data)\n+    assert response.status_code == 200\n+\n+def test_unicode_delete_method():\n+    response = requests.request(method=u'DELETE', url=httpbin('delete'))\n+    assert response.status_code == 200\n \n \n def request(method, url, **kwargs):\n",
  "psf__requests-1766": "diff --git a/requests/auth.py b/requests/auth.py\nindex ff8249e..7e5ac0c 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -55,6 +55,13 @@ class HTTPProxyAuth(HTTPBasicAuth):\n         return r\n \n \n+import requests\n+from requests.auth import HTTPDigestAuth\n+import hashlib\n+import os\n+import time\n+from urllib.parse import urlparse\n+\n class HTTPDigestAuth(AuthBase):\n     \"\"\"Attaches HTTP Digest Authentication to the given Request object.\"\"\"\n     def __init__(self, username, password):\n",
  "psf__requests-1921": "",
  "psf__requests-2317": "",
  "psf__requests-2931": "",
  "psf__requests-5414": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 7279149..b33e610 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -81,6 +81,14 @@ class TestRequests:\n             (InvalidSchema, 'localhost.localdomain:3128/'),\n             (InvalidSchema, '10.122.1.1:3128/'),\n             (InvalidURL, 'http://'),\n+            (InvalidURL, 'http://.example.com'),\n+            (InvalidURL, 'http://..example.com'),\n+            (InvalidURL, 'http://....example.com'),\n+            (InvalidURL, 'http://example..com'),\n+            (InvalidURL, 'http://example...com'),\n+            (InvalidURL, 'http://.-example.com'),\n+            (InvalidURL, 'http://-example.com'),\n+            (InvalidURL, 'http://example.com.-'),\n         ))\n     def test_invalid_url(self, exception, url):\n         with pytest.raises(exception):\n",
  "pydata__xarray-2905": "diff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex e1452a7..d4639f9 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2308,8 +2308,23 @@ class TestAsCompatibleData:\n         orig = Variable(dims=(\"x\"), data=array, attrs={\"foo\": \"bar\"})\n         assert isinstance(orig._data, CustomIndexable)\n \n+import xarray as xr\n+import numpy as np\n+\n+def test_setitem_with_values_attribute():\n+    good_indexed, bad_indexed = xr.DataArray([None]), xr.DataArray([None])\n+\n+    class HasValues:\n+        values = 5\n+\n+    # Assign an object without a 'values' attribute\n+    good_indexed.loc[{'dim_0': 0}] = set()\n+    assert good_indexed.values[0] == set(), \"Failed to store a set in the DataArray\"\n \n-def test_raise_no_warning_for_nan_in_binary_ops():\n+    # Assign an object with a 'values' attribute\n+    bad_indexed.loc[{'dim_0': 0}] = HasValues()\n+    assert isinstance(bad_indexed.values[0], HasValues), \\\n+        \"Failed to store an instance of HasValues in the DataArray\"\n     with pytest.warns(None) as record:\n         Variable(\"x\", [1, 2, np.NaN]) > 0\n     assert len(record) == 0\n",
  "pydata__xarray-3095": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex d6a4400..5d2222d 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -2107,6 +2107,21 @@ class TestDataset:\n \n         assert_identical(ds.coords['a'], expected_orig)\n \n+    def test_copy_unicode_index(self):\n+        import xarray as xr\n+        import numpy as np\n+        import pytest\n+        \n+        ds = xr.Dataset(\n+            coords={'x': ['foo'], 'y': ('x', ['bar'])},\n+            data_vars={'z': ('x', ['baz'])}\n+        )\n+        \n+        copied = ds.copy(deep=True)\n+        \n+        # Check that the copied dataset maintains the same dtype for 'x' coordinate\n+        assert copied.coords['x'].dtype == ds.coords['x'].dtype, \"dtype of 'x' changed after deep copy\"\n+\n     def test_copy_with_data_errors(self):\n         orig = create_test_data()\n         new_var1 = np.arange(orig['var1'].size).reshape(orig['var1'].shape)\n",
  "pydata__xarray-3151": "diff --git a/xarray/tests/test_combine.py b/xarray/tests/test_combine.py\nindex 026dec9..08e950b 100644\n--- a/xarray/tests/test_combine.py\n+++ b/xarray/tests/test_combine.py\n@@ -574,7 +574,47 @@ class TestCombineAuto:\n         def test_empty_input(self):\n             assert_identical(Dataset(), combine_by_coords([]))\n \n-    def test_infer_order_from_coords(self):\n+    def test_combine_non_monotonic_coords(self):\n+        # Test that the fix for non-monotonic identical coordinates works.\n+        \n+        ycoord = ['a', 'c', 'b']\n+        data1 = np.random.rand(3, 3)\n+        data2 = np.random.rand(4, 3)\n+        \n+        ds1 = Dataset(\n+            data_vars=dict(\n+                data=(['x', 'y'], data1)\n+            ),\n+            coords=dict(\n+                x=[1, 2, 3],\n+                y=ycoord\n+            )\n+        )\n+\n+        ds2 = Dataset(\n+            data_vars=dict(\n+                data=(['x', 'y'], data2)\n+            ),\n+            coords=dict(\n+                x=[4, 5, 6, 7],\n+                y=ycoord\n+            )\n+        )\n+\n+        combined = combine_by_coords((ds1, ds2))\n+\n+        expected_data = np.vstack([data1, data2])\n+        expected_ds = Dataset(\n+            data_vars=dict(\n+                data=(['x', 'y'], expected_data)\n+            ),\n+            coords=dict(\n+                x=[1, 2, 3, 4, 5, 6, 7],\n+                y=ycoord\n+            )\n+        )\n+\n+        assert_identical(combined, expected_ds)\n         data = create_test_data()\n         objs = [data.isel(dim2=slice(4, 9)), data.isel(dim2=slice(4))]\n         actual = combine_by_coords(objs)\n",
  "pydata__xarray-3305": "diff --git a/xarray/tests/test_dataarray.py b/xarray/tests/test_dataarray.py\nindex b0e2440..6d003be 100644\n--- a/xarray/tests/test_dataarray.py\n+++ b/xarray/tests/test_dataarray.py\n@@ -2310,7 +2310,26 @@ class TestDataArray:\n                 )\n                 np.testing.assert_allclose(actual.values, expected)\n \n-    def test_reduce_keep_attrs(self):\n+    def test_quantile_keep_attrs(self):\n+        da = DataArray([0, 0], dims=\"x\", attrs={'units':'K'})\n+        out = da.quantile(.9, dim='x', keep_attrs=True)\n+        assert out.attrs == {'units': 'K'}\n+\n+        da = DataArray([0, 0], dims=\"x\", attrs={})\n+        out = da.quantile(.9, dim='x', keep_attrs=True)\n+        assert out.attrs == {}\n+\n+        da = DataArray([0, 0], dims=\"x\", attrs={'description': 'test'})\n+        out = da.quantile(.9, dim='x', keep_attrs=True)\n+        assert out.attrs == {'description': 'test'}\n+\n+        da = DataArray([0, 0], dims=\"x\", attrs={'units':'K'})\n+        out = da.quantile(.9, dim='x', keep_attrs=False)\n+        assert out.attrs == {}\n+\n+        da = DataArray([0, 0], dims=\"x\")\n+        out = da.quantile(.9, dim='x', keep_attrs=True)\n+        assert out.attrs == {}\n         # Test dropped attrs\n         vm = self.va.mean()\n         assert len(vm.attrs) == 0\n",
  "pydata__xarray-3677": "diff --git a/xarray/tests/test_merge.py b/xarray/tests/test_merge.py\nindex cd14bf3..cde8f1e 100644\n--- a/xarray/tests/test_merge.py\n+++ b/xarray/tests/test_merge.py\n@@ -1,8 +1,10 @@\n+\n import numpy as np\n import pytest\n \n import xarray as xr\n from xarray.core import dtypes, merge\n+from xarray.testing import assert_identical\n \n from . import raises_regex\n from .test_dataset import create_test_data\n@@ -159,7 +161,11 @@ class TestMergeMethod:\n         with raises_regex(ValueError, \"should be coordinates or not\"):\n             data.merge(data.reset_coords())\n \n-    def test_merge_broadcast_equals(self):\n+    def test_merge_dataarray(self):\n+        ds = xr.Dataset({\"a\": 0})\n+        da = xr.DataArray(data=1, name=\"b\")\n+        expected = xr.merge([ds, da])\n+        assert_identical(ds.merge(da), expected)\n         ds1 = xr.Dataset({\"x\": 0})\n         ds2 = xr.Dataset({\"x\": (\"y\", [0, 0])})\n         actual = ds1.merge(ds2)\n",
  "pydata__xarray-4075": "",
  "pydata__xarray-4356": "",
  "pydata__xarray-4629": "diff --git a/xarray/tests/test_merge.py b/xarray/tests/test_merge.py\nindex ef48e47..b78485c 100644\n--- a/xarray/tests/test_merge.py\n+++ b/xarray/tests/test_merge.py\n@@ -109,6 +109,33 @@ class TestMergeFunction:\n             expected.attrs = expected_attrs\n             assert actual.identical(expected)\n \n+    def test_merge_attrs_override_copy(self):\n+        ds1 = xr.Dataset(attrs={\"x\": 0})\n+        ds2 = xr.Dataset(attrs={\"x\": 1})\n+        ds3 = xr.merge([ds1, ds2], combine_attrs=\"override\")\n+        ds3.attrs[\"x\"] = 2\n+        assert ds1.attrs[\"x\"] == 0\n+        assert ds2.attrs[\"x\"] == 1\n+        assert ds3.attrs[\"x\"] == 2\n+\n+    def test_merge_attrs_override_multiple_changes(self):\n+        ds1 = xr.Dataset(attrs={\"key\": \"value1\"})\n+        ds2 = xr.Dataset(attrs={\"key\": \"value2\"})\n+        ds3 = xr.Dataset(attrs={\"key\": \"value3\"})\n+        merged = xr.merge([ds1, ds2, ds3], combine_attrs=\"override\")\n+        \n+        # Initial check\n+        assert merged.attrs[\"key\"] == \"value1\"\n+        \n+        # Change attrs of the merged dataset\n+        merged.attrs[\"key\"] = \"new_value\"\n+        \n+        # Ensure original datasets' attrs remain unchanged\n+        assert ds1.attrs[\"key\"] == \"value1\"\n+        assert ds2.attrs[\"key\"] == \"value2\"\n+        assert ds3.attrs[\"key\"] == \"value3\"\n+        assert merged.attrs[\"key\"] == \"new_value\"\n+\n     def test_merge_dicts_simple(self):\n         actual = xr.merge([{\"foo\": 0}, {\"bar\": \"one\"}, {\"baz\": 3.5}])\n         expected = xr.Dataset({\"foo\": 0, \"bar\": \"one\", \"baz\": 3.5})\n",
  "pydata__xarray-4687": "diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex 636c1f4..f8bf6b8 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -1921,9 +1921,21 @@ def test_where() -> None:\n     expected = xr.DataArray([1, 0], dims=\"x\")\n     assert_identical(expected, actual)\n \n+def test_where_attrs_keep_attrs_true() -> None:\n+    cond = xr.DataArray([True, False], dims=\"x\", attrs={\"attr\": \"condition\"})\n+    x = xr.DataArray([42, 42], dims=\"x\", attrs={\"attr_1\": \"x\"})\n+    y = xr.DataArray([0, 0], dims=\"x\", attrs={\"attr_2\": \"y\"})\n+    actual = xr.where(cond, x, y, keep_attrs=True)\n+    expected = xr.DataArray([42, 0], dims=\"x\", attrs={\"attr_1\": \"x\"})\n+    assert_identical(expected, actual)\n \n-@pytest.mark.parametrize(\"use_dask\", [True, False])\n-@pytest.mark.parametrize(\"use_datetime\", [True, False])\n+def test_where_attrs_default_behavior() -> None:\n+    cond = xr.DataArray([True, False], dims=\"x\", attrs={\"attr\": \"condition\"})\n+    x = xr.DataArray([42, 42], dims=\"x\", attrs={\"attr_1\": \"x\"})\n+    y = xr.DataArray([0, 0], dims=\"x\", attrs={\"attr_2\": \"y\"})\n+    actual = xr.where(cond, x, y)\n+    expected = xr.DataArray([42, 0], dims=\"x\")\n+    assert_identical(expected, actual)\n def test_polyval(use_dask, use_datetime) -> None:\n     if use_dask and not has_dask:\n         pytest.skip(\"requires dask\")\n",
  "pydata__xarray-4695": "diff --git a/xarray/tests/test_dataarray.py b/xarray/tests/test_dataarray.py\nindex 3a4b8ad..4478005 100644\n--- a/xarray/tests/test_dataarray.py\n+++ b/xarray/tests/test_dataarray.py\n@@ -750,6 +750,45 @@ class TestDataArray:\n         assert 1 in data_array\n         assert 3 not in data_array\n \n+    def test_loc_dim_name_collision_with_sel_params(self):\n+        da = DataArray(\n+            [[0, 0], [1, 1]],\n+            dims=[\"dim1\", \"method\"],\n+            coords={\"dim1\": [\"x\", \"y\"], \"method\": [\"a\", \"b\"]},\n+        )\n+        np.testing.assert_array_equal(\n+            da.loc[dict(dim1=[\"x\", \"y\"], method=[\"a\"])], [[0], [1]]\n+        )\n+\n+    def test_loc_with_method_named_index(self):\n+        # Creating an array with dimension named 'method'\n+        da = DataArray(\n+            [[1, 2, 3], [4, 5, 6]],\n+            dims=['method', 'value'],\n+            coords={'method': ['a', 'b'], 'value': [10, 20, 30]}\n+        )\n+        \n+        # Test .loc to retrieve data using 'method' as a dimension\n+        result = da.loc[dict(method='a')]\n+        expected = DataArray([1, 2, 3], dims=['value'], coords={'value': [10, 20, 30]})\n+        assert_identical(result, expected)\n+\n+        # Test .loc with both dimensions\n+        result = da.loc[dict(method='b', value=20)]\n+        expected = DataArray(5)\n+        assert_identical(result, expected)\n+\n+    def test_error_when_method_conflicts_with_fill_method(self):\n+        # Ensuring that if 'method' is used in an incorrect context, the error is user-friendly\n+        da = DataArray(\n+            [[1, 2], [3, 4]],\n+            dims=[\"dim1\", \"dim2\"],\n+            coords={\"dim1\": [\"x\", \"y\"], \"dim2\": [\"method\", \"a\"]}\n+        )\n+\n+        with pytest.raises(ValueError, match=r\"Invalid fill method\"):\n+            da.reindex(dim2=[\"method\", \"a\", \"b\"], method=\"invalid\")\n+\n     def test_attr_sources_multiindex(self):\n         # make sure attr-style access for multi-index levels\n         # returns DataArray objects\n",
  "pydata__xarray-4966": "",
  "pydata__xarray-6461": "diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex f0b426a..ebafa16 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -1915,6 +1915,23 @@ def test_dot_align_coords(use_dask) -> None:\n \n def test_where() -> None:\n     cond = xr.DataArray([True, False], dims=\"x\")\n+    # Test with scalar values and keep_attrs=True\n+    scalar_cond = xr.DataArray([True, False], dims=\"x\")\n+    actual_scalar = xr.where(scalar_cond, 1, 0, keep_attrs=True)\n+    expected_scalar = xr.DataArray([1, 0], dims=\"x\")\n+    assert_identical(expected_scalar, actual_scalar)\n+\n+    # Test with scalar and all False condition\n+    false_scalar_cond = xr.DataArray([False, False], dims=\"x\")\n+    actual_all_false = xr.where(false_scalar_cond, 1, 0, keep_attrs=True)\n+    expected_all_false = xr.DataArray([0, 0], dims=\"x\")\n+    assert_identical(expected_all_false, actual_all_false)\n+\n+    # Test with scalar and all True condition\n+    true_scalar_cond = xr.DataArray([True, True], dims=\"x\")\n+    actual_all_true = xr.where(true_scalar_cond, 1, 0, keep_attrs=True)\n+    expected_all_true = xr.DataArray([1, 1], dims=\"x\")\n+    assert_identical(expected_all_true, actual_all_true)\n     actual = xr.where(cond, 1, 0)\n     expected = xr.DataArray([1, 0], dims=\"x\")\n     assert_identical(expected, actual)\n",
  "pydata__xarray-6599": "diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex f1ec005..a6fb6d7 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -2000,6 +2000,53 @@ def test_where_attrs() -> None:\n             xr.Dataset({\"a\": (\"x\", [1, 2, 3]), \"b\": (\"y\", [3, 4, 5])}),\n             id=\"dataset-dataset\",\n         ),\n+        pytest.param(\n+            xr.DataArray(\n+                np.array([1000, 2000, 3000], dtype=\"timedelta64[ns]\"), dims=\"x\"\n+            ),\n+            xr.DataArray([0, 1], dims=\"degree\", coords={\"degree\": [0, 1]}),\n+            xr.DataArray([1000.0, 2000.0, 3000.0], dims=\"x\"),\n+            id=\"timedelta\",\n+        ),\n+        pytest.param(\n+            xr.DataArray(\n+                np.array([\n+                    \"2021-04-01T05:25:19.000000000\",\n+                    \"2021-04-01T05:25:29.000000000\",\n+                    \"2021-04-01T05:25:39.000000000\",\n+                    \"2021-04-01T05:25:49.000000000\",\n+                    \"2021-04-01T05:25:59.000000000\",\n+                    \"2021-04-01T05:26:09.000000000\",\n+                ], dtype=\"datetime64[ns]\"),\n+                dims=\"azimuth_time\",\n+                coords={\"azimuth_time\": np.array([\n+                    0, 10, 20, 30, 40, 50\n+                ], dtype=\"timedelta64[s]\")}\n+            ),\n+            xr.DataArray(\n+                [\n+                    [2.33333335e-43, 1.62499999e-43, 2.79166678e-43],\n+                    [-1.15316667e-30, 1.49518518e-31, 9.08833333e-31],\n+                    [-2.50272583e-18, -1.23851062e-18, -2.99098229e-18],\n+                    [5.83965193e-06, -1.53321770e-07, -4.84640242e-06],\n+                    [4.44739216e6, 1.45053974e6, 5.29960857e6],\n+                ],\n+                dims=(\"degree\", \"axis\"),\n+                coords={\"axis\": [0, 1, 2], \"degree\": [4, 3, 2, 1, 0]},\n+            ),\n+            xr.DataArray(\n+                [\n+                    [4447392.16, 1450539.74, 5299608.57],\n+                    [4505537.25588366, 1448882.82238152, 5250846.359196],\n+                    [4563174.92026797, 1446979.12250014, 5201491.44401733],\n+                    [4620298.31815291, 1444829.59596699, 5151549.377964],\n+                    [4676900.67053846, 1442435.23739315, 5101025.78153601],\n+                    [4732975.25442459, 1439797.08038974, 5049926.34223336]\n+                ],\n+                dims=(\"azimuth_time\", \"axis\")\n+            ),\n+            id=\"timedelta-coordinate\"\n+        ),\n         pytest.param(\n             xr.DataArray(pd.date_range(\"1970-01-01\", freq=\"s\", periods=3), dims=\"x\"),\n             xr.DataArray([0, 1], dims=\"degree\", coords={\"degree\": [0, 1]}),\n@@ -2010,6 +2057,53 @@ def test_where_attrs() -> None:\n             ),\n             id=\"datetime\",\n         ),\n+        pytest.param(\n+            xr.DataArray(\n+                np.array([1000, 2000, 3000], dtype=\"timedelta64[ns]\"), dims=\"x\"\n+            ),\n+            xr.DataArray([0, 1], dims=\"degree\", coords={\"degree\": [0, 1]}),\n+            xr.DataArray([1000.0, 2000.0, 3000.0], dims=\"x\"),\n+            id=\"timedelta\",\n+        ),\n+        pytest.param(\n+            xr.DataArray(\n+                np.array([\n+                    \"2021-04-01T05:25:19.000000000\",\n+                    \"2021-04-01T05:25:29.000000000\",\n+                    \"2021-04-01T05:25:39.000000000\",\n+                    \"2021-04-01T05:25:49.000000000\",\n+                    \"2021-04-01T05:25:59.000000000\",\n+                    \"2021-04-01T05:26:09.000000000\",\n+                ], dtype=\"datetime64[ns]\"),\n+                dims=\"azimuth_time\",\n+                coords={\"azimuth_time\": np.array([\n+                    0, 10, 20, 30, 40, 50\n+                ], dtype=\"timedelta64[s]\")}\n+            ),\n+            xr.DataArray(\n+                [\n+                    [2.33333335e-43, 1.62499999e-43, 2.79166678e-43],\n+                    [-1.15316667e-30, 1.49518518e-31, 9.08833333e-31],\n+                    [-2.50272583e-18, -1.23851062e-18, -2.99098229e-18],\n+                    [5.83965193e-06, -1.53321770e-07, -4.84640242e-06],\n+                    [4.44739216e6, 1.45053974e6, 5.29960857e6],\n+                ],\n+                dims=(\"degree\", \"axis\"),\n+                coords={\"axis\": [0, 1, 2], \"degree\": [4, 3, 2, 1, 0]},\n+            ),\n+            xr.DataArray(\n+                [\n+                    [4447392.16, 1450539.74, 5299608.57],\n+                    [4505537.25588366, 1448882.82238152, 5250846.359196],\n+                    [4563174.92026797, 1446979.12250014, 5201491.44401733],\n+                    [4620298.31815291, 1444829.59596699, 5151549.377964],\n+                    [4676900.67053846, 1442435.23739315, 5101025.78153601],\n+                    [4732975.25442459, 1439797.08038974, 5049926.34223336]\n+                ],\n+                dims=(\"azimuth_time\", \"axis\")\n+            ),\n+            id=\"timedelta-coordinate\"\n+        ),\n     ],\n )\n def test_polyval(\n",
  "pydata__xarray-6721": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex cab9007..a455f78 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -221,6 +221,12 @@ class InaccessibleVariableDataStore(backends.InMemoryDataStore):\n \n \n class TestDataset:\n+    def test_chunks_does_not_load_entire_data(self) -> None:\n+        url = \"https://ncsa.osn.xsede.org/Pangeo/pangeo-forge/swot_adac/FESOM/surf/fma.zarr\"\n+        ds = xr.open_dataset(url, engine='zarr')\n+        with pytest.raises(AssertionError):\n+            assert np.asarray(ds.chunks) != np.asarray(ds)\n+        \n     def test_repr(self) -> None:\n         data = create_test_data(seed=123)\n         data.attrs[\"foo\"] = \"bar\"\n",
  "pydata__xarray-6744": "diff --git a/xarray/tests/test_rolling.py b/xarray/tests/test_rolling.py\nindex 0a9ef75..e90ade7 100644\n--- a/xarray/tests/test_rolling.py\n+++ b/xarray/tests/test_rolling.py\n@@ -27,7 +27,32 @@ pytestmark = [\n \n class TestDataArrayRolling:\n     @pytest.mark.parametrize(\"da\", (1, 2), indirect=True)\n-    def test_rolling_iter(self, da) -> None:\n+    @pytest.mark.parametrize(\"center\", [True, False])\n+    @pytest.mark.parametrize(\"size\", [1, 2, 3, 7])\n+    def test_rolling_iter(self, da, center, size) -> None:\n+        rolling_obj = da.rolling(time=size, center=center)\n+        rolling_obj_mean = rolling_obj.mean()\n+\n+        assert len(rolling_obj.window_labels) == len(da[\"time\"])\n+        assert_identical(rolling_obj.window_labels, da[\"time\"])\n+\n+        for i, (label, window_da) in enumerate(rolling_obj):\n+            assert label == da[\"time\"].isel(time=i)\n+\n+            actual = rolling_obj_mean.isel(time=i)\n+            expected = window_da.mean(\"time\")\n+\n+            assert_array_equal(actual.isnull(), expected.isnull())\n+            if (~actual.isnull()).sum() > 0:\n+                np.testing.assert_allclose(\n+                    actual.values[actual.values.nonzero()],\n+                    expected.values[expected.values.nonzero()],\n+                )\n+\n+        # Additional test: verify manual iteration with center\n+        result_manual_iter = [window.mean().values.item() for label, window in rolling_obj]\n+        result_rolling = da.rolling(time=size, center=center).mean().values\n+        np.testing.assert_allclose(result_manual_iter, result_rolling, err_msg=f\"Mismatch with center={center}, size={size}\")\n         rolling_obj = da.rolling(time=7)\n         rolling_obj_mean = rolling_obj.mean()\n \n",
  "pydata__xarray-7233": "",
  "pydata__xarray-7393": "diff --git a/xarray/tests/test_indexes.py b/xarray/tests/test_indexes.py\nindex fa8bd84..8fc3d42 100644\n--- a/xarray/tests/test_indexes.py\n+++ b/xarray/tests/test_indexes.py\n@@ -688,12 +688,22 @@ def test_safe_cast_to_index_cftimeindex():\n         assert isinstance(actual, type(expected))\n \n \n-# Test that datetime.datetime objects are never used in a CFTimeIndex\n-@requires_cftime\n-def test_safe_cast_to_index_datetime_datetime():\n-    dates = [datetime(1, 1, day) for day in range(1, 20)]\n+import pytest\n+import numpy as np\n+import xarray as xr\n \n-    expected = pd.Index(dates)\n-    actual = safe_cast_to_index(np.array(dates))\n-    assert_array_equal(expected, actual)\n-    assert isinstance(actual, pd.Index)\n+@pytest.mark.parametrize(\"dtype\", [\"int32\", \"float32\"])\n+def test_restore_dtype_on_multiindexes(dtype: str) -> None:\n+    foo = xr.Dataset(coords={\"bar\": (\"bar\", np.array([0, 1], dtype=dtype))})\n+    foo = foo.stack(baz=(\"bar\",))\n+    assert str(foo[\"bar\"].values.dtype) == dtype\n+\n+def test_stack_preserves_int32():\n+    ds = xr.Dataset(coords={'a': np.array([0], dtype='i4')})\n+    stacked = ds.stack(b=('a',))\n+    assert stacked['a'].values.dtype == ds['a'].values.dtype\n+\n+def test_stack_preserves_float32():\n+    ds = xr.Dataset(coords={'a': np.array([0.0], dtype='f4')})\n+    stacked = ds.stack(b=('a',))\n+    assert stacked['a'].values.dtype == ds['a'].values.dtype\n",
  "pylint-dev__pylint-4970": "diff --git a/tests/checkers/unittest_similar.py b/tests/checkers/unittest_similar.py\nindex 97cd4d0..bc26e36 100644\n--- a/tests/checkers/unittest_similar.py\n+++ b/tests/checkers/unittest_similar.py\n@@ -493,12 +493,22 @@ def test_get_map_data() -> None:\n             sim.append_stream(source_fname, stream)\n         # The map bit, can you tell? ;)\n         data.extend(sim.get_map_data())\n+from io import StringIO\n+from contextlib import redirect_stdout\n+import pytest\n+from pylint.checkers.similar import Similar\n \n-    assert len(expected_linelists) == len(data)\n+def test_set_min_similarity_lines_to_zero():\n+    \"\"\"Test that setting min-similarity-lines to 0 disables duplicate code check.\"\"\"\n+    output = StringIO()\n+    with redirect_stdout(output), pytest.raises(SystemExit) as ex:\n+        similar.Run([\"--duplicates=0\", \"file1.py\", \"file2.py\"])\n+    assert ex.value.code == 0\n+    assert output.getvalue() == \"\"\n     for source_fname, expected_lines, lineset_obj in zip(\n         source_streams, expected_linelists, data\n     ):\n         assert source_fname == lineset_obj.name\n         # There doesn't seem to be a faster way of doing this, yet.\n         lines = (linespec.text for linespec in lineset_obj.stripped_lines)\n-        assert tuple(expected_lines) == tuple(lines)\n+        assert tuple(expected_lines) == tuple(lines)\n",
  "pylint-dev__pylint-6386": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex a0b1b64..91a0136 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -94,9 +94,36 @@ def test_unknown_yes_no(capsys: CaptureFixture) -> None:\n     assert \"Invalid yn value 'maybe', should be in \" in output.err\n \n \n+from pytest import CaptureFixture\n+from pylint.lint.run import Run\n+from pathlib import Path\n+\n+EMPTY_MODULE = Path(__file__).parent / \"empty_module.py\"\n+\n+def test_short_verbose(capsys: CaptureFixture) -> None:\n+    \"\"\"Check that we correctly handle the -v flag.\"\"\"\n+    Run([str(EMPTY_MODULE), \"-v\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"Using config file\" in output.err\n+\n+def test_long_verbose(capsys: CaptureFixture) -> None:\n+    \"\"\"Check that we correctly handle the --verbose flag.\"\"\"\n+    Run([str(EMPTY_MODULE), \"--verbose\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"Using config file\" in output.err\n+    \n+def test_verbose_error_message(capsys: CaptureFixture) -> None:\n+    \"\"\"Ensure no error is raised for verbose flag.\"\"\"\n+    result = None\n+    try:\n+        Run([str(EMPTY_MODULE), \"-v\"], exit=False)\n+    except SystemExit as exc:\n+        result = exc.code\n+    assert result is None  # Verify that no SystemExit was raised\n+\n def test_unknown_py_version(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly error on an unknown python-version.\"\"\"\n     with pytest.raises(SystemExit):\n         Run([str(EMPTY_MODULE), \"--py-version=the-newest\"], exit=False)\n     output = capsys.readouterr()\n-    assert \"the-newest has an invalid format, should be a version string.\" in output.err\n+    assert \"the-newest has an invalid format, should be a version string.\" in output.err\n",
  "pylint-dev__pylint-6528": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex d5ccd91..5edf939 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -863,8 +863,44 @@ def test_by_module_statement_value(initialized_linter: PyLinter) -> None:\n         # computed for that module\n         assert module_stats[\"statement\"] == linter2.stats.statement\n \n+import os\n+from pylint.lint import Run\n+import pytest\n+from os.path import join\n+\n+@pytest.mark.parametrize(\n+    \"ignore_parameter,ignore_parameter_value\",\n+    [\n+        (\"--ignore\", \".a\"),\n+        (\"--ignore-patterns\", \"^\\\\.a\"),\n+        (\"--ignore-paths\", \".*/\\\\.a/.*\"),\n+    ],\n+)\n+def test_recursive_ignore_respects_parameters(ignore_parameter, ignore_parameter_value) -> None:\n+    regrtest_data_dir = \"path_to_test_data_directory\"  # Update with the actual path\n+    run = Run(\n+        [\n+            \"--recursive\",\n+            \"y\",\n+            ignore_parameter,\n+            ignore_parameter_value,\n+            regrtest_data_dir,\n+        ],\n+        do_exit=False,\n+    )\n+\n+    linted_files = run.linter._iterate_file_descrs(\n+        tuple(run.linter._discover_files([regrtest_data_dir]))\n+    )\n+    linted_file_paths = [file_item.filepath for file_item in linted_files]\n+\n+    ignored_file = os.path.abspath(\n+        join(regrtest_data_dir, \".a\", \"foo.py\")\n+    )\n+    assert ignored_file not in linted_file_paths\n \n-def test_import_sibling_module_from_namespace(initialized_linter: PyLinter) -> None:\n+    expected_module = os.path.abspath(join(regrtest_data_dir, \"bar.py\"))\n+    assert expected_module in linted_file_paths\n     \"\"\"If the parent directory above `namespace` is on sys.path, ensure that\n     modules under `namespace` can import each other without raising `import-error`.\"\"\"\n     linter = initialized_linter\n",
  "pylint-dev__pylint-6903": "",
  "pylint-dev__pylint-7080": "",
  "pylint-dev__pylint-7277": "",
  "pytest-dev__pytest-10051": "diff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex 26c4c15..2f4d2bc 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -160,7 +160,33 @@ def logging_during_setup_and_teardown(caplog):\n     assert [x.message for x in caplog.get_records(\"teardown\")] == [\"a_teardown_log\"]\n \n \n-def test_caplog_captures_for_all_stages(caplog, logging_during_setup_and_teardown):\n+def test_caplog_get_records_consistency_with_clear(caplog):\n+    def verify_consistency():\n+        assert caplog.get_records(\"call\") == caplog.records\n+\n+    verify_consistency()\n+    logging.warning(\"test\")\n+    verify_consistency()\n+    caplog.clear()\n+    verify_consistency()  # This should pass\n+\n+    logging.warning(\"test after clear\")\n+    assert [x.message for x in caplog.get_records(\"call\")] == [\"test after clear\"]\n+    assert caplog.records == caplog.get_records(\"call\")\n+\n+def test_caplog_get_records_consistency_with_clear(caplog):\n+    def verify_consistency():\n+        assert caplog.get_records(\"call\") == caplog.records\n+\n+    verify_consistency()\n+    logging.warning(\"test\")\n+    verify_consistency()\n+    caplog.clear()\n+    verify_consistency()  # This should pass\n+\n+    logging.warning(\"test after clear\")\n+    assert [x.message for x in caplog.get_records(\"call\")] == [\"test after clear\"]\n+    assert caplog.records == caplog.get_records(\"call\")\n     assert not caplog.records\n     assert not caplog.get_records(\"call\")\n     logger.info(\"a_call_log\")\n",
  "pytest-dev__pytest-10081": "diff --git a/testing/test_debugging.py b/testing/test_debugging.py\nindex 912abd7..35f789a 100644\n--- a/testing/test_debugging.py\n+++ b/testing/test_debugging.py\n@@ -258,7 +258,37 @@ class TestPDB:\n         assert \"1 failed\" in rest\n         self.flush(child)\n \n-    def test_pdb_print_captured_logs_nologging(self, pytester: Pytester) -> None:\n+    def test_pdb_unittest_skip_class_teardown(self, pytester: Pytester) -> None:\n+        \"\"\"\n+        Ensure `setUp` and `tearDown` are not called for a skipped class using unittest.\n+        \"\"\"\n+        p1 = pytester.makepyfile(\n+            \"\"\"\n+            import unittest\n+            import pytest\n+\n+            class TrackSkips:\n+                def __init__(self):\n+                    self.called_methods = []\n+\n+            @unittest.skip(\"skip test case\")\n+            class SkippedTestCase(unittest.TestCase):\n+                def setUp(self):\n+                    TrackSkips.called_methods.append(\"setUp:\" + self.id())\n+\n+                def tearDown(self):\n+                    TrackSkips.called_methods.append(\"tearDown:\" + self.id())\n+\n+                def test_example(self):\n+                    pass\n+\n+            def test_check_skipped_methods_called():\n+                assert TrackSkips.called_methods == []\n+        \"\"\"\n+        )\n+        result = pytester.runpytest_inprocess(\"--pdb\", p1)\n+        result.stdout.fnmatch_lines(\"* 1 skipped in *\")\n+        result.assert_outcomes(skipped=1)\n         p1 = pytester.makepyfile(\n             \"\"\"\n             def test_1():\n",
  "pytest-dev__pytest-5262": "",
  "pytest-dev__pytest-5631": "diff --git a/testing/test_unittest.py b/testing/test_unittest.py\nindex 8c1c2d7..01e7164 100644\n--- a/testing/test_unittest.py\n+++ b/testing/test_unittest.py\n@@ -1,7 +1,9 @@\n+\n import gc\n \n import pytest\n from _pytest.main import ExitCode\n+import numpy as np\n \n \n def test_simple_unittest(testdir):\n",
  "pytest-dev__pytest-5809": "diff --git a/testing/test_pastebin.py b/testing/test_pastebin.py\nindex c6a6cae..5d627a1 100644\n--- a/testing/test_pastebin.py\n+++ b/testing/test_pastebin.py\n@@ -119,15 +119,23 @@ class TestPaste(object):\n \n             monkeypatch.setattr(urllib.request, \"urlopen\", mocked)\n         return calls\n-\n-    def test_create_new_paste(self, pastebin, mocked_urlopen):\n+    def test_create_new_paste_text_lexer(self, pastebin, mocked_urlopen):\n+        result = pastebin.create_new_paste(b\"full-paste-contents\")\n+        assert result == \"https://bpaste.net/show/3c0c6750bd\"\n+        assert len(mocked_urlopen) == 1\n+        url, data = mocked_urlopen[0]\n+        assert type(data) is bytes\n+        assert url == \"https://bpaste.net\"\n+        assert \"lexer=text\" in data.decode()\n+        assert \"code=full-paste-contents\" in data.decode()\n+        assert \"expiry=1week\" in data.decode()\n         result = pastebin.create_new_paste(b\"full-paste-contents\")\n         assert result == \"https://bpaste.net/show/3c0c6750bd\"\n         assert len(mocked_urlopen) == 1\n         url, data = mocked_urlopen[0]\n         assert type(data) is bytes\n-        lexer = \"python3\" if sys.version_info[0] >= 3 else \"python\"\n         assert url == \"https://bpaste.net\"\n+        assert \"lexer=text\" in data.decode()\n         assert \"lexer=%s\" % lexer in data.decode()\n         assert \"code=full-paste-contents\" in data.decode()\n-        assert \"expiry=1week\" in data.decode()\n+        assert \"expiry=1week\" in data.decode()\n",
  "pytest-dev__pytest-6202": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex fb6b260..7995c5b 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -702,6 +702,28 @@ class Test_genitems:\n         assert items[1].name == \"testmethod_one\"\n         assert items[2].name == \"testmethod_one\"\n \n+        # Additional test case to ensure issue fix\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            @pytest.mark.parametrize(\"arg0\", [\".[\"])\n+            def testmethod_two(arg0):\n+                pass\n+\n+            class TestY:\n+                def testmethod_three(self, arg0):\n+                    pass\n+            \"\"\"\n+        )\n+        items, reprec = testdir.inline_genitems(p)\n+        assert len(items) == 2\n+        assert items[0].name == \"testmethod_two[.[]\"\n+        assert items[0].getmodpath() == \"testmethod_two[.[]\"\n+        # Check for class method parametrize usage as well\n+        assert items[1].name == \"testmethod_three[.[]\"\n+        assert items[1].getmodpath() == \"TestY.testmethod_three[.[]\"\n+\n         # let's also test getmodpath here\n         assert items[0].getmodpath() == \"testone\"\n         assert items[1].getmodpath() == \"TestX.testmethod_one\"\n",
  "pytest-dev__pytest-7205": "",
  "pytest-dev__pytest-7236": "",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..302cc4f 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -607,6 +607,26 @@ class TestSkip:\n         result = testdir.runpytest(\"-rs\")\n         result.stdout.fnmatch_lines([\"*unconditional skip*\", \"*1 skipped*\"])\n \n+    def test_xfail_run_with_skip_mark(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            @pytest.mark.skip\n+            def test_skip_location() -> None:\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(\"-rs\")\n+        result.stdout.fnmatch_lines(\n+            [\"SKIPPED [1] test_sample.py:3: unconditional skip\", \"*1 skipped*\"]\n+        )\n+\n+        # Now test with --runxfail\n+        result = testdir.runpytest(\"-rs\", \"--runxfail\")\n+        result.stdout.fnmatch_lines(\n+            [\"SKIPPED [1] test_sample.py:3: unconditional skip\", \"*1 skipped*\"]\n+        )\n+\n     def test_skip_with_reason(self, testdir):\n         testdir.makepyfile(\n             \"\"\"\n",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..bc5198b 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,7 +1,9 @@\n+\n import sys\n \n import pytest\n from _pytest.runner import runtestprotocol\n+from _pytest.pytester import Testdir\n from _pytest.skipping import evaluate_skip_marks\n from _pytest.skipping import evaluate_xfail_marks\n from _pytest.skipping import pytest_runtest_setup\n@@ -154,6 +156,34 @@ class TestEvaluation:\n \n \n class TestXFail:\n+    @pytest.mark.parametrize(\"strict\", [True, False])\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # Verify that adding xfail marker dynamically during runtime results in xfailed test\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            def test_dynamic_xfail(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir: Testdir) -> None:\n+        # Verify that a dynamic xfail marked test which passes fails strict check\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            def test_dynamic_xfail(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\", strict=True))\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n+\n     @pytest.mark.parametrize(\"strict\", [True, False])\n     def test_xfail_simple(self, testdir, strict):\n         item = testdir.getitem(\n",
  "pytest-dev__pytest-7521": "diff --git a/testing/test_capture.py b/testing/test_capture.py\nindex 9d70acf..6688d02 100644\n--- a/testing/test_capture.py\n+++ b/testing/test_capture.py\n@@ -513,8 +513,12 @@ class TestCaptureFixture:\n             \"\"\"\n         )\n         reprec.assertoutcome(passed=1)\n-\n-    def test_capfdbinary(self, testdir):\n+    @pytest.mark.parametrize(\"nl\", (\"\\n\", \"\\r\\n\", \"\\r\"))\n+    def test_cafd_preserves_newlines(self, capfd, nl):\n+        print(\"newline test\", end=nl)\n+        out, err = capfd.readouterr()\n+        assert out.endswith(nl)\n+        assert err == \"\"\n         reprec = testdir.inline_runsource(\n             \"\"\"\\\n             def test_hello(capfdbinary):\n",
  "pytest-dev__pytest-7571": "diff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex a9649e4..5ec5a95 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -1,3 +1,4 @@\n+\n import logging\n \n import pytest\n@@ -50,7 +51,34 @@ def test_change_level_undo(testdir):\n     result.stdout.no_fnmatch_line(\"*log from test2*\")\n \n \n-def test_with_statement(caplog):\n+def test_restored_log_level_after_test(testdir):\n+    \"\"\"Test to ensure log levels are restored after using `caplog.set_level` in each test.\"\"\"\n+    testdir.makepyfile(\n+        \"\"\"\n+        import logging\n+\n+        def test_first(caplog):\n+            caplog.set_level(logging.WARNING)\n+            assert logging.getLogger().level == logging.WARNING\n+\n+        def test_second(caplog):\n+            # Ensure log level is restored to NOTSET (0) for the handler after previous test\n+            assert caplog.handler.level == logging.NOTSET  # should be restored\n+            assert logging.getLogger().level == logging.NOTSET\n+\n+        def test_third(caplog):\n+            caplog.set_level(logging.ERROR)\n+            assert logging.getLogger().level == logging.ERROR\n+            assert caplog.handler.level == logging.ERROR\n+\n+        def test_fourth(caplog):\n+            # Ensure log level is restored to NOTSET (0) for the handler after previous test\n+            assert caplog.handler.level == logging.NOTSET  # should be restored\n+            assert logging.getLogger().level == logging.NOTSET\n+    \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    result.assert_outcomes(passed=4)\n     with caplog.at_level(logging.INFO):\n         logger.debug(\"handler DEBUG level\")\n         logger.info(\"handler INFO level\")\n",
  "pytest-dev__pytest-7982": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex b774a67..3335c82 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -1,3 +1,4 @@\n+\n import os\n import pprint\n import sys\n@@ -9,7 +10,7 @@ from _pytest.config import ExitCode\n from _pytest.main import _in_venv\n from _pytest.main import Session\n from _pytest.pathlib import symlink_or_skip\n-from _pytest.pytester import Testdir\n+from _pytest.pytester import Testdir, Pytester\n \n \n class TestCollector:\n@@ -1177,8 +1178,13 @@ def test_collect_symlink_out_of_tree(testdir):\n     )\n     assert result.ret == 0\n \n-\n-def test_collectignore_via_conftest(testdir):\n+def test_collect_symlink_dir(pytester: Pytester) -> None:\n+    \"\"\"A symlinked directory is collected.\"\"\"\n+    dir = pytester.mkdir(\"dir\")\n+    dir.joinpath(\"test_it.py\").write_text(\"def test_it(): pass\", \"utf-8\")\n+    pytester.path.joinpath(\"symlink_dir\").symlink_to(dir)\n+    result = pytester.runpytest()\n+    result.assert_outcomes(passed=2)\n     \"\"\"collect_ignore in parent conftest skips importing child (issue #4592).\"\"\"\n     tests = testdir.mkpydir(\"tests\")\n     tests.ensure(\"conftest.py\").write(\"collect_ignore = ['ignore_me']\")\n",
  "pytest-dev__pytest-8399": "diff --git a/testing/test_unittest.py b/testing/test_unittest.py\nindex 2c720b0..b7b8e70 100644\n--- a/testing/test_unittest.py\n+++ b/testing/test_unittest.py\n@@ -301,8 +301,31 @@ def test_setup_setUpClass(pytester: Pytester) -> None:\n     reprec = pytester.inline_run(testpath)\n     reprec.assertoutcome(passed=3)\n \n+def test_unittest_setUpClass_is_private(pytester: Pytester) -> None:\n+    testpath = pytester.makepyfile(\n+        \"\"\"\n+        import unittest\n+        class MyTestCase(unittest.TestCase):\n+            @classmethod\n+            def setUpClass(cls):\n+                pass\n+\n+            def test_func(self):\n+                pass\n+        \"\"\"\n+    )\n+    result = pytester.runpytest(\"--fixtures\")\n+    assert result.ret == 0\n+    # The fixture should not be listed by default, so check it's not present\n+    result.stdout.no_fnmatch_line(\"*unittest_setUpClass_fixture_MyTestCase*\")\n+\n+    result = pytester.runpytest(\"--fixtures\", \"-v\")\n+    assert result.ret == 0\n+    # When using -v, it should be visible as it shows all available fixtures\n+    result.stdout.fnmatch_lines([\"*unittest_setUpClass_fixture_MyTestCase*\"])\n+\n \n-def test_setup_class(pytester: Pytester) -> None:\n+# Existing test\n     testpath = pytester.makepyfile(\n         \"\"\"\n         import unittest\n",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..30920ee 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -598,7 +598,35 @@ def test_ridgecv_store_cv_values():\n     assert_equal(r.cv_values_.shape, (n_samples, n_responses, n_alphas))\n \n \n-def test_ridgecv_sample_weight():\n+def test_ridge_classifier_cv_store_cv_values():\n+    from sklearn.linear_model import RidgeClassifierCV\n+    import numpy as np\n+    from numpy.testing import assert_equal\n+    \n+    # Test that the store_cv_values attribute works correctly\n+    x = np.array([[-1.0, -1.0], [-1.0, 0], [-0.8, -1.0],\n+                  [1.0, 1.0], [1.0, 0.0]])\n+    y = np.array([1, 1, 1, -1, -1])\n+\n+    n_samples = x.shape[0]\n+    alphas = [1e-1, 1e0, 1e1]\n+    n_alphas = len(alphas)\n+\n+    # RidgeClassifierCV initialization with store_cv_values=True\n+    r = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+    \n+    # with len(y.shape) == 1\n+    n_targets = 1\n+    r.fit(x, y)\n+    assert_equal(r.cv_values_.shape, (n_samples, n_targets, n_alphas))\n+    \n+    # Multi-target scenario\n+    y = np.array([[1, 1, 1, -1, -1],\n+                  [1, -1, 1, -1, 1],\n+                  [-1, -1, 1, -1, -1]]).transpose()\n+    n_targets = y.shape[1]\n+    r.fit(x, y)\n+    assert_equal(r.cv_values_.shape, (n_samples, n_targets, n_alphas))\n     rng = np.random.RandomState(0)\n     alphas = (0.1, 1.0, 10.0)\n \n",
  "scikit-learn__scikit-learn-10844": "diff --git a/sklearn/metrics/cluster/tests/test_supervised.py b/sklearn/metrics/cluster/tests/test_supervised.py\nindex f5edf7a..e1cf808 100644\n--- a/sklearn/metrics/cluster/tests/test_supervised.py\n+++ b/sklearn/metrics/cluster/tests/test_supervised.py\n@@ -167,6 +167,10 @@ def test_adjusted_mutual_info_score():\n     assert_almost_equal(ami, 0.37, 2)\n \n \n+import numpy as np\n+from sklearn.metrics import fowlkes_mallows_score\n+from sklearn.utils.testing import assert_all_finite\n+\n def test_expected_mutual_info_overflow():\n     # Test for regression where contingency cell exceeds 2**16\n     # leading to overflow in np.outer, resulting in EMI > 1\n@@ -183,8 +187,14 @@ def test_int_overflow_mutual_info_score():\n \n     assert_all_finite(mutual_info_score(x.ravel(), y.ravel()))\n \n-\n-def test_entropy():\n+def test_fowlkes_mallows_score_large_values():\n+    # Test for issue with large values causing overflow in fowlkes_mallows_score\n+    labels_true = np.array([0] * 100000 + [1] * 100000)\n+    labels_pred = np.array([0, 1] * 100000)\n+    \n+    # This should not result in a RuntimeWarning or NaN value\n+    score = fowlkes_mallows_score(labels_true, labels_pred)\n+    assert_all_finite(score)\n     ent = entropy([0, 0, 42.])\n     assert_almost_equal(ent, 0.6365141, 5)\n     assert_almost_equal(entropy([]), 1)\n",
  "scikit-learn__scikit-learn-10908": "diff --git a/sklearn/feature_extraction/tests/test_text.py b/sklearn/feature_extraction/tests/test_text.py\nindex 0a2b603..c7aafe8 100644\n--- a/sklearn/feature_extraction/tests/test_text.py\n+++ b/sklearn/feature_extraction/tests/test_text.py\n@@ -558,8 +558,25 @@ def test_feature_names():\n     for idx, name in enumerate(feature_names):\n         assert_equal(idx, cv.vocabulary_.get(name))\n \n+def test_get_feature_names_with_custom_vocabulary():\n+    vocab = ['and', 'document', 'first', 'is', 'one', 'second', 'the', 'third', 'this']\n+    cv = CountVectorizer(vocabulary=vocab)\n \n-def test_vectorizer_max_features():\n+    # Check that get_feature_names does not raise NotFittedError\n+    feature_names = cv.get_feature_names()\n+    assert_array_equal(vocab, feature_names)\n+\n+    corpus = [\n+        'This is the first document.',\n+        'This is the second second document.',\n+        'And the third one.',\n+        'Is this the first document?',\n+    ]\n+\n+    # Transform the corpus and ensure it works correctly\n+    X = cv.transform(corpus)\n+    assert_equal(X.shape, (4, 9))\n+    assert_true(hasattr(cv, \"vocabulary_\"))\n     vec_factories = (\n         CountVectorizer,\n         TfidfVectorizer,\n",
  "scikit-learn__scikit-learn-11310": "diff --git a/sklearn/model_selection/tests/test_search.py b/sklearn/model_selection/tests/test_search.py\nindex 0b1d5f9..240fe1a 100644\n--- a/sklearn/model_selection/tests/test_search.py\n+++ b/sklearn/model_selection/tests/test_search.py\n@@ -1150,6 +1150,29 @@ def test_search_cv_results_none_param():\n \n \n @ignore_warnings()\n+def test_refit_time_attribute():\n+    svc = LinearSVC(random_state=0)\n+\n+    X, y = make_blobs(n_samples=20, centers=2, random_state=0)\n+\n+    grid_search = GridSearchCV(svc, {'C': [0.1, 1, 10]}, cv=3, refit=True)\n+    grid_search.fit(X, y)\n+    \n+    # Check that refit_time_ exists and is a float\n+    assert_true(hasattr(grid_search, \"refit_time_\"))\n+    assert_true(isinstance(grid_search.refit_time_, float))\n+    assert_greater_equal(grid_search.refit_time_, 0)\n+\n+    random_search = RandomizedSearchCV(svc, {'C': [0.1, 1, 10]}, cv=3, n_iter=2, refit=True)\n+    random_search.fit(X, y)\n+\n+    # Check again for RandomizedSearchCV\n+    assert_true(hasattr(random_search, \"refit_time_\"))\n+    assert_true(isinstance(random_search.refit_time_, float))\n+    assert_greater_equal(random_search.refit_time_, 0)\n+\n+\n+# Existing test_search_cv_timing remains unchanged\n def test_search_cv_timing():\n     svc = LinearSVC(random_state=0)\n \n",
  "scikit-learn__scikit-learn-11578": "diff --git a/sklearn/linear_model/tests/test_logistic.py b/sklearn/linear_model/tests/test_logistic.py\nindex daa75d1..78a2ca2 100644\n--- a/sklearn/linear_model/tests/test_logistic.py\n+++ b/sklearn/linear_model/tests/test_logistic.py\n@@ -21,6 +21,13 @@ from sklearn.utils.testing import assert_true\n from sklearn.utils.testing import assert_warns\n from sklearn.utils.testing import ignore_warnings\n from sklearn.utils.testing import assert_warns_message\n+from sklearn.model_selection import train_test_split\n+from sklearn.preprocessing import LabelBinarizer\n+from sklearn.datasets import make_classification\n+from sklearn.linear_model import LogisticRegression\n+from sklearn.utils import extmath\n+import pytest\n+from sklearn.metrics import log_loss\n \n from sklearn.exceptions import ConvergenceWarning\n from sklearn.exceptions import ChangedBehaviorWarning\n@@ -491,8 +498,52 @@ def test_logistic_cv():\n     scores = np.asarray(list(lr_cv.scores_.values()))\n     assert_array_equal(scores.shape, (1, 3, 1))\n \n+def test_logistic_regressioncv_multinomial_predict_proba():\n+    # Test that LogisticRegressionCV uses the correct multiclass strategy\n+    X, y = make_classification(n_samples=100, n_features=5, n_classes=3, n_informative=3, random_state=0)\n+    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n+\n+    lr_multinomial = LogisticRegression(multi_class='multinomial', solver='lbfgs')\n+    lr_multinomial.fit(X_train, y_train)\n+    probs_multinomial = lr_multinomial.predict_proba(X_test)\n+\n+    coefs = lr_multinomial.coef_\n+    intercept = lr_multinomial.intercept_\n+\n+    decision_function = X_test.dot(coefs.T) + intercept\n+    computed_probs = extmath.softmax(decision_function)\n+\n+    # Assert that predict_proba gives the same results as manually computed softmax probabilities\n+    assert_array_almost_equal(probs_multinomial, computed_probs, decimal=4)\n+\n+def test_logistic_regressioncv_ovr_predict_proba():\n+    # Test that LogisticRegressionCV with One-vs-Rest yields different probabilities than multinomial\n+    X, y = make_classification(n_samples=100, n_features=5, n_classes=3, n_informative=3, random_state=0)\n+    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n+\n+    lr_ovr = LogisticRegression(multi_class='ovr', solver='lbfgs')\n+    lr_ovr.fit(X_train, y_train)\n+    probs_ovr = lr_ovr.predict_proba(X_test)\n+\n+    lr_multinomial = LogisticRegression(multi_class='multinomial', solver='lbfgs')\n+    lr_multinomial.fit(X_train, y_train)\n+    probs_multinomial = lr_multinomial.predict_proba(X_test)\n+\n+    # Assert that multinomial and ovR approaches give different probability outputs\n+    assert not np.array_equal(probs_ovr, probs_multinomial)\n+\n+def test_logistic_regressioncv_neg_log_loss_multinomial():\n+    # Test that LogisticRegressionCV computes neg_log_loss with multinomial correctly\n+    X, y = make_classification(n_samples=100, n_features=5, n_classes=3, n_informative=3, random_state=0)\n+    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n+\n+    lr_multinomial = LogisticRegression(multi_class='multinomial', solver='lbfgs')\n+    lr_multinomial.fit(X_train, y_train)\n+    probs_multinomial = lr_multinomial.predict_proba(X_test)\n \n-def test_multinomial_logistic_regression_string_inputs():\n+    # Compute neg_log_loss with truth labels and probabilities\n+    neg_log_loss_value = -log_loss(y_test, probs_multinomial)\n+    assert neg_log_loss_value < 0, \"Negative log loss should be negative\"\n     # Test with string labels for LogisticRegression(CV)\n     n_samples, n_features, n_classes = 50, 5, 3\n     X_ref, y = make_classification(n_samples=n_samples, n_features=n_features,\n",
  "scikit-learn__scikit-learn-12585": "diff --git a/sklearn/tests/test_base.py b/sklearn/tests/test_base.py\nindex 4752f9c..bae4e4c 100644\n--- a/sklearn/tests/test_base.py\n+++ b/sklearn/tests/test_base.py\n@@ -154,6 +154,18 @@ def test_clone_nan():\n     assert clf.empty is clf2.empty\n \n \n+from sklearn.base import BaseEstimator, clone\n+\n+class MyEstimator(BaseEstimator):\n+    def __init__(self, empty=None):\n+        self.empty = empty\n+\n+def test_clone_estimator_types():\n+    # Check that clone works for parameters that are types rather than instances\n+    clf = MyEstimator(empty=MyEstimator)\n+    clf2 = clone(clf)\n+    assert clf.empty is clf2.empty\n+\n def test_clone_sparse_matrices():\n     sparse_matrix_classes = [\n         getattr(sp, name)\n",
  "scikit-learn__scikit-learn-12973": "",
  "scikit-learn__scikit-learn-13124": "",
  "scikit-learn__scikit-learn-13135": "diff --git a/sklearn/preprocessing/tests/test_discretization.py b/sklearn/preprocessing/tests/test_discretization.py\nindex a18a1c5..a48692c 100644\n--- a/sklearn/preprocessing/tests/test_discretization.py\n+++ b/sklearn/preprocessing/tests/test_discretization.py\n@@ -184,12 +184,20 @@ def test_invalid_strategy_option():\n                          est.fit, X)\n \n \n+from sklearn.utils._testing import assert_array_equal\n+from sklearn.preprocessing import KBinsDiscretizer\n+import numpy as np\n+import pytest\n+\n @pytest.mark.parametrize(\n-    'strategy, expected_2bins, expected_3bins',\n-    [('uniform', [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 2, 2]),\n-     ('kmeans', [0, 0, 0, 0, 1, 1], [0, 0, 1, 1, 2, 2]),\n-     ('quantile', [0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 2, 2])])\n-def test_nonuniform_strategies(strategy, expected_2bins, expected_3bins):\n+    'strategy, expected_2bins, expected_3bins, expected_5bins',\n+    [('uniform', [0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 2, 2], [0, 0, 1, 1, 4, 4]),\n+     ('kmeans', [0, 0, 0, 0, 1, 1], [0, 0, 1, 1, 2, 2], [0, 0, 1, 2, 3, 4]),\n+     ('quantile', [0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 2, 2], [0, 1, 2, 3, 4, 4])])\n+def test_nonuniform_strategies(strategy, expected_2bins, expected_3bins, expected_5bins):\n+    X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)\n+\n+    # with 2 bins\n     X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)\n \n     # with 2 bins\n@@ -202,6 +210,16 @@ def test_nonuniform_strategies(strategy, expected_2bins, expected_3bins):\n     Xt = est.fit_transform(X)\n     assert_array_equal(expected_3bins, Xt.ravel())\n \n+    # with 5 bins\n+    est = KBinsDiscretizer(n_bins=5, strategy=strategy, encode='ordinal')\n+    Xt = est.fit_transform(X)\n+    assert_array_equal(expected_2bins, Xt.ravel())\n+\n+    # with 3 bins\n+    est = KBinsDiscretizer(n_bins=3, strategy=strategy, encode='ordinal')\n+    Xt = est.fit_transform(X)\n+    assert_array_equal(expected_3bins, Xt.ravel())\n+\n \n @pytest.mark.parametrize('strategy', ['uniform', 'kmeans', 'quantile'])\n @pytest.mark.parametrize('encode', ['ordinal', 'onehot', 'onehot-dense'])\n",
  "scikit-learn__scikit-learn-13142": "",
  "scikit-learn__scikit-learn-13328": "",
  "scikit-learn__scikit-learn-13439": "diff --git a/sklearn/pipeline.py b/sklearn/pipeline.py\nindex 4594f40..e1dbdfa 100644\n--- a/sklearn/pipeline.py\n+++ b/sklearn/pipeline.py\n@@ -131,6 +131,10 @@ class Pipeline(_BaseComposition):\n         self._validate_steps()\n         self.memory = memory\n \n+    def __len__(self):\n+        \"\"\"Return the number of steps in the pipeline.\"\"\"\n+        return len(self.steps)\n+\n     def get_params(self, deep=True):\n         \"\"\"Get parameters for this estimator.\n \n",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..9c5dc7f 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -8,6 +9,7 @@ Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \n import pytest\n \n+from sklearn.ensemble import IsolationForest\n import numpy as np\n \n from sklearn.utils.testing import assert_array_equal\n@@ -15,7 +17,7 @@ from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_raises\n from sklearn.utils.testing import assert_raises_regex\n from sklearn.utils.testing import assert_warns_message\n-from sklearn.utils.testing import assert_equal\n+from sklearn.utils.validation import check_random_state\n from sklearn.utils.testing import assert_greater\n from sklearn.utils.testing import ignore_warnings\n from sklearn.utils.testing import assert_allclose\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..1e18a08 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -497,8 +497,31 @@ def test_transform():\n         ('lr', clf1), ('rf', clf2), ('gnb', clf3)],\n         voting='soft',\n         flatten_transform=False).fit(X, y)\n-\n-    assert_array_equal(eclf1.transform(X).shape, (4, 6))\n+from sklearn.ensemble import VotingClassifier, VotingRegressor\n+from sklearn.linear_model import LogisticRegression\n+from sklearn.ensemble import RandomForestClassifier\n+import pytest\n+import numpy as np\n+from sklearn.datasets import load_iris, make_regression\n+\n+# Test to ensure VotingClassifier handles None estimator with weights correctly\n+@pytest.mark.parametrize(\n+    \"X, y, voter\",\n+    [(load_iris(return_X_y=True)[0], load_iris(return_X_y=True)[1], VotingClassifier(\n+        estimators=[('lr', LogisticRegression()),\n+                    ('rf', RandomForestClassifier(n_estimators=5))])),\n+     (make_regression(n_samples=50, n_features=4, noise=0.1)[0],\n+      make_regression(n_samples=50, n_features=4, noise=0.1)[1], VotingRegressor(\n+         estimators=[('lr', LinearRegression()),\n+                     ('rf', RandomForestRegressor(n_estimators=5))]))]\n+)\n+def test_none_estimator_with_weights(X, y, voter):\n+    # Check that an estimator can be set to None and passing some weight\n+    voter.fit(X, y, sample_weight=np.ones(y.shape[0]))\n+    voter.set_params(lr=None)\n+    voter.fit(X, y, sample_weight=np.ones(y.shape[0]))\n+    y_pred = voter.predict(X)\n+    assert y_pred.shape == y.shape\n     assert_array_equal(eclf2.transform(X).shape, (4, 6))\n     assert_array_equal(eclf3.transform(X).shape, (3, 4, 2))\n     assert_array_almost_equal(eclf1.transform(X),\n@@ -506,4 +529,4 @@ def test_transform():\n     assert_array_almost_equal(\n             eclf3.transform(X).swapaxes(0, 1).reshape((4, 6)),\n             eclf2.transform(X)\n-    )\n+    )\n",
  "scikit-learn__scikit-learn-14053": "diff --git a/sklearn/tree/tests/test_export.py b/sklearn/tree/tests/test_export.py\nindex 50eb697..82f0455 100644\n--- a/sklearn/tree/tests/test_export.py\n+++ b/sklearn/tree/tests/test_export.py\n@@ -328,6 +328,25 @@ def test_export_text_errors():\n                          export_text, clf, spacing=0)\n \n \n+def test_export_single_feature():\n+    # Test for export_text to handle a decision tree with a single feature\n+    X_single = [[-2], [-1], [-1], [1], [1], [2]]\n+    y_single = [-1, -1, -1, 1, 1, 1]\n+    \n+    clf_single = DecisionTreeClassifier(max_depth=2, random_state=0)\n+    clf_single.fit(X_single, y_single)\n+    \n+    expected_report_single = dedent(\"\"\"\n+    |--- first <= 0.00\n+    |   |--- class: -1\n+    |--- first >  0.00\n+    |   |--- class: 1\n+    \"\"\").lstrip()\n+    \n+    assert export_text(clf_single, feature_names=['first']) == expected_report_single\n+    assert export_text(clf_single, feature_names=['first'], show_weights=True) == expected_report_single\n+\n+\n def test_export_text():\n     clf = DecisionTreeClassifier(max_depth=2, random_state=0)\n     clf.fit(X, y)\n",
  "scikit-learn__scikit-learn-14087": "diff --git a/sklearn/linear_model/tests/test_logistic.py b/sklearn/linear_model/tests/test_logistic.py\nindex 2a87dbf..9ec4d6c 100644\n--- a/sklearn/linear_model/tests/test_logistic.py\n+++ b/sklearn/linear_model/tests/test_logistic.py\n@@ -1532,6 +1532,35 @@ def test_LogisticRegressionCV_GridSearchCV_elastic_net_ovr():\n     assert (lrcv.predict(X_test) == gs.predict(X_test)).mean() >= .8\n \n \n+import pytest\n+import numpy as np\n+from sklearn.linear_model import LogisticRegressionCV\n+from sklearn.datasets import make_classification\n+\n+@pytest.mark.parametrize('penalty', ('l2', 'elasticnet'))\n+@pytest.mark.parametrize('multi_class', ('ovr', 'multinomial', 'auto'))\n+def test_LogisticRegressionCV_no_refit(penalty, multi_class):\n+    # Additional test to cover more variations of penalties and multi_class settings\n+\n+    n_classes = 3\n+    n_features = 20\n+    X, y = make_classification(n_samples=200, n_classes=n_classes,\n+                               n_informative=n_classes, n_features=n_features,\n+                               random_state=0)\n+\n+    Cs = np.logspace(-4, 4, 3)\n+    l1_ratios = np.linspace(0, 1, 2) if penalty == 'elasticnet' else None\n+\n+    lrcv = LogisticRegressionCV(penalty=penalty, Cs=Cs, solver='saga',\n+                                l1_ratios=l1_ratios, random_state=0,\n+                                multi_class=multi_class, refit=False)\n+    lrcv.fit(X, y)\n+    assert lrcv.C_.shape == (n_classes,)\n+    if penalty == 'elasticnet':\n+        assert lrcv.l1_ratio_.shape == (n_classes,)\n+    assert lrcv.coef_.shape == (n_classes, n_features)\n+\n+# Original existing test case\n @pytest.mark.parametrize('multi_class', ('ovr', 'multinomial'))\n def test_LogisticRegressionCV_no_refit(multi_class):\n     # Test LogisticRegressionCV attribute shapes when refit is False\n",
  "scikit-learn__scikit-learn-14141": "diff --git a/sklearn/utils/tests/test_show_versions.py b/sklearn/utils/tests/test_show_versions.py\nindex fa39255..4906c01 100644\n--- a/sklearn/utils/tests/test_show_versions.py\n+++ b/sklearn/utils/tests/test_show_versions.py\n@@ -12,6 +12,8 @@ def test_get_sys_info():\n     assert 'machine' in sys_info\n \n \n+import joblib\n+\n def test_get_deps_info():\n     deps_info = _get_deps_info()\n \n@@ -23,11 +25,17 @@ def test_get_deps_info():\n     assert 'Cython' in deps_info\n     assert 'pandas' in deps_info\n     assert 'matplotlib' in deps_info\n+    assert 'joblib' in deps_info\n+\n \n+def test_show_versions_with_joblib(capsys):\n+    show_versions()\n+    out, err = capsys.readouterr()\n+    assert 'joblib' in out\n \n def test_show_versions_with_blas(capsys):\n     show_versions()\n     out, err = capsys.readouterr()\n     assert 'python' in out\n     assert 'numpy' in out\n-    assert 'BLAS' in out\n+    assert 'BLAS' in out\n",
  "scikit-learn__scikit-learn-14496": "diff --git a/sklearn/cluster/tests/test_optics.py b/sklearn/cluster/tests/test_optics.py\nindex 6c9dac3..b6306ef 100644\n--- a/sklearn/cluster/tests/test_optics.py\n+++ b/sklearn/cluster/tests/test_optics.py\n@@ -78,6 +78,27 @@ def test_the_extract_xi_labels(ordering, clusters, expected):\n     assert_array_equal(labels, expected)\n \n \n+def test_float_min_samples():\n+    # Prepare random state and datasets\n+    rng = np.random.RandomState(0)\n+    n_points_per_cluster = 5\n+\n+    C1 = [-5, -2] + .8 * rng.randn(n_points_per_cluster, 2)\n+    C2 = [4, -1] + .1 * rng.randn(n_points_per_cluster, 2)\n+    C3 = [1, -2] + .2 * rng.randn(n_points_per_cluster, 2)\n+\n+    X = np.vstack((C1, C2, C3))\n+    expected_labels = np.r_[[0] * 5, [1] * 5, [2] * 5]\n+    X, expected_labels = shuffle(X, expected_labels, random_state=rng)\n+\n+    # Test with float min_samples\n+    clust = OPTICS(min_samples=0.1, min_cluster_size=0.2, max_eps=20, cluster_method='xi', xi=0.4).fit(X)\n+    assert_array_equal(clust.labels_, expected_labels)\n+\n+    # Check minimum size is at least 2 when using fractions\n+    n_samples = len(X)\n+    assert clust.min_samples_ == max(2, int(round(0.1 * n_samples)))\n+\n def test_extract_xi():\n     # small and easy test (no clusters around other clusters)\n     # but with a clear noise data.\n",
  "scikit-learn__scikit-learn-14710": "",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..845548f 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -680,6 +680,27 @@ def test_unicode_kernel():\n                                 random_seed=0)\n \n \n+# Import necessary packages for testing\n+import numpy as np\n+from scipy import sparse\n+from sklearn import svm\n+\n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for the issue involving ZeroDivisionError in _sparse_fit\n+    X_train = sparse.csr_matrix([\n+        [0, 1, 0, 0],\n+        [0, 0, 0, 1],\n+        [0, 0, 1, 0],\n+        [0, 0, 0, 1]\n+    ])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear', C=316.227766017, gamma=1.0, max_iter=15000, epsilon=0.1)\n+    model.fit(X_train, y_train)\n+    # Check if support_vectors_ and dual_coef_ are correctly set to empty\n+    assert model.support_vectors_.shape[0] == 0, \"Support vectors are not empty as expected.\"\n+    assert model.dual_coef_.shape[1] == 0, \"Dual coefficients are not empty as expected.\"\n+\n+\n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n     sparse_gram = sparse.csr_matrix([[1, 0], [0, 1]])\n",
  "scikit-learn__scikit-learn-14983": "",
  "scikit-learn__scikit-learn-15100": "diff --git a/sklearn/feature_extraction/tests/test_text.py b/sklearn/feature_extraction/tests/test_text.py\nindex 96ea20a..a7619f6 100644\n--- a/sklearn/feature_extraction/tests/test_text.py\n+++ b/sklearn/feature_extraction/tests/test_text.py\n@@ -97,6 +97,33 @@ def test_strip_accents():\n     expected = 'this is a test'\n     assert strip_accents_unicode(a) == expected\n \n+def test_strip_accents_nfkd():\n+    from sklearn.feature_extraction.text import strip_accents_unicode\n+\n+    # This string contains one code point, \"LATIN SMALL LETTER N WITH TILDE\"\n+    s1 = chr(241)  # \u00f1\n+    # This string contains two code points, \"LATIN SMALL LETTER N\" followed by \"COMBINING TILDE\"\n+    s2 = chr(110) + chr(771)  # n\u0303\n+\n+    # They are visually identical\n+    assert s1 != s2\n+    assert strip_accents_unicode(s1) == 'n'\n+    assert strip_accents_unicode(s2) == 'n'\n+\n+    # additional decomposition and combination checks\n+    a = \"o\\u0308\"  # o with diaeresis in decomposed form\n+    expected = \"o\"\n+    assert strip_accents_unicode(a) == expected\n+\n+    # combining marks by themselves\n+    a = \"\\u0300\\u0301\\u0302\\u0303\"  # various combining marks\n+    expected = \"\"\n+    assert strip_accents_unicode(a) == expected\n+\n+    # multiple combining marks on one character in decomposed form\n+    a = \"o\\u0308\\u0304\"  # o with diaeresis and macron\n+    expected = \"o\"\n+    assert strip_accents_unicode(a) == expected\n \n def test_to_ascii():\n     # check some classical latin accentuated symbols\n",
  "scikit-learn__scikit-learn-25102": "diff --git a/sklearn/feature_selection/tests/test_feature_select.py b/sklearn/feature_selection/tests/test_feature_select.py\nindex 1bc044a..0dd892d 100644\n--- a/sklearn/feature_selection/tests/test_feature_select.py\n+++ b/sklearn/feature_selection/tests/test_feature_select.py\n@@ -943,4 +943,28 @@ def test_mutual_info_regression():\n     support = univariate_filter.get_support()\n     gtruth = np.zeros(10)\n     gtruth[:2] = 1\n-    assert_array_equal(support, gtruth)\n+    assert_array_equal(support, gtruth)\n+\n+\n+def test_selectkbest_output_dataframe_dtypes():\n+    \"\"\"Test SelectKBest transformer to ensure it preserves input dataframe dtypes.\"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+\n+    X, y = load_iris(return_X_y=True, as_frame=True)\n+    # Set specific dtypes to columns to check if they are preserved\n+    X = X.astype(\n+        {\n+            \"sepal length (cm)\": np.float16,\n+            \"sepal width (cm)\": np.float64,\n+        }\n+    )\n+    X[\"species\"] = y.astype(\"category\")\n+\n+    # Add another feature to match the previous example in the issue scenario.\n+    selector = SelectKBest(chi2, k=2).set_output(transform=\"pandas\")\n+    X_out = selector.fit_transform(X, y)\n+\n+    # The output should maintain the same dtypes as the input for the selected features\n+    expected_dtypes = {\"sepal length (cm)\": np.float16, \"species\": \"category\"}\n+    for col in X_out.columns:\n+        assert X_out.dtypes[col] == expected_dtypes[col]\n",
  "scikit-learn__scikit-learn-25232": "diff --git a/sklearn/impute/tests/test_impute.py b/sklearn/impute/tests/test_impute.py\nindex ee482a8..f5b2a27 100644\n--- a/sklearn/impute/tests/test_impute.py\n+++ b/sklearn/impute/tests/test_impute.py\n@@ -1513,6 +1513,11 @@ def test_iterative_imputer_keep_empty_features(initial_strategy):\n     \"\"\"Check the behaviour of the iterative imputer with different initial strategy\n     and keeping empty features (i.e. features containing only missing values).\n     \"\"\"\n+    import numpy as np\n+    from sklearn.impute import IterativeImputer\n+    from sklearn.utils._testing import assert_array_equal\n+    import pytest\n+\n     X = np.array([[1, np.nan, 2], [3, np.nan, np.nan]])\n \n     imputer = IterativeImputer(\n@@ -1527,6 +1532,11 @@ def test_iterative_imputer_keep_empty_features(initial_strategy):\n @pytest.mark.parametrize(\"keep_empty_features\", [True, False])\n def test_knn_imputer_keep_empty_features(keep_empty_features):\n     \"\"\"Check the behaviour of `keep_empty_features` for `KNNImputer`.\"\"\"\n+    import numpy as np\n+    from sklearn.impute import IterativeImputer\n+    from sklearn.utils._testing import assert_array_equal\n+    import pytest\n+\n     X = np.array([[1, np.nan, 2], [3, np.nan, np.nan]])\n \n     imputer = KNNImputer(keep_empty_features=keep_empty_features)\n",
  "scikit-learn__scikit-learn-25931": "",
  "scikit-learn__scikit-learn-25973": "",
  "scikit-learn__scikit-learn-26323": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex b52e888..f4196e4 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -21,6 +21,10 @@ from sklearn.compose import (\n )\n from sklearn.exceptions import NotFittedError\n from sklearn.preprocessing import FunctionTransformer\n+from sklearn.feature_selection import VarianceThreshold\n+import pandas as pd\n+import pytest\n+import numpy as np\n from sklearn.preprocessing import StandardScaler, Normalizer, OneHotEncoder\n \n \n",
  "scikit-learn__scikit-learn-9288": "diff --git a/sklearn/cluster/tests/test_k_means.py b/sklearn/cluster/tests/test_k_means.py\nindex abeeff0..cebb683 100644\n--- a/sklearn/cluster/tests/test_k_means.py\n+++ b/sklearn/cluster/tests/test_k_means.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Testing for K-means\"\"\"\n import sys\n \n@@ -945,6 +946,29 @@ def test_k_means_empty_cluster_relocated():\n     assert_allclose(km.cluster_centers_, [[-1], [1]])\n \n \n+def test_result_of_kmeans_equal_in_diff_n_jobs():\n+    # Check if inertia and labels are the same for different n_jobs\n+    \n+    from sklearn.cluster import KMeans\n+    from sklearn.datasets import make_blobs\n+\n+    # Generate some data\n+    X, _ = make_blobs(n_samples=1000, centers=10, n_features=2, random_state=2)\n+\n+    # Fit KMeans with n_jobs=1\n+    kmeans_1 = KMeans(n_clusters=10, random_state=2, n_jobs=1, n_init=1)\n+    kmeans_1.fit(X)\n+    \n+    # Check results with n_jobs > 1\n+    for n_jobs in range(2, 5):\n+        kmeans_parallel = KMeans(n_clusters=10, random_state=2, n_jobs=n_jobs, n_init=1)\n+        kmeans_parallel.fit(X)\n+        \n+        assert_array_equal(kmeans_1.labels_, kmeans_parallel.labels_, \n+                           f\"Labels differ for n_jobs={n_jobs}\")\n+        assert_almost_equal(kmeans_1.inertia_, kmeans_parallel.inertia_, \n+                            decimal=5, err_msg=f\"Inertia differs for n_jobs={n_jobs}\")\n+\n def test_minibatch_kmeans_partial_fit_int_data():\n     # Issue GH #14314\n     X = np.array([[-1], [1]], dtype=np.int)\n",
  "sphinx-doc__sphinx-10323": "diff --git a/tests/test_directive_code.py b/tests/test_directive_code.py\nindex 949c70e..45dd003 100644\n--- a/tests/test_directive_code.py\n+++ b/tests/test_directive_code.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Test the code-block directive.\"\"\"\n \n import os\n@@ -250,9 +251,22 @@ def test_LiteralIncludeReader_dedent(literal_inc_path):\n                        \"    pass\\n\"\n                        \"\\n\")\n \n-\n @pytest.mark.xfail(os.name != 'posix', reason=\"Not working on windows\")\n-def test_LiteralIncludeReader_tabwidth(testroot):\n+def test_LiteralIncludeReader_dedent_and_prepend_with_indentation(literal_inc_path):\n+    # dedent: 5, prepend with intended indent\n+    options = {\n+        'lines': '13-16',\n+        'dedent': 5,\n+        'prepend': '      <plugin>',\n+        'append': '</plugin>'\n+    }\n+    reader = LiteralIncludeReader(literal_inc_path, options, DUMMY_CONFIG)\n+    content, lines = reader.read()\n+    assert content == (\"      <plugin>\\n\"\n+                       \"        <groupId>com.github.ekryd.sortpom</groupId>\\n\"\n+                       \"        <artifactId>sortpom-maven-plugin</artifactId>\\n\"\n+                       \"        <version>2.15.0</version>\\n\"\n+                       \"</plugin>\\n\")\n     # tab-width: 4\n     options = {'tab-width': 4, 'pyobject': 'Qux'}\n     reader = LiteralIncludeReader(testroot / 'target.py', options, DUMMY_CONFIG)\n",
  "sphinx-doc__sphinx-10449": "",
  "sphinx-doc__sphinx-10466": "diff --git a/tests/test_build_gettext.py b/tests/test_build_gettext.py\nindex a6fc946..93a2e94 100644\n--- a/tests/test_build_gettext.py\n+++ b/tests/test_build_gettext.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Test the build process with gettext builder with the test root.\"\"\"\n \n import gettext\n@@ -9,6 +10,58 @@ from subprocess import PIPE, CalledProcessError\n import pytest\n \n from sphinx.util.osutil import cd\n+from sphinx.builders.gettext import Catalog, MsgOrigin\n+\n+def test_Catalog_duplicated_message():\n+    catalog = Catalog()\n+    catalog.add('hello', MsgOrigin('/path/to/file', 10))\n+    catalog.add('hello', MsgOrigin('/path/to/file', 10))\n+    catalog.add('hello', MsgOrigin('/path/to/other', 20))\n+\n+    # Check that 'hello' is in the catalog exactly once\n+    assert len(list(catalog)) == 1\n+\n+    # Extract the message from the catalog\n+    message = list(catalog)[0]\n+    assert message.text == 'hello'\n+\n+    # Check locations are not duplicated\n+    assert set(message.locations) == {('/path/to/file', 10), ('/path/to/other', 20)}\n+\n+def test_Catalog_no_duplicate_message():\n+    catalog = Catalog()\n+    catalog.add('world', MsgOrigin('/path/to/file', 1))\n+    catalog.add('world', MsgOrigin('/path/to/other', 2))\n+\n+    # Check that 'world' is in the catalog exactly once\n+    assert len(list(catalog)) == 1\n+\n+    # Extract the message from the catalog\n+    message = list(catalog)[0]\n+    assert message.text == 'world'\n+\n+    # Check locations recorded\n+    assert set(message.locations) == {('/path/to/file', 1), ('/path/to/other', 2)}\n+\n+def test_Catalog_single_message_single_location():\n+    catalog = Catalog()\n+    catalog.add('single', MsgOrigin('/path/to/single', 1))\n+\n+    # Check that 'single' is in the catalog exactly once\n+    assert len(list(catalog)) == 1\n+\n+    # Extract the message from the catalog\n+    message = list(catalog)[0]\n+    assert message.text == 'single'\n+\n+    # Check single location is recorded\n+    assert set(message.locations) == {('/path/to/single', 1)}\n+\n+def test_Catalog_empty():\n+    catalog = Catalog()\n+\n+    # The catalog should be empty\n+    assert len(list(catalog)) == 0\n \n \n @pytest.mark.sphinx('gettext', srcdir='root-gettext')\n",
  "sphinx-doc__sphinx-10673": "diff --git a/tests/test_environment_toctree.py b/tests/test_environment_toctree.py\nindex d3bf6a2..5a725fb 100644\n--- a/tests/test_environment_toctree.py\n+++ b/tests/test_environment_toctree.py\n@@ -336,13 +336,47 @@ def test_get_toctree_for_includehidden(app):\n                 ([list_item, compact_paragraph, reference, \"quux\"],\n                  [list_item, compact_paragraph, reference, \"foo.1\"],\n                  [list_item, compact_paragraph, reference, \"foo.2\"]))\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+from sphinx import addnodes\n+from sphinx.util.docutils import assert_node\n \n+@pytest.mark.sphinx('dummy', testroot='toctree-index')\n+def test_toctree_with_indices(app: SphinxTestApp):\n+    app.build()\n+    toctree = app.env.tocs['index']\n+    assert_node(toctree,\n+                [addnodes.toctree,\n+                 {\n+                     'entries': [\n+                         (None, 'genindex'),\n+                         (None, 'modindex'),\n+                         (None, 'search')\n+                     ]\n+                 }])\n     assert_node(toctree[1][0][0][0], reference, refuri=\"foo\", secnumber=[1])\n     assert_node(toctree[1][0][1][0][0][0], reference, refuri=\"quux\", secnumber=[1, 1])\n     assert_node(toctree[1][0][1][1][0][0], reference, refuri=\"foo#foo-1\", secnumber=[1, 2])\n     assert_node(toctree[1][0][1][2][0][0], reference, refuri=\"foo#foo-2\", secnumber=[1, 3])\n     assert_node(toctree[1][1][0][0], reference, refuri=\"bar\", secnumber=[2])\n     assert_node(toctree[1][2][0][0], reference, refuri=\"http://sphinx-doc.org/\")\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+from sphinx import addnodes\n+from sphinx.util.docutils import assert_node\n \n+@pytest.mark.sphinx('dummy', testroot='toctree-index')\n+def test_toctree_with_indices(app: SphinxTestApp):\n+    app.build()\n+    toctree = app.env.tocs['index']\n+    assert_node(toctree,\n+                [addnodes.toctree,\n+                 {\n+                     'entries': [\n+                         (None, 'genindex'),\n+                         (None, 'modindex'),\n+                         (None, 'search')\n+                     ]\n+                 }])\n     assert_node(toctree[2],\n-                [bullet_list, list_item, compact_paragraph, reference, \"baz\"])\n+                [bullet_list, list_item, compact_paragraph, reference, \"baz\"])\n",
  "sphinx-doc__sphinx-7440": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 975a00f..d225969 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -95,6 +95,39 @@ def test_get_full_qualified_name():\n     assert domain.get_full_qualified_name(node) == 'ls.-l'\n \n \n+def test_glossary_case_sensitivity(app):\n+    text = (\".. glossary::\\n\"\n+            \"\\n\"\n+            \"   MySQL\\n\"\n+            \"       A popular open-source database management system.\\n\"\n+            \"\\n\"\n+            \"   mysql\\n\"\n+            \"       A command-line client for the MySQL database.\\n\")\n+\n+    # doctree\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (\n+        [glossary, definition_list, ([definition_list_item, ([term, (\"MySQL\",\n+                                                                     index)],\n+                                                             definition)],\n+                                     [definition_list_item, ([term, (\"mysql\",\n+                                                                     index)],\n+                                                             definition)])],\n+    ))\n+    assert_node(doctree[0][0][0][0][1],\n+                entries=[(\"single\", \"MySQL\", \"term-MySQL\", \"main\", None)])\n+    assert_node(doctree[0][0][0][1],\n+                [definition, nodes.paragraph, \"A popular open-source database management system.\"])\n+    assert_node(doctree[0][0][1][0][1],\n+                entries=[(\"single\", \"mysql\", \"term-mysql\", \"main\", None)])\n+    assert_node(doctree[0][0][1][1],\n+                [definition, nodes.paragraph, \"A command-line client for the MySQL database.\"])\n+\n+    # index\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert (\"MySQL\", \"MySQL\", \"term\", \"index\", \"term-MySQL\", -1) in objects\n+    assert (\"mysql\", \"mysql\", \"term\", \"index\", \"term-mysql\", -1) in objects\n+\n def test_glossary(app):\n     text = (\".. glossary::\\n\"\n             \"\\n\"\n@@ -146,6 +179,9 @@ def test_glossary(app):\n     assert (\"term2\", \"term2\", \"term\", \"index\", \"term-term2\", -1) in objects\n     assert (\"term3\", \"term3\", \"term\", \"index\", \"term-term3\", -1) in objects\n     assert (\"term4\", \"term4\", \"term\", \"index\", \"term-term4\", -1) in objects\n+    # Test for case sensitivity: terms \"MySQL\" and \"mysql\" should be distinct\n+    assert (\"MySQL\", \"MySQL\", \"term\", \"index\", \"term-MySQL\", -1) not in objects\n+    assert (\"mysql\", \"mysql\", \"term\", \"index\", \"term-mysql\", -1) not in objects\n \n \n def test_glossary_warning(app, status, warning):\n",
  "sphinx-doc__sphinx-7757": "diff --git a/tests/test_util_inspect.py b/tests/test_util_inspect.py\nindex b3053d1..494c7cb 100644\n--- a/tests/test_util_inspect.py\n+++ b/tests/test_util_inspect.py\n@@ -325,6 +325,15 @@ def test_signature_from_str_complex_annotations():\n \n def test_signature_from_str_kwonly_args():\n     sig = inspect.signature_from_str('(a, *, b)')\n+\n+def test_signature_from_str_positional_only_with_defaults():\n+    sig = inspect.signature_from_str('(a, b=0, /, c=1)')\n+    assert list(sig.parameters.keys()) == ['a', 'b', 'c']\n+    assert sig.parameters['a'].kind == Parameter.POSITIONAL_ONLY\n+    assert sig.parameters['b'].kind == Parameter.POSITIONAL_ONLY\n+    assert sig.parameters['b'].default == '0'\n+    assert sig.parameters['c'].kind == Parameter.POSITIONAL_OR_KEYWORD\n+    assert sig.parameters['c'].default == '1'\n     assert list(sig.parameters.keys()) == ['a', 'b']\n     assert sig.parameters['a'].kind == Parameter.POSITIONAL_OR_KEYWORD\n     assert sig.parameters['a'].default == Parameter.empty\n",
  "sphinx-doc__sphinx-7889": "diff --git a/tests/test_ext_autodoc_mock.py b/tests/test_ext_autodoc_mock.py\nindex 7302feb..36613f8 100644\n--- a/tests/test_ext_autodoc_mock.py\n+++ b/tests/test_ext_autodoc_mock.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_ext_autodoc_mock\n     ~~~~~~~~~~~~~~~~~~~~~\n@@ -15,6 +16,7 @@ from importlib import import_module\n import pytest\n \n from sphinx.ext.autodoc.mock import _MockModule, _MockObject, mock\n+from typing import TypeVar\n \n \n def test_MockModule():\n@@ -52,7 +54,20 @@ def test_MockObject():\n     assert isinstance(obj.other_method(), SubClass)\n \n \n-def test_mock():\n+def test_generic_typed_mock():\n+    # Test for handling generic-typed classes with mock objects\n+    T = TypeVar('T')\n+\n+    class GenericClass(mock.SomeClass[T]):\n+        \"\"\"docstring of GenericClass\"\"\"\n+\n+        def method(self):\n+            return \"generic string\"\n+\n+    obj = GenericClass()\n+    assert GenericClass.__doc__ == \"docstring of GenericClass\"\n+    assert isinstance(obj, GenericClass)\n+    assert obj.method() == \"generic string\"\n     modname = 'sphinx.unknown'\n     submodule = modname + '.submodule'\n     assert modname not in sys.modules\n",
  "sphinx-doc__sphinx-7910": "diff --git a/tests/test_ext_napoleon.py b/tests/test_ext_napoleon.py\nindex 0676869..6440484 100644\n--- a/tests/test_ext_napoleon.py\n+++ b/tests/test_ext_napoleon.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_napoleon\n     ~~~~~~~~~~~~~\n@@ -14,6 +15,7 @@ from collections import namedtuple\n from unittest import TestCase, mock\n \n from sphinx.application import Sphinx\n+from functools import wraps\n from sphinx.ext.napoleon import _process_docstring, _skip_member, Config, setup\n \n \n@@ -164,11 +166,35 @@ class SkipMemberTest(TestCase):\n         self.assertSkip('class', '__special_doc__',\n                         SampleClass.__special_doc__, False,\n                         'napoleon_include_special_with_doc')\n+    \n+    def test_decorated_init(self):\n+        \"\"\"Test that a decorated __init__ method appears in the documentation.\"\"\"\n+        class SampleDecoratedInit:\n+            @simple_decorator\n+            def __init__(self):\n+                \"\"\"SampleDecoratedInit.__init__.DOCSTRING\"\"\"\n+                pass\n+\n+        self.assertSkip('class', '__init__',\n+                        SampleDecoratedInit.__init__, False,\n+                        'napoleon_include_init_with_doc')\n \n     def test_class_special_undoc(self):\n         self.assertSkip('class', '__special_undoc__',\n                         SampleClass.__special_undoc__, True,\n                         'napoleon_include_special_with_doc')\n+    \n+    def test_decorated_init(self):\n+        \"\"\"Test that a decorated __init__ method appears in the documentation.\"\"\"\n+        class SampleDecoratedInit:\n+            @simple_decorator\n+            def __init__(self):\n+                \"\"\"SampleDecoratedInit.__init__.DOCSTRING\"\"\"\n+                pass\n+\n+        self.assertSkip('class', '__init__',\n+                        SampleDecoratedInit.__init__, False,\n+                        'napoleon_include_init_with_doc')\n \n     def test_exception_private_doc(self):\n         self.assertSkip('exception', '_private_doc',\n@@ -184,6 +210,18 @@ class SkipMemberTest(TestCase):\n         self.assertSkip('exception', '__special_doc__',\n                         SampleError.__special_doc__, False,\n                         'napoleon_include_special_with_doc')\n+    \n+    def test_decorated_init(self):\n+        \"\"\"Test that a decorated __init__ method appears in the documentation.\"\"\"\n+        class SampleDecoratedInit:\n+            @simple_decorator\n+            def __init__(self):\n+                \"\"\"SampleDecoratedInit.__init__.DOCSTRING\"\"\"\n+                pass\n+\n+        self.assertSkip('class', '__init__',\n+                        SampleDecoratedInit.__init__, False,\n+                        'napoleon_include_init_with_doc')\n \n     def test_exception_special_undoc(self):\n         self.assertSkip('exception', '__special_undoc__',\n",
  "sphinx-doc__sphinx-7985": "diff --git a/tests/test_build_linkcheck.py b/tests/test_build_linkcheck.py\nindex 5b1b2ed..d0a7e42 100644\n--- a/tests/test_build_linkcheck.py\n+++ b/tests/test_build_linkcheck.py\n@@ -13,9 +13,16 @@ import re\n from unittest import mock\n import pytest\n \n-\n @pytest.mark.sphinx('linkcheck', testroot='linkcheck', freshenv=True)\n-def test_defaults(app, status, warning):\n+def test_local_links(app, status, warning):\n+    app.builder.build_all()\n+\n+    assert (app.outdir / 'output.txt').exists()\n+    content = (app.outdir / 'output.txt').read_text()\n+\n+    # Test for checking local links\n+    assert \"-local-   doesntexist\" in content  # Check for broken local link logged\n+    assert len(content.splitlines()) >= 5  # Expecting additional line for local link\n     app.builder.build_all()\n \n     assert (app.outdir / 'output.txt').exists()\n",
  "sphinx-doc__sphinx-8035": "",
  "sphinx-doc__sphinx-8120": "diff --git a/tests/test_intl.py b/tests/test_intl.py\nindex 58339b1..317c7ff 100644\n--- a/tests/test_intl.py\n+++ b/tests/test_intl.py\n@@ -1287,5 +1287,46 @@ def test_image_glob_intl_using_figure_language_filename(app):\n                             'image/svg+xml': 'subdir/svgimg.svg'})\n \n \n-def getwarning(warnings):\n-    return strip_escseq(warnings.getvalue().replace(os.sep, '/'))\n+def test_issue_locale_translation_override(make_app, app_params, sphinx_test_tempdir):\n+    \"\"\"\n+    Test case for verifying if locale/<language>/LC_MESSAGES/sphinx.po translations\n+    are applied over the default translations.\n+    \"\"\"\n+    from sphinx import locale\n+    from babel.messages import pofile\n+    from babel.messages.catalog import Catalog\n+    \n+    try:\n+        # Clear any existing translators cache\n+        locale.translators.clear()\n+\n+        # Prepare message catalog (.po)\n+        locale_dir = sphinx_test_tempdir / 'basic' / 'locales' / 'da' / 'LC_MESSAGES'\n+        locale_dir.makedirs(exist_ok=True)\n+        \n+        with (locale_dir / 'sphinx.po').open('wb') as file:\n+            catalog = Catalog()\n+            # Custom translations for testing\n+            catalog.add('Fig. %s', 'Foobar %s')\n+            catalog.add('Listing %s', 'Whatever %s')\n+            pofile.write_po(file, catalog)\n+        \n+        # Construct application and convert po file to .mo\n+        args, kwargs = app_params\n+        kwargs.update({'confoverrides': {'language': 'da'}})\n+        \n+        app = make_app(*args, **kwargs)\n+        app.build()\n+\n+        # Ensure .mo file is generated\n+        assert (locale_dir / 'sphinx.mo').exists()\n+\n+        # Check if custom translations are applied\n+        content = (app.outdir / 'index.html').read_text()\n+        assert 'Foobar 1' in content\n+        assert 'Whatever 1' in content\n+    \n+    finally:\n+        # Clear cache to prevent interference with other tests\n+        locale.translators.clear()\n+    return strip_escseq(warnings.getvalue().replace(os.sep, '/'))\n",
  "sphinx-doc__sphinx-8269": "",
  "sphinx-doc__sphinx-8459": "diff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex d1881df..9bc7fc7 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_ext_autodoc_configs\n     ~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -8,6 +9,34 @@\n     :license: BSD, see LICENSE for details.\n \"\"\"\n \n+import sys\n+import pytest\n+\n+@pytest.mark.skipif(sys.version_info < (3, 7), reason='python 3.7+ is required.')\n+@pytest.mark.sphinx('text', testroot='ext-autodoc',\n+                   srcdir='autodoc_typehints_description_and_type_aliases',\n+                   confoverrides={'autodoc_typehints': 'description',\n+                                  'autodoc_type_aliases': {'JSONObject': 'types.JSONObject'}})\n+def test_autodoc_typehints_with_aliases(app):\n+    (app.srcdir / 'types.rst').write_text('.. autofunction:: types.sphinx_doc')\n+    app.build()\n+    content = (app.outdir / 'types.txt').read_text()\n+    assert ('types.sphinx_doc(data)\\n'\n+            '\\n'\n+            '   Does it work.\\n'\n+            '\\n'\n+            '   Parameters:\\n'\n+            '      * **data** (*types.JSONObject*) --\\n'\n+            '         Does it args.\\n'\n+            '\\n'\n+            '   Returns\\n'\n+            '   ------\\n'\n+            '   Does it work in return.\\n'\n+            '\\n'\n+            '   Return type\\n'\n+            '   ----------\\n'\n+            '   types.JSONObject\\n') in content\n+\n import platform\n import sys\n \n",
  "sphinx-doc__sphinx-8475": "diff --git a/tests/test_build_linkcheck.py b/tests/test_build_linkcheck.py\nindex 41632e7..571a1c0 100644\n--- a/tests/test_build_linkcheck.py\n+++ b/tests/test_build_linkcheck.py\n@@ -372,13 +372,90 @@ def test_connect_to_selfsigned_nonexistent_cert_file(app):\n     with https_server(OKHandler):\n         app.builder.build_all()\n \n+import pytest\n+import json\n+import http.server\n+from sphinx.testing.util import SphinxTestApp\n+from sphinx.util import requests\n+\n+@pytest.mark.sphinx('linkcheck', testroot='linkcheck-localserver', freshenv=True)\n+def test_TooManyRedirects_on_HEAD(app: SphinxTestApp):\n+    class InfiniteRedirectOnHeadHandler(http.server.BaseHTTPRequestHandler):\n+        def do_HEAD(self):\n+            self.send_response(302, \"Found\")\n+            self.send_header(\"Location\", \"http://localhost:7777/\")\n+            self.end_headers()\n+\n+        def do_GET(self):\n+            self.send_response(200, \"OK\")\n+            self.end_headers()\n+            self.wfile.write(b\"ok\\n\")\n+\n+    with http_server(InfiniteRedirectOnHeadHandler):\n+        app.builder.build_all()\n+\n     with open(app.outdir / 'output.json') as fp:\n         content = json.load(fp)\n     assert content == {\n         \"code\": 0,\n-        \"status\": \"broken\",\n+        \"status\": \"working\",\n         \"filename\": \"index.rst\",\n         \"lineno\": 1,\n-        \"uri\": \"https://localhost:7777/\",\n-        \"info\": \"Could not find a suitable TLS CA certificate bundle, invalid path: does/not/exist\",\n-    }\n+        \"uri\": \"http://localhost:7777/\",\n+        \"info\": \"\",\n+    }\n+\n+@pytest.mark.sphinx('linkcheck', testroot='linkcheck-localserver', freshenv=True)\n+def test_temporary_redirect_followup(app: SphinxTestApp):\n+    \"\"\"Test a temporary redirect (307) where GET should follow it.\"\"\"\n+    class TemporaryRedirectHandler(http.server.BaseHTTPRequestHandler):\n+        def do_HEAD(self):\n+            self.send_response(307, \"Temporary Redirect\")\n+            self.send_header(\"Location\", \"http://example.com/\")\n+            self.end_headers()\n+\n+        def do_GET(self):\n+            self.send_response(200, \"OK\")\n+            self.end_headers()\n+            self.wfile.write(b\"temporary redirect handled\\n\")\n+\n+    with http_server(TemporaryRedirectHandler):\n+        app.builder.build_all()\n+\n+    with open(app.outdir / 'output.json') as fp:\n+        content = json.load(fp)\n+    assert content == {\n+        \"code\": 0,\n+        \"status\": \"working\",\n+        \"filename\": \"index.rst\",\n+        \"lineno\": 1,\n+        \"uri\": \"http://localhost:7777/\",\n+        \"info\": \"\",\n+    }\n+\n+@pytest.mark.sphinx('linkcheck', testroot='linkcheck-localserver', freshenv=True)\n+def test_no_redirects_on_get(app: SphinxTestApp):\n+    \"\"\"Ensure that a URL with no redirects is reported working.\"\"\"\n+    class NoRedirectHandler(http.server.BaseHTTPRequestHandler):\n+        def do_HEAD(self):\n+            self.send_response(200, \"OK\")\n+            self.end_headers()\n+\n+        def do_GET(self):\n+            self.send_response(200, \"OK\")\n+            self.end_headers()\n+            self.wfile.write(b\"no redirect\\n\")\n+\n+    with http_server(NoRedirectHandler):\n+        app.builder.build_all()\n+\n+    with open(app.outdir / 'output.json') as fp:\n+        content = json.load(fp)\n+    assert content == {\n+        \"code\": 0,\n+        \"status\": \"working\",\n+        \"filename\": \"index.rst\",\n+        \"lineno\": 1,\n+        \"uri\": \"http://localhost:7777/\",\n+        \"info\": \"\",\n+    }\n",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..c00ab26 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -29,6 +29,18 @@ try:\n except ImportError:\n     pyximport = None\n \n+from .test_ext_autodoc import do_autodoc\n+\n+def test_empty_all_behavior(app):\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.empty_all', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.empty_all',\n+        '',\n+        'docsting of empty_all module.',\n+        '',\n+    ]\n \n def do_autodoc(app, objtype, name, options=None):\n     if options is None:\n",
  "sphinx-doc__sphinx-8721": "",
  "sphinx-doc__sphinx-9281": "diff --git a/tests/test_util_inspect.py b/tests/test_util_inspect.py\nindex 3c31d3d..437b22a 100644\n--- a/tests/test_util_inspect.py\n+++ b/tests/test_util_inspect.py\n@@ -515,6 +515,16 @@ def test_dict_customtype():\n     # Type is unsortable, just check that it does not crash\n     assert \"<CustomType(2)>: 2\" in description\n \n+def test_object_description_enum():\n+    import enum\n+    \n+    class MyEnum(enum.Enum):\n+        VALUE_A = 10\n+        VALUE_B = 20\n+\n+    assert inspect.object_description(MyEnum.VALUE_A) == \"MyEnum.VALUE_A\"\n+    assert inspect.object_description(MyEnum.VALUE_B) == \"MyEnum.VALUE_B\"\n+\n \n def test_getslots():\n     class Foo:\n",
  "sphinx-doc__sphinx-9320": "diff --git a/tests/test_quickstart.py b/tests/test_quickstart.py\nindex ff8df08..98f96f1 100644\n--- a/tests/test_quickstart.py\n+++ b/tests/test_quickstart.py\n@@ -10,6 +10,7 @@\n \n import time\n from io import StringIO\n+import sys\n \n import pytest\n \n",
  "sphinx-doc__sphinx-9367": "diff --git a/tests/test_pycode_ast.py b/tests/test_pycode_ast.py\nindex a3de258..285ce81 100644\n--- a/tests/test_pycode_ast.py\n+++ b/tests/test_pycode_ast.py\n@@ -54,6 +54,7 @@ from sphinx.pycode import ast\n     (\"- 1\", \"- 1\"),                             # UnaryOp\n     (\"- a\", \"- a\"),                             # USub\n     (\"(1, 2, 3)\", \"(1, 2, 3)\"),                   # Tuple\n+    (\"(1,)\", \"(1,)\"),                             # Tuple (single element)\n     (\"()\", \"()\"),                               # Tuple (empty)\n ])\n def test_unparse(source, expected):\n",
  "sphinx-doc__sphinx-9591": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex 29731ea..def308e 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -841,13 +841,33 @@ def test_pyproperty(app):\n                                                      [desc_name, \"prop2\"],\n                                                      [desc_annotation, \": str\"])],\n                                    [desc_content, ()]))\n-    assert 'Class.prop1' in domain.objects\n+    # Check for cross-references in property type annotation\n+    prop1_type_annotation = doctree[1][1][1][0][3]\n+    assert_node(prop1_type_annotation, pending_xref, refdomain='py', reftype='class', reftarget='str')\n     assert domain.objects['Class.prop1'] == ('index', 'Class.prop1', 'property', False)\n     assert 'Class.prop2' in domain.objects\n     assert domain.objects['Class.prop2'] == ('index', 'Class.prop2', 'property', False)\n \n \n-def test_pydecorator_signature(app):\n+def test_pyproperty_cross_references(app):\n+    text = (\".. py:class:: SampleClass\\n\"\n+            \"\\n\"\n+            \"   .. py:property:: cross_ref_property\\n\"\n+            \"      :type: Point\\n\"\n+            \"\\n\"\n+            \"   .. py:class:: Point\\n\"\n+            \"      :members:\\n\")\n+    domain = app.env.get_domain('py')\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (addnodes.index,\n+                          [desc, ([desc_signature, ([desc_annotation, \"class \"],\n+                                                    [desc_name, \"SampleClass\"])],\n+                                  [desc_content, (addnodes.index,\n+                                                  desc,\n+                                                  addnodes.index,\n+                                                  desc)])]))\n+    cross_ref_annotation = doctree[1][1][1][0][3]\n+    assert_node(cross_ref_annotation, pending_xref, refdomain='py', reftype='class', reftarget='Point')\n     text = \".. py:decorator:: deco\"\n     domain = app.env.get_domain('py')\n     doctree = restructuredtext.parse(app, text)\n",
  "sphinx-doc__sphinx-9698": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex 4731988..f9d58d9 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -754,12 +754,13 @@ def test_pymethod_options(app):\n     assert 'Class.meth4' in domain.objects\n     assert domain.objects['Class.meth4'] == ('index', 'Class.meth4', 'method', False)\n \n-    # :property:\n+    # :property: (Updated to check index entry without parentheses for properties)\n     assert_node(doctree[1][1][8], addnodes.index,\n-                entries=[('single', 'meth5() (Class property)', 'Class.meth5', '', None)])\n+                entries=[('single', 'meth5 (Class property)', 'Class.meth5', '', None)])\n     assert_node(doctree[1][1][9], ([desc_signature, ([desc_annotation, (\"property\", desc_sig_space)],\n-                                                     [desc_name, \"meth5\"])],\n-                                   [desc_content, ()]))\n+                                                     [desc_name, \"meth5\"],\n+                                                     [desc_parameterlist, ()])],\n+                                   [desc_content, ()]))  # Adjusted expecting parameter list for non-property methods\n     assert 'Class.meth5' in domain.objects\n     assert domain.objects['Class.meth5'] == ('index', 'Class.meth5', 'method', False)\n \n",
  "sphinx-doc__sphinx-9711": "",
  "sympy__sympy-11618": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 399f58e..9827d04 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -235,8 +235,36 @@ def test_Point2D():\n     assert p1.distance(p2) == sqrt(61)/2\n     assert p2.distance(p3) == sqrt(17)/2\n \n-\n-def test_issue_9214():\n+from sympy import sqrt\n+from sympy.geometry import Point2D, Point3D\n+\n+def test_issue_11617():\n+    p1 = Point3D(1, 0, 2)\n+    p2 = Point2D(2, 0)\n+    assert p1.distance(p2) == sqrt(5)\n+\n+def test_issue_11617_additional_cases():\n+    # Test with both points as 3D points\n+    p1 = Point3D(1, 0, 2)\n+    p2 = Point3D(2, 0, 0)\n+    assert p1.distance(p2) == sqrt(5)\n+\n+    # Test with both points as 2D points\n+    p1 = Point2D(1, 0)\n+    p2 = Point2D(4, 0)\n+    assert p1.distance(p2) == 3\n+\n+    # Test with mixed dimensions (2D to 3D)\n+    p3 = Point2D(4, 0)\n+    assert p2.distance(p3) == 2  # 2D to 2D\n+\n+    # More mixed dimension (3D to 2D and 2D to 3D)\n+    assert p2.distance(p1) == 2\n+    assert p3.distance(p1) == sqrt(10)\n+\n+    # Test with zero distances in higher dimensions\n+    p4 = Point3D(2, 0, 0)\n+    assert p4.distance(p2) == 0\n     p1 = Point3D(4, -2, 6)\n     p2 = Point3D(1, 2, 3)\n     p3 = Point3D(7, 2, 3)\n",
  "sympy__sympy-12096": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex 386dc7c..3cb327b 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -741,7 +741,16 @@ def test_special_printers():\n     assert isinstance(func1(), mpi)\n     assert isinstance(func2(), mpi)\n \n-def test_true_false():\n+from sympy.utilities.lambdify import implemented_function\n+from sympy import Float\n+\n+def test_issue_12092():\n+    f = implemented_function('f', lambda x: x**2)\n+    g = implemented_function('g', lambda x: 2 * x)\n+    assert f(f(2)).evalf() == Float(16)\n+    assert g(g(2)).evalf() == Float(8)\n+    assert f(g(2)).evalf() == Float(16)\n+    assert g(f(2)).evalf() == Float(8)\n     # We want exact is comparison here, not just ==\n     assert lambdify([], true)() is True\n     assert lambdify([], false)() is False\n",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..649d445 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -83,6 +83,10 @@ def test_Identity():\n     assert transpose(In) == In\n     assert In.inverse() == In\n     assert In.conjugate() == In\n+from sympy import Identity, MatrixSymbol, Sum, symbols\n+from sympy.abc import n\n+from sympy.assumptions import assuming\n+from sympy.assumptions import Q as Query\n \n def test_Identity_doit():\n     Inn = Identity(Add(n, n, evaluate=False))\n@@ -90,8 +94,24 @@ def test_Identity_doit():\n     assert Inn.doit() == Identity(2*n)\n     assert isinstance(Inn.doit().rows, Mul)\n \n+    # Additional test for the identity matrix sum issue\n+    i, j = symbols('i j', integer=True)\n+    In = Identity(n)\n+\n+    # Test: Sum of elements in an identity matrix should be n\n+    assert Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).doit() == n\n+\n+    # Test the behavior when instantiated with a specific size\n+    specific_n = 3\n+    In3 = Identity(specific_n)\n+    # Test: Specific example check\n+    assert Sum(Sum(In3[i, j], (i, 0, specific_n-1)), (j, 0, specific_n-1)).doit() == specific_n\n \n-def test_addition():\n+    # Reproduce behavior with assuming for orthogonal assumption\n+    M = MatrixSymbol('M', n, n)\n+    with assuming(Query.orthogonal(M)):\n+        e = refine((M.T * M).doit())\n+        assert Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit() == n\n     A = MatrixSymbol('A', n, m)\n     B = MatrixSymbol('B', n, m)\n \n",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..4ba40d2 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -330,6 +330,16 @@ def test_args():\n     assert p._array_form == [3, 2, 0, 1, 5, 4]\n     p = Permutation((0, 3, 1, 2))\n     assert p._cyclic_form is None\n+    \n+    # Additional test for non-disjoint cycles\n+    # Non-disjoint cycles should result in applying them left to right\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])  # Should be the identity permutation\n+    assert Permutation([[0, 1], [1, 0]]) == Permutation([0, 1])  # Should also be the identity permutation\n+    assert Permutation([[0, 2, 1], [0, 1]]) == Permutation([0, 1, 2])  # Both cycles lead to identity permutation\n+    assert Permutation([[0, 1, 2], [2, 0]]) == Permutation([1, 0, 2])  # The two cycles compose to swap 0 and 1\n+\n+    # The original test case\n+    assert Permutation([[0, 1], [0, 2]]) == Permutation(0, 1, 2)\n     assert p._array_form == [0, 3, 1, 2]\n     assert Permutation([0]) == Permutation((0, ))\n     assert Permutation([[0], [1]]) == Permutation(((0, ), (1, ))) == \\\n",
  "sympy__sympy-13031": "",
  "sympy__sympy-13372": "diff --git a/sympy/core/tests/test_evalf.py b/sympy/core/tests/test_evalf.py\nindex e95146a..2bae6fc 100644\n--- a/sympy/core/tests/test_evalf.py\n+++ b/sympy/core/tests/test_evalf.py\n@@ -170,9 +170,14 @@ def test_evalf_ramanujan():\n \n # Input that for various reasons have failed at some point\n \n-\n-def test_evalf_bugs():\n-    assert NS(sin(1) + exp(-10**10), 10) == NS(sin(1), 10)\n+from sympy import Mul, Max, Symbol\n+\n+# Tests for issue where UnboundLocalError was raised in evalf under certain conditions.\n+def test_issue_13076():\n+    x = Symbol('x')\n+    y = Symbol('y')\n+    assert NS(Mul(x, Max(0, y), evaluate=False).evalf()) == 'x*Max(0, y)'\n+    assert NS(Mul(Max(0, y), x, evaluate=False).evalf()) == 'x*Max(0, y)'\n     assert NS(exp(10**10) + sin(1), 10) == NS(exp(10**10), 10)\n     assert NS('log(1+1/10**50)', 20) == '1.0000000000000000000e-50'\n     assert NS('log(10**100,10)', 10) == '100.0000000'\n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..b4dd2b4 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -200,6 +200,19 @@ def test_tanh():\n \n     assert tanh(k*pi*I) == 0\n     assert tanh(17*k*pi*I) == 0\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+    assert e.subs(x, 2) == coth(log(tan(2)))\n+    assert e.subs(x, 3) == coth(log(tan(3)))\n+    assert e.subs(x, 5) == coth(log(tan(5)))\n+    assert e.subs(x, 6) == coth(log(tan(6)))\n+    assert e.subs(x, 8) == coth(log(tan(8)))\n+    assert e.subs(x, 9) == coth(log(tan(9)))\n+    assert e.subs(x, 11) == coth(log(tan(11)))\n+    assert e.subs(x, 12) == coth(log(tan(12)))\n+    assert e.subs(x, 13) == coth(log(tan(13)))\n+    assert e.subs(x, 15) == coth(log(tan(15)))\n+    assert e.subs(x, 18) == coth(log(tan(18)))\n \n     assert tanh(k*pi*I/2) == tan(k*pi/2)*I\n \n",
  "sympy__sympy-13615": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 6d534c0..60750a0 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -188,7 +188,23 @@ def test_Complement():\n     assert S.Reals - Union(S.Naturals, FiniteSet(pi)) == \\\n             Intersection(S.Reals - S.Naturals, S.Reals - FiniteSet(pi))\n \n-def test_complement():\n+from sympy import Symbol, FiniteSet, Complement, Interval, S, EmptySet, Union, pi\n+\n+def test_issue_12712():\n+    x = Symbol('x')\n+    y = Symbol('y')\n+    assert Complement(FiniteSet(x, y, 2), Interval(-10, 10)) == \\\n+        Complement(FiniteSet(x, y), Interval(-10, 10))\n+\n+    # Additional Test Cases\n+    assert Complement(FiniteSet(1, x, 3), Interval(-5, 5)) == \\\n+        Complement(FiniteSet(x), Interval(-5, 5), evaluate=False)\n+    \n+    assert Complement(FiniteSet(x, y, 5), Union(Interval(1, 4), FiniteSet(5))) == \\\n+        Complement(FiniteSet(x, y), Interval(1, 4), evaluate=False)\n+\n+    assert Complement(FiniteSet(0, 1, 2, x), Interval(-1, 1)) == \\\n+        Complement(FiniteSet(2, x), Interval(-1, 1))\n     assert Interval(0, 1).complement(S.Reals) == \\\n         Union(Interval(-oo, 0, True, True), Interval(1, oo, True, True))\n     assert Interval(0, 1, True, False).complement(S.Reals) == \\\n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..ab7842e 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -201,7 +201,50 @@ def test_col_insert():\n         l.insert(i, 4)\n         assert flatten(zeros_Shaping(3).col_insert(i, c4).row(0).tolist()) == l\n \n-def test_extract():\n+def test_issue_13643_col_insert():\n+    from sympy import Matrix, eye, ones\n+    # Reproducing the issue\n+    M = eye(6)  # 6x6 identity matrix\n+    V = 2 * ones(6, 2)  # 6x2 matrix of twos\n+    expected = Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    result = M.col_insert(3, V)\n+    assert result == expected, \"The column insertion did not produce the expected matrix.\"\n+\n+    # Additional test case with different sizes\n+    M2 = Matrix([[1, 2], [3, 4]])\n+    V2 = Matrix([[5], [6]])\n+    expected2 = Matrix([[1, 2, 5], [3, 4, 6]])\n+    result2 = M2.col_insert(2, V2)\n+    assert result2 == expected2, \"Column insertion into a smaller matrix failed.\"\n+\n+    # Edge case inserting at the start\n+    M3 = eye(3)\n+    V3 = ones(3, 1) * 9\n+    expected3 = Matrix([\n+        [9, 1, 0, 0],\n+        [9, 0, 1, 0],\n+        [9, 0, 0, 1]\n+    ])\n+    result3 = M3.col_insert(0, V3)\n+    assert result3 == expected3, \"Column insertion at the beginning failed.\"\n+\n+    # Edge case inserting at the end\n+    M4 = eye(3)\n+    V4 = ones(3, 1) * 7\n+    expected4 = Matrix([\n+        [1, 0, 0, 7],\n+        [0, 1, 0, 7],\n+        [0, 0, 1, 7]\n+    ])\n+    result4 = M4.col_insert(3, V4)\n+    assert result4 == expected4, \"Column insertion at the end failed.\"\n     m = ShapingOnlyMatrix(4, 3, lambda i, j: i*3 + j)\n     assert m.extract([0, 1, 3], [0, 1]) == Matrix(3, 2, [0, 1, 3, 4, 9, 10])\n     assert m.extract([0, 3], [0, 0, 2]) == Matrix(2, 3, [0, 0, 2, 9, 9, 11])\n",
  "sympy__sympy-13757": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex a463b22..8a2ebc6 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -665,8 +665,16 @@ def test_Poly_sub():\n def test_Poly_mul():\n     assert Poly(0, x).mul(Poly(0, x)) == Poly(0, x)\n     assert Poly(0, x) * Poly(0, x) == Poly(0, x)\n-\n-    assert Poly(2, x).mul(Poly(4, x)) == Poly(8, x)\n+from sympy import Poly, Symbol, S\n+\n+x = Symbol('x')\n+    \n+def test_issue_13079():\n+    assert Poly(x)*x == Poly(x**2, x, domain='ZZ')\n+    assert x*Poly(x) == Poly(x**2, x, domain='ZZ')\n+    assert -2*Poly(x) == Poly(-2*x, x, domain='ZZ')\n+    assert S(-2)*Poly(x) == Poly(-2*x, x, domain='ZZ')\n+    assert Poly(x)*S(-2) == Poly(-2*x, x, domain='ZZ')\n     assert Poly(2, x, y) * Poly(4, x) == Poly(8, x, y)\n     assert Poly(4, x).mul(Poly(2, x, y)) == Poly(8, x, y)\n     assert Poly(4, x, y) * Poly(2, x, y) == Poly(8, x, y)\n",
  "sympy__sympy-13798": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex b1f9614..93e5bac 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -54,6 +54,31 @@ def test_printmethod():\n             return \"foo\"\n     assert latex(R(x)) == \"foo\"\n \n+def test_latex_mul_symbol():\n+    from sympy import symbols\n+    x, y = symbols('x y')\n+    \n+    # Original test cases for fixed issue\n+    assert latex(3*x**2*y, mul_symbol=r'\\,') == r\"3\\,x^{2}\\,y\"\n+    assert latex(1.5*3**x, mul_symbol=r'\\,') == r\"1.5 \\cdot 3^{x}\"\n+    \n+    # Additional test cases\n+    # Test with no multiplication symbol\n+    assert latex(3*x**2*y, mul_symbol='') == r\"3x^{2}y\"\n+    \n+    # Test with asterisk as multiplication symbol\n+    assert latex(3*x**2*y, mul_symbol='*') == r\"3 * x^{2} * y\"\n+    \n+    # Test with custom symbol\n+    assert latex(3*x**2*y, mul_symbol='custom') == r\"3customx^{2}customy\"\n+    \n+    # Test with integral to make sure integrals are unaffected\n+    from sympy import Integral\n+    assert latex(Integral(2*x**2*y, x)) == r\"\\int 2 x^{2} y\\, dx\"\n+    \n+    # Test mixed use of standard symbols with the multiplication value 'dot' being the common one\n+    assert latex(3*x**2*y, mul_symbol='dot') == r\"3 \\cdot x^{2} \\cdot y\"\n+\n \n def test_latex_basic():\n     assert latex(1 + x) == \"x + 1\"\n",
  "sympy__sympy-13877": "diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py\nindex 2018055..e7254a6 100644\n--- a/sympy/matrices/tests/test_matrices.py\n+++ b/sympy/matrices/tests/test_matrices.py\n@@ -313,6 +313,19 @@ def test_as_mutable():\n     assert zeros(0, 3).as_immutable() == ImmutableMatrix(zeros(0, 3))\n     assert zeros(3, 0).as_immutable() == ImmutableMatrix(zeros(3, 0))\n \n+from sympy import symbols, Matrix\n+\n+def test_issue_13835():\n+    # This function tests the determinant calculation for matrices with symbolic entries.\n+    a = symbols('a')\n+    f = lambda n: Matrix([[i + a*j for i in range(n)] for j in range(n)]).det()\n+    assert f(1) == 0, \"Determinant of 1x1 matrix failed\"\n+    assert f(2) == -a, \"Determinant of 2x2 matrix failed\"\n+    assert f(3) == 2*a*(a + 2) + 2*a*(2*a + 1) - 3*a*(2*a + 2), \"Determinant of 3x3 matrix is incorrect\"\n+    assert f(4) == 0, \"Determinant of 4x4 matrix failed\"\n+    assert f(5) == 0, \"Determinant of 5x5 matrix should be zero\"\n+    assert f(6) == 0, \"Determinant of 6x6 matrix should be zero\"\n+    assert f(7) == 0, \"Determinant of 7x7 matrix should be zero\"\n \n def test_determinant():\n \n",
  "sympy__sympy-13878": "diff --git a/sympy/stats/tests/test_continuous_rv.py b/sympy/stats/tests/test_continuous_rv.py\nindex ff0c413..fbc3df2 100644\n--- a/sympy/stats/tests/test_continuous_rv.py\n+++ b/sympy/stats/tests/test_continuous_rv.py\n@@ -157,6 +157,10 @@ def test_characteristic_function():\n     assert simplify(cf(1)) == S(25)/26 + 5*I/26\n \n \n+from sympy.utilities.randtest import verify_numerically as tn\n+from sympy import pi, sqrt, Piecewise, gamma, exp, oo, log, gamma, beta, diff\n+from sympy import symbols, Rational, hyper, lowergamma, uppergamma, cdf\n+\n def test_sample():\n     z = Symbol('z')\n     Z = ContinuousRV(z, exp(-z), set=Interval(0, oo))\n@@ -708,8 +712,29 @@ def test_issue_10003():\n     G = Gamma('g', 1, 2)\n     assert P(X < -1) == S.Zero\n     assert P(G < -1) == S.Zero\n-\n-def test_precomputed_cdf():\n+def test_long_precomputed_cdf():\n+    x = symbols(\"x\", real=True, finite=True)\n+    distribs = [\n+        (Arcsin(\"A\", 0, 3), Piecewise((0, x < 0), (2/pi * asin(sqrt(x/3)), x <= 3), (1, True))),\n+        (Dagum(\"D\", S(1)/3, S(1)/5, 2), Piecewise(((1 + (x/(S(1)/5))**(-S(1)/3))**(-2), x >= 0), (0, True))),\n+        (Erlang(\"E\", 1, 1), Piecewise((lowergamma(1, x)/gamma(1), x > 0), (0, True))),\n+        (Frechet(\"F\", S(4)/3, 1, 2), Piecewise((exp(-((-2 + x)/1)**(-S(4)/3)), 2 <= x), (0, True))),\n+        (Gamma(\"G\", 0.1, 2), Piecewise((lowergamma(0.1, x/2)/gamma(0.1), x > 0), (0, True))),\n+        (GammaInverse(\"GI\", S(5)/7, 2), Piecewise((uppergamma(S(5)/7, 2/x)/gamma(S(5)/7), x > 0), (0, True))),\n+        (Kumaraswamy(\"K\", S(1)/123, 5), Piecewise((0, x < 0), (-(-x**(S(1)/123) + 1)**5 + 1, x <= 1), (1, True))),\n+        (Laplace(\"LA\", 2, 3), Piecewise((exp((x - 2)/3)/2, x < 2), (-exp((2 - x)/3)/2 + 1, True))),\n+        (Logistic(\"L\", 1, 0.1), 1/(exp((1 - x)/(0.1)) + 1)),\n+        (Nakagami(\"N\", S(7)/3, 1), Piecewise((lowergamma(S(7)/3, S(7)/3*x**2/1)/gamma(S(7)/3), x > 0), (0, True))),\n+        (StudentT(\"S\", 10), 1/2 + x*gamma(S(11)/2)*hyper((1/2, S(11)/2), (3/2,), -x**2/10)/(sqrt(pi)*sqrt(10)*gamma(5))),\n+    ]\n+    for distr, true_cdf in distribs:\n+        assert tn(diff(cdf(distr)(x), x), density(distr)(x), x)\n+        assert cdf(distr)(x) == true_cdf\n+\n+    US = UniformSum(\"US\", 5)\n+    pdf01 = density(US)(x).subs(floor(x), 0).doit()  # pdf on (0, 1)\n+    cdf01 = cdf(US, evaluate=False)(x).subs(floor(x), 0).doit()  # cdf on (0, 1)\n+    assert tn(diff(cdf01, x), pdf01, x)\n     x = symbols(\"x\", real=True, finite=True)\n     mu = symbols(\"mu\", real=True, finite=True)\n     sigma, xm, alpha = symbols(\"sigma xm alpha\", positive=True, finite=True)\n",
  "sympy__sympy-13974": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bd3e825..3971d5c 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -48,8 +48,29 @@ def test_tensor_product_commutator():\n def test_tensor_product_simp():\n     assert tensor_product_simp(TP(A, B)*TP(B, C)) == TP(A*B, B*C)\n \n-\n-def test_issue_5923():\n+def test_tensor_product_power_issue():\n+    A, B, C, D = symbols('A, B, C, D', commutative=False)\n+    from sympy.physics.quantum import TensorProduct as TP\n+    from sympy.physics.quantum import tensor_product_simp as tps\n+    from sympy import Symbol, expand\n+\n+    a = Symbol('a', commutative=False)\n+    t1 = TP(1, 1) * TP(1, 1)\n+    assert tps(t1) == t1\n+    assert t1.expand(tensorproduct=True) == t1\n+    assert tps(TP(1, 1) * TP(1, a)).subs(a, 1) == TP(1, 1)\n+\n+    t2 = TP(1, Pauli(3)) * TP(1, Pauli(3))\n+    assert tps(t2) == t2\n+    assert t2.expand(tensorproduct=True) == t2\n+    assert tps(TP(1, Pauli(3)) * TP(1, a)).subs(a, Pauli(3)) == TP(1, 1)\n+\n+    # Additional tests from the original test patch\n+    x = Symbol('x', commutative=False)\n+    assert tps(TP(A, B)**x) == TP(A**x, B**x)\n+    assert tps(x*TP(A, B)**2) == x*TP(A**2, B**2)\n+    assert tps(x*(TP(A, B)**2)*TP(C, D)) == x*TP(A**2*C, B**2*D)\n+    assert tps(TP(A, B) - TP(C, D)**x) == TP(A, B) - TP(C**x, D**x)\n     # most of the issue regarding sympification of args has been handled\n     # and is tested internally by the use of args_cnc through the quantum\n     # module, but the following is a test from the issue that used to raise.\n",
  "sympy__sympy-14531": "diff --git a/sympy/printing/tests/test_str.py b/sympy/printing/tests/test_str.py\nindex 29c7fd2..a28b9a5 100644\n--- a/sympy/printing/tests/test_str.py\n+++ b/sympy/printing/tests/test_str.py\n@@ -490,6 +490,9 @@ def test_Rational():\n     assert str(2**Rational(1, 10**10)) == \"2**(1/10000000000)\"\n \n     assert sstr(Rational(2, 3), sympy_integers=True) == \"S(2)/3\"\n+    # Additional test cases based on the issue\n+    assert sstr(Eq(Symbol('x'), Rational(1, 2)), sympy_integers=True) == \"Eq(x, S(1)/2)\"\n+    assert sstr(Limit(Symbol('x'), Symbol('x'), Rational(1, 2)), sympy_integers=True) == \"Limit(x, x, S(1)/2)\"\n     assert sstr(Symbol(\"x\")**Rational(2, 3), sympy_integers=True) == \"x**(S(2)/3)\"\n \n \n",
  "sympy__sympy-14711": "diff --git a/sympy/physics/vector/tests/test_vector.py b/sympy/physics/vector/tests/test_vector.py\nindex de6a8ff..f895c53 100644\n--- a/sympy/physics/vector/tests/test_vector.py\n+++ b/sympy/physics/vector/tests/test_vector.py\n@@ -4,7 +4,19 @@ from sympy.abc import x, y, z\n from sympy.utilities.pytest import raises\n \n \n-Vector.simp = True\n+def test_vector_zero_multiplication_addition():\n+    N = ReferenceFrame('N')\n+    # Testing the addition of a normal vector with a zero-multiplied vector \n+    v1 = N.x\n+    v2 = 0 * N.x\n+    try:\n+        v_sum = sum([v1, v2])\n+        assert v_sum == v1, \"Expected the sum to be equal to v1\"\n+        print(\"Test passed: sum([N.x, (0 * N.x)]) did not raise an error.\")\n+    except Exception as e:\n+        print(\"Test failed:\", e)\n+from sympy.physics.vector import ReferenceFrame, Vector\n+from sympy import symbols\n A = ReferenceFrame('A')\n \n \n",
  "sympy__sympy-14976": "diff --git a/sympy/solvers/tests/test_numeric.py b/sympy/solvers/tests/test_numeric.py\nindex 6a82251..3d9b4f3 100644\n--- a/sympy/solvers/tests/test_numeric.py\n+++ b/sympy/solvers/tests/test_numeric.py\n@@ -1,8 +1,12 @@\n+\n from sympy import (Eq, Matrix, pi, sin, sqrt, Symbol, Integral, Piecewise,\n     symbols, Float, I)\n from mpmath import mnorm, mpf\n from sympy.solvers import nsolve\n from sympy.utilities.lambdify import lambdify\n+from sympy.core import Rational\n+import inspect\n+import mpmath\n from sympy.utilities.pytest import raises, XFAIL\n from sympy.utilities.decorator import conserve_mpmath_dps\n \n",
  "sympy__sympy-15017": "diff --git a/sympy/tensor/array/tests/test_immutable_ndim_array.py b/sympy/tensor/array/tests/test_immutable_ndim_array.py\nindex 18941a7..affc3da 100644\n--- a/sympy/tensor/array/tests/test_immutable_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_immutable_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from copy import copy\n \n from sympy.tensor.array.dense_ndim_array import ImmutableDenseNDimArray\n@@ -73,7 +74,18 @@ def test_ndim_array_initiation():\n \n     from sympy.abc import x\n     rank_zero_array = ImmutableDenseNDimArray(x)\n-    assert len(rank_zero_array) == 0\n+    assert len(rank_zero_array) == 1\n+\n+    # Additional test case for rank-0 array with integer\n+    scalar_array = ImmutableDenseNDimArray(42)\n+    assert len(scalar_array) == 1\n+    assert scalar_array.shape == ()\n+    assert scalar_array.rank() == 0\n+    assert scalar_array[()] == 42\n+    raises(ValueError, lambda: scalar_array[0])\n+\n+    # Additional comparison with list conversion\n+    assert len(list(rank_zero_array)) == 1\n     assert rank_zero_array.shape == ()\n     assert rank_zero_array.rank() == 0\n     assert rank_zero_array[()] == x\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..3e433ef 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,9 +1,10 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n from sympy.functions import exp, sin, cos, conjugate\n-\n+from sympy.functions import Max, Min\n from sympy import mathematica_code as mcode\n \n x, y, z = symbols('x,y,z')\n",
  "sympy__sympy-15349": "",
  "sympy__sympy-15599": "",
  "sympy__sympy-15809": "diff --git a/sympy/functions/elementary/tests/test_miscellaneous.py b/sympy/functions/elementary/tests/test_miscellaneous.py\nindex 821fd0c..afb126e 100644\n--- a/sympy/functions/elementary/tests/test_miscellaneous.py\n+++ b/sympy/functions/elementary/tests/test_miscellaneous.py\n@@ -84,6 +84,12 @@ def test_Min():\n     assert Min(np, np_).func is Min\n     assert Min(p, p_).func is Min\n \n+    from sympy import S, Symbol, Min, Max, oo, raises  # Ensure necessary imports are present\n+\n+    # Test for zero-argument Min() and Max()\n+    assert Min() == S.Infinity\n+    assert Max() == S.NegativeInfinity\n+\n     # lists\n     raises(ValueError, lambda: Min())\n     assert Min(x, y) == Min(y, x)\n@@ -154,6 +160,12 @@ def test_Max():\n \n     assert Max(5, 4) == 5\n \n+    from sympy import S, Symbol, Min, Max, oo, raises  # Ensure necessary imports are present\n+\n+    # Test for zero-argument Min() and Max()\n+    assert Min() == S.Infinity\n+    assert Max() == S.NegativeInfinity\n+\n     # lists\n \n     raises(ValueError, lambda: Max())\n",
  "sympy__sympy-15875": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 58ab306..e5df4e4 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1987,10 +1987,29 @@ def test_Add_is_zero():\n     assert (x + y).is_zero\n \n \n-def test_issue_14392():\n+def test_issue_15873():\n+    from sympy import I, simplify\n+    e = -2*I + (1 + I)**2\n+    assert e.is_zero is None  # Original test patch\n+    assert simplify(e).is_zero is True  # Check the simplified expression\n+\n+    # Additional complex numbers tests\n+    a = (1 + I)*(1 - I)\n+    b = 1 + I - I - 1\n+    c = (3*I + 4) + (-3*I - 4)\n+    assert a.is_zero is False  # (1 + I)*(1 - I) -> 2, not zero\n+    assert b.is_zero is None   # Simplifies to zero, but it's indeterminate here\n+    assert simplify(b).is_zero is True  # Simplifies to zero\n+    assert c.is_zero is True   # Should be zero\n+\n+    # Check expressions incorporating addition\n+    x = Symbol('x', zero=True)\n+    y = Symbol('y', zero=True)\n+    z = (x + I*y).is_zero\n+    assert z is None  # Cannot determine if zero\n     assert (sin(zoo)**2).as_real_imag() == (nan, nan)\n \n def test_divmod():\n     assert divmod(x, y) == (x//y, x % y)\n     assert divmod(x, 3) == (x//3, x % 3)\n-    assert divmod(3, x) == (3//x, 3 % x)\n+    assert divmod(3, x) == (3//x, 3 % x)\n",
  "sympy__sympy-16450": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex aba4711..157c216 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -477,8 +477,30 @@ def test_logcombine_complex_coeff():\n     assert logcombine(i + 2*log(x), force=True) == \\\n         i + log(x**2)\n \n-\n-def test_issue_5950():\n+from sympy import Symbol, posify\n+\n+def test_posify_finite():\n+    # Test that finite assumption is preserved\n+    k = Symbol('k', finite=True)\n+    eq, rep = posify(k)\n+    assert eq.assumptions0['finite'] == True\n+    assert eq.assumptions0['infinite'] == False\n+\n+def test_posify_integer():\n+    # Test that integer assumption is preserved\n+    m = Symbol('m', integer=True)\n+    eq, rep = posify(m)\n+    assert eq.assumptions0['integer'] == True\n+    assert eq.assumptions0['rational'] == True\n+\n+def test_posify_even_odd():\n+    # Test that even and odd assumptions are preserved\n+    ev = Symbol('ev', even=True)\n+    od = Symbol('od', odd=True)\n+    eq_ev, rep_ev = posify(ev)\n+    eq_od, rep_od = posify(od)\n+    assert eq_ev.assumptions0['even'] == True\n+    assert eq_od.assumptions0['odd'] == True\n     x, y = symbols(\"x,y\", positive=True)\n     assert logcombine(log(3) - log(2)) == log(Rational(3,2), evaluate=False)\n     assert logcombine(log(x) - log(y)) == log(x/y)\n",
  "sympy__sympy-16766": "diff --git a/sympy/printing/tests/test_pycode.py b/sympy/printing/tests/test_pycode.py\nindex 51a287f..04b909b 100644\n--- a/sympy/printing/tests/test_pycode.py\n+++ b/sympy/printing/tests/test_pycode.py\n@@ -1,7 +1,9 @@\n+\n # -*- coding: utf-8 -*-\n from __future__ import absolute_import\n \n from sympy.codegen import Assignment\n+from sympy.tensor import IndexedBase\n from sympy.codegen.ast import none\n from sympy.core import Expr, Mod, symbols, Eq, Le, Gt, zoo, oo, Rational\n from sympy.core.numbers import pi\n@@ -35,8 +37,27 @@ def test_PythonCodePrinter():\n                                                         ' (3) if (x > 0) else None)'\n     assert prntr.doprint(sign(x)) == '(0.0 if x == 0 else math.copysign(1, x))'\n \n-\n-def test_MpmathPrinter():\n+def test_PythonCodePrinter_Indexed():\n+    prntr = PythonCodePrinter()\n+    # Original test case\n+    p = IndexedBase(\"p\")\n+    assert prntr.doprint(p[0, 1]) == 'p[0, 1]'\n+    \n+    # Additional test cases to verify different indexed usage\n+    q = IndexedBase(\"q\")\n+    i, j = symbols('i j')\n+    assert prntr.doprint(q[i]) == 'q[i]'  # Single index\n+    assert prntr.doprint(q[i, j]) == 'q[i, j]'  # Multiple indices\n+    assert prntr.doprint(q[0]) == 'q[0]'  # Literal index\n+\n+    # Check if combination with other expressions works\n+    from sympy import Add\n+    expr = Add(q[i], 1)\n+    assert prntr.doprint(expr) == '(q[i] + 1)'\n+\n+    # Nested Indexed within Indexed\n+    r = IndexedBase(\"r\")\n+    assert prntr.doprint(r[q[i], j]) == 'r[q[i], j]'\n     p = MpmathPrinter()\n     assert p.doprint(sign(x)) == 'mpmath.sign(x)'\n     assert p.doprint(Rational(1, 2)) == 'mpmath.mpf(1)/mpmath.mpf(2)'\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_autowrap.py b/sympy/utilities/tests/test_autowrap.py\nindex 23fddca..5924337 100644\n--- a/sympy/utilities/tests/test_autowrap.py\n+++ b/sympy/utilities/tests/test_autowrap.py\n@@ -31,6 +31,26 @@ def get_string(dump_fn, routines, prefix=\"file\", **kwargs):\n     return source\n \n \n+from sympy.utilities.autowrap import autowrap\n+from sympy import MatrixSymbol\n+import numpy as np\n+\n+def test_autowrap_cython_unused_array_arg():\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0  # `x` does not appear in the expression\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    # Ensure that calling the function returns 1.0 despite `x` not being used\n+    result = f(np.array([[1.0], [2.0]]))\n+    assert result == 1.0\n+\n+def test_autowrap_cython_used_array_arg():\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = x[0, 0]\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    # Ensure that calling the function with x[0,0] returns the first element\n+    result = f(np.array([[3.0], [4.0]]))\n+    assert result == 3.0\n+\n def test_cython_wrapper_scalar_function():\n     x, y, z = symbols('x,y,z')\n     expr = (x + y)*z\n",
  "sympy__sympy-16886": "diff --git a/sympy/crypto/tests/test_crypto.py b/sympy/crypto/tests/test_crypto.py\nindex 8b39574..757c024 100644\n--- a/sympy/crypto/tests/test_crypto.py\n+++ b/sympy/crypto/tests/test_crypto.py\n@@ -247,6 +247,12 @@ def test_encode_morse():\n     assert encode_morse(' ', sep='`') == '``'\n     assert encode_morse(' ', sep='``') == '````'\n     assert encode_morse('!@#$%^&*()_+') == '-.-.--|.--.-.|...-..-|-.--.|-.--.-|..--.-|.-.-.'\n+def test_encode_morse_numbers():\n+    # Specific test for the issue: validating correct Morse code for \"1\"\n+    assert encode_morse('1') == '.----'\n+    # Extending number tests with different separators to ensure robustness\n+    assert encode_morse('12345', sep='|') == '.----|..---|...--|....-|.....'\n+    assert encode_morse('67890', sep='|') == '-....|--...|---..|----.|-----'\n \n \n def test_decode_morse():\n",
  "sympy__sympy-17139": "",
  "sympy__sympy-17318": "diff --git a/sympy/simplify/tests/test_sqrtdenest.py b/sympy/simplify/tests/test_sqrtdenest.py\nindex 7a6c0e1..aed8a92 100644\n--- a/sympy/simplify/tests/test_sqrtdenest.py\n+++ b/sympy/simplify/tests/test_sqrtdenest.py\n@@ -1,4 +1,7 @@\n-from sympy import sqrt, root, S, Symbol, sqrtdenest, Integral, cos\n+\n+from sympy import sqrt, root, S, Symbol, sqrtdenest, Integral, cos, I, simplify\n+from sympy.simplify.sqrtdenest import _sqrt_match\n+from sympy.core.expr import unchanged\n from sympy.simplify.sqrtdenest import _subsets as subsets\n from sympy.utilities.pytest import slow\n \n@@ -175,8 +178,22 @@ def test_subsets():\n         [0, 1, 1, 0], [1, 1, 1, 0], [0, 0, 0, 1], [1, 0, 0, 1], [0, 1, 0, 1],\n         [1, 1, 0, 1], [0, 0, 1, 1], [1, 0, 1, 1], [0, 1, 1, 1], [1, 1, 1, 1]]\n \n-\n-def test_issue_5653():\n+def test_issue_12420():\n+    # Checking that the initial problematic case does not cause an error\n+    expr = (3 - sqrt(2)*sqrt(4 + 3*I) + 3*I)/2\n+    expected_output = simplify(expr)  # expected: 3/2 - sqrt(2)*sqrt(4 + 3*I)/2 + 3*I/2\n+    assert sqrtdenest(expr) == expected_output\n+    \n+    # Another expression to check behavior with complex\n+    expr2 = 3 - sqrt(2)*sqrt(4 + I) + 3*I\n+    assert sqrtdenest(expr2) == expr2  # should return unchanged\n+\n+    # Check behavior with simpler expression to see if it handles linear combinations with surds correctly\n+    expr3 = sqrt(2) + sqrt(3)\n+    assert sqrtdenest(expr3) == expr3  # should be returned unchanged, no denesting possible\n+    \n+    # Ensure _sqrt_match processes a simple case without error\n+    assert _sqrt_match(4 + I) == []\n     assert sqrtdenest(\n         sqrt(2 + sqrt(2 + sqrt(2)))) == sqrt(2 + sqrt(2 + sqrt(2)))\n \n",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..8906b89 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy import I, Rational, Symbol, pi, sqrt, S\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n@@ -91,6 +92,14 @@ def test_point():\n     assert (-p3).__rsub__(p4) == p3.midpoint(p4).scale(2, 2)\n \n     assert p4 * 5 == Point(5, 5)\n+    # New test cases for issue verification\n+    scalar = sympy.sympify(2.0)\n+    point_a = Point(0, 0)\n+    point_b = Point(1, 1)\n+    \n+    # Test both scenarios of scalar multiplication to check commutativity\n+    assert point_a + point_b * scalar == Point2D(2.0, 2.0)\n+    assert point_a + scalar * point_b == Point2D(2.0, 2.0)\n     assert p4 / 5 == Point(0.2, 0.2)\n \n     raises(ValueError, lambda: Point(0, 0) + 10)\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..5b3b5ad 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -473,8 +473,24 @@ def test_descent():\n     # supposed to be square-free\n     raises(TypeError, lambda: descent(4, 3))\n \n-\n-def test_diophantine():\n+from sympy import diophantine\n+from sympy.abc import m, n\n+\n+def test_issue_18186():\n+    # This test verifies the fix for inconsistent results based on syms order\n+    expr = n**4 + m**4 - 2**4 - 3**4\n+    expected_solution = {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n+    \n+    # Test with syms order (m, n)\n+    result_mn = diophantine(expr, syms=(m, n), permute=True)\n+    assert result_mn == expected_solution, f\"Failed for syms=(m, n). Got: {result_mn}\"\n+\n+    # Test with syms order (n, m)\n+    result_nm = diophantine(expr, syms=(n, m), permute=True)\n+    assert result_nm == expected_solution, f\"Failed for syms=(n, m). Got: {result_nm}\"\n+    \n+    # Check that both orders produce the same result\n+    assert result_mn == result_nm, \"Different solutions for different syms order.\"\n     assert check_solutions((x - y)*(y - z)*(z - x))\n     assert check_solutions((x - y)*(x**2 + y**2 - z**2))\n     assert check_solutions((x - 3*y + 7*z)*(x**2 + y**2 - z**2))\n",
  "sympy__sympy-18763": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex ba93bdc..356c7ec 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -664,6 +664,21 @@ def test_latex_derivatives():\n     x2 = Symbol('x2')\n     assert latex(diff(f(x1, x2), x1)) == r'\\frac{\\partial}{\\partial x_{1}} f{\\left(x_{1},x_{2} \\right)}'\n \n+def test_latex_subs_parentheses():\n+    from sympy import Subs, symbols\n+    x, y = symbols('x y')\n+    # Original test case\n+    assert latex(3*Subs(-x+y, (x,), (1,))) == \\\n+           r'3 \\left. \\left(- x + y\\right) \\right|_{\\substack{ x=1 }}'\n+    # Test an additional case with more complex expression\n+    assert latex(Subs(3*(x - y), (x,), (2,))) == \\\n+           r'\\left. \\left(3 \\left(x - y\\right)\\right) \\right|_{\\substack{ x=2 }}'\n+    # Nested Subs\n+    assert latex(Subs(Subs(x+y, (x,), (1,)), (y,), (2,))) == \\\n+           r'\\left. \\left(\\left. \\left(x + y\\right) \\right|_{\\substack{ x=1 }}\\right) \\right|_{\\substack{ y=2 }}'\n+    # Subs with no operation (identity)\n+    assert latex(Subs(x, (x,), (1,))) == r'\\left. x \\right|_{\\substack{ x=1 }}'\n+\n     n1 = Symbol('n1')\n     assert latex(diff(f(x), (x, n1))) ==  r'\\frac{d^{n_{1}}}{d x^{n_{1}}} f{\\left(x \\right)}'\n \n",
  "sympy__sympy-19346": "",
  "sympy__sympy-19495": "diff --git a/sympy/sets/tests/test_conditionset.py b/sympy/sets/tests/test_conditionset.py\nindex 68ee5d6..9e81fc7 100644\n--- a/sympy/sets/tests/test_conditionset.py\n+++ b/sympy/sets/tests/test_conditionset.py\n@@ -1,7 +1,8 @@\n+\n from sympy.sets import (ConditionSet, Intersection, FiniteSet,\n-    EmptySet, Union, Contains)\n-from sympy import (Symbol, Eq, S, Abs, sin, pi, Interval,\n-    And, Mod, oo, Function)\n+    EmptySet, Union, Contains, imageset)\n+from sympy import (Symbol, Eq, S, Abs, sin, asin, pi, Interval,\n+    And, Mod, oo, Function, Lambda)\n from sympy.testing.pytest import raises, XFAIL, warns_deprecated_sympy\n \n \n@@ -87,7 +88,14 @@ def test_free_symbols():\n         ).free_symbols == {x, z}\n \n \n-def test_subs_CondSet():\n+def test_issue_resolved_for_subs_on_conditionset_imageset():\n+    k = Symbol('k')\n+    img1 = imageset(Lambda(k, 2*k*pi + asin(y)), S.Integers)\n+    img2 = imageset(Lambda(k, 2*k*pi + asin(S.One/3)), S.Integers)\n+    assert ConditionSet(x, Contains(y, Interval(-1,1)), img1).subs(y, S.One/3).dummy_eq(img2)\n+\n+    condset = ConditionSet(x, Contains(y, Interval(-1,1)), img1)\n+    assert condset.subs(y, S.One/3) == ConditionSet(x, Contains(S.One/3, Interval(-1,1)), img2)\n     s = FiniteSet(z, y)\n     c = ConditionSet(x, x < 2, s)\n     # you can only replace sym with a symbol that is not in\n",
  "sympy__sympy-19637": "diff --git a/sympy/core/tests/test_sympify.py b/sympy/core/tests/test_sympify.py\nindex 4d20fb4..95251c2 100644\n--- a/sympy/core/tests/test_sympify.py\n+++ b/sympy/core/tests/test_sympify.py\n@@ -513,8 +513,38 @@ def test_kernS():\n     one = kernS('x - (x - 1)')\n     assert one != 1 and one.expand() == 1\n \n+def test_issue_unbound_local_error():\n+    # Test cases specifically aimed at ensuring 'kern' is always assigned\n+    from sympy.abc import x\n+    from sympy.core.interval import Interval\n+    from sympy.core.add import Add\n+    from sympy.core.mul import Mul\n+    from sympy.core.symbol import Symbol\n+    from sympy.core.numbers import Integer\n+\n+    assert kernS(\"(2*x)/(x-1)\") == 2*x/(x-1)  # Covers the initial issue\n+\n+    # Expression that causes the space token to create a unique kern\n+    expr = \"x * (y - z)\"\n+    kern_result = kernS(expr)\n+    # Assertion could depend on how `kernS` is implemented to handle implicitly\n+    # multiplied expressions with the 'hack'.\n+    expected_expr = x*(y - z)\n+    assert kern_result.simplify() == expected_expr.simplify()\n+\n+    # Test with expression not requiring modification, such as a simple number\n+    assert kernS(\"42\") == Integer(42)\n+\n+    # Expression with mismatched parenthesis - should raise a SympifyError\n+    try:\n+        kernS(\"(x+y\")\n+        assert False, \"SympifyError not raised with unmatched parentheses\"\n+    except:\n+        pass\n \n-def test_issue_6540_6552():\n+    # An input that initially caused a double kern assignment test\n+    expr_with_double_kern = \"-(-(x))\"\n+    assert kernS(expr_with_double_kern) == -(-(x))\n     assert S('[[1/3,2], (2/5,)]') == [[Rational(1, 3), 2], (Rational(2, 5),)]\n     assert S('[[2/6,2], (2/4,)]') == [[Rational(1, 3), 2], (S.Half,)]\n     assert S('[[[2*(1)]]]') == [[[2]]]\n",
  "sympy__sympy-19783": "diff --git a/sympy/physics/quantum/tests/test_operator.py b/sympy/physics/quantum/tests/test_operator.py\nindex 799aaae..fd5792b 100644\n--- a/sympy/physics/quantum/tests/test_operator.py\n+++ b/sympy/physics/quantum/tests/test_operator.py\n@@ -1,5 +1,6 @@\n+\n from sympy import (Derivative, diff, Function, Integer, Mul, pi, sin, Symbol,\n-                   symbols)\n+                   symbols, Expr, Integer)\n from sympy.physics.quantum.qexpr import QExpr\n from sympy.physics.quantum.dagger import Dagger\n from sympy.physics.quantum.hilbert import HilbertSpace\n@@ -106,7 +107,22 @@ def test_identity():\n         assert represent(IdentityOperator(n)) == eye(n)\n \n \n-def test_outer_product():\n+def test_dagger_with_identity():\n+    O = Operator('O')\n+    I = IdentityOperator()\n+\n+    D_O = Dagger(O)\n+\n+    # Tests to confirm the issue described:\n+    assert D_O * I == D_O, \"Dagger(O) * Identity should simplify to Dagger(O)\"\n+    assert I * D_O == D_O, \"Identity * Dagger(O) should simplify to Dagger(O)\"\n+\n+    # Ensure multiplication the other way also works correctly\n+    assert O * I == O, \"Operator * Identity should simplify to Operator\"\n+    assert I * O == O, \"Identity * Operator should simplify to Operator\"\n+\n+    # Ensure if Identity is on both sides, it still remains the same\n+    assert I * O * I == O, \"Identity * Operator * Identity should simplify to Operator\"\n     k = Ket('k')\n     b = Bra('b')\n     op = OuterProduct(k, b)\n",
  "sympy__sympy-19954": "diff --git a/sympy/combinatorics/tests/test_perm_groups.py b/sympy/combinatorics/tests/test_perm_groups.py\nindex 3f4bb48..9a98e96 100644\n--- a/sympy/combinatorics/tests/test_perm_groups.py\n+++ b/sympy/combinatorics/tests/test_perm_groups.py\n@@ -905,8 +905,23 @@ def test_sylow_subgroup():\n     assert G.order() % S.order() == 0\n     assert G.order()/S.order() % 2 > 0\n \n-\n-@slow\n+def test_sylow_subgroup_issue():\n+    from sympy.combinatorics import DihedralGroup\n+\n+    # Test for Dihedral Group of order 18\n+    G = DihedralGroup(18)\n+    S2 = G.sylow_subgroup(p=2)\n+    assert S2.order() == 9\n+\n+    # Test for Dihedral Group of order 50 (2*25)\n+    G = DihedralGroup(50)\n+    S2 = G.sylow_subgroup(p=2)\n+    assert S2.order() == 4\n+\n+    # Additional test: Large dihedral group\n+    G = DihedralGroup(100)\n+    S5 = G.sylow_subgroup(p=5)\n+    assert S5.order() == 25\n def test_presentation():\n     def _test(P):\n         G = P.presentation()\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..ca65540 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -471,7 +471,26 @@ def test_multiset_permutations():\n         6\\n''')\n \n \n-def test_partitions():\n+from sympy import S\n+from sympy.utilities.iterables import partitions\n+\n+def test_partitions_reuse():\n+    # Test to check that partitions do not reuse dictionary objects\n+\n+    # Using list() directly on partitions should give the same results as if copying each element\n+    p_list_copied = [p.copy() for p in partitions(5)]\n+    p_list_direct = list(partitions(5))\n+    \n+    # Check if all partitions are unique instances and their content is identical to the copied ones\n+    assert p_list_copied == p_list_direct\n+    assert all(copied is not direct for copied, direct in zip(p_list_copied, p_list_direct))\n+\n+    # Further, using a set to ensure no two dictionaries are the same instance by identity\n+    p_set = set(map(id, partitions(5)))\n+    p_list = list(map(id, partitions(5)))\n+\n+    # Length of set should be equal to length of the list if no object is reused\n+    assert len(p_set) == len(p_list)\n     ans = [[{}], [(0, {})]]\n     for i in range(2):\n         assert list(partitions(0, size=i)) == ans[i]\n",
  "sympy__sympy-20801": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\nindex 8e1c7e2..3b43d13 100644\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -579,7 +579,28 @@ def test_Float():\n     # oo and nan\n     u = ['inf', '-inf', 'nan', 'iNF', '+inf']\n     v = [oo, -oo, nan, oo, oo]\n-    for i, a in zip(u, v):\n+    from sympy import S\n+    \n+    def test_zero_not_false():\n+        # Issue: https://github.com/sympy/sympy/issues/20796\n+        assert (S(0.0) == S.false) is False\n+        assert (S.false == S(0.0)) is False\n+        assert (S(0) == S.false) is False\n+        assert (S.false == S(0)) is False\n+    \n+    def test_zero_float_symmetry():\n+        # Ensure symmetric comparison behavior\n+        z_float = S(0.0)\n+        f = S.false\n+        \n+        assert (z_float == f) == (f == z_float)\n+        assert (S(0) == f) == (f == S(0))\n+        \n+        # Cross-check with similar types of comparisons\n+        assert (z_float == S(0)) is True\n+        assert (S(0) == z_float) is True\n+        assert (z_float == 0) is True\n+        assert (0 == z_float) is True\n         assert Float(i) is a\n \n \n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..e6a8e0f 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -20,7 +21,33 @@ def test_subs():\n     assert e == Rational(6)\n \n \n-def test_subs_Matrix():\n+def test_issue_21373():\n+    from sympy.functions.elementary.hyperbolic import sinh\n+    from sympy.functions.elementary.exponential import exp\n+    from sympy import Piecewise\n+\n+    # Setup symbols\n+    x, y, z = symbols('x y z')\n+\n+    # Test cases specific to issue 21373\n+\n+    # Case 1: No real assumptions\n+    expr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\n+    assert expr.subs({1: 1.0}) == exp(sinh(Piecewise((x, y > x), (y, True)) / z))  # Ensures no error\n+    \n+    # Case 2: Real assumptions on x_r and y_r\n+    x_r, y_r = symbols('x_r y_r', real=True)\n+    expr_real = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))\n+    assert expr_real.subs({1: 1.0}) == exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))  # Ensures no error\n+\n+    # Additional similar case with cosh to cover hyperbolic cosine scenario\n+    from sympy.functions.elementary.hyperbolic import cosh\n+\n+    expr_cosh = exp(cosh(Piecewise((x, y > x), (y, True)) / z))\n+    assert expr_cosh.subs({1: 1.0}) == exp(cosh(Piecewise((x, y > x), (y, True)) / z))\n+    \n+    expr_cosh_real = exp(cosh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))\n+    assert expr_cosh_real.subs({1: 1.0}) == exp(cosh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z))\n     z = zeros(2)\n     z1 = ZeroMatrix(2, 2)\n     assert (x*y).subs({x:z, y:0}) in [z, z1]\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..06cacec 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -16,7 +16,41 @@ from sympy.core import S, symbols\n from sympy.testing.pytest import raises\n \n \n+from sympy.polys.monomials import itermonomials\n+from sympy.polys.orderings import monomial_key\n+\n def test_monomials():\n+    # Test for issue when using min_degrees argument\n+    # Correct set of monomials for min_degree = 3 and max_degree = 3\n+    assert set(itermonomials([x, y, z], 3, 3)) == {\n+        x**3, x**2*y, x**2*z, x*y**2, x*y*z, x*z**2,\n+        y**3, y**2*x, y**2*z, y*x*z, y*z**2,\n+        z**3, z**2*x, z**2*y\n+    }\n+\n+    # Further test for different combinations of min_degree and max_degree\n+    assert set(itermonomials([x, y, z], 4, 3)) >= {\n+        x**3, x**2*y, x**2*z, x*y**2, x*y*z, x*z**2,\n+        y**3, y**2*x, y**2*z, y*x*z, y*z**2,\n+        z**3, z**2*x, z**2*y\n+    }\n+\n+    # Original patch tests\n+    assert set(itermonomials([x, y], 3, 3)) == {x**3, x**2*y, x*y**2, y**3}\n+    assert set(itermonomials([x, y], 3, 2)) == {x**2, x*y, y**2, x**3, x**2*y, x*y**2, y**3}\n+\n+    i, j, k = symbols('i j k', commutative=False)\n+    assert set(itermonomials([i, j, k], 2, 2)) == {\n+        k*i, i**2, i*j, j*k, j*i, k**2, j**2, k*j, i*k\n+    }\n+\n+    assert set(itermonomials([i, j, k], 3, 2)) == {\n+        j*k**2, i*k**2, k*i*j, k*i**2, k**2, j*k*j, k*j**2, i*k*i, i*j,\n+        j**2*k, i**2*j, j*i*k, j**3, i**3, k*j*i, j*k*i, j*i,\n+        k**2*j, j*i**2, k*j, k*j*k, i*j*i, j*i*j, i*j**2, j**2,\n+        k*i*k, i**2, j*k, i*k, i*k*j, k**3, i**2*k, j**2*i, k**2*i,\n+        i*j*k, k*i\n+    }\n \n     # total_degree tests\n     assert set(itermonomials([], 0)) == {S.One}\n",
  "sympy__sympy-22456": "diff --git a/sympy/codegen/tests/test_ast.py b/sympy/codegen/tests/test_ast.py\nindex 6c38ed6..84c8b3b 100644\n--- a/sympy/codegen/tests/test_ast.py\n+++ b/sympy/codegen/tests/test_ast.py\n@@ -279,6 +279,10 @@ def test_String():\n     assert str(s) == 'foo'\n     assert repr(s) == \"String('foo')\"\n \n+def test_String_func_args_invariance():\n+    st = String('foobar')\n+    assert st.func(*st.args) == st\n+\n def test_Comment():\n     c = Comment('foobar')\n     assert c.text == 'foobar'\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..114b4bf 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,4 +1,5 @@\n-from sympy.core.basic import Basic\n+\n+from sympy.core.parameters import evaluate\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n@@ -12,7 +13,11 @@ from sympy.utilities.misc import Undecidable\n from sympy.testing.pytest import raises, warns\n \n \n-def test_point():\n+def test_issue_22684():\n+    # Test creating Point2D with evaluate(False) to ensure no error is raised\n+    with evaluate(False):\n+        p = Point2D(1, 2)\n+        assert isinstance(p, Point2D)\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n",
  "sympy__sympy-22914": "diff --git a/sympy/printing/tests/test_pycode.py b/sympy/printing/tests/test_pycode.py\nindex ab6551d..746282e 100644\n--- a/sympy/printing/tests/test_pycode.py\n+++ b/sympy/printing/tests/test_pycode.py\n@@ -1,3 +1,4 @@\n+\n from sympy.codegen import Assignment\n from sympy.codegen.ast import none\n from sympy.codegen.cfunctions import expm1, log1p\n@@ -6,7 +7,7 @@ from sympy.codegen.matrix_nodes import MatrixSolve\n from sympy.core import Expr, Mod, symbols, Eq, Le, Gt, zoo, oo, Rational, Pow\n from sympy.core.numbers import pi\n from sympy.core.singleton import S\n-from sympy.functions import acos, KroneckerDelta, Piecewise, sign, sqrt\n+from sympy.functions import acos, KroneckerDelta, Piecewise, sign, sqrt, Min, Max\n from sympy.logic import And, Or\n from sympy.matrices import SparseMatrix, MatrixSymbol, Identity\n from sympy.printing.pycode import (\n@@ -56,6 +57,27 @@ def test_PythonCodePrinter():\n     assert prntr.doprint(KroneckerDelta(x,y)) == '(1 if x == y else 0)'\n \n     assert prntr.doprint((2,3)) == \"(2, 3)\"\n+    assert prntr.doprint(Min(x, y)) == \"min(x, y)\"\n+    assert prntr.doprint(Max(x, y)) == \"max(x, y)\"\n+\n+    # Additional test cases for Min and Max\n+    a, b, c = symbols(\"a b c\")\n+    \n+    # Simple two argument Min/Max\n+    assert prntr.doprint(Min(a, b)) == \"min(a, b)\"\n+    assert prntr.doprint(Max(a, b)) == \"max(a, b)\"\n+\n+    # Three arguments Min/Max\n+    assert prntr.doprint(Min(a, b, c)) == \"min(a, b, c)\"\n+    assert prntr.doprint(Max(a, b, c)) == \"max(a, b, c)\"\n+\n+    # Min/Max with numbers\n+    assert prntr.doprint(Min(1, b, 2)) == \"min(1, b, 2)\"\n+    assert prntr.doprint(Max(1, b, 2)) == \"max(1, b, 2)\"\n+\n+    # Nested Min/Max\n+    assert prntr.doprint(Min(Min(a, b), c)) == \"min(min(a, b), c)\"\n+    assert prntr.doprint(Max(Max(a, b), c)) == \"max(max(a, b), c)\"\n     assert prntr.doprint([2,3]) == \"[2, 3]\"\n \n \n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..764965e 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,6 +1175,9 @@ def test_scipy_polys():\n \n \n \n+import inspect  # Necessary for inspect.getsource\n+from sympy import lambdify, Tuple, symbols\n+\n def test_lambdify_inspect():\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n@@ -1198,6 +1201,23 @@ def test_issue_14941():\n     assert f3(2, 3) == [3, 2]\n \n \n+def test_python_code_printer_tuple_single_element():\n+    # Test tuple with a single element\n+    f2b = lambdify([], (1,))  # Issue gh-23224 test\n+    assert f2b() == (1,)      # Must return a tuple\n+\n+    # Test the source code to verify the correct syntax\n+    source_code = inspect.getsource(f2b)\n+    assert 'return (1,)' in source_code\n+\n+def test_python_code_printer_tuple_multiple_elements():\n+    # Test tuple with multiple elements to ensure existing functionality\n+    f2c = lambdify([], (1, 2))\n+    assert f2c() == (1, 2)\n+\n+    source_code = inspect.getsource(f2c)\n+    assert 'return (1, 2)' in source_code\n+\n def test_lambdify_Derivative_arg_issue_16468():\n     f = Function('f')(x)\n     fx = f.diff()\n",
  "sympy__sympy-23534": "diff --git a/sympy/core/tests/test_symbol.py b/sympy/core/tests/test_symbol.py\nindex 645c231..8e0e79a 100644\n--- a/sympy/core/tests/test_symbol.py\n+++ b/sympy/core/tests/test_symbol.py\n@@ -1,7 +1,14 @@\n+\n+def test_issue_23532_symbols_with_parentheses():\n+    q, u = symbols(('q:2', 'u:2'), cls=Function)\n+    assert type(q[0]) == UndefinedFunction\n+    assert type(u[0]) == UndefinedFunction\n+\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.relational import (GreaterThan, LessThan, StrictGreaterThan, StrictLessThan)\n from sympy.core.symbol import (Dummy, Symbol, Wild, symbols)\n from sympy.core.sympify import sympify  # can't import as S yet\n+from sympy.core.function import Function, UndefinedFunction\n from sympy.core.symbol import uniquely_named_symbol, _symbol, Str\n \n from sympy.testing.pytest import raises\n",
  "sympy__sympy-23824": "diff --git a/sympy/physics/hep/tests/test_gamma_matrices.py b/sympy/physics/hep/tests/test_gamma_matrices.py\nindex a4e0962..7a6d3dc 100644\n--- a/sympy/physics/hep/tests/test_gamma_matrices.py\n+++ b/sympy/physics/hep/tests/test_gamma_matrices.py\n@@ -262,7 +262,28 @@ def test_kahane_simplify1():\n     assert r.equals(-2*G(sigma)*G(rho)*G(nu))\n \n \n-def test_gamma_matrix_class():\n+def test_kahane_leading_gamma_matrix_bug():\n+    # Test case 1: Simplifying expression should keep the leading order\n+    mu, nu, rho, sigma = tensor_indices(\"mu, nu, rho, sigma\", LorentzIndex)\n+\n+    t = G(mu)*G(-mu)*G(rho)*G(sigma)\n+    r = kahane_simplify(t)\n+    assert r.equals(4*G(rho)*G(sigma)), f\"Unexpected result: {r}. Expected: 4*G(rho)*G(sigma)\"\n+\n+    # Test case 2: Different order leading gamma matrices should remain the same\n+    t = G(rho)*G(sigma)*G(mu)*G(-mu)\n+    r = kahane_simplify(t)\n+    assert r.equals(4*G(rho)*G(sigma)), f\"Unexpected result: {r}. Expected: 4*G(rho)*G(sigma)\"\n+\n+    # Additional test case: Another free gamma index case to ensure no flip\n+    t = G(sigma)*G(rho)*G(mu)*G(-mu)\n+    r = kahane_simplify(t)\n+    assert r.equals(4*G(sigma)*G(rho)), f\"Unexpected result: {r}. Expected: 4*G(sigma)*G(rho)\"\n+\n+    # Additional test case: Check with no contracted matrices\n+    t = G(mu)*G(rho)*G(sigma)\n+    r = kahane_simplify(t)\n+    assert r.equals(G(mu)*G(rho)*G(sigma)), f\"Unexpected result: {r}. Expected: G(mu)*G(rho)*G(sigma)\"\n     i, j, k = tensor_indices('i,j,k', LorentzIndex)\n \n     # define another type of TensorHead to see if exprs are correctly handled:\n",
  "sympy__sympy-23950": "diff --git a/sympy/sets/tests/test_contains.py b/sympy/sets/tests/test_contains.py\nindex 4bcc7c8..030e995 100644\n--- a/sympy/sets/tests/test_contains.py\n+++ b/sympy/sets/tests/test_contains.py\n@@ -30,6 +30,9 @@ def test_issue_10326():\n     assert Contains(-oo, Interval(-oo, oo)) == False\n \n \n+from sympy import S, Reals, Integers, FiniteSet, Symbol, Contains, Piecewise, Eq\n+from sympy.testing.pytest import raises\n+\n def test_binary_symbols():\n     x = Symbol('x')\n     y = Symbol('y')\n@@ -46,6 +49,31 @@ def test_as_set():\n     raises(NotImplementedError, lambda:\n            Contains(x, FiniteSet(y)).as_set())\n \n+def test_contains_as_set():\n+    x = Symbol('x')\n+    y = Symbol('y')\n+\n+    # Original tests\n+    assert Contains(x, FiniteSet(y)).as_set() == FiniteSet(y)\n+    assert Contains(x, S.Integers).as_set() == S.Integers\n+    assert Contains(x, S.Reals).as_set() == S.Reals\n+\n+    # Additional test cases for completeness\n+    # Test with an empty set\n+    assert Contains(x, S.EmptySet).as_set() == S.EmptySet\n+\n+    # Testing Contains with Piecewise to ensure relational conversion\n+    pw = Piecewise((6, Contains(x, S.Reals).as_set()), (7, True))\n+    assert pw == Piecewise((6, S.Reals.as_relational(x)), (7, True))\n+\n+    # Imbalanced condition Pieces\n+    with raises(AttributeError):\n+        pw = Piecewise((6, Contains(x, S.Reals)), (7, True))\n+\n+    # Test with specific sets like FiniteSet\n+    fset = FiniteSet(1, 2, 3).as_relational(x)\n+    assert Piecewise((6, Contains(x, FiniteSet(1, 2, 3)).as_set()), (7, True)) == Piecewise((6, fset), (7, True))\n+    \n def test_type_error():\n     # Pass in a parameter not of type \"set\"\n-    raises(TypeError, lambda: Contains(2, None))\n+    raises(TypeError, lambda: Contains(2, None))\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..0e1b4ee 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -540,6 +540,28 @@ def test_issue_20288():\n     expr = 1 + exp(u**2/v**2)\n     assert SI._collect_factor_and_dimension(expr) == (1 + E, Dimension(1))\n \n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units import Quantity\n+    from sympy.physics.units.systems.si import SI\n+\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n+\n \n def test_prefixed_property():\n     assert not meter.is_prefixed\n",
  "sympy__sympy-24213": "",
  "sympy__sympy-24443": "diff --git a/sympy/combinatorics/tests/test_homomorphisms.py b/sympy/combinatorics/tests/test_homomorphisms.py\nindex 0a025da..80e2dd4 100644\n--- a/sympy/combinatorics/tests/test_homomorphisms.py\n+++ b/sympy/combinatorics/tests/test_homomorphisms.py\n@@ -1,3 +1,4 @@\n+\n from sympy.combinatorics import Permutation\n from sympy.combinatorics.perm_groups import PermutationGroup\n from sympy.combinatorics.homomorphisms import homomorphism, group_isomorphism, is_isomorphic\n@@ -57,7 +58,25 @@ def test_homomorphism():\n     assert T.codomain == D\n     assert T(a*b) == p\n \n-def test_isomorphisms():\n+def test_issue_homomorphism_on_permutation_group():\n+    from sympy.combinatorics.named_groups import DihedralGroup\n+    # Test the previously failing case\n+    D3 = DihedralGroup(3)\n+    T = homomorphism(D3, D3, D3.generators, D3.generators)\n+    assert T.is_isomorphism()\n+\n+    # Additional tests to ensure broader coverage\n+    a = Permutation(1, 2, 3)\n+    b = Permutation(1, 3)\n+    P = PermutationGroup([a, b])\n+    T2 = homomorphism(P, P, P.generators, P.generators)\n+    assert T2.is_isomorphism()\n+\n+    # Homomorphism with inversion\n+    G = DihedralGroup(4)\n+    T3 = homomorphism(G, G, G.generators, [G.generators[1]**-1, G.generators[0]**-1])\n+    assert not T3.is_isomorphism()\n+    assert T3.kernel().order() == 2\n \n     F, a, b = free_group(\"a, b\")\n     E, c, d = free_group(\"c, d\")\n",
  "sympy__sympy-24539": "diff --git a/sympy/polys/tests/test_rings.py b/sympy/polys/tests/test_rings.py\nindex 1f0e405..dab96ff 100644\n--- a/sympy/polys/tests/test_rings.py\n+++ b/sympy/polys/tests/test_rings.py\n@@ -267,6 +267,15 @@ def test_PolyElement_as_expr():\n \n     raises(ValueError, lambda: f.as_expr(X))\n \n+    # New test case to verify using completely different symbols\n+    U, V, W = symbols(\"u,v,w\")\n+    g = 3*U**2*V - U*V*W + 7*W**3 + 1\n+    assert f.as_expr(U, V, W) == g\n+\n+    # Additional partial substitution to test mixed behavior\n+    g_mixed = 3*x**2*U - x*U*z + 7*z**3 + 1\n+    assert f.as_expr(x, U, z) == g_mixed\n+\n     R, = ring(\"\", ZZ)\n     assert R(3).as_expr() == 3\n \n",
  "sympy__sympy-24661": "diff --git a/sympy/parsing/tests/test_sympy_parser.py b/sympy/parsing/tests/test_sympy_parser.py\nindex 3723931..5bc1efb 100644\n--- a/sympy/parsing/tests/test_sympy_parser.py\n+++ b/sympy/parsing/tests/test_sympy_parser.py\n@@ -270,6 +270,19 @@ def test_convert_equals_signs():\n     y = Symbol('y')\n     assert parse_expr(\"1*2=x\", transformations=transformations) == Eq(2, x)\n     assert parse_expr(\"y = x\", transformations=transformations) == Eq(y, x)\n+\n+def test_parse_expr_with_evaluate_false_for_relationals():\n+    inputs = {\n+        \"1 < 2\": Lt(1, 2, evaluate=False),\n+        \"1 <= 2\": Le(1, 2, evaluate=False),\n+        \"1 > 2\": Gt(1, 2, evaluate=False),\n+        \"1 >= 2\": Ge(1, 2, evaluate=False),\n+        \"1 != 2\": Ne(1, 2, evaluate=False),\n+        \"1 == 2\": Eq(1, 2, evaluate=False)\n+    }\n+    for text, expected in inputs.items():\n+        result = parse_expr(text, evaluate=False)\n+        assert result == expected, f\"Failed for input: {text}, got: {result}, expected: {expected}\"\n     assert parse_expr(\"(2*y = x) = False\",\n         transformations=transformations) == Eq(Eq(2*y, x), False)\n \n",
  "astropy__astropy-14369": "diff --git a/astropy/units/tests/test_format.py b/astropy/units/tests/test_format.py\nindex 062b5f4..eefc9f2 100644\n--- a/astropy/units/tests/test_format.py\n+++ b/astropy/units/tests/test_format.py\n@@ -84,6 +84,9 @@ def test_unit_grammar_fail(string):\n         ([\"Gyr\"], u.Gyr),\n         ([\"\u00b0\"], u.degree),\n         ([\"\u00b0/s\"], u.degree / u.s),\n+        # Test cases from the issue report\n+        ([\"10+3J/m/s/kpc2\"], u.Unit(1e3 * u.J / (u.m * u.s * u.kpc**2))),\n+        ([\"10-7J/s/kpc2\"], u.Unit(1e-7 * u.J / (u.s * u.kpc**2))),\n         ([\"\u00c5\"], u.AA),\n         ([\"\u00c5/s\"], u.AA / u.s),\n         ([\"\\\\h\"], si.h),\n",
  "astropy__astropy-14598": "",
  "django__django-11299": "",
  "django__django-11477": "diff --git a/tests/i18n/patterns/tests.py b/tests/i18n/patterns/tests.py\nindex e4898b6..04996a9 100644\n--- a/tests/i18n/patterns/tests.py\n+++ b/tests/i18n/patterns/tests.py\n@@ -148,8 +148,28 @@ class URLTranslationTests(URLTestCaseBase):\n \n         with translation.override('pt-br'):\n             self.assertEqual(reverse('users'), '/pt-br/usuarios/')\n+    from django.urls import resolve, re_path\n+    from django.utils.translation import gettext_lazy as _\n \n     def test_translate_url_utility(self):\n+        # Adding test cases for optional named groups\n+        with translation.override('en'):\n+            # Test case with missing optional group\n+            self.assertEqual(translate_url('/en/with-arguments/sample-arg/', 'nl'), '/nl/with-arguments/sample-arg/')\n+            # Test case when optional group is present\n+            self.assertEqual(translate_url('/en/with-arguments/sample-arg/extra.html', 'nl'), '/nl/with-arguments/sample-arg/extra.html')\n+\n+        # Resolving URLs to ensure capturing of optional parts\n+        def test_resolve_optional_groups(self):\n+            test_urls = [\n+                ('/regex_optional/1/2/', {'arg1': '1', 'arg2': '2'}),\n+                ('/regex_optional/1/', {'arg1': '1', 'arg2': None}),  # arg2 is optional\n+            ]\n+            for url, expected_kwargs in test_urls:\n+                with self.subTest(url=url):\n+                    match = resolve(url)\n+                    self.assertEqual(match.url_name, 'regex_optional')\n+                    self.assertEqual(match.kwargs, expected_kwargs)\n         with translation.override('en'):\n             self.assertEqual(translate_url('/en/nonexistent/', 'nl'), '/en/nonexistent/')\n             self.assertEqual(translate_url('/en/users/', 'nl'), '/nl/gebruikers/')\n",
  "django__django-12273": "diff --git a/tests/model_inheritance_regress/tests.py b/tests/model_inheritance_regress/tests.py\nindex d79faca..21b7d85 100644\n--- a/tests/model_inheritance_regress/tests.py\n+++ b/tests/model_inheritance_regress/tests.py\n@@ -1,4 +1,31 @@\n+\n \"\"\"\n+class ResetPrimaryKeyTestCase(TestCase):\n+    def setUp(self):\n+        # Create an instance of the Derived model\n+        self.derived_instance = Derived.objects.create(f=True)\n+\n+    def test_reset_primary_key_creates_new_instance(self):\n+        # Retrieve the derived object and reset it.\n+        derived_obj = Derived.objects.get(pk=self.derived_instance.pk)\n+        derived_obj.reset()\n+        derived_obj.save()\n+        \n+        # Verify that a new instance has been created.\n+        self.assertEqual(Derived.objects.count(), 2)\n+\n+    def test_original_instance_not_modified_after_reset(self):\n+        # The original instance should remain unchanged after resetting and saving the new one.\n+        Derived.objects.create(f=True)\n+        derived_obj_before_reset = Derived.objects.get(pk=self.derived_instance.pk)\n+        derived_obj_before_reset.reset()\n+        derived_obj_before_reset.save()\n+        derived_obj_after_reset = Derived.objects.get(pk=self.derived_instance.pk)\n+        \n+        # Ensure the original instance still exists and is unchanged\n+        self.assertTrue(derived_obj_after_reset.f)\n+        self.assertNotEqual(derived_obj_after_reset.pk, None)\n+\n Regression tests for Model inheritance behavior.\n \"\"\"\n import datetime\n@@ -13,7 +40,7 @@ from .models import (\n     DerivedM, InternalCertificationAudit, ItalianRestaurant, M2MChild,\n     MessyBachelorParty, ParkingLot, ParkingLot3, ParkingLot4A, ParkingLot4B,\n     Person, Place, Profile, QualityControl, Restaurant, SelfRefChild,\n-    SelfRefParent, Senator, Supplier, TrainStation, User, Wholesaler,\n+    SelfRefParent, Senator, Supplier, TrainStation, User, Wholesaler, Item, Derived,\n )\n \n \n",
  "django__django-12965": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 19cff3e..aa874ce 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -604,6 +604,32 @@ class DeletionTests(TestCase):\n                 signal.disconnect(receiver, sender=Referrer)\n \n \n+class IssueRegressionTests(TestCase):\n+\n+    def test_fast_delete_all(self):\n+        with self.assertNumQueries(1) as ctx:\n+            User.objects.all().delete()\n+        sql = ctx.captured_queries[0]['sql']\n+        # No subqueries are used when performing a full delete.\n+        self.assertNotIn('SELECT', sql)\n+    \n+    def test_delete_with_lock(self):\n+        # This test ensures that a subquery is not used in a DELETE statement, which would otherwise cause an error with MySQL's LOCK TABLE usage.\n+        with transaction.atomic(), connection.cursor() as cursor:\n+            cursor.execute(\"LOCK TABLES %s WRITE\" % connection.ops.quote_name(User._meta.db_table))\n+            with self.assertNumQueries(1) as ctx:\n+                User.objects.all().delete()\n+            sql = ctx.captured_queries[0]['sql']\n+            self.assertNotIn(\"SELECT\", sql)\n+            cursor.execute(\"UNLOCK TABLES\")\n+            \n+    def test_performance_regression(self):\n+        # This test validates that deleting 100,000 objects does not take an excessive amount of time\n+        User.objects.bulk_create(User() for _ in range(100000))\n+        with self.assertNumQueries(1) as ctx:\n+            with self.assertLessEqual(timeit.timeit(lambda: User.objects.all().delete(), number=1), 2):\n+                User.objects.all().delete()\n+\n class FastDeleteTests(TestCase):\n \n     def test_fast_delete_fk(self):\n@@ -702,4 +728,4 @@ class FastDeleteTests(TestCase):\n         origin = Origin.objects.create()\n         referer = Referrer.objects.create(origin=origin, unique_field=42)\n         with self.assertNumQueries(2):\n-            referer.delete()\n+            referer.delete()\n",
  "django__django-13023": "diff --git a/tests/model_fields/test_decimalfield.py b/tests/model_fields/test_decimalfield.py\nindex ab04b0d..5a2d179 100644\n--- a/tests/model_fields/test_decimalfield.py\n+++ b/tests/model_fields/test_decimalfield.py\n@@ -1,3 +1,4 @@\n+\n import unittest\n from decimal import Decimal\n \n@@ -25,7 +26,23 @@ class DecimalFieldTests(TestCase):\n         with self.assertRaisesMessage(ValidationError, msg):\n             f.to_python('abc')\n \n-    def test_default(self):\n+    def test_invalid_value(self):\n+        field = models.DecimalField(max_digits=4, decimal_places=2)\n+        msg = '\u201c%s\u201d value must be a decimal number.'\n+        tests = [\n+            (),\n+            [],\n+            {},\n+            set(),\n+            object(),\n+            complex(),\n+            'non-numeric string',\n+            b'non-numeric byte-string',\n+        ]\n+        for value in tests:\n+            with self.subTest(value=value):\n+                with self.assertRaisesMessage(ValidationError, msg % (value,)):\n+                    field.to_python(value)\n         f = models.DecimalField(default=Decimal('0.00'))\n         self.assertEqual(f.get_default(), Decimal('0.00'))\n \n",
  "django__django-13406": "diff --git a/tests/queryset_pickle/tests.py b/tests/queryset_pickle/tests.py\nindex d0a7de1..fad5307 100644\n--- a/tests/queryset_pickle/tests.py\n+++ b/tests/queryset_pickle/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import pickle\n \n@@ -259,8 +260,33 @@ class PickleabilityTestCase(TestCase):\n         event.edition_set.create()\n         self.assert_pickles(event.edition_set.order_by('event'))\n \n-\n-class InLookupTests(TestCase):\n+class PickleValuesTestCase(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        # Create some instances of the Toy model for testing\n+        Toy.objects.create(name='foo', price=10, material='wood')\n+        Toy.objects.create(name='bar', price=20, material='plastic')\n+        Toy.objects.create(name='baz', price=100, material='wood')\n+\n+    def test_pickle_values_correctness(self):\n+        prices = Toy.objects.values('material').annotate(total_price=Sum('price'))\n+        reloaded = Toy.objects.all()\n+        reloaded.query = pickle.loads(pickle.dumps(prices.query))\n+        # Ensure the types and values are correctly preserved after pickling and reloading\n+        self.assertIsInstance(reloaded[0], dict)\n+        original_data = list(prices)\n+        reloaded_data = list(reloaded)\n+        self.assertEqual(original_data, reloaded_data)\n+\n+    def test_pickle_values_list_correctness(self):\n+        prices_list = Toy.objects.values_list('material').annotate(total_price=Sum('price'))\n+        reloaded = Toy.objects.all()\n+        reloaded.query = pickle.loads(pickle.dumps(prices_list.query))\n+        # Ensure the types and values are correctly preserved after pickling and reloading\n+        self.assertIsInstance(reloaded[0], tuple)\n+        original_data = list(prices_list)\n+        reloaded_data = list(reloaded)\n+        self.assertEqual(original_data, reloaded_data)\n \n     @classmethod\n     def setUpTestData(cls):\n",
  "django__django-13449": "diff --git a/tests/expressions_window/models.py b/tests/expressions_window/models.py\nindex 3f59cdf..d9c7568 100644\n--- a/tests/expressions_window/models.py\n+++ b/tests/expressions_window/models.py\n@@ -11,4 +11,5 @@ class Employee(models.Model):\n     department = models.CharField(max_length=40, blank=False, null=False)\n     hire_date = models.DateField(blank=False, null=False)\n     age = models.IntegerField(blank=False, null=False)\n-    classification = models.ForeignKey('Classification', on_delete=models.CASCADE, null=True)\n+    classification = models.ForeignKey('Classification', on_delete=models.CASCADE, null=True)\n+    bonus = models.DecimalField(decimal_places=2, max_digits=15, null=True)\n",
  "django__django-13512": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex a61da37..14b5830 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -195,7 +195,21 @@ class UtilsTests(SimpleTestCase):\n                     display_value,\n                 )\n \n-    def test_number_formats_display_for_field(self):\n+    def test_unicode_json_display_for_field(self):\n+        unicode_tests = [\n+            ({'a': '\u4f60\u597d \u4e16\u754c'}, '{\"a\": \"\u4f60\u597d \u4e16\u754c\"}'),\n+            ({'a': '\ud83d\ude00\ud83d\udc31'}, '{\"a\": \"\ud83d\ude00\ud83d\udc31\"}'),\n+            (['\u4f60\u597d\uff0c\u4e16\u754c', 'ja\u017a\u0144'], '[\"\u4f60\u597d\uff0c\u4e16\u754c\", \"ja\u017a\u0144\"]'),\n+            ('\u4f60\u597d\uff0c\u4e16\u754c', '\"\u4f60\u597d\uff0c\u4e16\u754c\"'),\n+            ('\ud83d\ude00\ud83d\udc31', '\"\ud83d\ude00\ud83d\udc31\"'),\n+        ]\n+        \n+        for value, display_value in unicode_tests:\n+            with self.subTest(value=value):\n+                self.assertEqual(\n+                    display_for_field(value, models.JSONField(), self.empty_value),\n+                    display_value,\n+                )\n         display_value = display_for_field(12345.6789, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, '12345.6789')\n \n",
  "django__django-14404": "",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..e5cc6b1 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -655,6 +655,46 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(result.args, value.args)\n         self.assertEqual(result.keywords, value.keywords)\n \n+    def test_missing_model_import_in_migration(self):\n+        \"\"\"\n+        Test migration generation where a model base requires an import.\n+        \"\"\"\n+        # Simulate a model class structure similar to the issue description\n+        class MyField(models.TextField):\n+            pass\n+\n+        class MyBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        class MyMixin:\n+            pass\n+\n+        class MyModel(MyMixin, MyBaseModel):\n+            name = MyField(primary_key=True)\n+\n+        # Define migration using this model\n+        migration = type(\"Migration\", (migrations.Migration,), {\n+            \"operations\": [\n+                migrations.CreateModel(\n+                    name='MyModel',\n+                    fields=[\n+                        ('name', MyField(primary_key=True, serialize=False)),\n+                    ],\n+                    bases=(MyMixin, MyBaseModel),\n+                ),\n+            ],\n+        })\n+\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        \n+        # Check that the generated output imports `models` correctly\n+        self.assertIn(\"from django.db import models\", output)\n+        # Execute the generated migration to ensure it runs without errors\n+        result = self.safe_exec(output)\n+        self.assertIn(\"Migration\", result)\n+\n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n \n",
  "django__django-15375": "",
  "django__django-15695": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 99db46a..2e2d34a 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -2979,6 +2979,19 @@ class OperationTests(OperationTestBase):\n         )\n \n         new_state = project_state.clone()\n+\n+        # Test case to verify RenameIndex with unnamed index moving backward\n+        with connection.schema_editor() as editor:\n+            # Simulate unnamed index by dropping the explicit index\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+            # Re-apply renaming should not crash but use old auto-generated name\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n+\n+        # Second re-apply should still function correctly and not cause crashes\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n         operation.state_forwards(app_label, new_state)\n         # Rename index.\n         with connection.schema_editor() as editor:\n",
  "django__django-15732": "",
  "django__django-15916": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex cc5e08c..c48c1b9 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -3496,6 +3496,38 @@ class FormFieldCallbackTests(SimpleTestCase):\n                 type(NewForm.base_fields[name].widget),\n             )\n \n+    def test_modelform_factory_respects_meta_formfield_callback(self):\n+        def callback(db_field, **kwargs):\n+            formfield = db_field.formfield(**kwargs)\n+            formfield.required = True\n+            return formfield\n+\n+        class MetaCallbackForm(forms.ModelForm):\n+            class Meta:\n+                model = Person\n+                fields = [\"id\", \"name\"]\n+                formfield_callback = callback\n+\n+        FactoryForm = modelform_factory(model=Person, form=MetaCallbackForm)\n+        \n+        for field in FactoryForm.base_fields.values():\n+            self.assertTrue(field.required)\n+\n+    def test_modelform_factory_with_no_callbacks(self):\n+        class MetaCallbackForm(forms.ModelForm):\n+            class Meta:\n+                model = Person\n+                fields = [\"id\", \"name\"]\n+\n+        FactoryForm = modelform_factory(model=Person, form=MetaCallbackForm)\n+        \n+        for field in FactoryForm.base_fields.values():\n+            self.assertFalse(field.required)\n+\n+from django.test import TestCase\n+from django import forms\n+from django.forms import modelform_factory\n+from .models import Person, Triple  # Make sure these models are defined in your test models.\n \n class LocalizedModelFormTest(TestCase):\n     def test_model_form_applies_localize_to_some_fields(self):\n",
  "django__django-16938": "diff --git a/tests/serializers/test_json.py b/tests/serializers/test_json.py\nindex d77ef46..0c7489c 100644\n--- a/tests/serializers/test_json.py\n+++ b/tests/serializers/test_json.py\n@@ -7,7 +7,37 @@ from django.core import serializers\n from django.core.serializers.base import DeserializationError\n from django.core.serializers.json import DjangoJSONEncoder\n from django.db import models\n+from django.db import models\n+from django.core.serializers import serialize, DeserializationError\n from django.test import SimpleTestCase, TestCase, TransactionTestCase\n+\n+class TestTagMaster(models.Model):\n+    name = models.CharField(max_length=120)\n+\n+class TestTag(models.Model):\n+    name = models.CharField(max_length=120)\n+    master = models.ForeignKey(TestTagMaster, on_delete=models.SET_NULL, null=True)\n+\n+    class TestTagManager(models.Manager):\n+        def get_queryset(self):\n+            return super().get_queryset().select_related(\"master\")\n+\n+    objects = TestTagManager()\n+\n+class Test(models.Model):\n+    name = models.CharField(max_length=120)\n+    tags = models.ManyToManyField(TestTag, blank=True)\n+\n+class TestSerializationM2M(TestCase):\n+    def test_serialization_with_m2m_custom_manager(self):\n+        tag_master = TestTagMaster.objects.create(name=\"Master1\")\n+        tag = TestTag.objects.create(name=\"Tag1\", master=tag_master)\n+        test_obj = Test.objects.create(name=\"Test1\")\n+        test_obj.tags.add(tag)\n+        \n+        # Test if serialization raises error due to custom manager with select_related\n+        with self.assertRaisesMessage(Exception, \"FieldError: Field TestTag.master cannot be both deferred and traversed using select_related at the same time.\"):\n+            serialize(\"json\", [test_obj])\n from django.test.utils import isolate_apps\n from django.utils.translation import gettext_lazy, override\n \n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 53fdd55..174f6a0 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -206,8 +206,19 @@ def test_inset_and_secondary():\n def test_cmap(cmap):\n     pickle.dumps(cmap)\n \n+import pytest\n+import matplotlib.figure as mfigure\n \n-def test_unpickle_canvas():\n+def test_unpickle_figure_dpi():\n+    # This test is specific for M1 Mac issue where DPI doubles after unpickling\n+    initial_dpi = 100\n+    fig = mfigure.Figure(dpi=initial_dpi)\n+    for i in range(10):  # Unpickle 10 times and check dpi\n+        out = io.BytesIO()\n+        pickle.dump(fig, out)\n+        out.seek(0)\n+        fig = pickle.load(out)\n+        assert fig.dpi == initial_dpi, f\"DPI changed on unpickle {i+1}\"\n     fig = mfigure.Figure()\n     assert fig.canvas is not None\n     out = BytesIO()\n",
  "pydata__xarray-3993": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex 87375f2..50afc8e 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -6587,6 +6587,22 @@ def test_integrate(dask):\n \n     # along y\n     actual = da.integrate(\"y\")\n+    # Check using 'coord' consistently\n+    expected_y_coord = xr.DataArray(\n+        np.trapz(da, da[\"y\"], axis=1),\n+        dims=[\"x\"],\n+        coords={k: v for k, v in da.coords.items() if \"y\" not in v.dims},\n+    )\n+    actual_coord = da.integrate(coord=\"y\")\n+    assert_allclose(expected_y_coord, actual_coord.compute())\n+    assert_equal(actual_coord, ds.integrate(coord=\"y\")[\"var\"])\n+    assert_equal(ds[\"var\"].integrate(coord=\"y\"), ds.integrate(coord=\"y\")[\"var\"])\n+\n+    # with pytest.warns(FutureWarning):\n+    # test the deprecated behavior \n+    with pytest.warns(FutureWarning):\n+        actual_dim = da.integrate(dim=\"y\")\n+    assert_allclose(expected_y, actual_dim.compute())\n     expected_y = xr.DataArray(\n         np.trapz(da, da[\"y\"], axis=1),\n         dims=[\"x\"],\n",
  "pydata__xarray-4094": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex a2826fa..a1036d0 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -3044,8 +3044,14 @@ class TestDataset:\n         x0 = y[0].to_unstacked_dataset(\"features\")\n         d0 = D.isel(x=0)\n         assert_identical(d0, x0)\n-\n-    def test_to_stacked_array_to_unstacked_dataset_different_dimension(self):\n+    \n+    def test_to_stacked_array_single_dim_roundtrip(self):\n+        # single dimension: regression test for GH4049\n+        arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+        data = xr.Dataset({\"a\": arr, \"b\": arr})\n+        stacked = data.to_stacked_array(\"y\", sample_dims=[\"x\"])\n+        unstacked = stacked.to_unstacked_dataset(\"y\")\n+        assert_identical(unstacked, data)\n         # test when variables have different dimensionality\n         a, b = create_test_stacked_array()\n         sample_dims = [\"x\"]\n",
  "pylint-dev__pylint-8898": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex ae541fc..513447f 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -107,6 +107,39 @@ def test_unknown_yes_no(capsys: CaptureFixture) -> None:\n     assert \"Invalid yn value 'maybe', should be in \" in output.err\n \n \n+import re\n+from typing import Any\n+import pytest\n+from pylint.lint import Run\n+from pylint.config.argument import _regexp_csv_transfomer\n+\n+CSV_REGEX_COMMA_CASES = [\n+    (\"foo\", [\"foo\"]),\n+    (\"foo,bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar{1,3}\", [\"foo\", \"bar{1,3}\"]),\n+    # Test case for regex with a comma inside a quantifier (e.g., {1,3})\n+    (\"(foo{1,3})\", [\"(foo{1,3})\"]),\n+    (\"foo{2,4},bar{1,2}\", [\"foo{2,4}\", \"bar{1,2}\"]),\n+    # Edge cases\n+    (\"(foo{1,})\", [\"(foo{1,})\"]),  # infinite repetitions\n+]\n+\n+@pytest.mark.parametrize(\"in_string,expected\", CSV_REGEX_COMMA_CASES)\n+def test_csv_regex_comma_in_quantifier(in_string: str, expected: list[str]) -> None:\n+    \"\"\"Check that we correctly parse a comma-separated regex when there are one\n+    or more commas within quantifier expressions.\n+    \"\"\"\n+    def _template_run(in_string: str) -> list[re.Pattern[Any]]:\n+        r = Run(\n+            [str(EMPTY_MODULE), rf\"--bad-names-rgx={in_string}\"],\n+            exit=False,\n+        )\n+        bad_names_rgxs: list[re.Pattern[Any]] = r.linter.config.bad_names_rgxs\n+        return bad_names_rgxs\n+\n+    assert _template_run(in_string) == [re.compile(regex) for regex in expected]\n+\n def test_unknown_py_version(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly error on an unknown python-version.\"\"\"\n     with pytest.raises(SystemExit):\n",
  "pytest-dev__pytest-6197": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex d7aed6e..3bfd2d6 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1156,6 +1156,9 @@ def test_summary_list_after_errors(testdir):\n     )\n \n \n+import pytest\n+from _pytest.main import ExitCode\n+\n def test_importorskip():\n     with pytest.raises(\n         pytest.skip.Exception,\n@@ -1184,4 +1187,4 @@ def test_skip_package(testdir):\n \n     result = testdir.inline_run()\n     _, skipped, _ = result.listoutcomes()\n-    assert len(skipped) == 2\n+    assert len(skipped) == 2\n",
  "pytest-dev__pytest-7324": "diff --git a/testing/test_mark_expression.py b/testing/test_mark_expression.py\nindex 10b71e9..51bb366 100644\n--- a/testing/test_mark_expression.py\n+++ b/testing/test_mark_expression.py\n@@ -131,6 +131,7 @@ def test_syntax_errors(expr: str, column: int, message: str) -> None:\n         \"True\",\n         \"False\",\n         \"if\",\n+        \"None\",\n         \"else\",\n         \"while\",\n     ),\n",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..1abe069 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -259,4 +259,35 @@ def test_set_output_mro():\n     class C(A, B):\n         pass\n \n-    assert C().transform(None) == \"B\"\n+    assert C().transform(None) == \"B\"\n+\n+def test_feature_union_pandas_output():\n+    \"\"\"Test FeatureUnion with transformers when pandas output is specified\"\"\"\n+    import pandas as pd\n+    from sklearn.pipeline import FeatureUnion\n+    from sklearn.base import BaseEstimator, TransformerMixin\n+    from sklearn import set_config\n+\n+    class MyTransformer(BaseEstimator, TransformerMixin):\n+        def fit(self, X, y=None):\n+            return self\n+\n+        def transform(self, X):\n+            return X[\"value\"].groupby(X[\"date\"]).sum().to_frame()\n+\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+\n+    # Test with default output\n+    set_config(transform_output=\"default\")\n+    union_default = FeatureUnion([(\"my_transformer\", MyTransformer())])\n+    result_default = union_default.fit_transform(data)\n+    assert result_default.shape[0] == 4  # Four days aggregated\n+\n+    # Test with pandas output\n+    set_config(transform_output=\"pandas\")\n+    union_pandas = FeatureUnion([(\"my_transformer\", MyTransformer())])\n+    result_pandas = union_pandas.fit_transform(data)\n+    assert isinstance(result_pandas, pd.DataFrame)\n+    assert result_pandas.shape[0] == 4  # Four days aggregated\n",
  "sphinx-doc__sphinx-7454": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex a32a965..cd70e45 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -266,8 +266,16 @@ def test_parse_annotation():\n                           [pending_xref, \"int\"],\n                           [desc_sig_punctuation, \"]\"]))\n \n-\n-def test_pyfunction_signature(app):\n+def test_none_annotation_link():\n+    # Test if 'None' in type hints generates a correct reference\n+    doctree_description = _parse_annotation(\"None\")\n+    assert_node(doctree_description, ([pending_xref, \"None\"],))\n+    assert_node(doctree_description[0], pending_xref, refdomain=\"py\", reftype=\"obj\", reftarget=\"None\")\n+\n+    # Check if with `autodoc_typehints='signature'`, None is handled correctly\n+    doctree_signature = _parse_annotation(\" -> None\")\n+    assert_node(doctree_signature, ([pending_xref, \"None\"],))\n+    assert_node(doctree_signature[0], pending_xref, refdomain=\"py\", reftype=\"obj\", reftarget=\"None\")\n     text = \".. py:function:: hello(name: str) -> str\"\n     doctree = restructuredtext.parse(app, text)\n     assert_node(doctree, (addnodes.index,\n@@ -742,4 +750,3 @@ def test_modindex_common_prefix(app):\n                 IndexEntry('sphinx_intl', 0, 'index', 'module-sphinx_intl', '', '', '')])],\n         True\n     )\n-\n",
  "sphinx-doc__sphinx-8056": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 1d6a8cf..eb02a1a 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -2019,7 +2019,53 @@ definition_after_normal_text : int\n         actual = str(NumpyDocstring(docstring, config))\n         self.assertEqual(expected, actual)\n \n-    def test_token_type(self):\n+    def test_multiple_parameters(self):\n+        # Testing the original scenario without 'optional'\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        # Testing the scenario with 'optional'\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n+\"\"\"\n+        self.assertEqual(expected, actual)\n         tokens = (\n             (\"1\", \"literal\"),\n             (\"-4.6\", \"literal\"),\n",
  "sphinx-doc__sphinx-8551": "",
  "sphinx-doc__sphinx-8593": "",
  "sphinx-doc__sphinx-9230": "",
  "sphinx-doc__sphinx-9258": "",
  "sphinx-doc__sphinx-9673": "diff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex aa0401e..1026c84 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -834,6 +834,35 @@ def test_autodoc_typehints_description(app):\n             in context)\n \n \n+@pytest.mark.sphinx('text', testroot='ext-autodoc',\n+                    confoverrides={'autodoc_typehints': \"description\",\n+                                   'autodoc_typehints_description_target': 'documented',\n+                                   'napoleon_google_docstring': True,  # Enable Napoleon\n+                                   'napoleon_numpy_docstring': False})\n+def test_autodoc_typehints_description_target_with_napoleon(app):\n+    # Test that return types are included when using Google style with Napoleon\n+    (app.srcdir / 'index.rst').write_text(\n+        '.. autofunction:: target.typehints.example_func_with_docstring\\n'\n+        '\\n'\n+        '   :param param1: First parameter.\\n'\n+        '   :param param2: Second parameter.\\n'\n+        '   :returns: The returned value.\\n'\n+    )\n+    app.build()\n+    context = (app.outdir / 'index.txt').read_text()\n+    assert ('target.typehints.example_func_with_docstring(param1, param2)\\n'\n+            '\\n'\n+            '   Parameters:\\n'\n+            '      **param1** -- First parameter.\\n'\n+            '      **param2** -- Second parameter.\\n'\n+            '\\n'\n+            '   Returns:\\n'\n+            '      The returned value.\\n'\n+            '\\n'\n+            '   Return type:\\n'\n+            '      str\\n' in context)\n+\n+\n @pytest.mark.sphinx('text', testroot='ext-autodoc',\n                     confoverrides={'autodoc_typehints': \"description\",\n                                    'autodoc_typehints_description_target': 'documented'})\n",
  "sympy__sympy-18211": "diff --git a/sympy/solvers/tests/test_solveset.py b/sympy/solvers/tests/test_solveset.py\nindex 7bd9e29..d73dcb1 100644\n--- a/sympy/solvers/tests/test_solveset.py\n+++ b/sympy/solvers/tests/test_solveset.py\n@@ -1067,6 +1067,24 @@ def test_conditionset():\n     assert solveset(y**x-z, x, S.Reals) == \\\n         ConditionSet(x, Eq(y**x - z, 0), S.Reals)\n \n+def test_issue_18188():\n+    from sympy import Eq, cos, sin, Reals\n+    from sympy.sets.conditionset import ConditionSet\n+    from sympy.abc import n, x\n+\n+    # Test for the original issue equation\n+    result1 = Eq(n*cos(n) - 3*sin(n), 0)\n+    assert result1.as_set() == ConditionSet(n, Eq(n*cos(n) - 3*sin(n), 0), Reals)\n+\n+    # Additional tests to verify similar behavior\n+    result2 = Eq(x**2 + x*sin(x), 0)\n+    assert result2.as_set() == ConditionSet(x, Eq(x**2 + x*sin(x), 0), Reals)\n+\n+    result3 = Eq(x*cos(x) - sin(x), 0)\n+    assert result3.as_set() == ConditionSet(x, Eq(x*cos(x) - sin(x), 0), Reals)\n+\n+    result4 = Eq(n*cos(n) - 3*sin(n) + x, 0)\n+    assert result4.as_set() == ConditionSet(n, Eq(n*cos(n) - 3*sin(n) + x, 0), Reals)\n \n @XFAIL\n def test_conditionset_equality():\n",
  "sympy__sympy-18698": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex 38de6f6..7c520b6 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -3262,7 +3262,7 @@ def test_noncommutative():\n     c = 1/( 1 + y)\n     assert cancel(foo(e)) == foo(c)\n     assert cancel(e + foo(e)) == c + foo(c)\n-    assert cancel(e*foo(c)) == c*foo(c)\n+from sympy import symbols, sqf_list\n \n \n def test_to_rational_coeffs():\n@@ -3275,6 +3275,12 @@ def test_factor_terms():\n     assert factor_list(x*(x + y)) == (1, [(x, 1), (x + y, 1)])\n     assert sqf_list(x*(x + y)) == (1, [(x, 1), (x + y, 1)])\n \n+def test_issue_8695():\n+    x = symbols('x')\n+    p = (x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3\n+    result = (1, [(x**2 + 1, 1), (x - 1, 2), (x**2 - 5*x + 6, 3)])\n+    assert sqf_list(p) == result\n+\n \n def test_as_list():\n     # issue 14496\n",
  "sympy__sympy-19040": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex 6ddf041..4e7bdf7 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -3254,8 +3254,20 @@ def test_issue_5786():\n     assert expand(factor(expand(\n         (x - I*y)*(z - I*t)), extension=[I])) == -I*t*x - t*y + x*z - I*y*z\n \n-\n-def test_noncommutative():\n+def test_factor_with_extension_issue_18895():\n+    # Test for the issue where factor with extension=True drops a factor\n+    from sympy import I, symbols, expand\n+    from sympy.polys.polytools import factor\n+\n+    x, y = symbols('x y')\n+    z = expand((x - 1)*(y - 1))\n+       \n+    # Without extension\n+    assert factor(z) == (x - 1)*(y - 1)\n+\n+    # With extension\n+    factored_z = factor(z, extension=[I])\n+    assert factored_z == (x - 1)*(y - 1), f\"Expected (x - 1)*(y - 1), but got {factored_z}\"\n     class foo(Expr):\n         is_commutative=False\n     e = x/(x + x*y)\n",
  "sympy__sympy-20590": "",
  "sympy__sympy-24562": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\nindex 13e3235..7414860 100644\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -370,6 +370,8 @@ def test_Rational_new():\n     assert n.p == -2\n \n \n+from sympy import Rational\n+\n def test_Number_new():\n     \"\"\"\"\n     Test for Number constructor\n",
  "django__django-14534": "",
  "matplotlib__matplotlib-20676": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex b009975..75460d7 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -299,6 +299,54 @@ def test_tool_line_handle():\n         assert artist.get_animated()\n         assert artist.get_visible()\n \n+\n+@pytest.mark.parametrize('direction', (\"horizontal\", \"vertical\"))\n+def test_span_selector_bound(direction):\n+    fig, ax = plt.subplots(1, 1)\n+    ax.plot([10, 20], [10, 30])\n+    ax.figure.canvas.draw()\n+    x_bound = ax.get_xbound()\n+    y_bound = ax.get_ybound()\n+\n+    tool = widgets.SpanSelector(ax, print, direction, interactive=True)\n+    assert ax.get_xbound() == x_bound\n+    assert ax.get_ybound() == y_bound\n+\n+    bound = x_bound if direction == 'horizontal' else y_bound\n+    assert tool._edge_handles.positions == list(bound)\n+\n+    press_data = [10.5, 11.5]\n+    move_data = [11, 13]  # Updating selector is done in onmove\n+    release_data = move_data\n+    do_event(tool, 'press', xdata=press_data[0], ydata=press_data[1], button=1)\n+    do_event(tool, 'onmove', xdata=move_data[0], ydata=move_data[1], button=1)\n+\n+    assert ax.get_xbound() == x_bound\n+    assert ax.get_ybound() == y_bound\n+\n+    index = 0 if direction == 'horizontal' else 1\n+    handle_positions = [press_data[index], release_data[index]]\n+    assert tool._edge_handles.positions == handle_positions\n+\n+# Additional edge cases specific to the bug\n+@pytest.mark.parametrize('direction, data, expected_bounds', [\n+    (\"horizontal\", (5, 25), ((5, 25), (10, 30))),\n+    (\"horizontal\", (15, 15), ((10, 20), (10, 30))), # No change span is ineffective\n+    (\"vertical\", (7, 35), ((10, 20), (7, 35))),\n+])\n+def test_span_selector_no_zero_inclusion(direction, data, expected_bounds):\n+    fig, ax = plt.subplots(1, 1)\n+    ax.plot([10, 20], [10, 30])\n+    ax.figure.canvas.draw()\n+\n+    tool = widgets.SpanSelector(ax, print, direction, interactive=True)\n+    do_event(tool, 'press', xdata=data[0], ydata=data[1], button=1)\n+    do_event(tool, 'onmove', xdata=(data[0] + 1), ydata=(data[1] + 2), button=1)\n+    do_event(tool, 'release', xdata=(data[0] + 1), ydata=(data[1] + 2), button=1)\n+\n+    assert ax.get_xbound() == expected_bounds[0]\n+    assert ax.get_ybound() == expected_bounds[1]\n+\n     assert tool_line_handle.positions == positions\n \n \n",
  "scikit-learn__scikit-learn-12682": "diff --git a/sklearn/decomposition/tests/test_dict_learning.py b/sklearn/decomposition/tests/test_dict_learning.py\nindex 35a43f8..7aa2095 100644\n--- a/sklearn/decomposition/tests/test_dict_learning.py\n+++ b/sklearn/decomposition/tests/test_dict_learning.py\n@@ -51,6 +51,65 @@ def test_dict_learning_shapes():\n     assert_equal(dico.transform(X).shape, (X.shape[0], n_components))\n \n \n+def test_sparse_coder_max_iter_handling():\n+    \"\"\"Test if SparseCoder max_iter parameter influences convergence\"\"\"\n+\n+    def ricker_function(resolution, center, width):\n+        \"\"\"Discrete sub-sampled Ricker (Mexican hat) wavelet\"\"\"\n+        x = np.linspace(0, resolution - 1, resolution)\n+        x = ((2 / (np.sqrt(3 * width) * np.pi ** .25))\n+             * (1 - (x - center) ** 2 / width ** 2)\n+             * np.exp(-(x - center) ** 2 / (2 * width ** 2)))\n+        return x\n+\n+    def ricker_matrix(width, resolution, n_components):\n+        \"\"\"Dictionary of Ricker (Mexican hat) wavelets\"\"\"\n+        centers = np.linspace(0, resolution - 1, n_components)\n+        D = np.empty((n_components, resolution))\n+        for i, center in enumerate(centers):\n+            D[i] = ricker_function(resolution, center, width)\n+        D /= np.sqrt(np.sum(D ** 2, axis=1))[:, np.newaxis]\n+        return D\n+\n+    transform_algorithm = 'lasso_cd'\n+    resolution = 512\n+    subsampling = 4  # subsampling factor\n+    n_components = resolution // subsampling\n+\n+    # Compute a wavelet dictionary\n+    dictionary = np.r_[tuple(ricker_matrix(width=w, resolution=resolution,\n+                                           n_components=n_components // 5)\n+                             for w in (10, 50, 100, 200))]\n+\n+    # Create an input signal\n+    X = np.zeros((1, resolution))\n+    X[0, :resolution // 3] = np.linspace(3, 0, num=resolution // 3)\n+\n+    # Check that setting max_iter=1 makes convergence fail\n+    with pytest.warns(ConvergenceWarning):\n+        model = SparseCoder(dictionary, transform_algorithm=transform_algorithm,\n+                            transform_max_iter=1)\n+        model.fit_transform(X)\n+\n+    # Check that setting max_iter to a large value ensures convergence\n+    with pytest.warns(None) as record:\n+        model = SparseCoder(dictionary, transform_algorithm=transform_algorithm,\n+                            transform_max_iter=3000)\n+        model.fit_transform(X)\n+    assert not record.list\n+\n+    # Check if model still doesn't warn when changing max_iter slightly\n+    with pytest.warns(None) as record:\n+        model = SparseCoder(dictionary, transform_algorithm=transform_algorithm,\n+                            transform_max_iter=500)\n+        model.fit_transform(X)\n+    assert not record.list\n+\n+import pytest\n+import numpy as np\n+from sklearn.decomposition import DictionaryLearning, SparseCoder\n+from sklearn.exceptions import ConvergenceWarning\n+\n def test_dict_learning_overcomplete():\n     n_components = 12\n     dico = DictionaryLearning(n_components, random_state=0).fit(X)\n",
  "scikit-learn__scikit-learn-14629": "diff --git a/sklearn/tests/test_multioutput.py b/sklearn/tests/test_multioutput.py\nindex 4b401f3..a3f5864 100644\n--- a/sklearn/tests/test_multioutput.py\n+++ b/sklearn/tests/test_multioutput.py\n@@ -148,6 +148,24 @@ def test_multi_target_sample_weights():\n     assert_almost_equal(rgr.predict(X_test), rgr_w.predict(X_test))\n \n \n+import pytest\n+from sklearn.datasets import make_multilabel_classification\n+from sklearn.multioutput import MultiOutputClassifier\n+from sklearn.discriminant_analysis import LinearDiscriminantAnalysis\n+from sklearn.model_selection import cross_val_predict\n+\n+# Test for issue with cross_val_predict when using predict_proba on MultiOutputClassifier\n+def test_cross_val_predict_predict_proba_multioutput():\n+    X, Y = make_multilabel_classification(n_samples=100, n_features=20, n_classes=3, n_labels=2, random_state=42)\n+    mo_clf = MultiOutputClassifier(LinearDiscriminantAnalysis())\n+    # This should not raise an error\n+    pred_proba = cross_val_predict(mo_clf, X, Y, cv=5, method='predict_proba')\n+    assert len(pred_proba) == Y.shape[1]  # Predictions should be for each output\n+    for output_predictions in pred_proba:\n+        assert output_predictions.shape[0] == X.shape[0]\n+        # Each prediction should be a probability distribution over the classes\n+        assert np.allclose(output_predictions.sum(axis=1), 1)\n+\n # Import the data\n iris = datasets.load_iris()\n # create a multiple targets by randomized shuffling and concatenating y.\n",
  "sphinx-doc__sphinx-9658": "",
  "sympy__sympy-13551": "diff --git a/sympy/concrete/tests/test_products.py b/sympy/concrete/tests/test_products.py\nindex 1f1aaf7..edcd043 100644\n--- a/sympy/concrete/tests/test_products.py\n+++ b/sympy/concrete/tests/test_products.py\n@@ -347,8 +347,17 @@ def test_reverse_order():\n     assert Product(x*y, (x, a, b), (y, 2, 5)).reverse_order(y, x) == \\\n            Product(x*y, (x, b + 1, a - 1), (y, 6, 1))\n \n-\n-def test_issue_9983():\n+from sympy import Symbol, Product, S\n+from sympy.abc import n, k\n+\n+def test_issue_13546():\n+    n = Symbol('n', integer=True)\n+    k = Symbol('k', integer=True)\n+    p = Product(n + 1 / 2**k, (k, 0, n-1)).doit()\n+    # Check several values of n to ensure the product is computed correctly.\n+    assert p.subs(n, 2).doit() == S(15)/2\n+    assert p.subs(n, 3).doit() == S(175)/8\n+    assert p.subs(n, 4).doit() == S(11025)/128\n     n = Symbol('n', integer=True, positive=True)\n     p = Product(1 + 1/n**(S(2)/3), (n, 1, oo))\n     assert p.is_convergent() is S.false\n@@ -357,4 +366,4 @@ def test_issue_9983():\n \n def test_rewrite_Sum():\n     assert Product(1 - S.Half**2/k**2, (k, 1, oo)).rewrite(Sum) == \\\n-        exp(Sum(log(1 - 1/(4*k**2)), (k, 1, oo)))\n+        exp(Sum(log(1 - 1/(4*k**2)), (k, 1, oo)))\n"
}