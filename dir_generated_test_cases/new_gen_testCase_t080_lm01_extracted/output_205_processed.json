{
  "astropy__astropy-12907": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 88711b0..cf1526c 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -134,8 +134,20 @@ def test_separable(compound_model, result):\n     assert_allclose(is_separable(compound_model), result[0])\n     assert_allclose(separability_matrix(compound_model), result[1])\n \n-\n-def test_custom_model_separable():\n+def test_issue_nested_compound_model_separability():\n+    from astropy.modeling import models as m\n+    from astropy.modeling.separable import separability_matrix\n+    \n+    cm = m.Linear1D(10) & m.Linear1D(5)\n+    expected_cm = np.array([[True, False], [False, True]])\n+    assert_allclose(separability_matrix(cm), expected_cm)\n+\n+    cm_nested = m.Pix2Sky_TAN() & cm\n+    expected_cm_nested = np.array([[True, True, False, False],\n+                                   [True, True, False, False],\n+                                   [False, False, True, False],\n+                                   [False, False, False, True]])\n+    assert_allclose(separability_matrix(cm_nested), expected_cm_nested)\n     @custom_model\n     def model_a(x):\n         return x\n",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..e77e7ac 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,8 +1,46 @@\n+\n+def test_rst_with_header_rows():\n+    \"\"\"Round-trip a table with header_rows specified for RST format\"\"\"\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct     \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\",\n+    ]\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"wave\"].dtype == np.float64\n+    assert tbl[\"response\"].dtype == np.float32\n+    assert tbl[\"ints\"].dtype == np.int8\n+\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert out.getvalue().splitlines() == lines\n+\n+def test_rst_error_on_invalid_header_rows():\n+    \"\"\"Test to ensure error is raised on invalid header_rows for RST format\"\"\"\n+    tbl = QTable({'wave': [350, 950]*u.nm, 'response': [0.7, 1.2]*u.count})\n+    \n+    # This should raise an error because RST format does not support header_rows\n+    try:\n+        tbl.write(StringIO(), format=\"ascii.rst\", header_rows=[\"name\", \"unit\"])\n+    except TypeError as e:\n+        assert \"unexpected keyword argument 'header_rows'\" in str(e)\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n from io import StringIO\n \n from astropy.io import ascii\n+from io import StringIO\n+import numpy as np\n+import astropy.units as u\n+from astropy.table import QTable\n \n from .common import assert_almost_equal, assert_equal\n \n",
  "astropy__astropy-14365": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 9b66109..3c5e7a5 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -108,8 +108,53 @@ def test_roundtrip(tmp_path):\n     for meta_name in [\"initial_comments\", \"comments\"]:\n         assert meta_name in new_table.meta\n \n+import pytest\n+import numpy as np\n+from astropy.table import Table\n+from astropy.utils.exceptions import AstropyUserWarning\n+\n+def lowercase_header(value):\n+    \"\"\"Make every non-comment line lower case.\"\"\"\n+    lines = []\n+    for line in value.splitlines():\n+        if not line.startswith(\"!\"):\n+            line = line.lower()\n+        lines.append(line)\n+    return \"\\n\".join(lines)\n+\n \n-def test_read_example():\n+@pytest.mark.parametrize(\"lowercase\", [False, True])\n+def test_roundtrip_case_insensitivity(tmp_path, lowercase):\n+    example_qdp = \"\"\"\n+    ! Example QDP file\n+    READ SERR 1\n+    READ TERR 2\n+    ! Example data\n+    !x y yerr\n+    1.0 2.0 0.1\n+    2.0 3.5 0.2\n+    3.0 5.1 0.3\n+    NO NO NO\n+    \"\"\"\n+\n+    if lowercase:\n+        example_qdp = lowercase_header(example_qdp)\n+    \n+    path = str(tmp_path / \"test_case.qdp\")\n+\n+    with open(path, \"w\") as fp:\n+        fp.write(example_qdp)\n+\n+    with pytest.warns(AstropyUserWarning):\n+        table = Table.read(path, format='ascii.qdp')\n+\n+    assert \"x\" in table.colnames\n+    assert \"y\" in table.colnames\n+    assert \"yerr\" in table.colnames\n+    assert len(table) == 3\n+    assert np.isclose(table[\"yerr\"][0], 0.1)\n+    assert np.isclose(table[\"yerr\"][1], 0.2)\n+    assert np.isclose(table[\"yerr\"][2], 0.3)\n     example_qdp = \"\"\"\n         ! Initial comment line 1\n         ! Initial comment line 2\n",
  "astropy__astropy-14995": "diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py\nindex fc27f69..7639f07 100644\n--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py\n+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py\n@@ -28,6 +28,48 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n         return False\n \n \n+import numpy as np\n+from astropy.nddata import NDDataRef\n+import pytest\n+\n+def test_nddata_bitmask_arithmetic():\n+    # NDData.mask is usually assumed to be boolean, but could be\n+    # a bitmask. Ensure bitmask works:\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_masked = NDDataRef(array, mask=mask)\n+\n+    # multiply no mask by constant (no mask * no mask)\n+    assert nref_nomask.multiply(1.0, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply no mask by itself (no mask * no mask)\n+    assert nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply masked by constant (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(1.0, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by itself (mask * mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_masked, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by no mask (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_nomask, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # check bitwise logic still works\n+    other_mask = np.array([[64, 1, 0], [2, 1, 0], [8, 0, 2]])\n+    nref_mask_other = NDDataRef(array, mask=other_mask)\n+    np.testing.assert_equal(\n+        nref_mask_other.multiply(nref_masked, handle_mask=np.bitwise_or).mask,\n+        np.bitwise_or(mask, other_mask),\n+    )\n+\n # Test with Data covers:\n # scalars, 1D, 2D and 3D\n # broadcasting between them\n",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..81c7b67 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -254,6 +254,29 @@ class TestTableFunctions(FitsTestCase):\n \n         t.close()\n \n+    def test_fits_d_exponent_replacement(self):\n+        \"\"\"Test that 'E' is replaced by 'D' in exponent of floating-point numbers.\"\"\"\n+\n+        import numpy as np\n+        from astropy.io import fits\n+        from astropy.utils.data import get_pkg_data_filename\n+\n+        # Create a floating-point column with 'D' format\n+        data = np.array([1.23e4, 5.67e8], dtype=np.float64)\n+        col = fits.Column(name='values', format='D', array=data)\n+        hdu = fits.BinTableHDU.from_columns([col])\n+        hdu.writeto(self.temp('test_d_exponent.fits'), overwrite=True)\n+\n+        # Read the FITS file and verify the 'D' in the exponent\n+        with open(self.temp('test_d_exponent.fits')) as f:\n+            content = f.read()\n+            assert '1.2300000000000000D+04' in content\n+            assert '5.6700000000000000D+08' in content\n+\n+        with fits.open(self.temp('test_d_exponent.fits')) as hdul:\n+            assert comparerecords(hdu.data, hdul[1].data)\n+            assert np.allclose(hdul[1].data['values'], data)\n+\n     def test_ascii_table(self):\n         # ASCII table\n         a = fits.open(self.data('ascii.fits'))\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..e6ae689 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1103,6 +1103,13 @@ class OverrideSettingsTests(SimpleTestCase):\n         with self.settings(FILE_UPLOAD_PERMISSIONS=0o777):\n             self.assertEqual(default_storage.file_permissions_mode, 0o777)\n \n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        The default FILE_UPLOAD_PERMISSIONS should be 0o644.\n+        \"\"\"\n+        with self.settings(FILE_UPLOAD_PERMISSIONS=None):\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n+\n     def test_override_file_upload_directory_permissions(self):\n         \"\"\"\n         Overriding the FILE_UPLOAD_DIRECTORY_PERMISSIONS setting should be\n",
  "django__django-10924": "",
  "django__django-11001": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 4e3940c..4588ad8 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -384,7 +384,34 @@ class BasicExpressionsTests(TestCase):\n         )\n         self.assertSequenceEqual(mustermanns_by_seniority, [self.max, mary])\n \n-    def test_outerref(self):\n+    def test_order_by_multiline_sql(self):\n+        # Create some sample data to test ordering\n+        example_inc = Company.objects.create(name='Example Inc', status='verification', accepted_datetime='2023-09-01', preferred_datetime='2023-09-02')\n+        gmbh = Company.objects.create(name='GmbH', status='accepted', accepted_datetime='2023-09-03', preferred_datetime='2023-09-04')\n+        foobar_ltd = Company.objects.create(name='Foobar Ltd', status='pending', created_at='2023-09-05')\n+\n+        raw_order_by = (\n+            RawSQL('''\n+                case when status in ('accepted', 'verification')\n+                     then 2 else 1 end''', []).desc(),\n+            RawSQL('''\n+                case when status in ('accepted', 'verification')\n+                     then (accepted_datetime, preferred_datetime)\n+                     else null end''', []).asc(),\n+            RawSQL('''\n+                case when status not in ('accepted', 'verification')\n+                     then (accepted_datetime, preferred_datetime, created_at)\n+                     else null end''', []).desc(),\n+        )\n+        for qs in (\n+            Company.objects.all(),\n+            Company.objects.distinct(),\n+        ):\n+            with self.subTest(qs=qs):\n+                self.assertSequenceEqual(\n+                    qs.order_by(*raw_order_by),\n+                    [example_inc, gmbh, foobar_ltd],\n+                )\n         inner = Company.objects.filter(point_of_contact=OuterRef('pk'))\n         msg = (\n             'This queryset contains a reference to an outer query and may only '\n",
  "django__django-11039": "",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..a2ce855 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -72,6 +72,7 @@ class TestValidation(SimpleTestCase):\n         with self.assertRaises(exceptions.ValidationError) as cm:\n             field.clean('not a datetime', None)\n         self.assertEqual(cm.exception.code, 'invalid')\n+        # Update the error message in the test to match the correct format\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n             \"'not a datetime' value has an invalid format. \"\n@@ -84,4 +85,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..922533e 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -248,7 +248,20 @@ class UsernameValidatorsTests(SimpleTestCase):\n                 with self.assertRaises(ValidationError):\n                     v(invalid)\n \n-    def test_ascii_validator(self):\n+    def test_newline_in_username(self):\n+        invalid_usernames = [\n+            \"username\\n\",  # newline at the end\n+            \"username\\r\\n\",  # carriage return + newline at the end\n+            \"normal\\nusername\"  # newline in the middle\n+        ]\n+        v_unicode = validators.UnicodeUsernameValidator()\n+        v_ascii = validators.ASCIIUsernameValidator()\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v_unicode(invalid)\n+                with self.assertRaises(ValidationError):\n+                    v_ascii(invalid)\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n         invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n         v = validators.ASCIIUsernameValidator()\n@@ -258,4 +271,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..36cb731 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -366,7 +366,23 @@ class HttpResponseTests(unittest.TestCase):\n         r.content = 12345\n         self.assertEqual(r.content, b'12345')\n \n-    def test_iter_content(self):\n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview'))\n+        self.assertEqual(r.content, b'memoryview')\n+        \n+    def test_memoryview_empty_content(self):\n+        r = HttpResponse(memoryview(b''))\n+        self.assertEqual(r.content, b'')\n+    \n+    def test_memoryview_large_content(self):\n+        large_content = memoryview(b'a' * 10**6)  # 1MB of data\n+        r = HttpResponse(large_content)\n+        self.assertEqual(r.content, b'a' * 10**6)\n+    \n+    def test_memoryview_non_byte_content(self):\n+        # This should raise an error, as memoryview expects bytes-like objects\n+        with self.assertRaises(TypeError):\n+            HttpResponse(memoryview(\"string\"))\n         r = HttpResponse(['abc', 'def', 'ghi'])\n         self.assertEqual(r.content, b'abcdefghi')\n \n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..18f4397 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,6 +1,8 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n+from django.db.models.deletion import Collector\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n@@ -464,7 +466,38 @@ class FastDeleteTests(TestCase):\n         # 1 to delete t, 1 to fast-delete t's m_set\n         self.assertNumQueries(2, f.delete)\n \n-    def test_fast_delete_qs(self):\n+    def test_fast_delete_instance_set_pk_none(self):\n+        u = User.objects.create()\n+        # User can be fast-deleted.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        u.delete()\n+        self.assertIsNone(u.pk)\n+\n+    def test_delete_instance_without_dependencies(self):\n+        # Create a model instance without dependencies\n+        simple_model = User.objects.create()\n+        # Delete the model instance\n+        simple_model.delete()\n+        # Check that the primary key is set to None\n+        self.assertIsNone(simple_model.pk)\n+\n+    def test_delete_instance_with_dependencies(self):\n+        # Create instances with dependencies\n+        avatar = Avatar.objects.create(desc='test')\n+        user_with_avatar = User.objects.create(avatar=avatar)\n+        # Delete the User instance\n+        user_with_avatar.delete()\n+        # Check that the primary key is set to None\n+        self.assertIsNone(user_with_avatar.pk)\n+\n+    def test_delete_instance_with_foreign_key(self):\n+        parent = Parent.objects.create(name='Parent')\n+        child = Child.objects.create(parent=parent, name='Child')\n+        # Delete the child instance\n+        child.delete()\n+        # Check that the primary key is set to None\n+        self.assertIsNone(child.pk)\n         u1 = User.objects.create()\n         u2 = User.objects.create()\n         self.assertNumQueries(1, User.objects.filter(pk=u1.pk).delete)\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..bbff1dc 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,9 +1,12 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n from django.contrib.auth.models import Permission, User\n from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n+from django.db.utils import IntegrityError\n+from django.test.utils import captured_stdout\n \n from .models import Proxy, UserProxy\n \n@@ -140,7 +143,68 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n-    def test_user_keeps_same_permissions_after_migrating_backward(self):\n+    def test_migrate_with_existing_target_permission(self):\n+        \"\"\"\n+        Test that migrating with existing target permissions doesn't cause duplicate issues.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='display_proxys',\n+            name='May display proxys information',\n+        )\n+        with captured_stdout() as stdout:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        self.assertIn('A problem arose migrating proxy model permissions', stdout.getvalue())\n+\n+    def test_update_proxy_permissions_no_duplicates(self):\n+        \"\"\"\n+        Test that running the update_proxy_permissions does not introduce duplicate permissions.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        # Create a permission that should exist after migration\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        try:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+            self.assertFalse(\n+                Permission.objects.filter(\n+                    content_type=proxy_model_content_type,\n+                    codename='add_proxy'\n+                ).count() > 1,\n+                \"Duplicate permissions were created\"\n+            )\n+        except IntegrityError:\n+            self.fail(\"IntegrityError raised due to duplicate permissions\")\n+\n+    def test_update_proxy_permissions_reverse(self):\n+        \"\"\"\n+        Test the reverse migration to ensure it reverts proxy permissions correctly.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        concrete_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=True)\n+\n+        # Simulate migration forward\n+        Permission.objects.create(\n+            content_type=concrete_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+\n+        # Now reverse the migration\n+        update_proxy_permissions.revert_proxy_model_permissions(apps, None)\n+\n+        # Check the permission is now back to the concrete content type\n+        self.assertTrue(Permission.objects.filter(content_type=concrete_model_content_type, codename='add_proxy').exists())\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n         user.user_permissions.add(self.custom_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..5dc83d5 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -20,6 +20,8 @@ from django.utils import autoreload\n from django.utils.autoreload import WatchmanUnavailable\n \n from .utils import on_macos_with_hfs\n+import sys\n+import os\n \n \n class TestIterModulesAndFiles(SimpleTestCase):\n@@ -72,7 +74,26 @@ class TestIterModulesAndFiles(SimpleTestCase):\n \n         self.assertFileFound(filename.absolute())\n \n-    def test_check_errors(self):\n+    def test_manage_py_detection(self):\n+        \"\"\"\n+        Ensure that changes to manage.py are detected by the StatReloader.\n+        \"\"\"\n+        # Create a temporary manage.py file\n+        filename = self.temporary_file('manage.py')\n+        filename.write_text(\"print('Initial content')\\n\")\n+\n+        # Import the module to simulate running the server\n+        with extend_sys_path(str(filename.parent)):\n+            self.import_and_cleanup('manage')\n+\n+        # Assert that the file is being watched by the autoreloader\n+        self.assertFileFound(filename)\n+\n+        # Simulate a change in manage.py\n+        filename.write_text(\"print('Updated content')\\n\")\n+\n+        # Assert that the autoreloader still tracks the file\n+        self.assertFileFound(filename)\n         \"\"\"\n         When a file containing an error is imported in a function wrapped by\n         check_errors(), gen_filenames() returns it.\n",
  "django__django-11583": "",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..ab00f55 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1,5 +1,22 @@\n import importlib\n import inspect\n+class ConverterHttp404Tests(SimpleTestCase):\n+    def test_technical_404_converter_raise_404(self):\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+            response = self.client.get('/path-post/1/')\n+            self.assertContains(response, 'Page not found', status_code=404)\n+\n+    @override_settings(DEBUG=True)\n+    def test_debug_technical_404_converter_raise_404(self):\n+        \"\"\"\n+        Test that when DEBUG is True, raising Http404 in a path converter's\n+        to_python method results in a technical 404 response.\n+        \"\"\"\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+            response = self.client.get('/path-post/1/')\n+            self.assertContains(response, 'Page not found', status_code=404)\n+            self.assertContains(response, 'Using the URLconf defined', status_code=404)\n+\n import os\n import re\n import sys\n@@ -10,6 +27,8 @@ from pathlib import Path\n from unittest import mock\n \n from django.core import mail\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n from django.core.files.uploadedfile import SimpleUploadedFile\n from django.db import DatabaseError, connection\n from django.shortcuts import render\n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..92945ce 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -334,6 +334,25 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_choices_max_length_too_small(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2, \n+                choices=[\n+                    ('ABC', 'Value Too Long'),  # 3 characters\n+                    ('OK', 'Good'),  # 2 characters\n+                ],\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n     @unittest.skipUnless(connection.vendor == 'mysql',\n                          \"Test valid only for MySQL\")\n     def test_too_long_char_field_under_mysql(self):\n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..c448c04 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -253,6 +253,28 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n \n     def test_serialize_enums(self):\n+        # Test that the Enum default value uses the name, not the translated value\n+        class TextTranslatedEnum(enum.Enum):\n+            GOOD = _('Good')\n+            BAD = _('Bad')\n+\n+        field = models.CharField(\n+            default=TextTranslatedEnum.GOOD,\n+            choices=[(m.value, m) for m in TextTranslatedEnum],\n+            max_length=128,\n+        )\n+\n+        # Serialize the field and ensure that the default uses the Enum name\n+        serialized = MigrationWriter.serialize(field)[0]\n+        expected_serialization = (\n+            \"models.CharField(choices=[\"\n+            \"('Good', migrations.test_writer.TextTranslatedEnum['GOOD']), \"\n+            \"('Bad', migrations.test_writer.TextTranslatedEnum['BAD'])], \"\n+            \"default=migrations.test_writer.TextTranslatedEnum['GOOD'], \"\n+            \"max_length=128)\"\n+        )\n+\n+        self.assertEqual(serialized, expected_serialization)\n         class TextEnum(enum.Enum):\n             A = 'a-value'\n             B = 'value-b'\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..bff1c25 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,3 +1,4 @@\n+\n import unittest\n from datetime import datetime\n \n@@ -316,7 +317,27 @@ class HttpDateProcessingTests(unittest.TestCase):\n         parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n-    def test_parsing_rfc850(self):\n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850(self, mocked_datetime):\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+        utcnow_1 = datetime(2019, 11, 6, 8, 49, 37)\n+        utcnow_2 = datetime(2020, 11, 6, 8, 49, 37)\n+        utcnow_3 = datetime(2048, 11, 6, 8, 49, 37)\n+        tests = (\n+            (utcnow_1, 'Tuesday, 31-Dec-69 08:49:37 GMT', datetime(2069, 12, 31, 8, 49, 37)),\n+            (utcnow_1, 'Tuesday, 10-Nov-70 08:49:37 GMT', datetime(1970, 11, 10, 8, 49, 37)),\n+            (utcnow_1, 'Sunday, 06-Nov-94 08:49:37 GMT', datetime(1994, 11, 6, 8, 49, 37)),\n+            (utcnow_2, 'Wednesday, 31-Dec-70 08:49:37 GMT', datetime(2070, 12, 31, 8, 49, 37)),\n+            (utcnow_2, 'Friday, 31-Dec-71 08:49:37 GMT', datetime(1971, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Sunday, 31-Dec-00 08:49:37 GMT', datetime(2000, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Friday, 31-Dec-99 08:49:37 GMT', datetime(1999, 12, 31, 8, 49, 37)),\n+        )\n+        for utcnow, rfc850str, expected_date in tests:\n+            with self.subTest(rfc850str=rfc850str):\n+                mocked_datetime.utcnow.return_value = utcnow\n+                parsed = parse_http_date(rfc850str)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n         parsed = parse_http_date('Sunday, 06-Nov-94 08:49:37 GMT')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..6a06bc1 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -40,7 +40,15 @@ class Gender(models.TextChoices):\n     __empty__ = '(Undeclared)'\n \n \n+from django.db import models\n+\n class ChoicesTests(SimpleTestCase):\n+    def test_enum_value_str_representation(self):\n+        # This test checks if the string representation of the enum value is as expected\n+        for enum_class in [Gender, YearInSchool]:\n+            for member in enum_class:\n+                with self.subTest(member=member):\n+                    self.assertEqual(str(member), member.value)\n     def test_integerchoices(self):\n         self.assertEqual(Suit.choices, [(1, 'Diamond'), (2, 'Spade'), (3, 'Heart'), (4, 'Club')])\n         self.assertEqual(Suit.labels, ['Diamond', 'Spade', 'Heart', 'Club'])\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..44e904a 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -148,7 +148,20 @@ class ChoicesTests(SimpleTestCase):\n                 self.assertIsInstance(field.formfield(), forms.ChoiceField)\n \n \n+from django.test import TestCase\n+from django.db import models\n+\n class GetFieldDisplayTests(SimpleTestCase):\n+    \n+    def test_overriding_get_FIELD_display(self):\n+        class FooBar(models.Model):\n+            foo_bar = models.IntegerField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                return 'something'\n+\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), 'something')\n \n     def test_choices_and_field_display(self):\n         \"\"\"\n",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "diff --git a/tests/urlpatterns/path_urls.py b/tests/urlpatterns/path_urls.py\nindex 12487f2..888a533 100644\n--- a/tests/urlpatterns/path_urls.py\n+++ b/tests/urlpatterns/path_urls.py\n@@ -2,7 +2,11 @@ from django.urls import include, path, re_path\n \n from . import views\n \n+from django.urls import re_path\n+from . import views\n+\n urlpatterns = [\n+    re_path(r'^module/(?P<format>(html|json|xml))?/?$', views.modules, name='modules'),\n     path('articles/2003/', views.empty_view, name='articles-2003'),\n     path('articles/<int:year>/', views.empty_view, name='articles-year'),\n     path('articles/<int:year>/<int:month>/', views.empty_view, name='articles-year-month'),\n@@ -14,4 +18,4 @@ urlpatterns = [\n     re_path(r'^regex_optional/(?P<arg1>\\d+)/(?:(?P<arg2>\\d+)/)?', views.empty_view, name='regex_optional'),\n     path('', include('urlpatterns.more_urls')),\n     path('<lang>/<path:url>/', views.empty_view, name='lang-and-path'),\n-]\n+]\n",
  "django__django-12284": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex 7dc81d2..b1d4b26 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -1,3 +1,28 @@\n+\n+class BaseModel(models.Model):\n+    foo = models.CharField(max_length=254, choices=[('A', 'Base A'), ('B', 'Base B')])\n+\n+    class Meta:\n+        abstract = True\n+\n+class ChildModel(BaseModel):\n+    foo = models.CharField(max_length=254, choices=[('A', 'Child A'), ('B', 'Child B'), ('C', 'Child C')])\n+\n+class InheritedChoicesTestCase(TestCase):\n+    def test_inherited_choices(self):\n+        # Test that the overridden choices are used\n+        child_instance_a = ChildModel(foo='A')\n+        child_instance_b = ChildModel(foo='B')\n+        child_instance_c = ChildModel(foo='C')\n+\n+        self.assertEqual(child_instance_a.get_foo_display(), 'Child A')\n+        self.assertEqual(child_instance_b.get_foo_display(), 'Child B')\n+        self.assertEqual(child_instance_c.get_foo_display(), 'Child C')\n+\n+        # Test that an unknown value returns the value itself\n+        child_instance_unknown = ChildModel(foo='D')\n+        self.assertEqual(child_instance_unknown.get_foo_display(), 'D')\n+\n import pickle\n \n from django import forms\n",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..d96ebef 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,9 +1,10 @@\n+\n from django.core.checks import Error\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n     check_setting_languages, check_setting_languages_bidi,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, override_settings\n \n \n class TranslationCheckTests(SimpleTestCase):\n@@ -75,6 +76,26 @@ class TranslationCheckTests(SimpleTestCase):\n                     Error(msg % tag, id='translation.E003'),\n                 ])\n \n+    @override_settings(\n+        USE_I18N=True,\n+        LANGUAGES=[\n+            ('de', 'German'),\n+            ('es', 'Spanish'),\n+            ('fr', 'French'),\n+            ('ca', 'Catalan'),\n+            ('en', 'English'),\n+        ],\n+    )\n+    def test_no_error_on_available_base_language(self):\n+        valid_sublanguage_tests = [\n+            'de-at',  # Base language 'de' is available\n+            'fr-CA',  # Base language 'fr' is available\n+            'ca-ES-valencia',  # Base language 'ca' is available\n+        ]\n+        for tag in valid_sublanguage_tests:\n+            with self.subTest(tag), self.settings(LANGUAGE_CODE=tag):\n+                self.assertEqual(check_language_settings_consistent(None), [])\n+\n     def test_inconsistent_language_settings(self):\n         msg = (\n             'You have provided a value for the LANGUAGE_CODE setting that is '\n",
  "django__django-12308": "",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..c11351c 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,3 +1,77 @@\n+\n+class TestDeserializeDbFromString(SimpleTestCase):\n+    databases = {'default'}\n+\n+    def test_circular_reference(self):\n+        # deserialize_db_from_string() handles circular references.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj_ref\": 1, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get(pk=1)\n+        obj_ref = ObjectReference.objects.get(pk=1)\n+        self.assertEqual(obj.obj_ref, obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n+\n+    def test_non_circular_reference(self):\n+        # Test deserialization with non-circular references.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 2,\n+                \"fields\": {\"obj\": null}\n+            },\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 2,\n+                \"fields\": {\"obj_ref\": 2, \"related_objects\": []}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get(pk=2)\n+        obj_ref = ObjectReference.objects.get(pk=2)\n+        self.assertEqual(obj.obj_ref, obj_ref)\n+        self.assertIsNone(obj_ref.obj)\n+\n+    def test_invalid_reference(self):\n+        # Test deserialization with invalid references should not raise errors.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 3,\n+                \"fields\": {\"obj_ref\": null, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 3,\n+                \"fields\": {\"obj\": 3}\n+            }\n+        ]\n+        \"\"\"\n+        try:\n+            connection.creation.deserialize_db_from_string(data)\n+        except Exception as e:\n+            self.fail(f\"Deserialization raised an exception: {e}\")\n+\n+        obj = Object.objects.get(pk=3)\n+        obj_ref = ObjectReference.objects.get(pk=3)\n+        self.assertIsNone(obj.obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n+\n import copy\n from unittest import mock\n \n@@ -5,7 +79,8 @@ from django.db import DEFAULT_DB_ALIAS, connection, connections\n from django.db.backends.base.creation import (\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, TestCase\n+from ..models import Object, ObjectReference\n \n \n def get_connection_copy():\n",
  "django__django-12497": "diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 057ec3a..50773bf 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -159,7 +159,34 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n-    def test_relationship_model_with_foreign_key_to_wrong_model(self):\n+    def test_ambiguous_relationship_model_foreign_key_hint(self):\n+        class Person(models.Model):\n+            pass\n+\n+        class Group(models.Model):\n+            field = models.ManyToManyField('Person', through=\"AmbiguousRelationship\")\n+\n+        class AmbiguousRelationship(models.Model):\n+            person = models.ForeignKey(Person, models.CASCADE)\n+            first_group = models.ForeignKey(Group, models.CASCADE, related_name='first')\n+            second_group = models.ForeignKey(Group, models.CASCADE, related_name='second')\n+\n+        field = Group._meta.get_field('field')\n+        self.assertEqual(field.check(from_model=Group), [\n+            Error(\n+                \"The model is used as an intermediate model by \"\n+                \"'invalid_models_tests.Group.field', but it has more than one \"\n+                \"foreign key from 'Group', which is ambiguous. You must \"\n+                \"specify which foreign key Django should use via the \"\n+                \"through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"AmbiguousRelationship\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n         class WrongModel(models.Model):\n             pass\n \n",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..2307cf5 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1248,8 +1248,77 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleanse_setting('SETTING_NAME', initial),\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n \n-    def test_request_meta_filtering(self):\n+    def test_cleanse_setting_nested_lists(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            \"nested_list\": [\n+                {\"foo\": \"value\", \"secret\": \"value\", \"token\": \"value\"},\n+                [\n+                    {\"foo\": \"value\", \"secret\": \"value\", \"token\": \"value\"},\n+                    {\"foo\": \"value\", \"secret\": \"value\", \"token\": \"value\"},\n+                ]\n+            ],\n+            \"another_layer\": [\n+                [\n+                    {\"key\": \"foo\", \"token\": \"value\"},\n+                    {\"key\": \"bar\", \"secret\": \"value\"}\n+                ]\n+            ]\n+        }\n+        cleansed = {\n+            \"nested_list\": [\n+                {\"foo\": \"value\", \"secret\": reporter_filter.cleansed_substitute, \"token\": reporter_filter.cleansed_substitute},\n+                [\n+                    {\"foo\": \"value\", \"secret\": reporter_filter.cleansed_substitute, \"token\": reporter_filter.cleansed_substitute},\n+                    {\"foo\": \"value\", \"secret\": reporter_filter.cleansed_substitute, \"token\": reporter_filter.cleansed_substitute},\n+                ]\n+            ],\n+            \"another_layer\": [\n+                [\n+                    {\"key\": \"foo\", \"token\": reporter_filter.cleansed_substitute},\n+                    {\"key\": \"bar\", \"secret\": reporter_filter.cleansed_substitute}\n+                ]\n+            ]\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n         self.assertEqual(\n",
  "django__django-12708": "",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..a5ae767 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -685,6 +685,26 @@ class FastDeleteTests(TestCase):\n         self.assertNumQueries(2, a.delete)\n         self.assertEqual(User.objects.count(), 0)\n \n+    def test_zero_deletions_with_foreign_keys(self):\n+        \"\"\"\n+        Test that QuerySet.delete() returns (0, {}) when zero objects are\n+        deleted from a model with foreign keys.\n+        \"\"\"\n+        # Assume ForeignModel is a model with foreign key relationships\n+        deleted, deleted_objs = ForeignModel.objects.filter(id=-1).delete()\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {})\n+\n+    def test_zero_deletions_without_foreign_keys(self):\n+        \"\"\"\n+        Test that QuerySet.delete() returns (0, {}) consistently when zero objects\n+        are deleted from a simple model without foreign keys.\n+        \"\"\"\n+        # Assume SimpleModel is a model without foreign key relationships\n+        deleted, deleted_objs = SimpleModel.objects.filter(id=-1).delete()\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {})\n+\n     def test_fast_delete_empty_no_update_can_self_select(self):\n         \"\"\"\n         #25932 - Fast deleting on backends that don't have the\n",
  "django__django-12856": "diff --git a/django/db/models/base.py b/django/db/models/base.py\nindex 7fb65b7..1967036 100644\n--- a/django/db/models/base.py\n+++ b/django/db/models/base.py\n@@ -1280,6 +1280,7 @@ class Model(metaclass=ModelBase):\n                 *cls._check_indexes(databases),\n                 *cls._check_ordering(),\n                 *cls._check_constraints(databases),\n+                *cls._check_unique_constraint_fields(),\n             ]\n \n         return errors\n",
  "django__django-12915": "diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex 72f5bd1..19a2e84 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -73,12 +73,61 @@ class ASGITest(SimpleTestCase):\n                 (b'Content-Disposition', b'inline; filename=\"urls.py\"'),\n             },\n         )\n+class TestASGIStaticFilesHandler(SimpleTestCase):\n+    async_request_factory = AsyncRequestFactory()\n+\n+    @modify_settings(INSTALLED_APPS={'append': 'django.contrib.staticfiles'})\n+    @override_settings(\n+        STATIC_URL='/static/',\n+        STATIC_ROOT=Path(__file__).parent / 'project' / 'static',\n+        STATICFILES_DIRS=[Path(__file__).parent / 'project' / 'static'],\n+        STATICFILES_FINDERS=[\n+            'django.contrib.staticfiles.finders.FileSystemFinder',\n+        ],\n+    )\n+    async def test_static_file_response(self):\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        # Construct HTTP request.\n+        scope = self.async_request_factory._base_scope(path='/static/file.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        # Get the file content.\n+        file_path = Path(__file__).parent / 'project' / 'static' / 'file.txt'\n+        with open(file_path, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+        # Read the response.\n+        stat = file_path.stat()\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', str(len(test_file_contents)).encode('ascii')),\n+                (b'Content-Type', b'text/plain'),\n+                (b'Content-Disposition', b'inline; filename=\"file.txt\"'),\n+                (b'Last-Modified', http_date(stat.st_mtime).encode('ascii')),\n+            },\n+        )\n         response_body = await communicator.receive_output()\n         self.assertEqual(response_body['type'], 'http.response.body')\n         self.assertEqual(response_body['body'], test_file_contents)\n         # Allow response.close() to finish.\n         await communicator.wait()\n \n+    async def test_get_async_response(self):\n+        request = self.async_request_factory.get('/static/test/file.txt')\n+        handler = ASGIStaticFilesHandler(ASGIHandler())\n+        response = await handler.get_response_async(request)\n+        response.close()\n+        self.assertEqual(response.status_code, 200)\n+\n+    async def test_get_async_response_not_found(self):\n+        request = self.async_request_factory.get('/static/test/not-found.txt')\n+        handler = ASGIStaticFilesHandler(ASGIHandler())\n+        response = await handler.get_response_async(request)\n+        self.assertEqual(response.status_code, 404)\n+\n     async def test_headers(self):\n         application = get_asgi_application()\n         communicator = ApplicationCommunicator(\n",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..63d5159 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -197,6 +197,17 @@ class TestUtilsText(SimpleTestCase):\n             ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True),\n             ('\u4f60\u597d', '\u4f60\u597d', True),\n             ('\u0130stanbul', 'istanbul', True),\n+            # Cases for leading/trailing dashes and underscores\n+            ('___This is a test ---', 'this-is-a-test', False),\n+            ('--strip-dash-value---', 'strip-dash-value', False),\n+            ('__strip__underscore-value___', 'strip-underscore-value', False),\n+            ('__strip-mixed-value---', 'strip-mixed-value', False),\n+            ('_ -strip-mixed-value _-', 'strip-mixed-value', False),\n+            # Additional edge cases\n+            ('_-_Leading and trailing_-_', 'leading-and-trailing', False),\n+            ('', '', False),  # Empty string case\n+            ('only-underscores___', 'only-underscores', False),\n+            ('___only-dashes---', 'only-dashes', False),\n         )\n         for value, output, is_unicode in items:\n             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n",
  "django__django-13028": "",
  "django__django-13158": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 070e08e..6b33704 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -1,3 +1,4 @@\n+\n import operator\n \n from django.db import DatabaseError, NotSupportedError, connection\n@@ -86,6 +87,12 @@ class QuerySetSetOperationTests(TestCase):\n         reserved_name = qs1.difference(qs2).values_list('name', 'order', 'id').get()\n         self.assertEqual(reserved_name[:2], ('a', 2))\n \n+    def test_union_with_none(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.filter(num__gte=8)\n+        union_qs = qs1.union(qs2)\n+        self.assertQuerysetEqual(union_qs.none(), [], transform=repr)\n+\n     def test_union_with_empty_qs(self):\n         qs1 = Number.objects.all()\n         qs2 = Number.objects.none()\n@@ -313,4 +320,4 @@ class QuerySetSetOperationTests(TestCase):\n                         NotSupportedError,\n                         msg % (operation, combinator),\n                     ):\n-                        getattr(getattr(qs, combinator)(qs), operation)()\n+                        getattr(getattr(qs, combinator)(qs), operation)()\n",
  "django__django-13230": "",
  "django__django-13315": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 64b15bf..d9523e1 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2817,6 +2817,73 @@ class LimitChoicesToTests(TestCase):\n \n     def test_fields_for_model_applies_limit_choices_to(self):\n         fields = fields_for_model(StumpJoke, ['has_fooled_today'])\n+\n+    @isolate_apps('model_forms')\n+    def test_limit_choices_to_no_duplicates(self):\n+        # Set up characters\n+        marley = Character.objects.create(username='Marley', last_action='2023-10-01')\n+        threepwood = Character.objects.create(username='Threepwood', last_action='2023-10-01')\n+\n+        # Create jokes associated with characters\n+        joke1 = StumpJoke.objects.create(funny=True, most_recently_fooled=threepwood)\n+        joke2 = StumpJoke.objects.create(funny=True, most_recently_fooled=threepwood)\n+        joke3 = StumpJoke.objects.create(funny=True, most_recently_fooled=marley)\n+        StumpJoke.objects.create(funny=False, most_recently_fooled=marley)\n+\n+        # Add relationships\n+        joke1.has_fooled_today.add(marley, threepwood)\n+        joke2.has_fooled_today.add(marley)\n+        joke3.has_fooled_today.add(marley, threepwood)\n+\n+        # Define model to test limit_choices_to\n+        class CharacterDetails(models.Model):\n+            character1 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_fk_1',\n+            )\n+            character2 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to={\n+                    'jokes__funny': True,\n+                    'jokes_today__funny': True,\n+                },\n+                related_name='details_fk_2',\n+            )\n+            character3 = models.ManyToManyField(\n+                Character,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_m2m_1',\n+            )\n+\n+        # Form for CharacterDetails\n+        class CharacterDetailsForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetails\n+                fields = '__all__'\n+\n+        # Create form instance and test for duplicate options\n+        form = CharacterDetailsForm()\n+        self.assertCountEqual(\n+            form.fields['character1'].queryset,\n+            [marley, threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character2'].queryset,\n+            [marley, threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character3'].queryset,\n+            [marley, threepwood],\n+        )\n         self.assertSequenceEqual(fields['has_fooled_today'].queryset, [self.threepwood])\n \n     def test_callable_called_each_time_form_is_instantiated(self):\n",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 536c423..460162d 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -1,6 +1,7 @@\n from django.contrib.contenttypes.fields import (\n     GenericForeignKey, GenericRelation,\n )\n+import pickle\n from django.contrib.contenttypes.models import ContentType\n from django.core.checks import Error\n from django.core.exceptions import FieldDoesNotExist, FieldError\n@@ -11,7 +12,35 @@ from django.test.utils import isolate_apps\n \n @isolate_apps('model_inheritance')\n class AbstractInheritanceTests(SimpleTestCase):\n-    def test_single_parent(self):\n+    def test_abstract_inherited_fields(self):\n+        \"\"\"Field instances from abstract models are not equal.\"\"\"\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritAbstractModel1(AbstractModel):\n+            pass\n+\n+        class InheritAbstractModel2(AbstractModel):\n+            pass\n+\n+        abstract_model_field = AbstractModel._meta.get_field('field')\n+        inherit1_model_field = InheritAbstractModel1._meta.get_field('field')\n+        inherit2_model_field = InheritAbstractModel2._meta.get_field('field')\n+\n+        self.assertNotEqual(abstract_model_field, inherit1_model_field)\n+        self.assertNotEqual(abstract_model_field, inherit2_model_field)\n+        self.assertNotEqual(inherit1_model_field, inherit2_model_field)\n+\n+        self.assertLess(abstract_model_field, inherit1_model_field)\n+        self.assertLess(abstract_model_field, inherit2_model_field)\n+        self.assertLess(inherit1_model_field, inherit2_model_field)\n+\n+        self.assertNotEqual(hash(abstract_model_field), hash(inherit1_model_field))\n+        self.assertNotEqual(hash(abstract_model_field), hash(inherit2_model_field))\n+        self.assertNotEqual(hash(inherit1_model_field), hash(inherit2_model_field))\n         class AbstractBase(models.Model):\n             name = models.CharField(max_length=30)\n \n@@ -347,4 +376,4 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('age', models.SmallIntegerField), ('concretemodel2_ptr', models.OneToOneField),\n                 ('name', models.CharField),\n             ]\n-        )\n+        )\n",
  "django__django-13447": "",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..b94e208 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,9 +1,11 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n from django.contrib.auth.models import User\n from django.contrib.auth.tokens import PasswordResetTokenGenerator\n from django.test import TestCase\n+from .models import CustomEmailField, IntegerUsernameUser\n from django.test.utils import ignore_warnings\n from django.utils.deprecation import RemovedInDjango40Warning\n \n",
  "django__django-13590": "",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..fd37306 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -28,6 +28,7 @@ from django.core.management.commands.testserver import (\n )\n from django.db import ConnectionHandler, connection\n from django.db.migrations.recorder import MigrationRecorder\n+from unittest import mock\n from django.test import (\n     LiveServerTestCase, SimpleTestCase, TestCase, override_settings,\n )\n",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..b9f040f 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,3 +1,4 @@\n+\n import sys\n import unittest\n from unittest import mock\n@@ -43,10 +44,45 @@ class ShellCommandTestCase(SimpleTestCase):\n         select.return_value = ([], [], [])\n         with self.assertRaisesMessage(CommandError, \"Couldn't import bpython interface.\"):\n             call_command('shell', interface='bpython')\n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n+\n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n \n     # [1] Patch select to prevent tests failing when when the test suite is run\n     # in parallel mode. The tests are run in a subprocess and the subprocess's\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 2d83d62..3802f2d 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -962,8 +962,58 @@ class TestReadOnlyChangeViewInlinePermissions(TestCase):\n         response = self.client.get(self.change_url)\n         self.assertNotContains(response, 'id=\"id_question_set-0-text\"')\n \n+admin_site = AdminSite()\n+\n \n @override_settings(ROOT_URLCONF='admin_inlines.urls')\n+class TestVerboseNameAndPluralInline(TestCase):\n+    factory = RequestFactory()\n+    superuser = None\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superuser = User.objects.create_superuser(\n+            username='superuser', password='secret', email='superuser@example.com'\n+        )\n+\n+    def setUp(self):\n+        self.client.login(username='superuser', password='secret')\n+\n+    def test_verbose_name_used_as_plural_when_plural_not_specified(self):\n+        class InlineWithoutVerboseNamePlural(TabularInline):\n+            model = Profile\n+            verbose_name = 'Singular Name'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [InlineWithoutVerboseNamePlural]\n+\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        self.assertContains(response, '<h2>Singular Names</h2>')\n+        self.assertNotContains(response, '<h2>Profiles</h2>')\n+        self.assertContains(response, 'Add another Singular Name')\n+\n+    def test_fallback_to_model_meta_verbose_name_if_inline_verbose_not_set(self):\n+        class InlineWithoutVerboseName(TabularInline):\n+            model = VerboseNameProfile\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [InlineWithoutVerboseName]\n+\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Assuming VerboseNameProfile model's Meta.verbose_name = 'Verbose Profile'\n+        # and Meta.verbose_name_plural = 'Verbose Profiles'\n+        self.assertContains(response, '<h2>Verbose Profiles</h2>')\n+        self.assertContains(response, 'Add another Verbose Profile')\n class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n     factory = RequestFactory()\n \n@@ -1071,8 +1121,58 @@ class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n         self.assertNotContains(response, '<h2>Model with both - plural name</h2>')\n         self.assertNotContains(response, 'Add another Model with both - name')\n \n+admin_site = AdminSite()\n+\n \n @override_settings(ROOT_URLCONF='admin_inlines.urls')\n+class TestVerboseNameAndPluralInline(TestCase):\n+    factory = RequestFactory()\n+    superuser = None\n+\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superuser = User.objects.create_superuser(\n+            username='superuser', password='secret', email='superuser@example.com'\n+        )\n+\n+    def setUp(self):\n+        self.client.login(username='superuser', password='secret')\n+\n+    def test_verbose_name_used_as_plural_when_plural_not_specified(self):\n+        class InlineWithoutVerboseNamePlural(TabularInline):\n+            model = Profile\n+            verbose_name = 'Singular Name'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [InlineWithoutVerboseNamePlural]\n+\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        self.assertContains(response, '<h2>Singular Names</h2>')\n+        self.assertNotContains(response, '<h2>Profiles</h2>')\n+        self.assertContains(response, 'Add another Singular Name')\n+\n+    def test_fallback_to_model_meta_verbose_name_if_inline_verbose_not_set(self):\n+        class InlineWithoutVerboseName(TabularInline):\n+            model = VerboseNameProfile\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [InlineWithoutVerboseName]\n+\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+\n+        # Assuming VerboseNameProfile model's Meta.verbose_name = 'Verbose Profile'\n+        # and Meta.verbose_name_plural = 'Verbose Profiles'\n+        self.assertContains(response, '<h2>Verbose Profiles</h2>')\n+        self.assertContains(response, 'Add another Verbose Profile')\n class SeleniumTests(AdminSeleniumTestCase):\n \n     available_apps = ['admin_inlines'] + AdminSeleniumTestCase.available_apps\n",
  "django__django-13757": "",
  "django__django-13768": "diff --git a/tests/dispatch/tests.py b/tests/dispatch/tests.py\nindex b1feefd..ae1be7d 100644\n--- a/tests/dispatch/tests.py\n+++ b/tests/dispatch/tests.py\n@@ -154,6 +154,36 @@ class DispatcherTests(SimpleTestCase):\n         result = a_signal.send_robust(sender=self, val='test')\n         self.assertEqual(result, [])\n \n+    def test_send_robust_logs_exception(self):\n+        import logging\n+        from django.dispatch import Signal\n+        from unittest.mock import patch\n+        from types import TracebackType\n+\n+        def fails(val, **kwargs):\n+            raise ValueError('this')\n+\n+        a_signal = Signal()\n+        a_signal.connect(fails)\n+\n+        with self.assertLogs('django.dispatch', level='ERROR') as cm:\n+            result = a_signal.send_robust(sender=self, val='test')\n+\n+        err = result[0][1]\n+        self.assertIsInstance(err, ValueError)\n+        self.assertEqual(err.args, ('this',))\n+        self.assertTrue(hasattr(err, '__traceback__'))\n+        self.assertIsInstance(err.__traceback__, TracebackType)\n+\n+        log_record = cm.records[0]\n+        self.assertEqual(log_record.getMessage(), 'Error calling fails in Signal.send_robust() (this)')\n+        self.assertIsNotNone(log_record.exc_info)\n+        _, exc_value, _ = log_record.exc_info\n+        self.assertIsInstance(exc_value, ValueError)\n+        self.assertEqual(str(exc_value), 'this')\n+\n+        a_signal.disconnect(fails)\n+\n     def test_send_robust_ignored_sender(self):\n         a_signal.connect(receiver_1_arg)\n         result = a_signal.send_robust(sender=self, val='test')\n",
  "django__django-13925": "",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..e61edf1 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -283,6 +283,19 @@ class FormsErrorMessagesTestCase(SimpleTestCase, AssertFormErrorsMixin):\n \n \n class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n+    def test_modelchoicefield_value_placeholder(self):\n+        f = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            },\n+        )\n+        self.assertFormErrors(\n+            ['\"invalid\" is not one of the available choices.'],\n+            f.clean,\n+            'invalid',\n+        )\n+\n     def test_modelchoicefield(self):\n         # Create choices for the model choice field tests below.\n         ChoiceModel.objects.create(pk=1, name='a')\n@@ -307,4 +320,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "diff --git a/tests/many_to_one/models.py b/tests/many_to_one/models.py\nindex 1078928..e5efc00 100644\n--- a/tests/many_to_one/models.py\n+++ b/tests/many_to_one/models.py\n@@ -81,7 +81,11 @@ class ToFieldChild(models.Model):\n     parent = models.ForeignKey(Parent, models.CASCADE, to_field='name', related_name='to_field_children')\n \n \n-# Multiple paths to the same model (#7110, #7125)\n+class ParentStringPrimaryKey(models.Model):\n+    name = models.CharField(primary_key=True, max_length=15)\n+\n+class ChildStringPrimaryKeyParent(models.Model):\n+    parent = models.ForeignKey(ParentStringPrimaryKey, on_delete=models.CASCADE)\n class Category(models.Model):\n     name = models.CharField(max_length=20)\n \n",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..4470a9d 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,9 +1,18 @@\n+\n from django.db.models import F, Q\n from django.test import SimpleTestCase\n \n \n class QTests(SimpleTestCase):\n-    def test_combine_and_empty(self):\n+    def test_q_with_dict_keys_and(self):\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q & Q(), q)\n+        self.assertEqual(Q() & q, q)\n+\n+    def test_q_with_dict_keys_or(self):\n+        q = Q(x__in={}.keys())\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n         q = Q(x=1)\n         self.assertEqual(q & Q(), q)\n         self.assertEqual(Q() & q, q)\n",
  "django__django-14017": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 707f339..39749b0 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -30,6 +30,7 @@ from django.test.utils import (\n )\n from django.utils.functional import SimpleLazyObject\n \n+from django.db.models import Q, Exists, OuterRef\n from .models import (\n     UUID, UUIDPK, Company, Employee, Experiment, Manager, Number,\n     RemoteEmployee, Result, SimulationRun, Time,\n@@ -794,6 +795,25 @@ class BasicExpressionsTests(TestCase):\n         )\n         self.assertCountEqual(qs, [self.example_inc.ceo, self.foobar_ltd.ceo, self.max])\n \n+    def test_boolean_expression_combined_with_Q_and_Exists_order(self):\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        \n+        # Test Q() & Exists() to ensure the TypeError is resolved\n+        try:\n+            result = Employee.objects.filter(Q() & Exists(is_ceo))\n+            self.assertCountEqual(result, [])\n+        except TypeError:\n+            self.fail(\"Q() & Exists() raised TypeError unexpectedly!\")\n+        \n+        try:\n+            result = Employee.objects.filter(Q() | Exists(is_ceo))\n+            self.assertCountEqual(result, [self.example_inc.ceo, self.foobar_ltd.ceo])\n+        except TypeError:\n+            self.fail(\"Q() | Exists() raised TypeError unexpectedly!\")\n+\n     def test_boolean_expression_combined(self):\n         is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n         is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n",
  "django__django-14155": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 0f968fa..a5d1610 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1128,6 +1128,26 @@ class ResolverMatchTests(SimpleTestCase):\n                 self.assertEqual(match[1], args)\n                 self.assertEqual(match[2], kwargs)\n \n+    @override_settings(ROOT_URLCONF='urlpatterns_reverse.urls')\n+    def test_repr_functools_partial(self):\n+        tests = [\n+            ('partial', 'template.html'),\n+            ('partial_nested', 'nested_partial.html'),\n+            ('partial_wrapped', 'template.html'),\n+        ]\n+        for name, template_name in tests:\n+            with self.subTest(name=name):\n+                func_repr = (\n+                    f\"functools.partial({views.empty_view!r}, \"\n+                    f\"template_name='{template_name}')\"\n+                )\n+                self.assertEqual(\n+                    repr(resolve(f'/{name}/')),\n+                    f\"ResolverMatch(func={func_repr}, args=(), kwargs={{}}, \"\n+                    f\"url_name='{name}', app_names=[], namespaces=[], \"\n+                    f\"route='{name}/')\",\n+                )\n+\n     def test_resolver_match_on_request(self):\n         response = self.client.get('/resolver_match/')\n         resolver_match = response.resolver_match\n@@ -1146,6 +1166,11 @@ class ResolverMatchTests(SimpleTestCase):\n         )\n \n \n+import functools\n+from django.urls import resolve\n+from django.test import SimpleTestCase, override_settings\n+from . import views  # Assuming views is correctly imported from the right module\n+\n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n class ErroneousViewTests(SimpleTestCase):\n \n",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..9ecd401 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,4 +1,7 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n+from django.test import override_settings\n+from django.db import models\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n from django.test.utils import isolate_apps\n@@ -66,7 +69,27 @@ class TestDefaultPK(SimpleTestCase):\n             class Model(models.Model):\n                 pass\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n@@ -82,7 +105,27 @@ class TestDefaultPK(SimpleTestCase):\n \n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_m2m_default_auto_field_setting(self):\n         class M2MModel(models.Model):\n",
  "django__django-14382": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex afeed3e..f255078 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2197,7 +2197,15 @@ class StartApp(AdminScriptTestCase):\n                     \"make sure the directory is a valid identifier.\" % bad_target\n                 )\n \n-    def test_importable_target_name(self):\n+    def test_trailing_slash_in_target_app_directory_name(self):\n+        \"\"\"\n+        Test that providing a directory path with a trailing slash does not result in an error.\n+        \"\"\"\n+        app_dir = os.path.join(self.test_dir, 'apps', 'app1')\n+        os.makedirs(app_dir)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', 'app1', '')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n         _, err = self.run_django_admin(['startapp', 'app', 'os'])\n         self.assertOutput(\n             err,\n",
  "django__django-14411": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 331338c..805f41d 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,5 +1,7 @@\n import datetime\n import re\n+from django.forms import Form\n+from django.test import SimpleTestCase\n from unittest import mock\n \n from django.contrib.auth.forms import (\n@@ -1026,6 +1028,20 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n         self.assertFalse(field.has_changed('aaa', 'bbb'))\n \n \n+class ReadOnlyPasswordHashWidgetTest(SimpleTestCase):\n+    def test_label_does_not_contain_for_attribute(self):\n+        \"\"\"\n+        Test that the label for ReadOnlyPasswordHashWidget does not contain\n+        a 'for' attribute since it does not have a labelable element.\n+        \"\"\"\n+        class TestForm(Form):\n+            hash_field = ReadOnlyPasswordHashField()\n+\n+        form = TestForm()\n+        bound_field = form['hash_field']\n+        self.assertEqual(bound_field.field.widget.id_for_label('id'), None)\n+        self.assertEqual(bound_field.label_tag(), '<label>Hash field:</label>')\n+\n class AdminPasswordChangeFormTest(TestDataMixin, TestCase):\n \n     @mock.patch('django.contrib.auth.password_validation.password_changed')\n",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..1cad03d 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -655,6 +655,39 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(result.args, value.args)\n         self.assertEqual(result.keywords, value.keywords)\n \n+    def test_missing_import_in_generated_migration(self):\n+        \"\"\"\n+        Test that a migration with a custom model field and mixin correctly generates needed imports.\n+        \"\"\"\n+        from django.db import models\n+        from django.db.migrations.writer import MigrationWriter\n+        from django.db.migrations import Migration\n+\n+        class MyField(models.TextField):\n+            pass\n+\n+        class MyMixin:\n+            pass\n+\n+        class MyBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        class MyModel(MyMixin, MyBaseModel):\n+            name = MyField(primary_key=True)\n+\n+        # Simulate a migration that would be generated for MyModel\n+        writer = MigrationWriter(Migration(\"0001_initial\", \"myapp\"))\n+        writer.serialize = lambda obj: (\"'{}'\".format(obj.__name__), set())\n+        migration_file_contents, _ = writer.serialize_deconstructed(\n+            ('name', 'app.models.MyField(primary_key=True, serialize=False)'),\n+            bases=(MyMixin, models.Model),\n+            options={'abstract': False}\n+        )\n+\n+        # Check for the correct import statement for models\n+        self.assertIn(\"from django.db import models\", migration_file_contents)\n+\n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n \n",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..26a0241 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -336,7 +336,10 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at most 1 form.'])\n+        non_form_errors = formset.non_form_errors()\n+        self.assertEqual(non_form_errors, ['Please submit at most 1 form.'])\n+        # New test to check if the 'nonform' class is applied\n+        self.assertEqual(str(non_form_errors), '<ul class=\"errorlist nonform\"><li>Please submit at most 1 form.</li></ul>')\n \n     def test_formset_validate_min_flag(self):\n         \"\"\"\n@@ -358,7 +361,10 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, min_num=3, validate_min=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at least 3 forms.'])\n+        non_form_errors = formset.non_form_errors()\n+        self.assertEqual(non_form_errors, ['Please submit at least 3 forms.'])\n+        # New test to check if the 'nonform' class is applied\n+        self.assertEqual(str(non_form_errors), '<ul class=\"errorlist nonform\"><li>Please submit at least 3 forms.</li></ul>')\n \n     def test_formset_validate_min_unchanged_forms(self):\n         \"\"\"\n@@ -982,7 +988,10 @@ class FormsFormsetTestCase(SimpleTestCase):\n         }\n         formset = FavoriteDrinksFormSet(data, prefix='drinks')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n+        non_form_errors = formset.non_form_errors()\n+        self.assertEqual(non_form_errors, ['You may only specify a drink once.'])\n+        # New test to check if the 'nonform' class is applied\n+        self.assertEqual(str(non_form_errors), '<ul class=\"errorlist nonform\"><li>You may only specify a drink once.</li></ul>')\n \n     def test_formset_iteration(self):\n         \"\"\"Formset instances are iterable.\"\"\"\n",
  "django__django-14672": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex d9eaabe..1208679 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -31,6 +31,16 @@ class M2mThroughTests(TestCase):\n             attrgetter(\"name\")\n         )\n \n+    def test_through_fields_make_hashable(self):\n+        reverse_m2m = Event._meta.get_field('invitees')\n+        self.assertEqual(reverse_m2m.through_fields, ('event', 'invitee'))\n+\n+        inherited_reverse_m2m = PersonChild._meta.get_field('events_invited')\n+        self.assertEqual(inherited_reverse_m2m.through_fields, ('event', 'invitee'))\n+\n+        # Hash comparison to ensure through_fields is made hashable.\n+        self.assertEqual(hash(reverse_m2m), hash(inherited_reverse_m2m))\n+\n     def test_get_on_intermediate_model(self):\n         Membership.objects.create(person=self.jane, group=self.rock)\n \n",
  "django__django-14752": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex 7ef6d86..4405f2e 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -282,6 +282,45 @@ class AutocompleteJsonViewTests(AdminViewBasicTestCase):\n             'pagination': {'more': True},\n         })\n         # The second page of results.\n+\n+    def test_serialize_result(self):\n+        # Test that CustomAutocompleteJsonView correctly overrides serialize_result to add extra fields.\n+        class AutocompleteJsonSerializeResultView(AutocompleteJsonView):\n+            def serialize_result(self, obj, to_field_name):\n+                return {\n+                    **super().serialize_result(obj, to_field_name),\n+                    'posted': str(obj.posted),\n+                }\n+\n+        Question.objects.create(question='Question 1', posted=datetime.date(2021, 8, 9))\n+        Question.objects.create(question='Question 2', posted=datetime.date(2021, 8, 7))\n+\n+        request = self.factory.get(self.url, {'term': 'question', **self.opts})\n+        request.user = self.superuser\n+        response = AutocompleteJsonSerializeResultView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+        \n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [\n+                {'id': str(q.pk), 'text': q.question, 'posted': str(q.posted)}\n+                for q in Question.objects.order_by('-posted')\n+            ],\n+            'pagination': {'more': False},\n+        })\n+\n+    def test_default_serialize_result(self):\n+        # Test that the default serialize_result method does not include extra fields.\n+        request = self.factory.get(self.url, {'term': 'question', **self.opts})\n+        request.user = self.superuser\n+        response = AutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+\n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [{'id': str(q.pk), 'text': q.question} for q in Question.objects.all()],\n+            'pagination': {'more': False},\n+        })\n         request = self.factory.get(self.url, {'term': '', 'page': '2', **self.opts})\n         request.user = self.superuser\n         with model_admin(Question, PKOrderingQuestionAdmin):\n",
  "django__django-14787": "",
  "django__django-14855": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 507855b..ad93f68 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -5083,6 +5083,42 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase):\n     def test_user_password_change_limited_queryset(self):\n         su = User.objects.filter(is_superuser=True)[0]\n         response = self.client.get(reverse('admin2:auth_user_password_change', args=(su.pk,)))\n+\n+    def _test_readonly_foreignkey_links(self, admin_site):\n+        \"\"\"\n+        Helper method to test readonly ForeignKey links for a given admin site.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1',\n+            content='content',\n+            book=Book.objects.create(name='Book 1'),\n+        )\n+        language = Language.objects.create(iso='_40', name='Test')\n+        obj = ReadOnlyRelatedField.objects.create(\n+            chapter=chapter,\n+            language=language,\n+            user=self.superuser,\n+        )\n+        response = self.client.get(\n+            reverse(f'{admin_site}:admin_views_readonlyrelatedfield_change', args=(obj.pk,))\n+        )\n+        self.assertContains(\n+            response,\n+            reverse(f'{admin_site}:admin_views_language_change', args=(language.pk,)),\n+            msg_prefix=f\"Failed for admin site: {admin_site}\"\n+        )\n+\n+    def test_readonly_foreignkey_links_default_admin_site(self):\n+        \"\"\"\n+        Test readonly ForeignKey links on the default admin site.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('admin')\n+\n+    def test_readonly_foreignkey_links_custom_admin_site(self):\n+        \"\"\"\n+        Test readonly ForeignKey links on a custom admin site.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('site2')\n         self.assertEqual(response.status_code, 404)\n \n     def test_change_form_renders_correct_null_choice_value(self):\n",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..b5b2f20 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,9 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n@@ -346,7 +347,30 @@ class ModelChoiceFieldTests(TestCase):\n             field = forms.ModelChoiceField(Category.objects.order_by('-name'))\n             self.assertEqual('Entertainment', field.clean(self.c1.pk).name)\n \n-    def test_queryset_manager(self):\n+    def test_choice_value_hash(self):\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+        # Test that ModelChoiceIteratorValue is now hashable\n+        self.assertEqual(hash(value_1), hash(ModelChoiceIteratorValue(self.c1.pk, None)))\n+        self.assertNotEqual(hash(value_1), hash(value_2))\n+\n+    def test_choice_value_comparison(self):\n+        # Test that ModelChoiceIteratorValue can be compared correctly\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c1.pk, None)\n+        value_3 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+        self.assertTrue(value_1 == value_2)\n+        self.assertFalse(value_1 == value_3)\n+        self.assertTrue(value_1 != value_3)\n+\n+    def test_choice_value_in_dict(self):\n+        # Test that ModelChoiceIteratorValue can be used as a dictionary key\n+        choice_dict = {\n+            ModelChoiceIteratorValue(self.c1.pk, self.c1): 'Category 1',\n+            ModelChoiceIteratorValue(self.c2.pk, self.c2): 'Category 2',\n+        }\n+        self.assertEqual(choice_dict[ModelChoiceIteratorValue(self.c1.pk, None)], 'Category 1')\n+        self.assertEqual(choice_dict[ModelChoiceIteratorValue(self.c2.pk, None)], 'Category 2')\n         f = forms.ModelChoiceField(Category.objects)\n         self.assertEqual(len(f.choices), 4)\n         self.assertEqual(list(f.choices), [\n",
  "django__django-14999": "",
  "django__django-15061": "diff --git a/tests/forms_tests/field_tests/test_multivaluefield.py b/tests/forms_tests/field_tests/test_multivaluefield.py\nindex 53aee21..a2b70c5 100644\n--- a/tests/forms_tests/field_tests/test_multivaluefield.py\n+++ b/tests/forms_tests/field_tests/test_multivaluefield.py\n@@ -154,7 +154,11 @@ class MultiValueFieldTest(SimpleTestCase):\n             \"\"\",\n         )\n \n-    def test_form_as_table_data(self):\n+    def test_label_without_index_in_multivaluefield(self):\n+        form = ComplexFieldForm()\n+        rendered = form.as_table()\n+        self.assertIn('<label for=\"id_field1_0\">Field1:</label>', rendered)\n+        self.assertNotIn('<label for=\"id_field1\">Field1:</label>', rendered)\n         form = ComplexFieldForm({\n             'field1_0': 'some text',\n             'field1_1': ['J', 'P'],\n",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..a1a5d0b 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -107,7 +107,17 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n                 with self.assertRaisesMessage(ValidationError, msg):\n                     f.clean(value)\n \n-    def test_urlfield_clean_required(self):\n+    def test_urlfield_clean_invalid_issue_case(self):\n+        f = URLField()\n+        tests = [\n+            '////]@N.AN',  # Specific test case from the issue.\n+            '#@A.bO',     # Another test case mentioned in the original test patch.\n+        ]\n+        msg = \"'Enter a valid URL.'\"\n+        for value in tests:\n+            with self.subTest(value=value):\n+                with self.assertRaisesMessage(ValidationError, msg):\n+                    f.clean(value)\n         f = URLField()\n         msg = \"'This field is required.'\"\n         with self.assertRaisesMessage(ValidationError, msg):\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..b496147 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -197,7 +197,19 @@ class NonAggregateAnnotationTestCase(TestCase):\n         combined = int(test.pages + test.rating)\n         self.assertEqual(b.combined, combined)\n \n-    def test_empty_expression_annotation(self):\n+    def test_expression_wrapper_with_empty_list(self):\n+        # Test with ~Q(pk__in=[]) to ensure it doesn't crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=Book.objects.none()), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n         books = Book.objects.annotate(\n             selected=ExpressionWrapper(Q(pk__in=[]), output_field=BooleanField())\n         )\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..359c4aa 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,4 @@\n+\n import json\n import random\n \n@@ -163,6 +164,17 @@ class CookieTests(BaseTests, SimpleTestCase):\n         decoded_messages = json.loads(value, cls=MessageDecoder)\n         self.assertEqual(messages, decoded_messages)\n \n+    def test_extra_tags_serialization(self):\n+        \"\"\"\n+        Test that extra_tags='' is correctly serialized and deserialized\n+        without being transformed into None.\n+        \"\"\"\n+        storage = self.get_storage()\n+        message = Message(constants.INFO, \"Test message\", extra_tags=\"\")\n+        encoded_message = storage._encode(message)\n+        decoded_message = storage._decode(encoded_message)\n+        self.assertEqual(decoded_message.extra_tags, \"\")\n+\n     def test_safedata(self):\n         \"\"\"\n         A message containing SafeData is keeping its safe status when\n",
  "django__django-15388": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex 42ab5ba..93b1db5 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -50,7 +50,19 @@ class TemplateReloadTests(SimpleTestCase):\n             ]\n         )\n \n-    def test_get_template_directories(self):\n+    @override_settings(\n+        TEMPLATES=[{\n+            'DIRS': [ROOT],\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]\n+    )\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    def test_dev_server_restart_on_settings_change(self, mock_reset):\n+        \"\"\"Test that the dev server detects changes in settings.py and restarts.\"\"\"\n+        # Simulating a change in the settings.py file\n+        settings_path = Path(__file__).parent / 'settings.py'\n+        self.assertTrue(autoreload.template_changed(None, settings_path))\n+        mock_reset.assert_called_once()\n         self.assertSetEqual(\n             autoreload.get_template_directories(),\n             {\n@@ -59,7 +71,19 @@ class TemplateReloadTests(SimpleTestCase):\n             }\n         )\n \n-    @mock.patch('django.template.loaders.base.Loader.reset')\n+    @override_settings(\n+        TEMPLATES=[{\n+            'DIRS': [BASE_DIR],\n+            'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+        }]\n+    )\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    def test_no_restart_with_basedir_in_dirs(self, mock_reset):\n+        \"\"\"Test that the dev server does not restart with BASE_DIR in TEMPLATES DIRS.\"\"\"\n+        # Simulating a change in the settings.py file\n+        settings_path = Path(__file__).parent / 'settings.py'\n+        self.assertFalse(autoreload.template_changed(None, settings_path))\n+        mock_reset.assert_not_called()\n     def test_reset_all_loaders(self, mock_reset):\n         autoreload.reset_loaders()\n         self.assertEqual(mock_reset.call_count, 2)\n",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..67505cc 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -184,6 +185,35 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"\n+        Test handling of an empty string for the If-Modified-Since header.\n+        Ensure no exception is raised and the function behaves correctly.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=\"\", mtime=1))\n+    \n+    def test_was_modified_since_none_header(self):\n+        \"\"\"\n+        Test handling of a None value for the If-Modified-Since header.\n+        Ensure the function behaves correctly without raising exceptions.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=None, mtime=1))\n+\n+    def test_was_modified_since_invalid_date(self):\n+        \"\"\"\n+        Test handling of an invalid date string for the If-Modified-Since header.\n+        The function should handle it gracefully, possibly defaulting to modified.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=\"invalid-date\", mtime=1))\n+\n+    def test_was_modified_since_future_date(self):\n+        \"\"\"\n+        Test handling of a future date for the If-Modified-Since header.\n+        The function should return False, indicating that the resource has not been modified since the future date.\n+        \"\"\"\n+        future_date = http_date(9999999999)  # A date far in the future\n+        self.assertFalse(was_modified_since(header=future_date, mtime=1))\n+\n     def test_was_modified_since_fp(self):\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..2e4ce76 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,3 +1,4 @@\n+\n import os\n from io import StringIO\n from unittest import mock\n@@ -8,6 +9,7 @@ from django.apps import apps\n from django.core import management\n from django.core.checks import Tags\n from django.core.management import BaseCommand, CommandError, find_commands\n+from argparse import ArgumentDefaultsHelpFormatter\n from django.core.management.utils import (\n     find_command,\n     get_random_secret_key,\n@@ -411,7 +413,33 @@ class CommandTests(SimpleTestCase):\n         parser = BaseCommand().create_parser(\"prog_name\", \"subcommand\", epilog=epilog)\n         self.assertEqual(parser.epilog, epilog)\n \n-    def test_outputwrapper_flush(self):\n+    def test_command_help_formatting(self):\n+        \"\"\"\n+        Test that the help output of a command is formatted correctly.\n+        \"\"\"\n+        class TestCommand(BaseCommand):\n+            help = '''\n+            Import a contract from tzkt.\n+            Example usage:\n+                ./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\n+            '''\n+\n+        command = TestCommand()\n+        parser = command.create_parser(\"manage.py\", \"tzkt_import\")\n+        out = StringIO()\n+        with mock.patch('sys.stdout', new=out):\n+            parser.print_help()\n+        help_output = out.getvalue()\n+        \n+        expected_output = (\n+            \"usage: manage.py tzkt_import [-h]\\n\"\n+            \"\\n\"\n+            \"Import a contract from tzkt.\\n\"\n+            \"Example usage:\\n\"\n+            \"    ./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\\n\"\n+        )\n+        \n+        self.assertIn(expected_output, help_output)\n         out = StringIO()\n         with mock.patch.object(out, \"flush\") as mocked_flush:\n             management.call_command(\"outputwrapper\", stdout=out)\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..1734394 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,7 +1,10 @@\n+\n import os\n from datetime import datetime\n \n from django.test import SimpleTestCase\n+from django.core.serializers.json import DjangoJSONEncoder\n+import json\n from django.utils.functional import lazystr\n from django.utils.html import (\n     conditional_escape,\n@@ -211,7 +214,32 @@ class TestUtilsHtml(SimpleTestCase):\n             with self.subTest(arg=arg):\n                 self.assertEqual(json_script(arg, \"test_id\"), expected)\n \n-    def test_json_script_without_id(self):\n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"custom\": \"output\"}'\n+\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"custom\": \"output\"}</script>',\n+        )\n+    \n+    def test_json_script_default_behavior(self):\n+        data = {\"key\": \"value\"}\n+        self.assertHTMLEqual(\n+            json_script(data),\n+            '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n+        )\n+\n+    def test_json_script_with_id_and_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"id\": \"custom\"}'\n+\n+        self.assertHTMLEqual(\n+            json_script({}, element_id=\"test_id\", encoder=CustomDjangoJSONEncoder),\n+            '<script id=\"test_id\" type=\"application/json\">{\"id\": \"custom\"}</script>',\n+        )\n         self.assertHTMLEqual(\n             json_script({\"key\": \"value\"}),\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n",
  "django__django-15790": "diff --git a/tests/check_framework/test_templates.py b/tests/check_framework/test_templates.py\nindex 72e6cfe..3a5a10d 100644\n--- a/tests/check_framework/test_templates.py\n+++ b/tests/check_framework/test_templates.py\n@@ -103,6 +103,12 @@ class CheckTemplateStringIfInvalidTest(SimpleTestCase):\n         with self.settings(TEMPLATES=TEMPLATES):\n             self.assertEqual(check_string_if_invalid_is_string(None), [self.error1])\n \n+from django.test import override_settings\n+from django.core.checks import Error\n+from django.test import SimpleTestCase\n+from django.conf import settings\n+from collections import defaultdict\n+from copy import deepcopy\n \n class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n     @classmethod\n@@ -186,6 +192,39 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n                 ],\n             )\n \n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+            \"check_framework.template_test_apps.library_conflict_app\",\n+        ]\n+    )\n+    def test_conflict_with_libraries_in_templates_options(self):\n+        # Test when a conflicting template tag library is added via TEMPLATES['OPTIONS']['libraries']\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"my_tags\", \"library_conflict_app.templatetags.my_tags\"\n+                ),\n+                self.get_settings(\n+                    \"my_tags\", \"same_tags_app_1.templatetags.my_tags\"\n+                ),\n+            ]\n+        ):\n+            expected_error = Error(\n+                E003.msg.format(\n+                    \"'my_tags'\",\n+                    \"'check_framework.template_test_apps.library_conflict_app.\"\n+                    \"templatetags.my_tags', \"\n+                    \"'check_framework.template_test_apps.same_tags_app_1.\"\n+                    \"templatetags.my_tags'\",\n+                ),\n+                id=E003.id,\n+            )\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [expected_error],\n+            )\n+\n     def test_template_tags_with_different_library_name(self):\n         with self.settings(\n             TEMPLATES=[\n@@ -206,4 +245,4 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n         ]\n     )\n     def test_template_tags_with_different_name(self):\n-        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..2754f4d 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -398,9 +398,22 @@ class ProxyModelTests(TestCase):\n     def test_eq(self):\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n-\n-@override_settings(ROOT_URLCONF=\"proxy_models.urls\")\n-class ProxyModelAdminTests(TestCase):\n+from django.test import TestCase\n+from .models import AnotherModel, ProxyCustomModel\n+\n+class ProxyModelQueryTests(TestCase):\n+    def setUp(self):\n+        self.custom_instance = ProxyCustomModel.objects.create(name=\"Test Name\")\n+        self.another_instance = AnotherModel.objects.create(custom=self.custom_instance)\n+\n+    def test_select_related_only_on_proxy_model(self):\n+        # This test tries to reproduce the original issue described\n+        try:\n+            objs = list(AnotherModel.objects.select_related(\"custom\").only(\"custom__name\").all())\n+            # If no exception is raised, we consider the issue resolved.\n+            self.assertTrue(True)\n+        except ValueError as e:\n+            self.fail(f\"select_related().only() on proxy models raised an error: {e}\")\n     @classmethod\n     def setUpTestData(cls):\n         cls.superuser = AuthUser.objects.create(is_superuser=True, is_staff=True)\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..7239a18 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -152,6 +152,10 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         )\n \n     def test_parameters(self):\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"SELECT * FROM some_table;\"]),\n+            ([\"psql\", \"-c\", \"SELECT * FROM some_table;\", \"dbname\"], None),\n+        )\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n             ([\"psql\", \"dbname\", \"--help\"], None),\n@@ -183,4 +187,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 44ea946..a4efdc1 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1901,6 +1901,14 @@ class AllValidTests(SimpleTestCase):\n class DeprecationTests(SimpleTestCase):\n     def test_warning(self):\n         from django.forms.utils import DEFAULT_TEMPLATE_DEPRECATION_MSG\n+        from django.forms.formsets import BaseFormSet, formset_factory\n+        from django.test import SimpleTestCase\n+        from django.utils.decorators import method_decorator\n+        from django.test.utils import override_settings\n+        from django.core.exceptions import ImproperlyConfigured\n+        from django.utils.cache import isolate_lru_cache\n+        from django.forms.renderers import get_default_renderer\n+        import warnings\n \n         with isolate_lru_cache(get_default_renderer), self.settings(\n             FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n@@ -1909,4 +1917,4 @@ class DeprecationTests(SimpleTestCase):\n         ):\n             ChoiceFormSet = formset_factory(Choice)\n             formset = ChoiceFormSet()\n-            str(formset)\n+            str(formset)\n",
  "django__django-16041": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex a34f3d3..d571d1a 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -179,7 +179,19 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertTrue(hasattr(formset.empty_form, \"custom_kwarg\"))\n         self.assertEqual(formset.empty_form.custom_kwarg, 1)\n \n-    def test_formset_validation(self):\n+    def test_empty_permitted_true_empty_form(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        formset = FormSet(form_kwargs={\"empty_permitted\": True})\n+        # Since empty_form shouldn't care about empty_permitted, it should have its default.\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n+\n+    def test_empty_permitted_key_error(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        try:\n+            formset = FormSet(form_kwargs={\"empty_permitted\": False})\n+            formset.empty_form  # Accessing empty_form should not raise KeyError\n+        except KeyError:\n+            self.fail(\"Accessing empty_form raised KeyError unexpectedly\")\n         # FormSet instances can also have an error attribute if validation failed for\n         # any of the forms.\n         formset = self.make_choiceformset([(\"Calexico\", \"\")])\n",
  "django__django-16046": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 41aae41..eb31a2d 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -1,3 +1,4 @@\n+\n from decimal import Decimal\n from sys import float_info\n \n@@ -160,7 +161,13 @@ class TestNumberFormat(SimpleTestCase):\n                     nformat(Decimal(value), \".\", decimal_pos), expected_value\n                 )\n \n-    def test_decimal_subclass(self):\n+    def test_empty_string(self):\n+        # Test case for an empty string\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        \n+    def test_none(self):\n+        # Test case for None\n+        self.assertEqual(nformat(None, \".\"), \"None\")\n         class EuroDecimal(Decimal):\n             \"\"\"\n             Wrapper for Decimal which prefixes each amount with the \u20ac symbol.\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..e3190e5 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -24,6 +25,7 @@ from django.forms.fields import CharField, Field, IntegerField\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.utils import translation\n from django.utils.text import capfirst\n+from django.urls import reverse\n from django.utils.translation import gettext as _\n \n from .models.custom_user import (\n@@ -892,6 +894,26 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # value to render correctly\n         self.assertEqual(form.initial[\"password\"], form[\"password\"].value())\n \n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search(r'<a href=\"(.*?)\">', password_help_text)\n+\n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.username,),\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n     def test_custom_form(self):\n         class CustomUserChangeForm(UserChangeForm):\n             class Meta(UserChangeForm.Meta):\n",
  "django__django-16255": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 1469efd..821d7b5 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -507,9 +507,38 @@ class HTTPSitemapTests(SitemapTestsBase):\n         self.assertXMLEqual(index_response.content.decode(), expected_content_index)\n         self.assertXMLEqual(sitemap_response.content.decode(), expected_content_sitemap)\n \n-\n-# RemovedInDjango50Warning\n-class DeprecatedTests(SitemapTestsBase):\n+from django.test import TestCase\n+from django.contrib.sitemaps import Sitemap\n+from django.urls import path\n+from django.contrib.sitemaps.views import index\n+\n+class CallableLastmodNoItemsSitemap(Sitemap):\n+    location = \"/location/\"\n+\n+    def items(self):\n+        return []\n+\n+    def lastmod(self, obj):\n+        return obj.lastmod\n+\n+class SitemapTests(TestCase):\n+    def test_callable_sitemod_no_items(self):\n+        callable_lastmod_no_items_sitemap = {\n+            \"callable-lastmod\": CallableLastmodNoItemsSitemap,\n+        }\n+        # Simulating a request to the sitemap index view with the sitemap\n+        response = self.client.get(\"/callable-lastmod-no-items/index.xml\")\n+        # Assert that the response does not contain a Last-Modified header\n+        self.assertNotIn(\"Last-Modified\", response)\n+        # Define the expected XML content of the sitemap index\n+        expected_content_index = (\n+            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n+            '<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\\n'\n+            '    <sitemap><loc>http://example.com/simple/sitemap-callable-lastmod.xml</loc></sitemap>\\n'\n+            '</sitemapindex>'\n+        )\n+        # Assert that the response content matches the expected XML content\n+        self.assertXMLEqual(response.content.decode(), expected_content_index)\n     @override_settings(\n         TEMPLATES=[\n             {\n",
  "django__django-16379": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 014d28a..1df8e1a 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1,3 +1,4 @@\n+\n # Unit tests for cache framework\n # Uses whatever cache backend is set in the test settings file.\n import copy\n@@ -9,6 +10,8 @@ import shutil\n import sys\n import tempfile\n import threading\n+import unittest\n+from unittest import mock\n import time\n import unittest\n from pathlib import Path\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..3ef0759 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -10,7 +11,8 @@ from django.urls import reverse\n \n from .admin import ArticleAdmin, site\n from .models import Article, Question\n-from .tests import AdminViewBasicTestCase\n+from django.contrib.auth import get_permission_codename\n+from .tests import AdminViewBasicTestCase, get_perm\n \n \n class AdminTemplateTagsTest(AdminViewBasicTestCase):\n",
  "django__django-16595": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 3979e76..39a6bd1 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -236,6 +236,44 @@ class OptimizerTests(SimpleTestCase):\n             ],\n         )\n \n+    def test_alter_alter_field(self):\n+        \"\"\"AlterField should collapse into the last one.\"\"\"\n+        self.assertOptimizesTo(\n+            [\n+                migrations.AlterField(\n+                    model_name=\"Foo\",\n+                    name=\"name\",\n+                    field=models.CharField(max_length=256, null=True),\n+                ),\n+                migrations.AlterField(\n+                    model_name=\"Foo\",\n+                    name=\"name\",\n+                    field=models.CharField(max_length=128, null=True),\n+                ),\n+                migrations.AlterField(\n+                    model_name=\"Foo\",\n+                    name=\"name\",\n+                    field=models.CharField(max_length=128, null=True, help_text=\"help\"),\n+                ),\n+                migrations.AlterField(\n+                    model_name=\"Foo\",\n+                    name=\"name\",\n+                    field=models.CharField(\n+                        max_length=128, null=True, help_text=\"help\", default=None\n+                    ),\n+                ),\n+            ],\n+            [\n+                migrations.AlterField(\n+                    model_name=\"Foo\",\n+                    name=\"name\",\n+                    field=models.CharField(\n+                        max_length=128, null=True, help_text=\"help\", default=None\n+                    ),\n+                ),\n+            ],\n+        )\n+\n     def test_alter_alter_table_model(self):\n         self._test_alter_alter_model(\n             migrations.AlterModelTable(\"Foo\", \"a\"),\n",
  "django__django-16873": "",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..4c9c71f 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -654,7 +654,52 @@ class BulkCreateTests(TestCase):\n     def test_update_conflicts_two_fields_no_unique_fields(self):\n         self._test_update_conflicts_two_fields([])\n \n-    def _test_update_conflicts_unique_two_fields(self, unique_fields):\n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        \"\"\"\n+        Test that bulk_create with update_conflicts=True returns instances\n+        with primary keys set.\n+        \"\"\"\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"x\"),\n+            TwoFields(f1=2, f2=2, name=\"y\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n+    def test_bulk_create_with_update_conflicts_and_new_entries(self):\n+        \"\"\"\n+        Test that bulk_create with update_conflicts=True returns instances\n+        with primary keys set for both updated and newly created entries.\n+        \"\"\"\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"a\"),\n+            TwoFields(f1=2, f2=2, name=\"b\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+\n+        hybrid_objects = [\n+            TwoFields(f1=1, f2=1, name=\"c\"),  # conflict\n+            TwoFields(f1=2, f2=2, name=\"d\"),  # conflict\n+            TwoFields(f1=3, f2=3, name=\"e\"),  # new\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            hybrid_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(hybrid_objects))\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n         Country.objects.bulk_create(self.data)\n         self.assertEqual(Country.objects.count(), 4)\n \n@@ -816,4 +861,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..67f0d83 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -197,6 +197,29 @@ class OperationWriterTests(SimpleTestCase):\n             \"),\",\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -255,12 +278,58 @@ class WriterTests(SimpleTestCase):\n             decimal.Decimal(\"1.3\"), (\"Decimal('1.3')\", {\"from decimal import Decimal\"})\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n         self.assertSerializedEqual(Money(\"1.3\"))\n         self.assertSerializedResultEqual(\n             Money(\"1.3\"),\n             (\"migrations.test_writer.Money('1.3')\", {\"import migrations.test_writer\"}),\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -296,6 +365,29 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set()),\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r\"^foo$\")\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -306,6 +398,29 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\n@@ -313,6 +428,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\n@@ -320,10 +458,56 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -331,11 +515,57 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(\n             default=TextEnum.B, choices=[(m.value, m) for m in TextEnum]\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -344,10 +574,56 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -356,9 +632,55 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         field = models.CharField(\n             default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum]\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -367,9 +689,55 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         field = models.IntegerField(\n             default=IntEnum.A, choices=[(m.value, m) for m in IntEnum]\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -379,6 +747,29 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n@@ -387,6 +778,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n@@ -394,9 +808,55 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -405,6 +865,29 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A | IntFlagEnum.B,\n             (\n@@ -414,6 +897,29 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = \"A\", \"A value\"\n@@ -433,6 +939,29 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             (\"datetime.date(1969, 7, 20)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         field = models.CharField(default=TextChoices.B, choices=TextChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -440,12 +969,58 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -456,6 +1031,29 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\",\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_nested_class(self):\n         for nested_cls in [self.NestedEnum, self.NestedChoices]:\n             cls_name = nested_cls.__name__\n@@ -478,14 +1076,83 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {\"import uuid\"}),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {\"import uuid\"}),\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n         field = models.UUIDField(\n             choices=((uuid_a, \"UUID A\"), (uuid_b, \"UUID B\")), default=uuid_a\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -495,6 +1162,29 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\",\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_pathlib(self):\n         # Pure path objects work in all platforms.\n         self.assertSerializedEqual(pathlib.PurePosixPath())\n@@ -523,6 +1213,29 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"models.FilePathField(path=pathlib.PurePosixPath('/home/user'))\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertIn(\"import pathlib\", imports)\n \n     def test_serialize_path_like(self):\n@@ -554,13 +1267,82 @@ class WriterTests(SimpleTestCase):\n         self.assertSerializedEqual(\n             datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone())\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedEqual(\n             datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180))\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc),\n             (\n@@ -568,6 +1350,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import datetime\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(\n                 2012, 1, 1, 2, 1, tzinfo=zoneinfo.ZoneInfo(\"Europe/Paris\")\n@@ -578,12 +1383,58 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"}),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n@@ -593,20 +1444,112 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(\n             SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\")\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedResultEqual(\n             SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"}),\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)), (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -624,6 +1567,29 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.RegexValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a compiled regex.\n@@ -633,6 +1599,29 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test a string regex with flag\n@@ -643,6 +1632,29 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[0-9]+$', \"\n             \"flags=re.RegexFlag['DOTALL'])\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n@@ -653,6 +1665,29 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', \"\n             \"'invalid')\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a subclass.\n@@ -661,6 +1696,29 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.EmailValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.serialize_round_trip(validator)\n \n         validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(\n@@ -671,9 +1729,55 @@ class WriterTests(SimpleTestCase):\n             string, \"migrations.test_writer.EmailValidator(message='hello')\"\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n         validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(\n             message=\"hello\"\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n             MigrationWriter.serialize(validator)\n \n@@ -700,6 +1804,29 @@ class WriterTests(SimpleTestCase):\n             models.OrderBy(models.F(\"name\").desc()),\n             name=\"complex_func_index\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         string, imports = MigrationWriter.serialize(index)\n         self.assertEqual(\n             string,\n@@ -711,6 +1838,29 @@ class WriterTests(SimpleTestCase):\n             \"models.OrderBy(models.OrderBy(models.F('name'), descending=True)), \"\n             \"name='complex_func_index')\",\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertEqual(imports, {\"from django.db import models\"})\n \n     def test_serialize_empty_nonempty_tuple(self):\n@@ -762,6 +1912,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.models\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         self.assertSerializedEqual(FoodManager(\"a\", \"b\"))\n         self.assertSerializedEqual(FoodManager(\"x\", \"y\", c=3, d=4))\n \n@@ -772,6 +1945,29 @@ class WriterTests(SimpleTestCase):\n             frozenset(\"cba\"), (\"frozenset(['a', 'b', 'c'])\", set())\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_serialize_set(self):\n         self.assertSerializedEqual(set())\n         self.assertSerializedResultEqual(set(), (\"set()\", set()))\n@@ -809,6 +2005,29 @@ class WriterTests(SimpleTestCase):\n             (\"('models.Model', {'from django.db import models'})\", set()),\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -848,6 +2067,29 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [(\"testapp\", \"some_other_one\")],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         # We don't test the output formatting - that's too fragile.\n@@ -887,6 +2129,29 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -896,6 +2161,29 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_sorted_dependencies(self):\n         migration = type(\n             \"Migration\",\n@@ -912,6 +2200,29 @@ class WriterTests(SimpleTestCase):\n                 ],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         output = MigrationWriter(migration, include_header=False).as_string()\n         self.assertIn(\n             \"    dependencies = [\\n\"\n@@ -923,6 +2234,29 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -949,6 +2283,29 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -956,6 +2313,29 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -1001,6 +2381,29 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\"from django.db import migrations\\n\", output)\n@@ -1017,6 +2420,29 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\",\n         )\n \n+    def test_serialize_nested_class_method_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+                \n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+            capabilities = ArrayField(\n+                models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+                null=True,\n+                default=Capability.default\n+            )\n+\n+        field = Profile._meta.get_field('capabilities')\n+        serialized_field = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.Profile.Capability.default\",\n+            serialized_field,\n+            \"Nested class method default serialization is incorrect.\",\n+        )\n+\n     def test_register_serializer(self):\n         class ComplexSerializer(BaseSerializer):\n             def serialize(self):\n@@ -1032,4 +2458,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "matplotlib__matplotlib-22711": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex 39c625e..90821e7 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1119,6 +1119,22 @@ def test_range_slider(orientation):\n     slider.reset()\n     assert_allclose(slider.val, [0.1, 0.34])\n \n+@pytest.mark.parametrize(\"orientation\", [\"horizontal\", \"vertical\"])\n+def test_rangeslider_valinit(orientation):\n+    fig, ax = plt.subplots()\n+    widget = widgets.RangeSlider(\n+        ax=ax, label=\"Test\", valmin=0.0, valmax=1.0, orientation=orientation,\n+        valinit=[0.2, 0.8]\n+    )\n+    \n+    # Check if the initial values are correctly set\n+    assert_allclose(widget.val, (0.2, 0.8))\n+    assert widget.poly.xy[0][0 if orientation == \"horizontal\" else 1] == 0.2\n+    assert widget.poly.xy[2][0 if orientation == \"horizontal\" else 1] == 0.8\n+\n+    # Test slider movement and value update\n+    widget.set_val((0.3, 0.7))\n+    assert_allclose(widget.val, (0.3, 0.7))\n \n def check_polygon_selector(event_sequence, expected_result, selections_count,\n                            **kwargs):\n",
  "matplotlib__matplotlib-23299": "diff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 144880c..6341018 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -508,7 +508,19 @@ def test_rcparams_reset_after_fail():\n         assert mpl.rcParams['text.usetex'] is False\n \n \n-@pytest.mark.skipif(sys.platform != \"linux\", reason=\"Linux only\")\n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend, rc_context\n+import pytest\n+\n+def test_get_backend_does_not_clear_figures_in_rc_context():\n+    # This test verifies that get_backend() does not clear figures \n+    # from Gcf.figs when they are created within an rc_context.\n+    with rc_context():\n+        fig2 = plt.figure()\n+        before = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+    get_backend()\n+    after = f'{id(plt._pylab_helpers.Gcf)} {plt._pylab_helpers.Gcf.figs!r}'\n+    assert before == after, f'Figures were cleared:\\nBefore: {before}\\nAfter: {after}'\n def test_backend_fallback_headless(tmpdir):\n     env = {**os.environ,\n            \"DISPLAY\": \"\", \"WAYLAND_DISPLAY\": \"\",\n",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..380a92b 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -20,8 +20,15 @@ import numpy as np\n mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n+@check_figures_equal(extensions=[\"png\"])\n+def test_3d_axes_set_visible_false(fig_test, fig_ref):\n+    ax_test = fig_test.add_subplot(111, projection='3d')\n+    ax_test.scatter(1, 1, 1)\n+    ax_test.set_visible(False)\n \n-def test_aspect_equal_error():\n+    # In reference figure, we leave the axis visible to compare.\n+    ax_ref = fig_ref.add_subplot(111, projection='3d')\n+    ax_ref.scatter(1, 1, 1)\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     with pytest.raises(NotImplementedError):\n",
  "matplotlib__matplotlib-23562": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex a51a857..6339d01 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -1809,6 +1809,38 @@ def test_scatter_spiral():\n     sc = ax.scatter(np.sin(th), np.cos(th), th, s=(1 + th * 5), c=th ** 2)\n \n     # force at least 1 draw!\n+\n+def test_Poly3DCollection_get_facecolor():\n+    # Test to ensure get_facecolor does not raise exceptions\n+    y, x = np.ogrid[1:10:100j, 1:10:100j]\n+    z2 = np.cos(x) ** 3 - np.sin(y) ** 2\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111, projection='3d')\n+    r = ax.plot_surface(x, y, z2, cmap='hot')\n+    \n+    # Ensure the method call does not raise an exception\n+    try:\n+        facecolor = r.get_facecolor()\n+        print(\"Facecolor:\", facecolor)\n+    except AttributeError as e:\n+        print(\"AttributeError:\", e)\n+        raise\n+\n+def test_Poly3DCollection_get_edgecolor():\n+    # Test to ensure get_edgecolor does not raise exceptions\n+    y, x = np.ogrid[1:10:100j, 1:10:100j]\n+    z2 = np.cos(x) ** 3 - np.sin(y) ** 2\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111, projection='3d')\n+    r = ax.plot_surface(x, y, z2, cmap='hot')\n+    \n+    # Ensure the method call does not raise an exception\n+    try:\n+        edgecolor = r.get_edgecolor()\n+        print(\"Edgecolor:\", edgecolor)\n+    except AttributeError as e:\n+        print(\"AttributeError:\", e)\n+        raise\n     fig.canvas.draw()\n \n \n",
  "matplotlib__matplotlib-23563": "",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..1b3176e 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -774,6 +774,24 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n         assert mpl.colors.same_color(text.get_color(), color)\n \n \n+import matplotlib.pyplot as plt\n+import pytest\n+\n+@pytest.mark.parametrize('draggable', (True, False))\n+def test_legend_draggable(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='shabnams')\n+    leg = ax.legend(draggable=draggable)\n+    assert leg.get_draggable() is draggable\n+\n+def test_get_set_draggable():\n+    legend = plt.legend()\n+    assert not legend.get_draggable()\n+    legend.set_draggable(True)\n+    assert legend.get_draggable()\n+    legend.set_draggable(False)\n+    assert not legend.get_draggable()\n+\n def test_get_set_draggable():\n     legend = plt.legend()\n     assert not legend.get_draggable()\n",
  "matplotlib__matplotlib-23964": "",
  "matplotlib__matplotlib-23987": "diff --git a/lib/matplotlib/tests/test_constrainedlayout.py b/lib/matplotlib/tests/test_constrainedlayout.py\nindex 41fdfa1..392365f 100644\n--- a/lib/matplotlib/tests/test_constrainedlayout.py\n+++ b/lib/matplotlib/tests/test_constrainedlayout.py\n@@ -655,4 +655,25 @@ def test_compressed1():\n     np.testing.assert_allclose(pos.y1, 0.8537, atol=1e-3)\n     pos = axs[1, 2].get_position()\n     np.testing.assert_allclose(pos.x1, 0.8618, atol=1e-3)\n-    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n+    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n+\n+def test_constrained_layout_warning():\n+    import matplotlib.pyplot as plt\n+    import numpy as np\n+    import warnings\n+\n+    a = np.linspace(0, 2*np.pi, 100)\n+    b = np.sin(a)\n+    c = np.cos(a)\n+\n+    # Test case to ensure no warning with constrained_layout=False\n+    with warnings.catch_warnings(record=True) as w:\n+        warnings.simplefilter(\"always\")\n+        fig, ax = plt.subplots(1, 2, figsize=(8, 2), constrained_layout=False)\n+        ax[0].plot(a, b)\n+        ax[1].plot(a, c)\n+        plt.subplots_adjust(wspace=0)\n+        \n+        # Check that no UserWarning was raised\n+        assert not any(item.category == UserWarning for item in w), \\\n+            \"Expected no UserWarning when constrained_layout=False\"\n",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "",
  "matplotlib__matplotlib-24970": "",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..a3d3c47 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -90,6 +91,8 @@ def _generate_complete_test_figure(fig_ref):\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n \n+import pickletools\n+\n @mpl.style.context(\"default\")\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n@@ -106,7 +109,31 @@ def test_complete(fig_test, fig_ref):\n     plt.close(loaded)\n \n \n-def _pickle_load_subprocess():\n+def test_pickle_figure_with_draggable_legend():\n+    # Setup a figure and ax\n+    fig, ax = plt.subplots()\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40, 43, 45, 47, 48]\n+    ax.plot(time, speed, label=\"speed\")\n+\n+    # Add a draggable legend\n+    leg = ax.legend()\n+    leg.set_draggable(True)\n+\n+    # Pickle the figure\n+    pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+\n+    # Verify that 'FigureCanvasQTAgg' is not present in the pickle stream\n+    assert \"FigureCanvasAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+\n+    # Load the pickled figure and check for successful unpickling\n+    loaded = pickle.loads(pkl)\n+\n+    # Ensure the loaded figure still contains a legend\n+    assert any(isinstance(legend, mpl.legend.Legend) for legend in loaded.legends)\n+\n+    plt.close(fig)\n+    plt.close(loaded)\n     import os\n     import pickle\n \n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..2d968c9 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -89,8 +89,36 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n \n @mpl.style.context(\"default\")\n+def test_pickle_with_aligned_labels():\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    fig.align_labels()  # This is the line that originally caused the pickling issue\n+\n+    # Attempt to pickle the figure\n+    try:\n+        pickle_data = pickle.dumps(fig)\n+    except Exception as e:\n+        assert False, f\"Pickling failed with exception: {e}\"\n+\n+    # Also verify that we can unpickle the figure and it behaves as expected\n+    loaded_fig = pickle.loads(pickle_data)\n+    loaded_fig.canvas.draw()\n+\n+    plt.close(loaded_fig)\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25442": "diff --git a/lib/matplotlib/tests/test_offsetbox.py b/lib/matplotlib/tests/test_offsetbox.py\nindex 204af9c..e2d463d 100644\n--- a/lib/matplotlib/tests/test_offsetbox.py\n+++ b/lib/matplotlib/tests/test_offsetbox.py\n@@ -445,8 +445,32 @@ def test_paddedbox():\n     pb = PaddedBox(ta, pad=10, patch_attrs={'facecolor': 'b'})\n     ab = AnchoredOffsetbox('upper right', child=pb)\n     ax.add_artist(ab)\n+import numpy as np\n+import matplotlib.pyplot as plt\n+import mplcursors\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+def test_mplcursor_attribute_error():\n+    x = np.arange(1, 11)\n+    y1 = x\n+\n+    fig, ax = plt.subplots()\n+    ax.scatter(x, y1)\n \n+    cursor = mplcursors.cursor(ax)\n+\n+    # Simulate a click on the data point to see if the error occurs\n+    for i in range(5):  # Click multiple times to simulate user interaction\n+        cursor._on_click(MockEvent(ax, x[i], y1[i]))\n+\n+    plt.close(fig)\n+\n+class MockEvent:\n+    def __init__(self, ax, xdata, ydata):\n+        self.inaxes = ax\n+        self.xdata = xdata\n+        self.ydata = ydata\n     ta = TextArea(\"foobar\")\n     pb = PaddedBox(ta, pad=15, draw_frame=True)\n     ab = AnchoredOffsetbox('lower right', child=pb)\n-    ax.add_artist(ab)\n+    ax.add_artist(ab)\n",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\nindex 9aa3203..cfac32d 100644\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -1,4 +1,5 @@\n \n+\n import numpy as np\n import pandas as pd\n \n@@ -8,9 +9,34 @@ from numpy.testing import assert_array_equal, assert_array_almost_equal\n from seaborn._core.groupby import GroupBy\n from seaborn._stats.regression import PolyFit\n \n+from pandas.testing import assert_frame_equal\n \n class TestPolyFit:\n \n+    def test_polyfit_with_missing_data(self):\n+        df = pd.DataFrame({\n+            \"x\": [1, 2, 3, np.nan, 4],\n+            \"y\": [1, 2, 3, 4, 5],\n+            \"group\": [\"a\", \"a\", \"a\", \"a\", \"a\"]\n+        })\n+        groupby = GroupBy([\"group\"])\n+        # Using PolyFit with missing data\n+        res1 = PolyFit()(df[[\"x\", \"y\"]], groupby, \"x\", {})\n+        # Using PolyFit with missing data removed\n+        res2 = PolyFit()(df[[\"x\", \"y\"]].dropna(), groupby, \"x\", {})\n+        assert_frame_equal(res1, res2)\n+\n+    def test_polyfit_without_missing_data(self):\n+        df = pd.DataFrame({\n+            \"x\": [1, 2, 3, 4, 5],\n+            \"y\": [1, 2, 3, 4, 5],\n+            \"group\": [\"a\", \"a\", \"a\", \"a\", \"a\"]\n+        })\n+        groupby = GroupBy([\"group\"])\n+        # Ensure PolyFit works correctly without missing data\n+        res = PolyFit()(df[[\"x\", \"y\"]], groupby, \"x\", {})\n+        assert not res.empty\n+\n     @pytest.fixture\n     def df(self, rng):\n \n",
  "mwaskom__seaborn-3190": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\nindex 72a27ec..f839a82 100644\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -96,12 +96,38 @@ class TestContinuous:\n         s = Continuous()._setup(x, Color())\n         assert_array_equal(s(x), cmap([0, .25, 1])[:, :3])  # FIXME RGBA\n \n+    def test_interval_with_bools(self):\n+\n+        import pandas as pd\n+        from seaborn._core.scales import Continuous\n+        from seaborn._core.properties import IntervalProperty\n+        from numpy.testing import assert_array_equal\n+\n+        # Original test case to ensure IntervalProperty handles boolean values\n+        x = pd.Series([True, False, False])\n+        s = Continuous()._setup(x, IntervalProperty())\n+        assert_array_equal(s(x), [1, 0, 0])\n+\n     def test_color_named_values(self, x):\n \n         cmap = color_palette(\"viridis\", as_cmap=True)\n         s = Continuous(\"viridis\")._setup(x, Color())\n         assert_array_equal(s(x), cmap([0, .25, 1])[:, :3])  # FIXME RGBA\n \n+    def test_color_mapping_with_booleans(self):\n+        import pandas as pd\n+        from seaborn._core.scales import Continuous\n+        from seaborn._core.properties import Color\n+        from seaborn import color_palette\n+        from numpy.testing import assert_array_equal\n+\n+        # Test for color mapping with boolean data\n+        x = pd.Series([True, False, True])\n+        cmap = color_palette(\"ch:\", as_cmap=True)\n+        s = Continuous()._setup(x, Color())\n+        expected_colors = cmap([1, 0, 1])[:, :3]  # Map True to 1 and False to 0\n+        assert_array_equal(s(x), expected_colors)  # Ensure the color mapping is correct\n+\n     def test_color_tuple_values(self, x):\n \n         cmap = color_palette(\"blend:b,g\", as_cmap=True)\n",
  "mwaskom__seaborn-3407": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\nindex b2e4a92..8a9ba9a 100644\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -1314,6 +1314,13 @@ class TestPairGrid:\n         for ax in g.diag_axes:\n             assert len(ax.collections) == n\n \n+    def test_pairplot_column_multiindex(self):\n+\n+        cols = pd.MultiIndex.from_arrays([[\"x\", \"y\"], [1, 2]])\n+        df = self.df[[\"x\", \"y\"]].set_axis(cols, axis=1)\n+        g = ag.pairplot(df)\n+        assert g.diag_vars == list(cols)\n+\n     def test_pairplot_reg(self):\n \n         vars = [\"x\", \"y\", \"z\"]\n",
  "pallets__flask-4992": "diff --git a/tests/test_config.py b/tests/test_config.py\nindex 179b09c..02e349d 100644\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -1,6 +1,9 @@\n+\n import json\n import os\n+import sys\n import textwrap\n+import tomllib\n \n import pytest\n \n@@ -11,8 +14,14 @@ import flask\n TEST_KEY = \"foo\"\n SECRET_KEY = \"config\"\n \n-\n-def common_object_test(app):\n+def test_config_from_file_toml_with_mode():\n+    tomllib = pytest.importorskip(\"tomllib\", reason=\"tomllib added in 3.11\")\n+    app = flask.Flask(__name__)\n+    current_dir = os.path.dirname(os.path.abspath(__file__))\n+    app.config.from_file(\n+        os.path.join(current_dir, \"static\", \"config.toml\"), tomllib.load, mode=\"rb\"\n+    )\n+    common_object_test(app)\n     assert app.secret_key == \"config\"\n     assert app.config[\"TEST_KEY\"] == \"foo\"\n     assert \"TestConfig\" not in app.config\n",
  "psf__requests-1963": "",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..af1c2e0 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1636,6 +1636,42 @@ def test_prepared_request_complete_copy():\n     assert_copy(p, p.copy())\n \n \n+import pytest\n+from requests import Session, HTTPAdapter\n+from requests.exceptions import RequestException, Timeout\n+from requests.packages.urllib3.exceptions import DecodeError, TimeoutError\n+\n+def httpbin(endpoint):\n+    # This function should return the full URL to the httpbin endpoint.\n+    # Assuming it's a placeholder for a function that returns a correct URL.\n+    return f'http://httpbin.org/{endpoint}'\n+\n+def test_urllib3_decode_error():\n+    s = Session()\n+    # Mocking an adapter to raise DecodeError\n+    adapter = HTTPAdapter()\n+    s.mount('http://', adapter)\n+\n+    with pytest.raises(RequestException) as excinfo:\n+        # Mock a request that would cause DecodeError\n+        s.get(httpbin('mock-decode-error'))\n+\n+    assert isinstance(excinfo.value, RequestException)\n+    assert \"DecodeError\" in str(excinfo.value)\n+\n+def test_urllib3_timeout_error():\n+    s = Session()\n+    # Mocking an adapter to raise TimeoutError\n+    adapter = HTTPAdapter()\n+    s.mount('http://', adapter)\n+\n+    with pytest.raises(Timeout) as excinfo:\n+        # Mock a request that would cause TimeoutError\n+        s.get(httpbin('mock-timeout-error'))\n+\n+    assert isinstance(excinfo.value, Timeout)\n+    assert \"TimeoutError\" in str(excinfo.value)\n+\n def test_prepare_unicode_url():\n     p = PreparedRequest()\n     p.prepare(\n@@ -1663,4 +1699,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "",
  "psf__requests-863": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 0ee4333..28739ff 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -744,7 +744,27 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n             assert 'foo' in response.text\n             assert 'bar' in response.text\n \n-    def test_session_persistent_cookies(self):\n+    def test_multiple_hooks_execution(self):\n+        \"\"\"Test that a list of hooks is executed correctly\"\"\"\n+\n+        def hook1(args):\n+            args[\"hook1_executed\"] = True\n+            return args\n+\n+        def hook2(args):\n+            args[\"hook2_executed\"] = True\n+            return args\n+\n+        hooks = [hook1, hook2]\n+        r = requests.models.Request(hooks={'args': hooks})\n+\n+        # Simulate the triggering of hooks\n+        args = {}\n+        for hook in r.hooks['args']:\n+            args = hook(args)\n+\n+        assert args.get(\"hook1_executed\") is True\n+        assert args.get(\"hook2_executed\") is True\n \n         s = requests.session()\n \n",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..6c4a2a9 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -388,7 +388,7 @@ repr_da = xr.DataArray(\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over %r \" % dim\n+    expected += \", grouped over %r\" % dim\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj[dim])))\n     if dim == \"x\":\n         expected += \"1, 2, 3, 4, 5.\"\n@@ -405,7 +405,7 @@ def test_groupby_repr(obj, dim):\n def test_groupby_repr_datetime(obj):\n     actual = repr(obj.groupby(\"t.month\"))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over 'month' \"\n+    expected += \", grouped over 'month'\"\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj.t.dt.month)))\n     expected += \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.\"\n     assert actual == expected\n",
  "pylint-dev__pylint-5859": "diff --git a/tests/checkers/unittest_misc.py b/tests/checkers/unittest_misc.py\nindex 460d485..9429e17 100644\n--- a/tests/checkers/unittest_misc.py\n+++ b/tests/checkers/unittest_misc.py\n@@ -78,6 +78,16 @@ class TestFixme(CheckerTestCase):\n         with self.assertNoMessages():\n             self.checker.process_tokens(_tokenize_str(code))\n \n+    @set_config(notes=[\"???\"])\n+    def test_entirely_punctuation_codetag(self) -> None:\n+        code = \"\"\"a = 1\n+                # ???\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n+\n     @set_config(notes=[\"CODETAG\"])\n     def test_other_present_codetag(self) -> None:\n         code = \"\"\"a = 1\n@@ -119,4 +129,4 @@ class TestFixme(CheckerTestCase):\n         # Todoist API: Fetch all Tasks\n         \"\"\"\n         with self.assertNoMessages():\n-            self.checker.process_tokens(_tokenize_str(code))\n+            self.checker.process_tokens(_tokenize_str(code))\n",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..4749d49 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -60,6 +60,9 @@ def test_unknown_message_id(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly raise a message on an unknown id.\"\"\"\n     Run([str(EMPTY_MODULE), \"--disable=12345\"], exit=False)\n     output = capsys.readouterr()\n+    assert \"usage: pylint\" in output.err\n+    assert \"Unrecognized option\" in output.err\n+    assert \"Traceback (most recent call last):\" not in output.err\n     assert \"Command line:1:0: E0012: Bad option value for --disable.\" in output.out\n \n \n@@ -68,14 +71,21 @@ def test_unknown_option_name(capsys: CaptureFixture) -> None:\n     with pytest.raises(_UnrecognizedOptionError):\n         Run([str(EMPTY_MODULE), \"--unknown-option=yes\"], exit=False)\n     output = capsys.readouterr()\n+    assert \"usage: pylint\" in output.err\n+    assert \"Unrecognized option\" in output.err\n+    assert \"Traceback (most recent call last):\" not in output.err\n     assert \"E0015: Unrecognized option found: unknown-option=yes\" in output.out\n \n \n def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly raise a message on an unknown short option.\"\"\"\n+    result = pytest.raises(SystemExit)\n     with pytest.raises(_UnrecognizedOptionError):\n         Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n     output = capsys.readouterr()\n+    assert \"usage: pylint\" in output.err\n+    assert \"Unrecognized option\" in output.err\n+    assert \"Traceback (most recent call last):\" not in output.err\n     assert \"E0015: Unrecognized option found: Q\" in output.out\n \n \n@@ -84,6 +94,9 @@ def test_unknown_confidence(capsys: CaptureFixture) -> None:\n     with pytest.raises(SystemExit):\n         Run([str(EMPTY_MODULE), \"--confidence=UNKNOWN_CONFIG\"], exit=False)\n     output = capsys.readouterr()\n+    assert \"usage: pylint\" in output.err\n+    assert \"Unrecognized option\" in output.err\n+    assert \"Traceback (most recent call last):\" not in output.err\n     assert \"argument --confidence: UNKNOWN_CONFIG should be in\" in output.err\n \n \n",
  "pylint-dev__pylint-7080": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex fa7078d..5172338 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1330,6 +1330,28 @@ class TestRunTC:\n                     code=0,\n                 )\n \n+    def test_ignore_paths_with_recursive(self):\n+        \"\"\"Test that the ignore-paths setting is respected with --recursive=y\"\"\"\n+        with _test_sys_path():\n+            sys.path = [\n+                path\n+                for path in sys.path\n+                if not os.path.basename(path) == \"regrtest_data\"\n+            ]\n+            with _test_cwd():\n+                # Change to the directory containing the source code\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n+                \n+                # Run Pylint with both recursive and ignore-paths flags\n+                self._runtest(\n+                    [\n+                        \".\",\n+                        \"--recursive=y\",\n+                        \"--ignore-paths=^subdirectory/.*\",\n+                    ],\n+                    code=0,\n+                )\n+\n     def test_regression_recursive_current_dir(self):\n         with _test_sys_path():\n             # pytest is including directory HERE/regrtest_data to sys.path which causes\n",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..c497fde 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -935,10 +935,50 @@ print(submodule1)\n     assert not linter.stats.by_msg\n \n \n+def test_lint_identically_named_nested_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test for the issue where pylint fails if module contains another module of the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        linter.check([\"a\"])\n+    assert not linter.stats.by_msg\n+\n+\n+def test_import_from_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test importing from a module with the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"from a import b\\n\")\n+        linter.check([\"r\", \"a\"])\n+    assert not linter.stats.by_msg\n+\n+\n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n     linter = initialized_linter\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n+\n+\n+def test_lint_identically_named_nested_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test for the issue where pylint fails if module contains another module of the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        linter.check([\"a\"])\n+    assert not linter.stats.by_msg\n+\n+\n+def test_import_from_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test importing from a module with the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"from a import b\\n\")\n+        linter.check([\"r\", \"a\"])\n+    assert not linter.stats.by_msg\n",
  "pylint-dev__pylint-7993": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 6338072..6df8d40 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n@@ -113,6 +114,41 @@ def test_template_option_non_existing(linter) -> None:\n     assert out_lines[2] == \"my_mod:2::()\"\n \n \n+def test_template_with_custom_braces(linter: PyLinter) -> None:\n+    \"\"\"Test using custom braces in the message template.\"\"\"\n+    output = StringIO()\n+    linter.reporter.out = output\n+    linter.config.msg_template = '{{ \"Category\": \"{category}\" }}'\n+\n+    linter.open()\n+    linter.set_current_module(\"my_mod\")\n+    linter.add_message(\"C0301\", line=1, args=(1, 2))\n+    linter.add_message(\"E0602\", line=2, args=(3, 4))\n+\n+    out_lines = output.getvalue().split(\"\\n\")\n+    assert out_lines[1] == '{ \"Category\": \"convention\" }'\n+    assert out_lines[2] == '{ \"Category\": \"error\" }'\n+\n+\n+def test_template_with_unrecognized_argument(linter: PyLinter, recwarn: WarningsRecorder) -> None:\n+    \"\"\"Test that a warning is raised for unrecognized arguments in the template.\"\"\"\n+    output = StringIO()\n+    linter.reporter.out = output\n+    linter.config.msg_template = '{unknown_arg} {category}'\n+\n+    linter.open()\n+    linter.set_current_module(\"my_mod\")\n+    linter.add_message(\"C0301\", line=1, args=(1, 2))\n+\n+    # Check that a warning was issued for the unrecognized argument\n+    assert len(recwarn) > 0\n+    assert \"Don't recognize the argument 'unknown_arg'\" in str(recwarn.pop().message)\n+\n+    # Verify that the recognized part of the template is used\n+    out_lines = output.getvalue().split(\"\\n\")\n+    assert out_lines[1] == ' convention'\n+\n+\n def test_deprecation_set_output(recwarn):\n     \"\"\"TODO remove in 3.0.\"\"\"\n     reporter = BaseReporter()\n",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "",
  "pytest-dev__pytest-5227": "diff --git a/testing/logging/test_formatter.py b/testing/logging/test_formatter.py\nindex 54a08a2..c454a0c 100644\n--- a/testing/logging/test_formatter.py\n+++ b/testing/logging/test_formatter.py\n@@ -1,3 +1,4 @@\n+\n import logging\n \n import py.io\n@@ -5,11 +6,11 @@ import py.io\n from _pytest.logging import ColoredLevelFormatter\n \n \n-def test_coloredlogformatter():\n-    logfmt = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n+def test_coloredlogformatter_old_format():\n+    old_logfmt = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n \n-    record = logging.LogRecord(\n-        name=\"dummy\",\n+    record_old = logging.LogRecord(\n+        name=\"dummy_old\",\n         level=logging.INFO,\n         pathname=\"dummypath\",\n         lineno=10,\n@@ -22,15 +23,39 @@ def test_coloredlogformatter():\n         class option(object):\n             pass\n \n-    tw = py.io.TerminalWriter()\n-    tw.hasmarkup = True\n-    formatter = ColoredLevelFormatter(tw, logfmt)\n-    output = formatter.format(record)\n-    assert output == (\n+    tw_old = py.io.TerminalWriter()\n+    tw_old.hasmarkup = True\n+    formatter_old = ColoredLevelFormatter(tw_old, old_logfmt)\n+    output_old = formatter_old.format(record_old)\n+    assert output_old == (\n         \"dummypath                   10 \\x1b[32mINFO    \\x1b[0m Test Message\"\n     )\n \n-    tw.hasmarkup = False\n-    formatter = ColoredLevelFormatter(tw, logfmt)\n-    output = formatter.format(record)\n-    assert output == (\"dummypath                   10 INFO     Test Message\")\n+    tw_old.hasmarkup = False\n+    formatter_old = ColoredLevelFormatter(tw_old, old_logfmt)\n+    output_old = formatter_old.format(record_old)\n+    assert output_old == (\"dummypath                   10 INFO     Test Message\")\n+\n+def test_coloredlogformatter_new_format():\n+    new_logfmt = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n+\n+    record_new = logging.LogRecord(\n+        name=\"dummy_new\",\n+        level=logging.INFO,\n+        pathname=\"dummypath\",\n+        lineno=10,\n+        msg=\"Test Message\",\n+        args=(),\n+        exc_info=False,\n+    )\n+\n+    tw_new = py.io.TerminalWriter()\n+    tw_new.hasmarkup = True\n+    formatter_new = ColoredLevelFormatter(tw_new, new_logfmt)\n+    output_new = formatter_new.format(record_new)\n+    assert output_new == (\"INFO    dummy_new:dummypath:10 \\x1b[32mINFO    \\x1b[0m Test Message\")\n+\n+    tw_new.hasmarkup = False\n+    formatter_new = ColoredLevelFormatter(tw_new, new_logfmt)\n+    output_new = formatter_new.format(record_new)\n+    assert output_new == (\"INFO    dummy_new:dummypath:10 INFO     Test Message\")\n",
  "pytest-dev__pytest-5495": "diff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex b05f85c..0073e70 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -324,7 +324,29 @@ class TestAssert_reprcompare:\n         assert \"- \" + \"a\" * 50 + \"spam\" in lines\n         assert \"+ \" + \"a\" * 50 + \"eggs\" in lines\n \n-    def test_multiline_text_diff(self):\n+    def test_bytes_diff_empty_vs_nonempty(self):\n+        \"\"\"Test comparing empty and non-empty byte strings.\"\"\"\n+        diff = callequal(b\"\", b\"42\")\n+        assert diff == [\n+            \"b'' == b'42'\",\n+            \"Right contains more items, first extra item: 52\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'42'\",\n+            \"?  ++\",\n+        ]\n+\n+    def test_bytes_diff_single_char(self):\n+        \"\"\"Test comparing byte strings with single different character.\"\"\"\n+        diff = callequal(b\"\", b\"1\")\n+        assert diff == [\n+            \"b'' == b'1'\",\n+            \"Right contains more items, first extra item: 49\",\n+            \"Full diff:\",\n+            \"- b''\",\n+            \"+ b'1'\",\n+            \"?  +\",\n+        ]\n         left = \"foo\\nspam\\nbar\"\n         right = \"foo\\neggs\\nbar\"\n         diff = callequal(left, right)\n",
  "pytest-dev__pytest-5692": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3392814..fe125ad 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1,3 +1,4 @@\n+\n import os\n from xml.dom import minidom\n \n@@ -139,7 +140,29 @@ class TestPython:\n         node = dom.find_first_by_tag(\"testsuite\")\n         node.assert_attr(name=\"pytest\", errors=1, failures=2, skipped=1, tests=5)\n \n-    def test_timing_function(self, testdir):\n+    def test_hostname_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+            \"\"\"\n+        )\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        node.assert_attr(hostname=platform.node())\n+\n+    def test_timestamp_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+            \"\"\"\n+        )\n+        start_time = datetime.now()\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        timestamp = datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S\")\n+        assert start_time <= timestamp < datetime.now()\n         testdir.makepyfile(\n             \"\"\"\n             import time, pytest\n",
  "pytest-dev__pytest-7168": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 38e0b6b..ab40f79 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -143,6 +143,44 @@ def test_repr_on_newstyle():\n \n     assert saferepr(Function())\n \n+def test_broken_getattribute():\n+    \"\"\"saferepr() can create proper representations of classes with\n+    broken __getattribute__ (#7145)\n+    \"\"\"\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError\n+\n+        def __repr__(self):\n+            raise RuntimeError\n+\n+    assert saferepr(SomeClass()).startswith(\n+        \"<[RuntimeError() raised in repr()] SomeClass object at 0x\"\n+    )\n+\n+\n+def test_broken_repr():\n+    \"\"\"Test saferepr() with an object that raises an exception in __repr__.\"\"\"\n+    class SomeClass:\n+        def __repr__(self):\n+            raise ValueError(\"Error in __repr__\")\n+\n+    result = saferepr(SomeClass())\n+    assert result.startswith(\"<[ValueError('Error in __repr__',) raised in repr()] SomeClass object at 0x\")\n+\n+\n+def test_broken_getattribute_and_repr():\n+    \"\"\"Test saferepr() with an object that raises an exception in both __getattribute__ and __repr__.\"\"\"\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise KeyError(\"Error in __getattribute__\")\n+\n+        def __repr__(self):\n+            raise ValueError(\"Error in __repr__\")\n+\n+    result = saferepr(SomeClass())\n+    assert result.startswith(\"<[ValueError('Error in __repr__',) raised in repr()] SomeClass object at 0x\")\n+\n \n def test_unicode():\n     val = \"\u00a3\u20ac\"\n@@ -153,4 +191,4 @@ def test_unicode():\n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n-    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n",
  "pytest-dev__pytest-7220": "",
  "pytest-dev__pytest-7373": "",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..3237c68 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -219,6 +219,32 @@ class TestXFail:\n         assert str(callreport.longrepr) == \"[XPASS(strict)] nope\"\n         assert not hasattr(callreport, \"wasxfail\")\n \n+    @pytest.mark.parametrize(\n+        \"test_input,expected\",\n+        [\n+            (\n+                [\"-rs\"],\n+                [\"SKIPPED [1] test_sample.py:2: unconditional skip\", \"*1 skipped*\"],\n+            ),\n+            (\n+                [\"-rs\", \"--runxfail\"],\n+                [\"SKIPPED [1] test_sample.py:2: unconditional skip\", \"*1 skipped*\"],\n+            ),\n+        ],\n+    )\n+    def test_skip_location_reporting(self, testdir, test_input, expected):\n+        testdir.makepyfile(\n+            test_sample=\"\"\"\n+            import pytest\n+\n+            @pytest.mark.skip\n+            def test_skip_location():\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(*test_input)\n+        result.stdout.fnmatch_lines(expected)\n+\n     def test_xfail_run_anyway(self, testdir):\n         testdir.makepyfile(\n             \"\"\"\n",
  "pytest-dev__pytest-7490": "",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..b7e5a38 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,3 +1,4 @@\n+\n import os\n import stat\n import sys\n@@ -20,6 +21,7 @@ from _pytest.pathlib import register_cleanup_lock_removal\n from _pytest.pathlib import rm_rf\n from _pytest.pytester import Pytester\n from _pytest.tmpdir import get_user\n+from _pytest.monkeypatch import MonkeyPatch\n from _pytest.tmpdir import TempdirFactory\n from _pytest.tmpdir import TempPathFactory\n \n@@ -433,7 +435,32 @@ def test_basetemp_with_read_only_files(pytester: Pytester) -> None:\n         import os\n         import stat\n \n-        def test(tmp_path):\n+def test_tmp_path_factory_handles_invalid_dir_characters(tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch) -> None:\n+    # Test with a username containing illegal directory characters\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"os/<:*?;>agnostic\")\n+    # _basetemp / _given_basetemp are cached / set in parallel runs, patch them\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"pytest-of-unknown\" in str(p)\n+\n+def test_tmp_path_factory_handles_domain_usernames(tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch) -> None:\n+    # Test with a domain-style username\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"contoso\\\\john_doe\")\n+    # _basetemp / _given_basetemp are cached / set in parallel runs, patch them\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"pytest-of-unknown\" in str(p)\n+\n+def test_tmp_path_factory_handles_regular_usernames(tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch) -> None:\n+    # Test with a simple username\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"john_doe\")\n+    # _basetemp / _given_basetemp are cached / set in parallel runs, patch them\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"pytest-of-john_doe\" in str(p)\n             fn = tmp_path / 'foo.txt'\n             fn.write_text('hello')\n             mode = os.stat(str(fn)).st_mode\n",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..35e50ed 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -574,6 +574,36 @@ def test_class_weights_cv():\n     assert_array_equal(reg.predict([[-.2, 2]]), np.array([-1]))\n \n \n+import numpy as np\n+from sklearn.linear_model import RidgeClassifierCV\n+from sklearn.utils._testing import assert_array_equal, assert_equal\n+\n+def test_ridge_classifier_cv_store_cv_values():\n+    # Test RidgeClassifierCV's store_cv_values attribute.\n+    x = np.array([[-1.0, -1.0], [-1.0, 0], [-0.8, -1.0], \n+                  [1.0, 1.0], [1.0, 0.0]])\n+    y = np.array([1, 1, 1, -1, -1])\n+    alphas = [1e-1, 1e0, 1e1]\n+    \n+    n_samples = x.shape[0]\n+    n_alphas = len(alphas)\n+    \n+    # Test for single target\n+    r = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+    r.fit(x, y)\n+    assert r.cv_values_.shape == (n_samples, n_alphas)\n+    \n+    # Test for multi-target\n+    y_multi = np.array([[1, 1, 1, -1, -1],\n+                        [1, -1, 1, -1, 1],\n+                        [-1, -1, 1, -1, -1]]).transpose()\n+    n_targets = y_multi.shape[1]\n+    r.fit(x, y_multi)\n+    assert r.cv_values_.shape == (n_samples, n_targets, n_alphas)\n+\n+# Ensure that the RidgeClassifierCV with store_cv_values works as intended\n+test_ridge_classifier_cv_store_cv_values()\n+\n def test_ridgecv_store_cv_values():\n     # Test _RidgeCV's store_cv_values attribute.\n     rng = rng = np.random.RandomState(42)\n",
  "scikit-learn__scikit-learn-11281": "",
  "scikit-learn__scikit-learn-12471": "diff --git a/sklearn/preprocessing/tests/test_encoders.py b/sklearn/preprocessing/tests/test_encoders.py\nindex 3f9b211..fb3c3f4 100644\n--- a/sklearn/preprocessing/tests/test_encoders.py\n+++ b/sklearn/preprocessing/tests/test_encoders.py\n@@ -260,7 +260,55 @@ def test_one_hot_encoder_not_fitted():\n         enc.transform(X)\n \n \n-def test_one_hot_encoder_no_categorical_features():\n+import numpy as np\n+import pytest\n+from sklearn.preprocessing import OneHotEncoder\n+from numpy.testing import assert_array_equal\n+\n+def test_one_hot_encoder_handle_unknown_strings():\n+    X_train = np.array(['11111111', '22', '333', '4444']).reshape((-1, 1))\n+    X_test = np.array(['55555', '22']).reshape((-1, 1))\n+    \n+    # Non Regression test for the issue #12470\n+    # Test the ignore option, when categories are numpy string dtype\n+    # particularly when the known category strings are larger\n+    # than the unknown category strings\n+    ohe = OneHotEncoder(handle_unknown='ignore', sparse=False, dtype=bool)\n+    ohe.fit(X_train)\n+    X2_passed = X_test.copy()\n+    \n+    transformed = ohe.transform(X2_passed)\n+    expected = np.array([[0., 0., 0., 0.], [0., 1., 0., 0.]])\n+    \n+    assert_array_equal(transformed, expected)\n+    # ensure transformed data was not modified in place\n+    assert_array_equal(X_test, X2_passed)\n+\n+def test_one_hot_encoder_handle_unknown_strings_mixed_lengths():\n+    X_train = np.array(['short', 'a bit longer', 'longeststring']).reshape((-1, 1))\n+    X_test = np.array(['unknown', 'a bit longer']).reshape((-1, 1))\n+    \n+    ohe = OneHotEncoder(handle_unknown='ignore', sparse=False, dtype=bool)\n+    ohe.fit(X_train)\n+    X_test_transformed = ohe.transform(X_test)\n+    \n+    # Expecting all zeros for the unknown 'unknown' and correct one-hot for 'a bit longer'\n+    expected_transformed = np.array([[0., 0., 0.], [0., 1., 0.]])\n+    \n+    assert_array_equal(X_test_transformed, expected_transformed)\n+\n+def test_one_hot_encoder_handle_unknown_all_unknown():\n+    X_train = np.array(['cat', 'dog', 'mouse']).reshape((-1, 1))\n+    X_test = np.array(['elephant', 'tiger']).reshape((-1, 1))\n+    \n+    ohe = OneHotEncoder(handle_unknown='ignore', sparse=False, dtype=bool)\n+    ohe.fit(X_train)\n+    X_test_transformed = ohe.transform(X_test)\n+    \n+    # Expecting all zeros as all samples in X_test are unknown\n+    expected_transformed = np.zeros((2, 3), dtype=bool)\n+    \n+    assert_array_equal(X_test_transformed, expected_transformed)\n     X = np.array([[3, 2, 1], [0, 1, 1]], dtype='float64')\n \n     cat = [False, False, False]\n",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex f8e4d54..9361d08 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -598,7 +598,16 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n \n-def test_gaussian_mixture_fit():\n+import numpy as np\n+from sklearn.mixture import GaussianMixture\n+from numpy.testing import assert_array_equal\n+def test_gaussian_mixture_fit_predict_n_init():\n+    # Check that fit_predict is equivalent to fit.predict, when n_init > 1\n+    X = np.random.RandomState(0).randn(1000, 5)\n+    gm = GaussianMixture(n_components=5, n_init=5, random_state=0)\n+    y_pred1 = gm.fit_predict(X)\n+    y_pred2 = gm.predict(X)\n+    assert_array_equal(y_pred1, y_pred2)\n     # recover the ground truth\n     rng = np.random.RandomState(0)\n     rand_data = RandomData(rng)\n",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..cf5b823 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,3 +1,4 @@\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n@@ -70,8 +71,22 @@ def test_kernel_pca_consistent_transform():\n     transformed2 = kpca.transform(X_copy)\n     assert_array_almost_equal(transformed1, transformed2)\n \n+from sklearn.utils.testing import assert_allclose\n \n-def test_kernel_pca_sparse():\n+def test_kernel_pca_sign_consistency():\n+    rng = np.random.RandomState(0)\n+    X = rng.rand(10, 10)\n+    \n+    transformed_X_list = []\n+    \n+    for i in range(20):\n+        kpca = KernelPCA(n_components=7, kernel='rbf', eigen_solver='arpack', random_state=rng)\n+        transformed_X = kpca.fit_transform(X)\n+        transformed_X_list.append(transformed_X[0])\n+        \n+    # Check that all transformed results are the same up to a sign flip\n+    for i in range(1, 20):\n+        assert_allclose(np.abs(transformed_X_list[0]), np.abs(transformed_X_list[i]))\n     rng = np.random.RandomState(0)\n     X_fit = sp.csr_matrix(rng.random_sample((5, 4)))\n     X_pred = sp.csr_matrix(rng.random_sample((2, 4)))\n",
  "scikit-learn__scikit-learn-13439": "",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..77f3b12 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -11,6 +12,8 @@ import pytest\n import numpy as np\n \n from sklearn.utils.testing import assert_array_equal\n+from sklearn.ensemble import IsolationForest\n+from sklearn.utils import check_random_state\n from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_raises\n from sklearn.utils.testing import assert_raises_regex\n",
  "scikit-learn__scikit-learn-13497": "diff --git a/sklearn/feature_selection/tests/test_mutual_info.py b/sklearn/feature_selection/tests/test_mutual_info.py\nindex f5a2908..231ba06 100644\n--- a/sklearn/feature_selection/tests/test_mutual_info.py\n+++ b/sklearn/feature_selection/tests/test_mutual_info.py\n@@ -197,4 +197,15 @@ def test_mutual_info_options():\n         assert_array_equal(mi_1, mi_2)\n         assert_array_equal(mi_3, mi_4)\n \n-    assert not np.allclose(mi_1, mi_3)\n+    # Test with discrete_features as an array of indices\n+    assert_raises(ValueError, mutual_info, X, y, discrete_features='manual')\n+    assert_raises(ValueError, mutual_info, X_csr, y, discrete_features=[True, False, True])\n+    assert_raises(IndexError, mutual_info, X, y, discrete_features=[True, False, True, False])\n+    assert_raises(IndexError, mutual_info, X, y, discrete_features=[1, 4])\n+\n+    mi_5 = mutual_info(X, y, discrete_features=[True, False, True], random_state=0)\n+    mi_6 = mutual_info(X, y, discrete_features=[0, 2], random_state=0)\n+    \n+    assert_array_equal(mi_5, mi_6)\n+    \n+    assert not np.allclose(mi_1, mi_3)\n",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..1196cf5 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,3 +1,4 @@\n+\n import re\n from pprint import PrettyPrinter\n \n@@ -8,6 +9,8 @@ from sklearn.pipeline import make_pipeline\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.feature_selection import SelectKBest, chi2\n from sklearn import set_config\n+import numpy as np\n+from sklearn.linear_model import LogisticRegressionCV\n \n \n # Ignore flake8 (lots of line too long issues)\n@@ -214,8 +217,16 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n \n     set_config(print_changed_only=False)\n \n-\n-def test_pipeline():\n+def test_logistic_regression_cv_repr_with_array():\n+    \"\"\"Test `repr` of LogisticRegressionCV with array parameters when print_changed_only=True.\"\"\"\n+    set_config(print_changed_only=True)\n+    try:\n+        repr_output = repr(LogisticRegressionCV(Cs=np.array([0.1, 1])))\n+        assert isinstance(repr_output, str), \"repr output should be a string\"\n+    except Exception as e:\n+        assert False, f\"Unexpected error occurred: {e}\"\n+    finally:\n+        set_config(print_changed_only=False)\n     # Render a pipeline object\n     pipeline = make_pipeline(StandardScaler(), LogisticRegression(C=999))\n     expected = \"\"\"\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..172e3ef 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,3 +1,8 @@\n+\n+from sklearn.linear_model import LinearRegression\n+from sklearn.ensemble import RandomForestRegressor\n+from sklearn.ensemble import VotingClassifier, VotingRegressor\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "diff --git a/sklearn/neighbors/tests/test_nca.py b/sklearn/neighbors/tests/test_nca.py\nindex 3963eca..f732de0 100644\n--- a/sklearn/neighbors/tests/test_nca.py\n+++ b/sklearn/neighbors/tests/test_nca.py\n@@ -161,6 +161,21 @@ def test_params_validation():\n                          NCA(n_components=n_components).fit, X, y)\n \n \n+@pytest.mark.parametrize('param, value', [\n+    ('n_components', np.int64(3)),   # Test numpy integer type\n+    ('max_iter', np.int32(100)),     # Test another numpy integer type\n+    ('tol', np.float64(1e-4)),       # Test numpy float type\n+    ('tol', 1),                      # Test Python integer type for float parameter\n+])\n+def test_parameters_with_numpy_types(param, value):\n+    # Check if NeighborhoodComponentsAnalysis accepts numpy integer and floating types\n+    X = np.random.random_sample((100, 10))\n+    y = np.random.randint(2, size=100)\n+\n+    nca = NeighborhoodComponentsAnalysis(**{param: value})\n+    # Should not raise any error\n+    nca.fit(X, y)\n+\n def test_transformation_dimensions():\n     X = np.arange(12).reshape(4, 3)\n     y = [1, 1, 2, 2]\n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..456acb4 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -680,6 +680,34 @@ def test_unicode_kernel():\n                                 random_seed=0)\n \n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for the issue where an empty support_vectors_ causes ZeroDivisionError\n+    import numpy as np\n+    from scipy import sparse\n+    from sklearn import svm\n+\n+    # Sparse training data\n+    X_train = sparse.csr_matrix([\n+        [0, 1, 0, 0],\n+        [0, 0, 0, 1],\n+        [0, 0, 1, 0],\n+        [0, 0, 0, 1]\n+    ])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+\n+    # Create an SVR model with a 'linear' kernel\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+\n+    # Assert that support_vectors_ and dual_coef_ are empty\n+    assert not model.support_vectors_.data.size\n+    assert not model.dual_coef_.data.size\n+\n+    # Assert that no error occurs and model can predict without error\n+    y_pred = model.predict(X_train)\n+    assert y_pred is not None\n+\n+\n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n     sparse_gram = sparse.csr_matrix([[1, 0], [0, 1]])\n",
  "scikit-learn__scikit-learn-14983": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex dd52c66..9797ad6 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -972,7 +972,34 @@ def test_leave_one_p_group_out_error_on_fewer_number_of_groups():\n                          LeavePGroupsOut(n_groups=3).split(X, y, groups))\n \n \n-@ignore_warnings\n+import pytest\n+from sklearn.model_selection import RepeatedKFold, RepeatedStratifiedKFold\n+\n+@pytest.mark.parametrize(\n+    \"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold]\n+)\n+def test_repeated_cv_repr(RepeatedCV):\n+    n_splits, n_repeats = 2, 6\n+    repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats)\n+    repeated_cv_repr = ('{}(n_repeats=6, n_splits=2, random_state=None)'\n+                        .format(repeated_cv.__class__.__name__))\n+    assert repeated_cv_repr == repr(repeated_cv)\n+\n+@pytest.mark.parametrize(\n+    \"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold]\n+)\n+def test_repeated_cv_repr_with_random_state(RepeatedCV):\n+    n_splits, n_repeats, random_state = 3, 5, 42\n+    repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats, random_state=random_state)\n+    repeated_cv_repr = ('{}(n_repeats=5, n_splits=3, random_state=42)'\n+                        .format(repeated_cv.__class__.__name__))\n+    assert repeated_cv_repr == repr(repeated_cv)\n+\n+def test_repeated_cv_repr_defaults():\n+    rkf_default = repr(RepeatedKFold())\n+    rskf_default = repr(RepeatedStratifiedKFold())\n+    assert rkf_default == \"RepeatedKFold(n_splits=5, n_repeats=10, random_state=None)\"\n+    assert rskf_default == \"RepeatedStratifiedKFold(n_splits=5, n_repeats=10, random_state=None)\"\n def test_repeated_cv_value_errors():\n     # n_repeats is not integer or <= 0\n     for cv in (RepeatedKFold, RepeatedStratifiedKFold):\n",
  "scikit-learn__scikit-learn-15512": "",
  "scikit-learn__scikit-learn-15535": "",
  "scikit-learn__scikit-learn-25500": "diff --git a/sklearn/tests/test_isotonic.py b/sklearn/tests/test_isotonic.py\nindex 5021282..1cdd6cd 100644\n--- a/sklearn/tests/test_isotonic.py\n+++ b/sklearn/tests/test_isotonic.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n import numpy as np\n import pickle\n@@ -14,6 +15,7 @@ from sklearn.isotonic import (\n )\n \n from sklearn.utils.validation import check_array\n+from sklearn.calibration import CalibratedClassifierCV\n from sklearn.utils._testing import (\n     assert_allclose,\n     assert_array_equal,\n@@ -668,7 +670,25 @@ def test_isotonic_regression_sample_weight_not_overwritten():\n \n \n @pytest.mark.parametrize(\"shape\", [\"1d\", \"2d\"])\n-def test_get_feature_names_out(shape):\n+def test_isotonic_regression_with_calibrated_classifier():\n+    \"\"\"Check that CalibratedClassifierCV works with isotonic regression\n+    when set_config(transform_output=\"pandas\") is used.\"\"\"\n+\n+    from sklearn import set_config\n+    from sklearn.linear_model import SGDClassifier\n+    from sklearn.datasets import make_classification\n+\n+    pd = pytest.importorskip(\"pandas\")\n+\n+    X, y = make_classification(n_samples=30, n_features=3, random_state=42)\n+    base_clf = SGDClassifier()\n+    cal_clf = CalibratedClassifierCV(base_clf, method='isotonic')\n+\n+    with set_config(transform_output=\"pandas\"):\n+        cal_clf.fit(X, y)\n+        predictions = cal_clf.predict_proba(X)\n+\n+    assert isinstance(predictions, np.ndarray)\n     \"\"\"Check `get_feature_names_out` for `IsotonicRegression`.\"\"\"\n     X = np.arange(10)\n     if shape == \"2d\":\n",
  "scikit-learn__scikit-learn-25570": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex 23e3b97..4c4caa1 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -2121,6 +2121,56 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n     with pytest.raises(AttributeError, match=\"not provide get_feature_names_out\"):\n         ct.get_feature_names_out()\n \n+@pytest.mark.parametrize(\n+    \"empty_selection\",\n+    [[], np.array([False, False]), [False, False]],\n+    ids=[\"list\", \"bool\", \"bool_int\"],\n+)\n+def test_empty_selection_pandas_output(empty_selection):\n+    \"\"\"Check that pandas output works when there is an empty selection.\n+\n+    Non-regression test for gh-25487\n+    \"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+\n+    X = pd.DataFrame([[1.0, 2.2], [3.0, 1.0]], columns=[\"a\", \"b\"])\n+    ct = ColumnTransformer(\n+        [\n+            (\"categorical\", \"passthrough\", empty_selection),\n+            (\"numerical\", StandardScaler(), [\"a\", \"b\"]),\n+        ],\n+        verbose_feature_names_out=True,\n+    )\n+    ct.set_output(transform=\"pandas\")\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"numerical__a\", \"numerical__b\"])\n+\n+    ct.set_params(verbose_feature_names_out=False)\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"a\", \"b\"])\n+\n+def test_column_transformer_with_no_features():\n+    \"\"\"Test that ColumnTransformer handles transformers with no features when using pandas output.\"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+    np = pytest.importorskip(\"numpy\")\n+\n+    X = pd.DataFrame(data=[[1.0, 2.0, 3.0, 4.0], [4, 2, 2, 5]], columns=[\"a\", \"b\", \"c\", \"d\"])\n+    y = np.array([0, 1])\n+    categorical_features = []  # Empty selection for categorical features\n+    numerical_features = [\"a\", \"b\", \"c\"]\n+    model_preprocessing = (\n+        \"preprocessing\",\n+        ColumnTransformer(\n+            [\n+                ('categorical', 'passthrough', categorical_features),\n+                ('numerical', Pipeline([(\"scaler\", RobustScaler()),\n+                                        (\"imputer\", SimpleImputer(strategy=\"median\"))\n+                                        ]), numerical_features),\n+            ], remainder='drop')\n+    )\n+    pipeline = Pipeline([model_preprocessing, (\"classifier\", LGBMClassifier())]).set_output(transform=\"pandas\")\n+    pipeline.fit(X, y)\n+\n     # The feature names are prefixed because verbose_feature_names_out=True is default\n     ct.set_output(transform=\"pandas\")\n     X_trans_df0 = ct.fit_transform(X_df)\n@@ -2128,4 +2178,4 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n \n     ct.set_params(verbose_feature_names_out=False)\n     X_trans_df1 = ct.fit_transform(X_df)\n-    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n+    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n",
  "sphinx-doc__sphinx-10325": "diff --git a/tests/test_ext_autodoc_automodule.py b/tests/test_ext_autodoc_automodule.py\nindex 787cd0c..d57f2bd 100644\n--- a/tests/test_ext_autodoc_automodule.py\n+++ b/tests/test_ext_autodoc_automodule.py\n@@ -113,6 +113,10 @@ def test_automodule_special_members(app):\n     ]\n \n \n+import sys\n+import pytest\n+from .test_ext_autodoc import do_autodoc\n+\n @pytest.mark.sphinx('html', testroot='ext-autodoc',\n                     confoverrides={'autodoc_mock_imports': ['missing_module',\n                                                             'missing_package1',\n@@ -125,4 +129,225 @@ def test_subclass_of_mocked_object(app):\n \n     options = {'members': None}\n     actual = do_autodoc(app, 'module', 'target.need_mocks', options)\n-    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n",
  "sphinx-doc__sphinx-7975": "",
  "sphinx-doc__sphinx-8435": "",
  "sphinx-doc__sphinx-8506": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 08bd595..852b125 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -91,6 +91,49 @@ def test_get_full_qualified_name():\n     assert domain.get_full_qualified_name(node) == 'ls.-l'\n \n \n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+from sphinx import addnodes\n+from docutils import nodes\n+from sphinx.domains.std import StandardDomain\n+from sphinx.testing.util import assert_node\n+from sphinx.util.docutils import sphinx_domains\n+from sphinx.util.docutils import sphinx_domains\n+\n+@pytest.fixture\n+def app():\n+    return SphinxTestApp()\n+\n+def test_cmd_option_with_optional_value(app):\n+    \"\"\"Test for command option with an optional value.\"\"\"\n+    text = \".. option:: -j[=N]\"\n+    with sphinx_domains(app.env):\n+        doctree = app.env.get_doctree('index')\n+        doctree.extend(addnodes(desc=addnodes.desc(),\n+                                desc_signature=addnodes.desc_signature(text=text),\n+                                desc_name=addnodes.desc_name(text='-j'),\n+                                desc_addname=addnodes.desc_addname(text='[=N]')))\n+        assert_node(doctree, (addnodes.index, [addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '-j'],\n+                                                                                    [addnodes.desc_addname, '[=N]'])],\n+                                                         [addnodes.desc_content, ()])]))\n+        objects = list(app.env.get_domain(\"std\").get_objects())\n+        assert ('-j', '-j', 'cmdoption', 'index', 'cmdoption-j', 1) in objects\n+\n+def test_cmd_option_starting_with_bracket(app):\n+    \"\"\"Test for command option starting with a bracket.\"\"\"\n+    text = \".. option:: [enable=]PATTERN\"\n+    with sphinx_domains(app.env):\n+        doctree = app.env.get_doctree('index')\n+        doctree.extend(addnodes(desc=addnodes.desc(),\n+                                desc_signature=addnodes.desc_signature(text=text),\n+                                desc_name=addnodes.desc_name(text='[enable'),\n+                                desc_addname=addnodes.desc_addname(text='=]PATTERN')))\n+        assert_node(doctree, (addnodes.index, [addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '[enable'],\n+                                                                                    [addnodes.desc_addname, '=]PATTERN'])],\n+                                                         [addnodes.desc_content, ()])]))\n+        objects = list(app.env.get_domain(\"std\").get_objects())\n+        assert ('[enable', '[enable', 'cmdoption', 'index', 'cmdoption-arg-enable', 1) in objects\n+\n def test_glossary(app):\n     text = (\".. glossary::\\n\"\n             \"\\n\"\n",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..e6a6e94 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -21,6 +21,7 @@ from sphinx.ext.autodoc import ALL, ModuleLevelDocumenter, Options\n from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n from sphinx.testing.util import SphinxTestApp, Struct  # NOQA\n from sphinx.util.docutils import LoggingReporter\n+from .test_ext_autodoc import do_autodoc  # Ensure this import is present\n \n try:\n     # Enable pyximport to test cython module\n",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..501e192 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -16,6 +17,7 @@ from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tup\n import pytest\n \n from sphinx.util.typing import restify, stringify\n+from struct import Struct\n \n \n class MyClass1:\n@@ -119,7 +121,8 @@ def test_restify_broken_type_hints():\n     assert restify(BrokenType) == ':class:`tests.test_util_typing.BrokenType`'\n \n \n-def test_stringify():\n+def test_restify_struct_struct():\n+    assert restify(Struct) == \":class:`struct.Struct`\"\n     assert stringify(int) == \"int\"\n     assert stringify(str) == \"str\"\n     assert stringify(None) == \"None\"\n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..0dd04c2 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1455,6 +1455,35 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n         expected = \"\"\"\\\n :param param1:\n :type param1: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_other_parameters_with_napoleon_use_param_false(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param2** (:class:`MyClass <name.space.MyClass>` instance)\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_other_parameters_with_napoleon_use_param_true(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+\n+\"\"\"\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param param2:\n+:type param2: :class:`MyClass <name.space.MyClass>` instance\n \"\"\"\n         self.assertEqual(expected, actual)\n \n",
  "sphinx-doc__sphinx-8721": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\nindex d4fba47..a34b7fb 100644\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -49,7 +49,18 @@ def test_viewcode(app, status, warning):\n             '<span>    &quot;&quot;&quot;</span></div>\\n') in result\n \n \n-@pytest.mark.sphinx(testroot='ext-viewcode', tags=['test_linkcode'])\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode')\n+def test_viewcode_epub_default(app, status, warning):\n+    app.builder.build_all()\n+\n+    assert not (Path(app.outdir) / '_modules/spam/mod1.xhtml').exists()\n+\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode',\n+                    confoverrides={'viewcode_enable_epub': True})\n+def test_viewcode_epub_enabled(app, status, warning):\n+    app.builder.build_all()\n+\n+    assert (Path(app.outdir) / '_modules/spam/mod1.xhtml').exists()\n def test_linkcode(app, status, warning):\n     app.builder.build(['objects'])\n \n",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..938265b 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -350,6 +350,17 @@ def test_args():\n            # enclosing brackets needed on 0\n     raises(ValueError, lambda: Permutation([1, 1, 0]))\n     raises(ValueError, lambda: Permutation([[1], [1, 2]]))\n+    \n+    # New test cases for non-disjoint cycles\n+    # Test case: Non-disjoint cycles that should form identity permutation\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n+    # Test case: Non-disjoint cycles applied in left-to-right order\n+    assert Permutation([[0, 1], [1, 2]]) == Permutation([0, 2, 1])\n+    assert Permutation([[1, 2], [0, 2]]) == Permutation([2, 0, 1])\n+    # Test case: Overlapping cycles where earlier application affects later ones\n+    assert Permutation([[0, 1], [1, 2], [2, 0]]) == Permutation([0])\n+    # Test case: Larger cycle set with multiple overlaps\n+    assert Permutation([[0, 1], [0, 2], [2, 3]]) == Permutation([2, 0, 3, 1])\n     raises(ValueError, lambda: Permutation([4, 5], size=10))  # where are 0-3?\n     # but this is ok because cycles imply that only those listed moved\n     assert Permutation(4, 5) == Permutation([0, 1, 2, 3, 5, 4])\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..72027ce 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -1,4 +1,5 @@\n-from sympy import Abs, S, Symbol, I, Rational, PurePoly\n+\n+from sympy import Abs, S, Symbol, I, Rational, PurePoly, Matrix\n from sympy.matrices import Matrix, SparseMatrix, eye, zeros, ShapeError\n from sympy.utilities.pytest import raises\n \n@@ -449,6 +450,36 @@ def test_sparse_matrix():\n     assert SparseMatrix.eye(2).nnz() == 2\n \n \n+def test_hstack_vstack_zero_matrices():\n+    # Test hstack with zero-row matrices\n+    M1 = SparseMatrix.zeros(0, 0)\n+    M2 = SparseMatrix.zeros(0, 1)\n+    M3 = SparseMatrix.zeros(0, 2)\n+    M4 = SparseMatrix.zeros(0, 3)\n+    result = SparseMatrix.hstack(M1, M2, M3, M4)\n+    assert result.shape == (0, 6), f\"Expected shape (0, 6), got {result.shape}\"\n+\n+    # Test vstack with zero-column matrices\n+    M1 = SparseMatrix.zeros(0, 0)\n+    M2 = SparseMatrix.zeros(1, 0)\n+    M3 = SparseMatrix.zeros(2, 0)\n+    M4 = SparseMatrix.zeros(3, 0)\n+    result = SparseMatrix.vstack(M1, M2, M3, M4)\n+    assert result.shape == (6, 0), f\"Expected shape (6, 0), got {result.shape}\"\n+\n+    # Test with some non-zero dimension matrices to ensure no regression\n+    M1 = SparseMatrix.zeros(1, 0)\n+    M2 = SparseMatrix.zeros(1, 1)\n+    M3 = SparseMatrix.zeros(1, 2)\n+    M4 = SparseMatrix.zeros(1, 3)\n+    result = SparseMatrix.hstack(M1, M2, M3, M4)\n+    assert result.shape == (1, 6), f\"Expected shape (1, 6), got {result.shape}\"\n+\n+    M1 = SparseMatrix.zeros(0, 1)\n+    M2 = SparseMatrix.zeros(1, 1)\n+    result = SparseMatrix.vstack(M1, M2)\n+    assert result.shape == (1, 1), f\"Expected shape (1, 1), got {result.shape}\"\n+\n def test_transpose():\n     assert SparseMatrix(((1, 2), (3, 4))).transpose() == \\\n         SparseMatrix(((1, 3), (2, 4)))\n",
  "sympy__sympy-13471": "diff --git a/sympy/utilities/tests/test_pickling.py b/sympy/utilities/tests/test_pickling.py\nindex 52dcc20..84ec7a7 100644\n--- a/sympy/utilities/tests/test_pickling.py\n+++ b/sympy/utilities/tests/test_pickling.py\n@@ -81,8 +81,22 @@ def check(a, exclude=[], check_attr=True):\n \n #================== core =========================\n \n-\n-def test_core_basic():\n+import pickle\n+import sys\n+from sympy import Float, symbols, Add\n+\n+def test_pickle_float_expression_cross_version():\n+    # Simulate pickling a float-containing expression in Python 2 and loading in Python 3\n+    x = symbols(\"x\")\n+    expr = x + 1.0\n+    \n+    # Dump in Python 2 format\n+    dumped = pickle.dumps(expr, protocol=2)\n+    \n+    # Load in Python 3\n+    loaded = pickle.loads(dumped)\n+    \n+    assert expr == loaded, \"Expression did not pickle and unpickle correctly across Python versions\"\n     for c in (Atom, Atom(),\n               Basic, Basic(),\n               # XXX: dynamically created types are not picklable\n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..b6c1f56 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -272,8 +272,19 @@ def test_coth():\n \n     assert coth(k*pi*I) == -cot(k*pi)*I\n \n+def test_coth_subs_issue():\n+    from sympy import Symbol, coth, log, tan, I, pi, S\n \n-def test_coth_series():\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+\n+    # Test specific integral values that previously caused an error\n+    for n in [2, 3, 5, 6, 8, 9, 11, 12, 13, 15, 18]:\n+        assert e.subs(x, n) is not S.NaN  # Ensure that it does not return NaN or raise an error\n+\n+    # Original test cases\n+    assert coth(log(tan(2))) == coth(log(-tan(2)))\n+    assert coth(1 + I*pi/2) == tanh(1)\n     x = Symbol('x')\n     assert coth(x).series(x, 0, 8) == \\\n         1/x + x/3 - x**3/45 + 2*x**5/945 - x**7/4725 + O(x**8)\n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..9a7aaa2 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -187,6 +187,28 @@ def test_col_join():\n                    [0, 0, 1],\n                    [7, 7, 7]])\n \n+def test_issue_13643_col_insert():\n+    import sympy as sm\n+\n+    # Create a 6x6 identity matrix\n+    M = sm.eye(6)\n+    # Create a 6x2 matrix of twos\n+    V = 2 * sm.ones(6, 2)\n+    \n+    # Expected result after column insertion at index 3\n+    expected = sm.Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    \n+    # Check if col_insert correctly inserts columns\n+    result = M.col_insert(3, V)\n+    assert result == expected\n+\n def test_row_insert():\n     r4 = Matrix([[4, 4, 4]])\n     for i in range(-4, 5):\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..7fecf4f 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -662,8 +662,41 @@ def test_latex_sequences():\n     latex_str = r'\\left\\[\\ldots, 18, 4, 2, 0\\right\\]'\n     assert latex(SeqMul(s5, s6)) == latex_str\n \n-\n-def test_latex_FourierSeries():\n+def test_issue_seqformula_brackets():\n+    from sympy import symbols, SeqFormula, latex, oo\n+\n+    n = symbols('n', integer=True)\n+\n+    # Test case for infinite sequence\n+    seq_inf = SeqFormula(n**2, (n, 0, oo))\n+    expected_latex_inf = r'[0, 1, 4, 9, \\ldots]'\n+    assert latex(seq_inf) == expected_latex_inf\n+\n+    # Test case for finite sequence\n+    seq_finite = SeqFormula(n**2, (n, 0, 3))\n+    expected_latex_finite = r'[0, 1, 4, 9]'\n+    assert latex(seq_finite) == expected_latex_finite\n+\n+    # Test case for negative start\n+    seq_neg = SeqFormula(n**2, (n, -3, 0))\n+    expected_latex_neg = r'[\\ldots, 1, 4, 9, 0]'\n+    assert latex(seq_neg) == expected_latex_neg\n+\n+    # Test case for a simple periodic sequence\n+    from sympy import SeqPer\n+    seq_per = SeqPer((1, 2))\n+    expected_latex_per = r'[1, 2, 1, 2, \\ldots]'\n+    assert latex(seq_per) == expected_latex_per\n+\n+    # Test case for sequence addition\n+    seq_add = SeqFormula(n**2, (n, 0, oo)) + SeqPer((1, 2))\n+    expected_latex_add = r'[1, 3, 5, 11, \\ldots]'\n+    assert latex(seq_add) == expected_latex_add\n+\n+    # Test case for sequence multiplication\n+    seq_mul = SeqFormula(n**2, (n, 0, oo)) * SeqPer((1, 2))\n+    expected_latex_mul = r'[0, 2, 4, 18, \\ldots]'\n+    assert latex(seq_mul) == expected_latex_mul\n     latex_str = r'2 \\sin{\\left (x \\right )} - \\sin{\\left (2 x \\right )} + \\frac{2}{3} \\sin{\\left (3 x \\right )} + \\ldots'\n     assert latex(fourier_series(x, (x, -pi, pi))) == latex_str\n \n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..2ab8a73 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,12 @@\n+\n+def test_Poly_with_domain_RR_yz():\n+    # Test that Poly works with domain='RR[y,z]'\n+    from sympy.abc import x, y, z\n+    from sympy import Poly\n+\n+    p = Poly(1.2*x*y*z, x, domain='RR[y,z]')\n+    assert p.rep.domain == RR[y, z]\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +15,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n@@ -172,7 +181,10 @@ def test_Domain_preprocess():\n     assert Domain.preprocess('FF(23)') == FF(23)\n     assert Domain.preprocess('GF(23)') == GF(23)\n \n-    raises(OptionError, lambda: Domain.preprocess('Z[]'))\n+    assert Domain.preprocess('RR[x]') == RR[x]\n+    assert Domain.preprocess('CC[x]') == CC[x]\n+    assert Domain.preprocess('RR[x,y]') == RR[x, y]\n+    assert Domain.preprocess('CC[x,y]') == CC[x, y]\n \n     assert Domain.preprocess('Z[x]') == ZZ[x]\n     assert Domain.preprocess('Q[x]') == QQ[x]\n@@ -186,7 +198,10 @@ def test_Domain_preprocess():\n     assert Domain.preprocess('ZZ[x,y]') == ZZ[x, y]\n     assert Domain.preprocess('QQ[x,y]') == QQ[x, y]\n \n-    raises(OptionError, lambda: Domain.preprocess('Z()'))\n+    assert Domain.preprocess('RR[y,z]') == RR[y, z]\n+    assert Domain.preprocess('CC[y,z]') == CC[y, z]\n+\n+    raises(OptionError, lambda: Poly(1.2*x*y*z, x, domain='ZZ[y,z]'))\n \n     assert Domain.preprocess('Z(x)') == ZZ.frac_field(x)\n     assert Domain.preprocess('Q(x)') == QQ.frac_field(x)\n",
  "sympy__sympy-14774": "",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..2e70080 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6121,8 +6121,29 @@ def test_MatrixSymbol_printing():\n     assert pretty(A - B) == \"-B + A\"\n     assert pretty(A*B*C - A*B - B*C) == \"-A*B -B*C + A*B*C\"\n \n+from sympy import MatrixSymbol, pretty, symbols\n \n-def test_degree_printing():\n+def test_MatrixSymbol_pretty_printing_issue_14814():\n+    # Original test case for issue #14814\n+    n = symbols('n', integer=True)\n+    x = MatrixSymbol('x', n, n)\n+    y_star = MatrixSymbol('y*', n, n)\n+    assert pretty(x + y_star) == \"x + y*\"\n+\n+    # Additional test cases\n+    negative_a = symbols('a', negative=True)\n+    y = MatrixSymbol('y', n, n)\n+    assert pretty(-negative_a*x + -2*y*y) == \"-a*x - 2*y**2\"\n+\n+    z_underscore = MatrixSymbol('z_', n, n)\n+    assert pretty(z_underscore + x) == \"z_ + x\"\n+\n+    z_dash = MatrixSymbol('z-', n, n)\n+    assert pretty(z_dash + y) == \"z- + y\"\n+\n+    # Ensure no exception for complex symbol names\n+    complex_symbol = MatrixSymbol('complex*symbol', n, n)\n+    assert pretty(complex_symbol) == \"complex*symbol\"\n     expr1 = 90*degree\n     assert pretty(expr1) == u'90\u00b0'\n     expr2 = x*degree\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..f1c4a03 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -728,6 +728,38 @@ def test_dummification():\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 2 * F(t) + 5))\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 4 * F(t) + 5))\n \n+def test_curly_matrix_symbol():\n+    # Issue #15009\n+    from sympy import MatrixSymbol, lambdify\n+    curlyv = MatrixSymbol(\"{v}\", 2, 1)\n+    # Test if lambdify works with curly braces in MatrixSymbol name\n+    lam = lambdify(curlyv, curlyv)\n+    assert lam([[1], [2]]) == [[1], [2]]\n+    lam_dummify = lambdify(curlyv, curlyv, dummify=True)\n+    assert lam_dummify([[1], [2]]) == [[1], [2]]\n+\n+def test_various_matrixsymbol_names():\n+    from sympy import MatrixSymbol, lambdify, symbols\n+    # Regular symbol names\n+    x = symbols('x')\n+    A = MatrixSymbol('A', 2, 2)\n+    lam_A = lambdify(A, A)\n+    assert lam_A([[1, 2], [3, 4]]) == [[1, 2], [3, 4]]\n+    \n+    # Curly brace symbol names\n+    curlyA = MatrixSymbol('{A}', 2, 2)\n+    lam_curlyA = lambdify(curlyA, curlyA)\n+    assert lam_curlyA([[1, 2], [3, 4]]) == [[1, 2], [3, 4]]\n+    \n+    # More complex symbol names\n+    complex_name = MatrixSymbol('A{complicated}', 2, 2)\n+    lam_complex = lambdify(complex_name, complex_name)\n+    assert lam_complex([[1, 2], [3, 4]]) == [[1, 2], [3, 4]]\n+    \n+    # Dummify test\n+    lam_complex_dummify = lambdify(complex_name, complex_name, dummify=True)\n+    assert lam_complex_dummify([[1, 2], [3, 4]]) == [[1, 2], [3, 4]]\n+\n def test_python_keywords():\n     # Test for issue 7452. The automatic dummification should ensure use of\n     # Python reserved keywords as symbol names will create valid lambda\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..7eaf694 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..f23c5b3 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1726,7 +1726,14 @@ def test_latex_UnevaluatedExpr():\n     assert latex(x*he) == r\"x \\frac{1}{x}\"\n \n \n+from sympy import symbols, MatrixSymbol, latex\n+\n def test_MatrixElement_printing():\n+    # Test for indexed matrix-expression LaTeX printer issue\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n     # test cases for issue #11821\n     A = MatrixSymbol(\"A\", 1, 3)\n     B = MatrixSymbol(\"B\", 1, 3)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..d673093 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, exp, Eq\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -6,6 +7,21 @@ from sympy.utilities.pytest import raises\n \n \n def test_idiff():\n+    f = Function('f')\n+    g = Function('g')\n+    x = Symbol('x', real=True)\n+    y = Symbol('y', real=True)\n+\n+    # Test: idiff with Eq\n+    assert idiff(Eq(y*exp(y), x*exp(x)), y, x) == (x + 1)*exp(x - y)/(y + 1)\n+\n+    # Test: idiff with f(x) instead of y\n+    assert idiff(f(x)*exp(f(x)) - x*exp(x), f(x), x) == (x + 1)*exp(x - f(x))/(f(x) + 1)\n+\n+    # Test: idiff with multiple dependent variables\n+    assert idiff(f(x) - y*exp(x), [f(x), y], x) == (y + Derivative(y, x)) * exp(x)\n+    assert idiff(f(x) - y*exp(x), [y, f(x)], x) == -y + exp(-x) * Derivative(f(x), x)\n+    assert idiff(f(x) - g(x), [f(x), g(x)], x) == Derivative(g(x), x)\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     t = Symbol('t', real=True)\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_codegen.py b/sympy/utilities/tests/test_codegen.py\nindex 6bc2605..1d295e5 100644\n--- a/sympy/utilities/tests/test_codegen.py\n+++ b/sympy/utilities/tests/test_codegen.py\n@@ -581,8 +581,40 @@ def test_ccode_cse():\n         '}\\n'\n     )\n     assert source == expected\n+def test_ccode_unused_array_arg():\n+    from sympy.utilities.codegen import codegen\n+    from sympy import MatrixSymbol\n+    from sympy.utilities.codegen import CCodeGen\n+\n+    x = MatrixSymbol('x', 2, 1)\n+    # x does not appear in output\n+    name_expr = (\"test\", 1.0)\n+    generator = CCodeGen()\n+    result = codegen(name_expr, code_gen=generator, header=False, empty=False, argument_sequence=(x,))\n+    source = result[0][1]\n+    # note: x should appear as (double *)\n+    expected = (\n+        '#include \"test.h\"\\n'\n+        '#include <math.h>\\n'\n+        'double test(double *x) {\\n'\n+        '   double test_result;\\n'\n+        '   test_result = 1.0;\\n'\n+        '   return test_result;\\n'\n+        '}\\n'\n+    )\n+    assert source == expected\n+\n+def test_autowrap_cython_with_unused_array_arg():\n+    from sympy.utilities.autowrap import autowrap\n+    from sympy import MatrixSymbol\n+    import numpy as np\n+\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0\n+    f = autowrap(expr, args=(x,), backend='cython')\n \n-def test_empty_f_code():\n+    result = f(np.array([[1.0], [2.0]]))\n+    assert result == 1.0\n     code_gen = FCodeGen()\n     source = get_string(code_gen.dump_f95, [])\n     assert source == \"\"\n",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..234bb73 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -339,6 +339,13 @@ def test_intersection():\n \n     assert Intersection(S.Complexes, FiniteSet(S.ComplexInfinity)) == S.EmptySet\n \n+    # Test case for issue where Intersection should remove duplicates\n+    x = Symbol('x')\n+    assert Intersection({1}, {1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    assert Intersection({1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    assert Intersection({1, 1, 1}, {1, 1, 1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    assert Intersection({1, 1, 1}, {1, 1, 1}, {1, x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+\n     # issue 12178\n     assert Intersection() == S.UniversalSet\n \n",
  "sympy__sympy-17022": "diff --git a/sympy/printing/tests/test_numpy.py b/sympy/printing/tests/test_numpy.py\nindex fa5ed1f..05f2bdc 100644\n--- a/sympy/printing/tests/test_numpy.py\n+++ b/sympy/printing/tests/test_numpy.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Piecewise, lambdify, Equality, Unequality, Sum, Mod, cbrt, sqrt,\n     MatrixSymbol, BlockMatrix\n@@ -10,7 +11,8 @@ from sympy.codegen.array_utils import (CodegenArrayContraction,\n         CodegenArrayPermuteDims, CodegenArrayElementwiseAdd)\n from sympy.printing.lambdarepr import NumPyPrinter\n \n-from sympy.utilities.pytest import warns_deprecated_sympy\n+from sympy.utilities.pytest import warns_deprecated_sympy, raises\n+from sympy.matrices import Identity, MatrixSymbol\n from sympy.utilities.pytest import skip\n from sympy.external import import_module\n \n@@ -26,7 +28,21 @@ def test_numpy_piecewise_regression():\n     assert NumPyPrinter().doprint(p) == 'numpy.select([numpy.less(x, 0),True], [1,0], default=numpy.nan)'\n \n \n-def test_sum():\n+def test_issue_identity_matrix_numpy():\n+    if not np:\n+        skip(\"NumPy not installed\")\n+\n+    M = MatrixSymbol(\"M\", 2, 2)\n+    f = lambdify(M, M + Identity(2), modules='numpy')\n+    ma = np.array([[1, 2], [3, 4]])\n+    mr = np.array([[2, 2], [3, 5]])\n+\n+    assert (f(ma) == mr).all()\n+\n+    from sympy import symbols\n+    n = symbols('n', integer=True)\n+    N = MatrixSymbol(\"M\", n, n)\n+    raises(NotImplementedError, lambda: lambdify(N, N + Identity(n), modules='numpy'))\n     if not np:\n         skip(\"NumPy not installed\")\n \n",
  "sympy__sympy-17139": "",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..65727e6 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy import I, Rational, Symbol, pi, sqrt, S\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n@@ -95,6 +96,10 @@ def test_point():\n \n     raises(ValueError, lambda: Point(0, 0) + 10)\n \n+    # Test for commutativity of multiplication with scalar\n+    assert point1 + point2 * sympy.sympify(2.0) == point1 + sympy.sympify(2.0) * point2\n+    assert point1 * sympy.sympify(2.0) == sympy.sympify(2.0) * point1\n+\n     # Point differences should be simplified\n     assert Point(x*(x - 1), y) - Point(x**2 - x, y + 1) == Point(0, -1)\n \n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..9c8f841 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1894,6 +1894,43 @@ def test_normal():\n     assert e.normal() == e\n \n \n+def test_non_string_equality():\n+    # Expressions should not compare equal to strings\n+    x = symbols('x')\n+    one = sympify(1)\n+    assert (x == 'x') is False\n+    assert (x != 'x') is True\n+    assert (one == '1') is False\n+    assert (one != '1') is True\n+    assert (x + 1 == 'x + 1') is False\n+    assert (x + 1 != 'x + 1') is True\n+\n+    # Make sure == doesn't try to convert the resulting expression to a string\n+    # (e.g., by calling sympify() instead of _sympify())\n+    class BadRepr(object):\n+        def __repr__(self):\n+            raise RuntimeError\n+\n+    assert (x == BadRepr()) is False\n+    assert (x != BadRepr()) is True\n+\n+    # Test the original issue with a class that has a problematic repr\n+    class C:\n+        def __repr__(self):\n+            return 'x.y'\n+    try:\n+        _ = sympy.Symbol('x') == C()\n+    except AttributeError as e:\n+        assert str(e) == \"'Symbol' object has no attribute 'y'\"\n+\n+    # Test that a class whose repr is 'x' does not compare as equal to a Symbol('x')\n+    class CReprX:\n+        def __repr__(self):\n+            return 'x'\n+    assert sympy.Symbol('x') != CReprX()\n+\n+from sympy import symbols, sympify, Symbol, raises\n+\n def test_expr():\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n@@ -1902,4 +1939,4 @@ def test_expr():\n def test_ExprBuilder():\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..79908e4 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -547,6 +547,17 @@ def test_diophantine():\n     assert diophantine(x**2 + y**2 +3*x- 5, permute=True) == \\\n         set([(-1, 1), (-4, -1), (1, -1), (1, 1), (-4, 1), (-1, -1), (4, 1), (4, -1)])\n \n+    # Test for issue with incomplete results depending on symbol order with permute=True\n+    from sympy.abc import m, n\n+\n+    # Test with the original problematic symbol order\n+    assert diophantine(n**4 + m**4 - 2**4 - 3**4, syms=(m, n), permute=True) == \\\n+        {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n+\n+    # Test with the reverse order of symbols to ensure consistency\n+    assert diophantine(n**4 + m**4 - 2**4 - 3**4, syms=(n, m), permute=True) == \\\n+        {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n+\n     # issue 18122\n     assert check_solutions(x**2-y)\n     assert check_solutions(y**2-x)\n",
  "sympy__sympy-18532": "",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..67020dc 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,29 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_BlockDiagMatrix_one_element_conversion():\n+    from sympy import Matrix, BlockDiagMatrix\n+    # Test case for the issue where a BlockDiagMatrix with one matrix element can't be converted to a Matrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    \n+    try:\n+        B = Matrix(D)\n+        assert B == M, \"The conversion from BlockDiagMatrix to Matrix should yield the original matrix\"\n+    except Exception as e:\n+        assert False, f\"An exception was raised during conversion: {str(e)}\"\n+    \n+    # Ensure functionality with two elements remains unchanged\n+    D2 = BlockDiagMatrix(M, M)\n+    B2 = Matrix(D2)\n+    expected = Matrix([\n+        [1, 2, 0, 0],\n+        [3, 4, 0, 0],\n+        [0, 0, 1, 2],\n+        [0, 0, 3, 4]\n+    ])\n+    assert B2 == expected, \"The conversion from BlockDiagMatrix with two elements failed\"\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..1cc96c6 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n@@ -83,6 +84,28 @@ def test_block_index():\n     assert BI.as_explicit().equals(eye(6))\n \n \n+def test_issue_block_index_symbolic():\n+    # Test case derived from the issue statement\n+    A = MatrixSymbol('A', 1, 1)\n+    n, i = symbols('n i', integer=True)\n+    B = MatrixSymbol('B', n, 1)\n+    C = BlockMatrix([[A], [B]])\n+    \n+    # Check if the indexing does not simplify incorrectly\n+    assert C[i, 0] == MatrixElement(C, i, 0)\n+\n+    # Test with concrete values for n and index inside range\n+    n_val = 3\n+    B_concrete = MatrixSymbol('B', n_val, 1)\n+    C_concrete = BlockMatrix([[A], [B_concrete]])\n+    assert C_concrete[0, 0] == A[0, 0]\n+    assert C_concrete[1, 0] == B_concrete[0, 0]\n+    assert C_concrete[2, 0] == B_concrete[1, 0]\n+\n+    # Test with index out of range to ensure it does not simplify\n+    with raises(IndexError):\n+        C_concrete[3, 0]\n+\n def test_slicing():\n     A.as_explicit()[0, :]  # does not raise an error\n \n",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..197fb9e 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -309,6 +309,24 @@ def test_sign():\n     # if there is a fast way to know when and when you cannot prove an\n     # expression like this is zero then the equality to zero is ok\n     assert sign(eq).func is sign or sign(eq) == 0\n+\n+    # New test cases for the issue regarding sign rewrite to Abs\n+    from sympy import Symbol, Abs, Piecewise, Eq\n+\n+    x = Symbol('x')\n+    assert sign(x).rewrite(Abs) == Piecewise((0, Eq(x, 0)), (x/Abs(x), True))\n+\n+    # Test the rewritten form for zero\n+    assert sign(0).rewrite(Abs) == 0\n+\n+    # Test with a function symbol\n+    f = Function('f')\n+    y = Symbol('y')\n+    assert sign(f(y)).rewrite(Abs) == Piecewise((0, Eq(f(y), 0)), (f(y)/Abs(f(y)), True))\n+\n+    # Test with a known non-zero complex number\n+    z = 2 + 3*I\n+    assert sign(z).rewrite(Abs) == z / Abs(z)\n     # but sometimes it's hard to do this so it's better not to load\n     # abs down with tests that will be very slow\n     q = 1 + sqrt(2) - 2*sqrt(3) + 1331*sqrt(6)\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..90501e0 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -513,8 +513,28 @@ def test_partitions():\n             i += 1\n         assert i == RGS_enum(n)\n \n-\n-def test_binary_partitions():\n+def test_partition_uniqueness():\n+    # Test that the partitions produced are unique and not reused\n+    partition_examples = [\n+        (6, 2),\n+        (6, 3),\n+        (8, 4, 3),\n+        (3, None, 2),\n+        (4, 3)\n+    ]\n+    for example in partition_examples:\n+        seen_ids = set()\n+        for p in partitions(*example):\n+            # Check that the dictionary ID is unique for each partition\n+            partition_id = id(p)\n+            assert partition_id not in seen_ids, f\"Partition reused: {p}\"\n+            seen_ids.add(partition_id)\n+\n+    # Check that partitions don't affect each other\n+    part_list = list(partitions(6, k=2))\n+    for p in part_list:\n+        p[1] = 99  # Mutate the dictionary\n+    assert all(p[1] != 99 for p in partitions(6, k=2)), \"Partitions affect each other\"\n     assert [i[:] for i in binary_partitions(10)] == [[8, 2], [8, 1, 1],\n         [4, 4, 2], [4, 4, 1, 1], [4, 2, 2, 2], [4, 2, 2, 1, 1],\n         [4, 2, 1, 1, 1, 1], [4, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2],\n",
  "sympy__sympy-20212": "diff --git a/sympy/core/tests/test_power.py b/sympy/core/tests/test_power.py\nindex 686973b..0a2fc08 100644\n--- a/sympy/core/tests/test_power.py\n+++ b/sympy/core/tests/test_power.py\n@@ -253,8 +253,12 @@ def test_power_rewrite_exp():\n     assert all((1/func(x)).rewrite(exp) == 1/(func(x).rewrite(exp)) for func in\n                     (sin, cos, tan, sec, csc, sinh, cosh, tanh))\n \n+from sympy import oo, S, power, zoo\n \n def test_zero():\n+    # Test issue 19572\n+    assert 0 ** -oo == zoo\n+    assert power(0, -oo) == zoo\n     x = Symbol('x')\n     y = Symbol('y')\n     assert 0**x != 0\n",
  "sympy__sympy-20442": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 6a8906d..53334a4 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,7 +1,9 @@\n+\n from sympy import (Abs, Add, Function, Number, Rational, S, Symbol,\n                    diff, exp, integrate, log, sin, sqrt, symbols)\n from sympy.physics.units import (amount_of_substance, convert_to, find_unit,\n-                                 volume, kilometer)\n+                                 volume, kilometer, joule)\n+from sympy.physics.units.definitions import kg, m, s\n from sympy.physics.units.definitions import (amu, au, centimeter, coulomb,\n     day, foot, grams, hour, inch, kg, km, m, meter, millimeter,\n     minute, quart, s, second, speed_of_light, bit,\n",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..46e405d 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -28,6 +28,16 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+from sympy import Symbol\n+from pytest import raises\n+\n+def test_symbol_slots():\n+    s = Symbol('s')\n+    assert not hasattr(s, '__dict__')\n+    assert hasattr(s, '__slots__')\n+    with raises(AttributeError):\n+        s.x = 1\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-21055": "",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..155395f 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -6,9 +7,31 @@ from sympy import (\n     AccumBounds, Matrix, zeros, ZeroMatrix)\n from sympy.core.basic import _aresame\n from sympy.testing.pytest import XFAIL\n-from sympy.abc import a, x, y, z, t\n-\n-def test_subs():\n+from sympy.functions.elementary.trigonometric import sinh, cosh, tanh\n+from sympy.functions.elementary.piecewise import Piecewise\n+from sympy import exp\n+def test_issue_polynomial_error_with_subs():\n+    # Reproducing issue with sinh and Piecewise\n+    x_r, y_r, z_r = symbols('x_r y_r z_r', real=True)\n+    \n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr.subs({1: 1.0}) is not None  # Should not raise PolynomialError\n+\n+    # Test with cosh\n+    expr_cosh = exp(cosh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr_cosh.subs({1: 1.0}) is not None  # Should not raise PolynomialError\n+\n+    # Test with tanh\n+    expr_tanh = exp(tanh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr_tanh.subs({1: 1.0}) is not None  # Should not raise PolynomialError\n+\n+    # Simplified test with sinh without division by z\n+    expr_no_div = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True))))\n+    assert expr_no_div.subs({1: 1.0}) is not None  # Should not raise PolynomialError\n+\n+    # Ensure no errors without exp\n+    expr_no_exp = sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r)\n+    assert expr_no_exp.subs({1: 1.0}) is not None  # Should not raise PolynomialError\n     n3 = Rational(3)\n     e = x\n     e = e.subs(x, n3)\n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..acc2ade 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n@@ -5,6 +6,7 @@ from sympy.core.numbers import pi, zoo, I, AlgebraicNumber\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n from sympy.integrals.integrals import Integral\n+from sympy.core.function import Derivative\n from sympy.matrices import (Matrix, SparseMatrix, ImmutableMatrix,\n     ImmutableSparseMatrix, MatrixSymbol, MatrixKind, MatMul)\n \n@@ -34,7 +36,10 @@ def test_Symbol_kind():\n     assert comm_x.kind is NumberKind\n     assert noncomm_x.kind is UndefinedKind\n \n-def test_Integral_kind():\n+def test_Derivative_kind():\n+    A = MatrixSymbol('A', 2, 2)\n+    assert Derivative(x, x).kind is NumberKind\n+    assert Derivative(A, x).kind is MatrixKind(NumberKind)\n     A = MatrixSymbol('A', 2,2)\n     assert Integral(comm_x, comm_x).kind is NumberKind\n     assert Integral(A, comm_x).kind is MatrixKind(NumberKind)\n",
  "sympy__sympy-21847": "",
  "sympy__sympy-22005": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 341f63c..e7c3966 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n@@ -48,6 +49,15 @@ def test_solve_poly_system():\n     raises(NotImplementedError, lambda: solve_poly_system(\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\n     raises(PolynomialError, lambda: solve_poly_system([1/x], x))\n+    \n+    # Test for detection of infinite solution request\n+    raises(NotImplementedError, lambda: solve_poly_system([x - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system([y - 1], (x, y)))\n+    \n+    # Additional test cases to ensure the fix does not affect other functionalities\n+    raises(NotImplementedError, lambda: solve_poly_system([x*y - 1], x, y))\n+    assert solve_poly_system([x**2 - 1, y**2 - 1], x, y) == [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n+    assert solve_poly_system([x**2 + y**2 - 1], x, y) == [(1, 0), (-1, 0), (0, 1), (0, -1)]\n \n \n def test_solve_biquadratic():\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..386ea74 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,4 +1,6 @@\n+\n from sympy.core.basic import Basic\n+from sympy.core.parameters import evaluate\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n@@ -440,6 +442,22 @@ def test_unit():\n     assert Point(1, 1).unit == Point(sqrt(2)/2, sqrt(2)/2)\n \n \n+def test_issue_22684():\n+    # Used to give an error with evaluate(False)\n+    with evaluate(False):\n+        Point2D(1, 2)  # Point2D with simple integers should not raise an error\n+\n+    # Check if Point2D with imaginary parts raises error when evaluated\n+    raises(ValueError, lambda: Point2D(1 + I, 2))\n+\n+    # Ensure evaluate=False still works without error\n+    p = Point2D(1, 2, evaluate=False)\n+    assert isinstance(p, Point2D)\n+\n+    # Testing on complex numbers directly\n+    with evaluate(False):\n+        raises(ValueError, lambda: Point2D(1 + I, 2))\n+\n def test_dot():\n     raises(TypeError, lambda: Point(1, 2).dot(Line((0, 0), (1, 1))))\n \n",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..537fd00 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -346,8 +346,41 @@ def test_cse_MatrixSymbol():\n     n = symbols('n', integer=True)\n     B = MatrixSymbol(\"B\", n, n)\n     assert cse(B) == ([], [B])\n-\n-def test_cse_MatrixExpr():\n+def test_cse_MatrixSymbol_indexing():\n+    from sympy import symbols, MatrixSymbol, Matrix, cse\n+\n+    def sub_in_matrixsymbols(exp, matrices):\n+        for matrix in matrices:\n+            for i in range(matrix.shape[0]):\n+                for j in range(matrix.shape[1]):\n+                    name = \"%s_%d_%d\" % (matrix.name, i, j)\n+                    sym = symbols(name)\n+                    exp = exp.subs(sym, matrix[i, j])\n+        return exp\n+\n+    def t44(name):\n+        return Matrix(4, 4, lambda i, j: symbols('%s_%d_%d' % (name, i, j)))\n+\n+    # Construct matrices of symbols that work with our expressions\n+    a = t44(\"a\")\n+    b = t44(\"b\")\n+\n+    # Set up expression as a simple example\n+    e = a * b\n+\n+    # Put in matrixsymbols\n+    e2 = sub_in_matrixsymbols(e, [MatrixSymbol(\"a\", 4, 4), MatrixSymbol(\"b\", 4, 4)])\n+    cse_subs, cse_reduced = cse(e2)\n+\n+    # Assert that cse correctly identifies common subexpressions\n+    # And does not introduce unnecessary temporary variables for MatrixSymbols\n+    assert any(isinstance(sub[1], MatrixSymbol) for sub in cse_subs)\n+    assert all(not isinstance(expr, MatrixSymbol) for expr in cse_reduced)\n+\n+    # Check that the CSE results in the expected format\n+    # This checks that cse does not create extra copies of matrices\n+    print(cse_subs)\n+    print(cse_reduced)\n     A = MatrixSymbol('A', 3, 3)\n     y = MatrixSymbol('y', 3, 1)\n \n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..9292802 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -38,7 +39,12 @@ def test_array_negative_indices():\n         assert test_array[-1, -1] == 10\n \n \n-def test_issue_18361():\n+def test_issue_empty_array():\n+    for ArrayType in array_types:\n+        A = ArrayType([])\n+        assert isinstance(A, ArrayType)\n+        assert A.shape == (0,)\n+        assert list(A) == []\n     A = Array([sin(2 * x) - 2 * sin(x) * cos(x)])\n     B = Array([sin(x)**2 + cos(x)**2, 0])\n     C = Array([(x + x**2)/(x*sin(y)**2 + x*cos(y)**2), 2*sin(x)*cos(x)])\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..c5bf0f5 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,6 +1175,11 @@ def test_scipy_polys():\n \n \n \n+import inspect\n+from sympy.utilities.lambdify import lambdify\n+from sympy import Dummy, Function, symbols\n+x = symbols('x')\n+\n def test_lambdify_inspect():\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n@@ -1182,7 +1187,24 @@ def test_lambdify_inspect():\n     assert 'x**2' in inspect.getsource(f)\n \n \n-def test_issue_14941():\n+def test_tuple_with_one_element():\n+    # Test case to verify the issue with tuple with one element is fixed\n+    f = lambdify([], (1,))  # Should return a tuple with one element\n+    assert f() == (1,)\n+    \n+    f2 = lambdify([], (1, 2))  # Returns a tuple with two elements\n+    assert f2() == (1, 2)\n+\n+    # Test with a function having a list\n+    f3 = lambdify([], [1])  # Should return a list with one element\n+    assert f3() == [1]\n+\n+    # Test with multiple elements to ensure normal operation\n+    f4 = lambdify([], [1, 2])  # Should return a list with two elements\n+    assert f4() == [1, 2]\n+\n+    # Cleanup to avoid affecting other tests\n+    del f, f2, f3, f4\n     x, y = Dummy(), Dummy()\n \n     # test dict\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..5a27e64 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -528,6 +528,31 @@ def test_issue_22819():\n     assert Da.scale_factor == 1.66053906660000e-24\n \n \n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy import exp\n+    from sympy.physics.units import Quantity\n+    from sympy.physics.units.systems.si import SI\n+    from sympy.physics.units.dimensions import Dimension\n+\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n+\n+\n def test_issue_20288():\n     from sympy.core.numbers import E\n     from sympy.physics.units import energy\n",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..7305617 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -45,8 +45,21 @@ def test_tensor_product_expand():\n     assert TP(A + B, B + C).expand(tensorproduct=True) == \\\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n-\n-def test_tensor_product_commutator():\n+def test_tensor_product_expand_issue_24142():\n+    # Tests for fix of issue #24142\n+    assert TP(A - B, B - A).expand(tensorproduct=True) == \\\n+        TP(A, B) - TP(A, A) - TP(B, B) + TP(B, A)\n+    assert TP(2 * A + B, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A, A) + 2 * TP(A, B) + TP(B, A) + TP(B, B)\n+    assert TP(2 * A * B + A, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A * B, A) + 2 * TP(A * B, B) + TP(A, A) + TP(A, B)\n+    # Additional test cases\n+    assert TP(A + B, 2 * A + 3 * B).expand(tensorproduct=True) == \\\n+        2 * TP(A, A) + 3 * TP(A, B) + 2 * TP(B, A) + 3 * TP(B, B)\n+    assert TP(3 * A - B, A - 2 * B).expand(tensorproduct=True) == \\\n+        3 * TP(A, A) - 6 * TP(A, B) - TP(B, A) + 2 * TP(B, B)\n+    assert TP(x * A, y * B).expand(tensorproduct=True) == x * y * TP(A, B)\n+    assert TP(0 * A, B).expand(tensorproduct=True) == 0\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n         TP(A*B, C) - TP(B*A, C)\n     assert Comm(TP(A, B), TP(B, C)).doit() == \\\n",
  "sympy__sympy-24213": "",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..36392e5 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,10 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, V, milli, kilo\n+from sympy.core.singleton import S\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n@@ -27,6 +29,19 @@ def test_prefix_operations():\n     assert k / dodeca == S(1000) / 12\n     assert dodeca / dodeca == 1\n \n+    # Additional test cases for milli prefix issue\n+    assert milli * W == W / 1000\n+    assert milli * V == V / 1000\n+\n+    # Test cases to ensure the fix works correctly for other units\n+    assert milli * kilo == S.One / 1000\n+    assert W * milli == W / 1000\n+    assert V * milli == V / 1000\n+\n+    # Ensure that the prefix doesn't affect addition or subtraction\n+    assert (milli * W + W).simplify() == 1.001 * W\n+    assert (W - milli * W).simplify() == 0.999 * W\n+\n     m = Quantity(\"fake_meter\")\n     SI.set_quantity_dimension(m, S.One)\n     SI.set_quantity_scale_factor(m, S.One)\n",
  "django__django-12470": "diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py\nindex 067de1c..32ce94d 100644\n--- a/tests/model_inheritance/tests.py\n+++ b/tests/model_inheritance/tests.py\n@@ -5,10 +5,11 @@ from django.db import connection, models\n from django.test import SimpleTestCase, TestCase\n from django.test.utils import CaptureQueriesContext, isolate_apps\n \n+from django.db import connection\n from .models import (\n     Base, Chef, CommonInfo, GrandChild, GrandParent, ItalianRestaurant,\n     MixinModel, ParkingLot, Place, Post, Restaurant, Student, SubBase,\n-    Supplier, Title, Worker,\n+    Supplier, Title, Worker, Parent, Child,\n )\n \n \n",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..d366d72 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,7 +343,51 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n-    def test_order_by_f_expression(self):\n+    def test_order_by_self_referential_fk(self):\n+        author_1 = Author.objects.create(name=\"Author 1\")\n+        author_2 = Author.objects.create(name=\"Author 2\")\n+        # Create articles with authors\n+        a1 = Article.objects.create(headline=\"Article 1\", author=author_1)\n+        a2 = Article.objects.create(headline=\"Article 2\", author=author_2)\n+        # Assign editors to authors (self-referential FK)\n+        author_1.editor = author_2\n+        author_1.save()\n+        author_2.editor = author_1\n+        author_2.save()\n+        \n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline'),\n+        )\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'),\n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline'),\n+        )\n+\n+    def test_order_by_self_referential_fk_descending(self):\n+        author_1 = Author.objects.create(name=\"Author 1\")\n+        author_2 = Author.objects.create(name=\"Author 2\")\n+        # Create articles with authors\n+        a1 = Article.objects.create(headline=\"Article 1\", author=author_1)\n+        a2 = Article.objects.create(headline=\"Article 2\", author=author_2)\n+        # Assign editors to authors (self-referential FK)\n+        author_1.editor = author_2\n+        author_1.save()\n+        author_2.editor = author_1\n+        author_2.save()\n+        \n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('-author__editor'),\n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline'),\n+        )\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('-author__editor_id'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline'),\n+        )\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n                 \"Article 1\",\n",
  "django__django-13265": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..d00590d 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3201,8 +3201,23 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         form = SomeForm()\n         self.assertEqual(form['field'].id_for_label, 'myCustomID')\n         self.assertEqual(form['field_none'].id_for_label, 'id_field_none')\n+    def test_boundwidget_id_for_label_with_custom_id(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label uses the custom ID set in ChoiceWidget.options.\n+        \"\"\"\n+        class CustomForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('x', 'X'), ('y', 'Y')],\n+                widget=CheckboxSelectMultiple\n+            )\n \n-    def test_boundfield_widget_type(self):\n+        form = CustomForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        # Simulate setting custom ids in the widget options\n+        subwidgets[0].data['attrs']['id'] = 'custom_id_x'\n+        subwidgets[1].data['attrs']['id'] = 'custom_id_y'\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_x')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_y')\n         class SomeForm(Form):\n             first_name = CharField()\n             birthday = SplitDateTimeField(widget=SplitHiddenDateTimeWidget)\n",
  "django__django-16400": "diff --git a/tests/auth_tests/test_management.py b/tests/auth_tests/test_management.py\nindex de2502e..a97f13f 100644\n--- a/tests/auth_tests/test_management.py\n+++ b/tests/auth_tests/test_management.py\n@@ -1484,4 +1484,29 @@ class CreatePermissionsTests(TestCase):\n                 content_type__app_label=opts.app_label,\n                 codename=codename,\n             ).exists()\n-        )\n+        )\n+\n+\n+@override_settings(\n+    DATABASE_ROUTERS=[TenantDatabaseRouter()],\n+    TENANT_MAP={\"localhost\": \"default\", \"tenant_1\": \"other\"},\n+)\n+class MigrateCommandDatabaseParameterTests(TestCase):\n+    databases = {\"default\", \"other\"}\n+\n+    def test_migrate_command_respects_database_parameter(self):\n+        # Ensure the 'other' database is empty initially\n+        Permission.objects.using(\"other\").all().delete()\n+        self.assertFalse(Permission.objects.using(\"other\").exists())\n+\n+        # Run migrate command specifying the database\n+        out = StringIO()\n+        call_command(\"migrate\", database=\"other\", stdout=out)\n+        \n+        # Check that permissions were created in the 'other' database\n+        self.assertTrue(Permission.objects.using(\"other\").exists())\n+\n+        # Verify output to ensure the migrate used the correct database\n+        out_content = out.getvalue()\n+        self.assertIn(\"Running migrations:\", out_content)\n+        self.assertIn(\"other\", out_content)\n",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..921fcc1 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -640,6 +640,10 @@ def test_colorbar_format(fmt):\n             '$\\\\mathdefault{10^{-2}}$')\n \n \n+import matplotlib.pyplot as plt\n+import numpy as np\n+from matplotlib.colors import LogNorm, Normalize\n+\n def test_colorbar_scale_reset():\n     x, y = np.ogrid[-4:4:31j, -4:4:31j]\n     z = 120000*np.exp(-x**2 - y**2)\n@@ -658,7 +662,32 @@ def test_colorbar_scale_reset():\n     assert cbar.outline.get_edgecolor() == mcolors.to_rgba('red')\n \n \n-def test_colorbar_get_ticks_2():\n+def test_colorbar_update_after_norm_change():\n+    # Create some random data\n+    img = 10**np.random.normal(1, 1, size=(50, 50))\n+\n+    # Create a figure and a set of subplots\n+    fig, ax = plt.subplots()\n+    \n+    # Plot the data\n+    plot = ax.imshow(img, cmap='gray')\n+    \n+    # Add a colorbar to the figure\n+    cb = fig.colorbar(plot, ax=ax)\n+    \n+    # Change the norm of the plot\n+    plot.set_norm(LogNorm(vmin=img.min(), vmax=img.max()))\n+    \n+    # Update the colorbar with the new norm\n+    cb.update_normal(plot)\n+    \n+    # Draw the canvas to update the colorbar\n+    fig.canvas.draw()\n+    \n+    # Check that the colorbar's tick labels have updated to reflect the new log scale\n+    tick_labels = [label.get_text() for label in cb.ax.yaxis.get_ticklabels()]\n+    assert '$\\\\mathdefault{10^{0}}$' in tick_labels\n+    assert '$\\\\mathdefault{10^{1}}$' in tick_labels\n     plt.rcParams['_internal.classic_mode'] = False\n     fig, ax = plt.subplots()\n     pc = ax.pcolormesh([[.05, .95]])\n",
  "pydata__xarray-4094": "",
  "scikit-learn__scikit-learn-25747": "",
  "sphinx-doc__sphinx-8801": "",
  "sympy__sympy-15346": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex cce4836..a7d9179 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     symbols, sin, simplify, cos, trigsimp, rad, tan, exptrigsimp,sinh,\n     cosh, diff, cot, Subs, exp, tanh, exp, S, integrate, I,Matrix,\n@@ -9,8 +10,30 @@ from sympy.utilities.pytest import XFAIL\n from sympy.abc import x, y, z, t, a, b, c, d, e, f, g, h, i, k\n \n \n-\n-def test_trigsimp1():\n+def test_issue_15129_trigsimp_methods():\n+    t1 = Matrix([sin(Rational(1, 50)), cos(Rational(1, 50)), 0])\n+    t2 = Matrix([sin(Rational(1, 25)), cos(Rational(1, 25)), 0])\n+    t3 = Matrix([cos(Rational(1, 25)), sin(Rational(1, 25)), 0])\n+    r1 = t1.dot(t2)\n+    r2 = t1.dot(t3)\n+    assert trigsimp(r1) == cos(S(1)/50)\n+    assert trigsimp(r2) == sin(S(3)/50)\n+\n+def test_trigsimp_with_rationals():\n+    # Test case for issue where sin/cos with Rationals couldn't be simplified\n+    expr1 = sin(Rational(1, 50)) * sin(Rational(1, 25)) + cos(Rational(1, 50)) * cos(Rational(1, 25))\n+    simplified_expr1 = trigsimp(expr1)\n+    assert simplified_expr1 == cos(S(1)/50 - S(1)/25)\n+\n+    # Test acos simplification\n+    expr2 = acos(expr1)\n+    simplified_expr2 = trigsimp(expr2)\n+    assert simplified_expr2 == acos(cos(S(1)/50 - S(1)/25))\n+\n+    # Additional sanity checks for correct simplifications\n+    expr3 = sin(x)*sin(y) + cos(x)*cos(y)\n+    simplified_expr3 = trigsimp(expr3)\n+    assert simplified_expr3 == cos(x - y)\n     x, y = symbols('x,y')\n \n     assert trigsimp(1 - sin(x)**2) == cos(x)**2\n",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..67e0d35 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4862,8 +4862,35 @@ k = \u2500\u2500\u2500\u2500\u2500                                \\n\\\n     assert pretty(expr) == ascii_str\n     assert upretty(expr) == ucode_str\n \n+def test_pretty_sum_issue_alignment():\n+    from sympy import Sum, oo\n+    from sympy.abc import x\n \n-def test_units():\n+    expr = Sum(x, (x, 1, oo)) + 3\n+    ascii_str = \\\n+\"\"\"\\\n+  oo    \\n\\\n+ ____   \\n\\\n+ \\\\     \\n\\\n+  \\\\   x\\n\\\n+  /   +\\n\\\n+ /__, 3\\n\\\n+x = 1  \\\n+\"\"\"\n+    ucode_str = \\\n+u(\"\"\"\\\n+  \u221e     \\n\\\n+ ____   \\n\\\n+ \u2572      \\n\\\n+  \u2572   x \\n\\\n+  \u2571   + \\n\\\n+ \u2571   3 \\n\\\n+ \u203e\u203e\u203e\u203e  \\n\\\n+x = 1  \\\n+\"\"\")\n+\n+    assert pretty(expr) == ascii_str\n+    assert upretty(expr) == ucode_str\n     expr = joule\n     ascii_str1 = \\\n \"\"\"\\\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex b2b6202..b9c6a5b 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -699,6 +699,25 @@ def test_uniq():\n     assert list(uniq('a')) == ['a']\n     assert list(uniq('ababc')) == list('abc')\n     assert list(uniq([[1], [2, 1], [1]])) == [[1], [2, 1]]\n+    \n+    # Test case 1: RuntimeError when modifying the list during iteration\n+    f = [1, 2, 3, 4]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Test case 2: RuntimeError with nested lists\n+    f = [[1], [2], [1], [3]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Test case 3: RuntimeError when element is added during iteration\n+    f = [1, 2, 3]\n+    def modify_and_iterate():\n+        for i in uniq(f):\n+            f.append(i)\n+    raises(RuntimeError, modify_and_iterate)\n+\n+    # Test case 4: No error with non-modifying operations\n+    f = [1, 2, 3, 4]\n+    assert list(uniq(f)) == [1, 2, 3, 4]  # Should not raise any error\n     assert list(uniq(permutations(i for i in [[1], 2, 2]))) == \\\n         [([1], 2, 2), (2, [1], 2), (2, 2, [1])]\n     assert list(uniq([2, 3, 2, 4, [2], [1], [2], [3], [1]])) == \\\n",
  "django__django-11797": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 7beeac3..c49374d 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -1,3 +1,4 @@\n+\n import collections.abc\n from datetime import datetime\n from math import ceil\n@@ -7,6 +8,7 @@ from django.core.exceptions import FieldError\n from django.db import connection\n from django.db.models.expressions import Exists, OuterRef\n from django.db.models.functions import Substr\n+from django.db.models import Max\n from django.test import TestCase, skipUnlessDBFeature\n \n from .models import (\n",
  "django__django-15320": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 35f7f03..d39f498 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -546,6 +546,33 @@ class BasicExpressionsTests(TestCase):\n         subquery_test2 = Company.objects.filter(pk=Subquery(small_companies.filter(num_employees=3)))\n         self.assertCountEqual(subquery_test2, [self.foobar_ltd])\n \n+    def test_subquery_sql_correctness(self):\n+        # Testing subquery SQL generation with default behavior\n+        from django.db import connection\n+        from apps.models import App\n+\n+        q = Subquery(App.objects.all())\n+        compiler = q.query.get_compiler('default', connection)\n+        sql, params = q.as_sql(compiler, connection)\n+\n+        # Ensure the SQL starts correctly and ends correctly.\n+        self.assertTrue(sql.startswith('(SELECT '))\n+        self.assertTrue(sql.strip().endswith(')'))\n+\n+    def test_subquery_no_subquery_flag(self):\n+        # Testing without subquery flag set directly to check default behavior\n+        from django.db import connection\n+        from apps.models import App\n+\n+        q = Subquery(App.objects.all())\n+        q.query.subquery = False  # Explicitly set to False to simulate issue\n+        compiler = q.query.get_compiler('default', connection)\n+        sql, params = q.as_sql(compiler, connection)\n+\n+        # Ensure the SQL is still wrapped correctly in parentheses\n+        self.assertTrue(sql.startswith('(SELECT '))\n+        self.assertTrue(sql.strip().endswith(')'))\n+\n     def test_uuid_pk_subquery(self):\n         u = UUIDPK.objects.create()\n         UUID.objects.create(uuid_fk=u)\n",
  "django__django-15819": "",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..76eba06 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -152,6 +153,33 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n+    def test_wrong_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(PoolStyle.objects.annotate(\n+                tournament_pool=FilteredRelation('pool__tournament__pool'),\n+            ).select_related('tournament_pool'))\n+            self.assertEqual(p[0].pool.tournament, p[0].tournament_pool.tournament)\n+\n+    def test_multilevel_reverse_fk_cyclic_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation(\"pool__tournament__pool\"),\n+                ).select_related(\"tournament_pool\", \"tournament_pool__tournament\")\n+            )\n+            self.assertEqual(p[0].tournament_pool.tournament, p[0].pool.tournament)\n+\n+    def test_multilevel_reverse_fk_select_related(self):\n+        with self.assertNumQueries(2):\n+            p = list(\n+                Tournament.objects.filter(id=self.t2.id)\n+                .annotate(\n+                    style=FilteredRelation(\"pool__another_style\"),\n+                )\n+                .select_related(\"style\")\n+            )\n+            self.assertEqual(p[0].style.another_pool, self.p3)\n+\n     def test_reverse_fk_select_related_multiple(self):\n         with self.assertNumQueries(1):\n             ps = list(\n@@ -163,4 +191,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex ad1a5e1..929f044 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from datetime import datetime\n import io\n@@ -11,7 +12,9 @@ import numpy as np\n import pytest\n from PIL import Image\n \n+import pickle\n import matplotlib as mpl\n+from matplotlib.figure import Figure\n from matplotlib import gridspec, rcParams\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n from matplotlib.axes import Axes\n",
  "mwaskom__seaborn-2848": "",
  "pytest-dev__pytest-5413": "diff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 226bfb9..bb4e890 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -323,6 +323,8 @@ class TestTraceback_f_g_h:\n         assert entry.frame.code.name == \"g\"\n \n \n+import pytest\n+\n def test_excinfo_exconly():\n     excinfo = pytest.raises(ValueError, h)\n     assert excinfo.exconly().startswith(\"ValueError\")\n@@ -347,7 +349,24 @@ def test_excinfo_str():\n     assert len(s.split(\":\")) >= 3  # on windows it's 4\n \n \n-def test_excinfo_for_later():\n+def test_raises_str_consistency():\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\n+            f\"A\\n\"\n+            f\"B\\n\"\n+            f\"C\"\n+        )\n+    \n+    # Test that str(excinfo) gives a consistent output\n+    assert str(excinfo) != \"<console>:3: LookupError: A\"\n+    assert str(excinfo.value) == \"A\\nB\\nC\"\n+\n+def test_raises_value_str():\n+    with pytest.raises(ValueError) as excinfo:\n+        raise ValueError(\"hello\\nworld\")\n+\n+    # Test that str(excinfo.value) gives the correct message\n+    assert str(excinfo.value) == \"hello\\nworld\"\n     e = ExceptionInfo.for_later()\n     assert \"for raises\" in repr(e)\n     assert \"for raises\" in str(e)\n",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..72ae1a3 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -405,6 +405,11 @@ class TestCustomConftests:\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n \n+    def test_collect_only_shortcut(self, testdir):\n+        testdir.makepyfile(\"def test_y(): pass\")\n+        result = testdir.runpytest(\"-c\")\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+\n     def test_pytest_collect_file_from_sister_dir(self, testdir):\n         sub1 = testdir.mkpydir(\"sub1\")\n         sub2 = testdir.mkpydir(\"sub2\")\n@@ -434,8 +439,43 @@ class TestCustomConftests:\n         p.copy(sub1.join(p.basename))\n         p.copy(sub2.join(p.basename))\n         result = testdir.runpytest(\"--collect-only\")\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+\n+    def test_collect_only_shortcut(self, testdir):\n+        testdir.makepyfile(\"def test_y(): pass\")\n+        result = testdir.runpytest(\"-c\")\n         result.stdout.fnmatch_lines([\"*MyModule1*\", \"*MyModule2*\", \"*test_x*\"])\n \n+    def test_collect_only_shortcut_in_sister_dir(self, testdir):\n+        sub1 = testdir.mkpydir(\"sub1\")\n+        sub2 = testdir.mkpydir(\"sub2\")\n+        conf1 = testdir.makeconftest(\n+            '''\n+            import pytest\n+            class MyModule1(pytest.Module):\n+                pass\n+            def pytest_collect_file(path, parent):\n+                if path.ext == \".py\":\n+                    return MyModule1(path, parent)\n+            '''\n+        )\n+        conf2 = testdir.makeconftest(\n+            '''\n+            import pytest\n+            class MyModule2(pytest.Module):\n+                pass\n+            def pytest_collect_file(path, parent):\n+                if path.ext == \".py\":\n+                    return MyModule2(path, parent)\n+            '''\n+        )\n+        conf2.move(sub2.join(conf2.basename))\n+        p = testdir.makepyfile(\"def test_y(): pass\")\n+        p.copy(sub1.join(p.basename))\n+        p.copy(sub2.join(p.basename))\n+        result = testdir.runpytest(\"-c\")\n+        result.stdout.fnmatch_lines([\"*MyModule1*\", \"*MyModule2*\", \"*test_y*\"])\n+\n \n class TestSession:\n     def test_parsearg(self, testdir):\n",
  "sphinx-doc__sphinx-10451": "diff --git a/tests/roots/test-ext-autodoc/target/typehints.py b/tests/roots/test-ext-autodoc/target/typehints.py\nindex 100ea06..bc6d551 100644\n--- a/tests/roots/test-ext-autodoc/target/typehints.py\n+++ b/tests/roots/test-ext-autodoc/target/typehints.py\n@@ -90,12 +90,20 @@ def missing_attr(c,\n     # type: (...) -> str\n     return a + (b or \"\")\n \n+class _ClassWithDocumentedInitAndStarArgs:\n+    \"\"\"Class docstring.\"\"\"\n+\n+    def __init__(self, x: int, *args: int, **kwargs: int) -> None:\n+        \"\"\"Init docstring.\n \n-class _ClassWithDocumentedInit:\n+        :param x: Some integer\n+        :param *args: Some integer\n+        :param **kwargs: Some integer\n+        \"\"\"\n     \"\"\"Class docstring.\"\"\"\n \n     def __init__(self, x: int) -> None:\n         \"\"\"Init docstring.\n \n         :param x: Some integer\n-        \"\"\"\n+        \"\"\"\n",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..264342f 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -83,8 +83,20 @@ def test_Identity():\n     assert transpose(In) == In\n     assert In.inverse() == In\n     assert In.conjugate() == In\n+from sympy import Symbol, symbols, MatrixSymbol, Identity, Sum, refine, assuming, Q\n \n def test_Identity_doit():\n+    n = Symbol('n', integer=True, positive=True)\n+    i, j = symbols('i j', integer=True)\n+    M = MatrixSymbol('M', n, n)\n+    \n+    e = None\n+    with assuming(Q.orthogonal(M)):\n+        e = refine((M.T * M).doit())\n+    \n+    # Test for the total sum of the elements of an identity matrix of size n\n+    total_sum = Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit()\n+    assert total_sum == n, f\"Expected {n}, but got {total_sum}\"\n     Inn = Identity(Add(n, n, evaluate=False))\n     assert isinstance(Inn.rows, Add)\n     assert Inn.doit() == Identity(2*n)\n",
  "sympy__sympy-20049": "",
  "sympy__sympy-21612": "diff --git a/sympy/parsing/tests/test_latex.py b/sympy/parsing/tests/test_latex.py\nindex b252985..05a4659 100644\n--- a/sympy/parsing/tests/test_latex.py\n+++ b/sympy/parsing/tests/test_latex.py\n@@ -251,7 +251,14 @@ def test_parseable():\n     for latex_str, sympy_expr in GOOD_PAIRS:\n         assert parse_latex(latex_str) == sympy_expr, latex_str\n \n-# These bad LaTeX strings should raise a LaTeXParsingError when parsed\n+def test_issue_21537():\n+    from sympy.parsing.latex import parse_latex\n+    from sympy import Pow, Add, Mul, symbols\n+\n+    a, b, c = symbols('a b c')\n+    expr = parse_latex(r\"\\frac{\\frac{a^3+b}{c}}{\\frac{1}{c^2}}\")\n+    expected = Mul(Add(Pow(a, 3), b), Pow(c, 2)) / c\n+    assert expr == expected\n BAD_STRINGS = [\n     r\"(\",\n     r\")\",\n"
}