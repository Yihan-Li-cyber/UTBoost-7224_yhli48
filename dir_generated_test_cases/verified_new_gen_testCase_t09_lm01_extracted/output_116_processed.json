{
  "astropy__astropy-12907": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 88711b0..3c8e41c 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -55,6 +55,28 @@ compound_models = {\n             )\n }\n \n+def test_nested_compound_model_separability():\n+    # Import necessary functions and modules\n+    import numpy as np\n+    from astropy.modeling import models as m\n+    from astropy.modeling.separable import separability_matrix\n+    \n+    # Define a nested compound model\n+    cm = m.Linear1D(10) & m.Linear1D(5)\n+    nested_model = m.Pix2Sky_TAN() & cm\n+\n+    # Calculate its separability matrix\n+    result = separability_matrix(nested_model)\n+    \n+    # Expected result for the nested compound model\n+    expected = np.array([[True, True, False, False],\n+                         [True, True, False, False],\n+                         [False, False, True, False],\n+                         [False, False, False, True]])\n+    \n+    # Assert if the computed result matches the expected separability matrix\n+    assert np.array_equal(result, expected), f\"Unexpected result: {result}\"\n+\n \n def test_coord_matrix():\n     c = _coord_matrix(p2, 'left', 2)\n",
  "astropy__astropy-13236": "",
  "astropy__astropy-13453": "",
  "astropy__astropy-13579": "",
  "astropy__astropy-14096": "",
  "astropy__astropy-14309": "",
  "astropy__astropy-14508": "diff --git a/astropy/io/fits/tests/test_header.py b/astropy/io/fits/tests/test_header.py\nindex 6bdf92c..f379249 100644\n--- a/astropy/io/fits/tests/test_header.py\n+++ b/astropy/io/fits/tests/test_header.py\n@@ -137,7 +137,64 @@ class TestHeaderFunctions(FitsTestCase):\n         ):\n             assert str(c) == _pad(\"FLOATNUM= -4.6737463674763E+32\")\n \n-    def test_complex_value_card(self):\n+    def test_floating_point_string_representation_card(self):\n+        \"\"\"\n+        Ensures Card formats float values with the correct precision, avoiding\n+        comment truncation\n+\n+        Regression test for https://github.com/astropy/astropy/issues/14507\n+        \"\"\"\n+        k = \"HIERARCH ABC DEF GH IJKLMN\"\n+        com = \"[m] abcdef ghijklm nopqrstu vw xyzab\"\n+        c = fits.Card(k, 0.009125, com)\n+        expected_str = f\"{k} = 0.009125 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        c = fits.Card(k, 8.95, com)\n+        expected_str = f\"{k} = 8.95 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        c = fits.Card(k, -99.9, com)\n+        expected_str = f\"{k} = -99.9 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+    def test_floating_point_more_cases(self):\n+        \"\"\"\n+        Additional tests for floating point precision and comment non-truncation\n+        \"\"\"\n+        k = \"HIERARCH TEST PRECISION\"\n+        com = \"Precision testing comment\"\n+\n+        # Boundary condition tests\n+        c = fits.Card(k, 1.234567890123456, com)\n+        expected_str = f\"{k} = 1.234567890123456 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        c = fits.Card(k, 0.0000001, com)  # very small value\n+        expected_str = f\"{k} = 1E-07 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        c = fits.Card(k, -1.2e-10, com)  # negative small value\n+        expected_str = f\"{k} = -1.2E-10 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        c = fits.Card(k, 999999999.9999999, com)  # large value\n+        expected_str = f\"{k} = 999999999.9999999 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        # Edge cases for significant digits\n+        c = fits.Card(k, 9.9999999999999e-3, com)\n+        expected_str = f\"{k} = 0.0099999999999999 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        # Regular edge tests\n+        c = fits.Card(k, 0.0, com)\n+        expected_str = f\"{k} = 0.0 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n+\n+        c = fits.Card(k, -0.0, com)\n+        expected_str = f\"{k} = -0.0 / {com}\"\n+        assert str(c)[: len(expected_str)] == expected_str\n         \"\"\"Test Card constructor with complex value\"\"\"\n \n         c = fits.Card(\"abc\", (1.2345377437887837487e88 + 6324767364763746367e-33j))\n",
  "astropy__astropy-14539": "diff --git a/astropy/io/fits/tests/test_diff.py b/astropy/io/fits/tests/test_diff.py\nindex 9bf4897..6df6e72 100644\n--- a/astropy/io/fits/tests/test_diff.py\n+++ b/astropy/io/fits/tests/test_diff.py\n@@ -601,7 +601,33 @@ class TestDiff(FitsTestCase):\n         assert \"13 different table data element(s) found (65.00% different)\" in report\n         assert report.count(\"more indices\") == 1\n \n-    def test_identical_files_basic(self):\n+    def test_fitsdiff_vla_behavior(self):\n+        \"\"\"\n+        Test FITSDiff behavior on files with variable-length arrays (VLAs).\n+        Ensure no differences are reported when a file is compared to itself.\n+        \"\"\"\n+\n+        # Create a FITS file with VLAs\n+        col_vla = Column(name='a', format='QD', array=[[0], [0, 0]])\n+        hdu_vla = BinTableHDU.from_columns([col_vla])\n+\n+        # Write to a temporary file\n+        with fits.open(hdu_vla) as hdu_list_vla:\n+            hdu_list_vla.writeto('temp_vla.fits', overwrite=True)\n+\n+        # Compare the file to itself\n+        diff_vla = FITSDiff('temp_vla.fits', 'temp_vla.fits')\n+        assert diff_vla.identical, \"The file should be identical to itself.\"\n+\n+        # Create another file with a slight difference\n+        col_vla_diff = Column(name='a', format='QD', array=[[0, 0], [0]])\n+        hdu_vla_diff = BinTableHDU.from_columns([col_vla_diff])\n+        with fits.open(hdu_vla_diff) as hdu_list_vla_diff:\n+            hdu_list_vla_diff.writeto('temp_vla_diff.fits', overwrite=True)\n+\n+        # Compare the original file with the modified file\n+        diff_vla_non_identical = FITSDiff('temp_vla.fits', 'temp_vla_diff.fits')\n+        assert not diff_vla_non_identical.identical, \"The files should not be identical.\"\n         \"\"\"Test identicality of two simple, extensionless files.\"\"\"\n \n         a = np.arange(100).reshape(10, 10)\n",
  "astropy__astropy-14995": "",
  "astropy__astropy-7166": "diff --git a/astropy/utils/tests/test_misc.py b/astropy/utils/tests/test_misc.py\nindex 77667e4..bccd486 100644\n--- a/astropy/utils/tests/test_misc.py\n+++ b/astropy/utils/tests/test_misc.py\n@@ -89,7 +89,24 @@ def test_inherit_docstrings():\n         assert Subclass.__call__.__doc__ == \"FOO\"\n \n \n-def test_set_locale():\n+def test_inherit_docstrings_properties():\n+    # Define a base class with a property that has a docstring\n+    class Base(metaclass=misc.InheritDocstrings):\n+        @property\n+        def bar(self):\n+            \"BAR\"\n+            return 42\n+\n+    # Subclass that should inherit the docstring for the property\n+    class Subclass(Base):\n+        @property\n+        def bar(self):\n+            # Overriding the property without a docstring\n+            return 84\n+\n+    # Check if the docstring was inherited\n+    if Base.bar.__doc__ is not None:\n+        assert Subclass.bar.__doc__ == \"BAR\"\n     # First, test if the required locales are available\n     current = locale.setlocale(locale.LC_ALL)\n     try:\n",
  "astropy__astropy-7336": "",
  "astropy__astropy-7606": "diff --git a/astropy/units/tests/test_units.py b/astropy/units/tests/test_units.py\nindex d95b776..7fe7bbc 100644\n--- a/astropy/units/tests/test_units.py\n+++ b/astropy/units/tests/test_units.py\n@@ -188,6 +188,13 @@ def test_unknown_unit3():\n     with pytest.raises(ValueError):\n         unit._get_converter(unit3)\n \n+    # Test for equality/inequality with None directly\n+    assert unit != None\n+    assert not (unit == None)\n+    # Test for membership check with None\n+    assert unit not in (None, u.m)\n+    assert unit in (unit2, unit3)\n+\n     x = unit.to_string('latex')\n     y = unit2.to_string('cgs')\n \n",
  "astropy__astropy-7671": "diff --git a/astropy/utils/tests/test_introspection.py b/astropy/utils/tests/test_introspection.py\nindex 852d721..e1ca6fd 100644\n--- a/astropy/utils/tests/test_introspection.py\n+++ b/astropy/utils/tests/test_introspection.py\n@@ -69,7 +69,23 @@ def test_minversion():\n     test_module.__version__ = '0.12.2'\n     good_versions = ['0.12', '0.12.1', '0.12.0.dev']\n     bad_versions = ['1', '1.2rc1']\n+    # Test cases for versions that should pass\n     for version in good_versions:\n         assert minversion(test_module, version)\n+\n+    # Test case for the issue described, using LooseVersion to check if it can differentiate correctly\n+    assert not minversion(test_module, '1.14dev')\n+    test_module.__version__ = '1.14.3'\n+    assert not minversion(test_module, '1.14dev')\n+\n+    # Additional test cases with more complex version strings\n+    complex_good_versions = ['0.12.2', '0.12.1.5', '0.13dev', '1.0b1']\n+    complex_bad_versions = ['0.12.3alpha', '0.13.0', '2.0']\n+    \n+    for version in complex_good_versions:\n+        assert minversion(test_module, version)\n+\n+    for version in complex_bad_versions:\n+        assert minversion(test_module, version)\n     for version in bad_versions:\n-        assert not minversion(test_module, version)\n+        assert not minversion(test_module, version)\n",
  "astropy__astropy-8707": "diff --git a/astropy/io/fits/tests/test_header.py b/astropy/io/fits/tests/test_header.py\nindex a2103c6..411abb2 100644\n--- a/astropy/io/fits/tests/test_header.py\n+++ b/astropy/io/fits/tests/test_header.py\n@@ -78,6 +78,21 @@ class TestHeaderFunctions(FitsTestCase):\n         assert header[0] == 'B'\n         assert header['B'] == 'B'\n         assert header.comments['B'] == 'C'\n+    def test_card_fromstring_str(self):\n+        \"\"\"Test loading a Card from a `str` object.\"\"\"\n+        c = fits.Card.fromstring(\"ABC     = 'str'\")\n+        assert c.keyword == 'ABC'\n+        assert c.value == 'str'\n+    \n+    def test_header_fromstring_str(self):\n+        \"\"\"Test reading a Header from a `str` string.\"\"\"\n+        with open(self.data('test0.fits'), 'r', encoding='ascii') as fobj:\n+            pri_hdr_from_str = fits.Header.fromstring(fobj.read())\n+        \n+        pri_hdr = fits.getheader(self.data('test0.fits'))\n+        assert pri_hdr['NAXIS'] == pri_hdr_from_str['NAXIS']\n+        assert pri_hdr == pri_hdr_from_str\n+        assert pri_hdr.tostring() == pri_hdr_from_str.tostring()\n \n     def test_card_constructor_default_args(self):\n         \"\"\"Test Card constructor with default argument values.\"\"\"\n",
  "astropy__astropy-8872": "diff --git a/astropy/units/tests/test_quantity.py b/astropy/units/tests/test_quantity.py\nindex 283420f..f0ff442 100644\n--- a/astropy/units/tests/test_quantity.py\n+++ b/astropy/units/tests/test_quantity.py\n@@ -143,6 +143,25 @@ class TestQuantityCreation:\n         q3 = u.Quantity(a3, u.yr)\n         assert q3.dtype == a3.dtype\n         # items stored as objects by numpy should be converted to float\n+\n+        # New test cases for dtype preservation with different float types\n+        a3_16 = np.array([1., 2.], dtype=np.float16)\n+        q3_16 = u.Quantity(a3_16, u.km)\n+        assert q3_16.dtype == a3_16.dtype\n+\n+        # Direct creation from scalars\n+        q_16_scalar = u.Quantity(np.float16(1), u.km)\n+        assert q_16_scalar.dtype == np.dtype('float16')\n+\n+        q_32_scalar = u.Quantity(np.float32(1), u.km)\n+        assert q_32_scalar.dtype == np.dtype('float32')\n+\n+        q_64_scalar = u.Quantity(np.float64(1), u.km)\n+        assert q_64_scalar.dtype == np.dtype('float64')\n+\n+        if hasattr(np, 'float128'):\n+            q_128_scalar = u.Quantity(np.float128(1), u.km)\n+            assert q_128_scalar.dtype == np.dtype('float128')\n         # by default\n         q4 = u.Quantity(decimal.Decimal('10.25'), u.m)\n         assert q4.dtype == float\n",
  "django__django-10097": "diff --git a/tests/validators/tests.py b/tests/validators/tests.py\nindex 90c3285..cfac72d 100644\n--- a/tests/validators/tests.py\n+++ b/tests/validators/tests.py\n@@ -218,6 +218,19 @@ TEST_DATA = [\n     (URLValidator(EXTENDED_SCHEMES), 'git+ssh://git@github.com/example/hg-git.git', None),\n \n     (URLValidator(EXTENDED_SCHEMES), 'git://-invalid.com', ValidationError),\n+    # URLs with invalid characters in username or password should be invalid\n+    (URLValidator(), 'http://fo:o@bar@example.com', ValidationError),\n+    (URLValidator(), 'http://foo@bar@baz@example.com', ValidationError),\n+    (URLValidator(), 'http://foo:ba@r@example.com', ValidationError),\n+    (URLValidator(), 'http://foo:ba:z@example.com', ValidationError),\n+    (URLValidator(), 'http://fo/o@bar@example.com', ValidationError),\n+    # URL with multiple \"@\" signs and unencoded invalid characters\n+    (URLValidator(), 'http://foo/bar@example.com', ValidationError),\n+    # URLs should require \":\" to be encoded in user:pass field\n+    (URLValidator(), 'http://foo:bar:baz@example.com', ValidationError),\n+    # URLs with valid encoding should be valid\n+    (URLValidator(), 'http://foo%3Abar%40baz@example.com', None),\n+    (URLValidator(), 'http://user%40name:pass%2Fword@domain.com', None),\n     # Trailing newlines not accepted\n     (URLValidator(), 'http://www.djangoproject.com/\\n', ValidationError),\n     (URLValidator(), 'http://[::ffff:192.9.5.5]\\n', ValidationError),\n",
  "django__django-10880": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex 491ba54..daccab0 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from decimal import Decimal\n@@ -9,6 +10,7 @@ from django.db.models import (\n     Max, Min, Sum, Value,\n )\n from django.test import TestCase\n+from django.db.models import Case, When\n from django.test.utils import Approximate, CaptureQueriesContext\n from django.utils import timezone\n \n@@ -395,6 +397,47 @@ class AggregateTestCase(TestCase):\n         sql = ctx.captured_queries[0]['sql']\n         self.assertIn('SELECT COUNT(*) ', sql)\n \n+    def test_count_distinct_expression(self):\n+        \"\"\"\n+        Test Count annotation with a Case condition and distinct=True.\n+        This verifies the fix for the issue with missing space in SQL syntax.\n+        \"\"\"\n+        aggs = Book.objects.aggregate(\n+            distinct_ratings=Count(\n+                Case(When(pages__gt=300, then='rating')), distinct=True\n+            ),\n+        )\n+        self.assertEqual(aggs['distinct_ratings'], 4)\n+\n+    def test_count_distinct_expression_no_match(self):\n+        \"\"\"\n+        Test when no Case condition matches. This should return 0, indicating no distinct ratings match the condition.\n+        \"\"\"\n+        aggs = Book.objects.aggregate(\n+            distinct_authors=Count(\n+                Case(When(pages__lt=0, then='author_id')), distinct=True\n+            ),\n+        )\n+        self.assertEqual(aggs['distinct_authors'], 0)\n+\n+    def test_count_distinct_expression_multiple_conditions(self):\n+        \"\"\"\n+        Test with multiple Case conditions combined and distinct=True.\n+        The query should correctly handle this without errors.\n+        \"\"\"\n+        aggs = Book.objects.aggregate(\n+            distinct_ratings_multiple=Count(\n+                Case(\n+                    When(pages__gt=300, rating__gt=3, then='rating'),\n+                    When(pages__lt=200, rating__gt=3, then='rating'),\n+                    output_field=IntegerField(),\n+                ),\n+                distinct=True\n+            ),\n+        )\n+        expected_count = [...]  # Determine the expected result based on test data\n+        self.assertEqual(aggs['distinct_ratings_multiple'], expected_count)\n+\n     def test_non_grouped_annotation_not_in_group_by(self):\n         \"\"\"\n         An annotation not included in values() before an aggregate should be\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..162e4be 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1100,6 +1100,9 @@ class OverrideSettingsTests(SimpleTestCase):\n         django.core.files.storage.default_storage.\n         \"\"\"\n         self.assertIsNone(default_storage.file_permissions_mode)\n+        # Test default FILE_UPLOAD_PERMISSIONS\n+        with self.settings():\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n         with self.settings(FILE_UPLOAD_PERMISSIONS=0o777):\n             self.assertEqual(default_storage.file_permissions_mode, 0o777)\n \n",
  "django__django-10973": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex 9eb05c7..85dbeae 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -1,5 +1,7 @@\n+\n import os\n import signal\n+import subprocess\n from unittest import mock\n \n from django.db.backends.postgresql.client import DatabaseClient\n@@ -113,4 +115,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         with mock.patch('subprocess.check_call', new=_mock_subprocess_call):\n             DatabaseClient.runshell_db({})\n         # dbshell restores the original handler.\n-        self.assertEqual(sigint_handler, signal.getsignal(signal.SIGINT))\n+        self.assertEqual(sigint_handler, signal.getsignal(signal.SIGINT))\n",
  "django__django-11066": "diff --git a/tests/contenttypes_tests/test_operations.py b/tests/contenttypes_tests/test_operations.py\nindex ff1d778..7519ae7 100644\n--- a/tests/contenttypes_tests/test_operations.py\n+++ b/tests/contenttypes_tests/test_operations.py\n@@ -5,6 +5,7 @@ from django.contrib.contenttypes.models import ContentType\n from django.core.management import call_command\n from django.db import migrations, models\n from django.test import TransactionTestCase, override_settings\n+from django.contrib.contenttypes.models import ContentType\n \n \n @override_settings(\n@@ -45,6 +46,21 @@ class ContentTypeOperationsTests(TransactionTestCase):\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n         call_command('migrate', 'contenttypes_tests', 'zero', database='default', interactive=False, verbosity=0)\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='foo').exists())\n+\n+    def test_existing_content_type_rename_other_database(self):\n+        class TestRouter:\n+            def db_for_write(self, model, **hints):\n+                return 'default'\n+\n+        with override_settings(DATABASE_ROUTERS=[TestRouter()]):\n+            ContentType.objects.using('other').create(app_label='contenttypes_tests', model='foo')\n+            other_content_types = ContentType.objects.using('other').filter(app_label='contenttypes_tests')\n+            call_command('migrate', 'contenttypes_tests', database='other', interactive=False, verbosity=0)\n+            self.assertFalse(other_content_types.filter(model='foo').exists())\n+            self.assertTrue(other_content_types.filter(model='renamedfoo').exists())\n+            call_command('migrate', 'contenttypes_tests', 'zero', database='other', interactive=False, verbosity=0)\n+            self.assertTrue(other_content_types.filter(model='foo').exists())\n+            self.assertFalse(other_content_types.filter(model='renamedfoo').exists())\n         self.assertFalse(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n \n     def test_missing_content_type_rename_ignore(self):\n@@ -53,6 +69,21 @@ class ContentTypeOperationsTests(TransactionTestCase):\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n         call_command('migrate', 'contenttypes_tests', 'zero', database='default', interactive=False, verbosity=0)\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='foo').exists())\n+\n+    def test_existing_content_type_rename_other_database(self):\n+        class TestRouter:\n+            def db_for_write(self, model, **hints):\n+                return 'default'\n+\n+        with override_settings(DATABASE_ROUTERS=[TestRouter()]):\n+            ContentType.objects.using('other').create(app_label='contenttypes_tests', model='foo')\n+            other_content_types = ContentType.objects.using('other').filter(app_label='contenttypes_tests')\n+            call_command('migrate', 'contenttypes_tests', database='other', interactive=False, verbosity=0)\n+            self.assertFalse(other_content_types.filter(model='foo').exists())\n+            self.assertTrue(other_content_types.filter(model='renamedfoo').exists())\n+            call_command('migrate', 'contenttypes_tests', 'zero', database='other', interactive=False, verbosity=0)\n+            self.assertTrue(other_content_types.filter(model='foo').exists())\n+            self.assertFalse(other_content_types.filter(model='renamedfoo').exists())\n         self.assertFalse(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n \n     def test_content_type_rename_conflict(self):\n@@ -60,7 +91,37 @@ class ContentTypeOperationsTests(TransactionTestCase):\n         ContentType.objects.create(app_label='contenttypes_tests', model='renamedfoo')\n         call_command('migrate', 'contenttypes_tests', database='default', interactive=False, verbosity=0)\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='foo').exists())\n+\n+    def test_existing_content_type_rename_other_database(self):\n+        class TestRouter:\n+            def db_for_write(self, model, **hints):\n+                return 'default'\n+\n+        with override_settings(DATABASE_ROUTERS=[TestRouter()]):\n+            ContentType.objects.using('other').create(app_label='contenttypes_tests', model='foo')\n+            other_content_types = ContentType.objects.using('other').filter(app_label='contenttypes_tests')\n+            call_command('migrate', 'contenttypes_tests', database='other', interactive=False, verbosity=0)\n+            self.assertFalse(other_content_types.filter(model='foo').exists())\n+            self.assertTrue(other_content_types.filter(model='renamedfoo').exists())\n+            call_command('migrate', 'contenttypes_tests', 'zero', database='other', interactive=False, verbosity=0)\n+            self.assertTrue(other_content_types.filter(model='foo').exists())\n+            self.assertFalse(other_content_types.filter(model='renamedfoo').exists())\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n         call_command('migrate', 'contenttypes_tests', 'zero', database='default', interactive=False, verbosity=0)\n         self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='foo').exists())\n-        self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n+\n+    def test_existing_content_type_rename_other_database(self):\n+        class TestRouter:\n+            def db_for_write(self, model, **hints):\n+                return 'default'\n+\n+        with override_settings(DATABASE_ROUTERS=[TestRouter()]):\n+            ContentType.objects.using('other').create(app_label='contenttypes_tests', model='foo')\n+            other_content_types = ContentType.objects.using('other').filter(app_label='contenttypes_tests')\n+            call_command('migrate', 'contenttypes_tests', database='other', interactive=False, verbosity=0)\n+            self.assertFalse(other_content_types.filter(model='foo').exists())\n+            self.assertTrue(other_content_types.filter(model='renamedfoo').exists())\n+            call_command('migrate', 'contenttypes_tests', 'zero', database='other', interactive=False, verbosity=0)\n+            self.assertTrue(other_content_types.filter(model='foo').exists())\n+            self.assertFalse(other_content_types.filter(model='renamedfoo').exists())\n+        self.assertTrue(ContentType.objects.filter(app_label='contenttypes_tests', model='renamedfoo').exists())\n",
  "django__django-11095": "diff --git a/tests/generic_inline_admin/tests.py b/tests/generic_inline_admin/tests.py\nindex 9dd9fd9..89b0286 100644\n--- a/tests/generic_inline_admin/tests.py\n+++ b/tests/generic_inline_admin/tests.py\n@@ -421,6 +421,47 @@ class GenericInlineModelAdminTest(SimpleTestCase):\n             form = MediaForm\n             model = Media\n \n+        def test_get_inlines_hook(self):\n+            class MediaInline(GenericTabularInline):\n+                model = Media\n+\n+            class AlternateInline(GenericTabularInline):\n+                model = Media\n+\n+            class EpisodeAdmin(admin.ModelAdmin):\n+                inlines = (AlternateInline, MediaInline)\n+\n+                def get_inlines(self, request, obj=None):\n+                    if hasattr(request, 'name'):\n+                        if request.name == 'alternate':\n+                            return self.inlines[:1]\n+                        elif request.name == 'media':\n+                            return self.inlines[1:2]\n+                    return []\n+\n+            ma = EpisodeAdmin(Episode, self.site)\n+            request = self.request_factory.get('/')\n+            request.user = self.superuser\n+\n+            # Test default behavior\n+            self.assertEqual(ma.get_inlines(request), [])\n+            self.assertEqual(ma.get_inline_instances(request), [])\n+\n+            # Test alternate inline is returned\n+            request.name = 'alternate'\n+            self.assertEqual(ma.get_inlines(request, None), (AlternateInline,))\n+            self.assertEqual(type(ma.get_inline_instances(request)[0]), AlternateInline)\n+\n+            # Test media inline is returned\n+            request.name = 'media'\n+            self.assertEqual(ma.get_inlines(request, None), (MediaInline,))\n+            self.assertEqual(type(ma.get_inline_instances(request)[0]), MediaInline)\n+\n+            # Test no permission scenario\n+            request.name = 'no_permission'\n+            self.assertEqual(ma.get_inlines(request, None), [])\n+            self.assertEqual(ma.get_inline_instances(request), [])\n+\n         class EpisodeAdmin(admin.ModelAdmin):\n             inlines = [\n                 AlternateInline, MediaInline\n@@ -428,4 +469,4 @@ class GenericInlineModelAdminTest(SimpleTestCase):\n         ma = EpisodeAdmin(Episode, self.site)\n         inlines = ma.get_inline_instances(request)\n         for (formset, inline), other_inline in zip(ma.get_formsets_with_inlines(request), inlines):\n-            self.assertIsInstance(formset, other_inline.get_formset(request).__class__)\n+            self.assertIsInstance(formset, other_inline.get_formset(request).__class__)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..6f891a3 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -248,7 +248,31 @@ class UsernameValidatorsTests(SimpleTestCase):\n                 with self.assertRaises(ValidationError):\n                     v(invalid)\n \n-    def test_ascii_validator(self):\n+    def test_trailing_newline_username(self):\n+        valid_usernames = ['validusername', 'anothervalidone']\n+        # Adding test cases for usernames with trailing newline\n+        invalid_usernames = ['validusername\\n', 'anothervalidone\\n', 'username\\nwithnewline']\n+\n+        unicode_validator = validators.UnicodeUsernameValidator()\n+        ascii_validator = validators.ASCIIUsernameValidator()\n+\n+        # Test with UnicodeUsernameValidator\n+        for valid in valid_usernames:\n+            with self.subTest(valid=valid):\n+                unicode_validator(valid)\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    unicode_validator(invalid)\n+\n+        # Test with ASCIIUsernameValidator\n+        for valid in valid_usernames:\n+            with self.subTest(valid=valid):\n+                ascii_validator(valid)\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    ascii_validator(invalid)\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n         invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n         v = validators.ASCIIUsernameValidator()\n@@ -258,4 +282,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11119": "diff --git a/tests/template_tests/test_engine.py b/tests/template_tests/test_engine.py\nindex ba32db8..1d72d45 100644\n--- a/tests/template_tests/test_engine.py\n+++ b/tests/template_tests/test_engine.py\n@@ -10,15 +10,27 @@ from .utils import ROOT, TEMPLATE_DIR\n OTHER_DIR = os.path.join(ROOT, 'other_templates')\n \n \n+import os\n+from django.template import Template, Context, Engine\n+from django.test import SimpleTestCase, override_settings\n+\n class RenderToStringTest(SimpleTestCase):\n \n     def setUp(self):\n         self.engine = Engine(dirs=[TEMPLATE_DIR])\n \n-    def test_basic_context(self):\n+    def test_autoescape_off(self):\n+        engine = Engine(dirs=[TEMPLATE_DIR], autoescape=False)\n+        self.assertEqual(\n+            engine.render_to_string('test_context.html', {'obj': '<script>'}),\n+            'obj:<script>\\n',\n+        )\n+\n+    def test_autoescape_on(self):\n+        engine = Engine(dirs=[TEMPLATE_DIR], autoescape=True)\n         self.assertEqual(\n-            self.engine.render_to_string('test_context.html', {'obj': 'test'}),\n-            'obj:test\\n',\n+            engine.render_to_string('test_context.html', {'obj': '<script>'}),\n+            'obj:&lt;script&gt;\\n',\n         )\n \n \n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..4987e72 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -413,7 +413,9 @@ class HttpResponseTests(unittest.TestCase):\n         self.assertEqual(list(i), [b'abc'])\n         self.assertEqual(list(i), [])\n \n-    def test_lazy_content(self):\n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview content'))\n+        self.assertEqual(r.content, b'memoryview content')\n         r = HttpResponse(lazystr('helloworld'))\n         self.assertEqual(r.content, b'helloworld')\n \n",
  "django__django-11141": "",
  "django__django-11149": "",
  "django__django-11163": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex b25d077..cbaa4ef 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -1820,7 +1820,22 @@ class ModelOneToOneFieldTests(TestCase):\n         bw2 = form.save()\n         self.assertEqual(bw2.score, 12)\n \n-    def test_onetoonefield(self):\n+    def test_model_to_dict_empty_fields(self):\n+        class BetterWriterForm(forms.ModelForm):\n+            class Meta:\n+                model = BetterWriter\n+                fields = '__all__'\n+\n+        bw = BetterWriter.objects.create(name='Joe Better', score=10)\n+        # Test for empty fields list\n+        self.assertEqual(model_to_dict(bw, fields={}), {})\n+        self.assertEqual(model_to_dict(bw, fields=[]), {})\n+\n+        # Test for None as fields (should return all fields)\n+        self.assertEqual(sorted(model_to_dict(bw, fields=None)), ['id', 'name', 'score', 'writer_ptr'])\n+\n+        # Test for valid fields\n+        self.assertEqual(model_to_dict(bw, fields=['id', 'name']), {'id': bw.id, 'name': 'Joe Better'})\n         class WriterProfileForm(forms.ModelForm):\n             class Meta:\n                 # WriterProfile has a OneToOneField to Writer\n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..a4d2853 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,9 +1,11 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n+from django.db.models.deletion import Collector\n from .models import (\n     MR, A, Avatar, Base, Child, HiddenUser, HiddenUserProfile, M, M2MFrom,\n     M2MTo, MRNull, Parent, R, RChild, S, T, User, create_a, get_default_r,\n",
  "django__django-11206": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 5fc4bdd..11950fb 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -95,6 +95,18 @@ class TestNumberFormat(SimpleTestCase):\n             ('1e-11', 8, '0.00000000'),\n             ('1' + ('0' * 300), 3, '1.000e+300'),\n             ('0.{}1234'.format('0' * 299), 3, '1.234e-300'),\n+            # Test issue case: extremely small decimals should be rounded to zero\n+            ('1e-199', 2, '0.00'),\n+            ('1e-200', 2, '0.00'),\n+            # Test similar cases with different precision value\n+            ('1e-199', 5, '0.00000'),\n+            ('1e-200', 5, '0.00000'),\n+            # Test larger numbers near cutoff point\n+            ('1e-198', 3, '0.000'),\n+            ('9.99e-199', 3, '0.000'),\n+            # Additional checks with other decimal points\n+            ('5e-201', 10, '0.0000000000'),\n+            ('3.14e-205', 8, '0.00000000'),\n         ]\n         for value, decimal_pos, expected_value in tests:\n             with self.subTest(value=value):\n",
  "django__django-11211": "diff --git a/tests/prefetch_related/models.py b/tests/prefetch_related/models.py\nindex 3ce4b3f..c5b12a0 100644\n--- a/tests/prefetch_related/models.py\n+++ b/tests/prefetch_related/models.py\n@@ -1,3 +1,4 @@\n+\n import uuid\n \n from django.contrib.contenttypes.fields import (\n@@ -192,6 +193,15 @@ class Comment(models.Model):\n     object_pk = models.TextField()\n     content_object = GenericForeignKey(ct_field=\"content_type\", fk_field=\"object_pk\")\n \n+class Foo(models.Model):\n+    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)\n+    name = models.CharField(max_length=100)\n+\n+class Bar(models.Model):\n+    foo_content_type = models.ForeignKey(ContentType, models.CASCADE, db_index=True)\n+    foo_object_id = models.CharField(max_length=255, db_index=True)\n+    foo = GenericForeignKey('foo_content_type', 'foo_object_id')\n+\n     class Meta:\n         ordering = ['id']\n \n",
  "django__django-11239": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex b843072..36e55a2 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -81,7 +81,28 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             )\n         )\n \n-    def test_sigint_handler(self):\n+    def test_ssl_certificate(self):\n+        self.assertEqual(\n+            self._run_it({\n+                'database': 'dbname',\n+                'user': 'someuser',\n+                'host': 'somehost',\n+                'port': '444',\n+                'sslmode': 'verify-ca',\n+                'sslrootcert': 'root.crt',\n+                'sslcert': 'client.crt',\n+                'sslkey': 'client.key',\n+            }), (\n+                ['psql', '-U', 'someuser', '-h', 'somehost', '-p', '444', 'dbname'],\n+                {\n+                    'PGSSLMODE': 'verify-ca',\n+                    'PGSSLROOTCERT': 'root.crt',\n+                    'PGSSLCERT': 'client.crt',\n+                    'PGSSLKEY': 'client.key',\n+                },\n+                None,\n+            )\n+        )\n         \"\"\"SIGINT is ignored in Python and passed to psql to abort quries.\"\"\"\n         def _mock_subprocess_run(*args, **kwargs):\n             handler = signal.getsignal(signal.SIGINT)\n",
  "django__django-11265": "diff --git a/tests/filtered_relation/tests.py b/tests/filtered_relation/tests.py\nindex a587c22..b6ba591 100644\n--- a/tests/filtered_relation/tests.py\n+++ b/tests/filtered_relation/tests.py\n@@ -82,6 +82,30 @@ class FilteredRelationTests(TestCase):\n                     (self.book4, self.author1),\n                 ], lambda x: (x, x.author_join))\n \n+    def test_exclude_with_join(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_alice=FilteredRelation('book', condition=Q(book__title__iexact='poem by alice')),\n+            ).exclude(book_alice__isnull=False),\n+            [self.author2]\n+        )\n+\n+    def test_exclude_with_join_and_different_condition(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_available=FilteredRelation('book', condition=Q(book__state=Book.AVAILABLE)),\n+            ).exclude(book_available__isnull=False),\n+            []\n+        )\n+\n+    def test_exclude_with_join_and_no_results(self):\n+        self.assertSequenceEqual(\n+            Author.objects.annotate(\n+                book_non_existent=FilteredRelation('book', condition=Q(book__title__iexact='non existent title')),\n+            ).exclude(book_non_existent__isnull=False),\n+            [self.author1, self.author2]\n+        )\n+\n     def test_without_join(self):\n         self.assertSequenceEqual(\n             Author.objects.annotate(\n",
  "django__django-11276": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex 4051a05..9635d4a 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -28,7 +28,10 @@ class TestUtilsHtml(SimpleTestCase):\n             ('>', '&gt;'),\n             ('\"', '&quot;'),\n             (\"'\", '&#39;'),\n+            (\"'single quotes'\", \"&#x27;single quotes&#x27;\"),\n         )\n+        self.assertEqual(escape(\"'\"), \"&#x27;\")\n+        self.assertEqual(escape('\"'), \"&quot;\")\n         # Substitution patterns for testing the above items.\n         patterns = (\"%s\", \"asdf%sfdsa\", \"%s1\", \"1%sb\")\n         for value, output in items:\n",
  "django__django-11292": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex b016284..0b59d65 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -243,6 +243,28 @@ class CommandRunTests(AdminScriptTestCase):\n         self.assertNoOutput(err)\n         self.assertEqual(out.strip(), '/PREFIX/some/url/')\n \n+    def test_skip_checks_with_errors(self):\n+        \"\"\"\n+        Test that the `--skip-checks` option actually skips system checks.\n+        \"\"\"\n+        self.write_settings('settings.py', apps=['django.contrib.staticfiles', 'user_commands'], sdict={\n+            'STATICFILES_DIRS': '\"foo\"',  # This should trigger a staticfiles check error\n+        })\n+        out, err = self.run_manage(['set_option', '--skip-checks', '--set', 'foo'])\n+        self.assertNoOutput(err)\n+        self.assertEqual(out.strip(), 'Set foo')\n+        \n+    def test_without_skip_checks_with_errors(self):\n+        \"\"\"\n+        Test that without the `--skip-checks` option, system checks are run and errors are output.\n+        \"\"\"\n+        self.write_settings('settings.py', apps=['django.contrib.staticfiles', 'user_commands'], sdict={\n+            'STATICFILES_DIRS': '\"foo\"',  # This should trigger a staticfiles check error\n+        })\n+        out, err = self.run_manage(['set_option', '--set', 'foo'])\n+        self.assertIn(\"The STATICFILES_DIRS setting is not a tuple or list.\", err)\n+        self.assertNotEqual(out.strip(), 'Set foo')\n+\n     def test_disallowed_abbreviated_options(self):\n         \"\"\"\n         To avoid conflicts with custom options, commands don't allow\n",
  "django__django-11333": "diff --git a/tests/urlpatterns/test_resolvers.py b/tests/urlpatterns/test_resolvers.py\nindex a9c1edd..1eb1c1e 100644\n--- a/tests/urlpatterns/test_resolvers.py\n+++ b/tests/urlpatterns/test_resolvers.py\n@@ -1,8 +1,37 @@\n+\n from django.test import SimpleTestCase\n-from django.urls.resolvers import RegexPattern, RoutePattern\n+from django.urls.resolvers import RegexPattern, RoutePattern, get_resolver\n+from django.test.utils import override_settings\n from django.utils.translation import gettext_lazy as _\n \n \n+class ResolverCacheTests(SimpleTestCase):\n+    \n+    @override_settings(ROOT_URLCONF='urlpatterns.path_urls')\n+    def test_resolver_cache_default_root_urlconf(self):\n+        # Resolver for a default URLconf (passing no argument) and for the\n+        # settings.ROOT_URLCONF is the same cached object.\n+        self.assertIs(get_resolver(), get_resolver('urlpatterns.path_urls'))\n+        self.assertIsNot(get_resolver(), get_resolver('urlpatterns.path_dynamic_urls'))\n+\n+    @override_settings(ROOT_URLCONF='urlpatterns.another_path_urls')\n+    def test_resolver_cache_with_different_urlconf(self):\n+        # This test ensures that a different URLconf produces a different cache object.\n+        resolver_before = get_resolver()\n+        resolver_after = get_resolver('urlpatterns.another_path_urls')\n+        self.assertIsNot(resolver_before, resolver_after)\n+\n+    @override_settings(ROOT_URLCONF='urlpatterns.path_urls')\n+    def test_resolver_cache_after_set_urlconf(self):\n+        # Initially, when ROOT_URLCONF is not set and get_resolver is called,\n+        # it should create a new resolver object, different from the one after the URLconf is set.\n+        initial_resolver = get_resolver()\n+        # Simulate setting the URLconf, mimicking request handling\n+        from django.urls import set_urlconf\n+        set_urlconf('urlpatterns.another_path_urls')\n+        new_resolver = get_resolver()\n+        self.assertIsNot(initial_resolver, new_resolver)\n+\n class RegexPatternTests(SimpleTestCase):\n \n     def test_str(self):\n@@ -12,4 +41,4 @@ class RegexPatternTests(SimpleTestCase):\n class RoutePatternTests(SimpleTestCase):\n \n     def test_str(self):\n-        self.assertEqual(str(RoutePattern(_('translated/'))), 'translated/')\n+        self.assertEqual(str(RoutePattern(_('translated/'))), 'translated/')\n",
  "django__django-11451": "diff --git a/tests/auth_tests/test_auth_backends.py b/tests/auth_tests/test_auth_backends.py\nindex b010b42..8170772 100644\n--- a/tests/auth_tests/test_auth_backends.py\n+++ b/tests/auth_tests/test_auth_backends.py\n@@ -241,8 +241,25 @@ class ModelBackendTest(BaseModelBackendTest, TestCase):\n             email='test2@example.com',\n             password='test',\n         )\n-\n-    def test_authenticate_inactive(self):\n+    @override_settings(PASSWORD_HASHERS=['auth_tests.test_auth_backends.CountingMD5PasswordHasher'])\n+    def test_authenticate_no_queries_when_username_or_password_none(self):\n+        \"\"\"\n+        Test that authenticate(username=None) or authenticate(password=None) does not trigger any database query.\n+        \"\"\"\n+        # Case where both username and password are None\n+        with self.subTest('username and password are None'):\n+            with self.assertNumQueries(0):\n+                self.assertIsNone(authenticate(username=None, password=None))\n+\n+        # Case where username is None only\n+        with self.subTest('username is None'):\n+            with self.assertNumQueries(0):\n+                self.assertIsNone(authenticate(username=None, password='some_password'))\n+\n+        # Case where password is None only\n+        with self.subTest('password is None'):\n+            with self.assertNumQueries(0):\n+                self.assertIsNone(authenticate(username='some_username', password=None))\n         \"\"\"\n         An inactive user can't authenticate.\n         \"\"\"\n",
  "django__django-11490": "",
  "django__django-11532": "diff --git a/tests/mail/tests.py b/tests/mail/tests.py\nindex a6f0e17..1257ad8 100644\n--- a/tests/mail/tests.py\n+++ b/tests/mail/tests.py\n@@ -16,6 +16,7 @@ from smtplib import SMTP, SMTPAuthenticationError, SMTPException\n from ssl import SSLError\n \n from django.core import mail\n+from unittest import mock\n from django.core.mail import (\n     EmailMessage, EmailMultiAlternatives, mail_admins, mail_managers,\n     send_mail, send_mass_mail,\n",
  "django__django-11551": "diff --git a/tests/modeladmin/test_checks.py b/tests/modeladmin/test_checks.py\nindex debaf8a..378e0c6 100644\n--- a/tests/modeladmin/test_checks.py\n+++ b/tests/modeladmin/test_checks.py\n@@ -1,9 +1,10 @@\n+\n from django import forms\n from django.contrib.admin import BooleanFieldListFilter, SimpleListFilter\n from django.contrib.admin.options import VERTICAL, ModelAdmin, TabularInline\n from django.contrib.admin.sites import AdminSite\n from django.core.checks import Error\n-from django.db.models import F\n+from django.db.models import F, Field, Model\n from django.db.models.functions import Upper\n from django.forms.models import BaseModelFormSet\n from django.test import SimpleTestCase\n",
  "django__django-11555": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex d1363b3..ebaebdd 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -2,6 +2,7 @@ from datetime import datetime\n from operator import attrgetter\n \n from django.core.exceptions import FieldError\n+from datetime import datetime\n from django.db.models import (\n     CharField, Count, DateTimeField, F, Max, OuterRef, Subquery, Value,\n )\n@@ -462,7 +463,37 @@ class OrderingTests(TestCase):\n             attrgetter('headline')\n         )\n \n-    def test_deprecated_values_annotate(self):\n+    def test_order_by_with_expressions_in_meta(self):\n+        ca1 = ChildArticle.objects.create(\n+            headline='h2',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_2,\n+        )\n+        ca2 = ChildArticle.objects.create(\n+            headline='h2',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_1,\n+        )\n+        ca3 = ChildArticle.objects.create(\n+            headline='h3',\n+            pub_date=datetime(2005, 7, 27),\n+            author=self.author_1,\n+        )\n+        ca4 = ChildArticle.objects.create(headline='h1', pub_date=datetime(2005, 7, 28))\n+        articles = ChildArticle.objects.order_by('article_ptr')\n+        self.assertSequenceEqual(articles, [ca4, ca2, ca1, ca3])\n+\n+    def test_ordering_with_expression_in_meta_proxy_model(self):\n+        a1 = OrderedByFArticle.objects.create(headline=\"Ordered Article 1\", pub_date=datetime(2005, 7, 26))\n+        a2 = OrderedByFArticle.objects.create(headline=\"Ordered Article 2\", pub_date=datetime(2005, 7, 27))\n+        OrderedByFArticle.objects.filter(headline='Ordered Article 1').update(author=self.author_1)\n+        OrderedByFArticle.objects.filter(headline='Ordered Article 2').update(author=self.author_2)\n+\n+        articles = OrderedByFArticle.objects.all()\n+        self.assertQuerysetEqual(\n+            articles, ['Ordered Article 2', 'Ordered Article 1'],\n+            attrgetter('headline')\n+        )\n         msg = (\n             \"Article QuerySet won't use Meta.ordering in Django 3.1. Add \"\n             \".order_by('-pub_date', 'headline', OrderBy(F(author__name), \"\n",
  "django__django-11603": "",
  "django__django-11740": "",
  "django__django-11749": "",
  "django__django-11790": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 440150b..cc915b9 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -437,7 +437,14 @@ class AuthenticationFormTest(TestDataMixin, TestCase):\n         self.assertEqual(form.fields['username'].max_length, 254)\n         self.assertEqual(form.errors, {})\n \n-    def test_username_field_label(self):\n+    def test_username_field_maxlength_html_attribute(self):\n+        data = {\n+            'username': 'testuser',\n+            'password': 'password',\n+        }\n+        form = AuthenticationForm(None, data)\n+        self.assertEqual(form.fields['username'].widget.attrs.get('maxlength'), 150, \n+                         \"The maxlength HTML attribute for the username field should be 150, matching the default User model's max_length.\")\n \n         class CustomAuthenticationForm(AuthenticationForm):\n             username = CharField(label=\"Name\", max_length=75)\n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..9840067 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -306,7 +306,22 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum(1))\"\n         )\n \n-    def test_serialize_choices(self):\n+    def test_enum_with_translated_values(self):\n+        from django.utils.translation import gettext_lazy as _\n+\n+        class TextTranslatedEnum(enum.Enum):\n+            A = _('a-value')\n+            B = _('value-b')\n+\n+        field = models.CharField(default=TextTranslatedEnum.A, choices=[(m.value, m) for m in TextTranslatedEnum])\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"models.CharField(choices=[\"\n+            \"('a-value', migrations.test_writer.TextTranslatedEnum['A']), \"\n+            \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n+            \"default=migrations.test_writer.TextTranslatedEnum['A'])\"\n+        )\n         class TextChoices(models.TextChoices):\n             A = 'A', 'A value'\n             B = 'B', 'B value'\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..db2da31 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,5 +1,6 @@\n+\n import unittest\n-from datetime import datetime\n+from datetime import datetime, timedelta\n \n from django.test import SimpleTestCase, ignore_warnings\n from django.utils.datastructures import MultiValueDict\n",
  "django__django-11880": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 95afc0d..a2a98df 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3686,7 +3686,34 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         self.assertIsInstance(p.files, MultiValueDict)\n \n \n-class CustomRenderer(DjangoTemplates):\n+class DeepCopyTestCases(SimpleTestCase):\n+\n+    def test_field_deep_copy_error_messages(self):\n+        class CustomCharField(CharField):\n+            def __init__(self, **kwargs):\n+                kwargs['error_messages'] = {'invalid': 'Form custom error message.'}\n+                super().__init__(**kwargs)\n+\n+        field = CustomCharField()\n+        field_copy = copy.deepcopy(field)\n+        self.assertIsInstance(field_copy, CustomCharField)\n+        self.assertIsNot(field_copy.error_messages, field.error_messages)\n+\n+    def test_deep_copy_error_messages_modification(self):\n+        class CustomCharField(CharField):\n+            default_error_messages = {'invalid': 'An unused default error message.'}\n+\n+            def __init__(self, **kwargs):\n+                kwargs['error_messages'] = {'invalid': 'Original custom error.'}\n+                super().__init__(**kwargs)\n+\n+        field = CustomCharField()\n+        field_copy = copy.deepcopy(field)\n+\n+        # Modify the error messages in the original and ensure the copy does not change\n+        field.error_messages['invalid'] = 'Modified original custom error.'\n+        self.assertNotEqual(field.error_messages['invalid'], field_copy.error_messages['invalid'],\n+                            \"Deep copied field's error messages should not reflect changes in the original field.\")\n     pass\n \n \n",
  "django__django-11951": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex f2f6bbd..81c92c4 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -1,5 +1,7 @@\n+\n from operator import attrgetter\n \n+from math import ceil\n from django.db import IntegrityError, NotSupportedError, connection\n from django.db.models import FileField, Value\n from django.db.models.functions import Lower\n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..48aa425 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -32,6 +32,21 @@ class Vehicle(models.IntegerChoices):\n     __empty__ = _('(Unknown)')\n \n \n+from django.test import SimpleTestCase\n+from django.utils.translation import gettext_lazy as _\n+from django.db import models\n+\n+# Define some test cases to test the enum value retrieval\n+class MyChoice(models.TextChoices):\n+    FIRST_CHOICE = \"first\", _(\"The first choice, it is\")\n+    SECOND_CHOICE = \"second\", _(\"The second choice, it is\")\n+\n+class EnumValueTests(SimpleTestCase):\n+    def test_enum_value_retrieval(self):\n+        # Test string conversion directly from enum member to ensure it's a value, not the member reference\n+        self.assertEqual(str(MyChoice.FIRST_CHOICE), \"first\")\n+        self.assertEqual(str(MyChoice.SECOND_CHOICE), \"second\")\n+\n class Gender(models.TextChoices):\n     MALE = 'M'\n     FEMALE = 'F'\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..0d03351 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -148,7 +148,24 @@ class ChoicesTests(SimpleTestCase):\n                 self.assertIsInstance(field.formfield(), forms.ChoiceField)\n \n \n-class GetFieldDisplayTests(SimpleTestCase):\n+from django.db import models\n+from django.test import TestCase\n+\n+class FooBar(models.Model):\n+    foo_bar = models.IntegerField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+    def get_foo_bar_display(self):\n+        return \"something\"\n+\n+class OverrideGetFieldDisplayTests(TestCase):\n+    \n+    def test_overriding_field_display(self):\n+        \"\"\"\n+        Test that `get_foo_bar_display` can be overridden and returns\n+        the expected value.\n+        \"\"\"\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), 'something')\n \n     def test_choices_and_field_display(self):\n         \"\"\"\n",
  "django__django-12039": "diff --git a/tests/indexes/tests.py b/tests/indexes/tests.py\nindex 700f574..85b6808 100644\n--- a/tests/indexes/tests.py\n+++ b/tests/indexes/tests.py\n@@ -10,7 +10,8 @@ from django.test import (\n     TestCase, TransactionTestCase, skipIfDBFeature, skipUnlessDBFeature,\n )\n from django.test.utils import override_settings\n-from django.utils import timezone\n+from django.db import connection\n+from django.db.models import Index\n \n from .models import (\n     Article, ArticleTranslation, IndexedArticle2, IndexTogetherSingleList,\n@@ -75,8 +76,74 @@ class SchemaIndexesTests(TestCase):\n         index_sql = connection.schema_editor()._model_indexes_sql(IndexTogetherSingleList)\n         self.assertEqual(len(index_sql), 1)\n \n+    def test_columns_list_sql(self):\n+        index = Index(fields=['headline'], name='whitespace_idx')\n+        editor = connection.schema_editor()\n+        self.assertIn(\n+            '(%s)' % editor.quote_name('headline'),\n+            str(index.create_sql(Article, editor)),\n+        )\n+\n+    def test_descending_columns_list_sql(self):\n+        index = Index(fields=['-headline'], name='whitespace_idx')\n+        editor = connection.schema_editor()\n+        self.assertIn(\n+            '(%s DESC)' % editor.quote_name('headline'),\n+            str(index.create_sql(Article, editor)),\n+        )\n+\n+    def test_ops_class_columns_lists_sql(self):\n+        index = Index(\n+            fields=['headline'],\n+            name='whitespace_idx',\n+            opclasses=['text_pattern_ops'],\n+        )\n+        with connection.schema_editor() as editor:\n+            self.assertIn(\n+                '(%s text_pattern_ops)' % editor.quote_name('headline'),\n+                str(index.create_sql(Article, editor)),\n+            )\n \n-@skipIf(connection.vendor == 'postgresql', 'opclasses are PostgreSQL only')\n+    def test_ops_class_descending_columns_list_sql(self):\n+        index = Index(\n+            fields=['-headline'],\n+            name='whitespace_idx',\n+            opclasses=['text_pattern_ops'],\n+        )\n+        with connection.schema_editor() as editor:\n+            self.assertIn(\n+                '(%s text_pattern_ops DESC)' % editor.quote_name('headline'),\n+                str(index.create_sql(Article, editor)),\n+            )\n+\n+    def test_columns_with_whitespace_fix(self):\n+        # Additional test case for handling whitespace correctly in ascending order\n+        index = Index(fields=['name'], name='idx')\n+        editor = connection.schema_editor()\n+        sql = str(index.create_sql(Article, editor))\n+        self.assertIn('(%s)' % editor.quote_name('name'), sql)\n+\n+    def test_columns_with_opclasses_whitespace_fix(self):\n+        # Test case for proper whitespace handling with opclasses without explicit ordering\n+        index = Index(\n+            fields=['name'],\n+            name='idx_with_opclass',\n+            opclasses=['text_pattern_ops'],\n+        )\n+        with connection.schema_editor() as editor:\n+            sql = str(index.create_sql(Article, editor))\n+            self.assertIn('(%s text_pattern_ops)' % editor.quote_name('name'), sql)\n+\n+    def test_columns_with_opclasses_and_desc_order_fix(self):\n+        # Make sure that opclasses with descending order are rendered correctly\n+        index = Index(\n+            fields=['-name'],\n+            name='idx_with_opclass_desc',\n+            opclasses=['text_pattern_ops'],\n+        )\n+        with connection.schema_editor() as editor:\n+            sql = str(index.create_sql(Article, editor))\n+            self.assertIn('(%s text_pattern_ops DESC)' % editor.quote_name('name'), sql)\n class SchemaIndexesNotPostgreSQLTests(TransactionTestCase):\n     available_apps = ['indexes']\n \n",
  "django__django-12050": "diff --git a/tests/queries/test_query.py b/tests/queries/test_query.py\nindex 49d26f3..740651e 100644\n--- a/tests/queries/test_query.py\n+++ b/tests/queries/test_query.py\n@@ -1,7 +1,9 @@\n+\n from datetime import datetime\n \n from django.core.exceptions import FieldError\n from django.db.models import CharField, F, Q\n+from django.db.models.lookups import Exact\n from django.db.models.expressions import SimpleCol\n from django.db.models.fields.related_lookups import RelatedIsNull\n from django.db.models.functions import Lower\n@@ -107,7 +109,26 @@ class TestQuery(SimpleTestCase):\n         self.assertIsInstance(b_isnull.lhs, SimpleCol)\n         self.assertEqual(b_isnull.lhs.target, ObjectC._meta.get_field('objectb'))\n \n-    def test_clone_select_related(self):\n+    def test_list_lookup_value(self):\n+        query = Query(Item)\n+        where = query.build_where(Q(name=['x', 'y', 'z']))\n+        name_exact = where.children[0]\n+        self.assertIsInstance(name_exact, Exact)\n+        self.assertEqual(name_exact.rhs, ['x', 'y', 'z'])\n+\n+    def test_tuple_lookup_value(self):\n+        query = Query(Item)\n+        where = query.build_where(Q(name=('x', 'y', 'z')))\n+        name_exact = where.children[0]\n+        self.assertIsInstance(name_exact, Exact)\n+        self.assertEqual(name_exact.rhs, ('x', 'y', 'z'))\n+\n+    def test_set_lookup_value(self):\n+        query = Query(Item)\n+        where = query.build_where(Q(name={'x', 'y', 'z'}))\n+        name_exact = where.children[0]\n+        self.assertIsInstance(name_exact, Exact)\n+        self.assertEqual(name_exact.rhs, {'x', 'y', 'z'})\n         query = Query(Item)\n         query.add_select_related(['creator'])\n         clone = query.clone()\n",
  "django__django-12125": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex e62f7b0..91cde84 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -179,6 +179,55 @@ class OperationWriterTests(SimpleTestCase):\n             '),'\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -229,12 +278,110 @@ class WriterTests(SimpleTestCase):\n             (\"Decimal('1.3')\", {'from decimal import Decimal'})\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n         self.assertSerializedEqual(Money('1.3'))\n         self.assertSerializedResultEqual(\n             Money('1.3'),\n             (\"migrations.test_writer.Money('1.3')\", {'import migrations.test_writer'})\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -270,6 +417,55 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set())\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r'^foo$')\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -280,18 +476,214 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {'import migrations.test_writer'})\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\"migrations.test_writer.TextTranslatedEnum['A']\", {'import migrations.test_writer'})\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\"migrations.test_writer.BinaryEnum['A']\", {'import migrations.test_writer'})\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {'import migrations.test_writer'})\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -299,6 +691,55 @@ class WriterTests(SimpleTestCase):\n                 {'import migrations.test_writer'},\n             ),\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(default=TextEnum.B, choices=[(m.value, m) for m in TextEnum])\n@@ -310,10 +751,108 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\"\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -322,6 +861,55 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\"\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         field = models.CharField(default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum])\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -331,6 +919,55 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\"\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         field = models.IntegerField(default=IntEnum.A, choices=[(m.value, m) for m in IntEnum])\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -341,6 +978,55 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\"\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = 'A', 'A value'\n@@ -360,6 +1046,55 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             ('datetime.date(1969, 7, 20)', {'import datetime'}),\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         field = models.CharField(default=TextChoices.B, choices=TextChoices.choices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -367,12 +1102,110 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices.choices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices.choices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -383,6 +1216,55 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\"\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_serialize_uuid(self):\n         self.assertSerializedEqual(uuid.uuid1())\n         self.assertSerializedEqual(uuid.uuid4())\n@@ -393,11 +1275,109 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {'import uuid'})\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {'import uuid'})\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n         field = models.UUIDField(choices=((uuid_a, 'UUID A'), (uuid_b, 'UUID B')), default=uuid_a)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -408,6 +1388,55 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\"\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_serialize_functions(self):\n         with self.assertRaisesMessage(ValueError, 'Cannot serialize function: lambda'):\n             self.assertSerializedEqual(lambda x: 42)\n@@ -430,6 +1459,55 @@ class WriterTests(SimpleTestCase):\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {'import datetime'})\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=utc),\n             (\n@@ -438,18 +1516,165 @@ class WriterTests(SimpleTestCase):\n             )\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"})\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n             (\"models.TextField(blank=True, null=True)\", {'from django.db import models'})\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\"))\n         self.assertSerializedResultEqual(\n@@ -457,12 +1682,110 @@ class WriterTests(SimpleTestCase):\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"})\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)),\n             (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -558,6 +1881,55 @@ class WriterTests(SimpleTestCase):\n             FoodQuerySet.as_manager(),\n             ('migrations.models.FoodQuerySet.as_manager()', {'import migrations.models'})\n         )\n+\n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n         self.assertSerializedEqual(FoodManager('a', 'b'))\n         self.assertSerializedEqual(FoodManager('x', 'y', c=3, d=4))\n \n@@ -661,6 +2033,55 @@ class WriterTests(SimpleTestCase):\n             result['custom_migration_operations'].more_operations.TestOperation\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -681,6 +2102,55 @@ class WriterTests(SimpleTestCase):\n             output\n         )\n \n+    class NestedChoices(models.TextChoices):\n+        X = 'X', 'X value'\n+        Y = 'Y', 'Y value'\n+\n+    def test_serialize_nested_class(self):\n+        for nested_cls in [self.NestedEnum, self.NestedChoices]:\n+            cls_name = nested_cls.__name__\n+            with self.subTest(cls_name):\n+                self.assertSerializedResultEqual(\n+                    nested_cls,\n+                    (\n+                        \"migrations.test_writer.WriterTests.%s\" % cls_name,\n+                        {'import migrations.test_writer'},\n+                    ),\n+                )\n+\n+    def test_serialize_inner_class_field(self):\n+        class Outer:\n+            class Inner(models.CharField):\n+                pass\n+\n+        class ModelWithInnerClassField(models.Model):\n+            field = Outer.Inner(max_length=20)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = ModelWithInnerClassField._meta.get_field('field')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(\n+            string,\n+            \"migrations.test_writer.Outer.Inner(max_length=20)\"\n+        )\n+\n+    def test_serialize_enum_field_inner_class(self):\n+        import enum\n+        from enumfields import Enum, EnumField\n+\n+        class Thing(models.Model):\n+            @enum.unique\n+            class State(Enum):\n+                on = 'on'\n+                off = 'off'\n+            \n+            state = EnumField(enum=State)\n+\n+        # Serialize the field and check if the path is resolved correctly.\n+        field = Thing._meta.get_field('state')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\"enumfields.fields.EnumField(enum=migrations.test_writer.Thing.State\", string)\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -746,4 +2216,4 @@ class WriterTests(SimpleTestCase):\n \n     def test_register_non_serializer(self):\n         with self.assertRaisesMessage(ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "django__django-12143": "diff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex 2d13234..4751a65 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -844,7 +844,47 @@ class ChangeListTests(TestCase):\n         queryset = m._get_list_editable_queryset(request, prefix='form')\n         self.assertEqual(queryset.count(), 2)\n \n-    def test_changelist_view_list_editable_changed_objects_uses_filter(self):\n+    def test_get_list_editable_queryset_with_escaped_prefix(self):\n+        \"\"\"Test list_editable queryset with special regex characters in prefix.\"\"\"\n+        a = Swallow.objects.create(origin='Swallow A', load=4, speed=1)\n+        Swallow.objects.create(origin='Swallow B', load=2, speed=2)\n+        data = {\n+            'form$.TOTAL_FORMS': '2',\n+            'form$.INITIAL_FORMS': '2',\n+            'form$.MIN_NUM_FORMS': '0',\n+            'form$.MAX_NUM_FORMS': '1000',\n+            'form$.0.uuid': str(a.pk),\n+            'form$.0.load': '10',\n+            '_save': 'Save',\n+        }\n+        superuser = self._create_superuser('superuser')\n+        self.client.force_login(superuser)\n+        changelist_url = reverse('admin:admin_changelist_swallow_changelist')\n+        m = SwallowAdmin(Swallow, custom_site)\n+        request = self.factory.post(changelist_url, data=data)\n+        queryset = m._get_list_editable_queryset(request, prefix='form$')\n+        self.assertEqual(queryset.count(), 1)\n+        \n+    def test_get_list_editable_queryset_with_multiple_special_chars(self):\n+        \"\"\"Test list_editable queryset with multiple special regex characters in prefix.\"\"\"\n+        a = Swallow.objects.create(origin='Swallow A', load=4, speed=1)\n+        Swallow.objects.create(origin='Swallow B', load=2, speed=2)\n+        data = {\n+            'form*#%!+TOTAL_FORMS': '2',\n+            'form*#%!+INITIAL_FORMS': '2',\n+            'form*#%!+MIN_NUM_FORMS': '0',\n+            'form*#%!+MAX_NUM_FORMS': '1000',\n+            'form*#%!+0.uuid': str(a.pk),\n+            'form*#%!+0.load': '10',\n+            '_save': 'Save',\n+        }\n+        superuser = self._create_superuser('superuser')\n+        self.client.force_login(superuser)\n+        changelist_url = reverse('admin:admin_changelist_swallow_changelist')\n+        m = SwallowAdmin(Swallow, custom_site)\n+        request = self.factory.post(changelist_url, data=data)\n+        queryset = m._get_list_editable_queryset(request, prefix='form*#%!')\n+        self.assertEqual(queryset.count(), 1)\n         \"\"\"list_editable edits use a filtered queryset to limit memory usage.\"\"\"\n         a = Swallow.objects.create(origin='Swallow A', load=4, speed=1)\n         Swallow.objects.create(origin='Swallow B', load=2, speed=2)\n",
  "django__django-12155": "",
  "django__django-12193": "diff --git a/tests/forms_tests/widget_tests/test_checkboxinput.py b/tests/forms_tests/widget_tests/test_checkboxinput.py\nindex 5c5e45d..afe74ea 100644\n--- a/tests/forms_tests/widget_tests/test_checkboxinput.py\n+++ b/tests/forms_tests/widget_tests/test_checkboxinput.py\n@@ -88,4 +88,24 @@ class CheckboxInputTest(WidgetTest):\n \n     def test_value_omitted_from_data(self):\n         self.assertIs(self.widget.value_omitted_from_data({'field': 'value'}, {}, 'field'), False)\n-        self.assertIs(self.widget.value_omitted_from_data({}, {}, 'field'), False)\n+\n+    def test_checkbox_initial_data_mutation(self):\n+        # Create a SplitArrayWidget with a CheckboxInput and an initial value of [True, False]\n+        widget = SplitArrayWidget(forms.CheckboxInput(), size=3)\n+        context = widget.get_context('name', [True, False, True])\n+        # Validate that only the correct checkboxes are marked checked\n+        self.assertEqual(\n+            [subwidget['attrs'] for subwidget in context['widget']['subwidgets']],\n+            [{'checked': True}, {}, {'checked': True}]\n+        )\n+\n+    def test_checkbox_with_all_false(self):\n+        # Create a SplitArrayWidget with a CheckboxInput and initial value of [False, False]\n+        widget = SplitArrayWidget(forms.CheckboxInput(), size=3)\n+        context = widget.get_context('name', [False, False, False])\n+        # Validate that none of the checkboxes are marked checked\n+        self.assertEqual(\n+            [subwidget['attrs'] for subwidget in context['widget']['subwidgets']],\n+            [{}, {}, {}]\n+        )\n+        self.assertIs(self.widget.value_omitted_from_data({}, {}, 'field'), False)\n",
  "django__django-12209": "",
  "django__django-12262": "diff --git a/tests/template_tests/test_custom.py b/tests/template_tests/test_custom.py\nindex 8a8c535..11c44f3 100644\n--- a/tests/template_tests/test_custom.py\n+++ b/tests/template_tests/test_custom.py\n@@ -50,6 +50,7 @@ class SimpleTagTests(TagTestCase):\n         c = Context({'value': 42})\n \n         templates = [\n+            ('{% load custom %}{% hello greeting=\"hi\" %}', 'hello - Expected result: hi world'),\n             ('{% load custom %}{% no_params %}', 'no_params - Expected result'),\n             ('{% load custom %}{% one_param 37 %}', 'one_param - Expected result: 37'),\n             ('{% load custom %}{% explicit_no_context 37 %}', 'explicit_no_context - Expected result: 37'),\n@@ -79,6 +80,33 @@ class SimpleTagTests(TagTestCase):\n                 'simple_unlimited_args_kwargs - Expected result: 37, 42, 56 / eggs=scrambled, four=4'),\n         ]\n \n+        # Additional tests specifically targeting the issue with keyword arguments\n+        additional_templates = [\n+            ('{% load custom %}{% hello %}', 'hello - Expected result: hello world'),\n+            ('{% load custom %}{% hello greeting=\"hi\" %}', 'hello - Expected result: hi world'),\n+        ]\n+\n+        for entry in additional_templates:\n+            t = self.engine.from_string(entry[0])\n+            self.assertEqual(t.render(c), entry[1])\n+\n+    def test_keyword_only_arguments_errors(self):\n+        # Testing for errors reported in the issue\n+        additional_errors = [\n+            (\"'hello' received multiple values for keyword argument 'greeting'\",\n+                '{% load custom %}{% hello greeting=\"hi\" greeting=\"hello\" %}'),\n+            (\"'hi' received multiple values for keyword argument 'greeting'\",\n+                '{% load custom %}{% hi greeting=\"hi\" greeting=\"hello\" %}'),\n+        ]\n+\n+        for entry in additional_errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(entry[1])\n+\n+        for entry in additional_errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(\"%s as var %%}\" % entry[1][0:-2])\n+\n         for entry in templates:\n             t = self.engine.from_string(entry[0])\n             self.assertEqual(t.render(c), entry[1])\n@@ -103,6 +131,33 @@ class SimpleTagTests(TagTestCase):\n                 '{% load custom %}{% simple_unlimited_args_kwargs 37 eggs=\"scrambled\" eggs=\"scrambled\" %}'),\n         ]\n \n+        # Additional tests specifically targeting the issue with keyword arguments\n+        additional_templates = [\n+            ('{% load custom %}{% hello %}', 'hello - Expected result: hello world'),\n+            ('{% load custom %}{% hello greeting=\"hi\" %}', 'hello - Expected result: hi world'),\n+        ]\n+\n+        for entry in additional_templates:\n+            t = self.engine.from_string(entry[0])\n+            self.assertEqual(t.render(c), entry[1])\n+\n+    def test_keyword_only_arguments_errors(self):\n+        # Testing for errors reported in the issue\n+        additional_errors = [\n+            (\"'hello' received multiple values for keyword argument 'greeting'\",\n+                '{% load custom %}{% hello greeting=\"hi\" greeting=\"hello\" %}'),\n+            (\"'hi' received multiple values for keyword argument 'greeting'\",\n+                '{% load custom %}{% hi greeting=\"hi\" greeting=\"hello\" %}'),\n+        ]\n+\n+        for entry in additional_errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(entry[1])\n+\n+        for entry in additional_errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(\"%s as var %%}\" % entry[1][0:-2])\n+\n         for entry in errors:\n             with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n                 self.engine.from_string(entry[1])\n@@ -192,6 +247,33 @@ class InclusionTagTests(TagTestCase):\n                 'inclusion_unlimited_args_kwargs - Expected result: 37, 42, 56 / eggs=scrambled, four=4\\n'),\n         ]\n \n+        # Additional tests specifically targeting the issue with keyword arguments\n+        additional_templates = [\n+            ('{% load custom %}{% hello %}', 'hello - Expected result: hello world'),\n+            ('{% load custom %}{% hello greeting=\"hi\" %}', 'hello - Expected result: hi world'),\n+        ]\n+\n+        for entry in additional_templates:\n+            t = self.engine.from_string(entry[0])\n+            self.assertEqual(t.render(c), entry[1])\n+\n+    def test_keyword_only_arguments_errors(self):\n+        # Testing for errors reported in the issue\n+        additional_errors = [\n+            (\"'hello' received multiple values for keyword argument 'greeting'\",\n+                '{% load custom %}{% hello greeting=\"hi\" greeting=\"hello\" %}'),\n+            (\"'hi' received multiple values for keyword argument 'greeting'\",\n+                '{% load custom %}{% hi greeting=\"hi\" greeting=\"hello\" %}'),\n+        ]\n+\n+        for entry in additional_errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(entry[1])\n+\n+        for entry in additional_errors:\n+            with self.assertRaisesMessage(TemplateSyntaxError, entry[0]):\n+                self.engine.from_string(\"%s as var %%}\" % entry[1][0:-2])\n+\n         for entry in templates:\n             t = self.engine.from_string(entry[0])\n             self.assertEqual(t.render(c), entry[1])\n",
  "django__django-12276": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 61f7a13..ad6a74a 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import copy\n import datetime\n import json\n@@ -15,6 +16,7 @@ from django.forms import (\n     TimeField, ValidationError, forms,\n )\n from django.forms.renderers import DjangoTemplates, get_default_renderer\n+from django.forms import FileInput\n from django.forms.utils import ErrorList\n from django.http import QueryDict\n from django.template import Context, Template\n@@ -2486,7 +2488,27 @@ Password: <input type=\"password\" name=\"password\" required>\n         self.assertEqual(f.errors, {})\n         self.assertEqual(f.cleaned_data['file1'], 'resume.txt')\n \n-    def test_basic_processing_in_view(self):\n+    def test_filefield_with_fileinput_required_no_initial(self):\n+        class FileFormNoInitial(Form):\n+            file1 = FileField(widget=FileInput)\n+\n+        # Test when no initial data is provided\n+        f_no_initial = FileFormNoInitial(auto_id=False)\n+        self.assertHTMLEqual(\n+            f_no_initial.as_table(),\n+            '<tr><th>File1:</th><td><input type=\"file\" name=\"file1\" required></td></tr>',\n+        )\n+\n+    def test_filefield_with_fileinput_required_initial(self):\n+        class FileFormInitial(Form):\n+            file1 = FileField(widget=FileInput)\n+\n+        # Test when initial data is present\n+        f_initial = FileFormInitial(initial={'file1': 'existing_file.txt'}, auto_id=False)\n+        self.assertHTMLEqual(\n+            f_initial.as_table(),\n+            '<tr><th>File1:</th><td><input type=\"file\" name=\"file1\"></td></tr>',\n+        )\n         class UserRegistration(Form):\n             username = CharField(max_length=10)\n             password1 = CharField(widget=PasswordInput)\n",
  "django__django-12304": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 6cabf01..071be55 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import decimal\n import ipaddress\n@@ -7,6 +8,7 @@ from django.db import models\n from django.test import SimpleTestCase\n from django.utils.functional import Promise\n from django.utils.translation import gettext_lazy as _\n+from django.template import Context, Template\n \n \n class Suit(models.IntegerChoices):\n@@ -137,11 +139,13 @@ class ChoicesTests(SimpleTestCase):\n                 # A string is not permitted as the second argument to int().\n                 ONE = 1, 'X', 'Invalid'\n \n-        msg = \"duplicate values found in <enum 'Fruit'>: PINEAPPLE -> APPLE\"\n-        with self.assertRaisesMessage(ValueError, msg):\n-            class Fruit(models.IntegerChoices):\n-                APPLE = 1, 'Apple'\n-                PINEAPPLE = 1, 'Pineapple'\n+    def test_template_enum_usage(self):\n+        template = Template('{% if student_year == YearInSchool.FRESHMAN %}Freshman{% else %}Not Freshman{% endif %}')\n+        context = Context({'student_year': YearInSchool.FRESHMAN, 'YearInSchool': YearInSchool})\n+        self.assertEqual(template.render(context), 'Freshman')\n+\n+        context = Context({'student_year': YearInSchool.SENIOR, 'YearInSchool': YearInSchool})\n+        self.assertEqual(template.render(context), 'Not Freshman')\n \n     def test_str(self):\n         for test in [Gender, Suit, YearInSchool, Vehicle]:\n",
  "django__django-12308": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex acbcf33..228736e 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -176,7 +176,27 @@ class UtilsTests(SimpleTestCase):\n         display_value = display_for_field(None, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, self.empty_value)\n \n-    def test_number_formats_display_for_field(self):\n+    def test_json_display_for_field_edge_cases(self):\n+        \"\"\"\n+        Additional tests for JSONField to cover edge cases.\n+        \"\"\"\n+        tests = [\n+            ({}, '{}'),  # Empty dictionary\n+            ([], '[]'),  # Empty list\n+            ({\"foo\": \"bar\", \"baz\": [1, 2, {\"qux\": \"quux\"}]}, '{\"foo\": \"bar\", \"baz\": [1, 2, {\"qux\": \"quux\"}]}'),  # Complex nested JSON\n+            ({\"a\": {\"b\": {\"c\": \"d\"}}}, '{\"a\": {\"b\": {\"c\": \"d\"}}}'),  # Deeply nested\n+            ([{\"foo\": \"bar\"}, {\"baz\": \"qux\"}], '[{\"foo\": \"bar\"}, {\"baz\": \"qux\"}]'),  # List of dictionaries\n+            (None, 'null'),  # None value represented as null\n+            (\"string\", '\"string\"'),  # Simple string should be double-quoted\n+            ([None, True, False, 3.14159], '[null, true, false, 3.14159]'),  # JSON with various types\n+        ]\n+\n+        for value, display_value in tests:\n+            with self.subTest(value=value):\n+                self.assertEqual(\n+                    display_for_field(value, models.JSONField(), self.empty_value),\n+                    display_value,\n+                )\n         display_value = display_for_field(12345.6789, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, '12345.6789')\n \n",
  "django__django-12325": "",
  "django__django-12419": "diff --git a/tests/middleware/test_security.py b/tests/middleware/test_security.py\nindex 7af62eb..92622b9 100644\n--- a/tests/middleware/test_security.py\n+++ b/tests/middleware/test_security.py\n@@ -231,7 +231,12 @@ class SecurityMiddlewareTest(SimpleTestCase):\n         \"\"\"\n         self.assertNotIn('Referrer-Policy', self.process_response())\n \n-    def test_referrer_policy_on(self):\n+    @override_settings(SECURE_REFERRER_POLICY=None)\n+    def test_default_referrer_policy(self):\n+        \"\"\"\n+        Ensure the default Referrer-Policy is 'same-origin' when SECURE_REFERRER_POLICY is not set.\n+        \"\"\"\n+        self.assertEqual(self.process_response().get('Referrer-Policy'), 'same-origin')\n         \"\"\"\n         With SECURE_REFERRER_POLICY set to a valid value, the middleware adds a\n         \"Referrer-Policy\" header to the response.\n@@ -248,10 +253,30 @@ class SecurityMiddlewareTest(SimpleTestCase):\n                 self.assertEqual(self.process_response()['Referrer-Policy'], expected)\n \n     @override_settings(SECURE_REFERRER_POLICY='strict-origin')\n-    def test_referrer_policy_already_present(self):\n+    @override_settings(SECURE_REFERRER_POLICY=None)\n+    def test_default_referrer_policy(self):\n+        \"\"\"\n+        Ensure the default Referrer-Policy is 'same-origin' when SECURE_REFERRER_POLICY is not set.\n+        \"\"\"\n+        self.assertEqual(self.process_response().get('Referrer-Policy'), 'same-origin')\n+        \"\"\"\n+        With SECURE_REFERRER_POLICY set to a valid value, the middleware adds a\n+        \"Referrer-Policy\" header to the response.\n+        \"\"\"\n+        tests = (\n+            ('same-origin', 'same-origin'),  # Adding this line to check default behavior is testable.\n+            ('strict-origin', 'strict-origin'),\n+            ('strict-origin,origin', 'strict-origin,origin'),\n+            ('strict-origin, origin', 'strict-origin,origin'),\n+            (['strict-origin', 'origin'], 'strict-origin,origin'),\n+            (('strict-origin', 'origin'), 'strict-origin,origin'),\n+        )\n+        for value, expected in tests:\n+            with self.subTest(value=value), override_settings(SECURE_REFERRER_POLICY=value):\n+                self.assertEqual(self.process_response()['Referrer-Policy'], expected)\n         \"\"\"\n         The middleware will not override a \"Referrer-Policy\" header already\n         present in the response.\n         \"\"\"\n         response = self.process_response(headers={'Referrer-Policy': 'unsafe-url'})\n-        self.assertEqual(response['Referrer-Policy'], 'unsafe-url')\n+        self.assertEqual(response['Referrer-Policy'], 'unsafe-url')\n",
  "django__django-12663": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 872551b..03c77aa 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -13,6 +13,25 @@ from django.db.models import (\n     Func, IntegerField, Max, Min, Model, OrderBy, OuterRef, Q, StdDev,\n     Subquery, Sum, TimeField, UUIDField, Value, Variance, When,\n )\n+class LazyObjectSubqueryTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.manager = Manager.objects.create(name='Manager1')\n+        cls.company = Company.objects.create(\n+            name=\"Tech Corp\", ceo=Employee.objects.create(firstname=\"Alice\", lastname=\"Doe\", manager=cls.manager)\n+        )\n+\n+    def test_subquery_filter_by_lazy(self):\n+        lazy_manager = SimpleLazyObject(lambda: Manager.objects.get(pk=self.manager.pk))\n+        qs = Company.objects.annotate(\n+            ceo_manager=Subquery(\n+                Employee.objects.filter(\n+                    lastname=OuterRef('ceo__lastname'),\n+                ).values('manager'),\n+            ),\n+        ).filter(ceo_manager=lazy_manager)\n+        self.assertEqual(qs.get(), self.company)\n+\n from django.db.models.expressions import Col, Combinable, Random, RawSQL, Ref\n from django.db.models.functions import (\n     Coalesce, Concat, Left, Length, Lower, Substr, Upper,\n@@ -24,8 +43,10 @@ from django.test.utils import Approximate, isolate_apps\n \n from .models import (\n     UUID, UUIDPK, Company, Employee, Experiment, Number, RemoteEmployee,\n-    Result, SimulationRun, Time,\n+    Result, SimulationRun, Time, Manager\n )\n+from django.utils.functional import SimpleLazyObject\n+from django.db.models import OuterRef, Subquery\n \n \n class BasicExpressionsTests(TestCase):\n",
  "django__django-12708": "diff --git a/tests/migrations/test_base.py b/tests/migrations/test_base.py\nindex d6e6fdb..229fc05 100644\n--- a/tests/migrations/test_base.py\n+++ b/tests/migrations/test_base.py\n@@ -66,6 +66,36 @@ class MigrationTestBase(TransactionTestCase):\n                 ),\n             )\n \n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_migration_with_unique_and_index_together(self):\n+        \"\"\"\n+        Test that removing index_together when unique_together is defined\n+        on the same columns does not crash.\n+        \"\"\"\n+        app_label = 'test_migration_issue'\n+        table_name = '%s_pony' % app_label\n+        project_state = self.set_up_test_model(app_label, unique_together=True)\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+\n+        # Add index_together on the same fields as unique_together\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexExists(table_name, ['pink', 'weight'])\n+\n+        # Now, remove the index_together and test it does not crash\n+        project_state = new_state\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', None)\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+        # Ensure the unique_together constraint still exists\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+\n     def assertIndexNotExists(self, table, columns):\n         return self.assertIndexExists(table, columns, False)\n \n@@ -77,6 +107,36 @@ class MigrationTestBase(TransactionTestCase):\n                 any(c['check'] for n, c in constraints if n == name),\n             )\n \n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_migration_with_unique_and_index_together(self):\n+        \"\"\"\n+        Test that removing index_together when unique_together is defined\n+        on the same columns does not crash.\n+        \"\"\"\n+        app_label = 'test_migration_issue'\n+        table_name = '%s_pony' % app_label\n+        project_state = self.set_up_test_model(app_label, unique_together=True)\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+\n+        # Add index_together on the same fields as unique_together\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexExists(table_name, ['pink', 'weight'])\n+\n+        # Now, remove the index_together and test it does not crash\n+        project_state = new_state\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', None)\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+        # Ensure the unique_together constraint still exists\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+\n     def assertConstraintNotExists(self, table, name):\n         return self.assertConstraintExists(table, name, False)\n \n@@ -91,6 +151,36 @@ class MigrationTestBase(TransactionTestCase):\n                 ),\n             )\n \n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_migration_with_unique_and_index_together(self):\n+        \"\"\"\n+        Test that removing index_together when unique_together is defined\n+        on the same columns does not crash.\n+        \"\"\"\n+        app_label = 'test_migration_issue'\n+        table_name = '%s_pony' % app_label\n+        project_state = self.set_up_test_model(app_label, unique_together=True)\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+\n+        # Add index_together on the same fields as unique_together\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexExists(table_name, ['pink', 'weight'])\n+\n+        # Now, remove the index_together and test it does not crash\n+        project_state = new_state\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', None)\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+        # Ensure the unique_together constraint still exists\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+\n     def assertFKNotExists(self, table, columns, to):\n         return self.assertFKExists(table, columns, to, False)\n \n",
  "django__django-12713": "diff --git a/tests/admin_widgets/tests.py b/tests/admin_widgets/tests.py\nindex dc4dadc..83b7b7e 100644\n--- a/tests/admin_widgets/tests.py\n+++ b/tests/admin_widgets/tests.py\n@@ -14,7 +14,7 @@ from django.contrib.admin.tests import AdminSeleniumTestCase\n from django.contrib.auth.models import User\n from django.core.files.storage import default_storage\n from django.core.files.uploadedfile import SimpleUploadedFile\n-from django.db.models import CharField, DateField, DateTimeField, UUIDField\n+from django.db.models import CharField, DateField, DateTimeField, UUIDField, ManyToManyField\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.urls import reverse\n from django.utils import translation\n@@ -138,7 +138,20 @@ class AdminFormfieldForDBFieldTests(SimpleTestCase):\n         self.assertEqual(f2.widget.attrs['maxlength'], '20')\n         self.assertEqual(f2.widget.attrs['size'], '10')\n \n-    def test_formfield_overrides_for_datetime_field(self):\n+    def test_formfield_overrides_m2m_filter_widget(self):\n+        \"\"\"\n+        The autocomplete_fields, raw_id_fields, filter_vertical, and\n+        filter_horizontal widgets for ManyToManyFields may be overridden by\n+        specifying a widget in formfield_overrides.\n+        \"\"\"\n+        class BandAdmin(admin.ModelAdmin):\n+            filter_vertical = ['members']\n+            formfield_overrides = {\n+                ManyToManyField: {'widget': forms.CheckboxSelectMultiple},\n+            }\n+        ma = BandAdmin(Band, admin.site)\n+        field = ma.formfield_for_dbfield(Band._meta.get_field('members'), request=None)\n+        self.assertIsInstance(field.widget.widget, forms.CheckboxSelectMultiple)\n         \"\"\"\n         Overriding the widget for DateTimeField doesn't overrides the default\n         form_class for that field (#26449).\n",
  "django__django-12741": "diff --git a/tests/backends/base/test_operations.py b/tests/backends/base/test_operations.py\nindex 089eb18..b0ffe95 100644\n--- a/tests/backends/base/test_operations.py\n+++ b/tests/backends/base/test_operations.py\n@@ -172,7 +172,7 @@ class SqlFlushTests(TransactionTestCase):\n             reset_sequences=True,\n             allow_cascade=True,\n         )\n-        connection.ops.execute_sql_flush(connection.alias, sql_list)\n+        connection.ops.execute_sql_flush(sql_list)\n \n         with transaction.atomic():\n             self.assertIs(Author.objects.exists(), False)\n@@ -181,4 +181,4 @@ class SqlFlushTests(TransactionTestCase):\n                 author = Author.objects.create(name='F. Scott Fitzgerald')\n                 self.assertEqual(author.pk, 1)\n                 book = Book.objects.create(author=author)\n-                self.assertEqual(book.pk, 1)\n+                self.assertEqual(book.pk, 1)\n",
  "django__django-12754": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex 17e707b..c828193 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -2445,6 +2445,31 @@ class AutodetectorTests(TestCase):\n         self.assertOperationTypes(changes, 'testapp', 0, [\"AddField\", \"AddField\"])\n         self.assertOperationAttributes(changes, 'testapp', 0, 0)\n \n+    def test_add_model_with_field_removed_from_base_model(self):\n+        \"\"\"\n+        Removing a base field takes place before adding a new inherited model\n+        that has a field with the same name.\n+        \"\"\"\n+        before = [\n+            ModelState('app', 'readable', [\n+                ('id', models.AutoField(primary_key=True)),\n+                ('title', models.CharField(max_length=200)),\n+            ]),\n+        ]\n+        after = [\n+            ModelState('app', 'readable', [\n+                ('id', models.AutoField(primary_key=True)),\n+            ]),\n+            ModelState('app', 'book', [\n+                ('title', models.CharField(max_length=200)),\n+            ], bases=('app.readable',)),\n+        ]\n+        changes = self.get_changes(before, after)\n+        self.assertNumberMigrations(changes, 'app', 1)\n+        self.assertOperationTypes(changes, 'app', 0, ['RemoveField', 'CreateModel'])\n+        self.assertOperationAttributes(changes, 'app', 0, 0, name='title', model_name='readable')\n+        self.assertOperationAttributes(changes, 'app', 0, 1, name='book')\n+\n     def test_mti_inheritance_model_removal(self):\n         Animal = ModelState('app', 'Animal', [\n             (\"id\", models.AutoField(primary_key=True)),\n@@ -2453,4 +2478,4 @@ class AutodetectorTests(TestCase):\n         changes = self.get_changes([Animal, Dog], [Animal])\n         self.assertNumberMigrations(changes, 'app', 1)\n         self.assertOperationTypes(changes, 'app', 0, ['DeleteModel'])\n-        self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n+        self.assertOperationAttributes(changes, 'app', 0, 0, name='Dog')\n",
  "django__django-12774": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 057eac3..7c7aefc 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -9,6 +9,8 @@ from django.db.models import Exists, Max, OuterRef\n from django.db.models.functions import Substr\n from django.test import TestCase, skipUnlessDBFeature\n from django.utils.deprecation import RemovedInDjango40Warning\n+from django.db import models\n+from django.test.utils import isolate_apps\n \n from .models import (\n     Article, Author, Freebie, Game, IsNullWithNoneAsRHS, Player, Season, Tag,\n",
  "django__django-12858": "diff --git a/tests/invalid_models_tests/test_models.py b/tests/invalid_models_tests/test_models.py\nindex 3b6974f..c54cc45 100644\n--- a/tests/invalid_models_tests/test_models.py\n+++ b/tests/invalid_models_tests/test_models.py\n@@ -893,7 +893,21 @@ class OtherModelTests(SimpleTestCase):\n         with register_lookup(models.CharField, Lower):\n             self.assertEqual(Model.check(), [])\n \n-    def test_ordering_pointing_to_related_model_pk(self):\n+    def test_issue_29408_ordering_uses_nullable_foreignkey(self):\n+        class Product(models.Model):\n+            parent = models.ForeignKey('self', models.CASCADE, null=True)\n+\n+        class Supply(models.Model):\n+            product = models.ForeignKey(Product, models.CASCADE)\n+\n+        class Stock(models.Model):\n+            supply = models.ForeignKey(Supply, models.CASCADE)\n+            \n+            class Meta:\n+                ordering = ('supply__product__parent__isnull',)\n+\n+        # This should not raise any errors, verifying that chaining nullable FKs using __isnull works.\n+        self.assertEqual(Stock.check(), [])\n         class Parent(models.Model):\n             pass\n \n",
  "django__django-13012": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 87c0945..0aafdd1 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1821,10 +1821,16 @@ class CombinableTests(SimpleTestCase):\n         with self.assertRaisesMessage(NotImplementedError, self.bitwise_msg):\n             Combinable() | Combinable()\n \n-    def test_reversed_and(self):\n+    def test_constant_expression_not_in_group_by(self):\n+        expr = ExpressionWrapper(Value(42), output_field=IntegerField())\n+        self.assertEqual(expr.get_group_by_cols(alias=None), [])\n+\n+    def test_dynamic_expression_in_group_by(self):\n+        expr = ExpressionWrapper(Value('field') + Value('suffix'), output_field=IntegerField())\n+        self.assertNotEqual(expr.get_group_by_cols(alias=None), [])\n         with self.assertRaisesMessage(NotImplementedError, self.bitwise_msg):\n             object() & Combinable()\n \n     def test_reversed_or(self):\n         with self.assertRaisesMessage(NotImplementedError, self.bitwise_msg):\n-            object() | Combinable()\n+            object() | Combinable()\n",
  "django__django-13028": "diff --git a/tests/queries/models.py b/tests/queries/models.py\nindex a43cfb4..b9d5a8e 100644\n--- a/tests/queries/models.py\n+++ b/tests/queries/models.py\n@@ -78,6 +78,7 @@ class ExtraInfo(models.Model):\n \n class Author(models.Model):\n     name = models.CharField(max_length=10)\n+    extra = models.ForeignKey(ExtraInfo, models.CASCADE, null=True)\n     num = models.IntegerField(unique=True)\n     extra = models.ForeignKey(ExtraInfo, models.CASCADE)\n \n",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..2a7863e 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,6 +343,40 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n+    def test_order_by_self_referential_foreign_key(self):\n+        # Setup Authors where each author may have an editor\n+        author_1 = Author.objects.create(name=\"Author 1\")\n+        author_2 = Author.objects.create(name=\"Author 2\", editor=author_1) # Self-referential FK scenario\n+        author_3 = Author.objects.create(name=\"Author 3\", editor=author_2)\n+\n+        # Setup Articles using the authors\n+        article_1 = Article.objects.create(author=author_2, headline=\"Article 1\", pub_date=\"2023-01-01\")\n+        article_2 = Article.objects.create(author=author_3, headline=\"Article 2\", pub_date=\"2023-01-02\")\n+\n+        # Test ordering by self-referential foreign key (editor)\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline'),\n+        )\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'),\n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline'),\n+        )\n+\n+        # Test inverted ordering\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('-author__editor'),\n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline'),\n+        )\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('-author__editor_id'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline'),\n+        )\n+\n     def test_order_by_f_expression(self):\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n@@ -353,6 +387,40 @@ class OrderingTests(TestCase):\n             ],\n             attrgetter(\"headline\")\n         )\n+\n+    def test_order_by_self_referential_foreign_key(self):\n+        # Setup Authors where each author may have an editor\n+        author_1 = Author.objects.create(name=\"Author 1\")\n+        author_2 = Author.objects.create(name=\"Author 2\", editor=author_1) # Self-referential FK scenario\n+        author_3 = Author.objects.create(name=\"Author 3\", editor=author_2)\n+\n+        # Setup Articles using the authors\n+        article_1 = Article.objects.create(author=author_2, headline=\"Article 1\", pub_date=\"2023-01-01\")\n+        article_2 = Article.objects.create(author=author_3, headline=\"Article 2\", pub_date=\"2023-01-02\")\n+\n+        # Test ordering by self-referential foreign key (editor)\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline'),\n+        )\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'),\n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline'),\n+        )\n+\n+        # Test inverted ordering\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('-author__editor'),\n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline'),\n+        )\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('-author__editor_id'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline'),\n+        )\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline').asc()), [\n                 \"Article 1\",\n",
  "django__django-13089": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex e11856f..694595b 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -621,6 +621,21 @@ class BaseCacheTests:\n     def test_zero_cull(self):\n         self._perform_cull_test('zero_cull', 50, 19)\n \n+    def test_cull_when_no_cache_key_returned(self):\n+        # This test assumes that when cursor.fetchone() returns None,\n+        # the operation should be safely handled without throwing an error.\n+        try:\n+            cull_cache = caches['cull']\n+        except InvalidCacheBackendError:\n+            self.skipTest(\"Culling isn't implemented.\")\n+        \n+        cull_cache._max_entries = 0  # Force culling\n+        \n+        with self.assertLogs(level='WARNING') as log:\n+            cull_cache.set('test_no_key_returned', 'value', 1000)\n+            # If no error, this part of the culling process should handle `None`\n+            self.assertIn(\"Attempt to cull with no cache keys returned.\", log.output)\n+\n     def _perform_invalid_key_test(self, key, expected_warning):\n         \"\"\"\n         All the builtin backends should warn (except memcached that should\n",
  "django__django-13109": "diff --git a/tests/model_forms/models.py b/tests/model_forms/models.py\nindex ff8ad74..232b6a4 100644\n--- a/tests/model_forms/models.py\n+++ b/tests/model_forms/models.py\n@@ -28,8 +28,26 @@ class Category(models.Model):\n         return self.__str__()\n \n \n+from django.db import models\n+\n+class WriterManager(models.Manager):\n+    def get_queryset(self):\n+        qs = super().get_queryset()\n+        return qs.filter(archived=False)\n+\n class Writer(models.Model):\n     name = models.CharField(max_length=50, help_text='Use both first and last names.')\n+    archived = models.BooleanField(default=False, editable=False)\n+\n+    # Override objects manager\n+    objects = WriterManager()\n+\n+    class Meta:\n+        ordering = ('name',)\n+\n+    def __str__(self):\n+        return self.name\n+    name = models.CharField(max_length=50, help_text='Use both first and last names.')\n \n     class Meta:\n         ordering = ('name',)\n",
  "django__django-13112": "diff --git a/tests/migrations/test_state.py b/tests/migrations/test_state.py\nindex 081eff8..d0ef150 100644\n--- a/tests/migrations/test_state.py\n+++ b/tests/migrations/test_state.py\n@@ -867,6 +867,43 @@ class StateTests(SimpleTestCase):\n         with self.assertRaisesMessage(ValueError, msg):\n             project_state.apps\n \n+    def test_foreign_key_mixed_case_app_name(self):\n+        \"\"\"\n+        Test that a ForeignKey with a reference to a mixed-case app label does not crash.\n+        \"\"\"\n+        new_apps = Apps()\n+\n+        class Author(models.Model):\n+            class Meta:\n+                app_label = 'MiXeDCase_migrations'\n+                apps = new_apps\n+\n+        class Book(models.Model):\n+            author = models.ForeignKey(Author, models.CASCADE)\n+\n+            class Meta:\n+                app_label = 'MiXeDCase_migrations'\n+                apps = new_apps\n+\n+        class Magazine(models.Model):\n+            authors = models.ManyToManyField(Author)\n+\n+            class Meta:\n+                app_label = 'MiXeDCase_migrations'\n+                apps = new_apps\n+\n+        project_state = ProjectState()\n+        project_state.add_model(ModelState.from_model(Author))\n+        project_state.add_model(ModelState.from_model(Book))\n+        project_state.add_model(ModelState.from_model(Magazine))\n+\n+        # Ensure all models are registered without error\n+        self.assertEqual(len(project_state.apps.get_models()), 3)\n+\n+        # Ensure the mixed case app label does not cause reference issues\n+        author_apps_label = project_state.apps.get_model('MiXeDCase_migrations', 'author')._meta.app_label\n+        self.assertEqual(author_apps_label, 'MiXeDCase_migrations')\n+\n     def test_real_apps(self):\n         \"\"\"\n         Including real apps can resolve dangling FK errors.\n",
  "django__django-13121": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex a684d7e..9e34ffa 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1210,13 +1210,85 @@ class ExpressionOperatorTests(TestCase):\n         self.assertEqual(Number.objects.get(pk=self.n.pk).integer, 1764)\n         self.assertEqual(Number.objects.get(pk=self.n.pk).float, Approximate(61.02, places=2))\n \n-    @unittest.skipIf(connection.vendor == 'oracle', \"Oracle doesn't support bitwise XOR.\")\n+    from decimal import Decimal\n+    from django.db.models import F\n+    import datetime\n+    \n+    def test_duration_expressions(self):\n+        for delta in self.deltas:\n+            qs = Experiment.objects.annotate(duration=F('estimated_time') + delta)\n+            for obj in qs:\n+                self.assertEqual(obj.duration, obj.estimated_time + delta)\n+\n+    def test_duration_expression_with_large_delta(self):\n+        large_delta = datetime.timedelta(days=365, hours=5, minutes=30)\n+        Experiment.objects.create(estimated_time=datetime.timedelta(days=1))\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + large_delta)\n+        for obj in qs:\n+            self.assertEqual(obj.duration, obj.estimated_time + large_delta)\n+\n+    def test_duration_expression_zero_delta(self):\n+        zero_delta = datetime.timedelta(0)\n+        Experiment.objects.create(estimated_time=datetime.timedelta(hours=2))\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + zero_delta)\n+        for obj in qs:\n+            self.assertEqual(obj.duration, obj.estimated_time)\n+\n+    def test_negative_duration_expression(self):\n+        negative_delta = datetime.timedelta(days=-1)\n+        Experiment.objects.create(estimated_time=datetime.timedelta(days=2))\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + negative_delta)\n+        for obj in qs:\n+            self.assertEqual(obj.duration, obj.estimated_time + negative_delta)\n+\n+    def test_duration_expression_decimal_conversion(self):\n+        small_decimal_delta = datetime.timedelta(seconds=1, milliseconds=500)\n+        Experiment.objects.create(estimated_time=datetime.timedelta(seconds=10))\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + small_decimal_delta)\n+        for obj in qs:\n+            self.assertAlmostEqual(Decimal(obj.duration.total_seconds()), Decimal((obj.estimated_time + small_decimal_delta).total_seconds()))\n     def test_lefthand_bitwise_xor(self):\n         Number.objects.update(integer=F('integer').bitxor(48))\n         self.assertEqual(Number.objects.get(pk=self.n.pk).integer, 26)\n         self.assertEqual(Number.objects.get(pk=self.n1.pk).integer, -26)\n \n-    @unittest.skipIf(connection.vendor == 'oracle', \"Oracle doesn't support bitwise XOR.\")\n+    from decimal import Decimal\n+    from django.db.models import F\n+    import datetime\n+    \n+    def test_duration_expressions(self):\n+        for delta in self.deltas:\n+            qs = Experiment.objects.annotate(duration=F('estimated_time') + delta)\n+            for obj in qs:\n+                self.assertEqual(obj.duration, obj.estimated_time + delta)\n+\n+    def test_duration_expression_with_large_delta(self):\n+        large_delta = datetime.timedelta(days=365, hours=5, minutes=30)\n+        Experiment.objects.create(estimated_time=datetime.timedelta(days=1))\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + large_delta)\n+        for obj in qs:\n+            self.assertEqual(obj.duration, obj.estimated_time + large_delta)\n+\n+    def test_duration_expression_zero_delta(self):\n+        zero_delta = datetime.timedelta(0)\n+        Experiment.objects.create(estimated_time=datetime.timedelta(hours=2))\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + zero_delta)\n+        for obj in qs:\n+            self.assertEqual(obj.duration, obj.estimated_time)\n+\n+    def test_negative_duration_expression(self):\n+        negative_delta = datetime.timedelta(days=-1)\n+        Experiment.objects.create(estimated_time=datetime.timedelta(days=2))\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + negative_delta)\n+        for obj in qs:\n+            self.assertEqual(obj.duration, obj.estimated_time + negative_delta)\n+\n+    def test_duration_expression_decimal_conversion(self):\n+        small_decimal_delta = datetime.timedelta(seconds=1, milliseconds=500)\n+        Experiment.objects.create(estimated_time=datetime.timedelta(seconds=10))\n+        qs = Experiment.objects.annotate(duration=F('estimated_time') + small_decimal_delta)\n+        for obj in qs:\n+            self.assertAlmostEqual(Decimal(obj.duration.total_seconds()), Decimal((obj.estimated_time + small_decimal_delta).total_seconds()))\n     def test_lefthand_bitwise_xor_null(self):\n         employee = Employee.objects.create(firstname='John', lastname='Doe')\n         Employee.objects.update(salary=F('salary').bitxor(48))\n",
  "django__django-13128": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 82e96fa..a287c94 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1627,7 +1627,13 @@ class FTimeDeltaTests(TestCase):\n         for e in qs:\n             self.assertEqual(e.delta, delta)\n \n-    def test_duration_with_datetime(self):\n+    @skipUnlessDBFeature('supports_temporal_subtraction')\n+    def test_temporal_subtraction_without_expression_wrapper(self):\n+        # Test the case mentioned in the issue to check if temporal subtraction\n+        # between two DateTimeField works without an ExpressionWrapper.\n+        qs = Experiment.objects.annotate(delta=F('end') - F('start'))\n+        for obj in qs:\n+            self.assertEqual(obj.delta, obj.end - obj.start)\n         # Exclude e1 which has very high precision so we can test this on all\n         # backends regardless of whether or not it supports\n         # microsecond_precision.\n",
  "django__django-13158": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex c769d76..ad98cc0 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -169,8 +169,42 @@ class ModelChoiceFieldTests(TestCase):\n         # without affecting other forms, the following must hold (#11183):\n         self.assertIsNot(field1, ModelChoiceForm.base_fields['category'])\n         self.assertIs(field1.widget.choices.field, field1)\n+    from django import forms\n+    from .models import Category\n+\n+    def test_union_none(self):\n+        class ModelMultipleChoiceForm(forms.Form):\n+            category = forms.ModelMultipleChoiceField(\n+                Category.objects.filter(id__lt=2).union(\n+                    Category.objects.filter(id__gt=5)\n+                ),\n+                required=False\n+            )\n \n-    def test_result_cache_not_shared(self):\n+        # Check with an empty submission\n+        form = ModelMultipleChoiceForm(data={'category': []})\n+        self.assertTrue(form.is_valid())\n+        self.assertSequenceEqual(form.cleaned_data['category'], [])\n+        \n+        # Pre-create some categories for the test\n+        Category.objects.create(id=1, name='Category 1')\n+        Category.objects.create(id=6, name='Category 6')\n+        Category.objects.create(id=10, name='Category 10')\n+\n+        # Verify queryset returns correct union results\n+        form = ModelMultipleChoiceForm()\n+        self.assertCountEqual(\n+            form.fields['category'].queryset,\n+            [Category.objects.get(id=1), Category.objects.get(id=6), Category.objects.get(id=10)]\n+        )\n+        \n+        # Test submission with selected items (union keeps correct additions)\n+        form_with_data = ModelMultipleChoiceForm(data={'category': [1, 10]})\n+        self.assertTrue(form_with_data.is_valid())\n+        self.assertCountEqual(\n+            form_with_data.cleaned_data['category'],\n+            [Category.objects.get(id=1), Category.objects.get(id=10)]\n+        )\n         class ModelChoiceForm(forms.Form):\n             category = forms.ModelChoiceField(Category.objects.all())\n \n",
  "django__django-13279": "diff --git a/tests/sessions_tests/tests.py b/tests/sessions_tests/tests.py\nindex e3a089f..0521cc1 100644\n--- a/tests/sessions_tests/tests.py\n+++ b/tests/sessions_tests/tests.py\n@@ -31,7 +31,7 @@ from django.core.cache.backends.base import InvalidCacheBackendError\n from django.core.exceptions import ImproperlyConfigured, SuspiciousOperation\n from django.http import HttpResponse\n from django.test import (\n-    RequestFactory, TestCase, ignore_warnings, override_settings,\n+    RequestFactory, TestCase, ignore_warnings, override_settings, base64,\n )\n from django.utils import timezone\n \n@@ -312,7 +312,24 @@ class SessionTestsMixin:\n         self.assertEqual(self.session.decode(encoded), data)\n \n     @override_settings(SECRET_KEY='django_tests_secret_key')\n-    def test_decode_legacy(self):\n+    def test_default_hashing_algorithm_legacy_decode(self):\n+        # Test legacy decode with DEFAULT_HASHING_ALGORITHM set to 'sha1'\n+        with self.settings(DEFAULT_HASHING_ALGORITHM='sha1'):\n+            session_instance = self.backend()  # Assuming backend is defined in Mixin\n+            data = {'a test key': 'a test value'}\n+            encoded = session_instance.encode(data)\n+            self.assertEqual(session_instance._legacy_decode(encoded), data)\n+\n+    def test_decode_with_sha1_algorithm(self):\n+        # Test overall decode method handling with sha1 configuration\n+        with self.settings(DEFAULT_HASHING_ALGORITHM='sha1'):\n+            session_instance = self.backend()\n+\n+            # Synthetically create an old format encoded data\n+            legacy_encoded = base64.b64encode(b'somehash:{\"a test key\":\"a test value\"}').decode('ascii')\n+            expected_data = {'a test key': 'a test value'}\n+\n+            self.assertEqual(session_instance.decode(legacy_encoded), expected_data)\n         # RemovedInDjango40Warning: pre-Django 3.1 sessions will be invalid.\n         legacy_encoded = (\n             'OWUzNTNmNWQxNTBjOWExZmM4MmQ3NzNhMDRmMjU4NmYwNDUyNGI2NDp7ImEgdGVzd'\n",
  "django__django-13297": "diff --git a/tests/generic_views/test_base.py b/tests/generic_views/test_base.py\nindex 26c885d..ec08848 100644\n--- a/tests/generic_views/test_base.py\n+++ b/tests/generic_views/test_base.py\n@@ -8,7 +8,9 @@ from django.test import (\n from django.test.utils import require_jinja2\n from django.urls import resolve\n from django.utils.deprecation import RemovedInDjango40Warning\n+from django.shortcuts import get_object_or_404\n from django.views.generic import RedirectView, TemplateView, View\n+from .models import Artist  # Ensure this is correctly imported for the test with 'Artist'\n \n from . import views\n \n",
  "django__django-13315": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 64b15bf..3707c28 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2830,7 +2830,55 @@ class LimitChoicesToTests(TestCase):\n             self.assertEqual(today_callable_dict.call_count, 3)\n \n \n-class FormFieldCallbackTests(SimpleTestCase):\n+from django.test.utils import isolate_apps\n+\n+class ForeignKeyLimitChoicesTests(TestCase):\n+    def setUp(self):\n+        self.threepwood = Character.objects.create(username='Guybrush Threepwood', last_action='2023-10-01')\n+        self.marley = Character.objects.create(username='Elaine Marley', last_action='2023-10-01')\n+\n+        joke1 = StumpJoke.objects.create(funny=True, most_recently_fooled=self.threepwood)\n+        joke2 = StumpJoke.objects.create(funny=True, most_recently_fooled=self.threepwood)\n+        joke3 = StumpJoke.objects.create(funny=True, most_recently_fooled=self.marley)\n+        StumpJoke.objects.create(funny=False, most_recently_fooled=self.marley)\n+\n+        joke1.has_fooled_today.add(self.marley, self.threepwood)\n+        joke2.has_fooled_today.add(self.marley)\n+        joke3.has_fooled_today.add(self.marley, self.threepwood)\n+\n+    @isolate_apps('model_forms')\n+    def test_no_duplicate_options_in_formfield(self):\n+        class CharacterDetails(models.Model):\n+            character1 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to=models.Q(jokes__funny=True, jokes_today__funny=True),\n+                related_name='details_fk_1',\n+            )\n+            character2 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to={\n+                    'jokes__funny': True,\n+                    'jokes_today__funny': True,\n+                },\n+                related_name='details_fk_2',\n+            )\n+            character3 = models.ManyToManyField(\n+                Character,\n+                limit_choices_to=models.Q(jokes__funny=True, jokes_today__funny=True),\n+                related_name='details_m2m_1',\n+            )\n+\n+        class CharacterDetailsForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetails\n+                fields = '__all__'\n+\n+        form = CharacterDetailsForm()\n+        self.assertCountEqual(form.fields['character1'].queryset, [self.marley, self.threepwood])\n+        self.assertCountEqual(form.fields['character2'].queryset, [self.marley, self.threepwood])\n+        self.assertCountEqual(form.fields['character3'].queryset, [self.marley, self.threepwood])\n \n     def test_baseform_with_widgets_in_meta(self):\n         \"\"\"Regression for #13095: Using base forms with widgets defined in Meta should not raise errors.\"\"\"\n",
  "django__django-13343": "diff --git a/tests/file_storage/tests.py b/tests/file_storage/tests.py\nindex a5ab3a0..8b58759 100644\n--- a/tests/file_storage/tests.py\n+++ b/tests/file_storage/tests.py\n@@ -29,7 +29,7 @@ from django.test.utils import requires_tz_support\n from django.urls import NoReverseMatch, reverse_lazy\n from django.utils import timezone\n \n-from .models import Storage, temp_storage, temp_storage_location\n+from .models import Storage, callable_storage, temp_storage, temp_storage_location\n \n FILE_SUFFIX_REGEX = '[A-Za-z0-9]{7}'\n \n@@ -68,6 +68,16 @@ class GetStorageClassTests(SimpleTestCase):\n \n class FileSystemStorageTests(unittest.TestCase):\n \n+    def test_deconstruction_for_callable_storage(self):\n+        \"\"\"\n+        Ensures that deconstructing a FileField with callable storage\n+        returns the callable itself, not the evaluated storage instance.\n+        \"\"\"\n+        obj = Storage()\n+        *_, kwargs = obj._meta.get_field('storage_callable').deconstruct()\n+        storage = kwargs['storage']\n+        self.assertIs(storage, callable_storage)\n+\n     def test_deconstruction(self):\n         path, args, kwargs = temp_storage.deconstruct()\n         self.assertEqual(path, \"django.core.files.storage.FileSystemStorage\")\n",
  "django__django-13346": "",
  "django__django-13363": "diff --git a/tests/db_functions/datetime/test_extract_trunc.py b/tests/db_functions/datetime/test_extract_trunc.py\nindex 82d5e36..bff36df 100644\n--- a/tests/db_functions/datetime/test_extract_trunc.py\n+++ b/tests/db_functions/datetime/test_extract_trunc.py\n@@ -20,6 +20,8 @@ from django.test import (\n from django.utils import timezone\n \n from ..models import Author, DTModel, Fan\n+import pytz\n+from datetime import datetime\n \n \n def truncate_to(value, kind, tzinfo=None):\n@@ -1133,7 +1135,51 @@ class DateFunctionWithTimeZoneTests(DateFunctionTests):\n         self.assertEqual(model.melb_year.year, 2016)\n         self.assertEqual(model.pacific_year.year, 2015)\n \n-    def test_trunc_ambiguous_and_invalid_times(self):\n+    def test_truncdate_with_tzinfo(self):\n+        # Define timezones\n+        melb = pytz.timezone('Australia/Melbourne')\n+        pacific = pytz.timezone('US/Pacific')\n+\n+        # Create a datetime aware object\n+        start_datetime = datetime(2016, 1, 1, 15, 0, 0)\n+        start_datetime = timezone.make_aware(start_datetime, timezone.utc)\n+\n+        # Insert test data\n+        self.create_model(start_datetime=start_datetime, end_datetime=start_datetime)\n+\n+        model = DTModel.objects.annotate(\n+            melb_date=TruncDate('start_datetime', tzinfo=melb),\n+            pacific_date=TruncDate('start_datetime', tzinfo=pacific),\n+        ).order_by('start_datetime').get()\n+        \n+        melb_start_datetime = start_datetime.astimezone(melb)\n+        pacific_start_datetime = start_datetime.astimezone(pacific)\n+\n+        self.assertEqual(model.melb_date, melb_start_datetime.date())\n+        self.assertEqual(model.pacific_date, pacific_start_datetime.date())\n+\n+    def test_trunctime_with_tzinfo(self):\n+        # Define timezones\n+        melb = pytz.timezone('Australia/Melbourne')\n+        pacific = pytz.timezone('US/Pacific')\n+\n+        # Create a datetime aware object\n+        start_datetime = datetime(2016, 1, 1, 15, 0, 0)\n+        start_datetime = timezone.make_aware(start_datetime, timezone.utc)\n+\n+        # Insert test data\n+        self.create_model(start_datetime=start_datetime, end_datetime=start_datetime)\n+\n+        model = DTModel.objects.annotate(\n+            melb_time=TruncTime('start_datetime', tzinfo=melb),\n+            pacific_time=TruncTime('start_datetime', tzinfo=pacific),\n+        ).order_by('start_datetime').get()\n+        \n+        melb_start_datetime = start_datetime.astimezone(melb)\n+        pacific_start_datetime = start_datetime.astimezone(pacific)\n+\n+        self.assertEqual(model.melb_time, melb_start_datetime.time())\n+        self.assertEqual(model.pacific_time, pacific_start_datetime.time())\n         sao = pytz.timezone('America/Sao_Paulo')\n         utc = pytz.timezone('UTC')\n         start_datetime = utc.localize(datetime(2016, 10, 16, 13))\n",
  "django__django-13401": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex e39d03e..0ae44ec 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -103,6 +103,8 @@ class BasicFieldTests(SimpleTestCase):\n         self.assertEqual(path, 'model_fields.tests.Nested.Field')\n \n \n+import pickle\n+\n class ChoicesTests(SimpleTestCase):\n \n     @classmethod\n",
  "django__django-13410": "diff --git a/tests/files/tests.py b/tests/files/tests.py\nindex 1285e22..e05bf10 100644\n--- a/tests/files/tests.py\n+++ b/tests/files/tests.py\n@@ -1,3 +1,59 @@\n+\n+class FileLockTestCase(unittest.TestCase):\n+    def test_exclusive_lock(self):\n+        file_path = Path(__file__).parent / 'test.png'\n+        with open(file_path, 'w') as f:\n+            f.write('Test content')\n+\n+        with open(file_path) as f1, open(file_path) as f2:\n+            # Acquire an exclusive lock on f1\n+            self.assertIs(locks.lock(f1, locks.LOCK_EX), True)\n+            # Try to acquire an exclusive lock on f2 (non-blocking should fail)\n+            self.assertIs(locks.lock(f2, locks.LOCK_EX | locks.LOCK_NB), False)\n+            # Try to acquire a shared lock on f2 (non-blocking should fail)\n+            self.assertIs(locks.lock(f2, locks.LOCK_SH | locks.LOCK_NB), False)\n+            # Unlock f1\n+            self.assertIs(locks.unlock(f1), True)\n+\n+    def test_shared_lock(self):\n+        file_path = Path(__file__).parent / 'test.png'\n+        with open(file_path, 'w') as f:\n+            f.write('Test content')\n+\n+        with open(file_path) as f1, open(file_path) as f2:\n+            # Acquire a shared lock on f1\n+            self.assertIs(locks.lock(f1, locks.LOCK_SH), True)\n+            # Try to acquire a shared lock on f2 (non-blocking should succeed)\n+            self.assertIs(locks.lock(f2, locks.LOCK_SH | locks.LOCK_NB), True)\n+            # Unlock both f1 and f2\n+            self.assertIs(locks.unlock(f1), True)\n+            self.assertIs(locks.unlock(f2), True)\n+\n+    def test_unlock_unlocked_file(self):\n+        # Test unlocking an already unlocked file\n+        file_path = Path(__file__).parent / 'test.png'\n+        with open(file_path, 'w') as f:\n+            f.write('Test content')\n+\n+        with open(file_path) as f:\n+            # Unlocking an unlocked file should return True (or considered as successful no-op)\n+            self.assertIs(locks.unlock(f), True)\n+\n+    def test_acquire_lock_after_release(self):\n+        file_path = Path(__file__).parent / 'test.png'\n+        with open(file_path, 'w') as f:\n+            f.write('Test content')\n+\n+        with open(file_path) as f1, open(file_path) as f2:\n+            # Acquire an exclusive lock on f1\n+            self.assertIs(locks.lock(f1, locks.LOCK_EX), True)\n+            # Unlock f1\n+            self.assertIs(locks.unlock(f1), True)\n+            # Now f2 should be able to acquire an exclusive lock\n+            self.assertIs(locks.lock(f2, locks.LOCK_EX), True)\n+            # Cleanup: unlock f2\n+            self.assertIs(locks.unlock(f2), True)\n+\n import errno\n import gzip\n import os\n@@ -8,7 +64,8 @@ from io import BytesIO, StringIO, TextIOWrapper\n from pathlib import Path\n from unittest import mock\n \n-from django.core.files import File\n+from django.core.files import File, locks\n+from pathlib import Path\n from django.core.files.base import ContentFile\n from django.core.files.move import file_move_safe\n from django.core.files.temp import NamedTemporaryFile\n",
  "django__django-13417": "diff --git a/tests/queries/tests.py b/tests/queries/tests.py\nindex 8130de5..fd05dbc 100644\n--- a/tests/queries/tests.py\n+++ b/tests/queries/tests.py\n@@ -2084,6 +2084,20 @@ class QuerysetOrderedTests(unittest.TestCase):\n         self.assertIs(qs.ordered, False)\n         self.assertIs(qs.order_by('num_notes').ordered, True)\n \n+    def test_group_by_annotated_ordering(self):\n+        # This test covers the specific issue of ordered status for GROUP BY queries with annotations.\n+        qs = Foo.objects.annotate(num_pk=Count('pk')).all()\n+        self.assertIs(qs.ordered, False, \"QuerySet should not be ordered after GROUP BY with annotate\")\n+        qs_with_order = qs.order_by('name')\n+        self.assertIs(qs_with_order.ordered, True, \"Ordering should be true after explicitly ordering by a field\")\n+\n+    def test_annotated_values_ordering_without_group_by(self):\n+        # Test when values are used but without a GROUP BY that affects order.\n+        qs = Tag.objects.values('name').annotate(num_notes=Count('pk'))\n+        self.assertIs(qs.ordered, False)\n+        qs_with_order = qs.order_by('name')\n+        self.assertIs(qs_with_order.ordered, True)\n+\n \n @skipUnlessDBFeature('allow_sliced_subqueries_with_in')\n class SubqueryTests(TestCase):\n",
  "django__django-13516": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 89f7c38..1bacb53 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -335,6 +335,31 @@ class CommandTests(SimpleTestCase):\n             with self.assertRaisesMessage(TypeError, msg):\n                 management.call_command('subparser_dest', subcommand='foo', bar=12)\n \n+    def test_outputwrapper_flush(self):\n+        out = StringIO()\n+        with mock.patch.object(out, 'flush') as mocked_flush:\n+            management.call_command('outputwrapper', stdout=out)\n+        self.assertIn('Working...', out.getvalue())\n+        self.assertIs(mocked_flush.called, True)\n+\n+    def test_migrate_command_output(self):\n+        \"\"\"Test if flushing works correctly for long-running migrate commands\"\"\"\n+        out = StringIO()\n+        with mock.patch.object(out, 'flush') as mocked_flush:\n+            management.call_command('migrate', stdout=out)\n+            # check that intermediate output is present\n+            self.assertIn('Running migrations:', out.getvalue())\n+            self.assertIs(mocked_flush.called, True)\n+        \n+    def test_custom_command_with_flush(self):\n+        \"\"\"Test a custom command that requires flushing to stdout.\"\"\"\n+        out = StringIO()\n+        with mock.patch('sys.stdout', new=out):\n+            management.call_command('custom_command_with_flush')\n+            self.assertIn('Starting...', out.getvalue())\n+            self.assertIn('In Progress...', out.getvalue())\n+            self.assertIn('Finished.', out.getvalue())\n+\n     def test_create_parser_kwargs(self):\n         \"\"\"BaseCommand.create_parser() passes kwargs to CommandParser.\"\"\"\n         epilog = 'some epilog text'\n",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..1522e44 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,8 +1,10 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n from django.contrib.auth.models import User\n from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from .models.with_custom_email_field import CustomEmailField\n from django.test import TestCase\n from django.test.utils import ignore_warnings\n from django.utils.deprecation import RemovedInDjango40Warning\n@@ -37,7 +39,26 @@ class TokenGeneratorTest(TestCase):\n         tk2 = p0.make_token(user_reload)\n         self.assertEqual(tk1, tk2)\n \n-    def test_timeout(self):\n+    def test_token_invalidation_on_email_change(self):\n+        \"\"\"Token should be invalidated when the user's email is changed.\"\"\"\n+        tests = [\n+            (User, 'testuser@example.com'),\n+            (CustomEmailField, 'test4@example.com'),\n+        ]\n+        for model, email in tests:\n+            with self.subTest(model=model.__qualname__, email=email):\n+                user = model.objects.create_user(\n+                    'changeemailuser',\n+                    email=email,\n+                    password='testpw',\n+                )\n+                p0 = PasswordResetTokenGenerator()\n+                tk1 = p0.make_token(user)\n+                self.assertTrue(p0.check_token(user, tk1), \"Token should be initially valid.\")\n+                # Change user email\n+                setattr(user, user.get_email_field_name(), 'newemail@example.com')\n+                user.save()\n+                self.assertFalse(p0.check_token(user, tk1), \"Token should be invalid after email change.\")\n         \"\"\"The token is valid after n seconds, but no greater.\"\"\"\n         # Uses a mocked version of PasswordResetTokenGenerator so we can change\n         # the value of 'now'.\n",
  "django__django-13568": "diff --git a/tests/auth_tests/test_checks.py b/tests/auth_tests/test_checks.py\nindex c47b5c2..527b053 100644\n--- a/tests/auth_tests/test_checks.py\n+++ b/tests/auth_tests/test_checks.py\n@@ -1,9 +1,10 @@\n+\n from django.contrib.auth.checks import (\n     check_models_permissions, check_user_model,\n )\n from django.contrib.auth.models import AbstractBaseUser\n from django.core import checks\n-from django.db import models\n+from django.db import models, UniqueConstraint\n from django.test import (\n     SimpleTestCase, override_settings, override_system_checks,\n )\n@@ -138,7 +139,23 @@ class ModelsPermissionsChecksTests(SimpleTestCase):\n             ),\n         ])\n \n-    def test_non_clashing_custom_permissions(self):\n+    @override_settings(AUTH_USER_MODEL='auth_tests.CustomUserWithTotalUniqueConstraint')\n+    def test_username_with_total_unique_constraint(self):\n+        \"\"\"\n+        Test to verify that a UniqueConstraint on the USERNAME_FIELD\n+        suppresses the auth.E003 error.\n+        \"\"\"\n+        class CustomUserWithTotalUniqueConstraint(AbstractBaseUser):\n+            username = models.CharField(max_length=30)\n+            USERNAME_FIELD = 'username'\n+\n+            class Meta:\n+                constraints = [\n+                    UniqueConstraint(fields=['username'], name='username_total_unique'),\n+                ]\n+\n+        errors = checks.run_checks(app_configs=self.apps.get_app_configs())\n+        self.assertEqual(errors, [])\n         class Checked(models.Model):\n             class Meta:\n                 permissions = [\n",
  "django__django-13569": "",
  "django__django-13590": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 0b4f73f..d51ec1b 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import pickle\n import unittest\n@@ -802,7 +803,30 @@ class BasicExpressionsTests(TestCase):\n         )\n \n \n+from collections import namedtuple\n+\n class IterableLookupInnerExpressionsTests(TestCase):\n+    \n+    def test_range_lookup_namedtuple(self):\n+        \"\"\"Test using a named tuple as a range for filtering.\"\"\"\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=51, maximum=100),\n+        )\n+        self.assertQuerysetEqual(\n+            qs,\n+            ['<Company: 99300 Ltd>'],\n+            ordered=False\n+        )\n+\n+    def test_namedtuple_with_incomplete_arguments(self):\n+        \"\"\"Verify that creating a named tuple with missing arguments raises TypeError.\"\"\"\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        with self.assertRaises(TypeError):\n+            # We're intentionally providing a tuple without all arguments to ensure proper error handling.\n+            Company.objects.filter(\n+                num_employees__range=EmployeeRange(minimum=51)\n+            )\n     @classmethod\n     def setUpTestData(cls):\n         ceo = Employee.objects.create(firstname='Just', lastname='Doit', salary=30)\n",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..ad55d51 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -15,6 +15,7 @@ from io import StringIO\n from unittest import mock\n \n from django import conf, get_version\n+from django.test.utils import captured_stdout, captured_stderr\n from django.conf import settings\n from django.core.management import (\n     BaseCommand, CommandError, call_command, color,\n@@ -32,7 +33,41 @@ from django.test import (\n     LiveServerTestCase, SimpleTestCase, TestCase, override_settings,\n )\n \n-custom_templates_dir = os.path.join(os.path.dirname(__file__), 'custom_templates')\n+class ExecuteFromCommandLine(SimpleTestCase):\n+    def test_program_name_from_argv(self):\n+        \"\"\"\n+        Program name is computed from the execute_from_command_line()'s argv\n+        argument, not sys.argv.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line(['django-admin'] + args)\n+        self.assertIn('usage: django-admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_program_name_with_main_as_program(self):\n+        \"\"\"\n+        If '__main__.py' is passed as the program name, it should be corrected\n+        to 'python -m django'.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None] + args):\n+                execute_from_command_line(['__main__.py'] + args)\n+        self.assertIn('usage: python -m django shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n+\n+    def test_non_standard_sys_argv(self):\n+        \"\"\"\n+        Tests behavior when sys.argv is non-standard or None.\n+        \"\"\"\n+        args = ['help', 'shell']\n+        with captured_stdout() as out, captured_stderr() as err:\n+            with mock.patch('sys.argv', [None, None] + args):\n+                execute_from_command_line(['custom-admin'] + args)\n+        self.assertIn('usage: custom-admin shell', out.getvalue())\n+        self.assertEqual(err.getvalue(), '')\n \n SYSTEM_CHECK_MSG = 'System check identified no issues'\n \n",
  "django__django-13670": "diff --git a/tests/utils_tests/test_dateformat.py b/tests/utils_tests/test_dateformat.py\nindex 6f0b13f..976d39e 100644\n--- a/tests/utils_tests/test_dateformat.py\n+++ b/tests/utils_tests/test_dateformat.py\n@@ -1,3 +1,4 @@\n+\n from datetime import date, datetime\n \n from django.test import SimpleTestCase, override_settings\n@@ -146,7 +147,25 @@ class DateFormatTests(SimpleTestCase):\n         # Ticket #16924 -- We don't need timezone support to test this\n         self.assertEqual(dateformat.format(aware_dt, 'O'), '-0330')\n \n-    def test_invalid_time_format_specifiers(self):\n+    def test_year_before_1000(self):\n+        tests = [\n+            (476, '76'),\n+            (42, '42'),\n+            (4, '04'),\n+            (999, '99'),\n+            (1000, '00'),\n+            (1001, '01'),\n+            (100, '00'),\n+            (123, '23'),\n+            (9, '09'),\n+            (0, '00'),\n+        ]\n+        for year, expected_date in tests:\n+            with self.subTest(year=year):\n+                self.assertEqual(\n+                    dateformat.format(datetime(year, 9, 8, 5, 0), 'y'),\n+                    expected_date,\n+                )\n         my_birthday = date(1984, 8, 7)\n \n         for specifier in ['a', 'A', 'f', 'g', 'G', 'h', 'H', 'i', 'P', 'r', 's', 'u']:\n@@ -164,4 +183,4 @@ class DateFormatTests(SimpleTestCase):\n             self.assertEqual(\n                 dateformat.format(dt, 'r'),\n                 'Sun, 08 Jul 1979 22:00:00 +0100',\n-            )\n+            )\n",
  "django__django-13741": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex ca66cd5..34428f6 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1020,6 +1020,11 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n             \"\"\"\n         )\n \n+    def test_readonly_field_disabled(self):\n+        \"\"\"Test that the ReadOnlyPasswordHashField is disabled.\"\"\"\n+        field = ReadOnlyPasswordHashField()\n+        self.assertIs(field.disabled, True)\n+\n     def test_readonly_field_has_changed(self):\n         field = ReadOnlyPasswordHashField()\n         self.assertFalse(field.has_changed('aaa', 'bbb'))\n",
  "django__django-13786": "",
  "django__django-13794": "",
  "django__django-13807": "diff --git a/tests/backends/tests.py b/tests/backends/tests.py\nindex 0aee2b6..a5d7784 100644\n--- a/tests/backends/tests.py\n+++ b/tests/backends/tests.py\n@@ -21,9 +21,13 @@ from django.test import (\n from .models import (\n     Article, Object, ObjectReference, Person, Post, RawData, Reporter,\n     ReporterProxy, SchoolClass, Square,\n-    VeryLongModelNameZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ,\n+    VeryLongModelNameZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ, \n+    SQLKeywordsModel\n )\n \n+from django.db import connection, IntegrityError, transaction\n+from .models import Reporter\n+\n \n class DateQuotingTest(TestCase):\n \n@@ -626,7 +630,23 @@ class FkConstraintsTests(TransactionTestCase):\n             transaction.set_rollback(True)\n \n \n-class ThreadTests(TransactionTestCase):\n+\n+class SQLKeywordsModelTestCase(TransactionTestCase):\n+    available_apps = ['backends']\n+\n+    def setUp(self):\n+        self.reporter = Reporter.objects.create(name=\"Test Reporter\")\n+\n+    def test_check_constraints_sql_keywords(self):\n+        with transaction.atomic():\n+            obj = SQLKeywordsModel.objects.create(reporter=self.reporter)\n+            obj.refresh_from_db()\n+            obj.reporter_id = 30\n+            with connection.constraint_checks_disabled():\n+                obj.save()\n+                with self.assertRaises(IntegrityError):\n+                    connection.check_constraints(table_names=['order'])\n+            transaction.set_rollback(True)\n \n     available_apps = ['backends']\n \n",
  "django__django-13809": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex d88ea78..3055c09 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -1314,6 +1314,12 @@ class ManageRunserver(SimpleTestCase):\n         self.assertIn('unapplied migration(s)', self.output.getvalue())\n \n \n+from io import StringIO\n+from unittest import mock\n+from django.core.management import call_command\n+from django.test import TestCase\n+from django.core.management.commands.runserver import Command as RunserverCommand\n+\n class ManageRunserverMigrationWarning(TestCase):\n \n     def setUp(self):\n@@ -1342,8 +1348,37 @@ class ManageRunserverMigrationWarning(TestCase):\n             'app_waiting_migration.', output\n         )\n \n+class TestRunserverSkipChecksOption(TestCase):\n \n-class ManageRunserverEmptyAllowedHosts(AdminScriptTestCase):\n+    def setUp(self):\n+        self.output = StringIO()\n+\n+    @mock.patch('django.core.management.commands.runserver.run')\n+    @mock.patch('django.core.management.base.BaseCommand.check')\n+    def test_skip_checks_option(self, mocked_check, *mocked_objects):\n+        # Test with skip_checks enabled\n+        call_command(\n+            'runserver',\n+            use_reloader=False,\n+            skip_checks=True,\n+            stdout=self.output,\n+        )\n+        self.assertNotIn('Performing system checks...', self.output.getvalue())\n+        mocked_check.assert_not_called()\n+\n+        # Reset output buffer\n+        self.output.truncate(0)\n+        self.output.seek(0)\n+\n+        # Test with skip_checks disabled\n+        call_command(\n+            'runserver',\n+            use_reloader=False,\n+            skip_checks=False,\n+            stdout=self.output,\n+        )\n+        self.assertIn('Performing system checks...', self.output.getvalue())\n+        mocked_check.assert_called()\n     def setUp(self):\n         super().setUp()\n         self.write_settings('settings.py', sdict={\n",
  "django__django-13810": "",
  "django__django-13820": "diff --git a/tests/migrations/test_loader.py b/tests/migrations/test_loader.py\nindex 594c01e..b1d4449 100644\n--- a/tests/migrations/test_loader.py\n+++ b/tests/migrations/test_loader.py\n@@ -1,3 +1,4 @@\n+\n import compileall\n import os\n \n@@ -512,8 +513,36 @@ class LoaderTests(TestCase):\n         migrations = [name for app, name in loader.disk_migrations if app == 'migrations']\n         self.assertEqual(migrations, [])\n \n+from importlib import import_module\n \n-class PycLoaderTests(MigrationTestBase):\n+class LoaderFrozenEnvTests(TestCase):\n+    @override_settings(\n+        MIGRATION_MODULES={'migrations': 'migrations.test_migrations_frozen'},\n+    )\n+    def test_loading_package_without__file__(self):\n+        \"\"\"\n+        Ensure that MigrationLoader loads migrations from packages without __file__ attribute.\n+        \"\"\"\n+        test_module = import_module('migrations.test_migrations_frozen')\n+        loader = MigrationLoader(connection)\n+        module_file = test_module.__file__\n+        module_origin = test_module.__spec__.origin\n+        module_has_location = test_module.__spec__.has_location\n+        try:\n+            del test_module.__file__\n+            test_module.__spec__.origin = None\n+            test_module.__spec__.has_location = False\n+            loader.load_disk()\n+            migrations = [\n+                name\n+                for app, name in loader.disk_migrations\n+                if app == 'migrations'\n+            ]\n+            self.assertCountEqual(migrations, ['0001_initial', '0002_second'])\n+        finally:\n+            test_module.__file__ = module_file\n+            test_module.__spec__.origin = module_origin\n+            test_module.__spec__.has_location = module_has_location\n \n     def test_valid(self):\n         \"\"\"\n",
  "django__django-13821": "diff --git a/tests/backends/sqlite/tests.py b/tests/backends/sqlite/tests.py\nindex e602447..e7a0b7a 100644\n--- a/tests/backends/sqlite/tests.py\n+++ b/tests/backends/sqlite/tests.py\n@@ -10,6 +10,8 @@ from unittest import mock\n from django.core.exceptions import ImproperlyConfigured\n from django.db import NotSupportedError, connection, transaction\n from django.db.models import Aggregate, Avg, CharField, StdDev, Sum, Variance\n+from django.core.exceptions import ImproperlyConfigured\n+import unittest.mock as mock\n from django.db.utils import ConnectionHandler\n from django.test import (\n     TestCase, TransactionTestCase, override_settings, skipIfDBFeature,\n@@ -36,7 +38,21 @@ class Tests(TestCase):\n                 self.assertRaisesMessage(ImproperlyConfigured, msg):\n             check_sqlite_version()\n \n-    def test_aggregation(self):\n+    def test_check_sqlite_version_with_older_versions(self):\n+        msg = 'SQLite 3.9.0 or later is required (found 3.8.7).'\n+        with mock.patch.object(dbapi2, 'sqlite_version_info', (3, 8, 7)), \\\n+                mock.patch.object(dbapi2, 'sqlite_version', '3.8.7'), \\\n+                self.assertRaisesMessage(ImproperlyConfigured, msg):\n+            check_sqlite_version()\n+\n+    def test_check_sqlite_version_with_supported_version(self):\n+        # This test ensures that no exception is raised for a supported version.\n+        with mock.patch.object(dbapi2, 'sqlite_version_info', (3, 9, 0)), \\\n+                mock.patch.object(dbapi2, 'sqlite_version', '3.9.0'):\n+            try:\n+                check_sqlite_version()\n+            except ImproperlyConfigured:\n+                self.fail(\"check_sqlite_version() raised ImproperlyConfigured unexpectedly!\")\n         \"\"\"Raise NotSupportedError when aggregating on date/time fields.\"\"\"\n         for aggregate in (Sum, Avg, Variance, StdDev):\n             with self.assertRaises(NotSupportedError):\n",
  "django__django-13837": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 10ffa22..c3c6ab8 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -165,9 +165,21 @@ class TestChildArguments(SimpleTestCase):\n             [sys.executable, '-m', 'django', 'runserver']\n         )\n \n-    @mock.patch('sys.argv', [__file__, 'runserver'])\n+    @mock.patch.dict(sys.modules, {'__main__': django.__main__})\n+    @mock.patch('sys.argv', [test_main.__file__, 'runserver'])\n+    @mock.patch('sys.warnoptions', [])\n+    def test_run_as_non_django_module(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-m', 'utils_tests.test_module', 'runserver'],\n+        )\n     @mock.patch('sys.warnoptions', ['error'])\n-    def test_warnoptions(self):\n+    @mock.patch.dict(sys.modules, {'__main__': test_main})\n+    @mock.patch('sys.argv', ['nonexistent_script.py', 'runserver'])\n+    @mock.patch('sys.warnoptions', [])\n+    def test_nonexistent_script(self):\n+        with self.assertRaises(RuntimeError):\n+            autoreload.get_child_arguments()\n         self.assertEqual(\n             autoreload.get_child_arguments(),\n             [sys.executable, '-Werror', __file__, 'runserver']\n",
  "django__django-13925": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 6424d89..6d1b42c 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -393,6 +393,38 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n                 obj=Model,\n                 id='models.W042',\n             ),\n+\n+        ])\n+\n+    def test_inherited_explicit_pk_no_warning(self):\n+        class Base(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class Inherited(Base):\n+            pass\n+\n+        # No warnings should be raised, as the PK is explicitly defined and inherited.\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n+    def test_inherited_implicit_pk_warning(self):\n+        class Base(models.Model):\n+            pass\n+\n+        class Inherited(Base):\n+            pass\n+\n+        # Warning should be raised, as no PK is explicitly defined in the base or inherited model.\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [\n+            Warning(\n+                \"Auto-created primary key used when not defining a primary key type, by default 'django.db.models.AutoField'.\",\n+                hint=(\n+                    \"Configure the DEFAULT_AUTO_FIELD setting or the \"\n+                    \"CheckDefaultPKConfig.default_auto_field attribute to \"\n+                    \"point to a subclass of AutoField, e.g. 'django.db.models.BigAutoField'.\"\n+                ),\n+                obj=Base,\n+                id='models.W042',\n+            ),\n         ])\n \n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.BigAutoField')\n@@ -414,4 +446,4 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n             class Meta:\n                 app_label = 'check_framework.apps.CheckPKConfig'\n \n-        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..ac171c4 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -281,8 +281,29 @@ class FormsErrorMessagesTestCase(SimpleTestCase, AssertFormErrorsMixin):\n             '</ul></li></ul>'\n         )\n \n+from django.forms import ModelChoiceField, ModelMultipleChoiceField\n+from .models import ChoiceModel\n+from django.test import TestCase\n \n class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n+    def test_modelchoicefield_value_placeholder(self):\n+        # Create choices for the model choice field tests below.\n+        ChoiceModel.objects.create(pk=1, name='a')\n+        ChoiceModel.objects.create(pk=2, name='b')\n+        ChoiceModel.objects.create(pk=3, name='c')\n+\n+        # Test ModelChoiceField error message with invalid choice value.\n+        f = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            },\n+        )\n+        self.assertFormErrors(\n+            ['\"invalid\" is not one of the available choices.'],\n+            f.clean,\n+            'invalid',\n+        )\n     def test_modelchoicefield(self):\n         # Create choices for the model choice field tests below.\n         ChoiceModel.objects.create(pk=1, name='a')\n@@ -307,4 +328,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "diff --git a/tests/many_to_one/tests.py b/tests/many_to_one/tests.py\nindex 8af1b8e..4c3ad0d 100644\n--- a/tests/many_to_one/tests.py\n+++ b/tests/many_to_one/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n from copy import deepcopy\n \n@@ -9,7 +10,7 @@ from django.utils.translation import gettext_lazy\n from .models import (\n     Article, Category, Child, ChildNullableParent, City, Country, District,\n     First, Parent, Record, Relation, Reporter, School, Student, Third,\n-    ToFieldChild,\n+    ToFieldChild, ParentStringPrimaryKey, ChildStringPrimaryKeyParent\n )\n \n \n@@ -549,7 +550,29 @@ class ManyToOneTests(TestCase):\n         self.assertEqual(child.parent, parent)\n         self.assertEqual(child.parent_id, parent.name)\n \n-    def test_fk_to_bigautofield(self):\n+    def test_save_fk_after_parent_with_non_numeric_pk_set_on_child_unsaved_product(self):\n+        # Testing the issue where assigning an unsaved parent with non-numeric primary key\n+        # to a child and saving causes a data inconsistency in the relation\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey()\n+            child = ChildStringPrimaryKeyParent(parent=parent)\n+            parent.name = 'jeff'\n+            parent.save()\n+            child.save()\n+            child.refresh_from_db()\n+            self.assertEqual(child.parent, parent)\n+            self.assertEqual(child.parent_id, parent.name)\n+\n+    def test_save_fk_after_parent_with_non_numeric_pk_set_on_child_saved_product(self):\n+        # This test case checks the correct behavior when the parent is initialized with a primary key before assignment\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey(name='george')\n+            parent.save()\n+            child = ChildStringPrimaryKeyParent(parent=parent)\n+            child.save()\n+            child.refresh_from_db()\n+            self.assertEqual(child.parent, parent)\n+            self.assertEqual(child.parent_id, parent.name)\n         ch = City.objects.create(name='Chicago')\n         District.objects.create(city=ch, name='Far South')\n         District.objects.create(city=ch, name='North')\n",
  "django__django-14007": "diff --git a/tests/custom_pk/tests.py b/tests/custom_pk/tests.py\nindex cbae2d9..4aba06c 100644\n--- a/tests/custom_pk/tests.py\n+++ b/tests/custom_pk/tests.py\n@@ -1,7 +1,10 @@\n+\n from django.db import IntegrityError, transaction\n from django.test import TestCase, skipIfDBFeature\n \n-from .models import Bar, Business, Employee, Foo\n+from .models import Bar, Business, Employee, Foo, CustomAutoFieldModel\n+from .fields import MyWrapper\n+from django.test import skipUnlessDBFeature\n \n \n class BasicCustomPKTests(TestCase):\n",
  "django__django-14017": "",
  "django__django-14053": "diff --git a/tests/staticfiles_tests/test_storage.py b/tests/staticfiles_tests/test_storage.py\nindex 76f3d3e..43fea5c 100644\n--- a/tests/staticfiles_tests/test_storage.py\n+++ b/tests/staticfiles_tests/test_storage.py\n@@ -205,6 +205,21 @@ class TestHashedFiles:\n         self.assertIn(os.path.join('test', 'nonascii.css'), stats['post_processed'])\n         self.assertPostCondition()\n \n+    def test_no_duplicate_post_processed_files(self):\n+        \"\"\"\n+        Test that no file is yielded more than once during post-processing.\n+        \"\"\"\n+        # Simulate a collectstatic command to collect and post-process files\n+        collectstatic_cmd = CollectstaticCommand()\n+        collectstatic_cmd.set_options(post_process=True, dry_run=False)\n+        stats = collectstatic_cmd.collect()\n+\n+        # Gather all post-processed filenames\n+        post_processed_files = stats['post_processed']\n+\n+        # Verify no duplicate files are present in post-processed files\n+        self.assertCountEqual(post_processed_files, set(post_processed_files))\n+\n     def test_css_import_case_insensitive(self):\n         relpath = self.hashed_file_path(\"cached/styles_insensitive.css\")\n         self.assertEqual(relpath, \"cached/styles_insensitive.3fa427592a53.css\")\n@@ -214,6 +229,21 @@ class TestHashedFiles:\n             self.assertIn(b\"other.d41d8cd98f00.css\", content)\n         self.assertPostCondition()\n \n+    def test_no_duplicate_post_processed_files(self):\n+        \"\"\"\n+        Test that no file is yielded more than once during post-processing.\n+        \"\"\"\n+        # Simulate a collectstatic command to collect and post-process files\n+        collectstatic_cmd = CollectstaticCommand()\n+        collectstatic_cmd.set_options(post_process=True, dry_run=False)\n+        stats = collectstatic_cmd.collect()\n+\n+        # Gather all post-processed filenames\n+        post_processed_files = stats['post_processed']\n+\n+        # Verify no duplicate files are present in post-processed files\n+        self.assertCountEqual(post_processed_files, set(post_processed_files))\n+\n     @override_settings(\n         STATICFILES_DIRS=[os.path.join(TEST_ROOT, 'project', 'faulty')],\n         STATICFILES_FINDERS=['django.contrib.staticfiles.finders.FileSystemFinder'],\n",
  "django__django-14089": "diff --git a/tests/utils_tests/test_datastructures.py b/tests/utils_tests/test_datastructures.py\nindex 7fb3d83..b4a40c8 100644\n--- a/tests/utils_tests/test_datastructures.py\n+++ b/tests/utils_tests/test_datastructures.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Tests for stuff in django.utils.datastructures.\n \"\"\"\n@@ -6,6 +7,7 @@ import copy\n import pickle\n \n from django.test import SimpleTestCase\n+import collections.abc\n from django.utils.datastructures import (\n     CaseInsensitiveMapping, DictWrapper, ImmutableList, MultiValueDict,\n     MultiValueDictKeyError, OrderedSet,\n@@ -18,7 +20,26 @@ class OrderedSetTests(SimpleTestCase):\n         s = OrderedSet([1, 2, 3])\n         self.assertEqual(list(s.dict.keys()), [1, 2, 3])\n \n-    def test_remove(self):\n+    def test_reversed(self):\n+        # Test reversing a non-empty OrderedSet\n+        s = reversed(OrderedSet([1, 2, 3]))\n+        self.assertIsInstance(s, collections.abc.Iterator)\n+        self.assertEqual(list(s), [3, 2, 1])\n+\n+        # Test reversing an empty OrderedSet\n+        s_empty = reversed(OrderedSet())\n+        self.assertIsInstance(s_empty, collections.abc.Iterator)\n+        self.assertEqual(list(s_empty), [])\n+\n+        # Test reversing an OrderedSet with duplicate entries\n+        s_duplicates = reversed(OrderedSet([1, 2, 2, 3, 3, 3]))\n+        self.assertIsInstance(s_duplicates, collections.abc.Iterator)\n+        self.assertEqual(list(s_duplicates), [3, 2, 1])\n+\n+        # Test reversing an OrderedSet with one element\n+        s_single = reversed(OrderedSet([42]))\n+        self.assertIsInstance(s_single, collections.abc.Iterator)\n+        self.assertEqual(list(s_single), [42])\n         s = OrderedSet()\n         self.assertEqual(len(s), 0)\n         s.add(1)\n",
  "django__django-14122": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex b2ec8af..85f6423 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from decimal import Decimal\n@@ -101,7 +102,35 @@ class AggregateTestCase(TestCase):\n         s2.books.add(cls.b1, cls.b3, cls.b5, cls.b6)\n         s3.books.add(cls.b3, cls.b4, cls.b6)\n \n-    def test_empty_aggregate(self):\n+    def test_meta_ordering_not_included_in_group_by(self):\n+        \"\"\"\n+        Test that Meta.ordering fields are not incorrectly included in the\n+        GROUP BY clause when no explicit ordering is provided.\n+        \"\"\"\n+        # Ensure the test setup: Associate authors with books.\n+        self.b1.authors.add(self.a1, self.a2)\n+        self.b2.authors.add(self.a3)\n+        self.b3.authors.add(self.a4)\n+        \n+        # Set Meta.ordering on Author model in a hypothetical scenario.\n+        with CaptureQueriesContext(connection) as ctx:\n+            authors = Author.objects.values('name').annotate(total_books=Count('book')).order_by()\n+            self.assertEqual(\n+                list(authors), [\n+                    {'name': 'Adrian Holovaty', 'total_books': 1},\n+                    {'name': 'Brad Dayley', 'total_books': 1},\n+                    {'name': 'Jacob Kaplan-Moss', 'total_books': 1},\n+                    {'name': 'James Bennett', 'total_books': 1},\n+                    {'name': 'Jeffrey Forcier', 'total_books': 0},\n+                    {'name': 'Paul Bissex', 'total_books': 0},\n+                    {'name': 'Peter Norvig', 'total_books': 1},\n+                    {'name': 'Stuart Russell', 'total_books': 1},\n+                    {'name': 'Wesley J. Chun', 'total_books': 0},\n+                ],\n+            )\n+        # Check the query does not contain Meta.ordering fields in GROUP BY.\n+        for query in ctx.captured_queries:\n+            self.assertNotIn('author.ordering_field', query['sql'].lower())\n         self.assertEqual(Author.objects.all().aggregate(), {})\n \n     def test_aggregate_in_order_by(self):\n@@ -1339,4 +1368,4 @@ class AggregateTestCase(TestCase):\n             ('Wesley J. Chun', 1),\n             ('Stuart Russell', 1),\n             ('Peter Norvig', 2),\n-        ], lambda a: (a.name, a.contact_count), ordered=False)\n+        ], lambda a: (a.name, a.contact_count), ordered=False)\n",
  "django__django-14140": "",
  "django__django-14238": "diff --git a/tests/model_fields/test_autofield.py b/tests/model_fields/test_autofield.py\nindex bfbf1e8..102e322 100644\n--- a/tests/model_fields/test_autofield.py\n+++ b/tests/model_fields/test_autofield.py\n@@ -32,4 +32,26 @@ class AutoFieldInheritanceTests(SimpleTestCase):\n     def test_issubclass_of_autofield(self):\n         for field in (models.BigAutoField, models.SmallAutoField):\n             with self.subTest(field.__name__):\n-                self.assertTrue(issubclass(field, models.AutoField))\n+                self.assertTrue(issubclass(field, models.AutoField))\n+\n+    def test_isinstance_of_custom_big_small_autofield(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        for field in (MyBigAutoField, MySmallAutoField):\n+            with self.subTest(field.__name__):\n+                self.assertIsInstance(field(), models.AutoField)\n+\n+    def test_issubclass_of_custom_big_small_autofield(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        for field in (MyBigAutoField, MySmallAutoField):\n+            with self.subTest(field.__name__):\n+                self.assertTrue(issubclass(field, models.AutoField))\n",
  "django__django-14311": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex b7e6f92..5e850b2 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -166,6 +166,15 @@ class TestIterModulesAndFiles(SimpleTestCase):\n class TestChildArguments(SimpleTestCase):\n     @mock.patch.dict(sys.modules, {'__main__': django.__main__})\n     @mock.patch('sys.argv', [django.__main__.__file__, 'runserver'])\n+    @mock.patch.dict(sys.modules, {'__main__': test_main_module})\n+    @mock.patch('sys.argv', [test_main.__file__, 'runserver'])\n+    @mock.patch('sys.warnoptions', [])\n+    def test_run_as_non_django_module_non_package_with_dotted_name(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-m', 'utils_tests.test_module.main_module', 'runserver'],\n+        )\n+\n     @mock.patch('sys.warnoptions', [])\n     def test_run_as_module(self):\n         self.assertEqual(\n@@ -175,6 +184,15 @@ class TestChildArguments(SimpleTestCase):\n \n     @mock.patch.dict(sys.modules, {'__main__': test_main})\n     @mock.patch('sys.argv', [test_main.__file__, 'runserver'])\n+    @mock.patch.dict(sys.modules, {'__main__': test_main_module})\n+    @mock.patch('sys.argv', [test_main.__file__, 'runserver'])\n+    @mock.patch('sys.warnoptions', [])\n+    def test_run_as_non_django_module_non_package_with_dotted_name(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-m', 'utils_tests.test_module.main_module', 'runserver'],\n+        )\n+\n     @mock.patch('sys.warnoptions', [])\n     def test_run_as_non_django_module(self):\n         self.assertEqual(\n@@ -190,6 +208,15 @@ class TestChildArguments(SimpleTestCase):\n             [sys.executable, '-Werror', __file__, 'runserver']\n         )\n \n+    @mock.patch.dict(sys.modules, {'__main__': test_main_module})\n+    @mock.patch('sys.argv', [test_main.__file__, 'runserver'])\n+    @mock.patch('sys.warnoptions', [])\n+    def test_run_as_non_django_module_non_package_with_dotted_name(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-m', 'utils_tests.test_module.main_module', 'runserver'],\n+        )\n+\n     @mock.patch('sys.warnoptions', [])\n     def test_exe_fallback(self):\n         with tempfile.TemporaryDirectory() as tmpdir:\n@@ -201,6 +228,15 @@ class TestChildArguments(SimpleTestCase):\n                     [exe_path, 'runserver']\n                 )\n \n+    @mock.patch.dict(sys.modules, {'__main__': test_main_module})\n+    @mock.patch('sys.argv', [test_main.__file__, 'runserver'])\n+    @mock.patch('sys.warnoptions', [])\n+    def test_run_as_non_django_module_non_package_with_dotted_name(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-m', 'utils_tests.test_module.main_module', 'runserver'],\n+        )\n+\n     @mock.patch('sys.warnoptions', [])\n     def test_entrypoint_fallback(self):\n         with tempfile.TemporaryDirectory() as tmpdir:\n",
  "django__django-14349": "diff --git a/tests/validators/tests.py b/tests/validators/tests.py\nindex f726e49..ec2bca0 100644\n--- a/tests/validators/tests.py\n+++ b/tests/validators/tests.py\n@@ -234,6 +234,12 @@ TEST_DATA = [\n     (URLValidator(), 'http://www.asdasdasdasdsadfm.com.br z', ValidationError),\n \n     (BaseValidator(True), True, None),\n+    # Newlines, carriage returns, and tabs should not be accepted within the URL\n+    (URLValidator(), 'http://www.djangoproject.com/\\r\\n', ValidationError),\n+    (URLValidator(), 'http://www.djangoproject.com/\\t', ValidationError),\n+    (URLValidator(), 'http://www.djang\\noproject.com/', ValidationError),\n+    (URLValidator(), 'http://[::ffff:192.9.5.5]\\r', ValidationError),\n+    (URLValidator(), 'http://\\t[::ffff:192.9.5.5]', ValidationError),\n     (BaseValidator(True), False, ValidationError),\n \n     (RegexValidator(), '', None),\n",
  "django__django-14351": "diff --git a/tests/aggregation_regress/tests.py b/tests/aggregation_regress/tests.py\nindex 79963c3..8b871e3 100644\n--- a/tests/aggregation_regress/tests.py\n+++ b/tests/aggregation_regress/tests.py\n@@ -1526,6 +1526,52 @@ class AggregationTests(TestCase):\n         DistinctAggregate('foo', distinct=True)\n \n \n+from django.db.models import Q, Count\n+from django.test import TestCase\n+\n+class AggregationSubqueryTests(TestCase):\n+    def setUp(self):\n+        # Setup initial data for testing\n+        self.a1 = Author.objects.create(name='Author 1')\n+        self.a2 = Author.objects.create(name='Author 2')\n+        self.b1 = Book.objects.create(title='Book 1')\n+        self.b2 = Book.objects.create(title='Book 2')\n+        self.b3 = Book.objects.create(title='Book 3')\n+        self.b4 = Book.objects.create(title='Book 4')\n+\n+        self.b1.authors.add(self.a1)\n+        self.b2.authors.add(self.a2)\n+        self.b4.authors.add(self.a1, self.a2)\n+\n+    def test_having_subquery_select(self):\n+        authors = Author.objects.filter(pk=self.a1.pk)\n+        books = Book.objects.annotate(Count('authors')).filter(\n+            Q(authors__in=authors) | Q(authors__count__gt=2)\n+        )\n+        self.assertEqual(set(books), {self.b1, self.b4})\n+\n+    def test_property_groups_subquery(self):\n+        property_groups = PropertyGroup.objects.agent_groups(management_agent=342)\n+        queryset = ManagerTicketRatingCumulativeMovingAverage.objects.annotate(\n+            Count(\"agent__property_groups\")\n+        ).filter(\n+            Q(agent__property_groups__in=property_groups) | Q(agent__property_groups__count=0)\n+        ).distinct()\n+\n+        # Test should pass without raising \"subquery must return only one column\"\n+        self.assertIsNotNone(queryset)\n+\n+    def test_flattened_property_groups_subquery(self):\n+        qs = ManagerTicketRatingCumulativeMovingAverage.objects.all()\n+        property_groups = PropertyGroup.objects.agent_groups(management_agent=342)\n+        queryset = qs.annotate(Count(\"agent__property_groups\")).filter(\n+            Q(agent__property_groups__id__in=property_groups.values_list(\"id\", flat=True)) | Q(agent__property_groups__count=0)\n+        ).distinct()\n+\n+        # Controls to ensure query execution without errors\n+        self.assertIsNotNone(queryset)\n+\n+\n class JoinPromotionTests(TestCase):\n     def test_ticket_21150(self):\n         b = Bravo.objects.create()\n",
  "django__django-14373": "",
  "django__django-14376": "diff --git a/tests/dbshell/test_mysql.py b/tests/dbshell/test_mysql.py\nindex 643c2b6..588bea4 100644\n--- a/tests/dbshell/test_mysql.py\n+++ b/tests/dbshell/test_mysql.py\n@@ -68,6 +68,42 @@ class MySqlDbshellCommandTestCase(SimpleTestCase):\n             (expected_args, expected_env),\n         )\n \n+    def test_options_deprecated_and_new_keys(self):\n+        settings_port = 444\n+        options_port = 555\n+        self.assertNotEqual(settings_port, options_port, 'test pre-req')\n+        expected_args = [\n+            'mysql',\n+            '--user=optionuser',\n+            '--host=optionhost',\n+            '--port=%s' % options_port,\n+            'optiondbname',\n+        ]\n+        expected_env = {'MYSQL_PWD': 'optionpassword'}\n+        for keys in [('database', 'password'), ('db', 'passwd')]:\n+            with self.subTest(keys=keys):\n+                database, password = keys\n+                # If both new and deprecated keys are provided, the new ones should prevail\n+                self.assertEqual(\n+                    self.settings_to_cmd_args_env({\n+                        'NAME': 'settingdbname',\n+                        'USER': 'settinguser',\n+                        'PASSWORD': 'settingpassword',\n+                        'HOST': 'settinghost',\n+                        'PORT': settings_port,\n+                        'OPTIONS': {\n+                            database: 'optiondbname',\n+                            'user': 'optionuser',\n+                            password: 'optionpassword',\n+                            'host': 'optionhost',\n+                            'port': options_port,\n+                            'db': 'deprecatedoptiondbname',\n+                            'passwd': 'deprecatedoptionpassword',\n+                        },\n+                    }),\n+                    (expected_args, expected_env),\n+                )\n+\n     def test_options_password(self):\n         expected_args = [\n             'mysql',\n",
  "django__django-14434": "",
  "django__django-14493": "diff --git a/tests/staticfiles_tests/storage.py b/tests/staticfiles_tests/storage.py\nindex dc966a1..3b5d35c 100644\n--- a/tests/staticfiles_tests/storage.py\n+++ b/tests/staticfiles_tests/storage.py\n@@ -94,6 +94,9 @@ class ExtraPatternsStorage(ManifestStaticFilesStorage):\n     )\n \n \n+class NoPostProcessReplacedPathStorage(ManifestStaticFilesStorage):\n+    max_post_process_passes = 0\n+\n class NoneHashStorage(ManifestStaticFilesStorage):\n     def file_hash(self, name, content=None):\n-        return None\n+        return None\n",
  "django__django-14500": "diff --git a/tests/migrations/test_executor.py b/tests/migrations/test_executor.py\nindex d884fe4..6e4fd19 100644\n--- a/tests/migrations/test_executor.py\n+++ b/tests/migrations/test_executor.py\n@@ -653,7 +653,37 @@ class ExecutorTests(MigrationTestBase):\n             recorder.applied_migrations(),\n         )\n \n-    # When the feature is False, the operation and the record won't be\n+    @override_settings(MIGRATION_MODULES={'migrations': 'migrations.test_migrations_squashed'})\n+    def test_unapply_squashed_migration(self):\n+        \"\"\"\n+        Test that unapplying a squashed migration marks it as unapplied,\n+        without affecting the replaced migrations if they are still around.\n+        \"\"\"\n+        executor = MigrationExecutor(connection)\n+        # Apply the squashed migration\n+        executor.migrate([('migrations', '0001_squashed_0002')])\n+        try:\n+            self.assertIn(\n+                ('migrations', '0001_squashed_0002'),\n+                executor.recorder.applied_migrations(),\n+            )\n+            # Unapply the squashed migration\n+            executor.migrate([('migrations', None)])\n+            self.assertNotIn(\n+                ('migrations', '0001_squashed_0002'),\n+                executor.recorder.applied_migrations(),\n+            )\n+            # Ensure the replaced migrations are still marked as unapplied\n+            self.assertNotIn(\n+                ('migrations', '0001_initial'),\n+                executor.recorder.applied_migrations(),\n+            )\n+            self.assertNotIn(\n+                ('migrations', '0002_second'),\n+                executor.recorder.applied_migrations(),\n+            )\n+        finally:\n+            executor.loader.build_graph()\n     # performed in a transaction and the test will systematically pass.\n     @skipUnlessDBFeature('can_rollback_ddl')\n     def test_migrations_applied_and_recorded_atomically(self):\n",
  "django__django-14539": "",
  "django__django-14559": "diff --git a/tests/queries/test_bulk_update.py b/tests/queries/test_bulk_update.py\nindex b579834..5aa4ccf 100644\n--- a/tests/queries/test_bulk_update.py\n+++ b/tests/queries/test_bulk_update.py\n@@ -115,6 +115,37 @@ class BulkUpdateTests(TestCase):\n \n     pk_fields_error = 'bulk_update() cannot be used with primary key fields.'\n \n+from django.test import TestCase\n+from .models import Note, CustomPk, Valid, Detail, Paragraph, Member\n+\n+class BulkUpdateTest(TestCase):\n+    def test_return_value_empty_list(self):\n+        \"\"\"Test bulk_update returns 0 when the input list is empty.\"\"\"\n+        rows_updated = Note.objects.bulk_update([], ['note'])\n+        self.assertEqual(rows_updated, 0)\n+\n+    def test_large_update(self):\n+        \"\"\"Test bulk_update returns the correct number of updated rows.\"\"\"\n+        Note.objects.bulk_create([Note(note=str(i), misc=str(i)) for i in range(0, 2000)])\n+        notes = list(Note.objects.all())\n+        rows_updated = Note.objects.bulk_update(notes, ['note'])\n+        self.assertEqual(rows_updated, 2000)\n+\n+    def test_duplicates_in_update_list(self):\n+        \"\"\"Test bulk_update with duplicate objects in the list.\"\"\"\n+        note = Note.objects.create(note='test-note', misc='test')\n+        rows_updated = Note.objects.bulk_update([note, note], ['note'])\n+        self.assertEqual(rows_updated, 1)\n+\n+        rows_updated = Note.objects.bulk_update([note, note], ['note'], batch_size=1)\n+        self.assertEqual(rows_updated, 2)\n+\n+    def test_no_objects_updated(self):\n+        \"\"\"Test bulk_update with objects having unchanged field values.\"\"\"\n+        note = Note.objects.create(note='test-note', misc='test')\n+        rows_updated = Note.objects.bulk_update([note], ['note'])\n+        self.assertEqual(rows_updated, 1)\n+\n     def test_update_primary_key(self):\n         with self.assertRaisesMessage(ValueError, self.pk_fields_error):\n             Note.objects.bulk_update([], ['id'])\n",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..880868b 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -984,6 +984,24 @@ class FormsFormsetTestCase(SimpleTestCase):\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n \n+    def test_non_form_errors_with_css_class(self):\n+        \"\"\"\n+        Checks if the nonform CSS class is added to non-form errors in FormSets.\n+        \"\"\"\n+        data = {\n+            'drinks-TOTAL_FORMS': '3',  # number of forms rendered\n+            'drinks-INITIAL_FORMS': '0',  # number of forms with initial data\n+            'drinks-MIN_NUM_FORMS': '0',  # min number of forms\n+            'drinks-MAX_NUM_FORMS': '0',  # max number of forms\n+            'drinks-0-name': 'Rum and Coke',\n+            'drinks-1-name': 'Gin and Tonic',\n+            'drinks-2-name': 'Gin and Tonic',  # duplicate drink name to trigger error\n+        }\n+        formset = FavoriteDrinksFormSet(data, prefix='drinks')\n+        self.assertFalse(formset.is_valid())\n+        expected_error_html = '<ul class=\"errorlist nonform\"><li>You may only specify a drink once.</li></ul>'\n+        self.assertEqual(str(formset.non_form_errors()), expected_error_html)\n+\n     def test_formset_iteration(self):\n         \"\"\"Formset instances are iterable.\"\"\"\n         ChoiceFormset = formset_factory(Choice, extra=3)\n",
  "django__django-14631": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex a48e4b6..6113380 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -2129,6 +2129,31 @@ Password: <input type=\"password\" name=\"password\" required></li>\n         form = DateTimeForm({'dt': '2006-10-25 14:30:45'})\n         self.assertEqual(form.changed_data, [])\n \n+    def test_datetime_clean_fields_bound_field(self):\n+        \"\"\"\n+        Verify that _clean_fields() accesses values consistently through BoundField.\n+        \"\"\"\n+        now = datetime.datetime(2006, 10, 25, 14, 30, 45)\n+\n+        class DateTimeForm(forms.Form):\n+            dt = DateTimeField(initial=lambda: now, disabled=True)\n+\n+        form = DateTimeForm({})\n+        cleaned = form.cleaned_data['dt']\n+        bf = form['dt']\n+        self.assertEqual(cleaned, bf.initial)\n+\n+    def test_datetime_changed_data_bound_field(self):\n+        \"\"\"\n+        Verify that changed_data accesses values through BoundField and reflects changes.\n+        \"\"\"\n+        class DateTimeForm(forms.Form):\n+            dt = DateTimeField(initial=lambda: datetime.datetime(2006, 10, 25, 14, 30, 45), disabled=False)\n+\n+        form = DateTimeForm({'dt': '2006-10-25 14:30:46'})\n+        changed = form.changed_data\n+        self.assertIn('dt', changed)\n+\n     def test_help_text(self):\n         # You can specify descriptive text for a field by using the 'help_text' argument)\n         class UserRegistration(Form):\n",
  "django__django-14672": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex d9eaabe..3ed4c93 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -1,8 +1,36 @@\n from datetime import date, datetime, timedelta\n from operator import attrgetter\n \n+class ThroughFieldsHashableTest(TestCase):\n+    def test_m2m_with_through_fields_hashability(self):\n+        class Parent(Model):\n+            name = CharField(max_length=256)\n+\n+        class ProxyParent(Parent):\n+            class Meta:\n+                proxy = True\n+\n+        class Child(Model):\n+            parent = ForeignKey(Parent, on_delete=CASCADE)\n+            many_to_many_field = ManyToManyField(\n+                to=Parent,\n+                through=\"ManyToManyModel\",\n+                through_fields=['child', 'parent'],\n+                related_name=\"something\"\n+            )\n+        \n+        class ManyToManyModel(Model):\n+            parent = ForeignKey(Parent, on_delete=CASCADE, related_name='+')\n+            child = ForeignKey(Child, on_delete=CASCADE, related_name='+')\n+            second_child = ForeignKey(Child, on_delete=CASCADE, null=True, default=None)\n+        \n+        # No errors should be raised due to hashability issues\n+        self.assertEqual(Child.check(), [])\n+\n from django.db import IntegrityError\n-from django.test import TestCase\n+from django.core.exceptions import ValidationError\n+from django.db.models import Model, ForeignKey, CharField, CASCADE, ManyToManyField\n+from django.core.checks import Error\n \n from .models import (\n     CustomMembership, Employee, Event, Friendship, Group, Ingredient,\n",
  "django__django-14752": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex 7ef6d86..19f53b8 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -1,3 +1,4 @@\n+\n import json\n from contextlib import contextmanager\n \n@@ -10,6 +11,12 @@ from django.core.exceptions import PermissionDenied\n from django.http import Http404\n from django.test import RequestFactory, override_settings\n from django.urls import reverse, reverse_lazy\n+import datetime\n+\n+# Import necessary models and views for testing\n+from .models import Question\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+from django.test import TestCase\n \n from .admin import AnswerAdmin, QuestionAdmin\n from .models import (\n",
  "django__django-14765": "diff --git a/tests/migrations/test_state.py b/tests/migrations/test_state.py\nindex 11009e5..fb4d748 100644\n--- a/tests/migrations/test_state.py\n+++ b/tests/migrations/test_state.py\n@@ -923,8 +923,27 @@ class StateTests(SimpleTestCase):\n             len([x for x in rendered_state.get_models() if x._meta.app_label == \"migrations\"]),\n             1,\n         )\n-\n-    def test_ignore_order_wrt(self):\n+    def test_real_apps_non_set(self):\n+        \"\"\"\n+        Test that passing a non-set for real_apps raises an AssertionError.\n+        \"\"\"\n+        with self.assertRaises(AssertionError):\n+            ProjectState(real_apps=['contenttypes'])\n+            \n+    def test_real_apps_none(self):\n+        \"\"\"\n+        Test that passing None for real_apps defaults to an empty set.\n+        \"\"\"\n+        state = ProjectState(real_apps=None)\n+        self.assertEqual(state.real_apps, set())\n+        \n+    def test_real_apps_set(self):\n+        \"\"\"\n+        Test that passing a set for real_apps is accepted and used as is.\n+        \"\"\"\n+        real_apps_set = {'contenttypes', 'auth'}\n+        state = ProjectState(real_apps=real_apps_set)\n+        self.assertEqual(state.real_apps, real_apps_set)\n         \"\"\"\n         Makes sure ProjectState doesn't include OrderWrt fields when\n         making from existing models.\n",
  "django__django-14771": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 1875424..9609864 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -235,6 +235,51 @@ class TestChildArguments(SimpleTestCase):\n         with self.assertRaisesMessage(RuntimeError, msg):\n             autoreload.get_child_arguments()\n \n+    @mock.patch('sys.argv', [__file__, 'runserver'])\n+    @mock.patch('sys._xoptions', {'utf8': True, 'custom': 'value'})\n+    @mock.patch('sys.warnoptions', [])\n+    def test_xoptions_in_child_arguments(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-Xutf8', '-Xcustom=value', __file__, 'runserver']\n+        )\n+\n+    @mock.patch('sys.argv', [__file__, 'runserver'])\n+    @mock.patch('sys._xoptions', {})\n+    @mock.patch('sys.warnoptions', [])\n+    def test_no_xoptions_in_child_arguments(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, __file__, 'runserver']\n+        )\n+\n+    @mock.patch('sys.argv', [__file__, 'runserver'])\n+    @mock.patch('sys._xoptions', {'utf8': True})\n+    @mock.patch('sys.warnoptions', [])\n+    def test_single_xoption_in_child_arguments(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-Xutf8', __file__, 'runserver']\n+        )\n+        \n+    @mock.patch('sys.argv', [__file__, 'runserver'])\n+    @mock.patch('sys._xoptions', {'a': 'b', 'c': 'd', 'e': 'f'})\n+    @mock.patch('sys.warnoptions', [])\n+    def test_multiple_xoptions_in_child_arguments(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-Xa=b', '-Xc=d', '-Xe=f', __file__, 'runserver']\n+        )\n+        \n+    @mock.patch('sys.argv', [__file__, 'runserver'])\n+    @mock.patch('sys._xoptions', {'name': 'value'})\n+    @mock.patch('sys.warnoptions', [])\n+    def test_single_named_xoption_in_child_arguments(self):\n+        self.assertEqual(\n+            autoreload.get_child_arguments(),\n+            [sys.executable, '-Xname=value', __file__, 'runserver']\n+        )\n+\n     @mock.patch('sys.argv', [__file__, 'runserver'])\n     @mock.patch('sys.warnoptions', [])\n     def test_module_no_spec(self):\n@@ -246,7 +291,6 @@ class TestChildArguments(SimpleTestCase):\n                 [sys.executable, __file__, 'runserver']\n             )\n \n-\n class TestUtilities(SimpleTestCase):\n     def test_is_django_module(self):\n         for module, expected in (\n",
  "django__django-14787": "",
  "django__django-14855": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 507855b..37b947f 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -5093,7 +5093,37 @@ class ReadonlyTest(AdminFieldExtractionMixin, TestCase):\n         response = self.client.get(reverse('admin:admin_views_choice_change', args=(choice.pk,)))\n         self.assertContains(response, '<div class=\"readonly\">No opinion</div>', html=True)\n \n-    def test_readonly_foreignkey_links(self):\n+    def _test_readonly_foreignkey_links(self, admin_site):\n+        \"\"\"\n+        Helper method to test ForeignKey readonly fields render as links with the correct admin site prefix.\n+        \"\"\"\n+        chapter = Chapter.objects.create(\n+            title='Chapter 1',\n+            content='content',\n+            book=Book.objects.create(name='Book 1'),\n+        )\n+        language = Language.objects.create(iso='_40', name='Test')\n+        response = self.client.get(reverse(f'{admin_site}:admin_views_chapter_change', args=(chapter.pk,)))\n+        language_url = reverse(f'{admin_site}:admin_views_language_change', args=(quote(language.pk),))\n+        self.assertContains(\n+            response,\n+            '<div class=\"readonly\"><a href=\"%s\">_40</a></div>' % language_url,\n+            html=True,\n+        )\n+        # Related ForeignKey object not registered in admin.\n+        self.assertContains(response, '<div class=\"readonly\">Chapter 1</div>', html=True)\n+\n+    def test_readonly_foreignkey_links_default_admin_site(self):\n+        \"\"\"\n+        Test that the default admin site generates the correct URL for readonly ForeignKey fields.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('admin')\n+\n+    def test_readonly_foreignkey_links_custom_admin_site(self):\n+        \"\"\"\n+        Test that the custom admin site generates the correct URL for readonly ForeignKey fields.\n+        \"\"\"\n+        self._test_readonly_foreignkey_links('namespaced_admin')\n         \"\"\"\n         ForeignKey readonly fields render as links if the target model is\n         registered in admin.\n",
  "django__django-14915": "",
  "django__django-14999": "",
  "django__django-15022": "",
  "django__django-15037": "",
  "django__django-15103": "diff --git a/tests/template_tests/filter_tests/test_json_script.py b/tests/template_tests/filter_tests/test_json_script.py\nindex 607e24c..7b85db4 100644\n--- a/tests/template_tests/filter_tests/test_json_script.py\n+++ b/tests/template_tests/filter_tests/test_json_script.py\n@@ -1,3 +1,4 @@\n+\n from django.test import SimpleTestCase\n \n from ..utils import setup\n@@ -6,6 +7,11 @@ from ..utils import setup\n class JsonScriptTests(SimpleTestCase):\n \n     @setup({'json-tag01': '{{ value|json_script:\"test_id\" }}'})\n+    @setup({'json-tag02-no-id': '{{ value|json_script }}'})\n+    def test_without_id(self):\n+        output = self.engine.render_to_string('json-tag02-no-id', {'value': {}})\n+        self.assertEqual(output, '<script type=\"application/json\">{}</script>')\n+\n     def test_basic(self):\n         output = self.engine.render_to_string(\n             'json-tag01',\n@@ -16,4 +22,4 @@ class JsonScriptTests(SimpleTestCase):\n             '<script id=\"test_id\" type=\"application/json\">'\n             '{\"a\": \"testing\\\\r\\\\njson \\'string\\\\\" \\\\u003Cb\\\\u003Eescaping\\\\u003C/b\\\\u003E\"}'\n             '</script>'\n-        )\n+        )\n",
  "django__django-15104": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex 04452fa..57aac82 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -2835,7 +2835,25 @@ class AutodetectorTests(TestCase):\n                 )\n \n \n-class MigrationSuggestNameTests(SimpleTestCase):\n+class ReproIssueTestCase(TestCase):\n+    def test_custom_fk_with_hardcoded_to(self):\n+        class HardcodedForeignKey(models.ForeignKey):\n+            def __init__(self, *args, **kwargs):\n+                kwargs['to'] = 'testapp.HardcodedModel'\n+                super().__init__(*args, **kwargs)\n+\n+            def deconstruct(self):\n+                name, path, args, kwargs = super().deconstruct()\n+                del kwargs['to']\n+                return name, path, args, kwargs\n+\n+        before = ProjectState()\n+        before.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        after = ProjectState()\n+        after.add_model(ModelState('testapp', 'HardcodedModel', []))\n+        after.add_model(ModelState('testapp', 'TestModel', [('custom', HardcodedForeignKey(on_delete=models.CASCADE))]))\n+        changes = MigrationAutodetector(before, after)._detect_changes()\n+        self.assertEqual(len(changes['testapp']), 1)\n     def test_no_operations(self):\n         class Migration(migrations.Migration):\n             operations = []\n",
  "django__django-15127": "",
  "django__django-15128": "",
  "django__django-15161": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 5fdccc5..5cca52a 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1760,6 +1760,30 @@ class ValueTests(TestCase):\n         UUID.objects.update(uuid=Value(uuid.UUID('12345678901234567890123456789012'), output_field=UUIDField()))\n         self.assertEqual(UUID.objects.get().uuid, uuid.UUID('12345678901234567890123456789012'))\n \n+    def test_deconstruct_F_expression(self):\n+        # Test the deconstruction of the F expression to ensure the path is simplified\n+        f_expr = F('field_name')\n+        path, args, kwargs = f_expr.deconstruct()\n+        self.assertEqual(path, 'django.db.models.F')\n+        self.assertEqual(args, (f_expr.name,))\n+        self.assertEqual(kwargs, {})\n+\n+    def test_deconstruct_OrderBy_expression(self):\n+        # Test the deconstruction of the OrderBy expression\n+        order_by_expr = OrderBy(F('field_name').desc())\n+        path, args, kwargs = order_by_expr.deconstruct()\n+        self.assertEqual(path, 'django.db.models.OrderBy')\n+        self.assertEqual(len(args), 1)\n+        self.assertEqual(kwargs, {'descending': True})\n+\n+    def test_deconstruct_ExpressionWrapper(self):\n+        # Test the deconstruction of the ExpressionWrapper\n+        expression = ExpressionWrapper(F('field_name'), output_field=IntegerField())\n+        path, args, kwargs = expression.deconstruct()\n+        self.assertEqual(path, 'django.db.models.ExpressionWrapper')\n+        self.assertEqual(len(args), 1)\n+        self.assertEqual(kwargs['output_field'].deconstruct(), IntegerField().deconstruct())\n+\n     def test_deconstruct(self):\n         value = Value('name')\n         path, args, kwargs = value.deconstruct()\n",
  "django__django-15268": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex a6c0858..b2669b2 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -1591,7 +1591,26 @@ class AutodetectorTests(TestCase):\n             index_together={('title', 'author')},\n         )\n \n-    def test_add_field_and_foo_together(self):\n+    def test_optimize_foo_together_operations(self):\n+        \"\"\"\n+        Test the optimizer's ability to merge consecutive AlterFooTogether operations.\n+        \"\"\"\n+        changes = self.get_changes(\n+            [self.author_empty, self.book],\n+            [self.author_empty, self.book_foo_together_optimized]\n+        )\n+        # Ensure the optimizer combines the operations into one step per constraint type.\n+        self.assertNumberMigrations(changes, \"otherapp\", 1)\n+        self.assertOperationTypes(changes, 'otherapp', 0, [\n+            'AlterUniqueTogether',\n+            'AlterIndexTogether',\n+        ])\n+        self.assertOperationAttributes(\n+            changes, 'otherapp', 0, 0, name='book', unique_together={('title', 'author')}\n+        )\n+        self.assertOperationAttributes(\n+            changes, 'otherapp', 0, 1, name='book', index_together={('title', 'author')}\n+        )\n         \"\"\"\n         Added fields will be created before using them in index/unique_together.\n         \"\"\"\n",
  "django__django-15277": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 11f86ed..4d26562 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1847,6 +1847,35 @@ class ValueTests(TestCase):\n                 expr = Value(value)\n                 self.assertIsInstance(expr.output_field, output_field_type)\n \n+    def test_output_field_does_not_create_broken_validators(self):\n+        \"\"\"\n+        The output field for a given Value doesn't get cleaned & validated,\n+        however validators may still be instantiated for a given field type\n+        and this demonstrates that they don't throw an exception.\n+        \"\"\"\n+        import datetime\n+        from decimal import Decimal\n+        import uuid\n+        from django.db.models import Value\n+\n+        value_types = [\n+            'str',\n+            True,\n+            42,\n+            3.14,\n+            datetime.date(2019, 5, 15),\n+            datetime.datetime(2019, 5, 15),\n+            datetime.time(3, 16),\n+            datetime.timedelta(1),\n+            Decimal('3.14'),\n+            b'',\n+            uuid.uuid4(),\n+        ]\n+        for value in value_types:\n+            with self.subTest(type=type(value)):\n+                field = Value(value)._resolve_output_field()\n+                field.clean(value, model_instance=None)\n+\n     def test_resolve_output_field_failure(self):\n         msg = 'Cannot resolve expression type, unknown output_field'\n         with self.assertRaisesMessage(FieldError, msg):\n",
  "django__django-15278": "diff --git a/tests/schema/tests.py b/tests/schema/tests.py\nindex dd02aee..72672e1 100644\n--- a/tests/schema/tests.py\n+++ b/tests/schema/tests.py\n@@ -618,7 +618,33 @@ class SchemaTests(TransactionTestCase):\n         with connection.schema_editor() as editor:\n             editor.add_field(Author, new_field)\n         # Ensure the field is there\n+from django.db import connection\n+from django.db.models import CASCADE, OneToOneField\n+from django.test import TestCase\n+\n+class SchemaTests(TestCase):\n+    def test_add_nullable_one_to_one_field(self):\n+        \"\"\"\n+        Test adding a nullable OneToOneField to a model on SQLite to ensure\n+        the migration is handled without errors related to unique constraints.\n+        \"\"\"\n+        # Create the initial model schema\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+            editor.create_model(Note)\n+\n+        # Define a new nullable OneToOneField\n+        new_field = OneToOneField(Note, CASCADE, null=True)\n+        new_field.set_attributes_from_name('note')\n+\n+        # Add the new field using the schema editor\n+        with connection.schema_editor() as editor:\n+            editor.add_field(Author, new_field)\n+\n+        # Verify the field was added successfully\n         columns = self.column_classes(Author)\n+        self.assertIn('note_id', columns)\n+        self.assertTrue(columns['note_id'][1][6])  # Ensures the field is nullable\n         field_type, field_info = columns['thing']\n         self.assertEqual(field_type, connection.features.introspected_field_types['IntegerField'])\n         # Make sure the values were transformed correctly\n@@ -636,7 +662,33 @@ class SchemaTests(TransactionTestCase):\n         new_field.set_attributes_from_name(\"bits\")\n         with connection.schema_editor() as editor:\n             editor.add_field(Author, new_field)\n+from django.db import connection\n+from django.db.models import CASCADE, OneToOneField\n+from django.test import TestCase\n+\n+class SchemaTests(TestCase):\n+    def test_add_nullable_one_to_one_field(self):\n+        \"\"\"\n+        Test adding a nullable OneToOneField to a model on SQLite to ensure\n+        the migration is handled without errors related to unique constraints.\n+        \"\"\"\n+        # Create the initial model schema\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+            editor.create_model(Note)\n+\n+        # Define a new nullable OneToOneField\n+        new_field = OneToOneField(Note, CASCADE, null=True)\n+        new_field.set_attributes_from_name('note')\n+\n+        # Add the new field using the schema editor\n+        with connection.schema_editor() as editor:\n+            editor.add_field(Author, new_field)\n+\n+        # Verify the field was added successfully\n         columns = self.column_classes(Author)\n+        self.assertIn('note_id', columns)\n+        self.assertTrue(columns['note_id'][1][6])  # Ensures the field is nullable\n         # MySQL annoyingly uses the same backend, so it'll come back as one of\n         # these two types.\n         self.assertIn(columns['bits'][0], (\"BinaryField\", \"TextField\"))\n",
  "django__django-15315": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex e4daf0e..b3f959c 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -61,7 +61,53 @@ class BasicFieldTests(SimpleTestCase):\n \n         self.assertEqual(m._meta.get_field('id').verbose_name, 'verbose pk')\n \n-    def test_choices_form_class(self):\n+    def test_hash_immutability(self):\n+        \"\"\"\n+        Test that the hash of a Field instance does not change\n+        after it is assigned to a model class.\n+        \"\"\"\n+        field = models.CharField(max_length=200)\n+        initial_hash = hash(field)\n+        \n+        # Ensure the hash remains the same before model assignment\n+        self.assertEqual(initial_hash, hash(field))\n+\n+        class MyModel(models.Model):\n+            title = field\n+        \n+        # Check the hash again after assignment to the model\n+        self.assertEqual(initial_hash, hash(field))\n+\n+    def test_hash_unchanged_for_multiple_fields(self):\n+        \"\"\"\n+        Test hash immutability for multiple fields being assigned to a model.\n+        \"\"\"\n+        field1 = models.CharField(max_length=200)\n+        field2 = models.IntegerField()\n+        field1_initial_hash = hash(field1)\n+        field2_initial_hash = hash(field2)\n+\n+        class MyModel(models.Model):\n+            title = field1\n+            rank = field2\n+\n+        self.assertEqual(field1_initial_hash, hash(field1))\n+        self.assertEqual(field2_initial_hash, hash(field2))\n+\n+    def test_hash_dict_usage(self):\n+        \"\"\"\n+        Ensure that a field can be used as a key in a dictionary\n+        and does not break after being assigned to a model class.\n+        \"\"\"\n+        field = models.CharField(max_length=200)\n+        d = {field: 'value'}\n+        self.assertIn(field, d)\n+\n+        class MyModel(models.Model):\n+            title = field\n+        \n+        # Check if the previously created dictionary still contains the field\n+        self.assertIn(field, d)\n         \"\"\"Can supply a custom choices form class to Field.formfield()\"\"\"\n         choices = [('a', 'a')]\n         field = models.CharField(choices=choices)\n",
  "django__django-15368": "diff --git a/tests/queries/test_bulk_update.py b/tests/queries/test_bulk_update.py\nindex 447c150..8fa1df1 100644\n--- a/tests/queries/test_bulk_update.py\n+++ b/tests/queries/test_bulk_update.py\n@@ -211,7 +211,19 @@ class BulkUpdateTests(TestCase):\n         Number.objects.bulk_update(numbers, ['num'])\n         self.assertCountEqual(Number.objects.filter(num=1), numbers)\n \n-    def test_booleanfield(self):\n+    def test_f_expression_with_bulk_update(self):\n+        # Create test instances\n+        instances = [Number.objects.create(num=i) for i in range(10)]\n+        \n+        # Update with F() expression\n+        for instance in instances:\n+            instance.num = F('num') + 1\n+        Number.objects.bulk_update(instances, ['num'])\n+\n+        # Verify that the update was successful\n+        for i, instance in enumerate(instances):\n+            instance.refresh_from_db()\n+            self.assertEqual(instance.num, i + 1)\n         individuals = [Individual.objects.create(alive=False) for _ in range(10)]\n         for individual in individuals:\n             individual.alive = True\n",
  "django__django-15380": "diff --git a/tests/migrations/test_autodetector.py b/tests/migrations/test_autodetector.py\nindex e2de333..71bab1a 100644\n--- a/tests/migrations/test_autodetector.py\n+++ b/tests/migrations/test_autodetector.py\n@@ -1049,7 +1049,30 @@ class AutodetectorTests(TestCase):\n             new_name='renamed_foo',\n         )\n \n-    def test_rename_model(self):\n+    def test_rename_model_and_field_together(self):\n+        \"\"\"Tests autodetection of renaming a model and a field simultaneously.\"\"\"\n+        changes = self.get_changes(\n+            [self.author_name],\n+            [\n+                ModelState('testapp', 'RenamedAuthor', [\n+                    ('id', models.AutoField(primary_key=True)),\n+                    ('renamed_name', models.CharField(max_length=200)),\n+                ]),\n+            ],\n+            MigrationQuestioner({'ask_rename_model': True, 'ask_rename': True}),\n+        )\n+        # Check that one migration is generated\n+        self.assertNumberMigrations(changes, 'testapp', 1)\n+        # Check that the operations are RenameModel and RenameField\n+        self.assertOperationTypes(changes, 'testapp', 0, ['RenameModel', 'RenameField'])\n+        # Check attributes of RenameModel operation\n+        self.assertOperationAttributes(\n+            changes, 'testapp', 0, 0, old_name='Author', new_name='RenamedAuthor',\n+        )\n+        # Check attributes of RenameField operation\n+        self.assertOperationAttributes(\n+            changes, 'testapp', 0, 1, old_name='name', new_name='renamed_name',\n+        )\n         \"\"\"Tests autodetection of renamed models.\"\"\"\n         changes = self.get_changes(\n             [self.author_with_book, self.book],\n",
  "django__django-15382": "",
  "django__django-15467": "diff --git a/tests/admin_widgets/tests.py b/tests/admin_widgets/tests.py\nindex f5af59b..93e493f 100644\n--- a/tests/admin_widgets/tests.py\n+++ b/tests/admin_widgets/tests.py\n@@ -10,6 +10,10 @@ except ImportError:\n     from backports import zoneinfo\n \n from django import forms\n+from django.db import models\n+from django.contrib import admin\n+from django.test import TestCase\n+from django.utils.translation import gettext as _\n from django.conf import settings\n from django.contrib import admin\n from django.contrib.admin import widgets\n@@ -132,7 +136,25 @@ class AdminFormfieldForDBFieldTests(SimpleTestCase):\n             raw_id_fields=[\"main_band\"],\n         )\n \n-    def test_radio_fields_ForeignKey(self):\n+    def test_radio_fields_foreignkey_custom_empty_label(self):\n+        class Parent(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+\n+        class ChildAdmin(admin.ModelAdmin):\n+            radio_fields = {\"parent\": admin.VERTICAL}\n+\n+            def formfield_for_foreignkey(self, db_field, request, **kwargs):\n+                if db_field.name == \"parent\":\n+                    kwargs[\"empty_label\"] = \"Custom empty label\"\n+                return super().formfield_for_foreignkey(db_field, request, **kwargs)\n+\n+        parent_field = Child._meta.get_field(\"parent\")\n+        ma = ChildAdmin(Child, admin.site)\n+        formfield = ma.formfield_for_dbfield(parent_field, request=None)\n+        self.assertEqual(formfield.empty_label, \"Custom empty label\")\n         ff = self.assertFormfield(\n             Event,\n             \"main_band\",\n",
  "django__django-15499": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 5df1b06..39456d4 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -129,6 +129,60 @@ class OptimizerTests(SimpleTestCase):\n             ],\n         )\n \n+    def test_create_model_alter_managers_kept(self):\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\"Bar\", fields=[]),\n+                migrations.AlterModelManagers(\n+                    name=\"Bar\",\n+                    managers=[\n+                        (\"custom\", models.Manager()),\n+                    ],\n+                ),\n+            ],\n+            [\n+                migrations.CreateModel(\n+                    \"Bar\",\n+                    fields=[],\n+                    managers=[\n+                        (\"custom\", models.Manager()),\n+                    ],\n+                ),\n+            ],\n+            [\n+                migrations.CreateModel(\n+                    \"Foo\", fields=[], options={\"verbose_name_plural\": \"Foozes\"}\n+                ),\n+            ],\n+            [\n+                migrations.CreateModel(\n+                    \"Foo\", fields=[], options={\"verbose_name_plural\": \"Foozes\"}\n+                ),\n+            ],\n+        )\n+\n+    def test_create_model_alter_managers_kept(self):\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\"Bar\", fields=[]),\n+                migrations.AlterModelManagers(\n+                    name=\"Bar\",\n+                    managers=[\n+                        (\"custom\", models.Manager()),\n+                    ],\n+                ),\n+            ],\n+            [\n+                migrations.CreateModel(\n+                    \"Bar\",\n+                    fields=[],\n+                    managers=[\n+                        (\"custom\", models.Manager()),\n+                    ],\n+                ),\n+            ],\n+        )\n+\n     def test_create_model_and_remove_model_options(self):\n         self.assertOptimizesTo(\n             [\n@@ -137,6 +191,33 @@ class OptimizerTests(SimpleTestCase):\n                     fields=[],\n                     options={\"verbose_name\": \"My Model\"},\n                 ),\n+            ],\n+            [\n+                migrations.CreateModel(\n+                    \"Foo\", fields=[], options={\"verbose_name_plural\": \"Foozes\"}\n+                ),\n+            ],\n+        )\n+\n+    def test_create_model_alter_managers_kept(self):\n+        self.assertOptimizesTo(\n+            [\n+                migrations.CreateModel(\"Bar\", fields=[]),\n+                migrations.AlterModelManagers(\n+                    name=\"Bar\",\n+                    managers=[\n+                        (\"custom\", models.Manager()),\n+                    ],\n+                ),\n+            ],\n+            [\n+                migrations.CreateModel(\n+                    \"Bar\",\n+                    fields=[],\n+                    managers=[\n+                        (\"custom\", models.Manager()),\n+                    ],\n+                ),\n                 migrations.AlterModelOptions(\"MyModel\", options={}),\n             ],\n             [migrations.CreateModel(\"MyModel\", fields=[])],\n",
  "django__django-15525": "diff --git a/tests/fixtures_regress/tests.py b/tests/fixtures_regress/tests.py\nindex 3640e99..a5b97b7 100644\n--- a/tests/fixtures_regress/tests.py\n+++ b/tests/fixtures_regress/tests.py\n@@ -791,7 +791,26 @@ class NaturalKeyFixtureTests(TestCase):\n         )\n \n \n-class M2MNaturalKeyFixtureTests(TestCase):\n+class NaturalKeyFixtureOnOtherDatabaseTests(TestCase):\n+    databases = {'default', 'other'}\n+\n+    def test_natural_key_dependencies(self):\n+        \"\"\"\n+        Natural keys with foreign key dependencies should work in a multiple\n+        database setup.\n+        \"\"\"\n+        # Load the fixture into the 'other' database\n+        management.call_command(\n+            'loaddata',\n+            'testbug_nk_fixture.json',\n+            database='other',\n+            verbosity=0\n+        )\n+\n+        # Retrieve the Book instance using the 'other' database\n+        obj = Book.objects.using('other').get(title=\"The Ring\")\n+        self.assertEqual(obj.title, \"The Ring\")\n+        self.assertEqual(obj.author.name, \"JR Tolkien\")\n     \"\"\"Tests for ticket #14426.\"\"\"\n \n     def test_dependency_sorting_m2m_simple(self):\n",
  "django__django-15561": "diff --git a/tests/schema/tests.py b/tests/schema/tests.py\nindex b8137da..0c23c9f 100644\n--- a/tests/schema/tests.py\n+++ b/tests/schema/tests.py\n@@ -3955,6 +3955,32 @@ class SchemaTests(TransactionTestCase):\n             validators=[lambda x: x],\n             verbose_name=\"verbose name\",\n         )\n+\n+    def test_alter_field_choices_noop(self):\n+        \"\"\"\n+        Test that altering a field to add/change choices does not execute \n+        any SQL on the SQLite backend.\n+        \"\"\"\n+        with connection.schema_editor() as editor:\n+            editor.create_model(Author)\n+        \n+        # Original field with no choices\n+        old_field = Author._meta.get_field(\"name\")\n+        \n+        # New field with choices added\n+        new_field = CharField(\n+            choices=((\"Jane\", \"Jane\"), (\"Joe\", \"Joe\")),\n+            max_length=255,\n+        )\n+        new_field.set_attributes_from_name(\"name\")\n+        \n+        # Check that altering the field does not result in any queries\n+        with connection.schema_editor() as editor, self.assertNumQueries(0):\n+            editor.alter_field(Author, old_field, new_field, strict=True)\n+        \n+        # Check that reverting the field to the old state also results in no queries\n+        with connection.schema_editor() as editor, self.assertNumQueries(0):\n+            editor.alter_field(Author, new_field, old_field, strict=True)\n         new_field.set_attributes_from_name(\"author\")\n         with connection.schema_editor() as editor, self.assertNumQueries(0):\n             editor.alter_field(Book, old_field, new_field, strict=True)\n",
  "django__django-15569": "diff --git a/tests/custom_lookups/tests.py b/tests/custom_lookups/tests.py\nindex 74c331a..46b89b9 100644\n--- a/tests/custom_lookups/tests.py\n+++ b/tests/custom_lookups/tests.py\n@@ -312,7 +312,16 @@ class LookupTests(TestCase):\n         with register_lookup(models.Field, Exactly):\n             self.assertIsNone(field.get_lookup(\"exactly\"))\n \n-    def test_lookups_caching(self):\n+    def test_unregistration_clears_cache(self):\n+        field = Article._meta.get_field(\"author\")\n+\n+        # Register a lookup and verify it's cached\n+        with register_lookup(models.ForeignObject, Exactly):\n+            self.assertIn(\"exactly\", field.get_lookups())\n+\n+        # Unregister the lookup and verify cache is cleared\n+        models.ForeignObject._unregister_lookup(Exactly)\n+        self.assertNotIn(\"exactly\", field.get_lookups())\n         field = Article._meta.get_field(\"author\")\n \n         # clear and re-cache\n",
  "django__django-15572": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex 188dca4..e42c9b5 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -92,7 +92,34 @@ class TemplateReloadTests(SimpleTestCase):\n                 \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n             }\n         ]\n+    )  \n+    def test_template_dirs_ignore_empty_path(self):\n+        self.assertEqual(autoreload.get_template_directories(), set())\n+\n+    @override_settings(\n+        TEMPLATES=[\n+            {\n+                \"DIRS\": [\"\", str(ROOT) + \"/valid_dir\"],\n+                \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n+            }\n+        ]\n+    )\n+    def test_template_dirs_mixed_with_empty_path(self):\n+        # Check that the empty string is ignored and only the valid directory is returned\n+        expected_dirs = {Path.cwd() / to_path(str(ROOT) + \"/valid_dir\")}\n+        self.assertSetEqual(autoreload.get_template_directories(), expected_dirs)\n+\n+    @override_settings(\n+        TEMPLATES=[\n+            {\n+                \"DIRS\": [\"\", \"\", \"\"],\n+                \"BACKEND\": \"django.template.backends.django.DjangoTemplates\",\n+            }\n+        ]\n     )\n+    def test_template_dirs_all_empty_paths(self):\n+        # Check that all empty strings are ignored\n+        self.assertSetEqual(autoreload.get_template_directories(), set())\n     def test_template_dirs_normalized_to_paths(self):\n         self.assertSetEqual(\n             autoreload.get_template_directories(),\n",
  "django__django-15731": "diff --git a/tests/basic/tests.py b/tests/basic/tests.py\nindex 902f114..e3f4f1b 100644\n--- a/tests/basic/tests.py\n+++ b/tests/basic/tests.py\n@@ -1,3 +1,4 @@\n+\n import threading\n from datetime import datetime, timedelta\n from unittest import mock\n@@ -724,7 +725,27 @@ class ManagerTest(SimpleTestCase):\n \n     def test_manager_methods(self):\n         \"\"\"\n-        This test ensures that the correct set of methods from `QuerySet`\n+\n+    def test_manager_method_signature(self):\n+        # Verify the signature for bulk_create method is correctly reported\n+        self.assertEqual(\n+            str(inspect.signature(Article.objects.bulk_create)),\n+            \"(objs, batch_size=None, ignore_conflicts=False, update_conflicts=False, update_fields=None, unique_fields=None)\"\n+        )\n+\n+    def test_manager_method_docstring(self):\n+        # Verify the docstring is correctly copied from QuerySet to the Manager\n+        self.assertEqual(\n+            Article.objects.bulk_create.__doc__, \n+            models.QuerySet.bulk_create.__doc__\n+        )\n+\n+    def test_manager_method_name(self):\n+        # Verify the method name is correctly copied\n+        self.assertEqual(\n+            Article.objects.bulk_create.__name__,\n+            models.QuerySet.bulk_create.__name__\n+        )\n         are copied onto `Manager`.\n \n         It's particularly useful to prevent accidentally leaking new methods\n",
  "django__django-15741": "diff --git a/tests/template_tests/filter_tests/test_date.py b/tests/template_tests/filter_tests/test_date.py\nindex c6dbc53..a4cac61 100644\n--- a/tests/template_tests/filter_tests/test_date.py\n+++ b/tests/template_tests/filter_tests/test_date.py\n@@ -1,6 +1,9 @@\n+\n from datetime import datetime, time\n \n from django.template.defaultfilters import date\n+from django.utils.translation import gettext_lazy\n+from django.utils.formats import get_format\n from django.test import SimpleTestCase\n from django.utils import timezone, translation\n \n@@ -73,6 +76,15 @@ class DateTests(TimezoneTestCase):\n         self.assertEqual(output, \"00:00\")\n \n \n+class LazyDateTests(SimpleTestCase):\n+    def test_get_format_with_lazy_date_format(self):\n+        self.assertEqual(get_format(gettext_lazy(\"DATE_FORMAT\")), \"N j, Y\")\n+\n+    @setup({\"datelazy\": '{{ t|date:_(\"H:i\") }}'})\n+    def test_date_lazy(self):\n+        output = self.engine.render_to_string(\"datelazy\", {\"t\": time(0, 0)})\n+        self.assertEqual(output, \"00:00\")\n+\n class FunctionTests(SimpleTestCase):\n     def test_date(self):\n         self.assertEqual(date(datetime(2005, 12, 29), \"d F Y\"), \"29 December 2005\")\n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..4e9a46b 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -398,6 +398,31 @@ class ProxyModelTests(TestCase):\n     def test_eq(self):\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n+    def test_select_related_only_with_proxy_model(self):\n+        # Set up data\n+        custom = ProxyCustomModel.objects.create(name=\"Test Name\")\n+        another_instance = AnotherModel.objects.create(custom=custom)\n+\n+        # Perform the query that previously caused a crash\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+\n+        # Verify the query executes without error and returns expected results\n+        result = qs.get()\n+        self.assertEqual(result, another_instance)\n+        self.assertEqual(result.custom.name, \"Test Name\")\n+\n+    def test_select_related_only_with_no_fields(self):\n+        # Set up data\n+        custom = ProxyCustomModel.objects.create(name=\"Another Name\")\n+        AnotherModel.objects.create(custom=custom)\n+\n+        # Perform a query with no fields specified in only()\n+        qs = AnotherModel.objects.select_related(\"custom\").only()\n+\n+        # Verify the query executes without error\n+        result = qs.get()\n+        self.assertEqual(result.custom.name, \"Another Name\")\n+\n \n @override_settings(ROOT_URLCONF=\"proxy_models.urls\")\n class ProxyModelAdminTests(TestCase):\n",
  "django__django-15851": "",
  "django__django-15863": "diff --git a/tests/template_tests/filter_tests/test_floatformat.py b/tests/template_tests/filter_tests/test_floatformat.py\nindex 08f08e1..4cfba62 100644\n--- a/tests/template_tests/filter_tests/test_floatformat.py\n+++ b/tests/template_tests/filter_tests/test_floatformat.py\n@@ -31,6 +31,40 @@ class FloatformatTests(SimpleTestCase):\n         self.assertEqual(output, \"1.4 1.4\")\n \n \n+from decimal import Decimal\n+from django.test import SimpleTestCase\n+from django.utils.translation import override\n+from django.template.defaultfilters import floatformat\n+\n+class DecimalPrecisionTests(SimpleTestCase):\n+    def test_decimal_high_precision(self):\n+        # Test with high precision Decimal\n+        self.assertEqual(\n+            floatformat(Decimal(\"123456.123456789012345678901\"), 21),\n+            \"123456.123456789012345678901\"\n+        )\n+\n+    def test_decimal_rounding(self):\n+        # Test with rounding behavior\n+        self.assertEqual(\n+            floatformat(Decimal(\"42.12345678901234567890\"), 20),\n+            \"42.12345678901234567890\"\n+        )\n+\n+    def test_decimal_zeros(self):\n+        # Test with trailing zeros\n+        self.assertEqual(\n+            floatformat(Decimal(\"1.23000\"), 5),\n+            \"1.23000\"\n+        )\n+\n+    def test_decimal_no_precision(self):\n+        # Test with no precision specified\n+        self.assertEqual(\n+            floatformat(Decimal(\"12345.6789\")),\n+            \"12345.7\"\n+        )\n+\n class FunctionTests(SimpleTestCase):\n     def test_inputs(self):\n         self.assertEqual(floatformat(7.7), \"7.7\")\n",
  "django__django-15930": "diff --git a/tests/expressions_case/tests.py b/tests/expressions_case/tests.py\nindex 696f4d0..11ab8e3 100644\n--- a/tests/expressions_case/tests.py\n+++ b/tests/expressions_case/tests.py\n@@ -415,7 +415,20 @@ class CaseExpressionTests(TestCase):\n         self.assertEqual(len(objects), CaseTestModel.objects.count())\n         self.assertTrue(all(obj.selected == \"not selected\" for obj in objects))\n \n-    def test_combined_expression(self):\n+    def test_case_with_negated_empty_q(self):\n+        # This test checks the fix for the issue with ~Q(pk__in=[]) in a Case expression.\n+        objects = CaseTestModel.objects.annotate(\n+            annotated_value=Case(\n+                When(~Q(pk__in=[]), then=Value(True)),\n+                default=Value(False),\n+                output_field=BooleanField(),\n+            )\n+        ).order_by(\"-annotated_value\")\n+\n+        # Since ~Q(pk__in=[]) is effectively a condition that always holds true,\n+        # all objects should be annotated with True.\n+        self.assertEqual(len(objects), CaseTestModel.objects.count())\n+        self.assertTrue(all(obj.annotated_value for obj in objects))\n         self.assertQuerysetEqual(\n             CaseTestModel.objects.annotate(\n                 test=Case(\n",
  "django__django-15987": "diff --git a/tests/fixtures_regress/tests.py b/tests/fixtures_regress/tests.py\nindex 5ac9ab9..bd8df4f 100644\n--- a/tests/fixtures_regress/tests.py\n+++ b/tests/fixtures_regress/tests.py\n@@ -1,3 +1,4 @@\n+\n # Unittests for fixtures.\n import json\n import os\n@@ -575,6 +576,25 @@ class TestFixtures(TestCase):\n             os.path.join(_cur_dir, \"fixtures_2\"),\n         ]\n     )\n+    @override_settings(\n+        FIXTURE_DIRS=[\n+            Path(_cur_dir) / \"fixtures\",\n+            Path(_cur_dir) / \"fixtures\",\n+        ]\n+    )\n+    def test_fixture_dirs_with_path_duplicates(self):\n+        \"\"\"\n+        settings.FIXTURE_DIRS should detect duplicate Path instances\n+        to avoid repeated fixture loading.\n+        \"\"\"\n+        msg = (\n+            \"'%s' appears more than once in FIXTURE_DIRS. \"\n+            \"Duplicates are not allowed.\"\n+            % (os.path.join(_cur_dir, \"fixtures\"))\n+        )\n+        with self.assertRaisesMessage(ImproperlyConfigured, msg):\n+            management.call_command(\"loaddata\", \"absolute.json\", verbosity=0)\n+\n     def test_loaddata_with_valid_fixture_dirs(self):\n         management.call_command(\n             \"loaddata\",\n",
  "django__django-16032": "",
  "django__django-16082": "",
  "django__django-16100": "diff --git a/tests/admin_changelist/tests.py b/tests/admin_changelist/tests.py\nindex 0ab2941..f9d863d 100644\n--- a/tests/admin_changelist/tests.py\n+++ b/tests/admin_changelist/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib import admin\n@@ -21,7 +22,10 @@ from django.db.models import F, Field, IntegerField\n from django.db.models.functions import Upper\n from django.db.models.lookups import Contains, Exact\n from django.template import Context, Template, TemplateSyntaxError\n-from django.test import TestCase, override_settings\n+from unittest import mock\n+from django.db import DatabaseError\n+from django.test import TestCase, override_settings, skipUnlessDBFeature\n+from django.urls import reverse\n from django.test.client import RequestFactory\n from django.test.utils import CaptureQueriesContext, isolate_apps, register_lookup\n from django.urls import reverse\n@@ -400,7 +404,52 @@ class ChangeListTests(TestCase):\n         with self.assertRaises(IncorrectLookupParameters):\n             m.get_changelist_instance(request)\n \n-    def test_custom_paginator(self):\n+    @skipUnlessDBFeature(\"supports_transactions\")\n+    def test_list_editable_atomicity(self):\n+        a = Swallow.objects.create(origin=\"Swallow A\", load=4, speed=1)\n+        b = Swallow.objects.create(origin=\"Swallow B\", load=2, speed=2)\n+\n+        self.client.force_login(self.superuser)\n+        changelist_url = reverse(\"admin:admin_changelist_swallow_changelist\")\n+        data = {\n+            \"form-TOTAL_FORMS\": \"2\",\n+            \"form-INITIAL_FORMS\": \"2\",\n+            \"form-MIN_NUM_FORMS\": \"0\",\n+            \"form-MAX_NUM_FORMS\": \"1000\",\n+            \"form-0-uuid\": str(a.pk),\n+            \"form-1-uuid\": str(b.pk),\n+            \"form-0-load\": \"9.0\",\n+            \"form-0-speed\": \"3.0\",\n+            \"form-1-load\": \"5.0\",\n+            \"form-1-speed\": \"1.0\",\n+            \"_save\": \"Save\",\n+        }\n+        with mock.patch(\n+            \"django.contrib.admin.ModelAdmin.log_change\", side_effect=DatabaseError\n+        ):\n+            with self.assertRaises(DatabaseError):\n+                self.client.post(changelist_url, data)\n+        # Original values are preserved.\n+        a.refresh_from_db()\n+        self.assertEqual(a.load, 4)\n+        self.assertEqual(a.speed, 1)\n+        b.refresh_from_db()\n+        self.assertEqual(b.load, 2)\n+        self.assertEqual(b.speed, 2)\n+\n+        with mock.patch(\n+            \"django.contrib.admin.ModelAdmin.log_change\",\n+            side_effect=[None, DatabaseError],\n+        ):\n+            with self.assertRaises(DatabaseError):\n+                self.client.post(changelist_url, data)\n+        # Original values are preserved.\n+        a.refresh_from_db()\n+        self.assertEqual(a.load, 4)\n+        self.assertEqual(a.speed, 1)\n+        b.refresh_from_db()\n+        self.assertEqual(b.load, 2)\n+        self.assertEqual(b.speed, 2)\n         new_parent = Parent.objects.create(name=\"parent\")\n         for i in range(1, 201):\n             Child.objects.create(name=\"name %s\" % i, parent=new_parent)\n",
  "django__django-16116": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex cd0e572..d3e67f7 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -2400,7 +2400,16 @@ class MakeMigrationsTests(MigrationTestBase):\n         ):\n             call_command(\"makemigrations\", \"--check\", \"migrations\", verbosity=0)\n \n-    def test_makemigrations_migration_path_output(self):\n+    def test_makemigrations_check_without_creating_files(self):\n+        \"\"\"\n+        Test that makemigrations --check exits without creating migration files\n+        when there are unapplied changes.\n+        \"\"\"\n+        with self.temporary_migration_module() as tmpdir:\n+            with self.assertRaises(SystemExit):\n+                call_command(\"makemigrations\", \"--check\", \"migrations\", verbosity=0)\n+            # Verify no migration files are created.\n+            self.assertFalse(os.listdir(tmpdir), \"Expected no migration files to be created\")\n         \"\"\"\n         makemigrations should print the relative paths to the migrations unless\n         they are outside of the current tree, in which case the absolute path\n",
  "django__django-16136": "",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..8eaa06c 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -24,7 +25,9 @@ from django.forms.fields import CharField, Field, IntegerField\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.utils import translation\n from django.utils.text import capfirst\n+from django.urls import reverse\n from django.utils.translation import gettext as _\n+import urllib.parse\n \n from .models.custom_user import (\n     CustomUser,\n@@ -881,7 +884,33 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         form = UserChangeForm(instance=user, data=post_data)\n \n         self.assertTrue(form.is_valid())\n-        # original hashed password contains $\n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search('<a href=\"(.*?)\">', password_help_text)\n+\n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.username,),\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_password_help_text_format_without_to_field(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        expected_link = f\"../{user.pk}/password/\"\n+        self.assertIn(expected_link, password_help_text)\n         self.assertIn(\"$\", form.cleaned_data[\"password\"])\n \n     def test_bug_19349_bound_password_field(self):\n",
  "django__django-16145": "",
  "django__django-16255": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 1469efd..4e3ce17 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -508,6 +508,46 @@ class HTTPSitemapTests(SitemapTestsBase):\n         self.assertXMLEqual(sitemap_response.content.decode(), expected_content_sitemap)\n \n \n+from django.test import TestCase\n+from django.contrib.sitemaps import Sitemap\n+\n+class CallableLastmodNoItemsSitemap(Sitemap):\n+    \"\"\"\n+    A sitemap class that simulates the behavior of having no items but\n+    implementing a callable lastmod method.\n+    \"\"\"\n+    location = \"/location/\"\n+\n+    def items(self):\n+        return []\n+\n+    def lastmod(self, obj):\n+        # This method would normally return the lastmod attribute of an object.\n+        return obj.lastmod\n+\n+class SitemapTestsBase(TestCase):\n+    urlpatterns = [\n+        path(\n+            \"callable-lastmod-no-items/index.xml\",\n+            views.index,\n+            {\"sitemaps\": {\"callable-lastmod\": CallableLastmodNoItemsSitemap}},\n+        ),\n+    ]\n+\n+    def test_callable_sitemod_no_items(self):\n+        \"\"\"\n+        Test sitemap behavior when no items are present and lastmod is callable.\n+        Should handle empty item list without raising ValueError.\n+        \"\"\"\n+        index_response = self.client.get(\"/callable-lastmod-no-items/index.xml\")\n+        self.assertNotIn(\"Last-Modified\", index_response)\n+        expected_content_index = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n+        <sitemap><loc>http://example.com/callable-lastmod-no-items/sitemap.xml</loc></sitemap>\n+        </sitemapindex>\n+        \"\"\"\n+        self.assertXMLEqual(index_response.content.decode(), expected_content_index)\n+\n # RemovedInDjango50Warning\n class DeprecatedTests(SitemapTestsBase):\n     @override_settings(\n",
  "django__django-16315": "diff --git a/tests/bulk_create/models.py b/tests/bulk_create/models.py\nindex c5f5c07..2b5dcf9 100644\n--- a/tests/bulk_create/models.py\n+++ b/tests/bulk_create/models.py\n@@ -59,6 +59,11 @@ class Pizzeria(Restaurant):\n     pass\n \n \n+class FieldsWithDbColumns(models.Model):\n+    rank = models.IntegerField(unique=True, db_column=\"rAnK\")\n+    name = models.CharField(max_length=15, null=True, db_column=\"oTheRNaMe\")\n+\n+\n class State(models.Model):\n     two_letter_code = models.CharField(max_length=2, primary_key=True)\n \n@@ -79,6 +84,11 @@ class NoFields(models.Model):\n     pass\n \n \n+class FieldsWithDbColumns(models.Model):\n+    rank = models.IntegerField(unique=True, db_column=\"rAnK\")\n+    name = models.CharField(max_length=15, null=True, db_column=\"oTheRNaMe\")\n+\n+\n class SmallAutoFieldModel(models.Model):\n     id = models.SmallAutoField(primary_key=True)\n \n",
  "django__django-16333": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 714f137..9e18a9a 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,64 @@\n+\n+class CustomUserCreationFormTests(TestCase):\n+\n+    def test_custom_form_saves_many_to_many_field(self):\n+        class CustomUserCreationForm(UserCreationForm):\n+            class Meta(UserCreationForm.Meta):\n+                model = CustomUserWithM2M\n+                fields = UserCreationForm.Meta.fields + (\"orgs\",)\n+\n+        organization = Organization.objects.create(name=\"organization 1\")\n+\n+        data = {\n+            \"username\": \"testclient@example.com\",\n+            \"password1\": \"testclient\",\n+            \"password2\": \"testclient\",\n+            \"orgs\": [str(organization.pk)],\n+        }\n+        form = CustomUserCreationForm(data)\n+        self.assertTrue(form.is_valid())\n+        user = form.save(commit=True)\n+        self.assertSequenceEqual(user.orgs.all(), [organization])\n+\n+    def test_custom_form_without_committing_saves_many_to_many_field(self):\n+        class CustomUserCreationForm(UserCreationForm):\n+            class Meta(UserCreationForm.Meta):\n+                model = CustomUserWithM2M\n+                fields = UserCreationForm.Meta.fields + (\"orgs\",)\n+\n+        organization1 = Organization.objects.create(name=\"organization 1\")\n+        organization2 = Organization.objects.create(name=\"organization 2\")\n+\n+        data = {\n+            \"username\": \"testuser2@example.com\",\n+            \"password1\": \"testpassword\",\n+            \"password2\": \"testpassword\",\n+            \"orgs\": [str(organization1.pk), str(organization2.pk)],\n+        }\n+        form = CustomUserCreationForm(data)\n+        self.assertTrue(form.is_valid())\n+        user = form.save(commit=False)\n+        user.save()\n+        form.save_m2m()\n+        self.assertSequenceEqual(user.orgs.all(), [organization1, organization2])\n+\n+    def test_custom_form_invalid_data(self):\n+        class CustomUserCreationForm(UserCreationForm):\n+            class Meta(UserCreationForm.Meta):\n+                model = CustomUserWithM2M\n+                fields = UserCreationForm.Meta.fields + (\"orgs\",)\n+\n+        organization = Organization.objects.create(name=\"organization 1\")\n+\n+        data = {\n+            \"username\": \"testclient@example.com\",\n+            \"password1\": \"testclient\",\n+            \"password2\": \"mismatch\",\n+            \"orgs\": [str(organization.pk)],\n+        }\n+        form = CustomUserCreationForm(data)\n+        self.assertFalse(form.is_valid())\n+\n import datetime\n import re\n import urllib.parse\n@@ -36,6 +97,7 @@ from .models.custom_user import (\n from .models.with_custom_email_field import CustomEmailField\n from .models.with_integer_username import IntegerUsernameUser\n from .settings import AUTH_TEMPLATES\n+from .models.with_many_to_many import CustomUserWithM2M, Organization\n \n \n class TestDataMixin:\n",
  "django__django-16429": "diff --git a/tests/utils_tests/test_timesince.py b/tests/utils_tests/test_timesince.py\nindex f795bf7..084c981 100644\n--- a/tests/utils_tests/test_timesince.py\n+++ b/tests/utils_tests/test_timesince.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.test import TestCase\n@@ -236,6 +237,34 @@ class TimesinceTests(TestCase):\n             with self.subTest():\n                 self.assertEqual(timesince(t, value), expected)\n \n+    @requires_tz_support\n+    @override_settings(USE_TZ=True)\n+    def test_long_interval_with_tz(self):\n+        now = timezone.now()\n+        d = now - datetime.timedelta(days=31)\n+        self.assertEqual(timesince(d), \"1\\xa0month\")\n+        \n+    @requires_tz_support\n+    @override_settings(USE_TZ=True)\n+    def test_exact_one_month_with_tz(self):\n+        now = timezone.now()\n+        d = now - datetime.timedelta(days=30)\n+        self.assertEqual(timesince(d), \"4\\xa0weeks\")\n+        \n+    @requires_tz_support\n+    @override_settings(USE_TZ=True)\n+    def test_leap_year_february(self):\n+        now = timezone.datetime(2020, 3, 1, tzinfo=timezone.get_current_timezone())\n+        d = timezone.datetime(2020, 2, 1, tzinfo=timezone.get_current_timezone())\n+        self.assertEqual(timesince(d, now), \"1\\xa0month\")\n+        \n+    @requires_tz_support\n+    @override_settings(USE_TZ=True)\n+    def test_time_with_tzinfo(self):\n+        now = timezone.now()\n+        d = now - datetime.timedelta(days=365)\n+        self.assertEqual(timesince(d), \"1\\xa0year\")\n+        \n     def test_depth_invalid(self):\n         msg = \"depth must be greater than 0.\"\n         with self.assertRaisesMessage(ValueError, msg):\n",
  "django__django-16454": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 8d0729b..a1e4e6f 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -475,7 +475,23 @@ class UtilsTests(SimpleTestCase):\n         with self.assertRaisesMessage(CommandError, msg):\n             popen_wrapper([\"a_42_command_that_doesnt_exist_42\"])\n \n-    def test_get_random_secret_key(self):\n+    def test_subparser_missing_argument(self):\n+        class TestCommand(BaseCommand):\n+            def add_arguments(self, parser):\n+                subparsers = parser.add_subparsers(parser_class=CommandParser)\n+                create_parser = subparsers.add_parser('create')\n+                create_parser.add_argument('name')\n+\n+            def handle(self, *args, **options):\n+                pass\n+\n+        cmd = TestCommand()\n+        out, err = self.run_manage(['create'])\n+        \n+        self.assertNoOutput(out)\n+        err_lines = err.splitlines()\n+        self.assertTrue(err)\n+        self.assertIn(\"error: the following arguments are required: name\", err_lines[-1])\n         key = get_random_secret_key()\n         self.assertEqual(len(key), 50)\n         for char in key:\n",
  "django__django-16485": "",
  "django__django-16493": "diff --git a/tests/file_storage/tests.py b/tests/file_storage/tests.py\nindex 20567e7..1010508 100644\n--- a/tests/file_storage/tests.py\n+++ b/tests/file_storage/tests.py\n@@ -93,6 +93,16 @@ class GetStorageClassTests(SimpleTestCase):\n \n class FileSystemStorageTests(unittest.TestCase):\n     def test_deconstruction(self):\n+        \"\"\"\n+        Deconstructing a FileField with storage as a callable returning\n+        default_storage should include the callable in the kwargs.\n+        \"\"\"\n+        obj = Storage()\n+        *_, kwargs = obj._meta.get_field(\"storage_callable_default\").deconstruct()\n+        storage = kwargs[\"storage\"]\n+        self.assertIs(storage, callable_default_storage)\n+\n+    def test_deconstruction_random_storage(self):\n         path, args, kwargs = temp_storage.deconstruct()\n         self.assertEqual(path, \"django.core.files.storage.FileSystemStorage\")\n         self.assertEqual(args, ())\n@@ -1009,11 +1019,16 @@ class FieldCallableFileStorageTests(SimpleTestCase):\n         self.assertEqual(obj.storage_callable.storage.location, temp_storage_location)\n         self.assertIsInstance(obj.storage_callable_class.storage, BaseStorage)\n \n-    def test_deconstruction(self):\n+        obj = Storage()\n+\n+    def test_callable_random_storage_deconstruction(self):\n         \"\"\"\n-        Deconstructing gives the original callable, not the evaluated value.\n+        A callable that randomly returns default_storage or another storage\n+        is not omitted when deconstructing.\n         \"\"\"\n-        obj = Storage()\n+        *_, kwargs = obj._meta.get_field(\"random\").deconstruct()\n+        storage = kwargs[\"storage\"]\n+        self.assertIs(storage, get_storage)\n         *_, kwargs = obj._meta.get_field(\"storage_callable\").deconstruct()\n         storage = kwargs[\"storage\"]\n         self.assertIs(storage, callable_storage)\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..89e6225 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -6,6 +7,8 @@ from django.contrib.admin.templatetags.admin_modify import submit_row\n from django.contrib.auth.admin import UserAdmin\n from django.contrib.auth.models import User\n from django.test import RequestFactory, TestCase\n+from django.contrib.auth import get_permission_codename\n+from .tests import AdminViewBasicTestCase, get_perm\n from django.urls import reverse\n \n from .admin import ArticleAdmin, site\n@@ -33,6 +36,43 @@ class AdminTemplateTagsTest(AdminViewBasicTestCase):\n         self.assertIs(template_context[\"extra\"], True)\n         self.assertIs(template_context[\"show_save\"], True)\n \n+    def test_submit_row_save_as_new_add_permission_required(self):\n+        \"\"\"\n+        Test that \"show_save_as_new\" is correctly controlled by permissions.\n+        \"\"\"\n+        # User with change permission but without add permission\n+        change_user = User.objects.create_user(\n+            username=\"change_user\", password=\"secret\", is_staff=True\n+        )\n+        change_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = change_user\n+        admin = UserAdmin(User, site)\n+        admin.save_as = True\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], False)\n+\n+        # User with both add and change permissions\n+        add_user = User.objects.create_user(\n+            username=\"add_user\", password=\"secret\", is_staff=True\n+        )\n+        add_user.user_permissions.add(\n+            get_perm(User, get_permission_codename(\"add\", User._meta)),\n+            get_perm(User, get_permission_codename(\"change\", User._meta)),\n+        )\n+        request = self.request_factory.get(\n+            reverse(\"admin:auth_user_change\", args=[self.superuser.pk])\n+        )\n+        request.user = add_user\n+        response = admin.change_view(request, str(self.superuser.pk))\n+        template_context = submit_row(response.context_data)\n+        self.assertIs(template_context[\"show_save_as_new\"], True)\n+\n     def test_override_show_save_and_add_another(self):\n         request = self.request_factory.get(\n             reverse(\"admin:auth_user_change\", args=[self.superuser.pk]),\n",
  "django__django-16560": "",
  "django__django-16569": "",
  "django__django-16595": "",
  "django__django-16612": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 9120571..249abbc 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -8450,6 +8450,60 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n \n     @override_settings(APPEND_SLASH=True)\n     def test_missing_slash_append_slash_true(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_multiple_query_params(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(f\"{known_url[:-1]}?id=123&filter=active\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123&filter=active\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_without_query_string(self):\n         superuser = User.objects.create_user(\n             username=\"staff\",\n             password=\"secret\",\n@@ -8462,9 +8516,117 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n         self.assertRedirects(\n             response, known_url, status_code=301, target_status_code=403\n         )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_multiple_query_params(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(f\"{known_url[:-1]}?id=123&filter=active\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123&filter=active\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_without_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n \n     @override_settings(APPEND_SLASH=True)\n     def test_missing_slash_append_slash_true_script_name(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_multiple_query_params(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(f\"{known_url[:-1]}?id=123&filter=active\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123&filter=active\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_without_query_string(self):\n         superuser = User.objects.create_user(\n             username=\"staff\",\n             password=\"secret\",\n@@ -8480,9 +8642,117 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             status_code=301,\n             fetch_redirect_response=False,\n         )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_multiple_query_params(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(f\"{known_url[:-1]}?id=123&filter=active\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123&filter=active\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_without_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n \n     @override_settings(APPEND_SLASH=True, FORCE_SCRIPT_NAME=\"/prefix/\")\n     def test_missing_slash_append_slash_true_force_script_name(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_multiple_query_params(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(f\"{known_url[:-1]}?id=123&filter=active\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123&filter=active\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_without_query_string(self):\n         superuser = User.objects.create_user(\n             username=\"staff\",\n             password=\"secret\",\n@@ -8498,6 +8768,60 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             status_code=301,\n             fetch_redirect_response=False,\n         )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_multiple_query_params(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(f\"{known_url[:-1]}?id=123&filter=active\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123&filter=active\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_without_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n \n     @override_settings(APPEND_SLASH=True)\n     def test_missing_slash_append_slash_true_non_staff_user(self):\n@@ -8507,6 +8831,60 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n             email=\"user@example.com\",\n             is_staff=False,\n         )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_multiple_query_params(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(f\"{known_url[:-1]}?id=123&filter=active\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123&filter=active\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_without_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n         self.client.force_login(user)\n         known_url = reverse(\"admin:admin_views_article_changelist\")\n         response = self.client.get(known_url[:-1])\n@@ -8616,6 +8994,60 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n \n     @override_settings(APPEND_SLASH=True)\n     def test_missing_slash_append_slash_true_without_final_catch_all_view(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_multiple_query_params(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(f\"{known_url[:-1]}?id=123&filter=active\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123&filter=active\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_without_query_string(self):\n         superuser = User.objects.create_user(\n             username=\"staff\",\n             password=\"secret\",\n@@ -8628,9 +9060,117 @@ class AdminSiteFinalCatchAllPatternTests(TestCase):\n         self.assertRedirects(\n             response, known_url, status_code=301, target_status_code=403\n         )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_multiple_query_params(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(f\"{known_url[:-1]}?id=123&filter=active\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123&filter=active\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_without_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n \n     @override_settings(APPEND_SLASH=False)\n     def test_missing_slash_append_slash_false_without_final_catch_all_view(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_query_string(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(\"%s?id=123\" % known_url[:-1])\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_with_multiple_query_params(self):\n+        superuser = User.objects.create_user(\n+            username=\"staff\",\n+            password=\"secret\",\n+            email=\"staff@example.com\",\n+            is_staff=True,\n+        )\n+        self.client.force_login(superuser)\n+        known_url = reverse(\"admin:admin_views_article_changelist\")\n+        response = self.client.get(f\"{known_url[:-1]}?id=123&filter=active\")\n+        self.assertRedirects(\n+            response,\n+            f\"{known_url}?id=123&filter=active\",\n+            status_code=301,\n+            fetch_redirect_response=False,\n+        )\n+\n+    @override_settings(APPEND_SLASH=True)\n+    def test_catch_all_view_without_query_string(self):\n         superuser = User.objects.create_user(\n             username=\"staff\",\n             password=\"secret\",\n",
  "django__django-16642": "",
  "django__django-16661": "diff --git a/tests/modeladmin/tests.py b/tests/modeladmin/tests.py\nindex 8cb88da..508fd20 100644\n--- a/tests/modeladmin/tests.py\n+++ b/tests/modeladmin/tests.py\n@@ -153,6 +153,32 @@ class ModelAdminTests(TestCase):\n         self.assertIs(\n             ma.lookup_allowed(\"employee__department__code\", \"test_value\"), True\n         )\n+    \n+    @isolate_apps(\"modeladmin\")\n+    def test_lookup_allowed_foreign_primary(self):\n+        class Country(models.Model):\n+            name = models.CharField(max_length=256)\n+        \n+        class Place(models.Model):\n+            country = models.ForeignKey(Country, models.CASCADE)\n+        \n+        class Restaurant(models.Model):\n+            place = models.OneToOneField(Place, models.CASCADE, primary_key=True)\n+        \n+        class Waiter(models.Model):\n+            restaurant = models.ForeignKey(Restaurant, models.CASCADE)\n+        \n+        class WaiterAdmin(ModelAdmin):\n+            list_filter = [\n+                \"restaurant__place__country\",\n+                \"restaurant__place__country__name\",\n+            ]\n+        \n+        ma = WaiterAdmin(Waiter, self.site)\n+        # Test lookup for foreign key as primary key\n+        self.assertIs(ma.lookup_allowed(\"restaurant__place__country\", \"1\"), True)\n+        self.assertIs(ma.lookup_allowed(\"restaurant__place__country__id__exact\", \"1\"), True)\n+        self.assertIs(ma.lookup_allowed(\"restaurant__place__country__name\", \"test_value\"), True)\n \n     def test_field_arguments(self):\n         # If fields is specified, fieldsets_add and fieldsets_change should\n",
  "django__django-16662": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex f0046ca..0f71d94 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -922,7 +922,41 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n-    def test_migration_file_header_comments(self):\n+    def test_import_order_with_multiple_import_types(self):\n+        \"\"\"\n+        Test that imports are sorted correctly with mixed import and from-import statements.\n+        \"\"\"\n+        migration = type(\n+            \"Migration\",\n+            (migrations.Migration,),\n+            {\n+                \"operations\": [\n+                    migrations.AddField(\n+                        \"mymodel\",\n+                        \"myfield\",\n+                        models.FloatField(default=time.time),\n+                    ),\n+                ]\n+            },\n+        )\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        expected_import_order = (\n+            \"import datetime\\n\"\n+            \"import time\\n\"\n+            \"from django.db import migrations, models\\n\"\n+        )\n+        self.assertIn(expected_import_order, output)\n+\n+    def test_import_order_with_no_imports(self):\n+        \"\"\"\n+        Test that the output is correct when there are no imports required.\n+        \"\"\"\n+        migration = type(\"Migration\", (migrations.Migration,), {\"operations\": []})\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        # Check that the output doesn't contain any imports\n+        self.assertNotIn(\"import\", output)\n         \"\"\"\n         Test comments at top of file.\n         \"\"\"\n",
  "django__django-16801": "diff --git a/tests/model_fields/test_imagefield.py b/tests/model_fields/test_imagefield.py\nindex 9bf7f7d..db0fa9c 100644\n--- a/tests/model_fields/test_imagefield.py\n+++ b/tests/model_fields/test_imagefield.py\n@@ -319,8 +319,41 @@ class ImageFieldTwoDimensionsTests(ImageFieldTestMixin, TestCase):\n         # Dimensions were recalculated, and hence file should have opened.\n         self.assertIs(p.mugshot.was_opened, True)\n \n+from django.db.models import signals\n \n @skipIf(Image is None, \"Pillow is required to test ImageField\")\n+class ImageFieldPostInitTests(TestCase):\n+    \"\"\"\n+    Tests behavior of ImageField related to post_init signal connection.\n+    \"\"\"\n+\n+    def test_post_init_signal_not_connected_with_no_dimensions(self):\n+        # Create a mock model with an ImageField and no dimension fields\n+        class MockModelWithoutDimensions(models.Model):\n+            image = models.ImageField()\n+        \n+        # Ensure the post_init signal is not connected for models without dimensions\n+        model_id = id(MockModelWithoutDimensions)\n+        self.assertNotIn(\n+            model_id,\n+            [sender_id for (_, sender_id) in signals.post_init.receivers],\n+            \"post_init signal should not be connected when no dimension fields are present\"\n+        )\n+\n+    def test_post_init_signal_connected_with_dimensions(self):\n+        # Create a mock model with an ImageField and dimension fields\n+        class MockModelWithDimensions(models.Model):\n+            image = models.ImageField(width_field='width', height_field='height')\n+            width = models.IntegerField()\n+            height = models.IntegerField()\n+\n+        # Ensure the post_init signal is connected for models with dimensions\n+        model_id = id(MockModelWithDimensions)\n+        self.assertIn(\n+            model_id,\n+            [sender_id for (_, sender_id) in signals.post_init.receivers],\n+            \"post_init signal should be connected when dimension fields are present\"\n+        )\n class ImageFieldNoDimensionsTests(ImageFieldTwoDimensionsTests):\n     \"\"\"\n     Tests behavior of an ImageField with no dimension fields.\n@@ -328,8 +361,41 @@ class ImageFieldNoDimensionsTests(ImageFieldTwoDimensionsTests):\n \n     PersonModel = Person\n \n+from django.db.models import signals\n \n @skipIf(Image is None, \"Pillow is required to test ImageField\")\n+class ImageFieldPostInitTests(TestCase):\n+    \"\"\"\n+    Tests behavior of ImageField related to post_init signal connection.\n+    \"\"\"\n+\n+    def test_post_init_signal_not_connected_with_no_dimensions(self):\n+        # Create a mock model with an ImageField and no dimension fields\n+        class MockModelWithoutDimensions(models.Model):\n+            image = models.ImageField()\n+        \n+        # Ensure the post_init signal is not connected for models without dimensions\n+        model_id = id(MockModelWithoutDimensions)\n+        self.assertNotIn(\n+            model_id,\n+            [sender_id for (_, sender_id) in signals.post_init.receivers],\n+            \"post_init signal should not be connected when no dimension fields are present\"\n+        )\n+\n+    def test_post_init_signal_connected_with_dimensions(self):\n+        # Create a mock model with an ImageField and dimension fields\n+        class MockModelWithDimensions(models.Model):\n+            image = models.ImageField(width_field='width', height_field='height')\n+            width = models.IntegerField()\n+            height = models.IntegerField()\n+\n+        # Ensure the post_init signal is connected for models with dimensions\n+        model_id = id(MockModelWithDimensions)\n+        self.assertIn(\n+            model_id,\n+            [sender_id for (_, sender_id) in signals.post_init.receivers],\n+            \"post_init signal should be connected when dimension fields are present\"\n+        )\n class ImageFieldOneDimensionTests(ImageFieldTwoDimensionsTests):\n     \"\"\"\n     Tests behavior of an ImageField with one dimensions field.\n",
  "django__django-16819": "",
  "django__django-16877": "",
  "django__django-16899": "diff --git a/tests/admin_checks/tests.py b/tests/admin_checks/tests.py\nindex 5130136..de93eec 100644\n--- a/tests/admin_checks/tests.py\n+++ b/tests/admin_checks/tests.py\n@@ -798,7 +798,7 @@ class SystemChecksTestCase(SimpleTestCase):\n         errors = SongAdmin(Song, AdminSite()).check()\n         expected = [\n             checks.Error(\n-                \"The value of 'readonly_fields[1]' is not a callable, an attribute \"\n+                \"The value of 'readonly_fields[1]' refers to 'nonexistent', which is not a callable, an attribute \"\n                 \"of 'SongAdmin', or an attribute of 'admin_checks.Song'.\",\n                 obj=SongAdmin,\n                 id=\"admin.E035\",\n",
  "django__django-16901": "diff --git a/tests/xor_lookups/tests.py b/tests/xor_lookups/tests.py\nindex 389d908..4c74c35 100644\n--- a/tests/xor_lookups/tests.py\n+++ b/tests/xor_lookups/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import Q\n from django.test import TestCase\n \n@@ -19,7 +20,28 @@ class XorLookupsTests(TestCase):\n             self.numbers[:3] + self.numbers[8:],\n         )\n \n-    def test_filter_negated(self):\n+    def test_parity_xor(self):\n+        # Test the expected parity-based XOR behavior\n+        self.assertCountEqual(\n+            Number.objects.filter(\n+                Q(num__gte=1)\n+                ^ Q(num__gte=3)\n+                ^ Q(num__gte=5)\n+                ^ Q(num__gte=7)\n+                ^ Q(num__gte=9)\n+            ),\n+            self.numbers[1:3] + self.numbers[5:7] + self.numbers[9:],\n+        )\n+        self.assertCountEqual(\n+            Number.objects.filter(\n+                Q(num__gte=0)\n+                ^ Q(num__gte=2)\n+                ^ Q(num__gte=4)\n+                ^ Q(num__gte=6)\n+                ^ Q(num__gte=8)\n+            ),\n+            self.numbers[0:1] + self.numbers[3:5] + self.numbers[7:9],\n+        )\n         self.assertCountEqual(\n             Number.objects.filter(Q(num__lte=7) ^ ~Q(num__lt=3)),\n             self.numbers[:3] + self.numbers[8:],\n@@ -64,4 +86,4 @@ class XorLookupsTests(TestCase):\n         self.assertCountEqual(\n             Number.objects.filter(Q(pk__in=[]) ^ Q(num__gte=5)),\n             self.numbers[5:],\n-        )\n+        )\n",
  "django__django-17029": "",
  "django__django-17084": "",
  "django__django-17087": "",
  "django__django-7530": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex a74680b..25eb80f 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -638,6 +638,15 @@ class MakeMigrationsTests(MigrationTestBase):\n                 with self.settings(DATABASE_ROUTERS=['migrations.routers.TestRouter']):\n                     with mock.patch.object(TestRouter, 'allow_migrate', return_value=False) as allow_migrate:\n                         call_command('makemigrations', 'migrations', verbosity=0)\n+                # Check that allow_migrate has been called with the correct app_label and model_name for each connection.\n+                for call in allow_migrate.mock_calls:\n+                    _, call_args, call_kwargs = call\n+                    connection_alias, app_label = call_args\n+                    model_name = call_kwargs.get('model_name')\n+                    self.assertIn(connection_alias, ['default', 'other'])\n+                    self.assertIn(app_label, ['migrations', 'migrations2'])  # Assuming 'migrations2' is another app.\n+                    self.assertIn(model_name, ['UnicodeModel', 'AnotherModel'])  # Add here valid model names per app.\n+                    \n                 allow_migrate.assert_called_with('other', 'migrations', model_name='UnicodeModel')\n                 self.assertEqual(ensure_schema.call_count, 4)\n \n",
  "django__django-9296": "diff --git a/tests/pagination/tests.py b/tests/pagination/tests.py\nindex b9b5fbc..a88d6a8 100644\n--- a/tests/pagination/tests.py\n+++ b/tests/pagination/tests.py\n@@ -298,6 +298,42 @@ class PaginationTests(SimpleTestCase):\n             paginator.get_page(1)\n \n \n+    def test_paginator_iteration(self):\n+        paginator = Paginator([1, 2, 3], 2)\n+        page_iterator = iter(paginator)\n+        for page, expected in enumerate(([1, 2], [3]), start=1):\n+            with self.subTest(page=page):\n+                self.assertEqual(expected, list(next(page_iterator)))\n+\n+    def test_paginator_iteration_empty(self):\n+        paginator = Paginator([], 2)\n+        page_iterator = iter(paginator)\n+        with self.assertRaises(StopIteration):\n+            next(page_iterator)\n+\n+    def test_paginator_multiple_pages(self):\n+        # Test when there are more pages\n+        paginator = Paginator([1, 2, 3, 4, 5], 2)\n+        expected_pages = [[1, 2], [3, 4], [5]]\n+        page_iterator = iter(paginator)\n+        for expected in expected_pages:\n+            self.assertEqual(expected, list(next(page_iterator)))\n+\n+    def test_paginator_exact_full_page(self):\n+        # Test when items perfectly fill pages\n+        paginator = Paginator([1, 2, 3, 4], 2)\n+        page_iterator = iter(paginator)\n+        for expected in ([1, 2], [3, 4]):\n+            self.assertEqual(expected, list(next(page_iterator)))\n+\n+    def test_iter_on_single_page(self):\n+        # Single page test\n+        paginator = Paginator([1, 2], 2)\n+        page_iterator = iter(paginator)\n+        self.assertEqual([1, 2], list(next(page_iterator)))\n+        with self.assertRaises(StopIteration):\n+            next(page_iterator)\n+\n class ModelPaginationTests(TestCase):\n     \"\"\"\n     Test pagination with Django model instances\n",
  "matplotlib__matplotlib-13989": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 5483eef..54e477f 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -6359,8 +6359,25 @@ def test_hist_auto_bins():\n \n def test_hist_nan_data():\n     fig, (ax1, ax2) = plt.subplots(2)\n+import numpy as np\n+import matplotlib.pyplot as plt\n \n-    data = [1, 2, 3]\n+def test_hist_range_and_density():\n+    _, bins, _ = plt.hist(np.random.rand(10), \"auto\", range=(0, 1), density=True)\n+    assert bins[0] == 0, f\"Expected first bin edge to be 0, but got {bins[0]}\"\n+    assert bins[-1] == 1, f\"Expected last bin edge to be 1, but got {bins[-1]}\"\n+\n+def test_hist_range_density_false():\n+    # Test to ensure range works with density=False\n+    _, bins, _ = plt.hist(np.random.rand(10), \"auto\", range=(0, 1), density=False)\n+    assert bins[0] == 0, f\"Expected first bin edge to be 0, but got {bins[0]}\"\n+    assert bins[-1] == 1, f\"Expected last bin edge to be 1, but got {bins[-1]}\"\n+\n+def test_hist_different_range_density_true():\n+    # Test with a different range\n+    _, bins, _ = plt.hist(np.random.rand(10), \"auto\", range=(0.2, 0.8), density=True)\n+    assert bins[0] == 0.2, f\"Expected first bin edge to be 0.2, but got {bins[0]}\"\n+    assert bins[-1] == 0.8, f\"Expected last bin edge to be 0.8, but got {bins[-1]}\"\n     nan_data = data + [np.nan]\n \n     bins, edges, _ = ax1.hist(data)\n@@ -6368,4 +6385,4 @@ def test_hist_nan_data():\n         nanbins, nanedges, _ = ax2.hist(nan_data)\n \n     assert np.allclose(bins, nanbins)\n-    assert np.allclose(edges, nanedges)\n+    assert np.allclose(edges, nanedges)\n",
  "matplotlib__matplotlib-14623": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex c9ad946..be1de8b 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -938,9 +938,21 @@ def test_inverted_limits():\n     assert ax.get_ylim() == (5, -3)\n     plt.close()\n \n-\n-@image_comparison(baseline_images=['nonfinite_limits'])\n-def test_nonfinite_limits():\n+def test_invert_axis_log_scale():\n+    # Test inverting a y-axis with a log scale\n+    fig, ax = plt.subplots()\n+    ax.set_yscale(\"log\")\n+    ax.set_ylim(10, 1)  # Intentionally invert the limits\n+    # Ensure that the limits remain inverted\n+    assert ax.get_ylim() == (10, 1)\n+\n+    # Also check after plotting data\n+    y = np.linspace(1000, 1, 100)\n+    x = np.exp(-np.linspace(0, 1, y.size))\n+    ax.plot(x, y)\n+    ax.set_ylim(1000, 1)\n+    assert ax.get_ylim() == (1000, 1)\n+    plt.close(fig)\n     x = np.arange(0., np.e, 0.01)\n     # silence divide by zero warning from log(0)\n     with np.errstate(divide='ignore'):\n",
  "matplotlib__matplotlib-20488": "",
  "matplotlib__matplotlib-20826": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 24b5fb5..89763c0 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -6960,8 +6960,30 @@ def test_2dcolor_plot(fig_test, fig_ref):\n     axs[3].hist(np.arange(10), color=color.reshape((1, -1)))\n     axs[4].bar(np.arange(10), np.arange(10), color=color.reshape((1, -1)))\n \n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+@check_figures_equal(extensions=['png'])\n+def test_shared_axes_clear(fig_test, fig_ref):\n+    x = np.arange(0.0, 2*np.pi, 0.01)\n+    y = np.sin(x)\n+\n+    # Expected reference (without ax.clear())\n+    axs_ref = fig_ref.subplots(2, 2, sharex=True, sharey=True)\n+    for ax in axs_ref.flat:\n+        ax.plot(x, y)\n+    \n+    # Test case (with ax.clear())\n+    axs_test = fig_test.subplots(2, 2, sharex=True, sharey=True)\n+    for ax in axs_test.flat:\n+        ax.clear()\n+        ax.plot(x, y)\n \n-def test_shared_axes_retick():\n+    for ax in axs_test[0, :]:\n+        assert not ax.get_xticklabels(), \"Top row x-tick labels should be hidden\"\n+    for ax in axs_test[:, 1]:\n+        assert not ax.get_yticklabels(), \"Right column y-tick labels should be hidden\"\n     fig, axs = plt.subplots(2, 2, sharex='all', sharey='all')\n \n     for ax in axs.flat:\n",
  "matplotlib__matplotlib-20859": "",
  "matplotlib__matplotlib-22719": "diff --git a/lib/matplotlib/tests/test_category.py b/lib/matplotlib/tests/test_category.py\nindex 40c4dcf..a1d3329 100644\n--- a/lib/matplotlib/tests/test_category.py\n+++ b/lib/matplotlib/tests/test_category.py\n@@ -311,4 +311,35 @@ def test_hist():\n     fig, ax = plt.subplots()\n     n, bins, patches = ax.hist(['a', 'b', 'a', 'c', 'ff'])\n     assert n.shape == (10,)\n-    np.testing.assert_allclose(n, [2., 0., 0., 1., 0., 0., 1., 0., 0., 1.])\n+\n+def test_no_deprecation_on_empty_data():\n+    \"\"\"\n+    Smoke test to check that no deprecation warning is emitted. See #22640.\n+    \"\"\"\n+    f, ax = plt.subplots()\n+    ax.xaxis.update_units([\"a\", \"b\"])\n+    with pytest.warns(None) as record:\n+        ax.plot([], [])\n+    # Assert no warnings of MatplotlibDeprecationWarning are recorded\n+    assert not any(isinstance(warning.message, MatplotlibDeprecationWarning) for warning in record)\n+\n+def test_deprecation_warning_with_valid_data():\n+    \"\"\"\n+    Test that no deprecation warning is emitted even if valid data is used.\n+    \"\"\"\n+    f, ax = plt.subplots()\n+    ax.xaxis.update_units([\"a\", \"b\"])\n+    with pytest.warns(None) as record:\n+        ax.plot([\"a\"], [1])\n+    # Assert no warnings of MatplotlibDeprecationWarning are recorded\n+    assert not any(isinstance(warning.message, MatplotlibDeprecationWarning) for warning in record)\n+\n+def test_warning_on_numeric_data():\n+    \"\"\"\n+    Test that using numeric data raises a MatplotlibDeprecationWarning.\n+    \"\"\"\n+    f, ax = plt.subplots()\n+    ax.xaxis.update_units([\"a\", \"b\"])\n+    with pytest.raises(MatplotlibDeprecationWarning):\n+        ax.plot([1], [2])\n+    np.testing.assert_allclose(n, [2., 0., 0., 1., 0., 0., 1., 0., 0., 1.])\n",
  "matplotlib__matplotlib-22865": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex 2c28713..d31df5e 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -919,6 +919,35 @@ def test_proportional_colorbars():\n             fig.colorbar(CS3, spacing=spacings[j], ax=axs[i, j])\n \n \n+import pytest\n+import numpy as np\n+import matplotlib.pyplot as plt\n+import matplotlib.colors as mcolors\n+from matplotlib.colorbar import Colorbar\n+\n+@pytest.mark.parametrize(\"extend, coloroffset, res\", [\n+    ('both', 1, [np.array([[0., 0.], [0., 1.]]),\n+                 np.array([[1., 0.], [1., 1.]]),\n+                 np.array([[2., 0.], [2., 1.]])]),\n+    ('min', 0, [np.array([[0., 0.], [0., 1.]]),\n+                np.array([[1., 0.], [1., 1.]])]),\n+    ('max', 0, [np.array([[1., 0.], [1., 1.]]),\n+                np.array([[2., 0.], [2., 1.]])]),\n+    ('neither', -1, [np.array([[1., 0.], [1., 1.]])])\n+])\n+def test_colorbar_extend_drawedges(extend, coloroffset, res):\n+    cmap = plt.get_cmap(\"viridis\")\n+    bounds = np.arange(3)\n+    nb_colors = len(bounds) + coloroffset\n+    colors = cmap(np.linspace(100, 255, nb_colors).astype(int))\n+    cmap, norm = mcolors.from_levels_and_colors(bounds, colors, extend=extend)\n+\n+    plt.figure(figsize=(5, 1))\n+    ax = plt.subplot(111)\n+    cbar = Colorbar(ax, cmap=cmap, norm=norm, orientation='horizontal',\n+                    drawedges=True)\n+    assert np.all(np.equal(cbar.dividers.get_segments(), res))\n+\n def test_negative_boundarynorm():\n     fig, ax = plt.subplots(figsize=(1, 3))\n     cmap = plt.get_cmap(\"viridis\")\n",
  "matplotlib__matplotlib-23299": "diff --git a/lib/matplotlib/tests/test_rcparams.py b/lib/matplotlib/tests/test_rcparams.py\nindex 144880c..aefd7b1 100644\n--- a/lib/matplotlib/tests/test_rcparams.py\n+++ b/lib/matplotlib/tests/test_rcparams.py\n@@ -495,8 +495,29 @@ def test_keymaps():\n     for k in key_list:\n         assert isinstance(mpl.rcParams[k], list)\n \n-\n-def test_rcparams_reset_after_fail():\n+import matplotlib.pyplot as plt\n+from matplotlib import get_backend, rc_context\n+from matplotlib._pylab_helpers import Gcf\n+\n+def test_get_backend_does_not_clear_figures():\n+    # Ensure there are no figures initially\n+    Gcf.destroy_all()\n+    \n+    # Create a figure inside an rc_context\n+    with rc_context():\n+        fig = plt.figure()\n+    \n+    # Capture state of Gcf before calling get_backend()\n+    before = f'{id(Gcf)} {Gcf.figs!r}'\n+    \n+    # Call get_backend()\n+    get_backend()\n+    \n+    # Capture state of Gcf after calling get_backend()\n+    after = f'{id(Gcf)} {Gcf.figs!r}'\n+    \n+    # The state should remain the same, ensuring figures are not cleared\n+    assert before == after, \"Figures were cleared after calling get_backend()\"\n     # There was previously a bug that meant that if rc_context failed and\n     # raised an exception due to issues in the supplied rc parameters, the\n     # global rc parameters were left in a modified state.\n",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..89d1a62 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -12,8 +12,8 @@ from matplotlib.testing.decorators import image_comparison, check_figures_equal\n from matplotlib.testing.widgets import mock_event\n from matplotlib.collections import LineCollection, PolyCollection\n from matplotlib.patches import Circle\n-\n import matplotlib.pyplot as plt\n+from matplotlib.testing.decorators import check_figures_equal\n import numpy as np\n \n \n",
  "matplotlib__matplotlib-23412": "diff --git a/lib/matplotlib/tests/test_patches.py b/lib/matplotlib/tests/test_patches.py\nindex 6db3e7e..e422823 100644\n--- a/lib/matplotlib/tests/test_patches.py\n+++ b/lib/matplotlib/tests/test_patches.py\n@@ -149,6 +149,11 @@ def test_rotate_rect_draw(fig_test, fig_ref):\n     assert rect_test.get_angle() == angle\n \n \n+import matplotlib.pyplot as plt\n+import numpy as np\n+from matplotlib.patches import Rectangle\n+from matplotlib.testing.decorators import check_figures_equal\n+\n def test_negative_rect():\n     # These two rectangles have the same vertices, but starting from a\n     # different point.  (We also drop the last vertex, which is a duplicate.)\n",
  "matplotlib__matplotlib-24026": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex f408084..a97aae4 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -2866,8 +2866,24 @@ def test_stackplot():\n     ax.set_xlim((0, 10))\n     ax.set_ylim((0, 70))\n \n-\n-@image_comparison(['stackplot_test_baseline'], remove_text=True)\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.patches import Rectangle\n+from matplotlib.testing.decorators import image_comparison\n+\n+def test_stackplot_color_cycler():\n+    x = np.array([1, 2, 3])\n+    y = np.array([[1, 1, 1], [1, 2, 3], [4, 3, 2]])\n+    fig, ax = plt.subplots()\n+    \n+    # Test if colors with 'C' alias work without changing cycler\n+    ax.plot([1, 3], [1, 3], color='C0')  # Use color 'C0'\n+    ax.add_patch(Rectangle(xy=(1.5, 1.5), width=0.5, height=0.5, facecolor='C1'))  # Use color 'C1'\n+    ax.stackplot(x, y, colors=['C2', 'C3', 'C4'])  # Use colors 'C2', 'C3', 'C4'\n+\n+    # Verify that no errors were raised and plot appears correct\n+    # Execution alone is the test for no errors, but you could extend this\n+    plt.close(fig)  # Close the plot as the test is for errors only\n def test_stackplot_baseline():\n     np.random.seed(0)\n \n",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24570": "",
  "matplotlib__matplotlib-24627": "",
  "matplotlib__matplotlib-24637": "",
  "matplotlib__matplotlib-24970": "diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex 2be14fe..39100fe 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -20,6 +20,32 @@ import matplotlib.scale as mscale\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n \n \n+import pytest\n+import numpy as np\n+import matplotlib as mpl\n+from numpy.testing import assert_array_equal\n+\n+@pytest.mark.parametrize(\"dtype\", [np.uint8, int, np.float16, float])\n+def test_index_dtype(dtype):\n+    # We use subtraction in the indexing, so need to verify that uint8 works\n+    cm = mpl.colormaps[\"viridis\"]\n+    assert_array_equal(cm(dtype(0)), cm(0))\n+\n+def test_deprecation_warnings_no_occur():\n+    # Testing no deprecation warnings occur when using colormap with specific input\n+    cm = mpl.colormaps[\"viridis\"]\n+    with pytest.warns(None) as record:\n+        cm(np.array([0, 1, 255], dtype=np.uint8))\n+    assert len(record) == 0, \"Unexpected deprecation warnings detected.\"\n+\n+def test_boundary_values():\n+    cm = mpl.colormaps[\"viridis\"]\n+    # Test with boundary values\n+    with pytest.warns(None) as record:\n+        cm(-1)\n+        cm(256)\n+    assert len(record) == 0, \"Unexpected deprecation warnings detected for boundary values.\"\n+\n @pytest.mark.parametrize('N, result', [\n     (5, [1, .6, .2, .1, 0]),\n     (2, [1, 0]),\n",
  "matplotlib__matplotlib-25122": "",
  "matplotlib__matplotlib-25287": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex c24a832..0705001 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -7800,8 +7800,29 @@ def test_xtickcolor_is_not_xticklabelcolor():\n         assert tick.tick1line.get_color() == 'yellow'\n         assert tick.label1.get_color() == 'blue'\n \n+import matplotlib.pyplot as plt\n+import pytest\n+\n+def test_xaxis_offsetText_color():\n+    plt.rcParams['xtick.labelcolor'] = 'blue'\n+    ax = plt.axes()\n+    assert ax.xaxis.offsetText.get_color() == 'blue'\n+\n+    plt.rcParams['xtick.color'] = 'yellow'\n+    plt.rcParams['xtick.labelcolor'] = 'inherit'\n+    ax = plt.axes()\n+    assert ax.xaxis.offsetText.get_color() == 'yellow'\n+\n \n-def test_ytickcolor_is_not_yticklabelcolor():\n+def test_yaxis_offsetText_color():\n+    plt.rcParams['ytick.labelcolor'] = 'green'\n+    ax = plt.axes()\n+    assert ax.yaxis.offsetText.get_color() == 'green'\n+\n+    plt.rcParams['ytick.color'] = 'red'\n+    plt.rcParams['ytick.labelcolor'] = 'inherit'\n+    ax = plt.axes()\n+    assert ax.yaxis.offsetText.get_color() == 'red'\n     plt.rcParams['ytick.color'] = 'yellow'\n     plt.rcParams['ytick.labelcolor'] = 'blue'\n     ax = plt.axes()\n",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..f725158 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -89,8 +90,7 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n-\n-@mpl.style.context(\"default\")\n+import pickletools\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..d9cc2e4 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -90,8 +90,37 @@ def _generate_complete_test_figure(fig_ref):\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n \n-@mpl.style.context(\"default\")\n-@check_figures_equal(extensions=[\"png\"])\n+def test_pickle_figure_with_aligned_labels():\n+    import matplotlib.pyplot as plt\n+    import pickle\n+\n+    # Create figure and axes\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    \n+    # Sample data\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    \n+    # Plot data\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+    \n+    # Call align_labels\n+    fig.align_labels()\n+    \n+    # Try to pickle the figure\n+    try:\n+        pickle.dumps(fig)\n+        print(\"Pickling successful\")\n+    except Exception as e:\n+        print(\"Pickling failed:\", str(e))\n+    \n+    plt.close(fig)\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n     # plotting is done, now test its pickle-ability\n",
  "matplotlib__matplotlib-25775": "",
  "matplotlib__matplotlib-26113": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex ebe9106..84dcc2c 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -992,6 +992,85 @@ def test_hexbin_linear():\n               reduce_C_function=np.sum)\n \n \n+@check_figures_equal(extensions=['png'])\n+def test_hexbin_mincnt_behavior_upon_C_parameter(fig_test, fig_ref):\n+    # see: gh:12926\n+    datapoints = [\n+        # list of (x, y)\n+        (0, 0),\n+        (0, 0),\n+        (6, 0),\n+        (0, 6),\n+    ]\n+    X, Y = zip(*datapoints)\n+    C = [1] * len(X)\n+    extent = [-10., 10, -10., 10]\n+    gridsize = (7, 7)\n+\n+    ax_test = fig_test.subplots()\n+    ax_ref = fig_ref.subplots()\n+\n+    # without C parameter\n+    ax_ref.hexbin(\n+        X, Y,\n+        extent=extent,\n+        gridsize=gridsize,\n+        mincnt=1,\n+    )\n+    ax_ref.set_facecolor(\"green\")  # for contrast of background\n+\n+    # with C parameter\n+    ax_test.hexbin(\n+        X, Y,\n+        C=[1] * len(X),\n+        reduce_C_function=lambda v: sum(v),\n+        mincnt=1,\n+        extent=extent,\n+        gridsize=gridsize,\n+    )\n+    ax_test.set_facecolor(\"green\")\n+\n+\n+@check_figures_equal(extensions=['png'])\n+def test_hexbin_mincnt_zero_behavior_upon_C_parameter(fig_test, fig_ref):\n+    # Additional test to verify mincnt=0 with/without C parameter\n+    datapoints = [\n+        # list of (x, y)\n+        (0, 0),\n+        (0, 0),\n+        (6, 0),\n+        (0, 6),\n+    ]\n+    X, Y = zip(*datapoints)\n+    C = [1] * len(X)\n+    extent = [-10., 10, -10., 10]\n+    gridsize = (7, 7)\n+\n+    ax_test = fig_test.subplots()\n+    ax_ref = fig_ref.subplots()\n+\n+    # without C parameter\n+    ax_ref.hexbin(\n+        X, Y,\n+        extent=extent,\n+        gridsize=gridsize,\n+        mincnt=0,\n+    )\n+    ax_ref.set_facecolor(\"red\")  # different contrast color\n+\n+    # with C parameter\n+    ax_test.hexbin(\n+        X, Y,\n+        C=[1] * len(X),\n+        reduce_C_function=lambda v: sum(v),\n+        mincnt=0,\n+        extent=extent,\n+        gridsize=gridsize,\n+    )\n+    ax_test.set_facecolor(\"red\")\n+\n+from matplotlib.testing.decorators import check_figures_equal\n+\n def test_hexbin_log_clim():\n     x, y = np.arange(200).reshape((2, 100))\n     fig, ax = plt.subplots()\n",
  "matplotlib__matplotlib-26291": "",
  "matplotlib__matplotlib-26342": "diff --git a/lib/matplotlib/tests/test_contour.py b/lib/matplotlib/tests/test_contour.py\nindex 700190c..f0f922b 100644\n--- a/lib/matplotlib/tests/test_contour.py\n+++ b/lib/matplotlib/tests/test_contour.py\n@@ -89,6 +89,41 @@ def test_contour_no_valid_levels():\n     ax.contour(np.ones((9, 9)))\n \n \n+from matplotlib.testing.decorators import check_figures_equal\n+\n+@check_figures_equal(extensions=['png'])\n+def test_contour_set_paths_identity(fig_test, fig_ref):\n+    \"\"\"Test that set_paths with identity retains the original paths.\"\"\"\n+    x = [[0, 1], [1, 2]]\n+    ax_test = fig_test.subplots()\n+    ax_ref = fig_ref.subplots()\n+    \n+    cs_test = ax_test.contour(x)\n+    cs_ref = ax_ref.contour(x)\n+\n+    # Set paths of cs_test to its own paths (identity)\n+    cs_test.set_paths(cs_test.get_paths())\n+\n+    # The paths and visuals should remain the same\n+    assert cs_test.get_paths() == cs_ref.get_paths()\n+\n+@check_figures_equal(extensions=['png'])\n+def test_contour_set_paths_different(fig_test, fig_ref):\n+    \"\"\"Test that set_paths changes the paths to the new ones provided.\"\"\"\n+    x = [[0, 1], [1, 2]]\n+    y = [[1, 0], [2, 1]]\n+    ax_test = fig_test.subplots()\n+    ax_ref = fig_ref.subplots()\n+    \n+    cs_test = ax_test.contour(x)\n+    cs_ref = ax_ref.contour(y)\n+\n+    # Set paths of cs_test to paths of cs_ref\n+    cs_test.set_paths(cs_ref.get_paths())\n+\n+    # The paths should now be the same as cs_ref\n+    assert cs_test.get_paths() == cs_ref.get_paths()\n+\n def test_contour_Nlevels():\n     # A scalar levels arg or kwarg should trigger auto level generation.\n     # https://github.com/matplotlib/matplotlib/issues/11913\n",
  "mwaskom__seaborn-3069": "diff --git a/tests/_core/test_plot.py b/tests/_core/test_plot.py\nindex 3d202bc..b7d9398 100644\n--- a/tests/_core/test_plot.py\n+++ b/tests/_core/test_plot.py\n@@ -661,7 +661,39 @@ class TestPlotting:\n         Plot().plot()\n         assert m.n_splits == 0\n \n-    def test_single_split_single_layer(self, long_df):\n+    def test_nominal_x_axis_with_custom_ticks(self):\n+        \"\"\"Test x-axis limits with custom ticks for nominal scales.\"\"\"\n+        p = Plot(x=[\"a\", \"b\", \"c\", \"d\"], y=[1, 2, 3, 4]).scale(x=Nominal())\n+        ax1 = p.plot()._figure.axes[0]\n+        assert ax1.get_xlim() == (-.5, 3.5), \"X-axis limits should be set to -0.5, n-0.5 for nominal scales.\"\n+        \n+        # Changing the x limits explicitly\n+        lim = (0, 3)\n+        ax2 = p.limit(x=lim).plot()._figure.axes[0]\n+        assert ax2.get_xlim() == lim, \"Explicit x limits should override automatic nominal scaling.\"\n+\n+    def test_nominal_y_axis_with_custom_ticks(self):\n+        \"\"\"Test y-axis limits with custom ticks for nominal scales.\"\"\"\n+        p = Plot(x=[1, 2, 3, 4], y=[\"a\", \"b\", \"c\", \"d\"]).scale(y=Nominal())\n+        ax1 = p.plot()._figure.axes[0]\n+        assert ax1.get_ylim() == (3.5, -.5), \"Y-axis limits should be inverted from n-0.5 to -0.5 for nominal scales.\"\n+\n+        # Changing the y limits explicitly\n+        lim = (0, 3)\n+        ax2 = p.limit(y=lim).plot()._figure.axes[0]\n+        assert ax2.get_ylim() == lim, \"Explicit y limits should override automatic nominal scaling.\"\n+\n+    def test_nominal_x_axis_with_grid(self):\n+        \"\"\"Test the visibility of grid lines for nominal scales on the x-axis.\"\"\"\n+        p = Plot(x=[\"a\", \"b\", \"c\"], y=[1, 2, 3]).scale(x=Nominal())\n+        ax1 = p.plot()._figure.axes[0]\n+        assert not any(x.get_visible() for x in ax1.xaxis.get_gridlines()), \"Grid lines should not be visible by default on a nominal x-axis.\"\n+\n+    def test_nominal_y_axis_with_grid(self):\n+        \"\"\"Test the visibility of grid lines for nominal scales on the y-axis.\"\"\"\n+        p = Plot(x=[1, 2, 3], y=[\"a\", \"b\", \"c\"]).scale(y=Nominal())\n+        ax1 = p.plot()._figure.axes[0]\n+        assert not any(y.get_visible() for y in ax1.yaxis.get_gridlines()), \"Grid lines should not be visible by default on a nominal y-axis.\"\n \n         m = MockMark()\n         p = Plot(long_df, x=\"f\", y=\"z\").add(m).plot()\n",
  "pallets__flask-5014": "diff --git a/tests/test_blueprints.py b/tests/test_blueprints.py\nindex 94a27b3..345bfc5 100644\n--- a/tests/test_blueprints.py\n+++ b/tests/test_blueprints.py\n@@ -244,6 +244,27 @@ def test_default_static_max_age(app):\n         app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n \n \n+def test_empty_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"\", __name__)\n+\n+def test_non_empty_name_allowed(app, client):\n+    try:\n+        blueprint = flask.Blueprint(\"valid_name\", __name__)\n+    except ValueError:\n+        pytest.fail(\"Blueprint name should allow non-empty names\")\n+\n+def test_whitespace_only_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"   \", __name__)\n+\n+def test_dotted_name_not_allowed(app, client):\n+    with pytest.raises(ValueError):\n+        flask.Blueprint(\"app.ui\", __name__)\n+\n+import pytest\n+import flask\n+\n def test_templates_list(test_apps):\n     from blueprintapp import app\n \n",
  "psf__requests-1142": "diff --git a/requests/models.py b/requests/models.py\nindex 0d4482a..82b3872 100644\n--- a/requests/models.py\n+++ b/requests/models.py\n@@ -386,7 +386,9 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):\n         self.body = body\n \n     def prepare_content_length(self, body):\n-        self.headers['Content-Length'] = '0'\n+        # Only set Content-Length if the body exists\n+        if body:\n+            self.headers['Content-Length'] = '0'\n         if hasattr(body, 'seek') and hasattr(body, 'tell'):\n             body.seek(0, 2)\n             self.headers['Content-Length'] = str(body.tell())\n",
  "psf__requests-1724": "",
  "psf__requests-1766": "diff --git a/requests/auth.py b/requests/auth.py\nindex ff8249e..1e74f21 100644\n--- a/requests/auth.py\n+++ b/requests/auth.py\n@@ -144,7 +144,8 @@ class HTTPDigestAuth(AuthBase):\n         if entdig:\n             base += ', digest=\"%s\"' % entdig\n         if qop:\n-            base += ', qop=auth, nc=%s, cnonce=\"%s\"' % (ncvalue, cnonce)\n+            # Ensuring the qop is quoted as per RFC2617\n+            base += ', qop=\"%s\", nc=%s, cnonce=\"%s\"' % (qop, ncvalue, cnonce)\n \n         return 'Digest %s' % (base)\n \n",
  "psf__requests-1921": "",
  "psf__requests-2317": "",
  "psf__requests-2931": "",
  "psf__requests-5414": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 7279149..0672338 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -81,6 +81,18 @@ class TestRequests:\n             (InvalidSchema, 'localhost.localdomain:3128/'),\n             (InvalidSchema, '10.122.1.1:3128/'),\n             (InvalidURL, 'http://'),\n+            (InvalidURL, 'http://*example.com'),\n+            (InvalidURL, 'http://.example.com'),\n+        ))\n+    def test_invalid_url(self, exception, url):\n+        with pytest.raises(exception):\n+            requests.get(url)\n+\n+    @pytest.mark.parametrize(\n+        'exception, url', (\n+            (InvalidURL, 'http://..example.com'),\n+            (InvalidURL, 'http://example..com'),\n+            (InvalidURL, 'http://.sub.example.com'),\n         ))\n     def test_invalid_url(self, exception, url):\n         with pytest.raises(exception):\n",
  "pydata__xarray-2905": "diff --git a/xarray/tests/test_variable.py b/xarray/tests/test_variable.py\nindex e1452a7..7b39caf 100644\n--- a/xarray/tests/test_variable.py\n+++ b/xarray/tests/test_variable.py\n@@ -2308,6 +2308,31 @@ class TestAsCompatibleData:\n         orig = Variable(dims=(\"x\"), data=array, attrs={\"foo\": \"bar\"})\n         assert isinstance(orig._data, CustomIndexable)\n \n+def test_variable_setitem_with_values_property():\n+    import numpy as np\n+    from xarray import Variable\n+\n+    # Verify that objects with a 'values' property don't get coerced\n+    class HasValues:\n+        values = 5\n+\n+    # Create a Variable with object dtype to store arbitrary objects\n+    obj_var = Variable(dims=(\"x\"), data=[None], attrs={\"foo\": \"bar\"})\n+    obj_var[{\"x\": 0}] = HasValues()\n+\n+    # Check that the object is stored correctly, not coerced\n+    assert isinstance(obj_var.values[0], HasValues)\n+    assert obj_var.values.dtype == object\n+\n+    # Ensure no alterations to the original functionality with other test cases\n+    class CustomWithValuesAttr:\n+        def __init__(self, array):\n+            self.values = array\n+\n+    array = CustomWithValuesAttr(np.arange(3))\n+    orig = Variable(dims=(), data=array)\n+    assert isinstance(orig._data.item(), CustomWithValuesAttr)\n+\n \n def test_raise_no_warning_for_nan_in_binary_ops():\n     with pytest.warns(None) as record:\n",
  "pydata__xarray-3095": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex d6a4400..9e40114 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -2107,7 +2107,18 @@ class TestDataset:\n \n         assert_identical(ds.coords['a'], expected_orig)\n \n-    def test_copy_with_data_errors(self):\n+    def test_unicode_copy_regression(self):\n+        ds = xr.Dataset(\n+            coords={'x': ['foo'], 'y': ('x', ['bar'])},\n+            data_vars={'z': ('x', ['baz'])}\n+        )\n+        # Deep copy should not change the dtype of IndexVariable from '<U*' to object\n+        copied = ds.copy(deep=True)\n+        assert ds.x.dtype.kind == copied.x.dtype.kind == 'U'\n+        assert ds.y.dtype.kind == copied.y.dtype.kind == 'U'\n+        assert ds.z.dtype.kind == copied.z.dtype.kind == 'U'\n+        # Ensure the copy works correctly with the same output\n+        assert_identical(ds, copied)\n         orig = create_test_data()\n         new_var1 = np.arange(orig['var1'].size).reshape(orig['var1'].shape)\n         with raises_regex(ValueError, 'Data must be dict-like'):\n",
  "pydata__xarray-3151": "diff --git a/xarray/tests/test_combine.py b/xarray/tests/test_combine.py\nindex 026dec9..8b1d381 100644\n--- a/xarray/tests/test_combine.py\n+++ b/xarray/tests/test_combine.py\n@@ -533,6 +533,24 @@ class TestManualCombine:\n                                 fill_value=fill_value)\n         assert_identical(expected, actual)\n \n+    def test_combine_non_monotonic_identical_coords(self):\n+        # Ensure non-monotonic but identical coordinates do not raise an error\n+        ycoord = ['b', 'a', 'c']\n+\n+        data = np.random.rand(7, 3)\n+\n+        ds1 = Dataset(data_vars=dict(data=(['x', 'y'], data[:3, :])),\n+                      coords=dict(x=[1, 2, 3], y=ycoord))\n+\n+        ds2 = Dataset(data_vars=dict(data=(['x', 'y'], data[3:, :])),\n+                      coords=dict(x=[4, 5, 6, 7], y=ycoord))\n+\n+        expected = Dataset(data_vars=dict(data=(['x', 'y'], data)),\n+                           coords=dict(x=[1, 2, 3, 4, 5, 6, 7], y=ycoord))\n+\n+        actual = combine_by_coords((ds1, ds2))\n+        assert_identical(expected, actual)\n+\n \n class TestCombineAuto:\n     def test_combine_by_coords(self):\n@@ -541,14 +559,68 @@ class TestCombineAuto:\n         expected = Dataset({'x': [0, 1]})\n         assert_identical(expected, actual)\n \n+    def test_combine_non_monotonic_identical_coords(self):\n+        # Ensure non-monotonic but identical coordinates do not raise an error\n+        ycoord = ['b', 'a', 'c']\n+\n+        data = np.random.rand(7, 3)\n+\n+        ds1 = Dataset(data_vars=dict(data=(['x', 'y'], data[:3, :])),\n+                      coords=dict(x=[1, 2, 3], y=ycoord))\n+\n+        ds2 = Dataset(data_vars=dict(data=(['x', 'y'], data[3:, :])),\n+                      coords=dict(x=[4, 5, 6, 7], y=ycoord))\n+\n+        expected = Dataset(data_vars=dict(data=(['x', 'y'], data)),\n+                           coords=dict(x=[1, 2, 3, 4, 5, 6, 7], y=ycoord))\n+\n+        actual = combine_by_coords((ds1, ds2))\n+        assert_identical(expected, actual)\n+\n         actual = combine_by_coords([actual])\n         assert_identical(expected, actual)\n \n+    def test_combine_non_monotonic_identical_coords(self):\n+        # Ensure non-monotonic but identical coordinates do not raise an error\n+        ycoord = ['b', 'a', 'c']\n+\n+        data = np.random.rand(7, 3)\n+\n+        ds1 = Dataset(data_vars=dict(data=(['x', 'y'], data[:3, :])),\n+                      coords=dict(x=[1, 2, 3], y=ycoord))\n+\n+        ds2 = Dataset(data_vars=dict(data=(['x', 'y'], data[3:, :])),\n+                      coords=dict(x=[4, 5, 6, 7], y=ycoord))\n+\n+        expected = Dataset(data_vars=dict(data=(['x', 'y'], data)),\n+                           coords=dict(x=[1, 2, 3, 4, 5, 6, 7], y=ycoord))\n+\n+        actual = combine_by_coords((ds1, ds2))\n+        assert_identical(expected, actual)\n+\n         objs = [Dataset({'x': [0, 1]}), Dataset({'x': [2]})]\n         actual = combine_by_coords(objs)\n         expected = Dataset({'x': [0, 1, 2]})\n         assert_identical(expected, actual)\n \n+    def test_combine_non_monotonic_identical_coords(self):\n+        # Ensure non-monotonic but identical coordinates do not raise an error\n+        ycoord = ['b', 'a', 'c']\n+\n+        data = np.random.rand(7, 3)\n+\n+        ds1 = Dataset(data_vars=dict(data=(['x', 'y'], data[:3, :])),\n+                      coords=dict(x=[1, 2, 3], y=ycoord))\n+\n+        ds2 = Dataset(data_vars=dict(data=(['x', 'y'], data[3:, :])),\n+                      coords=dict(x=[4, 5, 6, 7], y=ycoord))\n+\n+        expected = Dataset(data_vars=dict(data=(['x', 'y'], data)),\n+                           coords=dict(x=[1, 2, 3, 4, 5, 6, 7], y=ycoord))\n+\n+        actual = combine_by_coords((ds1, ds2))\n+        assert_identical(expected, actual)\n+\n         # ensure auto_combine handles non-sorted variables\n         objs = [Dataset({'x': ('a', [0]), 'y': ('a', [0]), 'a': [0]}),\n                 Dataset({'x': ('a', [1]), 'y': ('a', [1]), 'a': [1]})]\n@@ -557,6 +629,24 @@ class TestCombineAuto:\n                             'a': [0, 1]})\n         assert_identical(expected, actual)\n \n+    def test_combine_non_monotonic_identical_coords(self):\n+        # Ensure non-monotonic but identical coordinates do not raise an error\n+        ycoord = ['b', 'a', 'c']\n+\n+        data = np.random.rand(7, 3)\n+\n+        ds1 = Dataset(data_vars=dict(data=(['x', 'y'], data[:3, :])),\n+                      coords=dict(x=[1, 2, 3], y=ycoord))\n+\n+        ds2 = Dataset(data_vars=dict(data=(['x', 'y'], data[3:, :])),\n+                      coords=dict(x=[4, 5, 6, 7], y=ycoord))\n+\n+        expected = Dataset(data_vars=dict(data=(['x', 'y'], data)),\n+                           coords=dict(x=[1, 2, 3, 4, 5, 6, 7], y=ycoord))\n+\n+        actual = combine_by_coords((ds1, ds2))\n+        assert_identical(expected, actual)\n+\n         objs = [Dataset({'x': [0], 'y': [0]}), Dataset({'y': [1], 'x': [1]})]\n         actual = combine_by_coords(objs)\n         expected = Dataset({'x': [0, 1], 'y': [0, 1]})\n@@ -592,6 +682,24 @@ class TestCombineAuto:\n         actual = combine_by_coords(datasets)\n         assert_identical(expected, actual)\n \n+    def test_combine_non_monotonic_identical_coords(self):\n+        # Ensure non-monotonic but identical coordinates do not raise an error\n+        ycoord = ['b', 'a', 'c']\n+\n+        data = np.random.rand(7, 3)\n+\n+        ds1 = Dataset(data_vars=dict(data=(['x', 'y'], data[:3, :])),\n+                      coords=dict(x=[1, 2, 3], y=ycoord))\n+\n+        ds2 = Dataset(data_vars=dict(data=(['x', 'y'], data[3:, :])),\n+                      coords=dict(x=[4, 5, 6, 7], y=ycoord))\n+\n+        expected = Dataset(data_vars=dict(data=(['x', 'y'], data)),\n+                           coords=dict(x=[1, 2, 3, 4, 5, 6, 7], y=ycoord))\n+\n+        actual = combine_by_coords((ds1, ds2))\n+        assert_identical(expected, actual)\n+\n     def test_combine_by_coords_still_fails(self):\n         # concat can't handle new variables (yet):\n         # https://github.com/pydata/xarray/issues/508\n@@ -606,11 +714,47 @@ class TestCombineAuto:\n         expected = Dataset({'x': 0, 'y': 1})\n         assert_identical(expected, actual)\n \n+    def test_combine_non_monotonic_identical_coords(self):\n+        # Ensure non-monotonic but identical coordinates do not raise an error\n+        ycoord = ['b', 'a', 'c']\n+\n+        data = np.random.rand(7, 3)\n+\n+        ds1 = Dataset(data_vars=dict(data=(['x', 'y'], data[:3, :])),\n+                      coords=dict(x=[1, 2, 3], y=ycoord))\n+\n+        ds2 = Dataset(data_vars=dict(data=(['x', 'y'], data[3:, :])),\n+                      coords=dict(x=[4, 5, 6, 7], y=ycoord))\n+\n+        expected = Dataset(data_vars=dict(data=(['x', 'y'], data)),\n+                           coords=dict(x=[1, 2, 3, 4, 5, 6, 7], y=ycoord))\n+\n+        actual = combine_by_coords((ds1, ds2))\n+        assert_identical(expected, actual)\n+\n         objs = [Dataset({'x': 0, 'y': 1}), Dataset({'y': np.nan, 'z': 2})]\n         actual = combine_by_coords(objs)\n         expected = Dataset({'x': 0, 'y': 1, 'z': 2})\n         assert_identical(expected, actual)\n \n+    def test_combine_non_monotonic_identical_coords(self):\n+        # Ensure non-monotonic but identical coordinates do not raise an error\n+        ycoord = ['b', 'a', 'c']\n+\n+        data = np.random.rand(7, 3)\n+\n+        ds1 = Dataset(data_vars=dict(data=(['x', 'y'], data[:3, :])),\n+                      coords=dict(x=[1, 2, 3], y=ycoord))\n+\n+        ds2 = Dataset(data_vars=dict(data=(['x', 'y'], data[3:, :])),\n+                      coords=dict(x=[4, 5, 6, 7], y=ycoord))\n+\n+        expected = Dataset(data_vars=dict(data=(['x', 'y'], data)),\n+                           coords=dict(x=[1, 2, 3, 4, 5, 6, 7], y=ycoord))\n+\n+        actual = combine_by_coords((ds1, ds2))\n+        assert_identical(expected, actual)\n+\n     def test_check_for_impossible_ordering(self):\n         ds0 = Dataset({'x': [0, 1, 5]})\n         ds1 = Dataset({'x': [2, 3]})\n",
  "pydata__xarray-3305": "diff --git a/xarray/tests/test_dataarray.py b/xarray/tests/test_dataarray.py\nindex b0e2440..7161f62 100644\n--- a/xarray/tests/test_dataarray.py\n+++ b/xarray/tests/test_dataarray.py\n@@ -2309,8 +2309,18 @@ class TestDataArray:\n                     self.dv.values, np.array(q) * 100, axis=axis\n                 )\n                 np.testing.assert_allclose(actual.values, expected)\n-\n-    def test_reduce_keep_attrs(self):\n+    \n+    def test_quantile_keep_attrs(self):\n+        import xarray as xr\n+\n+        # Create a DataArray with an attribute\n+        da = xr.DataArray([0, 0], dims=\"x\", attrs={'units':'K'})\n+        \n+        # Use the quantile method with keep_attrs=True\n+        out = da.quantile(.9, dim='x', keep_attrs=True)\n+        \n+        # Assert that the attributes are preserved\n+        assert out.attrs == da.attrs\n         # Test dropped attrs\n         vm = self.va.mean()\n         assert len(vm.attrs) == 0\n",
  "pydata__xarray-3677": "diff --git a/xarray/tests/test_merge.py b/xarray/tests/test_merge.py\nindex cd14bf3..357191d 100644\n--- a/xarray/tests/test_merge.py\n+++ b/xarray/tests/test_merge.py\n@@ -1,3 +1,4 @@\n+\n import numpy as np\n import pytest\n \n@@ -215,6 +216,22 @@ class TestMergeMethod:\n         assert expected.identical(ds1.merge(ds2, join=\"inner\"))\n         assert expected.identical(ds2.merge(ds1, join=\"inner\"))\n \n+    def test_merge_dataarray(self):\n+        ds = xr.Dataset({\"a\": 0})\n+        da = xr.DataArray(data=1, name=\"b\")\n+\n+        # Test that ds.merge(da) works as expected\n+        expected = xr.merge([ds, da])\n+        actual = ds.merge(da)\n+        assert_identical(expected, actual)\n+\n+        # Test merging when there's overlap in variable names\n+        ds2 = xr.Dataset({\"b\": 2})\n+        expected_overlap = xr.merge([ds2, da])\n+        actual_overlap = ds2.merge(da)\n+        assert_identical(expected_overlap, actual_overlap)\n+        assert actual_overlap[\"b\"].values == 1  # Ensures `da` has priority in merging\n+\n     @pytest.mark.parametrize(\"fill_value\", [dtypes.NA, 2, 2.0])\n     def test_merge_fill_value(self, fill_value):\n         ds1 = xr.Dataset({\"a\": (\"x\", [1, 2]), \"x\": [0, 1]})\n",
  "pydata__xarray-4075": "",
  "pydata__xarray-4356": "diff --git a/xarray/tests/test_duck_array_ops.py b/xarray/tests/test_duck_array_ops.py\nindex 0c63f0f..c9a1763 100644\n--- a/xarray/tests/test_duck_array_ops.py\n+++ b/xarray/tests/test_duck_array_ops.py\n@@ -603,18 +603,21 @@ def test_min_count_dataset(func):\n     expected = getattr(ds[\"var1\"], func)(dim=\"x\", skipna=True, min_count=3)\n     assert_allclose(actual, expected)\n \n-\n @pytest.mark.parametrize(\"dtype\", [float, int, np.float32, np.bool_])\n @pytest.mark.parametrize(\"dask\", [False, True])\n @pytest.mark.parametrize(\"func\", [\"sum\", \"prod\"])\n-def test_multiple_dims(dtype, dask, func):\n+def test_min_count_multiple_dims(dtype, dask, func):\n     if dask and not has_dask:\n         pytest.skip(\"requires dask\")\n+\n+    min_count = 2\n     da = construct_dataarray(3, dtype, contains_nan=True, dask=dask)\n \n-    actual = getattr(da, func)((\"x\", \"y\"))\n-    expected = getattr(getattr(da, func)(\"x\"), func)(\"y\")\n+    actual = getattr(da, func)((\"x\", \"y\"), skipna=True, min_count=min_count)\n+    expected = getattr(getattr(da, func)(\"x\", skipna=True, min_count=min_count), func)(\"y\", skipna=True, min_count=min_count)\n+\n     assert_allclose(actual, expected)\n+    assert_dask_array(actual, dask)\n \n \n def test_docs():\n",
  "pydata__xarray-4629": "diff --git a/xarray/tests/test_merge.py b/xarray/tests/test_merge.py\nindex ef48e47..bd4cf64 100644\n--- a/xarray/tests/test_merge.py\n+++ b/xarray/tests/test_merge.py\n@@ -109,7 +109,29 @@ class TestMergeFunction:\n             expected.attrs = expected_attrs\n             assert actual.identical(expected)\n \n-    def test_merge_dicts_simple(self):\n+    def test_merge_attrs_override_copy(self):\n+        ds1 = xr.Dataset(attrs={\"x\": 0})\n+        ds2 = xr.Dataset(attrs={\"x\": 1})\n+        ds3 = xr.merge([ds1, ds2], combine_attrs=\"override\")\n+        ds3.attrs[\"x\"] = 2\n+        assert ds1.attrs[\"x\"] == 0\n+        assert ds3.attrs[\"x\"] == 2\n+\n+    def test_merge_attrs_override_no_shared_attr(self):\n+        ds1 = xr.Dataset(attrs={\"x\": 0})\n+        ds2 = xr.Dataset(attrs={\"y\": 1})\n+        ds3 = xr.merge([ds1, ds2], combine_attrs=\"override\")\n+        ds3.attrs[\"x\"] = 2\n+        assert ds1.attrs[\"x\"] == 0\n+        assert \"y\" not in ds3.attrs\n+\n+    def test_merge_attrs_override_with_shared_attr(self):\n+        ds1 = xr.Dataset(attrs={\"x\": 0, \"shared\": \"a\"})\n+        ds2 = xr.Dataset(attrs={\"x\": 1, \"shared\": \"b\"})\n+        ds3 = xr.merge([ds1, ds2], combine_attrs=\"override\")\n+        ds3.attrs[\"shared\"] = \"c\"\n+        assert ds1.attrs[\"shared\"] == \"a\"\n+        assert ds3.attrs[\"shared\"] == \"c\"\n         actual = xr.merge([{\"foo\": 0}, {\"bar\": \"one\"}, {\"baz\": 3.5}])\n         expected = xr.Dataset({\"foo\": 0, \"bar\": \"one\", \"baz\": 3.5})\n         assert actual.identical(expected)\n",
  "pydata__xarray-4687": "diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex 636c1f4..366c2d2 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -1921,8 +1921,32 @@ def test_where() -> None:\n     expected = xr.DataArray([1, 0], dims=\"x\")\n     assert_identical(expected, actual)\n \n+def test_where_attrs() -> None:\n+    cond = xr.DataArray([True, False], dims=\"x\", attrs={\"attr\": \"cond\"})\n+    x = xr.DataArray([1, 1], dims=\"x\", attrs={\"attr\": \"x\"})\n+    y = xr.DataArray([0, 0], dims=\"x\", attrs={\"attr\": \"y\"})\n+    actual = xr.where(cond, x, y)\n+    expected = xr.DataArray([1, 0], dims=\"x\", attrs={\"attr\": \"x\"})\n+    assert_identical(expected, actual)\n \n-@pytest.mark.parametrize(\"use_dask\", [True, False])\n+def test_where_dtype() -> None:\n+    data = xr.DataArray(np.ones([10,10], dtype=np.int8))\n+    data.attrs[\"attr_1\"] = \"test1\"\n+    data.attrs[\"attr_2\"] = \"test2\"\n+    data2 = xr.where(data == 1, 5, 0)\n+    assert data2.dtype == np.int8\n+\n+    data3 = xr.where(data == 0, 5, 0)\n+    assert data3.dtype == np.int8\n+\n+def test_where_mixed_attrs() -> None:\n+    cond = xr.DataArray([True, False, True], dims=\"x\", attrs={\"attr\": \"cond\"})\n+    x = xr.DataArray([1, 2, 3], dims=\"x\", attrs={\"attr\": \"x\"})\n+    y = xr.DataArray([0, -1, -2], dims=\"x\", attrs={\"attr\": \"y\"})\n+    actual = xr.where(cond, x, y)\n+    expected_attrs = {\"attr\": \"x\"}\n+    assert actual.attrs == expected_attrs\n+    assert (actual.values == np.array([1, -1, 3])).all()\n @pytest.mark.parametrize(\"use_datetime\", [True, False])\n def test_polyval(use_dask, use_datetime) -> None:\n     if use_dask and not has_dask:\n",
  "pydata__xarray-4695": "",
  "pydata__xarray-4966": "diff --git a/xarray/tests/test_coding.py b/xarray/tests/test_coding.py\nindex 2dbb0b4..6b32a2f 100644\n--- a/xarray/tests/test_coding.py\n+++ b/xarray/tests/test_coding.py\n@@ -10,6 +10,32 @@ from xarray.conventions import decode_cf_variable, encode_cf_variable\n \n from . import assert_allclose, assert_equal, assert_identical, requires_dask\n \n+@pytest.mark.parametrize(\"bits\", [1, 2, 4, 8])\n+def test_decode_unsigned_from_signed(bits):\n+    unsigned_dtype = np.dtype(f\"u{bits}\")\n+    signed_dtype = np.dtype(f\"i{bits}\")\n+    original_values = np.array([np.iinfo(unsigned_dtype).max], dtype=unsigned_dtype)\n+    encoded = xr.Variable(\n+        (\"x\",), original_values.astype(signed_dtype), attrs={\"_Unsigned\": \"true\"}\n+    )\n+    coder = variables.UnsignedIntegerCoder()\n+    decoded = coder.decode(encoded)\n+    assert decoded.dtype == unsigned_dtype\n+    assert np.array_equal(decoded.values, original_values)\n+\n+@pytest.mark.parametrize(\"bits\", [1, 2, 4, 8])\n+def test_decode_signed_from_unsigned(bits):\n+    unsigned_dtype = np.dtype(f\"u{bits}\")\n+    signed_dtype = np.dtype(f\"i{bits}\")\n+    original_values = np.array([-1], dtype=signed_dtype)\n+    encoded = xr.Variable(\n+        (\"x\",), original_values.astype(unsigned_dtype), attrs={\"_Unsigned\": \"false\"}\n+    )\n+    coder = variables.UnsignedIntegerCoder()\n+    decoded = coder.decode(encoded)\n+    assert decoded.dtype == signed_dtype\n+    assert np.array_equal(decoded.values, original_values)\n+\n with suppress(ImportError):\n     import dask.array as da\n \n",
  "pydata__xarray-6461": "diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex f0b426a..e79320d 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -1928,6 +1928,12 @@ def test_where_attrs() -> None:\n     expected = xr.DataArray([1, 0], dims=\"x\", attrs={\"attr\": \"x\"})\n     assert_identical(expected, actual)\n \n+def test_where_with_scalar_and_keep_attrs() -> None:\n+    # Test case for the issue with scalar as the second argument and keep_attrs=True\n+    cond = xr.DataArray([True, False, True], dims=\"x\")\n+    actual = xr.where(cond, 1, 0, keep_attrs=True)\n+    expected = xr.DataArray([1, 0, 1], dims=\"x\")\n+    assert_identical(expected, actual)\n \n @pytest.mark.parametrize(\"use_dask\", [True, False])\n @pytest.mark.parametrize(\"use_datetime\", [True, False])\n",
  "pydata__xarray-6599": "diff --git a/xarray/tests/test_computation.py b/xarray/tests/test_computation.py\nindex f1ec005..c0f6173 100644\n--- a/xarray/tests/test_computation.py\n+++ b/xarray/tests/test_computation.py\n@@ -2000,6 +2000,14 @@ def test_where_attrs() -> None:\n             xr.Dataset({\"a\": (\"x\", [1, 2, 3]), \"b\": (\"y\", [3, 4, 5])}),\n             id=\"dataset-dataset\",\n         ),\n+        pytest.param(\n+            xr.DataArray(\n+                np.array([1000, 2000, 3000], dtype=\"timedelta64[ns]\"), dims=\"x\"\n+            ),\n+            xr.DataArray([0, 1], dims=\"degree\", coords={\"degree\": [0, 1]}),\n+            xr.DataArray([1000.0, 2000.0, 3000.0], dims=\"x\"),\n+            id=\"timedelta\",\n+        ),\n         pytest.param(\n             xr.DataArray(pd.date_range(\"1970-01-01\", freq=\"s\", periods=3), dims=\"x\"),\n             xr.DataArray([0, 1], dims=\"degree\", coords={\"degree\": [0, 1]}),\n@@ -2010,6 +2018,14 @@ def test_where_attrs() -> None:\n             ),\n             id=\"datetime\",\n         ),\n+        pytest.param(\n+            xr.DataArray(\n+                np.array([1000, 2000, 3000], dtype=\"timedelta64[ns]\"), dims=\"x\"\n+            ),\n+            xr.DataArray([0, 1], dims=\"degree\", coords={\"degree\": [0, 1]}),\n+            xr.DataArray([1000.0, 2000.0, 3000.0], dims=\"x\"),\n+            id=\"timedelta\",\n+        ),\n     ],\n )\n def test_polyval(\n",
  "pydata__xarray-6721": "",
  "pydata__xarray-6744": "diff --git a/xarray/tests/test_rolling.py b/xarray/tests/test_rolling.py\nindex 0a9ef75..12008ef 100644\n--- a/xarray/tests/test_rolling.py\n+++ b/xarray/tests/test_rolling.py\n@@ -49,6 +49,20 @@ class TestDataArrayRolling:\n                     expected.values[expected.values.nonzero()],\n                 )\n \n+    @pytest.mark.parametrize(\"da\", (1, 2), indirect=True)\n+    @pytest.mark.parametrize(\"size\", [3, 7])\n+    def test_rolling_iter_center(self, da, size) -> None:\n+        # Testing manual iteration with `center=True`\n+        rolling_obj = da.rolling(time=size, center=True)\n+        rolling_obj_mean = rolling_obj.mean()\n+\n+        for i, (label, window_da) in enumerate(rolling_obj):\n+            actual = rolling_obj_mean.isel(time=i)\n+            expected = window_da.mean(\"time\")\n+\n+            # Ensure window_da is center-aligned compared to rolling_obj_mean\n+            np.testing.assert_allclose(actual.values, expected.values)\n+\n     @pytest.mark.parametrize(\"da\", (1,), indirect=True)\n     def test_rolling_repr(self, da) -> None:\n         rolling_obj = da.rolling(time=7)\n",
  "pydata__xarray-7233": "",
  "pydata__xarray-7393": "",
  "pylint-dev__pylint-4970": "",
  "pylint-dev__pylint-6386": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex a0b1b64..48a594b 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -94,9 +94,34 @@ def test_unknown_yes_no(capsys: CaptureFixture) -> None:\n     assert \"Invalid yn value 'maybe', should be in \" in output.err\n \n \n+from pylint.lint import Run\n+import pytest\n+from _pytest.capture import CaptureFixture\n+from some_module import EMPTY_MODULE  # Assuming EMPTY_MODULE is defined here\n+\n+def test_short_verbose(capsys: CaptureFixture) -> None:\n+    \"\"\"Check that we correctly handle the -v flag.\"\"\"\n+    Run([str(EMPTY_MODULE), \"-v\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"Using config file\" in output.err\n+\n+def test_short_verbose_without_argument(capsys: CaptureFixture) -> None:\n+    \"\"\"Ensure -v does not expect an argument and behaves like --verbose.\"\"\"\n+    Run([str(EMPTY_MODULE), \"-v\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"Using config file\" in output.err\n+    assert \"expected one argument\" not in output.err\n+\n+def test_long_verbose_without_argument(capsys: CaptureFixture) -> None:\n+    \"\"\"Ensure --verbose behaves correctly without expecting an argument.\"\"\"\n+    Run([str(EMPTY_MODULE), \"--verbose\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"Using config file\" in output.err\n+    assert \"expected one argument\" not in output.err\n+\n def test_unknown_py_version(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly error on an unknown python-version.\"\"\"\n     with pytest.raises(SystemExit):\n         Run([str(EMPTY_MODULE), \"--py-version=the-newest\"], exit=False)\n     output = capsys.readouterr()\n-    assert \"the-newest has an invalid format, should be a version string.\" in output.err\n+    assert \"the-newest has an invalid format, should be a version string.\" in output.err\n",
  "pylint-dev__pylint-6528": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex 9123ae4..b8fa861 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1233,6 +1233,63 @@ class TestRunTC:\n             expected_output=\"No such file or directory\",\n         )\n \n+    def test_recursive_ignore(self):\n+        \"\"\"Tests recursive run of linter ignoring files and directories using --ignore parameter.\"\"\"\n+        self._runtest(\n+            [\n+                join(HERE, \"regrtest_data\", \"directory\"),\n+                \"--recursive=y\",\n+                \"--ignore=ignored_subdirectory\",\n+            ],\n+            code=0,\n+        )\n+        self._runtest(\n+            [\n+                join(HERE, \"regrtest_data\", \"directory\"),\n+                \"--recursive=y\",\n+                \"--ignore=failing.py\",\n+            ],\n+            code=0,\n+        )\n+\n+    def test_recursive_ignore_patterns(self):\n+        \"\"\"Tests recursive run of linter ignoring files and directories using --ignore-patterns parameter.\"\"\"\n+        self._runtest(\n+            [\n+                join(HERE, \"regrtest_data\", \"directory\"),\n+                \"--recursive=y\",\n+                \"--ignore-patterns=ignored_.*\",\n+            ],\n+            code=0,\n+        )\n+        self._runtest(\n+            [\n+                join(HERE, \"regrtest_data\", \"directory\"),\n+                \"--recursive=y\",\n+                \"--ignore-patterns=failing.*\",\n+            ],\n+            code=0,\n+        )\n+\n+    def test_recursive_ignore_paths(self):\n+        \"\"\"Tests recursive run of linter ignoring files and directories using --ignore-paths parameter.\"\"\"\n+        self._runtest(\n+            [\n+                join(HERE, \"regrtest_data\", \"directory\"),\n+                \"--recursive=y\",\n+                \"--ignore-paths=.*ignored.*\",\n+            ],\n+            code=0,\n+        )\n+        self._runtest(\n+            [\n+                join(HERE, \"regrtest_data\", \"directory\"),\n+                \"--recursive=y\",\n+                \"--ignore-paths=.*failing.*\",\n+            ],\n+            code=0,\n+        )\n+\n     def test_recursive(self):\n         self._runtest(\n             [join(HERE, \"regrtest_data\", \"directory\", \"subdirectory\"), \"--recursive=y\"],\n",
  "pylint-dev__pylint-6903": "",
  "pylint-dev__pylint-7080": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex fa7078d..333d896 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1324,7 +1324,28 @@ class TestRunTC:\n                 if not os.path.basename(path) == \"regrtest_data\"\n             ]\n             with _test_cwd():\n-                os.chdir(join(HERE, \"regrtest_data\", \"directory\", \"subdirectory\"))\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n+                self._runtest(\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^ignored_subdirectory/.*\"],\n+                    code=0,\n+                )\n+\n+    def test_ignore_paths_with_recursive(self) -> None:\n+        \"\"\"Tests that paths specified in ignore-paths are ignored when using --recursive=y.\"\"\"\n+        with _test_sys_path():\n+            # pytest is including directory HERE/regrtest_data to sys.path which causes\n+            # astroid to believe that directory is a package.\n+            sys.path = [\n+                path\n+                for path in sys.path\n+                if not os.path.basename(path) == \"regrtest_data\"\n+            ]\n+            with _test_cwd():\n+                os.chdir(join(HERE, \"regrtest_data\"))\n+                self._runtest(\n+                    [\"directory\", \"--recursive=y\", \"--ignore-paths=^directory/ignored_subdirectory/.*\"],\n+                    code=0,\n+                )\n                 self._runtest(\n                     [\".\", \"--recursive=y\"],\n                     code=0,\n",
  "pylint-dev__pylint-7277": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex 9f95f7b..c1cb4c2 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -751,7 +751,36 @@ a.py:1:4: E0001: Parsing failed: 'invalid syntax (<unknown>, line 1)' (syntax-er\n             \"/usr/local/lib/python3.9/lib-dynload\",\n             \"/usr/local/lib/python3.9/site-packages\",\n         ]\n-        with _test_sys_path(), patch(\"os.getcwd\") as mock_getcwd:\n+        with _test_sys_path(), patch(\"os.getcwd\") as mock_getcwd, patch.dict('os.environ', {}, clear=True):\n+            mock_getcwd.return_value = cwd\n+            \n+            # Test when the first entry is \"\"\n+            paths = [\"\", *default_paths]\n+            sys.path = copy(paths)\n+            with _test_environ_pythonpath():\n+                modify_sys_path()\n+            assert sys.path == paths[1:], 'Failed when first entry is \"\"'\n+            \n+            # Test when the first entry is \".\"\n+            paths = [\".\", *default_paths]\n+            sys.path = copy(paths)\n+            with _test_environ_pythonpath():\n+                modify_sys_path()\n+            assert sys.path == paths[1:], 'Failed when first entry is \".\"'\n+            \n+            # Test when the first entry is os.getcwd()\n+            paths = [cwd, *default_paths]\n+            sys.path = copy(paths)\n+            with _test_environ_pythonpath():\n+                modify_sys_path()\n+            assert sys.path == paths[1:], 'Failed when first entry is the current working directory'\n+            \n+            # Test when the first entry is a non-removable item\n+            paths = [\"/do_not_remove\", *default_paths]\n+            sys.path = copy(paths)\n+            with _test_environ_pythonpath():\n+                modify_sys_path()\n+            assert sys.path == paths, 'Incorrectly removed a non-empty first entry'\n             mock_getcwd.return_value = cwd\n             paths = [cwd, *default_paths]\n             sys.path = copy(paths)\n",
  "pytest-dev__pytest-10051": "diff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex 26c4c15..10418e6 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -160,6 +160,20 @@ def logging_during_setup_and_teardown(caplog):\n     assert [x.message for x in caplog.get_records(\"teardown\")] == [\"a_teardown_log\"]\n \n \n+def test_consistency_after_clear(caplog):\n+    logger = logging.getLogger(__name__)\n+\n+    logger.info(\"initial_message\")\n+    assert caplog.get_records(\"call\") == caplog.records\n+\n+    caplog.clear()\n+    assert caplog.get_records(\"call\") == caplog.records\n+\n+    logger.info(\"message_after_clear\")\n+    assert caplog.get_records(\"call\") == caplog.records\n+\n+import logging\n+\n def test_caplog_captures_for_all_stages(caplog, logging_during_setup_and_teardown):\n     assert not caplog.records\n     assert not caplog.get_records(\"call\")\n",
  "pytest-dev__pytest-10081": "diff --git a/testing/test_unittest.py b/testing/test_unittest.py\nindex 561df7f..0026ecb 100644\n--- a/testing/test_unittest.py\n+++ b/testing/test_unittest.py\n@@ -1273,8 +1273,69 @@ def test_pdb_teardown_skipped(\n     result.stdout.fnmatch_lines(\"* 1 skipped in *\")\n     assert tracked == []\n \n+@pytest.mark.parametrize(\"mark\", [\"@unittest.skip\", \"@pytest.mark.skip\"])\n+def test_no_teardown_execution_for_skipped_classes(\n+    pytester: Pytester, monkeypatch: MonkeyPatch, mark: str\n+) -> None:\n+    \"\"\"Ensure that tearDown is not called when a class is skipped with --pdb.\"\"\"\n+    tracked: List[str] = []\n+    monkeypatch.setattr(pytest, \"track_teardown_calls\", tracked, raising=False)\n+\n+    pytester.makepyfile(\n+        \"\"\"\n+        import unittest\n+        import pytest\n+\n+        {mark}(\"reason for skipping\")\n+        class MyTestCase(unittest.TestCase):\n+\n+            def setUp(self):\n+                pytest.track_teardown_calls.append(\"setUp:\" + self.id())\n+\n+            def tearDown(self):\n+                pytest.track_teardown_calls.append(\"tearDown:\" + self.id())\n+\n+            def test_1(self):\n+                pass\n+        \"\"\".format(\n+            mark=mark\n+        )\n+    )\n+    result = pytester.runpytest_inprocess(\"--pdb\")\n+    result.stdout.fnmatch_lines(\"* 1 skipped in *\")\n+    assert tracked == []\n \n-def test_async_support(pytester: Pytester) -> None:\n+@pytest.mark.parametrize(\"mark\", [\"@unittest.skipIf(True, 'conditional skip')\", \"@pytest.mark.skipif(True, reason='conditional skip')\"])\n+def test_no_teardown_execution_for_skipif_classes(\n+    pytester: Pytester, monkeypatch: MonkeyPatch, mark: str\n+) -> None:\n+    \"\"\"Ensure that tearDown is not called for skipIf classes with --pdb.\"\"\"\n+    tracked: List[str] = []\n+    monkeypatch.setattr(pytest, \"track_teardown_calls\", tracked, raising=False)\n+\n+    pytester.makepyfile(\n+        \"\"\"\n+        import unittest\n+        import pytest\n+\n+        {mark}\n+        class MyTestCase(unittest.TestCase):\n+\n+            def setUp(self):\n+                pytest.track_teardown_calls.append(\"setUp:\" + self.id())\n+\n+            def tearDown(self):\n+                pytest.track_teardown_calls.append(\"tearDown:\" + self.id())\n+\n+            def test_1(self):\n+                pass\n+        \"\"\".format(\n+            mark=mark\n+        )\n+    )\n+    result = pytester.runpytest_inprocess(\"--pdb\")\n+    result.stdout.fnmatch_lines(\"* 1 skipped in *\")\n+    assert tracked == []\n     pytest.importorskip(\"unittest.async_case\")\n \n     pytester.copy_example(\"unittest/test_unittest_asyncio.py\")\n",
  "pytest-dev__pytest-5262": "diff --git a/testing/test_capture.py b/testing/test_capture.py\nindex 1f092b0..fcc0cb0 100644\n--- a/testing/test_capture.py\n+++ b/testing/test_capture.py\n@@ -1051,8 +1051,31 @@ class TestFDCapture(object):\n             cap.done()\n             pytest.raises(AttributeError, cap.suspend)\n \n-\n-@contextlib.contextmanager\n+def test_encodedfile_write_str():\n+    import io\n+    encoding = 'utf-8'\n+    buffer = io.StringIO()\n+    ef = EncodedFile(buffer, encoding)\n+    ef.write(\"Hello, World!\")\n+    assert buffer.getvalue() == \"Hello, World!\"\n+\n+def test_encodedfile_write_bytes_error():\n+    import io\n+    encoding = 'utf-8'\n+    buffer = io.BytesIO()\n+    ef = EncodedFile(buffer, encoding)\n+    try:\n+        ef.write(b\"Hello, World!\")\n+    except TypeError as e:\n+        assert str(e) == \"write() argument must be str, not bytes\"\n+\n+def test_encodedfile_writelines():\n+    import io\n+    encoding = 'utf-8'\n+    buffer = io.StringIO()\n+    ef = EncodedFile(buffer, encoding)\n+    ef.writelines([\"Hello, \", \"World!\"])\n+    assert buffer.getvalue() == \"Hello, World!\"\n def saved_fd(fd):\n     new_fd = os.dup(fd)\n     try:\n",
  "pytest-dev__pytest-5631": "diff --git a/testing/python/integration.py b/testing/python/integration.py\nindex 044a31a..c32d650 100644\n--- a/testing/python/integration.py\n+++ b/testing/python/integration.py\n@@ -177,8 +177,23 @@ class TestMockDecoration:\n         )\n         reprec = testdir.inline_run()\n         reprec.assertoutcome(passed=2)\n+    \n+    def test_patch_with_numpy_array(self, testdir):\n+        \"\"\"Test patching with a numpy array to ensure no ValueError is raised during test collection.\"\"\"\n+        pytest.importorskip(\"numpy\", \"1.17.0\")\n+        testdir.makepyfile(\n+            \"\"\"\n+            from unittest.mock import patch\n+            import numpy as np\n \n-    def test_mock(self, testdir):\n+            class TestNumpyPatch:\n+                @patch('os.path.abspath', new=np.array([-5.5, 3.0]))\n+                def test_patch_numpy_array(self, abspath):\n+                    assert abspath.any()  # Simply verify that the patching does not cause error\n+            \"\"\"\n+        )\n+        reprec = testdir.inline_run()\n+        reprec.assertoutcome(passed=1)\n         pytest.importorskip(\"mock\", \"1.0.1\")\n         testdir.makepyfile(\n             \"\"\"\n",
  "pytest-dev__pytest-5809": "diff --git a/testing/test_pastebin.py b/testing/test_pastebin.py\nindex c6a6cae..aac0b65 100644\n--- a/testing/test_pastebin.py\n+++ b/testing/test_pastebin.py\n@@ -126,8 +126,7 @@ class TestPaste(object):\n         assert len(mocked_urlopen) == 1\n         url, data = mocked_urlopen[0]\n         assert type(data) is bytes\n-        lexer = \"python3\" if sys.version_info[0] >= 3 else \"python\"\n         assert url == \"https://bpaste.net\"\n-        assert \"lexer=%s\" % lexer in data.decode()\n+        assert \"lexer=text\" in data.decode()\n         assert \"code=full-paste-contents\" in data.decode()\n-        assert \"expiry=1week\" in data.decode()\n+        assert \"expiry=1week\" in data.decode()\n",
  "pytest-dev__pytest-6202": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex fb6b260..c659915 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -702,7 +702,39 @@ class Test_genitems:\n         assert items[1].name == \"testmethod_one\"\n         assert items[2].name == \"testmethod_one\"\n \n-        # let's also test getmodpath here\n+        # Original test patch\n+        import pytest\n+\n+        @pytest.mark.parametrize(\"arg0\", [\".[\"])\n+        def testmethod_two(self, arg0):\n+            pass\n+\n+        assert len(items) == 4\n+        assert items[3].name == \"testmethod_two[.[]\"\n+        # PR #6202: Fix incorrect result of getmodpath method. (Resolves issue #6189)\n+        assert items[3].getmodpath() == \"TestY.testmethod_two[.[]\"\n+\n+        # Additional test for variations\n+        @pytest.mark.parametrize(\"arg0\", [\"..[\", \".[\", \".[]\", \".[.\", \".[..\"])\n+        def testmethod_three(self, arg0):\n+            pass\n+\n+        items, reprec = testdir.inline_genitems(p)\n+        assert len(items) == 5  # Adjusted for the new test\n+        assert items[4].name == \"testmethod_three[..[\"\n+        assert items[4].getmodpath() == \"TestY.testmethod_three[..[\"\n+\n+        assert items[5].name == \"testmethod_three[.[\"\n+        assert items[5].getmodpath() == \"TestY.testmethod_three[.[\"\n+        \n+        assert items[6].name == \"testmethod_three[.[]\"\n+        assert items[6].getmodpath() == \"TestY.testmethod_three[.[]\"\n+        \n+        assert items[7].name == \"testmethod_three[.[.\"\n+        assert items[7].getmodpath() == \"TestY.testmethod_three[.[.\"\n+\n+        assert items[8].name == \"testmethod_three[.[..\"\n+        assert items[8].getmodpath() == \"TestY.testmethod_three[.[..\"\n         assert items[0].getmodpath() == \"testone\"\n         assert items[1].getmodpath() == \"TestX.testmethod_one\"\n         assert items[2].getmodpath() == \"TestY.testmethod_one\"\n",
  "pytest-dev__pytest-7205": "diff --git a/testing/test_setuponly.py b/testing/test_setuponly.py\nindex 8211d39..294b9d3 100644\n--- a/testing/test_setuponly.py\n+++ b/testing/test_setuponly.py\n@@ -1,3 +1,4 @@\n+\n import pytest\n from _pytest.config import ExitCode\n \n@@ -200,8 +201,26 @@ def test_show_fixtures_with_parameter_ids_function(testdir, mode):\n \n     result.stdout.fnmatch_lines([\"*SETUP    F foobar?FOO?\", \"*SETUP    F foobar?BAR?\"])\n \n+def test_show_fixture_action_with_bytes(testdir):\n+    # Test for BytesWarning when using --setup-show with bytes parameter\n+    test_file = testdir.makepyfile(\n+        \"\"\"\n+        import pytest\n \n-def test_dynamic_fixture_request(testdir):\n+        @pytest.mark.parametrize('data', [b'Hello World', b'Python Testing'])\n+        def test_data(data):\n+            pass\n+        \"\"\"\n+    )\n+    # Run pytest with Python's `-bb` flag to treat BytesWarning as error\n+    result = testdir.run(\n+        sys.executable, \"-bb\", \"-m\", \"pytest\", \"--setup-show\", str(test_file)\n+    )\n+    assert result.ret == 0\n+    result.stdout.fnmatch_lines([\n+        \"*SETUP    F data[Hello World]*\",\n+        \"*SETUP    F data[Python Testing]*\"\n+    ])\n     p = testdir.makepyfile(\n         \"\"\"\n         import pytest\n",
  "pytest-dev__pytest-7236": "",
  "pytest-dev__pytest-7432": "",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..3a2b7c1 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,6 +1,8 @@\n+\n import sys\n \n import pytest\n+from _pytest.pytester import Testdir\n from _pytest.runner import runtestprotocol\n from _pytest.skipping import evaluate_skip_marks\n from _pytest.skipping import evaluate_xfail_marks\n@@ -155,6 +157,33 @@ class TestEvaluation:\n \n class TestXFail:\n     @pytest.mark.parametrize(\"strict\", [True, False])\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # This test checks the behavior when a dynamic xfail is set, and the test fails.\n+        # It ensures that the test result is marked as xfailed.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_dynamic_xfail(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+\n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir: Testdir) -> None:\n+        # This test checks the behavior when a dynamic xfail with strict=True is set, and the test passes.\n+        # It ensures that the test result is marked as failed due to XPASS(strict).\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_dynamic_xfail(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\", strict=True))\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n+\n     def test_xfail_simple(self, testdir, strict):\n         item = testdir.getitem(\n             \"\"\"\n",
  "pytest-dev__pytest-7521": "diff --git a/testing/test_capture.py b/testing/test_capture.py\nindex 9d70acf..3630562 100644\n--- a/testing/test_capture.py\n+++ b/testing/test_capture.py\n@@ -513,8 +513,15 @@ class TestCaptureFixture:\n             \"\"\"\n         )\n         reprec.assertoutcome(passed=1)\n-\n-    def test_capfdbinary(self, testdir):\n+    @pytest.mark.parametrize(\"nl, expected\", [\n+        (\"\\n\", \"\\n\"),\n+        (\"\\r\\n\", \"\\r\\n\"),\n+        (\"\\r\", \"\\r\"),\n+    ])\n+    def test_cafd_preserves_newlines(capfd, nl, expected):\n+        print(\"test\", end=nl)\n+        out, err = capfd.readouterr()\n+        assert out.endswith(expected)\n         reprec = testdir.inline_runsource(\n             \"\"\"\\\n             def test_hello(capfdbinary):\n",
  "pytest-dev__pytest-7571": "diff --git a/testing/logging/test_fixture.py b/testing/logging/test_fixture.py\nindex a9649e4..802e3f9 100644\n--- a/testing/logging/test_fixture.py\n+++ b/testing/logging/test_fixture.py\n@@ -1,6 +1,9 @@\n+\n import logging\n \n import pytest\n+from _pytest.pytester import Testdir\n+\n from _pytest.logging import caplog_records_key\n \n logger = logging.getLogger(__name__)\n@@ -15,7 +18,31 @@ def test_fixture_help(testdir):\n def test_change_level(caplog):\n     caplog.set_level(logging.INFO)\n     logger.debug(\"handler DEBUG level\")\n-    logger.info(\"handler INFO level\")\n+def test_change_level_undos_handler_level(testdir: Testdir) -> None:\n+    \"\"\"Ensure that 'set_level' is undone after the end of the test (handler).\n+\n+    Issue #7569. Tests the handler level specifically.\n+    \"\"\"\n+    testdir.makepyfile(\n+        \"\"\"\n+        import logging\n+\n+        def test1(caplog):\n+            assert caplog.handler.level == 0\n+            caplog.set_level(41)\n+            assert caplog.handler.level == 41\n+\n+        def test2(caplog):\n+            assert caplog.handler.level == 0\n+\n+        def test3(caplog):\n+            assert caplog.handler.level == 0\n+            caplog.set_level(43)\n+            assert caplog.handler.level == 43\n+    \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    result.assert_outcomes(passed=3)\n \n     caplog.set_level(logging.CRITICAL, logger=sublogger.name)\n     sublogger.warning(\"logger WARNING level\")\n",
  "pytest-dev__pytest-7982": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex b774a67..0e3386b 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -1,3 +1,4 @@\n+\n import os\n import pprint\n import sys\n@@ -9,7 +10,7 @@ from _pytest.config import ExitCode\n from _pytest.main import _in_venv\n from _pytest.main import Session\n from _pytest.pathlib import symlink_or_skip\n-from _pytest.pytester import Testdir\n+from _pytest.pytester import Testdir, Pytester\n \n \n class TestCollector:\n@@ -1178,7 +1179,32 @@ def test_collect_symlink_out_of_tree(testdir):\n     assert result.ret == 0\n \n \n-def test_collectignore_via_conftest(testdir):\n+def test_collect_symlink_dir(pytester: Pytester) -> None:\n+    \"\"\"A symlinked directory is collected.\"\"\"\n+    dir = pytester.mkdir(\"dir\")\n+    dir.joinpath(\"test_it.py\").write_text(\"def test_it(): pass\", \"utf-8\")\n+    pytester.path.joinpath(\"symlink_dir\").symlink_to(dir)\n+    result = pytester.runpytest()\n+    result.assert_outcomes(passed=2)\n+\n+def test_collect_symlink_nested_dir(pytester: Pytester) -> None:\n+    \"\"\"A symlinked nested directory structure is collected.\"\"\"\n+    root_dir = pytester.mkdir(\"root_dir\")\n+    nested_dir = root_dir.mkdir(\"nested\")\n+    nested_dir.joinpath(\"test_nested.py\").write_text(\"def test_nested(): pass\", \"utf-8\")\n+    pytester.path.joinpath(\"symlink_nested\").symlink_to(root_dir)\n+    result = pytester.runpytest()\n+    result.assert_outcomes(passed=2)\n+\n+def test_collect_symlink_with_excluded_dir(pytester: Pytester) -> None:\n+    \"\"\"A symlinked directory with an excluded pattern is still partially collected.\"\"\"\n+    dir = pytester.mkdir(\"dir_with_exclude\")\n+    dir.joinpath(\"test_it.py\").write_text(\"def test_it(): pass\", \"utf-8\")\n+    exclude_dir = dir.mkdir(\"exclude_this\")\n+    exclude_dir.joinpath(\"test_exclude.py\").write_text(\"def test_exclude(): pass\", \"utf-8\")\n+    pytester.path.joinpath(\"symlink_dir_excluded\").symlink_to(dir)\n+    result = pytester.runpytest(\"--ignore=exclude_this\")\n+    result.assert_outcomes(passed=1)\n     \"\"\"collect_ignore in parent conftest skips importing child (issue #4592).\"\"\"\n     tests = testdir.mkpydir(\"tests\")\n     tests.ensure(\"conftest.py\").write(\"collect_ignore = ['ignore_me']\")\n",
  "pytest-dev__pytest-8399": "",
  "scikit-learn__scikit-learn-10297": "",
  "scikit-learn__scikit-learn-10844": "diff --git a/sklearn/metrics/cluster/tests/test_supervised.py b/sklearn/metrics/cluster/tests/test_supervised.py\nindex f5edf7a..0311c5c 100644\n--- a/sklearn/metrics/cluster/tests/test_supervised.py\n+++ b/sklearn/metrics/cluster/tests/test_supervised.py\n@@ -184,7 +184,17 @@ def test_int_overflow_mutual_info_score():\n     assert_all_finite(mutual_info_score(x.ravel(), y.ravel()))\n \n \n-def test_entropy():\n+from sklearn.metrics import fowlkes_mallows_score\n+import numpy as np\n+from numpy.testing import assert_all_finite\n+\n+def test_fowlkes_mallows_score_large_numbers():\n+    # Generate large numbers to cause potential overflow\n+    labels_true = np.repeat([0, 1], [2**16, 2**16])\n+    labels_pred = np.repeat([0, 1], [2**16, 2**16])\n+    # Ensure the computation does not result in overflow or RuntimeWarning\n+    score = fowlkes_mallows_score(labels_true, labels_pred)\n+    assert_all_finite(score)\n     ent = entropy([0, 0, 42.])\n     assert_almost_equal(ent, 0.6365141, 5)\n     assert_almost_equal(entropy([]), 1)\n",
  "scikit-learn__scikit-learn-10908": "diff --git a/sklearn/feature_extraction/tests/test_text.py b/sklearn/feature_extraction/tests/test_text.py\nindex 0a2b603..3da4a85 100644\n--- a/sklearn/feature_extraction/tests/test_text.py\n+++ b/sklearn/feature_extraction/tests/test_text.py\n@@ -558,8 +558,25 @@ def test_feature_names():\n     for idx, name in enumerate(feature_names):\n         assert_equal(idx, cv.vocabulary_.get(name))\n \n+def test_countvectorizer_with_vocabulary_and_get_feature_names():\n+    vocab = ['and', 'document', 'first', 'is', 'one', 'second', 'the', 'third', 'this']\n+    cv = CountVectorizer(vocabulary=vocab)\n+    \n+    # Ensure get_feature_names works without raising NotFittedError\n+    feature_names = cv.get_feature_names()\n+    assert_array_equal(feature_names, vocab)\n \n-def test_vectorizer_max_features():\n+    corpus = [\n+        'This is the first document.',\n+        'This is the second second document.',\n+        'And the third one.',\n+        'Is this the first document?',\n+    ]\n+    X = cv.transform(corpus)\n+    \n+    # Ensure transform works after get_feature_names\n+    expected_output_shape = (4, len(vocab))\n+    assert_equal(X.shape, expected_output_shape)\n     vec_factories = (\n         CountVectorizer,\n         TfidfVectorizer,\n",
  "scikit-learn__scikit-learn-11310": "",
  "scikit-learn__scikit-learn-11578": "diff --git a/sklearn/linear_model/tests/test_logistic.py b/sklearn/linear_model/tests/test_logistic.py\nindex daa75d1..586997d 100644\n--- a/sklearn/linear_model/tests/test_logistic.py\n+++ b/sklearn/linear_model/tests/test_logistic.py\n@@ -21,6 +21,8 @@ from sklearn.utils.testing import assert_true\n from sklearn.utils.testing import assert_warns\n from sklearn.utils.testing import ignore_warnings\n from sklearn.utils.testing import assert_warns_message\n+from sklearn.metrics import log_loss\n+from sklearn.model_selection import train_test_split\n \n from sklearn.exceptions import ConvergenceWarning\n from sklearn.exceptions import ChangedBehaviorWarning\n",
  "scikit-learn__scikit-learn-12585": "",
  "scikit-learn__scikit-learn-12973": "diff --git a/sklearn/linear_model/tests/test_least_angle.py b/sklearn/linear_model/tests/test_least_angle.py\nindex 790b864..8fd87c2 100644\n--- a/sklearn/linear_model/tests/test_least_angle.py\n+++ b/sklearn/linear_model/tests/test_least_angle.py\n@@ -16,7 +16,8 @@ from sklearn.utils.testing import assert_raises\n from sklearn.utils.testing import ignore_warnings\n from sklearn.utils.testing import assert_warns\n from sklearn.utils.testing import TempMemmap\n-from sklearn.exceptions import ConvergenceWarning\n+from sklearn.utils import check_X_y\n+from sklearn.linear_model import LassoLarsIC\n from sklearn import linear_model, datasets\n from sklearn.linear_model.least_angle import _lars_path_residues\n \n@@ -25,6 +26,39 @@ X, y = diabetes.data, diabetes.target\n \n # TODO: use another dataset that has multiple drops\n \n+@pytest.mark.parametrize('init_copy_X, fit_copy_X, expected', [\n+    (True, None, True),\n+    (False, None, False),\n+    (True, True, True),\n+    (True, False, False),\n+    (False, True, True),\n+    (False, False, False),\n+])\n+def test_lasso_lars_ic_copyX_resolution(init_copy_X, fit_copy_X, expected):\n+    \"\"\"Test that the copy_X resolution logic works correctly.\"\"\"\n+    lasso_lars = LassoLarsIC(copy_X=init_copy_X, precompute=False)\n+    rng = np.random.RandomState(0)\n+    X = rng.normal(0, 1, (100, 5))\n+    X_copy = X.copy()\n+    y = X[:, 2]\n+    if fit_copy_X is None:\n+        lasso_lars.fit(X, y)\n+    else:\n+        lasso_lars.fit(X, y, copy_X=fit_copy_X)\n+    assert expected == np.array_equal(X, X_copy)\n+\n+\n+@pytest.mark.parametrize('copy_X', [True, False])\n+def test_lasso_lars_ic_init_copyX_behaviour(copy_X):\n+    \"\"\"Test that initialization parameter copy_X is honored when no fit argument is provided.\"\"\"\n+    lasso_lars = LassoLarsIC(copy_X=copy_X, precompute=False)\n+    rng = np.random.RandomState(0)\n+    X = rng.normal(0, 1, (100, 5))\n+    X_copy = X.copy()\n+    y = X[:, 2]\n+    lasso_lars.fit(X, y)\n+    assert copy_X == np.array_equal(X, X_copy)\n+\n \n def test_simple():\n     # Principle of Lars is to keep covariances tied and decreasing\n",
  "scikit-learn__scikit-learn-13124": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex 785bf42..83a7d09 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -493,8 +493,24 @@ def test_shuffle_stratifiedkfold():\n         assert_not_equal(set(test0), set(test1))\n     check_cv_coverage(kf0, X_40, y, groups=None, expected_n_splits=5)\n \n-\n-def test_kfold_can_detect_dependent_samples_on_digits():  # see #2372\n+def test_issue_15125_stratified_kfold_shuffling():\n+    # Ensure that different random states for shuffled StratifiedKFold\n+    # lead to different test sets, addressing issue #15125\n+    \n+    X = np.arange(20)\n+    y = [0] * 10 + [1] * 10\n+\n+    # Using the same random state should result in the same splits\n+    kf1 = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n+    kf2 = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n+    splits1 = [test_idx for _, test_idx in kf1.split(X, y)]\n+    splits2 = [test_idx for _, test_idx in kf2.split(X, y)]\n+    assert splits1 == splits2, \"Splits should be identical for the same random state\"\n+    \n+    # Different random states should result in different splits\n+    kf3 = StratifiedKFold(n_splits=5, shuffle=True, random_state=43)\n+    splits3 = [test_idx for _, test_idx in kf3.split(X, y)]\n+    assert splits1 != splits3, \"Splits should differ for different random states\"\n     # The digits samples are dependent: they are apparently grouped by authors\n     # although we don't have any information on the groups segment locations\n     # for this data. We can highlight this fact by computing k-fold cross-\n",
  "scikit-learn__scikit-learn-13135": "diff --git a/sklearn/preprocessing/tests/test_discretization.py b/sklearn/preprocessing/tests/test_discretization.py\nindex a18a1c5..16b2d5b 100644\n--- a/sklearn/preprocessing/tests/test_discretization.py\n+++ b/sklearn/preprocessing/tests/test_discretization.py\n@@ -202,6 +202,17 @@ def test_nonuniform_strategies(strategy, expected_2bins, expected_3bins):\n     Xt = est.fit_transform(X)\n     assert_array_equal(expected_3bins, Xt.ravel())\n \n+@pytest.mark.parametrize('strategy, expected_5bins',\n+                         [('uniform', [0, 0, 1, 1, 4, 4]),\n+                          ('kmeans', [0, 0, 1, 2, 3, 4]),\n+                          ('quantile', [0, 1, 2, 3, 4, 4])])\n+def test_nonuniform_strategies_with_5_bins(strategy, expected_5bins):\n+    X = np.array([0, 0.5, 2, 3, 9, 10]).reshape(-1, 1)\n+\n+    # with 5 bins\n+    est = KBinsDiscretizer(n_bins=5, strategy=strategy, encode='ordinal')\n+    Xt = est.fit_transform(X)\n+    assert_array_equal(expected_5bins, Xt.ravel())\n \n @pytest.mark.parametrize('strategy', ['uniform', 'kmeans', 'quantile'])\n @pytest.mark.parametrize('encode', ['ordinal', 'onehot', 'onehot-dense'])\n",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex f8e4d54..1bd5e56 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -597,8 +597,13 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_array_equal(Y_pred1, Y_pred2)\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n-\n-def test_gaussian_mixture_fit():\n+def test_gaussian_mixture_fit_predict_n_init():\n+    # Check that fit_predict is equivalent to fit.predict, when n_init > 1\n+    X = np.random.RandomState(0).randn(1000, 5)\n+    gm = GaussianMixture(n_components=5, n_init=5, random_state=0)\n+    y_pred1 = gm.fit_predict(X)\n+    y_pred2 = gm.predict(X)\n+    assert_array_equal(y_pred1, y_pred2)\n     # recover the ground truth\n     rng = np.random.RandomState(0)\n     rand_data = RandomData(rng)\n",
  "scikit-learn__scikit-learn-13328": "",
  "scikit-learn__scikit-learn-13439": "",
  "scikit-learn__scikit-learn-13496": "",
  "scikit-learn__scikit-learn-13779": "",
  "scikit-learn__scikit-learn-14053": "",
  "scikit-learn__scikit-learn-14087": "diff --git a/sklearn/linear_model/tests/test_logistic.py b/sklearn/linear_model/tests/test_logistic.py\nindex 2a87dbf..c9c7306 100644\n--- a/sklearn/linear_model/tests/test_logistic.py\n+++ b/sklearn/linear_model/tests/test_logistic.py\n@@ -1531,6 +1531,36 @@ def test_LogisticRegressionCV_GridSearchCV_elastic_net_ovr():\n     assert (lrcv.predict(X_train) == gs.predict(X_train)).mean() >= .8\n     assert (lrcv.predict(X_test) == gs.predict(X_test)).mean() >= .8\n \n+@pytest.mark.parametrize('penalty', ('l2', 'elasticnet'))\n+@pytest.mark.parametrize('multi_class', ('ovr', 'multinomial', 'auto'))\n+def test_LogisticRegressionCV_no_refit_expanded(penalty, multi_class):\n+    # Expanded test for the issue with LogisticRegressionCV where refit=False\n+    \n+    n_classes = 2\n+    n_samples = 1000\n+    n_features = 3\n+    \n+    np.random.seed(29)\n+    X = np.random.normal(size=(n_samples, n_features))\n+    beta = np.random.normal(size=n_features)\n+    intercept = np.random.normal(size=None)\n+    y = np.sign(intercept + X @ beta)\n+    \n+    Cs = np.logspace(-4, 4, 3)\n+    if penalty == 'elasticnet':\n+        l1_ratios = np.linspace(0, 1, 2)\n+    else:\n+        l1_ratios = None\n+\n+    lrcv = LogisticRegressionCV(penalty=penalty, Cs=Cs, solver='saga',\n+                                l1_ratios=l1_ratios, random_state=0,\n+                                multi_class=multi_class, refit=False)\n+    lrcv.fit(X, y)\n+    # Verify no exceptions are raised and check the shapes of attributes\n+    assert len(lrcv.C_) == n_classes if n_classes > 2 else 1\n+    if penalty == 'elasticnet':\n+        assert len(lrcv.l1_ratio_) == n_classes if n_classes > 2 else 1\n+\n \n @pytest.mark.parametrize('multi_class', ('ovr', 'multinomial'))\n def test_LogisticRegressionCV_no_refit(multi_class):\n",
  "scikit-learn__scikit-learn-14141": "diff --git a/sklearn/utils/_show_versions.py b/sklearn/utils/_show_versions.py\nindex 72f054a..13bf362 100644\n--- a/sklearn/utils/_show_versions.py\n+++ b/sklearn/utils/_show_versions.py\n@@ -48,6 +48,7 @@ def _get_deps_info():\n         \"Cython\",\n         \"pandas\",\n         \"matplotlib\",\n+        \"joblib\",\n     ]\n \n     def get_version(module):\n",
  "scikit-learn__scikit-learn-14496": "diff --git a/sklearn/cluster/tests/test_optics.py b/sklearn/cluster/tests/test_optics.py\nindex 6c9dac3..d30ad1b 100644\n--- a/sklearn/cluster/tests/test_optics.py\n+++ b/sklearn/cluster/tests/test_optics.py\n@@ -124,6 +124,21 @@ def test_extract_xi():\n                    xi=0.04).fit(X)\n     assert_array_equal(clust.labels_, expected_labels)\n \n+def test_float_min_samples():\n+    # Generate some synthetic data\n+    rng = np.random.RandomState(42)\n+    X = rng.rand(100, 2)  # 100 points in 2D\n+\n+    # Define the expected behavior when min_samples is given as a float\n+    clust = OPTICS(min_samples=0.1, max_eps=10, cluster_method='xi', xi=0.05)\n+    \n+    # Ensure it doesn't raise and computes correctly\n+    clust.fit(X)\n+    assert clust.labels_ is not None  # Simplest check to ensure it runs\n+    \n+    # A synthetic test just to ensure no exceptions\n+    expected_labels = -1 * np.ones(100, dtype=int)  # no clustering expected in this random data\n+    assert_array_equal(clust.labels_, expected_labels)\n \n def test_cluster_hierarchy_():\n     rng = np.random.RandomState(0)\n",
  "scikit-learn__scikit-learn-14710": "diff --git a/sklearn/ensemble/_hist_gradient_boosting/tests/test_gradient_boosting.py b/sklearn/ensemble/_hist_gradient_boosting/tests/test_gradient_boosting.py\nindex 7e8bccd..5ec991b 100644\n--- a/sklearn/ensemble/_hist_gradient_boosting/tests/test_gradient_boosting.py\n+++ b/sklearn/ensemble/_hist_gradient_boosting/tests/test_gradient_boosting.py\n@@ -414,4 +414,20 @@ def test_infinite_values_missing_values():\n                                                learning_rate=1, max_depth=2)\n \n     assert stump_clf.fit(X, y_isinf).score(X, y_isinf) == 1\n-    assert stump_clf.fit(X, y_isnan).score(X, y_isnan) == 1\n+    assert stump_clf.fit(X, y_isnan).score(X, y_isnan) == 1\n+\n+\n+@pytest.mark.parametrize(\"scoring\", [None, 'loss'])\n+def test_string_target_early_stopping(scoring):\n+    # Regression tests for #14709 where the targets need to be encoded before\n+    # computing the score with early stopping enabled.\n+    rng = np.random.RandomState(42)\n+    X = rng.randn(100, 10)\n+    y = np.array(['x'] * 50 + ['y'] * 50, dtype=object)\n+    gbrt = HistGradientBoostingClassifier(n_iter_no_change=10, scoring=scoring)\n+    # The following should not raise any errors\n+    gbrt.fit(X, y)\n+\n+    # Making predictions and checking that they fall within expected classes\n+    predictions = gbrt.predict(X)\n+    assert set(predictions).issubset({'x', 'y'})\n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..a2df910 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -690,7 +690,25 @@ def test_sparse_precomputed():\n         assert \"Sparse precomputed\" in str(e)\n \n \n-def test_linearsvc_parameters():\n+from sklearn import svm\n+from scipy import sparse\n+import numpy as np\n+\n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for issue involving sparse support_vectors_\n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    \n+    # Check if support_vectors_ is empty\n+    assert model.support_vectors_.shape[0] == 0\n+    \n+    # Check if dual_coef_ is empty\n+    assert model.dual_coef_.shape[1] == 0\n     # Test possible parameter combinations in LinearSVC\n     # Generate list of possible parameter combinations\n     losses = ['hinge', 'squared_hinge', 'logistic_regression', 'foo']\n",
  "scikit-learn__scikit-learn-14983": "",
  "scikit-learn__scikit-learn-15100": "diff --git a/sklearn/feature_extraction/tests/test_text.py b/sklearn/feature_extraction/tests/test_text.py\nindex 96ea20a..a0ace5d 100644\n--- a/sklearn/feature_extraction/tests/test_text.py\n+++ b/sklearn/feature_extraction/tests/test_text.py\n@@ -97,6 +97,27 @@ def test_strip_accents():\n     expected = 'this is a test'\n     assert strip_accents_unicode(a) == expected\n \n+    # strings that are already decomposed\n+    a = \"o\\u0308\"  # o with diaresis\n+    expected = \"o\"\n+    assert strip_accents_unicode(a) == expected\n+\n+    # combining marks by themselves\n+    a = \"\\u0300\\u0301\\u0302\\u0303\"  # various combining marks\n+    expected = \"\"\n+    assert strip_accents_unicode(a) == expected\n+\n+    # Multiple combining marks on one character\n+    a = \"o\\u0308\\u0304\"  # o with diaeresis and macron\n+    expected = \"o\"\n+    assert strip_accents_unicode(a) == expected\n+\n+    # Test with `s2` from the issue\n+    s1 = chr(241)  # \u00f1\n+    s2 = chr(110) + chr(771)  # n + COMBINING TILDE\n+    assert strip_accents_unicode(s1) == 'n'\n+    assert strip_accents_unicode(s2) == 'n'\n+\n \n def test_to_ascii():\n     # check some classical latin accentuated symbols\n",
  "scikit-learn__scikit-learn-25102": "",
  "scikit-learn__scikit-learn-25232": "diff --git a/sklearn/impute/tests/test_impute.py b/sklearn/impute/tests/test_impute.py\nindex ee482a8..82aa35b 100644\n--- a/sklearn/impute/tests/test_impute.py\n+++ b/sklearn/impute/tests/test_impute.py\n@@ -1520,9 +1520,85 @@ def test_iterative_imputer_keep_empty_features(initial_strategy):\n     )\n     X_imputed = imputer.fit_transform(X)\n     assert_allclose(X_imputed[:, 1], 0)\n+\n+def test_iterative_imputer_custom_constant_fill_value():\n+    \"\"\"Test IterativeImputer with custom fill_value when initial_strategy is 'constant'.\"\"\"\n+    import numpy as np\n+    from sklearn.experimental import enable_iterative_imputer  # noqa\n+    from sklearn.impute import IterativeImputer\n+    from numpy.testing import assert_array_equal\n+\n+    X = np.array([[-1, 2, 3, -1], [4, -1, 5, -1], [6, 7, -1, -1], [8, 9, 0, -1]])\n+    fill_value = 100\n+    imputer = IterativeImputer(\n+        missing_values=-1,\n+        initial_strategy=\"constant\",\n+        fill_value=fill_value,\n+        max_iter=0,\n+    )\n+    X_imputed = imputer.fit_transform(X)\n+    # Check if the initial imputer fill value is set correctly\n+    assert_array_equal(imputer.initial_imputer_.statistics_, fill_value)\n+\n+def test_iterative_imputer_fill_value_with_nan():\n+    \"\"\"Test IterativeImputer with np.nan as fill_value when initial_strategy is 'constant'.\"\"\"\n+    import numpy as np\n+    from sklearn.experimental import enable_iterative_imputer  # noqa\n+    from sklearn.impute import IterativeImputer\n+    from numpy.testing import assert_array_equal\n+\n+    X = np.array([[np.nan, 2, 3, np.nan], [4, np.nan, 5, np.nan], [6, 7, np.nan, np.nan], [8, 9, 0, np.nan]])\n+    fill_value = np.nan\n+    imputer = IterativeImputer(\n+        missing_values=np.nan,\n+        initial_strategy=\"constant\",\n+        fill_value=fill_value,\n+        max_iter=0,\n+    )\n+    X_imputed = imputer.fit_transform(X)\n+    # Check if the initial imputer fill value is set correctly\n+    assert np.isnan(imputer.initial_imputer_.statistics_).all()\n     X_imputed = imputer.transform(X)\n     assert_allclose(X_imputed[:, 1], 0)\n \n+def test_iterative_imputer_custom_constant_fill_value():\n+    \"\"\"Test IterativeImputer with custom fill_value when initial_strategy is 'constant'.\"\"\"\n+    import numpy as np\n+    from sklearn.experimental import enable_iterative_imputer  # noqa\n+    from sklearn.impute import IterativeImputer\n+    from numpy.testing import assert_array_equal\n+\n+    X = np.array([[-1, 2, 3, -1], [4, -1, 5, -1], [6, 7, -1, -1], [8, 9, 0, -1]])\n+    fill_value = 100\n+    imputer = IterativeImputer(\n+        missing_values=-1,\n+        initial_strategy=\"constant\",\n+        fill_value=fill_value,\n+        max_iter=0,\n+    )\n+    X_imputed = imputer.fit_transform(X)\n+    # Check if the initial imputer fill value is set correctly\n+    assert_array_equal(imputer.initial_imputer_.statistics_, fill_value)\n+\n+def test_iterative_imputer_fill_value_with_nan():\n+    \"\"\"Test IterativeImputer with np.nan as fill_value when initial_strategy is 'constant'.\"\"\"\n+    import numpy as np\n+    from sklearn.experimental import enable_iterative_imputer  # noqa\n+    from sklearn.impute import IterativeImputer\n+    from numpy.testing import assert_array_equal\n+\n+    X = np.array([[np.nan, 2, 3, np.nan], [4, np.nan, 5, np.nan], [6, 7, np.nan, np.nan], [8, 9, 0, np.nan]])\n+    fill_value = np.nan\n+    imputer = IterativeImputer(\n+        missing_values=np.nan,\n+        initial_strategy=\"constant\",\n+        fill_value=fill_value,\n+        max_iter=0,\n+    )\n+    X_imputed = imputer.fit_transform(X)\n+    # Check if the initial imputer fill value is set correctly\n+    assert np.isnan(imputer.initial_imputer_.statistics_).all()\n+\n \n @pytest.mark.parametrize(\"keep_empty_features\", [True, False])\n def test_knn_imputer_keep_empty_features(keep_empty_features):\n",
  "scikit-learn__scikit-learn-25931": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3714d1a..9421c9e 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -332,10 +332,26 @@ def test_base_estimator_property_deprecated():\n     y = np.array([1, 0])\n     model = IsolationForest()\n     model.fit(X, y)\n+import pytest\n+import warnings\n+import numpy as np\n+from sklearn.ensemble import IsolationForest\n+\n+def test_iforest_no_warning_with_feature_names():\n+    \"\"\"Test that no warning is raised about feature names when contamination is not 'auto'.\"\"\"\n+    import pandas as pd\n+\n+    X = pd.DataFrame({\"feature1\": [1, 2, 3, 4, 5]})\n+    model = IsolationForest(contamination=0.1)\n+\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\"error\", UserWarning)\n+        model.fit(X)\n \n+        # If we reach this point, no UserWarning was raised\n     warn_msg = (\n         \"Attribute `base_estimator_` was deprecated in version 1.2 and \"\n         \"will be removed in 1.4. Use `estimator_` instead.\"\n     )\n     with pytest.warns(FutureWarning, match=warn_msg):\n-        model.base_estimator_\n+        model.base_estimator_\n",
  "scikit-learn__scikit-learn-25973": "",
  "scikit-learn__scikit-learn-26323": "",
  "scikit-learn__scikit-learn-9288": "diff --git a/sklearn/cluster/tests/test_k_means.py b/sklearn/cluster/tests/test_k_means.py\nindex abeeff0..2989610 100644\n--- a/sklearn/cluster/tests/test_k_means.py\n+++ b/sklearn/cluster/tests/test_k_means.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Testing for K-means\"\"\"\n import sys\n \n@@ -944,8 +945,43 @@ def test_k_means_empty_cluster_relocated():\n     assert len(set(km.labels_)) == 2\n     assert_allclose(km.cluster_centers_, [[-1], [1]])\n \n-\n-def test_minibatch_kmeans_partial_fit_int_data():\n+def test_result_of_kmeans_equal_in_diff_n_jobs():\n+    # PR 9288\n+    rnd = np.random.RandomState(0)\n+    X = rnd.normal(size=(50, 10))\n+\n+    result_1 = KMeans(n_clusters=3, random_state=0, n_jobs=1).fit(X).labels_\n+    result_2 = KMeans(n_clusters=3, random_state=0, n_jobs=2).fit(X).labels_\n+    assert_array_equal(result_1, result_2)\n+\n+def test_kmeans_inertia_consistency_across_n_jobs():\n+    X, _ = make_blobs(n_samples=1000, centers=10, n_features=2, random_state=42)\n+    \n+    inertia_1 = KMeans(n_clusters=10, random_state=42, n_jobs=1).fit(X).inertia_\n+    inertia_2 = KMeans(n_clusters=10, random_state=42, n_jobs=2).fit(X).inertia_\n+    inertia_3 = KMeans(n_clusters=10, random_state=42, n_jobs=3).fit(X).inertia_\n+    \n+    assert_almost_equal(inertia_1, inertia_2)\n+    assert_almost_equal(inertia_1, inertia_3)\n+    assert_almost_equal(inertia_2, inertia_3)\n+\n+def test_kmeans_large_dataset_n_jobs():\n+    # Testing with a larger dataset and more clusters to check n_jobs consistency\n+    X, _ = make_blobs(n_samples=5000, centers=15, n_features=5, random_state=0)\n+    \n+    result_1 = KMeans(n_clusters=15, random_state=42, n_jobs=1).fit(X).labels_\n+    result_2 = KMeans(n_clusters=15, random_state=42, n_jobs=-1).fit(X).labels_\n+    \n+    assert_array_equal(result_1, result_2)\n+\n+def test_kmeans_single_cluster():\n+    # Test edge case with single cluster\n+    X, _ = make_blobs(n_samples=100, centers=1, n_features=2, random_state=1)\n+    \n+    result_1 = KMeans(n_clusters=1, random_state=42, n_jobs=1).fit(X).labels_\n+    result_2 = KMeans(n_clusters=1, random_state=42, n_jobs=2).fit(X).labels_\n+    \n+    assert_array_equal(result_1, result_2)\n     # Issue GH #14314\n     X = np.array([[-1], [1]], dtype=np.int)\n     km = MiniBatchKMeans(n_clusters=2)\n",
  "sphinx-doc__sphinx-10323": "",
  "sphinx-doc__sphinx-10449": "diff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex 82ec43a..4313aec 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -1055,6 +1055,26 @@ def test_autodoc_typehints_description_with_documented_init(app):\n             '         None\\n' == context)\n \n \n+\n+@pytest.mark.sphinx('text', testroot='ext-autodoc',\n+                    confoverrides={'autodoc_typehints': \"description\"})\n+def test_autodoc_typehints_description_for_class_no_return_type(app):\n+    (app.srcdir / 'index.rst').write_text(\n+        '.. autoclass:: target.typehints.Square\\n'\n+        '   :members:\\n',\n+        encoding='utf8'\n+    )\n+    app.build()\n+    context = (app.outdir / 'index.txt').read_text(encoding='utf8')\n+    assert ('class target.typehints.Square(width, height)\\n'\n+            '\\n'\n+            '   A class representing a square figure.\\n'\n+            '\\n'\n+            '   Parameters:\\n'\n+            '      **width** (*int*) --\\n'\n+            '      **height** (*int*) --\\n'\n+            == context)\n+\n @pytest.mark.sphinx('text', testroot='ext-autodoc',\n                     confoverrides={'autodoc_typehints': \"description\",\n                                    'autodoc_typehints_description_target': 'documented'})\n",
  "sphinx-doc__sphinx-10466": "diff --git a/tests/test_build_gettext.py b/tests/test_build_gettext.py\nindex a6fc946..2e63f17 100644\n--- a/tests/test_build_gettext.py\n+++ b/tests/test_build_gettext.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Test the build process with gettext builder with the test root.\"\"\"\n \n import gettext\n@@ -8,17 +9,41 @@ from subprocess import PIPE, CalledProcessError\n \n import pytest\n \n-from sphinx.util.osutil import cd\n-\n-\n-@pytest.mark.sphinx('gettext', srcdir='root-gettext')\n-def test_build_gettext(app):\n-    # Generic build; should fail only when the builder is horribly broken.\n-    app.builder.build_all()\n-\n-    # Do messages end up in the correct location?\n-    # top-level documents end up in a message catalog\n-    assert (app.outdir / 'extapi.pot').isfile()\n+from sphinx.builders.gettext import Catalog, MsgOrigin\n+\n+\n+def test_Catalog_duplicated_message():\n+    catalog = Catalog()\n+    catalog.add('hello', MsgOrigin('/path/to/filename', 1))\n+    catalog.add('hello', MsgOrigin('/path/to/filename', 1))\n+    catalog.add('hello', MsgOrigin('/path/to/filename', 2))\n+    catalog.add('hello', MsgOrigin('/path/to/yetanother', 1))\n+    catalog.add('world', MsgOrigin('/path/to/filename', 1))\n+\n+    assert len(list(catalog)) == 2\n+\n+    msg1, msg2 = list(catalog)\n+    assert msg1.text == 'hello'\n+    assert set(msg1.locations) == {('/path/to/filename', 1),\n+                                   ('/path/to/filename', 2),\n+                                   ('/path/to/yetanother', 1)}\n+    assert msg2.text == 'world'\n+    assert msg2.locations == [('/path/to/filename', 1)]\n+\n+def test_Catalog_no_duplicated_message():\n+    catalog = Catalog()\n+    catalog.add('greet', MsgOrigin('/docs/path', 10))\n+    catalog.add('greet', MsgOrigin('/docs/path', 10))\n+    catalog.add('greet', MsgOrigin('/docs/path', 20))\n+    catalog.add('bye', MsgOrigin('/docs/path', 10))\n+\n+    assert len(list(catalog)) == 2\n+\n+    msg1, msg2 = list(catalog)\n+    assert msg1.text == 'greet'\n+    assert set(msg1.locations) == {('/docs/path', 10), ('/docs/path', 20)}\n+    assert msg2.text == 'bye'\n+    assert msg2.locations == [('/docs/path', 10)]\n     # directory items are grouped into sections\n     assert (app.outdir / 'subdir.pot').isfile()\n \n",
  "sphinx-doc__sphinx-10673": "",
  "sphinx-doc__sphinx-7440": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 975a00f..9383d50 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -147,6 +147,31 @@ def test_glossary(app):\n     assert (\"term3\", \"term3\", \"term\", \"index\", \"term-term3\", -1) in objects\n     assert (\"term4\", \"term4\", \"term\", \"index\", \"term-term4\", -1) in objects\n \n+    # Testing for case-sensitivity in terms: \"mysql\" and \"MySQL\"\n+    text_case_sensitive = (\".. glossary::\\n\"\n+                           \"\\n\"\n+                           \"   mysql\\n\"\n+                           \"       description for mysql\\n\"\n+                           \"\\n\"\n+                           \"   MySQL\\n\"\n+                           \"       description for MySQL\\n\")\n+\n+    doctree_case_sensitive = restructuredtext.parse(app, text_case_sensitive)\n+    assert_node(doctree_case_sensitive, (\n+        [glossary, definition_list, ([definition_list_item, ([term, (\"mysql\", index)],\n+                                                            definition)],\n+                                    [definition_list_item, ([term, (\"MySQL\", index)],\n+                                                            definition)])],\n+    ))\n+    assert_node(doctree_case_sensitive[0][0][0][0][1],\n+                entries=[(\"single\", \"mysql\", \"term-mysql\", \"main\", None)])\n+    assert_node(doctree_case_sensitive[0][0][1][0][1],\n+                entries=[(\"single\", \"MySQL\", \"term-MySQL\", \"main\", None)])\n+\n+    objects_case_sensitive = list(app.env.get_domain(\"std\").get_objects())\n+    assert (\"mysql\", \"mysql\", \"term\", \"index\", \"term-mysql\", -1) in objects_case_sensitive\n+    assert (\"MySQL\", \"MySQL\", \"term\", \"index\", \"term-MySQL\", -1) in objects_case_sensitive\n+\n \n def test_glossary_warning(app, status, warning):\n     # empty line between terms\n",
  "sphinx-doc__sphinx-7757": "diff --git a/tests/test_util_inspect.py b/tests/test_util_inspect.py\nindex b3053d1..a16f5f5 100644\n--- a/tests/test_util_inspect.py\n+++ b/tests/test_util_inspect.py\n@@ -332,6 +332,20 @@ def test_signature_from_str_kwonly_args():\n     assert sig.parameters['b'].default == Parameter.empty\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 8),\n+                    reason='python-3.8 or above is required')\n+def test_signature_from_str_positional_only_args_with_defaults():\n+    sig = inspect.signature_from_str('(a, b=0, /, c=1)')\n+    assert list(sig.parameters.keys()) == ['a', 'b', 'c']\n+    assert sig.parameters['a'].kind == Parameter.POSITIONAL_ONLY\n+    assert sig.parameters['a'].default == Parameter.empty\n+    assert sig.parameters['b'].kind == Parameter.POSITIONAL_ONLY\n+    assert sig.parameters['b'].default == '0'\n+    assert sig.parameters['c'].kind == Parameter.POSITIONAL_OR_KEYWORD\n+    assert sig.parameters['c'].default == '1'\n+    assert sig.parameters['b'].default == Parameter.empty\n+\n+\n @pytest.mark.skipif(sys.version_info < (3, 8),\n                     reason='python-3.8 or above is required')\n def test_signature_from_str_positionaly_only_args():\n",
  "sphinx-doc__sphinx-7889": "diff --git a/tests/test_ext_autodoc_mock.py b/tests/test_ext_autodoc_mock.py\nindex 7302feb..6c2b5e1 100644\n--- a/tests/test_ext_autodoc_mock.py\n+++ b/tests/test_ext_autodoc_mock.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_ext_autodoc_mock\n     ~~~~~~~~~~~~~~~~~~~~~\n@@ -32,7 +33,18 @@ def test_MockModule():\n     assert repr(mock) == 'mocked_module'\n \n \n-def test_MockObject():\n+from typing import TypeVar\n+\n+def test_GenericMockObject():\n+    # Test the mock with a generically-typed class\n+    T = TypeVar('T')\n+\n+    class SubClass3(mock.SomeClass[T]):\n+        \"\"\"docstring of SubClass3\"\"\"\n+\n+    obj3 = SubClass3()\n+    assert SubClass3.__doc__ == \"docstring of SubClass3\"\n+    assert isinstance(obj3, SubClass3)\n     mock = _MockObject()\n     assert isinstance(mock.some_attr, _MockObject)\n     assert isinstance(mock.some_method, _MockObject)\n",
  "sphinx-doc__sphinx-7910": "diff --git a/tests/test_ext_napoleon.py b/tests/test_ext_napoleon.py\nindex 0676869..2bb6765 100644\n--- a/tests/test_ext_napoleon.py\n+++ b/tests/test_ext_napoleon.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_napoleon\n     ~~~~~~~~~~~~~\n@@ -165,10 +166,16 @@ class SkipMemberTest(TestCase):\n                         SampleClass.__special_doc__, False,\n                         'napoleon_include_special_with_doc')\n \n-    def test_class_special_undoc(self):\n-        self.assertSkip('class', '__special_undoc__',\n-                        SampleClass.__special_undoc__, True,\n-                        'napoleon_include_special_with_doc')\n+    @simple_decorator\n+    def __init__(self, x):\n+        \"\"\"Initializes with x.\"\"\"\n+        self.x = x\n+\n+    def test_decorated_init_doc(self):\n+        # Expected to be False because we want it to not skip, thus included in documentation\n+        self.assertSkip('class', '__init__',\n+                        SampleClass.__init__, False,\n+                        'napoleon_include_init_with_doc')\n \n     def test_exception_private_doc(self):\n         self.assertSkip('exception', '_private_doc',\n",
  "sphinx-doc__sphinx-7985": "diff --git a/tests/test_build_linkcheck.py b/tests/test_build_linkcheck.py\nindex 5b1b2ed..e5b6389 100644\n--- a/tests/test_build_linkcheck.py\n+++ b/tests/test_build_linkcheck.py\n@@ -8,6 +8,37 @@\n     :license: BSD, see LICENSE for details.\n \"\"\"\n \n+@pytest.mark.sphinx('linkcheck', testroot='linkcheck', freshenv=True)\n+def test_internal_linkcheck(app, status, warning):\n+    app.builder.build_all()\n+\n+    assert (app.outdir / 'output.txt').exists()\n+    content = (app.outdir / 'output.txt').read_text()\n+\n+    # Check for existence of a local file (`conf.py`) marked as an internal link\n+    assert \"conf.py\" in content\n+    # Check for non-existence where the local file is absent (`path/to/notfound`)\n+    assert \"[broken] path/to/notfound\" in content\n+    # Length check to ensure our content lines match expectations\n+    assert len(content.splitlines()) >= 6\n+\n+@pytest.mark.sphinx('linkcheck', testroot='linkcheck', freshenv=True)\n+def test_internal_linkcheck_json(app, status, warning):\n+    app.builder.build_all()\n+\n+    assert (app.outdir / 'output.json').exists()\n+    content = (app.outdir / 'output.json').read_text()\n+    print(content)\n+\n+    rows = [json.loads(x) for x in content.splitlines()]\n+    assert any(row.get('uri') == 'conf.py' for row in rows)\n+    assert any(row.get('uri') == 'path/to/notfound' and row.get('status') == 'broken' for row in rows)\n+    # Check the total number of lines and rows\n+    assert len(content.splitlines()) >= 10\n+    assert len(rows) >= 10\n+\n+import os\n+\n import json\n import re\n from unittest import mock\n",
  "sphinx-doc__sphinx-8035": "diff --git a/tests/test_ext_autodoc_private_members.py b/tests/test_ext_autodoc_private_members.py\nindex ad1d950..08c729b 100644\n--- a/tests/test_ext_autodoc_private_members.py\n+++ b/tests/test_ext_autodoc_private_members.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_ext_autodoc_private_members\n     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n@@ -11,6 +12,9 @@\n import pytest\n \n from test_ext_autodoc import do_autodoc\n+from sphinx.pycode import ModuleAnalyzer\n+from sphinx.testing.fixtures import test_params, test_app\n+import types\n \n \n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n@@ -59,4 +63,31 @@ def test_private_field_and_private_members(app):\n         '',\n         '   :meta private:',\n         '',\n+    ]\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_specific_private_members(app):\n+    # This test is for explicitly specifying private members to document\n+    app.config.autoclass_content = 'class'\n+    options = {\"private-members\": \"_private_method1,_private_method2\"}\n+    actual = do_autodoc(app, 'class', 'target.ClassWithPrivateMembers', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: ClassWithPrivateMembers',\n+        '   :module: target',\n+        '',\n+        '   ClassWithPrivateMembers is a class with private members.',\n+        '',\n+        '',\n+        '   .. py:method:: ClassWithPrivateMembers._private_method1()',\n+        '      :module: target',\n+        '',\n+        '      _private_method1 is a private method.',\n+        '',\n+        '',\n+        '   .. py:method:: ClassWithPrivateMembers._private_method2()',\n+        '      :module: target',\n+        '',\n+        '      _private_method2 is another private method.',\n+        '',\n     ]\n",
  "sphinx-doc__sphinx-8120": "",
  "sphinx-doc__sphinx-8269": "diff --git a/tests/test_build_linkcheck.py b/tests/test_build_linkcheck.py\nindex 7842f56..27ab9e4 100644\n--- a/tests/test_build_linkcheck.py\n+++ b/tests/test_build_linkcheck.py\n@@ -107,6 +107,31 @@ def test_anchors_ignored(app, status, warning):\n     assert not content\n \n \n+import pytest\n+import http.server\n+import threading\n+\n+@pytest.mark.sphinx('linkcheck', testroot='linkcheck', freshenv=True)\n+def test_reports_404_error(app, status, warning):\n+    class NotFoundHandler(http.server.BaseHTTPRequestHandler):\n+        def do_GET(self):\n+            self.send_error(404, \"Not Found\")\n+\n+    server_thread = HttpServerThread(NotFoundHandler, daemon=True)\n+    server_thread.start()\n+    try:\n+        app.config['master_doc'] = 'index'\n+        with open(app.srcdir / 'index.rst', 'w') as f:\n+            f.write(\"`404 link <http://localhost:7777/#anchor>`_\\n\")\n+        \n+        app.builder.build_all()\n+        \n+        content = (app.outdir / 'output.txt').read_text()\n+        assert \"404 Client Error: Not Found for url: http://localhost:7777/\" in content\n+    finally:\n+        server_thread.terminate()\n+\n+\n @pytest.mark.sphinx(\n     'linkcheck', testroot='linkcheck', freshenv=True,\n     confoverrides={'linkcheck_auth': [\n@@ -116,6 +141,20 @@ def test_anchors_ignored(app, status, warning):\n                   })\n def test_auth(app, status, warning):\n     mock_req = mock.MagicMock()\n+\n+\n+class HttpServerThread(threading.Thread):\n+    def __init__(self, handler, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+        self.server = http.server.HTTPServer((\"localhost\", 7777), handler)\n+\n+    def run(self):\n+        self.server.serve_forever(poll_interval=0.01)\n+\n+    def terminate(self):\n+        self.server.shutdown()\n+        self.server.server_close()\n+        self.join()\n     mock_req.return_value = 'fake-response'\n \n     with mock.patch.multiple('requests', get=mock_req, head=mock_req):\n@@ -159,4 +198,11 @@ def test_linkcheck_request_headers(app, status, warning):\n                 assert headers[\"Accept\"] == \"text/html,application/xhtml+xml;q=0.9,*/*;q=0.8\"\n                 assert headers[\"X-Secret\"] == \"open sesami\"\n             else:\n-                assert headers[\"Accept\"] == \"text/html,application/xhtml+xml;q=0.9,*/*;q=0.8\"\n+                assert headers[\"Accept\"] == \"text/html,application/xhtml+xml;q=0.9,*/*;q=0.8\"\n+\n+\n+\n+\n+\n+\n+\n",
  "sphinx-doc__sphinx-8459": "",
  "sphinx-doc__sphinx-8475": "diff --git a/tests/test_build_linkcheck.py b/tests/test_build_linkcheck.py\nindex 41632e7..e1ff7ba 100644\n--- a/tests/test_build_linkcheck.py\n+++ b/tests/test_build_linkcheck.py\n@@ -381,4 +381,84 @@ def test_connect_to_selfsigned_nonexistent_cert_file(app):\n         \"lineno\": 1,\n         \"uri\": \"https://localhost:7777/\",\n         \"info\": \"Could not find a suitable TLS CA certificate bundle, invalid path: does/not/exist\",\n-    }\n+    }\n+\n+@pytest.mark.sphinx('linkcheck', testroot='linkcheck-localserver', freshenv=True)\n+def test_TooManyRedirects_on_GET(app):\n+    class InfiniteRedirectOnGetHandler(http.server.BaseHTTPRequestHandler):\n+        def do_HEAD(self):\n+            self.send_response(200, \"OK\")\n+            self.end_headers()\n+            self.wfile.write(b\"ok\\\\n\")\n+\n+        def do_GET(self):\n+            self.send_response(302, \"Found\")\n+            self.send_header(\"Location\", \"http://localhost:7777/\")\n+            self.end_headers()\n+\n+    with http_server(InfiniteRedirectOnGetHandler):\n+        app.builder.build_all()\n+\n+    with open(app.outdir / 'output.json') as fp:\n+        content = json.load(fp)\n+    assert content == {\n+        \"code\": 0,\n+        \"status\": \"broken\",\n+        \"filename\": \"index.rst\",\n+        \"lineno\": 1,\n+        \"uri\": \"http://localhost:7777/\",\n+        \"info\": \"Too many redirects\",\n+    }\n+\n+@pytest.mark.sphinx('linkcheck', testroot='linkcheck-localserver', freshenv=True)\n+def test_Valid_URL_no_redirects(app):\n+    class ValidRequestHandler(http.server.BaseHTTPRequestHandler):\n+        def do_HEAD(self):\n+            self.send_response(200, \"OK\")\n+            self.end_headers()\n+\n+        def do_GET(self):\n+            self.send_response(200, \"OK\")\n+            self.end_headers()\n+            self.wfile.write(b\"ok\\\\n\")\n+\n+    with http_server(ValidRequestHandler):\n+        app.builder.build_all()\n+\n+    with open(app.outdir / 'output.json') as fp:\n+        content = json.load(fp)\n+    assert content == {\n+        \"code\": 0,\n+        \"status\": \"working\",\n+        \"filename\": \"index.rst\",\n+        \"lineno\": 1,\n+        \"uri\": \"http://localhost:7777/\",\n+        \"info\": \"\",\n+    }\n+\n+@pytest.mark.sphinx('linkcheck', testroot='linkcheck-localserver', freshenv=True)\n+def test_TooManyRedirects_on_both_HEAD_and_GET(app):\n+    class CompleteRedirectHandler(http.server.BaseHTTPRequestHandler):\n+        def do_HEAD(self):\n+            self.send_response(302, \"Found\")\n+            self.send_header(\"Location\", \"http://localhost:7777/\")\n+            self.end_headers()\n+\n+        def do_GET(self):\n+            self.send_response(302, \"Found\")\n+            self.send_header(\"Location\", \"http://localhost:7777/\")\n+            self.end_headers()\n+\n+    with http_server(CompleteRedirectHandler):\n+        app.builder.build_all()\n+\n+    with open(app.outdir / 'output.json') as fp:\n+        content = json.load(fp)\n+    assert content == {\n+        \"code\": 0,\n+        \"status\": \"broken\",\n+        \"filename\": \"index.rst\",\n+        \"lineno\": 1,\n+        \"uri\": \"http://localhost:7777/\",\n+        \"info\": \"Too many redirects\",\n+    }\n",
  "sphinx-doc__sphinx-8595": "",
  "sphinx-doc__sphinx-8721": "",
  "sphinx-doc__sphinx-9281": "diff --git a/tests/test_util_inspect.py b/tests/test_util_inspect.py\nindex 3c31d3d..c09e3a1 100644\n--- a/tests/test_util_inspect.py\n+++ b/tests/test_util_inspect.py\n@@ -515,6 +515,18 @@ def test_dict_customtype():\n     # Type is unsortable, just check that it does not crash\n     assert \"<CustomType(2)>: 2\" in description\n \n+def test_object_description_enum_value():\n+    import enum\n+\n+    class MyEnum(enum.Enum):\n+        ValueA = 10\n+        ValueB = 20\n+\n+    # The expected string should be \"MyEnum.ValueA\" instead of \"<MyEnum.ValueA: 10>\"\n+    expected_description = \"MyEnum.ValueA\"\n+    actual_description = inspect.object_description(MyEnum.ValueA)\n+    assert actual_description == expected_description, f\"Expected '{expected_description}' but got '{actual_description}'\"\n+\n \n def test_getslots():\n     class Foo:\n",
  "sphinx-doc__sphinx-9320": "diff --git a/tests/test_quickstart.py b/tests/test_quickstart.py\nindex ff8df08..d7bb34e 100644\n--- a/tests/test_quickstart.py\n+++ b/tests/test_quickstart.py\n@@ -10,6 +10,7 @@\n \n import time\n from io import StringIO\n+import sys\n \n import pytest\n \n@@ -241,7 +242,32 @@ def test_default_filename(tempdir):\n     exec(conffile.read_text(), ns)\n \n \n-def test_extensions(tempdir):\n+def test_exits_when_existing_confpy(monkeypatch):\n+    # Mock path.isfile to simulate the existence of conf.py\n+    monkeypatch.setattr(path, 'isfile', lambda x: True)\n+\n+    # Mock user input to simulate pressing 'Enter'\n+    monkeypatch.setattr('builtins.input', lambda _: '')\n+\n+    # Capture the SystemExit to verify it exits correctly\n+    with pytest.raises(SystemExit) as exc_info:\n+        qs.ask_user({})\n+\n+    assert exc_info.value.code == 1  # Ensure it exits with status code 1\n+\n+def test_exits_when_no_existing_confpy(monkeypatch):\n+    # Mock path.isfile to simulate a directory without conf.py\n+    monkeypatch.setattr(path, 'isfile', lambda x: False)\n+\n+    # Mock user input to provide valid inputs\n+    input_values = iter(['.'])\n+    \n+    monkeypatch.setattr('builtins.input', lambda _: next(input_values))\n+\n+    try:\n+        qs.ask_user({})\n+    except SystemExit:\n+        pytest.fail(\"SystemExit should not be raised when no conf.py exists.\")\n     qs.main(['-q', '-p', 'project_name', '-a', 'author',\n              '--extensions', 'foo,bar,baz', tempdir])\n \n",
  "sphinx-doc__sphinx-9367": "diff --git a/tests/test_pycode_ast.py b/tests/test_pycode_ast.py\nindex a3de258..8fc9e97 100644\n--- a/tests/test_pycode_ast.py\n+++ b/tests/test_pycode_ast.py\n@@ -54,6 +54,7 @@ from sphinx.pycode import ast\n     (\"- 1\", \"- 1\"),                             # UnaryOp\n     (\"- a\", \"- a\"),                             # USub\n     (\"(1, 2, 3)\", \"(1, 2, 3)\"),                   # Tuple\n+    (\"(1,)\", \"(1,)\"),                             # Tuple (single element, issue #8265)\n     (\"()\", \"()\"),                               # Tuple (empty)\n ])\n def test_unparse(source, expected):\n",
  "sphinx-doc__sphinx-9591": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex 29731ea..fa7a3df 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -847,7 +847,42 @@ def test_pyproperty(app):\n     assert domain.objects['Class.prop2'] == ('index', 'Class.prop2', 'property', False)\n \n \n-def test_pydecorator_signature(app):\n+def test_property_type_annotation_cross_reference(app):\n+    text = (\".. py:class:: Point\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: x\\n\"\n+            \"      :type: int\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: y\\n\"\n+            \"      :type: int\\n\"\n+            \"\\n\"\n+            \".. py:class:: Square\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: start\\n\"\n+            \"      :type: Point\\n\"\n+            \"\\n\"\n+            \"   .. py:property:: end\\n\"\n+            \"      :type: Point\\n\"\n+            \"\\n\"\n+            \".. py:class:: Rectangle\\n\"\n+            \"\\n\"\n+            \"   .. py:attribute:: start\\n\"\n+            \"      :type: Point\\n\"\n+            \"\\n\"\n+            \"   .. py:property:: end\\n\"\n+            \"      :type: Point\\n\")\n+    domain = app.env.get_domain('py')\n+    doctree = restructuredtext.parse(app, text)\n+    \n+    # Test Square class's property\n+    assert_node(doctree[5][1][1], [desc_signature, ([desc_annotation, \"property \"],\n+                                                     [desc_name, \"end\"],\n+                                                     [desc_annotation, \": \", pending_xref, \"Point\"])])\n+    \n+    # Test Rectangle class's property\n+    assert_node(doctree[9][1][1], [desc_signature, ([desc_annotation, \"property \"],\n+                                                     [desc_name, \"end\"],\n+                                                     [desc_annotation, \": \", pending_xref, \"Point\"])])\n     text = \".. py:decorator:: deco\"\n     domain = app.env.get_domain('py')\n     doctree = restructuredtext.parse(app, text)\n",
  "sphinx-doc__sphinx-9698": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex 4731988..c636965 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -756,7 +756,7 @@ def test_pymethod_options(app):\n \n     # :property:\n     assert_node(doctree[1][1][8], addnodes.index,\n-                entries=[('single', 'meth5() (Class property)', 'Class.meth5', '', None)])\n+                entries=[('single', 'meth5 (Class property)', 'Class.meth5', '', None)])\n     assert_node(doctree[1][1][9], ([desc_signature, ([desc_annotation, (\"property\", desc_sig_space)],\n                                                      [desc_name, \"meth5\"])],\n                                    [desc_content, ()]))\n",
  "sphinx-doc__sphinx-9711": "",
  "sympy__sympy-11618": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 399f58e..ed40dde 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -236,7 +236,25 @@ def test_Point2D():\n     assert p2.distance(p3) == sqrt(17)/2\n \n \n-def test_issue_9214():\n+def test_issue_11617():\n+    p1 = Point3D(1, 0, 2)\n+    p2 = Point2D(2, 0)\n+    assert p1.distance(p2) == sqrt(5)\n+\n+def test_2d_3d_distance():\n+    p1 = Point2D(3, 4)\n+    p2 = Point3D(0, 0, 0)\n+    assert p1.distance(p2) == 5\n+\n+def test_3d_3d_distance():\n+    p1 = Point3D(1, 2, 2)\n+    p2 = Point3D(4, 6, 3)\n+    assert p1.distance(p2) == sqrt(27)\n+\n+def test_2d_2d_distance():\n+    p1 = Point2D(1, 2)\n+    p2 = Point2D(4, 6)\n+    assert p1.distance(p2) == 5\n     p1 = Point3D(4, -2, 6)\n     p2 = Point3D(1, 2, 3)\n     p3 = Point3D(7, 2, 3)\n",
  "sympy__sympy-12096": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex 386dc7c..724de62 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -741,7 +741,27 @@ def test_special_printers():\n     assert isinstance(func1(), mpi)\n     assert isinstance(func2(), mpi)\n \n-def test_true_false():\n+from sympy.core.numbers import Float\n+from sympy.utilities.lambdify import implemented_function\n+\n+def test_issue_12092():\n+    f = implemented_function('f', lambda x: x**2)\n+    assert f(f(2)).evalf() == Float(16)\n+\n+def test_recursive_evalf():\n+    f = implemented_function('f', lambda x: x**2)\n+    g = implemented_function('g', lambda x: 2 * x)\n+    # Test with nested function evaluations\n+    assert f(g(2)).evalf() == Float(16)  # f(g(2)) = f(4) = 16\n+    assert g(f(2)).evalf() == Float(8)   # g(f(2)) = g(4) = 8\n+\n+def test_multiple_compositions():\n+    f = implemented_function('f', lambda x: x**2)\n+    g = implemented_function('g', lambda x: 2 * x)\n+    h = implemented_function('h', lambda x: x + 1)\n+    # Test with more complex nested functions\n+    assert f(g(h(2))).evalf() == Float(36)  # f(g(h(2))) = f(g(3)) = f(6) = 36\n+    assert h(f(g(2))).evalf() == Float(17)  # h(f(g(2))) = h(16) = 17\n     # We want exact is comparison here, not just ==\n     assert lambdify([], true)() is True\n     assert lambdify([], false)() is False\n",
  "sympy__sympy-12419": "",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..ecf3e21 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -350,6 +350,15 @@ def test_args():\n            # enclosing brackets needed on 0\n     raises(ValueError, lambda: Permutation([1, 1, 0]))\n     raises(ValueError, lambda: Permutation([[1], [1, 2]]))\n+\n+    # Test for non-disjoint cycles resolving issue\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])  # Identity permutation\n+    assert Permutation([[0, 2, 1], [1, 0]]) == Permutation([0, 2, 1])  # Results in cycle [0, 2, 1]\n+    assert Permutation([[2, 3], [3, 2]]) == Permutation([0, 1, 2, 3])  # Identity permutation\n+    assert Permutation([[0, 1, 2], [2, 0]]) == Permutation([2, 0, 1])  # Results in cycle [2, 0, 1]\n+    assert Permutation([[0, 1, 2], [2, 0, 1]]) == Permutation([1, 2, 0])  # Results in cycle [1, 2, 0]\n+    assert Permutation([[0, 2], [1, 0]]) == Permutation([2, 1, 0])  # Results in cycle [2, 1, 0]\n+    assert Permutation([[0, 1], [1, 2], [2, 0]]) == Permutation([1, 2, 0])  # Results in cycle [1, 2, 0]\n     raises(ValueError, lambda: Permutation([4, 5], size=10))  # where are 0-3?\n     # but this is ok because cycles imply that only those listed moved\n     assert Permutation(4, 5) == Permutation([0, 1, 2, 3, 5, 4])\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..81e497a 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -502,8 +502,14 @@ def test_sparse_zeros_sparse_eye():\n     assert SparseMatrix.zeros(3) == zeros(3, cls=SparseMatrix)\n     assert len(SparseMatrix.zeros(3)._smat) == 0\n \n-\n-def test_copyin():\n+def test_sparse_stacking_zeros():\n+    # Testing horizontal stacking of 0 x n matrices\n+    sparse_matrices_h = [SparseMatrix.zeros(0, n) for n in range(4)]\n+    assert SparseMatrix.hstack(*sparse_matrices_h).shape == (0, 6)\n+\n+    # Testing vertical stacking of n x 0 matrices\n+    sparse_matrices_v = [SparseMatrix.zeros(n, 0) for n in range(4)]\n+    assert SparseMatrix.vstack(*sparse_matrices_v).shape == (6, 0)\n     s = SparseMatrix(3, 3, {})\n     s[1, 0] = 1\n     assert s[:, 0] == SparseMatrix(Matrix([0, 1, 0]))\n",
  "sympy__sympy-13372": "diff --git a/sympy/core/tests/test_evalf.py b/sympy/core/tests/test_evalf.py\nindex e95146a..d05b508 100644\n--- a/sympy/core/tests/test_evalf.py\n+++ b/sympy/core/tests/test_evalf.py\n@@ -170,8 +170,13 @@ def test_evalf_ramanujan():\n \n # Input that for various reasons have failed at some point\n \n+from sympy import Mul, Max, symbols\n \n-def test_evalf_bugs():\n+def test_evalf_mul_max_order_issue():\n+    # This test is specifically for issue 13076\n+    x, y = symbols('x y')\n+    assert NS(Mul(Max(0, y), x, evaluate=False).evalf()) == 'x*Max(0, y)'\n+    assert NS(Mul(x, Max(0, y), evaluate=False).evalf()) == 'x*Max(0, y)'\n     assert NS(sin(1) + exp(-10**10), 10) == NS(sin(1), 10)\n     assert NS(exp(10**10) + sin(1), 10) == NS(exp(10**10), 10)\n     assert NS('log(1+1/10**50)', 20) == '1.0000000000000000000e-50'\n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..c7839de 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -209,8 +209,19 @@ def test_tanh_series():\n     assert tanh(x).series(x, 0, 10) == \\\n         x - x**3/3 + 2*x**5/15 - 17*x**7/315 + 62*x**9/2835 + O(x**10)\n \n+def test_coth_substitution_issue():\n+    from sympy import coth, log, tan, Symbol\n \n-def test_coth():\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+\n+    # Test the substitution for values that previously caused an error\n+    for val in [2, 3, 5, 6, 8, 9, 11, 12, 13, 15, 18]:\n+        try:\n+            result = e.subs(x, val)\n+            assert result is not None, f\"Expected a result but got None for x = {val}\"\n+        except NameError as ne:\n+            assert False, f\"Substitution failed for x = {val} with error: {ne}\"\n     x, y = symbols('x,y')\n \n     k = Symbol('k', integer=True)\n",
  "sympy__sympy-13615": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 6d534c0..6ec5713 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -165,7 +165,13 @@ def test_difference():\n     assert -1 in S.Reals - S.Naturals\n \n \n+from sympy import FiniteSet, Interval, Complement, Symbol, oo, S, Union, EmptySet, pi\n+\n+x, y = Symbol('x'), Symbol('y')\n+\n def test_Complement():\n+    # Test for the specific issue with mixed numbers and symbols in FiniteSet\n+    assert Complement(FiniteSet(x, y, 2), Interval(-10, 10)) == FiniteSet(x, y)\n     assert Complement(Interval(1, 3), Interval(1, 2)) == Interval(2, 3, True)\n     assert Complement(FiniteSet(1, 3, 4), FiniteSet(3, 4)) == FiniteSet(1)\n     assert Complement(Union(Interval(0, 2),\n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..e14baeb 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -201,7 +201,45 @@ def test_col_insert():\n         l.insert(i, 4)\n         assert flatten(zeros_Shaping(3).col_insert(i, c4).row(0).tolist()) == l\n \n-def test_extract():\n+def test_issue_13643_col_insert():\n+    from sympy import Matrix, eye\n+    M = eye(6)\n+    V = 2 * Matrix.ones(6, 2)\n+    \n+    result = M.col_insert(3, V)\n+    expected = Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    assert result == expected, f\"Expected:\\n{expected}, but got:\\n{result}\"\n+\n+    # Additional test: inserting into the 0th column\n+    result_zero_insert = M.col_insert(0, V)\n+    expected_zero_insert = Matrix([\n+        [2, 2, 1, 0, 0, 0, 0, 0],\n+        [2, 2, 0, 1, 0, 0, 0, 0],\n+        [2, 2, 0, 0, 1, 0, 0, 0],\n+        [2, 2, 0, 0, 0, 1, 0, 0],\n+        [2, 2, 0, 0, 0, 0, 1, 0],\n+        [2, 2, 0, 0, 0, 0, 0, 1]\n+    ])\n+    assert result_zero_insert == expected_zero_insert, f\"Expected:\\n{expected_zero_insert}, but got:\\n{result_zero_insert}\"\n+\n+    # Additional test: inserting at the end\n+    result_end_insert = M.col_insert(6, V)\n+    expected_end_insert = Matrix([\n+        [1, 0, 0, 0, 0, 0, 2, 2],\n+        [0, 1, 0, 0, 0, 0, 2, 2],\n+        [0, 0, 1, 0, 0, 0, 2, 2],\n+        [0, 0, 0, 1, 0, 0, 2, 2],\n+        [0, 0, 0, 0, 1, 0, 2, 2],\n+        [0, 0, 0, 0, 0, 1, 2, 2]\n+    ])\n+    assert result_end_insert == expected_end_insert, f\"Expected:\\n{expected_end_insert}, but got:\\n{result_end_insert}\"\n     m = ShapingOnlyMatrix(4, 3, lambda i, j: i*3 + j)\n     assert m.extract([0, 1, 3], [0, 1]) == Matrix(3, 2, [0, 1, 3, 4, 9, 10])\n     assert m.extract([0, 3], [0, 0, 2]) == Matrix(2, 3, [0, 0, 2, 9, 9, 11])\n",
  "sympy__sympy-13757": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex a463b22..dc5f0d2 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -677,8 +677,16 @@ def test_Poly_mul():\n     assert Poly(x, x) * 2 == Poly(2*x, x)\n     assert 2 * Poly(x, x) == Poly(2*x, x)\n \n+from sympy import Poly, Symbol, S\n \n-def test_Poly_sqr():\n+x = Symbol('x')\n+\n+def test_issue_13079():\n+    assert Poly(x)*x == Poly(x**2, x, domain='ZZ')\n+    assert x*Poly(x) == Poly(x**2, x, domain='ZZ')\n+    assert -2*Poly(x) == Poly(-2*x, x, domain='ZZ')\n+    assert S(-2)*Poly(x) == Poly(-2*x, x, domain='ZZ')\n+    assert Poly(x)*S(-2) == Poly(-2*x, x, domain='ZZ')\n     assert Poly(x*y, x, y).sqr() == Poly(x**2*y**2, x, y)\n \n \n",
  "sympy__sympy-13798": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex b1f9614..609e52d 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -65,6 +65,14 @@ def test_latex_basic():\n     assert latex(2*x*y, mul_symbol='dot') == r\"2 \\cdot x \\cdot y\"\n \n     assert latex(1/x) == r\"\\frac{1}{x}\"\n+\n+    # Test custom mul_symbol with thin space\n+    assert latex(3*x**2*y, mul_symbol='\\,') == r\"3\\,x^{2}\\,y\"\n+    assert latex(x*y*z, mul_symbol='\\,') == r\"x\\,y\\,z\"\n+    assert latex(x*y*z, mul_symbol=None) == r\"x y z\"\n+    assert latex(x**2*y, mul_symbol='times') == r\"x^{2} \\times y\"\n+    assert latex(x**2*y, mul_symbol='dot') == r\"x^{2} \\cdot y\"\n+    assert latex(x**2*y, mul_symbol='ldot') == r\"x^{2} \\,.\\, y\"\n     assert latex(1/x, fold_short_frac=True) == \"1 / x\"\n     assert latex(-S(3)/2) == r\"- \\frac{3}{2}\"\n     assert latex(-S(3)/2, fold_short_frac=True) == r\"- 3 / 2\"\n",
  "sympy__sympy-13877": "diff --git a/sympy/matrices/tests/test_matrices.py b/sympy/matrices/tests/test_matrices.py\nindex 2018055..3b71b52 100644\n--- a/sympy/matrices/tests/test_matrices.py\n+++ b/sympy/matrices/tests/test_matrices.py\n@@ -402,8 +402,27 @@ def test_determinant():\n     assert M.det(method=\"bareiss\") == z**2 - x*y\n     assert M.det(method=\"berkowitz\") == z**2 - x*y\n \n-\n-def test_det_LU_decomposition():\n+def test_issue_13835():\n+    from sympy import symbols, Matrix\n+\n+    a = symbols('a')\n+    M = lambda n: Matrix([[i + a*j for i in range(n)] for j in range(n)])\n+\n+    assert M(5).det() == 0\n+    assert M(6).det() == 0\n+    assert M(7).det() == 0\n+\n+    # Additional test cases to verify behavior for lower sizes:\n+    assert M(1).det() == 0\n+    assert M(2).det() == -a\n+    assert M(3).det().expand() == -a*(a + 1)*(a - 1)\n+    assert M(4).det() == 0\n+\n+    # Testing with various symbolic entries to ensure robustness\n+    b, c = symbols('b c')\n+    N = lambda n: Matrix([[c*i + b*j for i in range(n)] for j in range(n)])\n+    assert N(2).det() == -b*c\n+    assert N(3).det().expand() == b*c*(b*c + b - c)\n \n     for M in [Matrix(), Matrix([[1]])]:\n         assert M.det(method=\"lu\") == 1\n",
  "sympy__sympy-13878": "diff --git a/sympy/stats/tests/test_continuous_rv.py b/sympy/stats/tests/test_continuous_rv.py\nindex ff0c413..f7ef09a 100644\n--- a/sympy/stats/tests/test_continuous_rv.py\n+++ b/sympy/stats/tests/test_continuous_rv.py\n@@ -157,6 +157,60 @@ def test_characteristic_function():\n     assert simplify(cf(1)) == S(25)/26 + 5*I/26\n \n \n+from sympy import Piecewise, symbols, sqrt, pi, exp, lowergamma, gamma, uppergamma, hyper, S\n+from sympy.stats import cdf, density, Arcsin, Dagum, Erlang, Frechet, Gamma, GammaInverse, Kumaraswamy, Laplace, Logistic, Nakagami, StudentT, UniformSum\n+\n+def test_precomputed_cdf_issue():\n+    x = symbols('x', real=True, finite=True)\n+\n+    # Test Arcsin distribution\n+    X = Arcsin(\"X\", 0, 3)\n+    assert cdf(X)(1) == Piecewise((0, x < 0), (2*asin(sqrt(x/3))/pi, x <= 3), (1, True))\n+\n+    # Test Dagum distribution\n+    X = Dagum(\"X\", S(1)/3, S(1)/5, 2)\n+    assert cdf(X)(3) == Piecewise(((1 + (3/2)**(-1/5))**(-1/3), 3 >= 0), (0, True))\n+\n+    # Test Erlang distribution\n+    X = Erlang(\"X\", 1, 1)\n+    assert cdf(X)(1) == lowergamma(1, 1)/gamma(1)\n+\n+    # Test Frechet distribution\n+    X = Frechet(\"X\", S(4)/3, 1, 2)\n+    assert isinstance(cdf(X)(3), Expr)  # Check it doesn't hang\n+\n+    # Test Gamma distribution\n+    X = Gamma(\"X\", S(0.1), 2)\n+    assert cdf(X)(3).simplify() == lowergamma(0.1, 1.5)/gamma(0.1)\n+\n+    # Test Gamma Inverse distribution\n+    X = GammaInverse(\"X\", S(5)/7, 2)\n+    assert isinstance(cdf(X)(3), Expr)  # Check it doesn't hang\n+\n+    # Test Kumaraswamy distribution\n+    X = Kumaraswamy(\"X\", S(1)/123, 5)\n+    assert isinstance(cdf(X)(S(1)/3), Expr)  # Check it doesn't hang\n+\n+    # Test Laplace distribution\n+    X = Laplace(\"X\", 2, 3)\n+    assert cdf(X)(5) == Piecewise((exp(-1), x >= 2), (-exp(-1) + 1, True))\n+\n+    # Test Logistic distribution\n+    X = Logistic(\"X\", 1, 0.1)\n+    assert cdf(X)(2) == 1/(exp(10) + 1)\n+\n+    # Test Nakagami distribution\n+    X = Nakagami(\"X\", S(7)/3, 1)\n+    assert isinstance(cdf(X)(2), Expr)  # Check it doesn't hang\n+\n+    # Test StudentT distribution\n+    X = StudentT(\"X\", 10)\n+    assert isinstance(cdf(X)(2), Expr)  # Check it doesn't hang\n+\n+    # Test UniformSum distribution\n+    X = UniformSum(\"X\", 5)\n+    assert isinstance(cdf(X)(2), Expr)  # Check it doesn't hang\n+\n def test_sample():\n     z = Symbol('z')\n     Z = ContinuousRV(z, exp(-z), set=Interval(0, oo))\n",
  "sympy__sympy-13974": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bd3e825..13f1622 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -48,6 +48,18 @@ def test_tensor_product_commutator():\n def test_tensor_product_simp():\n     assert tensor_product_simp(TP(A, B)*TP(B, C)) == TP(A*B, B*C)\n \n+    # Test cases for the issue with TensorProduct powers\n+    a = Symbol('a', commutative=False)\n+    t1 = TP(1, 1)*TP(1, 1)\n+    assert tensor_product_simp(t1) == TP(1*1, 1*1)\n+    assert t1.expand(tensorproduct=True) == TP(1*1, 1*1)\n+    assert tensor_product_simp(TP(1, 1)*TP(1, a)).subs(a, 1) == TP(1*1, 1*1)\n+\n+    t2 = TP(1, Pauli(3))*TP(1, Pauli(3))\n+    assert tensor_product_simp(t2) == TP(1*1, Pauli(3)*Pauli(3))\n+    assert t2.expand(tensorproduct=True) == TP(1*1, Pauli(3)*Pauli(3))\n+    assert tensor_product_simp(TP(1, Pauli(3))*TP(1, a)).subs(a, Pauli(3)) == TP(1*1, Pauli(3)*Pauli(3))\n+\n \n def test_issue_5923():\n     # most of the issue regarding sympification of args has been handled\n",
  "sympy__sympy-14531": "diff --git a/sympy/printing/tests/test_python.py b/sympy/printing/tests/test_python.py\nindex 73fc070..f5baba9 100644\n--- a/sympy/printing/tests/test_python.py\n+++ b/sympy/printing/tests/test_python.py\n@@ -70,6 +70,13 @@ def test_python_keyword_symbol_name_escaping():\n         5*Symbol(\"lambda\")) == \"lambda_ = Symbol('lambda')\\ne = 5*lambda_\"\n     assert (python(5*Symbol(\"lambda\") + 7*Symbol(\"lambda_\")) ==\n             \"lambda__ = Symbol('lambda')\\nlambda_ = Symbol('lambda_')\\ne = 7*lambda_ + 5*lambda__\")\n+    \n+    assert python(Eq(x, y)) == \"x = Symbol('x')\\ny = Symbol('y')\\ne = Eq(x, y)\"\n+    assert python(Ne(x/(y + 1), y**2)) in [\n+        \"x = Symbol('x')\\ny = Symbol('y')\\ne = Ne(x/(1 + y), y**2)\",\n+        \"x = Symbol('x')\\ny = Symbol('y')\\ne = Ne(x/(y + 1), y**2)\"\n+    ]\n+\n     assert (python(5*Symbol(\"for\") + Function(\"for_\")(8)) ==\n             \"for__ = Symbol('for')\\nfor_ = Function('for_')\\ne = 5*for__ + for_(8)\")\n \n",
  "sympy__sympy-14711": "diff --git a/sympy/physics/vector/tests/test_vector.py b/sympy/physics/vector/tests/test_vector.py\nindex de6a8ff..12c2891 100644\n--- a/sympy/physics/vector/tests/test_vector.py\n+++ b/sympy/physics/vector/tests/test_vector.py\n@@ -4,6 +4,19 @@ from sympy.abc import x, y, z\n from sympy.utilities.pytest import raises\n \n \n+from sympy.physics.vector import ReferenceFrame, dot, Vector\n+from sympy import symbols\n+\n+def test_vector_addition_with_zero_multiplication():\n+    N = ReferenceFrame('N')\n+    zero_vector = 0 * N.x\n+    assert N.x + zero_vector == N.x\n+    assert zero_vector + N.x == N.x\n+    assert N.y + zero_vector == N.y\n+    assert zero_vector + N.y == N.y\n+    assert N.x + zero_vector + N.y == N.x + N.y\n+    assert zero_vector + zero_vector == Vector(0)\n+\n Vector.simp = True\n A = ReferenceFrame('A')\n \n",
  "sympy__sympy-14976": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..5bed37e 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1,3 +1,4 @@\n+\n from distutils.version import LooseVersion as V\n from itertools import product\n import math\n@@ -134,6 +135,11 @@ def test_math_lambda():\n \n \n @conserve_mpmath_dps\n+def test_mpmath_lambdify_with_rational():\n+    x = symbols('x')\n+    eqn = Eq(x, Rational(232, 3))\n+    f = lambdify(x, eqn.rhs, modules='mpmath')\n+    assert f() == mpmath.mpf(232) / mpmath.mpf(3)\n def test_mpmath_lambda():\n     mpmath.mp.dps = 50\n     sin02 = mpmath.mpf(\"0.19866933079506121545941262711838975037020672954020\")\n@@ -145,6 +151,11 @@ def test_mpmath_lambda():\n \n \n @conserve_mpmath_dps\n+def test_mpmath_lambdify_with_rational():\n+    x = symbols('x')\n+    eqn = Eq(x, Rational(232, 3))\n+    f = lambdify(x, eqn.rhs, modules='mpmath')\n+    assert f() == mpmath.mpf(232) / mpmath.mpf(3)\n def test_number_precision():\n     mpmath.mp.dps = 50\n     sin02 = mpmath.mpf(\"0.19866933079506121545941262711838975037020672954020\")\n",
  "sympy__sympy-15017": "diff --git a/sympy/tensor/array/tests/test_immutable_ndim_array.py b/sympy/tensor/array/tests/test_immutable_ndim_array.py\nindex 18941a7..bae5cf1 100644\n--- a/sympy/tensor/array/tests/test_immutable_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_immutable_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from copy import copy\n \n from sympy.tensor.array.dense_ndim_array import ImmutableDenseNDimArray\n@@ -73,6 +74,12 @@ def test_ndim_array_initiation():\n \n     from sympy.abc import x\n     rank_zero_array = ImmutableDenseNDimArray(x)\n+    # Test case for verifying len() of rank-0 arrays\n+    # Rank-0 array should have a length of 1 since it contains one scalar element\n+    assert len(rank_zero_array) == 1\n+    assert len(list(rank_zero_array)) == 1\n+    numpy_rank_zero = numpy.asarray(1)\n+    assert numpy_rank_zero.size == len(rank_zero_array)\n     assert len(rank_zero_array) == 0\n     assert rank_zero_array.shape == ()\n     assert rank_zero_array.rank() == 0\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..7eaf694 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n",
  "sympy__sympy-15349": "diff --git a/sympy/algebras/tests/test_quaternion.py b/sympy/algebras/tests/test_quaternion.py\nindex c486cc1..dc6084b 100644\n--- a/sympy/algebras/tests/test_quaternion.py\n+++ b/sympy/algebras/tests/test_quaternion.py\n@@ -111,12 +111,76 @@ def test_quaternion_conversions():\n                                                [cos(theta), -sin(theta), 0],\n                                                [sin(theta),  cos(theta), 0],\n                                                [0,           0,          1]])\n+from sympy import symbols, cos, sin, trigsimp, pi\n+from sympy.algebras.quaternion import Quaternion\n \n+def test_quaternion_rotation_iss1593():\n+    \"\"\"\n+    There was a sign mistake in the definition,\n+    of the rotation matrix. This tests that particular sign mistake.\n+    See issue 1593 for reference.\n+    See wikipedia\n+    https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix\n+    for the correct definition\n+    \"\"\"\n+    x = symbols('x')\n+    q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+    assert(trigsimp(q.to_rotation_matrix()) == Matrix([\n+                [1,      0,      0],\n+                [0, cos(x), -sin(x)],\n+                [0, sin(x), cos(x)]]))\n+\n+def test_quaternion_to_rotation_matrix_zero_rotation():\n+    x = symbols('x')\n+    q = Quaternion(1, 0, 0, 0)\n+    assert(q.to_rotation_matrix() == Matrix([\n+                [1, 0, 0],\n+                [0, 1, 0],\n+                [0, 0, 1]]))\n+\n+def test_quaternion_to_rotation_matrix_90_deg():\n+    q = Quaternion(cos(pi/4), sin(pi/4), 0, 0)\n+    assert(trigsimp(q.to_rotation_matrix()) == Matrix([\n+                [1, 0, 0],\n+                [0, 0, -1],\n+                [0, 1, 0]]))\n     assert q2.to_axis_angle() == ((0, 0, sin(theta/2)/Abs(sin(theta/2))),\n                                    2*acos(cos(theta/2)))\n+from sympy import symbols, cos, sin, trigsimp, pi\n+from sympy.algebras.quaternion import Quaternion\n \n+def test_quaternion_rotation_iss1593():\n+    \"\"\"\n+    There was a sign mistake in the definition,\n+    of the rotation matrix. This tests that particular sign mistake.\n+    See issue 1593 for reference.\n+    See wikipedia\n+    https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix\n+    for the correct definition\n+    \"\"\"\n+    x = symbols('x')\n+    q = Quaternion(cos(x/2), sin(x/2), 0, 0)\n+    assert(trigsimp(q.to_rotation_matrix()) == Matrix([\n+                [1,      0,      0],\n+                [0, cos(x), -sin(x)],\n+                [0, sin(x), cos(x)]]))\n+\n+def test_quaternion_to_rotation_matrix_zero_rotation():\n+    x = symbols('x')\n+    q = Quaternion(1, 0, 0, 0)\n+    assert(q.to_rotation_matrix() == Matrix([\n+                [1, 0, 0],\n+                [0, 1, 0],\n+                [0, 0, 1]]))\n+\n+def test_quaternion_to_rotation_matrix_90_deg():\n+    q = Quaternion(cos(pi/4), sin(pi/4), 0, 0)\n+    assert(trigsimp(q.to_rotation_matrix()) == Matrix([\n+                [1, 0, 0],\n+                [0, 0, -1],\n+                [0, 1, 0]]))\n     assert trigsimp(q2.to_rotation_matrix((1, 1, 1))) == Matrix([\n                [cos(theta), -sin(theta), 0, sin(theta) - cos(theta) + 1],\n                [sin(theta),  cos(theta), 0, -sin(theta) - cos(theta) + 1],\n                [0,           0,          1,  0],\n-               [0,           0,          0,  1]])\n+               [0,           0,          0,  1]])\n",
  "sympy__sympy-15599": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex d8e8fc4..ffc08ee 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1625,6 +1625,26 @@ def test_Mod():\n     assert (3*i*x) % (2*i*y) == i*Mod(3*x, 2*y)\n     assert Mod(4*i, 4) == 0\n \n+    # Additional test cases to verify fix for issue #15493\n+    i, j = symbols('i j', integer=True, positive=True)\n+    assert Mod(9*i, 3) == 0   # Multiple of the modulus\n+    assert Mod(9*i + 1, 3) == 1  # Non-multiple\n+    assert Mod(3*i + 2, 2) == Mod(i, 2)  # Similar structure to issue example\n+    assert Mod(5*j**2 + 5*j, 5) == 0  # Should reduce due to factorization\n+\n+    # Test with nested mods\n+    assert Mod(Mod(3*i + 5*j, 2), 2) == Mod(i + 1, 2)\n+    assert Mod(2*Mod(3*i + 7, 3), 2) == Mod(i + 1, 2)\n+\n+    # Test with combination of symbols and constants\n+    x = Symbol('x', integer=True)\n+    assert Mod(3*x + 2, 3) == 2\n+    assert Mod(3*x + 4, 3) == 1  # Reduce modulo 3\n+\n+    # Edge case with zero\n+    assert Mod(0, 2) == 0\n+    assert Mod(3*0, 2) == 0\n+\n     # issue 8677\n     n = Symbol('n', integer=True, positive=True)\n     assert factorial(n) % n == 0\n",
  "sympy__sympy-15809": "diff --git a/sympy/functions/elementary/tests/test_miscellaneous.py b/sympy/functions/elementary/tests/test_miscellaneous.py\nindex 821fd0c..585e4e7 100644\n--- a/sympy/functions/elementary/tests/test_miscellaneous.py\n+++ b/sympy/functions/elementary/tests/test_miscellaneous.py\n@@ -76,6 +76,13 @@ def test_Min():\n     assert Min(oo, nn) == nn\n     assert Min(p, p) == p\n     assert Min(p, oo) == p\n+\n+    # Test for zero-argument Min and Max\n+    assert Min() == S.Infinity, \"Min() should return S.Infinity (oo)\"\n+    assert Min(x) == x, \"Min(x) should return x\"\n+    \n+    assert Max() == S.NegativeInfinity, \"Max() should return S.NegativeInfinity (-oo)\"\n+    assert Max(x) == x, \"Max(x) should return x\"\n     assert Min(oo, p) == p\n     assert Min(oo, oo) == oo\n \n",
  "sympy__sympy-15875": "diff --git a/sympy/core/tests/test_arit.py b/sympy/core/tests/test_arit.py\nindex 58ab306..d3a9309 100644\n--- a/sympy/core/tests/test_arit.py\n+++ b/sympy/core/tests/test_arit.py\n@@ -1987,10 +1987,31 @@ def test_Add_is_zero():\n     assert (x + y).is_zero\n \n \n-def test_issue_14392():\n+def test_issue_15873():\n+    from sympy import I, simplify\n+\n+    # This is the issue example\n+    e = -2*I + (1 + I)**2\n+    assert e.is_zero is None\n+    assert simplify(e).is_zero is True\n+\n+    # Additional complex test cases\n+    e2 = I*(1 + I) - I - 1\n+    assert e2.is_zero is None\n+    assert simplify(e2).is_zero is True\n+\n+    e3 = (1 + 2*I) - 1 - 2*I\n+    assert e3.is_zero is True  # Directly zero\n+\n+    e4 = (2*I + 2) - 2*I - 2\n+    assert e4.is_zero is True  # Directly zero\n+\n+    e5 = (1 + I)**2 - (1 + 2*I)\n+    assert e5.is_zero is None\n+    assert simplify(e5).is_zero is True\n     assert (sin(zoo)**2).as_real_imag() == (nan, nan)\n \n def test_divmod():\n     assert divmod(x, y) == (x//y, x % y)\n     assert divmod(x, 3) == (x//3, x % 3)\n-    assert divmod(3, x) == (3//x, 3 % x)\n+    assert divmod(3, x) == (3//x, 3 % x)\n",
  "sympy__sympy-16450": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex aba4711..e208f6d 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -478,6 +478,39 @@ def test_logcombine_complex_coeff():\n         i + log(x**2)\n \n \n+from sympy import Symbol, posify\n+\n+def test_posify_preserves_finite():\n+    # issue 16438: posify should preserve finite assumption\n+    x = Symbol('x', finite=True)\n+    xp, _ = posify(x)\n+    assert xp.is_finite is True\n+\n+def test_posify_preserves_integer():\n+    x = Symbol('x', integer=True)\n+    xp, _ = posify(x)\n+    assert xp.is_integer is True\n+\n+def test_posify_preserves_rational():\n+    x = Symbol('x', rational=True)\n+    xp, _ = posify(x)\n+    assert xp.is_rational is True\n+\n+def test_posify_preserves_prime():\n+    x = Symbol('x', prime=True)\n+    xp, _ = posify(x)\n+    assert xp.is_prime is True\n+\n+def test_posify_preserves_even():\n+    x = Symbol('x', even=True)\n+    xp, _ = posify(x)\n+    assert xp.is_even is True\n+\n+def test_posify_preserves_odd():\n+    x = Symbol('x', odd=True)\n+    xp, _ = posify(x)\n+    assert xp.is_odd is True\n+\n def test_issue_5950():\n     x, y = symbols(\"x,y\", positive=True)\n     assert logcombine(log(3) - log(2)) == log(Rational(3,2), evaluate=False)\n",
  "sympy__sympy-16766": "diff --git a/sympy/printing/tests/test_pycode.py b/sympy/printing/tests/test_pycode.py\nindex 51a287f..cba7079 100644\n--- a/sympy/printing/tests/test_pycode.py\n+++ b/sympy/printing/tests/test_pycode.py\n@@ -1,3 +1,4 @@\n+\n # -*- coding: utf-8 -*-\n from __future__ import absolute_import\n \n@@ -12,6 +13,7 @@ from sympy.printing.pycode import (\n     MpmathPrinter, NumPyPrinter, PythonCodePrinter, pycode, SciPyPrinter\n )\n from sympy.utilities.pytest import raises\n+from sympy.tensor import IndexedBase\n \n x, y, z = symbols('x y z')\n \n@@ -35,6 +37,13 @@ def test_PythonCodePrinter():\n                                                         ' (3) if (x > 0) else None)'\n     assert prntr.doprint(sign(x)) == '(0.0 if x == 0 else math.copysign(1, x))'\n \n+    # Test for Indexed support\n+    p = IndexedBase(\"p\")\n+    assert prntr.doprint(p[0]) == 'p[0]'\n+    assert prntr.doprint(p[0, 1]) == 'p[0, 1]'\n+    assert prntr.doprint(p[x]) == 'p[x]'\n+    assert prntr.doprint(p[x, y]) == 'p[x, y]'\n+\n \n def test_MpmathPrinter():\n     p = MpmathPrinter()\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_autowrap.py b/sympy/utilities/tests/test_autowrap.py\nindex 23fddca..5e28b86 100644\n--- a/sympy/utilities/tests/test_autowrap.py\n+++ b/sympy/utilities/tests/test_autowrap.py\n@@ -47,6 +47,17 @@ def test_cython_wrapper_scalar_function():\n         \"    return test(x, y, z)\")\n     assert source == expected\n \n+def test_cython_backend_with_unused_array_argument():\n+    from sympy.utilities.autowrap import autowrap\n+    from sympy import MatrixSymbol\n+    import numpy as np\n+    \n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    \n+    assert f(np.array([[1.0], [2.0]])) == 1.0\n+\n \n def test_cython_wrapper_outarg():\n     from sympy import Equality\n@@ -66,6 +77,17 @@ def test_cython_wrapper_outarg():\n         \"    return z\")\n     assert source == expected\n \n+def test_cython_backend_with_unused_array_argument():\n+    from sympy.utilities.autowrap import autowrap\n+    from sympy import MatrixSymbol\n+    import numpy as np\n+    \n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    \n+    assert f(np.array([[1.0], [2.0]])) == 1.0\n+\n \n def test_cython_wrapper_inoutarg():\n     from sympy import Equality\n",
  "sympy__sympy-16886": "diff --git a/sympy/crypto/tests/test_crypto.py b/sympy/crypto/tests/test_crypto.py\nindex 8b39574..63c91eb 100644\n--- a/sympy/crypto/tests/test_crypto.py\n+++ b/sympy/crypto/tests/test_crypto.py\n@@ -248,8 +248,17 @@ def test_encode_morse():\n     assert encode_morse(' ', sep='``') == '````'\n     assert encode_morse('!@#$%^&*()_+') == '-.-.--|.--.-.|...-..-|-.--.|-.--.-|..--.-|.-.-.'\n \n+    # Original test cases for verifying numbers 1 to 9\n+    assert encode_morse('12345') == '.----|..---|...--|....-|.....'\n+    assert encode_morse('67890') == '-....|--...|---..|----.|-----'\n \n-def test_decode_morse():\n+    # New test cases to explicitly check the encoding of '1'\n+    assert encode_morse('1') == '.----'\n+    assert encode_morse('11') == '.----|.----'\n+    assert encode_morse('111') == '.----|.----|.----'\n+\n+    # Test case for a mix of numbers including '1'\n+    assert encode_morse('109') == '.----|-----|----.'\n     assert decode_morse('-.-|.|-.--') == 'KEY'\n     assert decode_morse('.-.|..-|-.||') == 'RUN'\n     raises(KeyError, lambda: decode_morse('.....----'))\n",
  "sympy__sympy-17139": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex daf5f69..e5eeb60 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -814,4 +814,17 @@ def test_issue_15965():\n def test_issue_7971():\n     z = Integral(x, (x, 1, 1))\n     assert z != 0\n-    assert simplify(z) is S.Zero\n+\n+def test_issue_17137():\n+    # Test cases to ensure that invalid comparison errors do not arise\n+    assert simplify(cos(x)**I) == cos(x)**I\n+    assert simplify(cos(x)**(2 + 3*I)) == cos(x)**(2 + 3*I)\n+    assert simplify(sin(x)**I) == sin(x)**I\n+    assert simplify(exp(x)**I) == exp(x)**I\n+    # Additional tests for combinations of real and imaginary exponents\n+    assert simplify(cos(x)**(-I)) == cos(x)**(-I)\n+    assert simplify(cos(x)**(1 + I)) == cos(x)**(1 + I)\n+    assert simplify(cos(x)**(I**2)) == cos(x)**(I**2)\n+    assert simplify(tan(x)**(1 + 2*I)) == tan(x)**(1 + 2*I)\n+    assert simplify(exp(x)**(I + 3)) == exp(x)**(I + 3)\n+    assert simplify(z) is S.Zero\n",
  "sympy__sympy-17318": "diff --git a/sympy/simplify/tests/test_sqrtdenest.py b/sympy/simplify/tests/test_sqrtdenest.py\nindex 7a6c0e1..d3aa115 100644\n--- a/sympy/simplify/tests/test_sqrtdenest.py\n+++ b/sympy/simplify/tests/test_sqrtdenest.py\n@@ -1,4 +1,7 @@\n-from sympy import sqrt, root, S, Symbol, sqrtdenest, Integral, cos\n+\n+from sympy import sqrt, root, S, Symbol, sqrtdenest, Integral, cos, I\n+from sympy.simplify.sqrtdenest import _sqrt_match\n+from sympy.core.expr import unchanged\n from sympy.simplify.sqrtdenest import _subsets as subsets\n from sympy.utilities.pytest import slow\n \n@@ -176,7 +179,13 @@ def test_subsets():\n         [1, 1, 0, 1], [0, 0, 1, 1], [1, 0, 1, 1], [0, 1, 1, 1], [1, 1, 1, 1]]\n \n \n-def test_issue_5653():\n+def test_issue_12420():\n+    I = S.ImaginaryUnit\n+    assert _sqrt_match(4 + I) == []\n+    expression = (3 - sqrt(2)*sqrt(4 + 3*I) + 3*I) / 2\n+    assert sqrtdenest(expression) == expression\n+    e = 3 - sqrt(2)*sqrt(4 + I) + 3*I\n+    assert sqrtdenest(e) == e\n     assert sqrtdenest(\n         sqrt(2 + sqrt(2 + sqrt(2)))) == sqrt(2 + sqrt(2 + sqrt(2)))\n \n",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..3a95aa5 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy import I, Rational, Symbol, pi, sqrt, S\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n@@ -92,6 +93,11 @@ def test_point():\n \n     assert p4 * 5 == Point(5, 5)\n     assert p4 / 5 == Point(0.2, 0.2)\n+    \n+    # Test multiplication by number in both orders\n+    assert 5 * p4 == Point(5, 5)\n+    assert sympy.sympify(2.0) * p4 == Point(2, 2)\n+    assert p4 * sympy.sympify(2.0) == Point(2, 2)\n \n     raises(ValueError, lambda: Point(0, 0) + 10)\n \n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..120d846 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -553,8 +553,23 @@ def test_diophantine():\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n     assert diophantine((y**2-x), t) == set([(t**2, -t)])\n \n-\n-def test_general_pythagorean():\n+def test_issue_18186():\n+    from sympy import diophantine, symbols\n+    \n+    x, y = symbols('x y', integer=True)\n+    eq = y**4 + x**4 - 2**4 - 3**4\n+    \n+    # Original test cases\n+    assert diophantine(eq, syms=(x, y), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    assert diophantine(eq, syms=(y, x), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    \n+    # New test cases with swapped symbols order\n+    assert diophantine(eq, syms=(y, x), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    assert diophantine(eq, syms=(x, y), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n     from sympy.abc import a, b, c, d, e\n \n     assert check_solutions(a**2 + b**2 + c**2 - d**2)\n",
  "sympy__sympy-18763": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex ba93bdc..ec09118 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -671,6 +671,19 @@ def test_latex_derivatives():\n     assert latex(diff(f(x), (x, Max(n1, n2)))) == \\\n         r'\\frac{d^{\\max\\left(n_{1}, n_{2}\\right)}}{d x^{\\max\\left(n_{1}, n_{2}\\right)}} f{\\left(x \\right)}'\n \n+    # Test for the parenthesizing issue with Subs\n+    from sympy import Subs\n+    from sympy.abc import x, y\n+\n+    # Existing test case to verify fix\n+    assert latex(3*Subs(-x+y, (x,), (1,))) == r'3 \\\\left. \\\\left(- x + y\\\\right) \\\\right|_{\\\\substack{ x=1 }}'\n+\n+    # Additional test cases\n+    assert latex(Subs(x + y, (x,), (1,))) == r'\\left. \\left(x + y\\right) \\right|_{\\substack{ x=1 }}'\n+    assert latex(Subs(x + y, (x, y), (1, 2))) == r'\\left. \\left(x + y\\right) \\right|_{\\substack{ x=1\\\\ y=2 }}'\n+    assert latex(2*Subs(x*y + y, (x,), (1,))) == r'2 \\\\left. \\\\left(x y + y\\\\right) \\\\right|_{\\\\substack{ x=1 }}'\n+    assert latex(Subs(x*y + y, (x,), (-1,))) == r'\\left. \\left(x y + y\\right) \\right|_{\\substack{ x=-1 }}'\n+\n \n def test_latex_subs():\n     assert latex(Subs(x*y, (\n",
  "sympy__sympy-19346": "",
  "sympy__sympy-19495": "",
  "sympy__sympy-19637": "diff --git a/sympy/core/tests/test_sympify.py b/sympy/core/tests/test_sympify.py\nindex 4d20fb4..c89fedd 100644\n--- a/sympy/core/tests/test_sympify.py\n+++ b/sympy/core/tests/test_sympify.py\n@@ -513,8 +513,14 @@ def test_kernS():\n     one = kernS('x - (x - 1)')\n     assert one != 1 and one.expand() == 1\n \n-\n-def test_issue_6540_6552():\n+from sympy.abc import x\n+from sympy.core.sympify import kernS\n+\n+def test_issue_with_kernS():\n+    # Test with the input that was causing the issue\n+    text = \"(2*x)/(x-1)\"\n+    expected_result = 2*x/(x-1)\n+    assert kernS(text) == expected_result, \"kernS should correctly process simple arithmetic expressions.\"\n     assert S('[[1/3,2], (2/5,)]') == [[Rational(1, 3), 2], (Rational(2, 5),)]\n     assert S('[[2/6,2], (2/4,)]') == [[Rational(1, 3), 2], (S.Half,)]\n     assert S('[[[2*(1)]]]') == [[[2]]]\n",
  "sympy__sympy-19783": "diff --git a/sympy/physics/quantum/tests/test_dagger.py b/sympy/physics/quantum/tests/test_dagger.py\nindex ad97a01..c498ac4 100644\n--- a/sympy/physics/quantum/tests/test_dagger.py\n+++ b/sympy/physics/quantum/tests/test_dagger.py\n@@ -1,7 +1,9 @@\n+\n from sympy import I, Matrix, symbols, conjugate, Expr, Integer\n \n from sympy.physics.quantum.dagger import adjoint, Dagger\n from sympy.external import import_module\n+from sympy.physics.quantum.operator import Operator, IdentityOperator\n from sympy.testing.pytest import skip\n \n \n@@ -23,6 +25,17 @@ def test_scalars():\n     assert Dagger(A).is_commutative is False\n \n \n+def test_dagger_identity_simplification():\n+    O = Operator('O')\n+    I = IdentityOperator()\n+\n+    # Test multiplication with identity on the right\n+    assert Dagger(O) * I == Dagger(O)\n+\n+    # Test multiplication with identity on the left\n+    assert I * Dagger(O) == Dagger(O)\n+\n+\n def test_matrix():\n     x = symbols('x')\n     m = Matrix([[I, x*I], [2, 4]])\n",
  "sympy__sympy-19954": "diff --git a/sympy/combinatorics/tests/test_perm_groups.py b/sympy/combinatorics/tests/test_perm_groups.py\nindex 3f4bb48..cbe3396 100644\n--- a/sympy/combinatorics/tests/test_perm_groups.py\n+++ b/sympy/combinatorics/tests/test_perm_groups.py\n@@ -856,6 +856,15 @@ def test_generator_product():\n \n def test_sylow_subgroup():\n     P = PermutationGroup(Permutation(1, 5)(2, 4), Permutation(0, 1, 2, 3, 4, 5))\n+\n+    # Additional test cases to verify fix for sylow_subgroup IndexError\n+    G = DihedralGroup(18)\n+    S = G.sylow_subgroup(p=2)\n+    assert S.order() == 4\n+\n+    G = DihedralGroup(50)\n+    S = G.sylow_subgroup(p=2)\n+    assert S.order() == 4\n     S = P.sylow_subgroup(2)\n     assert S.order() == 4\n \n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..c392f2a 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -514,7 +514,27 @@ def test_partitions():\n         assert i == RGS_enum(n)\n \n \n-def test_binary_partitions():\n+def test_partitions_no_reuse():\n+    # Check that the partitions returned are unique objects\n+    for n in range(1, 10):\n+        generated_partitions = [p for p in partitions(n)]\n+        for p1, p2 in zip(generated_partitions, generated_partitions):\n+            if p1 is not p2:\n+                assert p1 != p2  # Assert they are not the same object\n+\n+    # Specific check for deep copy issues\n+    partitions_list_4 = list(partitions(4))\n+    partitions_list_4[0][4] = 99  # Modify the first partition\n+    assert partitions_list_4[1] != {4: 99}  # Ensure modification does not affect other partitions\n+\n+    # Testing with additional parameters\n+    partitions_list_with_k = list(partitions(6, k=2))\n+    assert all(isinstance(p, dict) for p in partitions_list_with_k)\n+    assert len(partitions_list_with_k) == len(set(id(p) for p in partitions_list_with_k))  # All partitions are unique\n+\n+    partitions_list_with_m = list(partitions(6, m=3))\n+    assert all(isinstance(p, dict) for p in partitions_list_with_m)\n+    assert len(partitions_list_with_m) == len(set(id(p) for p in partitions_list_with_m))  # All partitions are unique\n     assert [i[:] for i in binary_partitions(10)] == [[8, 2], [8, 1, 1],\n         [4, 4, 2], [4, 4, 1, 1], [4, 2, 2, 2], [4, 2, 2, 1, 1],\n         [4, 2, 1, 1, 1, 1], [4, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2],\n",
  "sympy__sympy-20801": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\nindex 8e1c7e2..8d56eab 100644\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -571,25 +571,110 @@ def test_Float():\n     raises(ValueError, lambda: Float(\"1.23\", dps=\"\", precision=10))\n     raises(ValueError, lambda: Float(\"1.23\", dps=3, precision=\"\"))\n     raises(ValueError, lambda: Float(\"1.23\", dps=\"\", precision=\"\"))\n-\n+from sympy import S\n+\n+def test_zero_not_false_extended():\n+    # Test related to the issue where S(0.0) == S.false returns True\n+    # These tests ensure that zero (both float and integer) is not considered equal to False\n+    # Verify that S(0.0) == S.false is False\n+    assert (S(0.0) == S.false) is False\n+    # Verify that S.false == S(0.0) is False\n+    assert (S.false == S(0.0)) is False\n+    # Verify that S(0) == S.false is False\n+    assert (S(0) == S.false) is False\n+    # Verify that S.false == S(0) is False\n+    assert (S.false == S(0)) is False\n+    # Additional test to check that reversing the order does not yield different results\n+    assert (S.false != S(0.0)) is True\n+    assert (S(0.0) != S.false) is True\n+    assert (S.false != S(0)) is True\n+    assert (S(0) != S.false) is True\n     # from NumberSymbol\n     assert same_and_same_prec(Float(pi, 32), pi.evalf(32))\n     assert same_and_same_prec(Float(Catalan), Catalan.evalf())\n-\n+from sympy import S\n+\n+def test_zero_not_false_extended():\n+    # Test related to the issue where S(0.0) == S.false returns True\n+    # These tests ensure that zero (both float and integer) is not considered equal to False\n+    # Verify that S(0.0) == S.false is False\n+    assert (S(0.0) == S.false) is False\n+    # Verify that S.false == S(0.0) is False\n+    assert (S.false == S(0.0)) is False\n+    # Verify that S(0) == S.false is False\n+    assert (S(0) == S.false) is False\n+    # Verify that S.false == S(0) is False\n+    assert (S.false == S(0)) is False\n+    # Additional test to check that reversing the order does not yield different results\n+    assert (S.false != S(0.0)) is True\n+    assert (S(0.0) != S.false) is True\n+    assert (S.false != S(0)) is True\n+    assert (S(0) != S.false) is True\n     # oo and nan\n     u = ['inf', '-inf', 'nan', 'iNF', '+inf']\n     v = [oo, -oo, nan, oo, oo]\n     for i, a in zip(u, v):\n         assert Float(i) is a\n-\n-\n-\n+from sympy import S\n+\n+def test_zero_not_false_extended():\n+    # Test related to the issue where S(0.0) == S.false returns True\n+    # These tests ensure that zero (both float and integer) is not considered equal to False\n+    # Verify that S(0.0) == S.false is False\n+    assert (S(0.0) == S.false) is False\n+    # Verify that S.false == S(0.0) is False\n+    assert (S.false == S(0.0)) is False\n+    # Verify that S(0) == S.false is False\n+    assert (S(0) == S.false) is False\n+    # Verify that S.false == S(0) is False\n+    assert (S.false == S(0)) is False\n+    # Additional test to check that reversing the order does not yield different results\n+    assert (S.false != S(0.0)) is True\n+    assert (S(0.0) != S.false) is True\n+    assert (S.false != S(0)) is True\n+    assert (S(0) != S.false) is True\n+\n+from sympy import S\n+\n+def test_zero_not_false_extended():\n+    # Test related to the issue where S(0.0) == S.false returns True\n+    # These tests ensure that zero (both float and integer) is not considered equal to False\n+    # Verify that S(0.0) == S.false is False\n+    assert (S(0.0) == S.false) is False\n+    # Verify that S.false == S(0.0) is False\n+    assert (S.false == S(0.0)) is False\n+    # Verify that S(0) == S.false is False\n+    assert (S(0) == S.false) is False\n+    # Verify that S.false == S(0) is False\n+    assert (S.false == S(0)) is False\n+    # Additional test to check that reversing the order does not yield different results\n+    assert (S.false != S(0.0)) is True\n+    assert (S(0.0) != S.false) is True\n+    assert (S.false != S(0)) is True\n+    assert (S(0) != S.false) is True\n @conserve_mpmath_dps\n def test_float_mpf():\n     import mpmath\n     mpmath.mp.dps = 100\n     mp_pi = mpmath.pi()\n-\n+from sympy import S\n+\n+def test_zero_not_false_extended():\n+    # Test related to the issue where S(0.0) == S.false returns True\n+    # These tests ensure that zero (both float and integer) is not considered equal to False\n+    # Verify that S(0.0) == S.false is False\n+    assert (S(0.0) == S.false) is False\n+    # Verify that S.false == S(0.0) is False\n+    assert (S.false == S(0.0)) is False\n+    # Verify that S(0) == S.false is False\n+    assert (S(0) == S.false) is False\n+    # Verify that S.false == S(0) is False\n+    assert (S.false == S(0)) is False\n+    # Additional test to check that reversing the order does not yield different results\n+    assert (S.false != S(0.0)) is True\n+    assert (S(0.0) != S.false) is True\n+    assert (S.false != S(0)) is True\n+    assert (S(0) != S.false) is True\n     assert Float(mp_pi, 100) == Float(mp_pi._mpf_, 100) == pi.evalf(100)\n \n     mpmath.mp.dps = 15\n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..6e8bf4b 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -7,6 +8,38 @@ from sympy import (\n from sympy.core.basic import _aresame\n from sympy.testing.pytest import XFAIL\n from sympy.abc import a, x, y, z, t\n+from sympy import sinh, exp, Piecewise, Mod\n+\n+def test_issue_21373_subs_PolynomialError():\n+    # Test case for the reported issue where PolynomialError arises unexpectedly\n+    x_real, y_real = symbols('x_real y_real', real=True)\n+    \n+    # Expression known to cause PolynomialError in the reported issue\n+    expr = exp(sinh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z))\n+    \n+    # Substitution that should not raise PolynomialError\n+    assert expr.subs({1: 1.0}) == exp(sinh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z))\n+    \n+    # Similar test to ensure consistency across function applications\n+    assert sinh(Piecewise((x_real, y_real > x_real), (y_real, True)) * z ** -1.0).is_zero == False\n+\n+    # Testing with `cosh` and `tanh` to ensure no errors are raised\n+    expr_cosh = exp(cosh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z))\n+    assert expr_cosh.subs({1: 1.0}) == exp(cosh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z))\n+\n+    expr_tanh = exp(tanh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z))\n+    assert expr_tanh.subs({1: 1.0}) == exp(tanh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z))\n+\n+    # Additional edge cases for coverage\n+    expr_no_division = exp(sinh(Piecewise((x_real, y_real > x_real), (y_real, True))))\n+    assert expr_no_division.subs({1: 1.0}) == expr_no_division\n+\n+    expr_no_exp = sinh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z)\n+    assert expr_no_exp.subs({1: 1.0}) == sinh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z)\n+\n+    # Mixed expressions with real and non-real symbols\n+    expr_mixed = exp(sinh(Piecewise((x_real, y > x_real), (y_real, True)) / z))\n+    assert expr_mixed.subs({1: 1.0}) == exp(sinh(Piecewise((x_real, y > x_real), (y_real, True)) / z))\n \n def test_subs():\n     n3 = Rational(3)\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..c951422 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -162,7 +162,42 @@ def test_monomials():\n                     x*j**2, x*k**2, x*j*k, x**2*j**2*k**2, x*j*k**2, x**2, x**2*j*k**2\n             }\n \n-def test_monomial_count():\n+def test_itermonomials_min_degrees():\n+    from sympy import symbols\n+    from sympy.polys.monomials import itermonomials\n+    \n+    x1, x2, x3 = symbols('x1 x2 x3')\n+    states = [x1, x2, x3]\n+    \n+    # Test case for the reported issue\n+    max_degrees = 3\n+    min_degrees = 3\n+    monomials = set(itermonomials(states, max_degrees, min_degrees=min_degrees))\n+    expected_monomials = {x1**3, x1**2*x2, x1*x2**2, x2**3, x1**2*x3, x1*x3**2, x3**3, x2**2*x3, x2*x3**2, x1*x2*x3}\n+    assert monomials == expected_monomials\n+\n+    # Additional test cases\n+    x, y = symbols('x y')\n+\n+    # Test for two variables with min_degrees = 2\n+    assert set(itermonomials([x, y], 3, 2)) == {x**2, x*y, y**2, x**3, x**2*y, x*y**2, y**3}\n+\n+    # Test with min_degrees = 1, should return x, y, x*y, x**2, y**2, x**2*y, x*y**2, x**3, y**3\n+    assert set(itermonomials([x, y], 3, 1)) == {x, y, x*y, x**2, y**2, x**2*y, x*y**2, x**3, y**3}\n+\n+    # Test with max_degrees = 2 and min_degrees = 2, should return all combinations with degree 2\n+    assert set(itermonomials([x, y], 2, 2)) == {x**2, y**2, x*y}\n+\n+    # Test with max_degrees = 4 and min_degrees = 3\n+    assert set(itermonomials([x, y], 4, 3)) == {x**3, y**3, x**2*y, x*y**2, x**4, y**4, x**3*y, x**2*y**2, x*y**3}\n+\n+    # Commutative symbols with 3 variables\n+    i, j, k = symbols('i j k', commutative=False)\n+    assert set(itermonomials([i, j, k], 3, 2)) == \\\n+        {j*k**2, i*k**2, k*i*j, k*i**2, k**2, j*k*j, k*j**2, i*k*i, i*j,\n+         j**2*k, i**2*j, j*i*k, j**3, i**3, k*j*i, j*k*i, j*i, k**2*j, j*i**2,\n+         k*j, k*j*k, i*j*i, j*i*j, i*j**2, j**2, k*i*k, i**2, j*k, i*k, i*k*j,\n+         k**3, i**2*k, j**2*i, k**2*i, i*j*k, k*i}\n     assert monomial_count(2, 2) == 6\n     assert monomial_count(2, 3) == 10\n \n",
  "sympy__sympy-22456": "diff --git a/sympy/codegen/tests/test_ast.py b/sympy/codegen/tests/test_ast.py\nindex 6c38ed6..94c26e0 100644\n--- a/sympy/codegen/tests/test_ast.py\n+++ b/sympy/codegen/tests/test_ast.py\n@@ -261,7 +261,14 @@ def test_none():\n     assert none.func(*none.args) == none\n \n \n+from sympy.codegen.ast import String\n+\n def test_String():\n+    # Test Argument Invariance of String\n+    st = String('hello world')\n+    assert st.func(*st.args) == st  # This should now hold as per the fix\n+\n+    # Further tests on String\n     st = String('foobar')\n     assert st.is_Atom\n     assert st == String('foobar')\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..db3eeff 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n@@ -8,7 +9,7 @@ from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate, GeometryEntity\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n-from sympy.utilities.misc import Undecidable\n+from sympy.core.parameters import evaluate\n from sympy.testing.pytest import raises, warns\n \n \n@@ -440,7 +441,33 @@ def test_unit():\n     assert Point(1, 1).unit == Point(sqrt(2)/2, sqrt(2)/2)\n \n \n-def test_dot():\n+def test_issue_22684():\n+    # Used to give an error\n+    with evaluate(False):\n+        assert Point(1, 2) == Point2D(1, 2)\n+\n+    # Test with imaginary coordinate to ensure ValueError is raised\n+    with raises(ValueError, match='Imaginary coordinates are not permitted.'):\n+        with evaluate(False):\n+            Point(1, 2*I)\n+\n+    # Test without evaluate to ensure it works normally\n+    assert Point(1, 2) == Point2D(1, 2)\n+\n+    # Additional tests to ensure other cases are unaffected\n+    # Test without evaluate False keyword\n+    assert Point(1, 2) == Point2D(1, 2)\n+    assert Point(1, 2, 3) == Point3D(1, 2, 3)\n+\n+    # Test with evaluate keyword set to False\n+    assert Point(1.0, 2.0, evaluate=False) == Point2D(1.0, 2.0)\n+\n+    # Ensure that non-number coordinates raise TypeError\n+    with raises(TypeError):\n+        Point(Symbol('x'), 2)\n+\n+    # Check handling of zero-dimensional points with dim keyword\n+    assert Point(dim=3) == Point3D(0, 0, 0)\n     raises(TypeError, lambda: Point(1, 2).dot(Line((0, 0), (1, 1))))\n \n \n",
  "sympy__sympy-22914": "diff --git a/sympy/printing/tests/test_pycode.py b/sympy/printing/tests/test_pycode.py\nindex ab6551d..a50b87a 100644\n--- a/sympy/printing/tests/test_pycode.py\n+++ b/sympy/printing/tests/test_pycode.py\n@@ -1,3 +1,4 @@\n+\n from sympy.codegen import Assignment\n from sympy.codegen.ast import none\n from sympy.codegen.cfunctions import expm1, log1p\n@@ -6,7 +7,7 @@ from sympy.codegen.matrix_nodes import MatrixSolve\n from sympy.core import Expr, Mod, symbols, Eq, Le, Gt, zoo, oo, Rational, Pow\n from sympy.core.numbers import pi\n from sympy.core.singleton import S\n-from sympy.functions import acos, KroneckerDelta, Piecewise, sign, sqrt\n+from sympy.functions import acos, KroneckerDelta, Piecewise, sign, sqrt, Min, Max\n from sympy.logic import And, Or\n from sympy.matrices import SparseMatrix, MatrixSymbol, Identity\n from sympy.printing.pycode import (\n@@ -51,7 +52,12 @@ def test_PythonCodePrinter():\n     assert prntr.doprint(Piecewise((2, Le(x, 0)),\n                         (3, Gt(x, 0)), evaluate=False)) == '((2) if (x <= 0) else'\\\n                                                         ' (3) if (x > 0) else None)'\n-    assert prntr.doprint(sign(x)) == '(0.0 if x == 0 else math.copysign(1, x))'\n+    assert prntr.doprint(Min(x, y)) == \"min(x, y)\"\n+    assert prntr.doprint(Max(x, y)) == \"max(x, y)\"\n+    assert prntr.doprint(Min(x, y, z)) == \"min(x, y, z)\"\n+    assert prntr.doprint(Max(x, y, z)) == \"max(x, y, z)\"\n+    assert prntr.doprint(Min(x, 5)) == \"min(x, 5)\"\n+    assert prntr.doprint(Max(3, y)) == \"max(3, y)\"\n     assert prntr.doprint(p[0, 1]) == 'p[0, 1]'\n     assert prntr.doprint(KroneckerDelta(x,y)) == '(1 if x == y else 0)'\n \n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..17a1f2d 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,6 +1175,16 @@ def test_scipy_polys():\n \n \n \n+import inspect\n+from sympy import lambdify\n+\n+def test_lambdify_single_element_tuple():\n+    # lambdify should respect single-element tuples, i.e., include the trailing comma\n+    f2b = lambdify([], (1,))  # Single-element tuple\n+    source = inspect.getsource(f2b)\n+    assert 'return (1,)' in source\n+    assert f2b() == (1,)\n+\n def test_lambdify_inspect():\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n",
  "sympy__sympy-23534": "diff --git a/sympy/core/tests/test_symbol.py b/sympy/core/tests/test_symbol.py\nindex 645c231..929aa32 100644\n--- a/sympy/core/tests/test_symbol.py\n+++ b/sympy/core/tests/test_symbol.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.relational import (GreaterThan, LessThan, StrictGreaterThan, StrictLessThan)\n from sympy.core.symbol import (Dummy, Symbol, Wild, symbols)\n from sympy.core.sympify import sympify  # can't import as S yet\n-from sympy.core.symbol import uniquely_named_symbol, _symbol, Str\n+from sympy.core.function import Function, UndefinedFunction\n \n from sympy.testing.pytest import raises\n from sympy.core.symbol import disambiguate\n@@ -295,7 +296,11 @@ def test_symbols():\n     assert symbols(('aa:d','x:z')) == ((aa, ab, ac, ad), (x, y, z))\n \n \n-    # issue 6675\n+def test_symbols_with_extra_parentheses():\n+    from sympy import symbols\n+    q, u = symbols(('q:2', 'u:2'), cls=Function)\n+    assert isinstance(q[0], UndefinedFunction), \"Expected an instance of UndefinedFunction\"\n+    assert isinstance(u[1], UndefinedFunction), \"Expected an instance of UndefinedFunction\"\n     def sym(s):\n         return str(symbols(s))\n     assert sym('a0:4') == '(a0, a1, a2, a3)'\n",
  "sympy__sympy-23824": "diff --git a/sympy/physics/hep/tests/test_gamma_matrices.py b/sympy/physics/hep/tests/test_gamma_matrices.py\nindex a4e0962..af276ad 100644\n--- a/sympy/physics/hep/tests/test_gamma_matrices.py\n+++ b/sympy/physics/hep/tests/test_gamma_matrices.py\n@@ -262,7 +262,28 @@ def test_kahane_simplify1():\n     assert r.equals(-2*G(sigma)*G(rho)*G(nu))\n \n \n-def test_gamma_matrix_class():\n+def test_leading_uncontracted_order():\n+    mu, nu, rho, sigma = tensor_indices(\"mu, nu, rho, sigma\", LorentzIndex)\n+    \n+    # Test case from the issue\n+    t1 = G(mu)*G(-mu)*G(rho)*G(sigma)\n+    r1 = kahane_simplify(t1)\n+    assert r1.equals(4*G(rho)*G(sigma)), \"Failed: kahane_simplify t1\"\n+\n+    t2 = G(rho)*G(sigma)*G(mu)*G(-mu)\n+    r2 = kahane_simplify(t2)\n+    assert r2.equals(4*G(rho)*G(sigma)), \"Failed: kahane_simplify t2\"\n+\n+    # Additional related tests\n+    # Simple case with single gamma matrices not to be affected\n+    t3 = G(mu)*G(nu)\n+    r3 = kahane_simplify(t3)\n+    assert r3.equals(G(mu)*G(nu)), \"Failed: kahane_simplify t3 - single gamma matrices\"\n+\n+    # Case with more than two gamma matrices\n+    t4 = G(mu)*G(nu)*G(rho)*G(sigma)*G(mu)\n+    r4 = kahane_simplify(t4)\n+    assert r4.equals(G(mu)*G(nu)*G(rho)*G(sigma)*G(mu)), \"Failed: kahane_simplify t4 - more than two gamma matrices\"\n     i, j, k = tensor_indices('i,j,k', LorentzIndex)\n \n     # define another type of TensorHead to see if exprs are correctly handled:\n",
  "sympy__sympy-23950": "diff --git a/sympy/sets/tests/test_contains.py b/sympy/sets/tests/test_contains.py\nindex 4bcc7c8..02385bf 100644\n--- a/sympy/sets/tests/test_contains.py\n+++ b/sympy/sets/tests/test_contains.py\n@@ -29,6 +29,9 @@ def test_issue_10326():\n     assert Contains(oo, Interval(-oo, oo)) == False\n     assert Contains(-oo, Interval(-oo, oo)) == False\n \n+from sympy import Symbol, S, FiniteSet, Integers, Reals, Contains, Piecewise\n+from sympy.core.relational import Eq\n+from sympy.testing.pytest import raises\n \n def test_binary_symbols():\n     x = Symbol('x')\n@@ -46,6 +49,20 @@ def test_as_set():\n     raises(NotImplementedError, lambda:\n            Contains(x, FiniteSet(y)).as_set())\n \n-def test_type_error():\n+def test_as_set_with_defined_sets():\n+    x = Symbol('x')\n+    y = Symbol('y')\n+    # Expected behavior: translate Contains to its respective set\n+    assert Contains(x, FiniteSet(y)).as_set() == FiniteSet(y)\n+    assert Contains(x, S.Integers).as_set() == S.Integers\n+    assert Contains(x, S.Reals).as_set() == S.Reals\n+\n+def test_contains_in_piecewise():\n+    x = Symbol('x')\n+    y = Symbol('y')\n+    # Check that Piecewise can handle Contains properly\n+    pw = Piecewise((6, Contains(x, Reals)), (7, True))\n+    assert pw.subs(x, 0) == 6\n+    assert pw.subs(x, S.Infinity) == 7\n     # Pass in a parameter not of type \"set\"\n-    raises(TypeError, lambda: Contains(2, None))\n+    raises(TypeError, lambda: Contains(2, None))\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..47e00be 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -528,6 +528,30 @@ def test_issue_22819():\n     assert Da.scale_factor == 1.66053906660000e-24\n \n \n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units import Quantity\n+    from sympy.physics.units.systems.si import SI\n+    from sympy import exp\n+    from sympy.physics.units.dimensions import Dimension\n+\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n+\n def test_issue_20288():\n     from sympy.core.numbers import E\n     from sympy.physics.units import energy\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..d48c56c 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -548,7 +548,60 @@ def test_issue_24062():\n     R = Quantity('R')\n     C = Quantity('C')\n     T = Quantity('T')\n-    SI.set_quantity_dimension(R, impedance)\n+from sympy.physics.units import Quantity, time, velocity, acceleration, second, meter\n+from sympy.physics.units.systems.si import SI\n+\n+def test_issue_24211():\n+    V1 = Quantity('V1')\n+    SI.set_quantity_dimension(V1, velocity)\n+    SI.set_quantity_scale_factor(V1, 1 * meter / second)\n+    A1 = Quantity('A1')\n+    SI.set_quantity_dimension(A1, acceleration)\n+    SI.set_quantity_scale_factor(A1, 1 * meter / second**2)\n+    T1 = Quantity('T1')\n+    SI.set_quantity_dimension(T1, time)\n+    SI.set_quantity_scale_factor(T1, 1 * second)\n+\n+    expr = A1*T1 + V1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr)\n+\n+def test_issue_24211_negative_velocity():\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+    \n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+    \n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+    \n+    expr1 = a1*t1 + v1\n+    # Check that no ValueError is raised\n+    SI._collect_factor_and_dimension(expr1)\n+\n+def test_incompatible_dimensions():\n+    length1 = Quantity('length1')\n+    SI.set_quantity_dimension(length1, meter)\n+    SI.set_quantity_scale_factor(length1, 5 * meter)\n+    \n+    length2 = Quantity('length2')\n+    SI.set_quantity_dimension(length2, meter)\n+    SI.set_quantity_scale_factor(length2, 10 * meter)\n+    \n+    time1 = Quantity('time1')\n+    SI.set_quantity_dimension(time1, second)\n+    SI.set_quantity_scale_factor(time1, 2 * second)\n+    \n+    expr_incompatible = length1 + time1\n+    try:\n+        SI._collect_factor_and_dimension(expr_incompatible)\n+        assert False  # If no exception, test fails\n+    except ValueError as e:\n+        assert str(e).startswith('Dimension of')\n     SI.set_quantity_dimension(C, capacitance)\n     SI.set_quantity_dimension(T, time)\n     R.set_global_relative_scale_factor(1, ohm)\n",
  "sympy__sympy-24443": "diff --git a/sympy/combinatorics/tests/test_homomorphisms.py b/sympy/combinatorics/tests/test_homomorphisms.py\nindex 0a025da..5f97058 100644\n--- a/sympy/combinatorics/tests/test_homomorphisms.py\n+++ b/sympy/combinatorics/tests/test_homomorphisms.py\n@@ -1,3 +1,4 @@\n+\n from sympy.combinatorics import Permutation\n from sympy.combinatorics.perm_groups import PermutationGroup\n from sympy.combinatorics.homomorphisms import homomorphism, group_isomorphism, is_isomorphic\n@@ -5,6 +6,7 @@ from sympy.combinatorics.free_groups import free_group\n from sympy.combinatorics.fp_groups import FpGroup\n from sympy.combinatorics.named_groups import AlternatingGroup, DihedralGroup, CyclicGroup\n from sympy.testing.pytest import raises\n+from sympy.combinatorics.named_groups import DihedralGroup\n \n def test_homomorphism():\n     # FpGroup -> PermutationGroup\n@@ -43,6 +45,10 @@ def test_homomorphism():\n     assert T.invert(a**-1*b**-1*a**2) == a*b**-1\n \n     # PermutationGroup -> PermutationGroup\n+    # Test for the issue with homomorphism on PermutationGroups\n+    D3 = DihedralGroup(3)\n+    T = homomorphism(D3, D3, D3.generators, D3.generators)\n+    assert T.is_isomorphism()\n     D = DihedralGroup(8)\n     p = Permutation(0, 1, 2, 3, 4, 5, 6, 7)\n     P = PermutationGroup(p)\n",
  "sympy__sympy-24539": "diff --git a/sympy/polys/tests/test_rings.py b/sympy/polys/tests/test_rings.py\nindex 1f0e405..1990c52 100644\n--- a/sympy/polys/tests/test_rings.py\n+++ b/sympy/polys/tests/test_rings.py\n@@ -250,6 +250,29 @@ def test_PolyElement_copy():\n     assert f != g\n \n def test_PolyElement_as_expr():\n+    # Test the method with different number of symbols\n+    R, x, y, z = ring(\"x,y,z\", ZZ)\n+    f = 3*x**2*y - x*y*z + 7*z**3 + 1\n+\n+    # Case with the correct number of symbols\n+    U, V, W = symbols(\"u,v,w\")\n+    g = 3*U**2*V - U*V*W + 7*W**3 + 1\n+    assert f.as_expr(U, V, W) == g\n+\n+    # Case with fewer symbols than generators\n+    raises(ValueError, lambda: f.as_expr(U, V))\n+\n+    # Case with more symbols than generators\n+    extra_symbol = symbols(\"extra\")\n+    raises(ValueError, lambda: f.as_expr(U, V, W, extra_symbol))\n+\n+    # Edge case where there are no generators\n+    R, = ring(\"\", ZZ)\n+    h = R(5)\n+    assert h.as_expr() == 5\n+\n+    # Case with mixed symbolic and non-symbolic input (should raise an error)\n+    raises(TypeError, lambda: f.as_expr(U, \"v\", W))\n     R, x, y, z = ring(\"x,y,z\", ZZ)\n     f = 3*x**2*y - x*y*z + 7*z**3 + 1\n \n",
  "sympy__sympy-24661": "diff --git a/sympy/parsing/tests/test_sympy_parser.py b/sympy/parsing/tests/test_sympy_parser.py\nindex 3723931..0b0a051 100644\n--- a/sympy/parsing/tests/test_sympy_parser.py\n+++ b/sympy/parsing/tests/test_sympy_parser.py\n@@ -267,6 +267,40 @@ def test_convert_equals_signs():\n     transformations = standard_transformations + \\\n                         (convert_equals_signs, )\n     x = Symbol('x')\n+\n+    def test_issue_24288():\n+        inputs = {\n+            \"1 < 2\": Lt(1, 2, evaluate=False),\n+            \"1 <= 2\": Le(1, 2, evaluate=False),\n+            \"1 > 2\": Gt(1, 2, evaluate=False),\n+            \"1 >= 2\": Ge(1, 2, evaluate=False),\n+            \"1 != 2\": Ne(1, 2, evaluate=False),\n+            \"1 == 2\": Eq(1, 2, evaluate=False)\n+        }\n+        for text, result in inputs.items():\n+            assert parse_expr(text, evaluate=False) == result\n+\n+    def test_relational_with_symbols():\n+        inputs = {\n+            \"x < y\": Lt(x, y, evaluate=False),\n+            \"x <= y\": Le(x, y, evaluate=False),\n+            \"x > y\": Gt(x, y, evaluate=False),\n+            \"x >= y\": Ge(x, y, evaluate=False),\n+            \"x != y\": Ne(x, y, evaluate=False),\n+            \"x == y\": Eq(x, y, evaluate=False)\n+        }\n+        for text, result in inputs.items():\n+            assert parse_expr(text, evaluate=False) == result\n+\n+    def test_complex_relational():\n+        inputs = {\n+            \"1 + x < 2\": Lt(1 + x, 2, evaluate=False),\n+            \"x**2 >= y\": Ge(x**2, y, evaluate=False),\n+            \"3*x != 2*y\": Ne(3*x, 2*y, evaluate=False),\n+            \"x + y == y + x\": Eq(x + y, y + x, evaluate=False)\n+        }\n+        for text, result in inputs.items():\n+            assert parse_expr(text, evaluate=False) == result\n     y = Symbol('y')\n     assert parse_expr(\"1*2=x\", transformations=transformations) == Eq(2, x)\n     assert parse_expr(\"y = x\", transformations=transformations) == Eq(y, x)\n@@ -276,6 +310,40 @@ def test_convert_equals_signs():\n \n def test_parse_function_issue_3539():\n     x = Symbol('x')\n+\n+    def test_issue_24288():\n+        inputs = {\n+            \"1 < 2\": Lt(1, 2, evaluate=False),\n+            \"1 <= 2\": Le(1, 2, evaluate=False),\n+            \"1 > 2\": Gt(1, 2, evaluate=False),\n+            \"1 >= 2\": Ge(1, 2, evaluate=False),\n+            \"1 != 2\": Ne(1, 2, evaluate=False),\n+            \"1 == 2\": Eq(1, 2, evaluate=False)\n+        }\n+        for text, result in inputs.items():\n+            assert parse_expr(text, evaluate=False) == result\n+\n+    def test_relational_with_symbols():\n+        inputs = {\n+            \"x < y\": Lt(x, y, evaluate=False),\n+            \"x <= y\": Le(x, y, evaluate=False),\n+            \"x > y\": Gt(x, y, evaluate=False),\n+            \"x >= y\": Ge(x, y, evaluate=False),\n+            \"x != y\": Ne(x, y, evaluate=False),\n+            \"x == y\": Eq(x, y, evaluate=False)\n+        }\n+        for text, result in inputs.items():\n+            assert parse_expr(text, evaluate=False) == result\n+\n+    def test_complex_relational():\n+        inputs = {\n+            \"1 + x < 2\": Lt(1 + x, 2, evaluate=False),\n+            \"x**2 >= y\": Ge(x**2, y, evaluate=False),\n+            \"3*x != 2*y\": Ne(3*x, 2*y, evaluate=False),\n+            \"x + y == y + x\": Eq(x + y, y + x, evaluate=False)\n+        }\n+        for text, result in inputs.items():\n+            assert parse_expr(text, evaluate=False) == result\n     f = Function('f')\n     assert parse_expr('f(x)') == f(x)\n \n",
  "astropy__astropy-14369": "diff --git a/astropy/units/tests/test_format.py b/astropy/units/tests/test_format.py\nindex 062b5f4..12ca811 100644\n--- a/astropy/units/tests/test_format.py\n+++ b/astropy/units/tests/test_format.py\n@@ -57,6 +57,8 @@ def test_unit_grammar_fail(string):\n     \"strings, unit\",\n     [\n         ([\"0.1nm\"], u.AA),\n+        ([\"10+3J/m/s/kpc2\"], u.Unit(1e3 * u.W / (u.m * u.s * u.kpc**2))),\n+        ([\"10-7J/s/kpc2\"], u.Unit(1e-7 * u.W / (u.s * u.kpc**2))),\n         ([\"mW/m2\"], u.Unit(u.erg / u.cm**2 / u.s)),\n         ([\"mW/(m2)\"], u.Unit(u.erg / u.cm**2 / u.s)),\n         ([\"km/s\", \"km.s-1\"], u.km / u.s),\n",
  "astropy__astropy-14598": "",
  "django__django-11299": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex b3dc643..7ec81e2 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1899,6 +1899,26 @@ class OperationTests(OperationTestBase):\n         self.assertEqual(Author.objects.get(), author)\n \n     @skipUnlessDBFeature('supports_table_check_constraints')\n+    def test_check_constraint_with_and_or(self):\n+        app_label = 'test_or_and_constraint'\n+        constraint_name = 'check_constraint_with_and_or'\n+        from_state = self.set_up_test_model(app_label)\n+        check = models.Q(flag__exact=True, field_1__isnull=False) | models.Q(flag__exact=False)\n+        constraint = models.CheckConstraint(check=check, name=constraint_name)\n+        operation = migrations.AddConstraint('TestConstraint', constraint)\n+        to_state = from_state.clone()\n+        operation.state_forwards(app_label, to_state)\n+\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, from_state, to_state)\n+\n+        # Check that the model's table has the constraint applied correctly\n+        TestConstraint = to_state.apps.get_model(app_label, 'TestConstraint')\n+        with self.assertRaises(IntegrityError), transaction.atomic():\n+            TestConstraint.objects.create(flag=True, field_1=None)\n+\n+        TestConstraint.objects.create(flag=False, field_1=None)  # Should not raise an error\n+        TestConstraint.objects.create(flag=True, field_1=5)  # Should not raise an error\n     def test_remove_constraint(self):\n         project_state = self.set_up_test_model(\"test_removeconstraint\", constraints=[\n             models.CheckConstraint(check=models.Q(pink__gt=2), name=\"test_remove_constraint_pony_pink_gt_2\"),\n",
  "django__django-11477": "diff --git a/tests/i18n/patterns/tests.py b/tests/i18n/patterns/tests.py\nindex e4898b6..799d0c4 100644\n--- a/tests/i18n/patterns/tests.py\n+++ b/tests/i18n/patterns/tests.py\n@@ -163,6 +163,27 @@ class URLTranslationTests(URLTestCaseBase):\n             self.assertEqual(translate_url('/nl/gebruikers/', 'en'), '/en/users/')\n             self.assertEqual(translation.get_language(), 'nl')\n \n+    def test_translate_url_with_optional_groups(self):\n+        # Test URL translation with optional parts in the pattern\n+        with translation.override('en'):\n+            self.assertEqual(\n+                translate_url('/en/regex_optional/1/2/', 'nl'),\n+                '/nl/regex_optional/1/2/'\n+            )\n+            self.assertEqual(\n+                translate_url('/en/regex_optional/1/', 'nl'),\n+                '/nl/regex_optional/1/'\n+            )\n+        \n+        with translation.override('nl'):\n+            self.assertEqual(\n+                translate_url('/nl/regex_optional/1/2/', 'en'),\n+                '/en/regex_optional/1/2/'\n+            )\n+            self.assertEqual(\n+                translate_url('/nl/regex_optional/1/', 'en'),\n+                '/en/regex_optional/1/'\n+            )\n \n class URLNamespaceTests(URLTestCaseBase):\n     \"\"\"\n",
  "django__django-12273": "diff --git a/tests/model_inheritance_regress/tests.py b/tests/model_inheritance_regress/tests.py\nindex d79faca..f2752e8 100644\n--- a/tests/model_inheritance_regress/tests.py\n+++ b/tests/model_inheritance_regress/tests.py\n@@ -1,4 +1,24 @@\n+\n \"\"\"\n+class PrimaryKeyResetTest(TestCase):\n+    def test_reset_pk_creates_new_instance(self):\n+        # Create an original Derived instance\n+        original = Derived.objects.create(f=True)\n+\n+        # Reset the object's pk and save it\n+        new_instance = Derived.objects.get(pk=original.pk)\n+        new_instance.reset()\n+        new_instance.save()\n+\n+        # The original instance should still exist\n+        self.assertTrue(Derived.objects.filter(pk=original.pk).exists())\n+\n+        # A new instance should be created\n+        self.assertEqual(Derived.objects.count(), 2)\n+\n+        # Test if the new instance has the attributes reset\n+        self.assertFalse(new_instance.f)\n+\n Regression tests for Model inheritance behavior.\n \"\"\"\n import datetime\n@@ -15,6 +35,7 @@ from .models import (\n     Person, Place, Profile, QualityControl, Restaurant, SelfRefChild,\n     SelfRefParent, Senator, Supplier, TrainStation, User, Wholesaler,\n )\n+from .models import Item, Derived\n \n \n class ModelInheritanceTest(TestCase):\n",
  "django__django-12965": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 19cff3e..7346962 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -606,6 +606,18 @@ class DeletionTests(TestCase):\n \n class FastDeleteTests(TestCase):\n \n+    def test_fast_delete_all_without_subquery(self):\n+        \"\"\"\n+        Ensure that deleting all objects from a model's queryset does not\n+        generate a subquery in the SQL, for performance reasons.\n+        \"\"\"\n+        User.objects.create()\n+        with self.assertNumQueries(1) as ctx:\n+            User.objects.all().delete()\n+        sql = ctx.captured_queries[0]['sql']\n+        # The SQL query should not contain 'SELECT' as part of a subquery.\n+        self.assertNotIn('SELECT', sql)\n+\n     def test_fast_delete_fk(self):\n         u = User.objects.create(\n             avatar=Avatar.objects.create()\n@@ -702,4 +714,4 @@ class FastDeleteTests(TestCase):\n         origin = Origin.objects.create()\n         referer = Referrer.objects.create(origin=origin, unique_field=42)\n         with self.assertNumQueries(2):\n-            referer.delete()\n+            referer.delete()\n",
  "django__django-13023": "diff --git a/tests/model_fields/test_decimalfield.py b/tests/model_fields/test_decimalfield.py\nindex ab04b0d..942c5e5 100644\n--- a/tests/model_fields/test_decimalfield.py\n+++ b/tests/model_fields/test_decimalfield.py\n@@ -1,3 +1,4 @@\n+\n import unittest\n from decimal import Decimal\n \n@@ -24,8 +25,24 @@ class DecimalFieldTests(TestCase):\n         msg = '\u201cabc\u201d value must be a decimal number.'\n         with self.assertRaisesMessage(ValidationError, msg):\n             f.to_python('abc')\n-\n-    def test_default(self):\n+    \n+    def test_invalid_value(self):\n+        field = models.DecimalField(max_digits=4, decimal_places=2)\n+        msg = '\u201c%s\u201d value must be a decimal number.'\n+        tests = [\n+            {},  # This is the critical test case\n+            (),  # Additional test cases for completeness\n+            [],\n+            set(),\n+            object(),\n+            complex(),\n+            'non-numeric string',\n+            b'non-numeric byte-string',\n+        ]\n+        for value in tests:\n+            with self.subTest(value=value):\n+                with self.assertRaisesMessage(ValidationError, msg % (value,)):\n+                    field.clean(value, None)\n         f = models.DecimalField(default=Decimal('0.00'))\n         self.assertEqual(f.get_default(), Decimal('0.00'))\n \n",
  "django__django-13406": "diff --git a/tests/queryset_pickle/tests.py b/tests/queryset_pickle/tests.py\nindex d0a7de1..9d0247b 100644\n--- a/tests/queryset_pickle/tests.py\n+++ b/tests/queryset_pickle/tests.py\n@@ -1,14 +1,49 @@\n+\n import datetime\n import pickle\n \n import django\n from django.db import models\n from django.test import TestCase\n+from django.db.models import Sum\n \n from .models import Container, Event, Group, Happening, M2MModel, MyEvent\n \n-\n-class PickleabilityTestCase(TestCase):\n+class QuerySetPickleTestCase(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        Happening.objects.create(name='test', when=datetime.datetime.now())\n+\n+    def test_values_annotate_group_by_behavior(self):\n+        # Create sample data\n+        Event.objects.create(title='Event 1', group=Group.objects.create(name='Group 1'))\n+        Event.objects.create(title='Event 2', group=Group.objects.create(name='Group 1'))\n+        \n+        # Original query\n+        qs = Event.objects.values('group__name').annotate(total_events=Sum('id'))\n+        \n+        # Pickle and unpickle the query\n+        reloaded = Event.objects.all()\n+        reloaded.query = pickle.loads(pickle.dumps(qs.query))\n+        \n+        # Verify the correct data type is returned after unpickling\n+        self.assertEqual(type(qs[0]), dict)\n+        self.assertEqual(type(reloaded[0]), dict)\n+\n+    def test_values_list_annotate(self):\n+        # Create sample data\n+        Event.objects.create(title='Event 1', group=Group.objects.create(name='Group 1'))\n+        \n+        # Original query\n+        qs = Event.objects.values_list('group__name', flat=True).annotate(total_events=Sum('id'))\n+        \n+        # Pickle and unpickle the query\n+        reloaded = Event.objects.all()\n+        reloaded.query = pickle.loads(pickle.dumps(qs.query))\n+        \n+        # Verify the correct data type is returned after unpickling\n+        self.assertEqual(type(list(qs)[0]), str)\n+        self.assertEqual(type(list(reloaded)[0]), str)\n     @classmethod\n     def setUpTestData(cls):\n         Happening.objects.create()  # make sure the defaults are working (#20158)\n",
  "django__django-13449": "diff --git a/tests/expressions_window/models.py b/tests/expressions_window/models.py\nindex 3f59cdf..d9c7568 100644\n--- a/tests/expressions_window/models.py\n+++ b/tests/expressions_window/models.py\n@@ -11,4 +11,5 @@ class Employee(models.Model):\n     department = models.CharField(max_length=40, blank=False, null=False)\n     hire_date = models.DateField(blank=False, null=False)\n     age = models.IntegerField(blank=False, null=False)\n-    classification = models.ForeignKey('Classification', on_delete=models.CASCADE, null=True)\n+    classification = models.ForeignKey('Classification', on_delete=models.CASCADE, null=True)\n+    bonus = models.DecimalField(decimal_places=2, max_digits=15, null=True)\n",
  "django__django-13512": "diff --git a/tests/forms_tests/field_tests/test_jsonfield.py b/tests/forms_tests/field_tests/test_jsonfield.py\nindex e31bff4..c6013d9 100644\n--- a/tests/forms_tests/field_tests/test_jsonfield.py\n+++ b/tests/forms_tests/field_tests/test_jsonfield.py\n@@ -24,6 +24,19 @@ class JSONFieldTest(SimpleTestCase):\n         with self.assertRaisesMessage(ValidationError, 'Enter a valid JSON.'):\n             field.clean('{some badly formed: json}')\n \n+    def test_unicode_characters(self):\n+        field = JSONField()\n+        # Test Chinese characters\n+        self.assertEqual(field.prepare_value({'a': '\u4f60\u597d \u4e16\u754c'}), '{\"a\": \"\u4f60\u597d \u4e16\u754c\"}')\n+        self.assertEqual(field.prepare_value('\u4f60\u597d\uff0c\u4e16\u754c'), '\"\u4f60\u597d\uff0c\u4e16\u754c\"')\n+        # Test emoji\n+        self.assertEqual(field.prepare_value({'a': '\ud83d\ude00\ud83d\udc31'}), '{\"a\": \"\ud83d\ude00\ud83d\udc31\"}')\n+        # Test mixed content\n+        self.assertEqual(\n+            field.prepare_value(['\u4f60\u597d\uff0c\u4e16\u754c', 'ja\u017a\u0144']),\n+            '[\"\u4f60\u597d\uff0c\u4e16\u754c\", \"ja\u017a\u0144\"]',\n+        )\n+\n     def test_prepare_value(self):\n         field = JSONField()\n         self.assertEqual(field.prepare_value({'a': 'b'}), '{\"a\": \"b\"}')\n",
  "django__django-14404": "",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..9d626c9 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -658,7 +658,45 @@ class WriterTests(SimpleTestCase):\n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n \n-    def test_simple_migration(self):\n+    def test_missing_import_in_migration(self):\n+        \"\"\"\n+        Test that a migration file includes necessary import statements.\n+        \"\"\"\n+\n+        class MyField(models.TextField):\n+            pass\n+\n+        class MyModelBase(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        class MyMixin:\n+            pass\n+\n+        class MyModel(MyMixin, MyModelBase):\n+            name = MyField(primary_key=True)\n+\n+        migration = type(\"Migration\", (migrations.Migration,), {\n+            \"operations\": [\n+                migrations.CreateModel(\n+                    name=\"MyModel\",\n+                    fields=[\n+                        (\"name\", MyField(primary_key=True, serialize=False)),\n+                    ],\n+                    options={\n+                        \"abstract\": False,\n+                    },\n+                    bases=(MyMixin, models.Model),  # This line is where 'models' should not cause NameError\n+                ),\n+            ],\n+            \"dependencies\": [],\n+        })\n+\n+        writer = MigrationWriter(migration)\n+        output = writer.as_string()\n+        result = self.safe_exec(output)\n+        self.assertIn(\"Migration\", result)\n+        self.assertIn(\"from django.db import models\", output)\n         \"\"\"\n         Tests serializing a simple migration.\n         \"\"\"\n",
  "django__django-15375": "diff --git a/tests/aggregation/tests.py b/tests/aggregation/tests.py\nindex 1d4ef56..ea8f572 100644\n--- a/tests/aggregation/tests.py\n+++ b/tests/aggregation/tests.py\n@@ -1629,8 +1629,22 @@ class AggregateTestCase(TestCase):\n             value=Sum('price', filter=Q(rating__lt=3.0), default=Avg('pages') / 10.0),\n         )\n         self.assertAlmostEqual(result['value'], Decimal('61.72'), places=2)\n-\n-    def test_exists_none_with_aggregate(self):\n+    def test_aggregation_sum_with_default_after_annotation(self):\n+        # Test case for the issue mentioned where using 'default' after annotate crashes.\n+        result = Book.objects.annotate(\n+            idx=F('id')\n+        ).aggregate(\n+            total_id=Sum('id', default=0)\n+        )\n+        # We expect this to no longer raise an OperationalError and return the correct sum.\n+        self.assertEqual(result['total_id'], 4560)\n+\n+    def test_aggregation_default_with_no_annotation(self):\n+        # Control test to ensure normal behavior with aggregate and default.\n+        result = Book.objects.aggregate(\n+            total_id=Sum('id', default=0)\n+        )\n+        self.assertEqual(result['total_id'], 4560)\n         qs = Book.objects.all().annotate(\n             count=Count('id'),\n             exists=Exists(Author.objects.none()),\n@@ -1642,4 +1656,4 @@ class AggregateTestCase(TestCase):\n             count=Count('id'),\n             exists=Exists(Author.objects.extra(where=['1=0'])),\n         )\n-        self.assertEqual(len(qs), 6)\n+        self.assertEqual(len(qs), 6)\n",
  "django__django-15695": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 99db46a..e8b2fcc 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -2988,7 +2988,14 @@ class OperationTests(OperationTestBase):\n         with connection.schema_editor() as editor, self.assertNumQueries(0):\n             operation.database_backwards(app_label, editor, new_state, project_state)\n         self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n-        # Deconstruction.\n+        # Re-apply renaming to test for crash when unnamed index moves backward and forward.\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n+        \n+        with connection.schema_editor() as editor, self.assertNumQueries(0):\n+            operation.database_backwards(app_label, editor, new_state, project_state)\n+        self.assertIndexNameExists(table_name, \"new_pony_test_idx\")\n         definition = operation.deconstruct()\n         self.assertEqual(definition[0], \"RenameIndex\")\n         self.assertEqual(definition[1], [])\n",
  "django__django-15732": "",
  "django__django-15916": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex cc5e08c..42785ce 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -3487,6 +3487,50 @@ class FormFieldCallbackTests(SimpleTestCase):\n \n         NewForm = modelform_factory(Person, form=BaseForm, formfield_callback=callback)\n \n+\n+        class InheritedForm(NewForm):\n+            pass\n+\n+        for name, field in NewForm.base_fields.items():\n+            self.assertEqual(type(field.widget), forms.Textarea)\n+\n+        self.assertEqual(\n+            type(NewForm.base_fields[\"id\"].widget),\n+            type(InheritedForm.base_fields[\"id\"].widget),\n+        )\n+        self.assertEqual(\n+            type(NewForm.base_fields[\"name\"].widget),\n+            type(InheritedForm.base_fields[\"name\"].widget),\n+        )\n+\n+    def test_custom_callback_in_meta(self):\n+        def callback(db_field, **kwargs):\n+            return forms.CharField(widget=forms.Textarea)\n+\n+        class NewForm(forms.ModelForm):\n+            class Meta:\n+                model = Person\n+                fields = [\"id\", \"name\"]\n+                formfield_callback = callback\n+\n+        for field in NewForm.base_fields.values():\n+            self.assertEqual(type(field.widget), forms.Textarea)\n+\n+    def test_custom_callback_from_base_form_meta(self):\n+        def callback(db_field, **kwargs):\n+            return forms.CharField(widget=forms.Textarea)\n+\n+        class BaseForm(forms.ModelForm):\n+            class Meta:\n+                model = Person\n+                fields = \"__all__\"\n+                formfield_callback = callback\n+\n+        NewForm = forms.modelform_factory(model=Person, form=BaseForm)\n+\n+        for name, field in NewForm.base_fields.items():\n+            self.assertEqual(type(field.widget), forms.Textarea)\n+\n         class InheritedForm(NewForm):\n             pass\n \n",
  "django__django-16938": "",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 53fdd55..57ecde4 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -221,10 +221,20 @@ def test_mpl_toolkits():\n     ax = parasite_axes.host_axes([0, 0, 1, 1])\n     assert type(pickle.loads(pickle.dumps(ax))) == parasite_axes.HostAxes\n \n+import platform\n+import pickle\n+import matplotlib.pyplot as plt\n \n-def test_standard_norm():\n-    assert type(pickle.loads(pickle.dumps(mpl.colors.LogNorm()))) \\\n-        == mpl.colors.LogNorm\n+def test_dpi_stability_on_unpickle():\n+    # This test simulates the environment described in the issue\n+    if platform.system() == 'Darwin' and platform.machine() == 'arm64':\n+        original_dpi = 200\n+        fig = plt.figure(dpi=original_dpi)\n+        \n+        # Pickle and unpickle the figure\n+        for _ in range(10):  # Repeat 10 times to ensure DPI stability\n+            fig = pickle.loads(pickle.dumps(fig))\n+            assert fig.get_dpi() == original_dpi, \"DPI should remain constant after unpickling\"\n \n \n def test_dynamic_norm():\n",
  "pydata__xarray-3993": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex 87375f2..40e6843 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -6596,6 +6596,19 @@ def test_integrate(dask):\n     assert_equal(actual, ds.integrate(\"y\")[\"var\"])\n     assert_equal(ds[\"var\"].integrate(\"y\"), ds.integrate(\"y\")[\"var\"])\n \n+    # Test for coord argument in DataArray.integrate\n+    with pytest.warns(FutureWarning, match=\"dim is deprecated\"):\n+        da.integrate(dim=\"x\")\n+    \n+    # Test using the new coord argument\n+    actual = da.integrate(coord=\"x\")\n+    expected = xr.DataArray(\n+        np.trapz(da, da[\"x\"], axis=0),\n+        dims=[\"y\"],\n+        coords={k: v for k, v in da.coords.items() if \"x\" not in v.dims},\n+    )\n+    assert_allclose(expected, actual.compute())\n+\n     # along x and y\n     actual = da.integrate((\"y\", \"x\"))\n     assert actual.ndim == 0\n",
  "pydata__xarray-4094": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex a2826fa..396f23b 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -3045,7 +3045,13 @@ class TestDataset:\n         d0 = D.isel(x=0)\n         assert_identical(d0, x0)\n \n-    def test_to_stacked_array_to_unstacked_dataset_different_dimension(self):\n+    def test_to_stacked_array_to_unstacked_dataset_single_dim(self):\n+        # single dimension: regression test for GH4049\n+        arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+        data = xr.Dataset({\"a\": arr, \"b\": arr})\n+        stacked = data.to_stacked_array(\"y\", sample_dims=[\"x\"])\n+        unstacked = stacked.to_unstacked_dataset(\"y\")\n+        assert_identical(unstacked, data)\n         # test when variables have different dimensionality\n         a, b = create_test_stacked_array()\n         sample_dims = [\"x\"]\n",
  "pylint-dev__pylint-8898": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex ae541fc..d5d9e2e 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -107,6 +107,36 @@ def test_unknown_yes_no(capsys: CaptureFixture) -> None:\n     assert \"Invalid yn value 'maybe', should be in \" in output.err\n \n \n+import re\n+from typing import Any\n+from pylint.lint import Run\n+import pytest\n+\n+EMPTY_MODULE = \"empty_module\"\n+\n+CSV_REGEX_COMMA_CASES = [\n+    (\"foo\", [\"foo\"]),\n+    (\"foo,bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar\", [\"foo\", \"bar\"]),\n+    (\"foo, bar{1,3}\", [\"foo\", \"bar{1,3}\"]),\n+]\n+\n+@pytest.mark.parametrize(\"in_string,expected\", CSV_REGEX_COMMA_CASES)\n+def test_csv_regex_comma_in_quantifier(in_string: str, expected: list[str]) -> None:\n+    \"\"\"Check that we correctly parse a comma-separated regex when there are one\n+    or more commas within quantifier expressions.\n+    \"\"\"\n+\n+    def _template_run(in_string: str) -> list[re.Pattern[Any]]:\n+        r = Run(\n+            [str(EMPTY_MODULE), rf\"--bad-names-rgx={in_string}\"],\n+            exit=False,\n+        )\n+        bad_names_rgxs: list[re.Pattern[Any]] = r.linter.config.bad_names_rgxs\n+        return bad_names_rgxs\n+\n+    assert _template_run(in_string) == [re.compile(regex) for regex in expected]\n+\n def test_unknown_py_version(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly error on an unknown python-version.\"\"\"\n     with pytest.raises(SystemExit):\n",
  "pytest-dev__pytest-6197": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex d7aed6e..3bfd2d6 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1156,6 +1156,9 @@ def test_summary_list_after_errors(testdir):\n     )\n \n \n+import pytest\n+from _pytest.main import ExitCode\n+\n def test_importorskip():\n     with pytest.raises(\n         pytest.skip.Exception,\n@@ -1184,4 +1187,4 @@ def test_skip_package(testdir):\n \n     result = testdir.inline_run()\n     _, skipped, _ = result.listoutcomes()\n-    assert len(skipped) == 2\n+    assert len(skipped) == 2\n",
  "pytest-dev__pytest-7324": "diff --git a/testing/test_mark_expression.py b/testing/test_mark_expression.py\nindex 10b71e9..99c54ac 100644\n--- a/testing/test_mark_expression.py\n+++ b/testing/test_mark_expression.py\n@@ -139,6 +139,18 @@ def test_valid_idents(ident: str) -> None:\n     assert evaluate(ident, {ident: True}.__getitem__)\n \n \n+@pytest.mark.parametrize(\n+    \"expression_str\",\n+    [\n+        \"False\",\n+        \"True\",\n+        \"None\",\n+    ],\n+)\n+def test_invalid_compilation(expression_str: str) -> None:\n+    with pytest.raises(AssertionError):\n+        Expression.compile(expression_str)\n+\n @pytest.mark.parametrize(\n     \"ident\",\n     (\n",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..2571f63 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -259,4 +259,34 @@ def test_set_output_mro():\n     class C(A, B):\n         pass\n \n-    assert C().transform(None) == \"B\"\n+    assert C().transform(None) == \"B\"\n+\n+def test_feature_union_with_pandas_output():\n+    # Test the FeatureUnion with a custom transformer and pandas output\n+    pd = pytest.importorskip(\"pandas\")\n+    import numpy as np\n+    from sklearn.pipeline import FeatureUnion\n+    from sklearn.base import BaseEstimator, TransformerMixin\n+\n+    class MyTransformer(BaseEstimator, TransformerMixin):\n+        def fit(self, X, y=None):\n+            return self\n+\n+        def transform(self, X):\n+            return pd.DataFrame({\"value\": X[\"value\"].groupby(X[\"date\"]).sum()}, index=X[\"date\"].unique())\n+\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+\n+    union = FeatureUnion([(\"custom\", MyTransformer())])\n+    union.set_output(transform=\"pandas\")\n+\n+    result = union.fit_transform(data)\n+\n+    # Check if the output is a DataFrame\n+    assert isinstance(result, pd.DataFrame)\n+\n+    # Check the correctness of the transformed values\n+    expected = pd.DataFrame({\"value\": [240] * 4}, index=pd.to_datetime([\"2020-01-01\", \"2020-01-02\", \"2020-01-03\", \"2020-01-04\"]))\n+    pd.testing.assert_frame_equal(result, expected)\n",
  "sphinx-doc__sphinx-7454": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex f07be18..775ccd5 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -12,8 +12,32 @@ import pytest\n \n from sphinx import addnodes\n \n+import sphinx\n+from sphinx.ext.autodoc import mock\n \n @pytest.mark.sphinx('dummy', testroot='ext-autodoc')\n+def test_autodoc_typehints_none_description(app, status, warning):\n+    app.config.autodoc_typehints = 'description'\n+    app.builder.build_all()\n+\n+    content = app.env.get_doctree('index')\n+    function_items = [item for item in content.traverse(addnodes.desc) if item.get('domain') == 'py']\n+    f1 = next(item for item in function_items if item['names'][0].endswith('f1'))\n+    \n+    assert 'None' in f1.astext()\n+    assert any(ref['refuri'].endswith('#None') for ref in f1.traverse(addnodes.pending_xref)), \"Expected a link to None's documentation.\"\n+\n+@pytest.mark.sphinx('dummy', testroot='ext-autodoc')\n+def test_autodoc_typehints_none_signature(app, status, warning):\n+    app.config.autodoc_typehints = 'signature'\n+    app.builder.build_all()\n+\n+    content = app.env.get_doctree('index')\n+    function_items = [item for item in content.traverse(addnodes.desc) if item.get('domain') == 'py']\n+    f1 = next(item for item in function_items if item['names'][0].endswith('f1'))\n+    \n+    assert 'None' in f1.astext()\n+    assert not any(ref['refuri'].endswith('#None') for ref in f1.traverse(addnodes.pending_xref)), \"Expected no link to None's documentation.\"\n def test_autodoc(app, status, warning):\n     app.builder.build_all()\n \n@@ -30,4 +54,4 @@ def test_autodoc(app, status, warning):\n my_name\n \n alias of bug2437.autodoc_dummy_foo.Foo\"\"\"\n-    assert warning.getvalue() == ''\n+    assert warning.getvalue() == ''\n",
  "sphinx-doc__sphinx-8056": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 1d6a8cf..c96d24f 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1093,6 +1093,54 @@ Do as you please\n \n :keyword gotham_is_yours: shall interfere.\n :kwtype gotham_is_yours: None\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n \"\"\"\n         self.assertEqual(expected, actual)\n \n@@ -1329,6 +1377,54 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n         actual = str(NumpyDocstring(docstring, config))\n         expected = \"\"\"\\\n :Parameters: **param1** (:class:`MyClass <name.space.MyClass>` instance)\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n \"\"\"\n         self.assertEqual(expected, actual)\n \n@@ -1337,6 +1433,54 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n         expected = \"\"\"\\\n :param param1:\n :type param1: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n \"\"\"\n         self.assertEqual(expected, actual)\n \n@@ -1352,6 +1496,54 @@ param1 : MyClass instance\n         actual = str(NumpyDocstring(docstring, config))\n         expected = \"\"\"\\\n :Parameters: **param1** (:class:`MyClass instance`)\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n \"\"\"\n         self.assertEqual(expected, actual)\n \n@@ -1360,6 +1552,54 @@ param1 : MyClass instance\n         expected = \"\"\"\\\n :param param1:\n :type param1: :class:`MyClass instance`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n \"\"\"\n         self.assertEqual(expected, actual)\n \n@@ -1388,6 +1628,54 @@ numpy.multivariate_normal(mean, cov, shape=None, spam=None)\n \"\"\"\n         self.assertEqual(expected, actual)\n \n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n         docstring = \"\"\"\\\n numpy.multivariate_normal(mean, cov, shape=None, spam=None)\n \n@@ -1411,6 +1699,54 @@ numpy.multivariate_normal(mean, cov, shape=None, spam=None)\n    \\n\\\n    :meth:`otherfunc`\n        relationship\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n \"\"\"\n         self.assertEqual(expected, actual)\n \n@@ -1437,6 +1773,54 @@ Summary\n \n         self.assertEqual(expected, actual)\n \n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n     def test_underscore_in_attribute(self):\n         docstring = \"\"\"\n Attributes\n@@ -1457,6 +1841,54 @@ arg_ : type\n \n         self.assertEqual(expected, actual)\n \n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n     def test_underscore_in_attribute_strip_signature_backslash(self):\n         docstring = \"\"\"\n Attributes\n@@ -1478,6 +1910,54 @@ arg_ : type\n \n         self.assertEqual(expected, actual)\n \n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n     def test_raises_types(self):\n         docstrings = [(\"\"\"\n Example Function\n@@ -1681,6 +2161,54 @@ Example Function\n         actual = str(NumpyDocstring(docstring, config, app, \"method\"))\n         self.assertEqual(expected, actual)\n \n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n     def test_section_header_underline_length(self):\n         docstrings = [(\"\"\"\n Summary line\n@@ -1927,6 +2455,54 @@ definition_after_normal_text : int\n         actual = str(NumpyDocstring(docstring, config))\n         self.assertEqual(expected, actual)\n \n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n         expected = \"\"\"One line summary.\n \n :Parameters: * **no_list** (:class:`int`)\n@@ -2019,6 +2595,54 @@ definition_after_normal_text : int\n         actual = str(NumpyDocstring(docstring, config))\n         self.assertEqual(expected, actual)\n \n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n     def test_token_type(self):\n         tokens = (\n             (\"1\", \"literal\"),\n@@ -2201,6 +2825,54 @@ definition_after_normal_text : int\n         actual = str(NumpyDocstring(docstring, config))\n         self.assertEqual(expected, actual)\n \n+    def test_multiple_parameters_single_line(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_optional_multiple_parameters(self):\n+        docstring = \"\"\"\\\n+Parameters\n+----------\n+x1, x2 : array_like, optional\n+    Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Parameters: **x1, x2** (:class:`array_like`, *optional*) -- Input arrays, description of `x1`, `x2`.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(dedent(docstring), config))\n+        expected = \"\"\"\\\n+:param x1: Input arrays, description of `x1`, `x2`.\n+:type x1: :class:`array_like`, *optional*\n+:param x2: Input arrays, description of `x1`, `x2`.\n+:type x2: :class:`array_like`, *optional*\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n \n @contextmanager\n def warns(warning, match):\n",
  "sphinx-doc__sphinx-8551": "",
  "sphinx-doc__sphinx-8593": "",
  "sphinx-doc__sphinx-9230": "diff --git a/tests/test_domain_py.py b/tests/test_domain_py.py\nindex e86a758..2fdf916 100644\n--- a/tests/test_domain_py.py\n+++ b/tests/test_domain_py.py\n@@ -983,8 +983,46 @@ def test_info_field_list(app):\n                 refdomain=\"py\", reftype=\"class\", reftarget=\"str\",\n                 **{\"py:module\": \"example\", \"py:class\": \"Class\"})\n \n+def test_dict_str_str_param_rendering(app):\n+    text = (\".. py:module:: example\\n\"\n+            \".. py:class:: Class\\n\"\n+            \"\\n\"\n+            \"   :param dict(str, str) opc_meta: (optional)\\n\")\n+    doctree = restructuredtext.parse(app, text)\n+\n+    assert_node(doctree, (nodes.target,\n+                          addnodes.index,\n+                          addnodes.index,\n+                          [desc, ([desc_signature, ([desc_annotation, \"class \"],\n+                                                    [desc_addname, \"example.\"],\n+                                                    [desc_name, \"Class\"])],\n+                                  [desc_content, nodes.field_list, nodes.field])]))\n+    assert_node(doctree[3][1][0][0],\n+                ([nodes.field_name, \"Parameters\"],\n+                 [nodes.field_body, nodes.bullet_list, [nodes.list_item, nodes.paragraph]]))\n \n-def test_info_field_list_var(app):\n+    # :param dict(str, str) opc_meta:\n+    assert_node(doctree[3][1][0][0][1][0][0][0],\n+                ([addnodes.literal_strong, \"opc_meta\"],\n+                 \" (\",\n+                 [pending_xref, addnodes.literal_emphasis, \"dict\"],\n+                 [addnodes.literal_emphasis, \"(\"],\n+                 [pending_xref, addnodes.literal_emphasis, \"str\"],\n+                 [addnodes.literal_emphasis, \", \"],\n+                 [pending_xref, addnodes.literal_emphasis, \"str\"],\n+                 [addnodes.literal_emphasis, \")\"],\n+                 \")\",\n+                 \" -- \",\n+                 \"(optional)\"))\n+    assert_node(doctree[3][1][0][0][1][0][0][0][2], pending_xref,\n+                refdomain=\"py\", reftype=\"class\", reftarget=\"dict\",\n+                **{\"py:module\": \"example\", \"py:class\": \"Class\"})\n+    assert_node(doctree[3][1][0][0][1][0][0][0][4], pending_xref,\n+                refdomain=\"py\", reftype=\"class\", reftarget=\"str\",\n+                **{\"py:module\": \"example\", \"py:class\": \"Class\"})\n+    assert_node(doctree[3][1][0][0][1][0][0][0][6], pending_xref,\n+                refdomain=\"py\", reftype=\"class\", reftarget=\"str\",\n+                **{\"py:module\": \"example\", \"py:class\": \"Class\"})\n     text = (\".. py:class:: Class\\n\"\n             \"\\n\"\n             \"   :var int attr: blah blah\\n\")\n",
  "sphinx-doc__sphinx-9258": "",
  "sphinx-doc__sphinx-9673": "",
  "sympy__sympy-18211": "diff --git a/sympy/solvers/tests/test_solveset.py b/sympy/solvers/tests/test_solveset.py\nindex 7bd9e29..d578857 100644\n--- a/sympy/solvers/tests/test_solveset.py\n+++ b/sympy/solvers/tests/test_solveset.py\n@@ -1040,6 +1040,18 @@ def test__solveset_multi():\n             [Interval(0, pi), Interval(-1, 1)]) == FiniteSet((0, 1), (pi, -1))\n     assert _solveset_multi([r*cos(theta)-1, r*sin(theta)], [r, theta],\n             [Interval(0, 1), Interval(0, pi)]) == FiniteSet((1, 0))\n+\n+def test_issue_18188():\n+    from sympy import Eq, cos, sin, ConditionSet, S\n+    from sympy.abc import n, x\n+\n+    # Test for the specific issue reported\n+    result1 = Eq(n*cos(n) - 3*sin(n), 0)\n+    assert result1.as_set() == ConditionSet(n, Eq(n*cos(n) - 3*sin(n), 0), S.Reals)\n+\n+    # Additional test case similar in nature to ensure robustness\n+    result2 = Eq(x**2 + sqrt(x*2) + sin(x), 0)\n+    assert result2.as_set() == ConditionSet(x, Eq(sqrt(2)*sqrt(x) + x**2 + sin(x), 0), S.Reals)\n     #assert _solveset_multi([r*cos(theta)-r, r*sin(theta)], [r, theta],\n     #        [Interval(0, 1), Interval(0, pi)]) == ?\n     assert _solveset_multi([r*cos(theta)-r, r*sin(theta)], [r, theta],\n",
  "sympy__sympy-18698": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex 38de6f6..1bdf5ee 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -3264,6 +3264,8 @@ def test_noncommutative():\n     assert cancel(e + foo(e)) == c + foo(c)\n     assert cancel(e*foo(c)) == c*foo(c)\n \n+from sympy import sqf_list, symbols\n+\n \n def test_to_rational_coeffs():\n     assert to_rational_coeffs(\n@@ -3330,6 +3332,24 @@ def test_issue_17988():\n     M = Matrix([[poly(x + 1), poly(x + 1)]])\n     assert p * M == M * p == Matrix([[poly(x**2 - 1), poly(x**2 - 1)]])\n \n+\n+def test_sqf_list_consistency_issue():\n+    x = symbols('x')\n+    # Issue case test\n+    p1 = (x**2 + 1) * (x - 1)**2 * (x - 2)**3 * (x - 3)**3\n+    expected_result1 = (1, [(x**2 + 1, 1), (x - 1, 2), (x**2 - 5*x + 6, 3)])\n+    assert sqf_list(p1) == expected_result1\n+\n+    # Additional test case: Simple polynomial with one factor\n+    p2 = x**5 - 2*x**4 - 2*x**3 + 4*x**2 + x - 2\n+    expected_result2 = (1, [(x - 2, 1), (x**2 - 1, 2)])\n+    assert sqf_list(p2) == expected_result2\n+\n+    # Additional test case: Polynomial with all distinct roots\n+    p3 = x**4 - 10*x**3 + 35*x**2 - 50*x + 24  # (x-1)(x-2)(x-3)(x-4)\n+    expected_result3 = (1, [(x - 4, 1), (x - 3, 1), (x - 2, 1), (x - 1, 1)])\n+    assert sqf_list(p3) == expected_result3\n+\n def test_issue_18205():\n     assert cancel((2 + I)*(3 - I)) == 7 + I\n     assert cancel((2 + I)*(2 - I)) == 5\n",
  "sympy__sympy-19040": "diff --git a/sympy/polys/tests/test_polytools.py b/sympy/polys/tests/test_polytools.py\nindex 6ddf041..a3b9243 100644\n--- a/sympy/polys/tests/test_polytools.py\n+++ b/sympy/polys/tests/test_polytools.py\n@@ -3254,8 +3254,17 @@ def test_issue_5786():\n     assert expand(factor(expand(\n         (x - I*y)*(z - I*t)), extension=[I])) == -I*t*x - t*y + x*z - I*y*z\n \n-\n-def test_noncommutative():\n+def test_issue_18895():\n+    # Test case to verify issue #18895\n+    z = expand((x - 1)*(y - 1))\n+    normal_factor = factor(z)\n+    extension_factor = factor(z, extension=[I])\n+    \n+    # Verify that the factors obtained are equivalent to the original expression\n+    assert expand(normal_factor) == expand(extension_factor) == z\n+\n+    # Specifically check the extension factorization\n+    assert extension_factor == (x - 1)*(y - 1)\n     class foo(Expr):\n         is_commutative=False\n     e = x/(x + x*y)\n",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..8a9ef86 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -1,3 +1,6 @@\n+\n+from sympy import Symbol\n+\n \"\"\"This tests sympy/core/basic.py with (ideally) no reference to subclasses\n of Basic or Atom.\"\"\"\n \n@@ -34,7 +37,20 @@ def test_structure():\n     assert bool(b1)\n \n \n-def test_equality():\n+def test_symbol_slots_vs_dict():\n+    s = Symbol('s')\n+    # Check that __slots__ exists\n+    assert hasattr(s, '__slots__')\n+    # Check the contents of __slots__\n+    assert s.__slots__ == ('name',)\n+    # Verify the Symbol has no __dict__ attribute if __slots__ are used correctly\n+    assert not hasattr(s, '__dict__')\n+\n+def test_symbol_dict_existence():\n+    s = Symbol('s')\n+    # Ensure __dict__ should not exist if __slots__ is correctly implemented\n+    with raises(AttributeError):\n+        _ = s.__dict__\n     instances = [b1, b2, b3, b21, Basic(b1, b1, b1), Basic]\n     for i, b_i in enumerate(instances):\n         for j, b_j in enumerate(instances):\n",
  "sympy__sympy-24562": "diff --git a/sympy/core/tests/test_numbers.py b/sympy/core/tests/test_numbers.py\nindex 13e3235..4ce054c 100644\n--- a/sympy/core/tests/test_numbers.py\n+++ b/sympy/core/tests/test_numbers.py\n@@ -369,8 +369,31 @@ def test_Rational_new():\n     assert n.q == 4\n     assert n.p == -2\n \n+from sympy import Rational\n \n-def test_Number_new():\n+def test_issue_rational_calc_value_error():\n+    # Test the core issue\n+    assert Rational('0.5', '100') == Rational(1, 200)\n+    assert Rational(0.5, 100) == Rational(1, 200)\n+\n+    # Additional test cases to cover more edge scenarios\n+    # Case with integer strings\n+    assert Rational('5', '10') == Rational(1, 2)\n+    assert Rational('123', '123') == Rational(1, 1)\n+\n+    # Negative values as strings\n+    assert Rational('-0.5', '100') == Rational(-1, 200)\n+    assert Rational('0.5', '-100') == Rational(-1, 200)\n+\n+    # Very large numbers\n+    assert Rational('5000', '10000') == Rational(1, 2)\n+    assert Rational('1234567890', '987654321') == Rational('1234567890/987654321').as_numer_denom()\n+\n+    # Invalid inputs that should raise errors\n+    try:\n+        Rational('0.5/0.5', '100')\n+    except TypeError:\n+        pass\n     \"\"\"\"\n     Test for Number constructor\n     \"\"\"\n",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..e6290e7 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3202,7 +3202,43 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         self.assertEqual(form['field'].id_for_label, 'myCustomID')\n         self.assertEqual(form['field_none'].id_for_label, 'id_field_none')\n \n-    def test_boundfield_widget_type(self):\n+    def test_boundfield_subwidget_id_for_label(self):\n+        \"\"\"\n+        If auto_id is provided when initializing the form, the generated ID in\n+        subwidgets must reflect that prefix.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple,\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'prefix_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'prefix_field_1')\n+\n+    def test_boundfield_subwidget_custom_id_for_label(self):\n+        \"\"\"\n+        If a custom id is provided via ChoiceWidget.options, id_for_label should\n+        respect that custom ID.\n+        \"\"\"\n+        class CustomCheckboxSelectMultiple(CheckboxSelectMultiple):\n+            def create_option(self, *args, **kwargs):\n+                option = super().create_option(*args, **kwargs)\n+                option['attrs']['id'] = 'custom_id_%s' % option['value']\n+                return option\n+\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CustomCheckboxSelectMultiple,\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_a')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_b')\n         class SomeForm(Form):\n             first_name = CharField()\n             birthday = SplitDateTimeField(widget=SplitHiddenDateTimeWidget)\n",
  "matplotlib__matplotlib-20676": "",
  "scikit-learn__scikit-learn-12682": "diff --git a/sklearn/decomposition/tests/test_dict_learning.py b/sklearn/decomposition/tests/test_dict_learning.py\nindex 35a43f8..412e344 100644\n--- a/sklearn/decomposition/tests/test_dict_learning.py\n+++ b/sklearn/decomposition/tests/test_dict_learning.py\n@@ -51,6 +51,57 @@ def test_dict_learning_shapes():\n     assert_equal(dico.transform(X).shape, (X.shape[0], n_components))\n \n \n+import pytest\n+import numpy as np\n+from sklearn.decomposition import SparseCoder\n+from sklearn.exceptions import ConvergenceWarning\n+\n+def test_sparse_coder_max_iter_exposure():\n+    def ricker_function(resolution, center, width):\n+        \"\"\"Discrete sub-sampled Ricker (Mexican hat) wavelet\"\"\"\n+        x = np.linspace(0, resolution - 1, resolution)\n+        x = ((2 / (np.sqrt(3 * width) * np.pi ** .25))\n+             * (1 - (x - center) ** 2 / width ** 2)\n+             * np.exp(-(x - center) ** 2 / (2 * width ** 2)))\n+        return x\n+\n+    def ricker_matrix(width, resolution, n_components):\n+        \"\"\"Dictionary of Ricker (Mexican hat) wavelets\"\"\"\n+        centers = np.linspace(0, resolution - 1, n_components)\n+        D = np.empty((n_components, resolution))\n+        for i, center in enumerate(centers):\n+            D[i] = ricker_function(resolution, center, width)\n+        D /= np.sqrt(np.sum(D ** 2, axis=1))[:, np.newaxis]\n+        return D\n+\n+    transform_algorithm = 'lasso_cd'\n+    resolution = 1024\n+    subsampling = 3\n+    n_components = resolution // subsampling\n+\n+    D_multi = np.r_[tuple(ricker_matrix(width=w, resolution=resolution,\n+                                        n_components=n_components // 5)\n+                          for w in (10, 50, 100, 500, 1000))]\n+\n+    X = np.linspace(0, resolution - 1, resolution)\n+    first_quarter = X < resolution / 4\n+    X[first_quarter] = 3.\n+    X[np.logical_not(first_quarter)] = -1.\n+    X = X.reshape(1, -1)\n+\n+    # check that the underlying model fails to converge with a low max_iter\n+    with pytest.warns(ConvergenceWarning):\n+        model = SparseCoder(D_multi, transform_algorithm=transform_algorithm,\n+                            transform_max_iter=1)\n+        model.fit_transform(X)\n+\n+    # check that the underlying model converges without warnings when max_iter is increased\n+    with pytest.warns(None) as record:\n+        model = SparseCoder(D_multi, transform_algorithm=transform_algorithm,\n+                            transform_max_iter=2000)\n+        model.fit_transform(X)\n+    assert not record.list\n+\n def test_dict_learning_overcomplete():\n     n_components = 12\n     dico = DictionaryLearning(n_components, random_state=0).fit(X)\n",
  "scikit-learn__scikit-learn-14629": "diff --git a/sklearn/tests/test_multioutput.py b/sklearn/tests/test_multioutput.py\nindex 4b401f3..bee8ea5 100644\n--- a/sklearn/tests/test_multioutput.py\n+++ b/sklearn/tests/test_multioutput.py\n@@ -137,8 +137,46 @@ def test_multi_target_sample_weights():\n     w = [2., 1.]\n     rgr_w = MultiOutputRegressor(GradientBoostingRegressor(random_state=0))\n     rgr_w.fit(Xw, yw, w)\n-\n-    # unweighted, but with repeated samples\n+import pytest\n+import numpy as np\n+from sklearn.utils._testing import assert_array_equal\n+from sklearn.datasets import make_multilabel_classification\n+from sklearn.multioutput import MultiOutputClassifier\n+from sklearn.ensemble import RandomForestClassifier\n+from sklearn.discriminant_analysis import LinearDiscriminantAnalysis\n+from sklearn.model_selection import cross_val_predict\n+\n+def test_cross_val_predict_predict_proba_multioutput():\n+    # Generate a multilabel dataset\n+    X, Y = make_multilabel_classification(n_samples=100, n_features=20, n_classes=3, n_labels=2, random_state=42)\n+    \n+    # Initialize a MultiOutputClassifier with a base estimator that supports predict_proba\n+    base_estimator = RandomForestClassifier(n_estimators=2, random_state=42)\n+    mo_clf = MultiOutputClassifier(base_estimator)\n+\n+    # Test predicting probabilities\n+    pred_proba = cross_val_predict(mo_clf, X, Y, cv=3, method='predict_proba')\n+    \n+    # Verify the prediction probabilities shape\n+    assert len(pred_proba) == Y.shape[1]\n+    for pred in pred_proba:\n+        assert pred.shape == (X.shape[0], len(np.unique(Y)))\n+\n+# Original test patch\n+@pytest.mark.parametrize(\n+    'estimator',\n+    [RandomForestClassifier(n_estimators=2),\n+     MultiOutputClassifier(RandomForestClassifier(n_estimators=2)),\n+     ClassifierChain(RandomForestClassifier(n_estimators=2))])\n+def test_multi_output_classes_(estimator):\n+    # Tests classes_ attribute of multioutput classifiers\n+    # RandomForestClassifier supports multioutput out-of-the-box\n+    estimator.fit(X, y)\n+    assert isinstance(estimator.classes_, list)\n+    assert len(estimator.classes_) == n_outputs\n+    for estimator_classes, expected_classes in zip(classes,\n+                                                   estimator.classes_):\n+        assert_array_equal(estimator_classes, expected_classes)\n     X = [[1, 2, 3], [1, 2, 3], [4, 5, 6]]\n     y = [[3.141, 2.718], [3.141, 2.718], [2.718, 3.141]]\n     rgr = MultiOutputRegressor(GradientBoostingRegressor(random_state=0))\n",
  "sphinx-doc__sphinx-9658": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 072cdc7..6977bd3 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -166,7 +166,27 @@ def test_restify_type_union_operator():\n                                          \":py:obj:`None`\")\n \n \n-def test_restify_broken_type_hints():\n+from sphinx.util.typing import restify, stringify\n+\n+def test_restify_mocked_base():\n+    \"\"\"Test restify with a mocked base class to ensure correct documentation output.\"\"\"\n+    with mock(['torch.nn']):\n+        import torch.nn as nn\n+        class MockBase(nn.Module):\n+            pass\n+\n+        assert restify(MockBase) == ':py:class:`unknown.secret.MockBase`'\n+        assert restify(nn.Module) == ':py:class:`torch.nn.Module`'\n+        \n+def test_stringify_mocked_base():\n+    \"\"\"Test stringify with a mocked base class to ensure correct documentation output.\"\"\"\n+    with mock(['torch.nn']):\n+        import torch.nn as nn\n+        class MockBase(nn.Module):\n+            pass\n+\n+        assert stringify(MockBase) == 'unknown.secret.MockBase'\n+        assert stringify(nn.Module) == 'torch.nn.Module'\n     assert restify(BrokenType) == ':py:class:`tests.test_util_typing.BrokenType`'\n \n \n",
  "sympy__sympy-13551": "diff --git a/sympy/concrete/tests/test_products.py b/sympy/concrete/tests/test_products.py\nindex 1f1aaf7..879ee73 100644\n--- a/sympy/concrete/tests/test_products.py\n+++ b/sympy/concrete/tests/test_products.py\n@@ -348,6 +348,20 @@ def test_reverse_order():\n            Product(x*y, (x, b + 1, a - 1), (y, 6, 1))\n \n \n+def test_issue_13546():\n+    from sympy import Product, Symbol, S\n+    n = Symbol('n', integer=True)\n+    k = Symbol('k', integer=True)\n+    p = Product(n + 1 / 2**k, (k, 0, n-1)).doit()\n+    assert p.subs(n, 2).doit() == S(15)/2\n+    \n+    # Additional test cases\n+    # Test for n=3\n+    assert p.subs(n, 3).doit() == S(175)/8\n+    # Test for n=4\n+    assert p.subs(n, 4).doit() == S(3675)/128\n+\n+\n def test_issue_9983():\n     n = Symbol('n', integer=True, positive=True)\n     p = Product(1 + 1/n**(S(2)/3), (n, 1, oo))\n@@ -357,4 +371,4 @@ def test_issue_9983():\n \n def test_rewrite_Sum():\n     assert Product(1 - S.Half**2/k**2, (k, 1, oo)).rewrite(Sum) == \\\n-        exp(Sum(log(1 - 1/(4*k**2)), (k, 1, oo)))\n+        exp(Sum(log(1 - 1/(4*k**2)), (k, 1, oo)))\n"
}