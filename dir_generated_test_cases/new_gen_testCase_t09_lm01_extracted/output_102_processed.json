{
  "astropy__astropy-12907": "",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..9516ed2 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,8 +1,13 @@\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n from io import StringIO\n \n from astropy.io import ascii\n+from astropy.table import QTable\n+from io import StringIO\n+import astropy.units as u\n+import numpy as np\n \n from .common import assert_almost_equal, assert_equal\n \n",
  "astropy__astropy-14365": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 9b66109..c0547f0 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -42,8 +42,57 @@ def test_get_tables_from_qdp_file(tmp_path):\n     assert table2.meta[\"comments\"][0].startswith(\"WT -- hardness\")\n     assert np.isclose(table2[\"MJD_nerr\"][0], -2.37847222222222e-05)\n \n+import pytest\n+from astropy.io.ascii.qdp import _read_table_qdp\n \n def test_roundtrip(tmp_path):\n+    example_qdp_lowercase = \"\"\"\n+    ! Swift/XRT hardness ratio of trigger: YYYY, name: ALPHA-2\n+    ! Columns are as labelled\n+    read terr 1\n+    read serr 2\n+    ! WT -- hard data\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   NO       0.212439\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   0.000000        0.000000\n+    NO NO NO NO NO\n+    ! WT -- soft data\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   0.726155        0.583890\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   2.410935        1.393592\n+    NO NO NO NO NO\n+    ! WT -- hardness ratio\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   -0.292553       -0.374935\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   0.000000        NO\n+    \"\"\"\n+\n+    path_lowercase = str(tmp_path / \"test_lowercase.qdp\")\n+\n+    with open(path_lowercase, \"w\") as fp:\n+        print(example_qdp_lowercase, file=fp)\n+\n+    with pytest.warns(AstropyUserWarning) as record_lowercase:\n+        table_lowercase = _read_table_qdp(path_lowercase, names=[\"MJD\", \"Rate\"], table_id=0)\n+\n+    for col in table_lowercase.colnames:\n+        is_masked = np.array([np.ma.is_masked(val) for val in table_lowercase[col]])\n+        if np.any(is_masked):\n+            # All NaN values are read as such.\n+            assert np.ma.is_masked(table_lowercase[col][is_masked])\n+\n+        is_nan = np.array(\n+            [(not np.ma.is_masked(val) and np.isnan(val)) for val in table_lowercase[col]]\n+        )\n+        # All non-NaN values are the same\n+        assert np.allclose(table_lowercase[col][~is_nan], table_lowercase[col][~is_nan])\n+        if np.any(is_nan):\n+            # All NaN values are read as such.\n+            assert np.isnan(table_lowercase[col][is_nan])\n+    assert np.allclose(table_lowercase[\"MJD_perr\"], [2.378472e-05, 1.1446759e-05])\n+\n+    for meta_name in [\"initial_comments\", \"comments\"]:\n+        assert meta_name in table_lowercase.meta\n     example_qdp = \"\"\"\n     ! Swift/XRT hardness ratio of trigger: XXXX, name: BUBU X-2\n     ! Columns are as labelled\n",
  "astropy__astropy-14995": "diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py\nindex fc27f69..a22c61c 100644\n--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py\n+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py\n@@ -28,7 +28,49 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n         return False\n \n \n-# Test with Data covers:\n+import numpy as np\n+from astropy.nddata import NDDataRef\n+import pytest\n+\n+def test_nddata_bitmask_arithmetic_v53():\n+    # This test case corresponds to the issue where NDDataRef masks don't propagate properly.\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_mask = NDDataRef(array, mask=mask)\n+\n+    # Multiply no mask by constant (no mask * no mask)\n+    assert nref_nomask.multiply(1.0, handle_mask=np.bitwise_or).mask is None\n+\n+    # Multiply no mask by itself (no mask * no mask)\n+    assert nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask is None\n+\n+    # Multiply mask by constant (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_mask.multiply(1.0, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # Multiply mask by itself (mask * mask)\n+    np.testing.assert_equal(\n+        nref_mask.multiply(nref_mask, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # Multiply mask by no mask (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_mask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask, mask\n+    )\n+    \n+    other_mask = np.array([[64, 1, 0], [2, 1, 0], [8, 0, 2]])\n+    nref_mask_other = NDDataRef(array, mask=other_mask)\n+    \n+    # Test combining two masked arrays with bitwise or\n+    np.testing.assert_equal(\n+        nref_mask_other.multiply(nref_mask, handle_mask=np.bitwise_or).mask,\n+        np.bitwise_or(mask, other_mask),\n+    )\n+    \n+# Existing Test with Data covers:\n # scalars, 1D, 2D and 3D\n # broadcasting between them\n @pytest.mark.filterwarnings(\"ignore:divide by zero encountered.*\")\n",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..cef6c65 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -254,6 +254,21 @@ class TestTableFunctions(FitsTestCase):\n \n         t.close()\n \n+    def test_d_exponent_replacement(self):\n+        # Test to ensure that 'E' is replaced with 'D' in the ASCII output\n+        \n+        # Setup: creating a table with a single column where the format is 'D'\n+        array = np.array([1.23e4, 5.67e8])\n+        c = fits.Column(name='col1', format='D', array=array)\n+        hdu = fits.TableHDU.from_columns([c])\n+        hdu.writeto(self.temp('test_d_exponent.fits'), overwrite=True)\n+        \n+        # Verify: reading back the file and checking the file output for 'D' exponents\n+        with open(self.temp('test_d_exponent.fits')) as f:\n+            content = f.read()\n+            assert '1.2300000000000000D+04' in content\n+            assert '5.6700000000000000D+08' in content\n+\n     def test_ascii_table(self):\n         # ASCII table\n         a = fits.open(self.data('ascii.fits'))\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..5d61d0d 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1090,6 +1090,42 @@ class OverrideSettingsTests(SimpleTestCase):\n         base_url attribute of django.core.files.storage.default_storage.\n         \"\"\"\n         self.assertEqual(default_storage.base_location, '')\n+\n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        Default FILE_UPLOAD_PERMISSIONS should be 0o644.\n+        \"\"\"\n+        with self.settings(FILE_UPLOAD_PERMISSIONS=None):\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n+\n+    def test_file_upload_permissions_memory_file(self):\n+        \"\"\"\n+        Test that MemoryUploadedFile uses the correct default permissions.\n+        \"\"\"\n+        from django.core.files.uploadedfile import SimpleUploadedFile\n+        uploaded_file = SimpleUploadedFile(\"file.txt\", b\"Test content\")\n+        \n+        with self.settings(FILE_UPLOAD_PERMISSIONS=None):\n+            uploaded_file.seek(0)\n+            saved_file_path = default_storage.save(\"test_memory_file.txt\", uploaded_file)\n+            file_permissions = os.stat(saved_file_path).st_mode & 0o777\n+            self.assertEqual(file_permissions, 0o644)\n+            default_storage.delete(saved_file_path)\n+\n+    def test_file_upload_permissions_temp_file(self):\n+        \"\"\"\n+        Test that TemporaryUploadedFile uses the correct default permissions.\n+        \"\"\"\n+        from django.core.files.uploadedfile import TemporaryUploadedFile\n+        uploaded_file = TemporaryUploadedFile(\"file.txt\", \"text/plain\", 12, \"utf-8\")\n+        uploaded_file.write(b\"Test content\")\n+        uploaded_file.seek(0)\n+        \n+        with self.settings(FILE_UPLOAD_PERMISSIONS=None):\n+            saved_file_path = default_storage.save(\"test_temp_file.txt\", uploaded_file)\n+            file_permissions = os.stat(saved_file_path).st_mode & 0o777\n+            self.assertEqual(file_permissions, 0o644)\n+            default_storage.delete(saved_file_path)\n         with self.settings(MEDIA_URL='/test_value/'):\n             self.assertEqual(default_storage.base_url, '/test_value/')\n \n",
  "django__django-10924": "",
  "django__django-11001": "",
  "django__django-11039": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex dbcbef0..05e5b5f 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -514,6 +514,23 @@ class MigrateTests(MigrationTestBase):\n             out.getvalue()\n         )\n \n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n+\n     @override_settings(INSTALLED_APPS=['migrations.migrations_test_apps.unmigrated_app'])\n     def test_showmigrations_plan_app_label_no_migrations(self):\n         out = io.StringIO()\n@@ -541,23 +558,108 @@ class MigrateTests(MigrationTestBase):\n             index_op_desc_author, index_tx_start,\n             \"Operation description (author) not found or found before transaction start\"\n         )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n         self.assertGreater(\n             index_create_table, index_op_desc_author,\n             \"CREATE TABLE not found or found before operation description (author)\"\n         )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n         self.assertGreater(\n             index_op_desc_tribble, index_create_table,\n             \"Operation description (tribble) not found or found before CREATE TABLE (author)\"\n         )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n         self.assertGreater(\n             index_op_desc_unique_together, index_op_desc_tribble,\n             \"Operation description (unique_together) not found or found before operation description (tribble)\"\n         )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n         self.assertGreater(\n             index_tx_end, index_op_desc_unique_together,\n             \"Transaction end not found or found before operation description (unique_together)\"\n         )\n \n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n+\n     @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n     def test_sqlmigrate_backwards(self):\n         \"\"\"\n@@ -582,24 +684,109 @@ class MigrateTests(MigrationTestBase):\n             index_op_desc_unique_together, index_tx_start,\n             \"Operation description (unique_together) not found or found before transaction start\"\n         )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n         self.assertGreater(\n             index_op_desc_tribble, index_op_desc_unique_together,\n             \"Operation description (tribble) not found or found before operation description (unique_together)\"\n         )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n         self.assertGreater(\n             index_op_desc_author, index_op_desc_tribble,\n             \"Operation description (author) not found or found before operation description (tribble)\"\n         )\n \n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n+\n         self.assertGreater(\n             index_drop_table, index_op_desc_author,\n             \"DROP TABLE not found or found before operation description (author)\"\n         )\n+\n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n         self.assertGreater(\n             index_tx_end, index_op_desc_unique_together,\n             \"Transaction end not found or found before DROP TABLE\"\n         )\n \n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Transaction wrappers aren't shown for databases that don't support\n+        transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command(\"sqlmigrate\", \"migrations\", \"0001\", stdout=out)\n+        \n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n+\n         # Cleanup by unmigrating everything\n         call_command(\"migrate\", \"migrations\", \"zero\", verbosity=0)\n \n",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..f1c82ab 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -75,7 +75,7 @@ class TestValidation(SimpleTestCase):\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n             \"'not a datetime' value has an invalid format. \"\n-            \"It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n         )\n \n \n@@ -84,4 +84,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..60e7128 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -248,7 +248,31 @@ class UsernameValidatorsTests(SimpleTestCase):\n                 with self.assertRaises(ValidationError):\n                     v(invalid)\n \n-    def test_ascii_validator(self):\n+    def test_newline_in_username(self):\n+        invalid_usernames = [\n+            'trailingnewline\\n',\n+            'trailingnewline\\r\\n',\n+            'leadingnewline\\nusername',\n+            'username\\nmiddle\\nnewline',\n+        ]\n+        valid_usernames = [\n+            'validusername',\n+            'another.valid+username123'\n+        ]\n+        unicode_validator = validators.UnicodeUsernameValidator()\n+        ascii_validator = validators.ASCIIUsernameValidator()\n+        \n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    unicode_validator(invalid)\n+                with self.assertRaises(ValidationError):\n+                    ascii_validator(invalid)\n+        \n+        for valid in valid_usernames:\n+            with self.subTest(valid=valid):\n+                unicode_validator(valid)\n+                ascii_validator(valid)\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n         invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n         v = validators.ASCIIUsernameValidator()\n@@ -258,4 +282,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..6e35f14 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -356,7 +356,24 @@ class HttpResponseTests(unittest.TestCase):\n         r = HttpResponse()\n         self.assertIsNone(r.get('test'))\n \n-    def test_non_string_content(self):\n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview content'))\n+        self.assertEqual(r.content, b'memoryview content')\n+\n+    def test_memoryview_alternative_assignment(self):\n+        r = HttpResponse()\n+        r.content = memoryview(b'alternative assignment')\n+        self.assertEqual(r.content, b'alternative assignment')\n+\n+    def test_nested_memoryview_content(self):\n+        mv = memoryview(b'nested memoryview')\n+        r = HttpResponse(mv)\n+        self.assertEqual(r.content, b'nested memoryview')\n+\n+    def test_memoryview_with_empty_response(self):\n+        mv = memoryview(b'')\n+        r = HttpResponse(mv)\n+        self.assertEqual(r.content, b'')\n         # Bug 16494: HttpResponse should behave consistently with non-strings\n         r = HttpResponse(12345)\n         self.assertEqual(r.content, b'12345')\n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..07a4f4c 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,9 +1,11 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n+from django.db.models.deletion import Collector\n from .models import (\n     MR, A, Avatar, Base, Child, HiddenUser, HiddenUserProfile, M, M2MFrom,\n     M2MTo, MRNull, Parent, R, RChild, S, T, User, create_a, get_default_r,\n@@ -464,7 +466,29 @@ class FastDeleteTests(TestCase):\n         # 1 to delete t, 1 to fast-delete t's m_set\n         self.assertNumQueries(2, f.delete)\n \n-    def test_fast_delete_qs(self):\n+    def test_fast_delete_instance_set_pk_none(self):\n+        u = User.objects.create()\n+        # User can be fast-deleted.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        u.delete()\n+        self.assertIsNone(u.pk)\n+\n+    def test_delete_instance_with_existing_pk(self):\n+        u = User.objects.create()\n+        pk_before_delete = u.pk\n+        u.delete()\n+        self.assertIsNone(u.pk)\n+        # Ensure that the PK is no longer in the database\n+        self.assertFalse(User.objects.filter(pk=pk_before_delete).exists())\n+\n+    def test_delete_multiple_instances_pk_none(self):\n+        u1 = User.objects.create()\n+        u2 = User.objects.create()\n+        u1.delete()\n+        u2.delete()\n+        self.assertIsNone(u1.pk)\n+        self.assertIsNone(u2.pk)\n         u1 = User.objects.create()\n         u2 = User.objects.create()\n         self.assertNumQueries(1, User.objects.filter(pk=u1.pk).delete)\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..7c8f68d 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,9 +1,11 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n from django.contrib.auth.models import Permission, User\n from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n+from django.db import IntegrityError\n \n from .models import Proxy, UserProxy\n \n@@ -140,7 +142,39 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n-    def test_user_keeps_same_permissions_after_migrating_backward(self):\n+    def test_migrate_proxy_permissions_no_integrity_error(self):\n+        \"\"\"\n+        Ensure migration does not raise IntegrityError when permissions\n+        already exist for proxy models.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='change_proxy',\n+            name='Can change proxy',\n+        )\n+        try:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        except IntegrityError as e:\n+            self.fail(f'Migration raised IntegrityError unexpectedly: {e}')\n+\n+    def test_proxy_model_permissions_correct_content_type(self):\n+        \"\"\"\n+        Verify that permissions of proxy models have correct content type after migration.\n+        \"\"\"\n+        proxy_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        # Run the migration to update permissions\n+        update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        # Check that the permissions for the Proxy model use the proxy content type\n+        permissions = Permission.objects.filter(content_type=proxy_content_type)\n+        self.assertGreater(permissions.count(), 0)\n+        for permission in permissions:\n+            self.assertEqual(permission.content_type, proxy_content_type)\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n         user.user_permissions.add(self.custom_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..b32fceb 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -10,6 +10,7 @@ import types\n import weakref\n import zipfile\n from importlib import import_module\n+import sys\n from pathlib import Path\n from unittest import mock, skip, skipIf\n \n@@ -132,8 +133,25 @@ class TestIterModulesAndFiles(SimpleTestCase):\n         del module.__spec__\n         self.assertEqual(autoreload.iter_modules_and_files((module,), frozenset()), frozenset())\n \n+class TestManagePyReloading(SimpleTestCase):\n+    def test_main_module_is_resolved(self):\n+        main_module = sys.modules['__main__']\n+        self.assertFileFound(Path(main_module.__file__))\n+\n+    def test_manage_py_changes_tracked(self):\n+        \"\"\"\n+        Ensure that modifications to manage.py trigger the autoreloader.\n+        \"\"\"\n+        manage_py_file = Path(__file__).parent / 'manage.py'\n+        manage_py_file.touch()  # Simulate a change\n+        self.assertFileFound(manage_py_file)\n \n-class TestCommonRoots(SimpleTestCase):\n+    def test_manage_py_not_initially_tracked(self):\n+        \"\"\"\n+        Ensure that manage.py is not originally part of the reloaded files under certain conditions.\n+        \"\"\"\n+        manage_py_file = Path(__file__).parent / 'manage.py'\n+        self.assertFileNotFound(manage_py_file)\n     def test_common_roots(self):\n         paths = (\n             Path('/first/second'),\n",
  "django__django-11583": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 99e5edd..1f3d89f 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -141,7 +141,22 @@ class TestIterModulesAndFiles(SimpleTestCase):\n         self.assertEqual(autoreload.iter_modules_and_files((fake_main,), frozenset()), frozenset())\n \n \n-class TestCommonRoots(SimpleTestCase):\n+class TestEmbeddedNullBytes(SimpleTestCase):\n+\n+    def test_path_with_embedded_null_bytes(self):\n+        paths_with_null_bytes = [\n+            'embedded_null_byte\\x00.py',\n+            'di\\x00rectory/embedded_null_byte.py',\n+            '\\x00start/embedded_null_byte.py',\n+            '/end/embedded_null_byte\\x00.py'\n+        ]\n+        for path in paths_with_null_bytes:\n+            with self.subTest(path=path):\n+                # Try to resolve the path and ensure it does not return any result\n+                self.assertEqual(\n+                    autoreload.iter_modules_and_files((), frozenset([path])),\n+                    frozenset()\n+                )\n     def test_common_roots(self):\n         paths = (\n             Path('/first/second'),\n",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..e99c00e 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1,5 +1,28 @@\n import importlib\n import inspect\n+class TestPathConverter404(SimpleTestCase):\n+    \"\"\"\n+    This test case checks that raising Http404 in a path converter's to_python method\n+    results in a proper technical 404 page when DEBUG is True.\n+    \"\"\"\n+    @override_settings(DEBUG=True)\n+    def test_technical_404_converter_raise_404(self):\n+        # Patch the IntConverter's to_python method to raise Http404\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+            response = self.client.get('/path-post/1/')\n+            # Check that a 404 status code is returned with a technical 404 page content\n+            self.assertContains(response, 'Page not found', status_code=404)\n+            self.assertContains(response, 'Django tried these URL patterns', status_code=404)\n+\n+    @override_settings(DEBUG=False)\n+    def test_non_technical_404_converter_raise_404(self):\n+        # Ensure that when DEBUG is False, a generic 404 page is shown\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+            response = self.client.get('/path-post/1/')\n+            # Check that a 404 status code is returned with a generic 404 page content\n+            self.assertContains(response, 'Page not found', status_code=404)\n+            self.assertNotContains(response, 'Django tried these URL patterns')\n+\n import os\n import re\n import sys\n@@ -8,6 +31,9 @@ import threading\n from io import StringIO\n from pathlib import Path\n from unittest import mock\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n+from django.test import override_settings\n \n from django.core import mail\n from django.core.files.uploadedfile import SimpleUploadedFile\n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..dd04023 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -80,6 +80,32 @@ class BinaryFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n \n @isolate_apps('invalid_models_tests')\n class CharFieldTests(SimpleTestCase):\n@@ -111,6 +137,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_negative_max_length(self):\n         class Model(models.Model):\n             field = models.CharField(max_length=-1)\n@@ -124,6 +176,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_bad_max_length_value(self):\n         class Model(models.Model):\n             field = models.CharField(max_length=\"bad\")\n@@ -137,6 +215,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_str_max_length_value(self):\n         class Model(models.Model):\n             field = models.CharField(max_length='20')\n@@ -150,6 +254,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_str_max_length_type(self):\n         class Model(models.Model):\n             field = models.CharField(max_length=True)\n@@ -163,6 +293,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_non_iterable_choices(self):\n         class Model(models.Model):\n             field = models.CharField(max_length=10, choices='bad')\n@@ -176,6 +332,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_non_iterable_choices_two_letters(self):\n         \"\"\"Two letters isn't a valid choice pair.\"\"\"\n         class Model(models.Model):\n@@ -191,6 +373,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_iterable_of_iterable_choices(self):\n         class ThingItem:\n             def __init__(self, value, display):\n@@ -272,6 +480,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_choices_named_group_bad_structure(self):\n         class Model(models.Model):\n             field = models.CharField(\n@@ -293,6 +527,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_choices_named_group_lazy(self):\n         class Model(models.Model):\n             field = models.CharField(\n@@ -317,6 +577,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     def test_bad_validators(self):\n         class Model(models.Model):\n             field = models.CharField(max_length=10, validators=[True])\n@@ -334,6 +620,32 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n     @unittest.skipUnless(connection.vendor == 'mysql',\n                          \"Test valid only for MySQL\")\n     def test_too_long_char_field_under_mysql(self):\n@@ -352,6 +664,32 @@ class CharFieldTests(SimpleTestCase):\n             )\n         ])\n \n+    def test_max_length_less_than_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (9 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_max_length_matches_longest_choice(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=9,\n+                choices=[('LongValue', 'Long Value'), ('OK', 'Okay')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n \n @isolate_apps('invalid_models_tests')\n class DateFieldTests(SimpleTestCase):\n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..07ef490 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -252,7 +252,23 @@ class WriterTests(SimpleTestCase):\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n \n-    def test_serialize_enums(self):\n+    def test_serialize_enum_with_translations_as_default(self):\n+        from django.utils.translation import gettext_lazy as _\n+        \n+        class Status(enum.Enum):\n+            GOOD = _('Good')\n+            BAD = _('Bad')\n+\n+        class TestModel(models.Model):\n+            status = models.CharField(default=Status.GOOD, max_length=128)\n+        \n+        field = models.CharField(\n+            default=Status.GOOD,\n+            choices=[(m.value, m.name) for m in Status],\n+            max_length=128\n+        )\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertEqual(string, \"models.CharField(choices=[('Good', 'GOOD'), ('Bad', 'BAD')], default='GOOD', max_length=128)\")\n         class TextEnum(enum.Enum):\n             A = 'a-value'\n             B = 'value-b'\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..2da54b4 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,9 +1,38 @@\n+\n+class ParseHttpDateTests(unittest.TestCase):\n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850_edge_cases(self, mocked_datetime):\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+        \n+        # Set up different \"current\" times for testing\n+        utcnow_1 = datetime(2019, 11, 6, 8, 49, 37)\n+        utcnow_2 = datetime(2020, 11, 6, 8, 49, 37)\n+        utcnow_3 = datetime(2048, 11, 6, 8, 49, 37)\n+\n+        test_cases = [\n+            (utcnow_1, 'Tuesday, 31-Dec-69 08:49:37 GMT', datetime(2069, 12, 31, 8, 49, 37)),\n+            (utcnow_1, 'Tuesday, 10-Nov-70 08:49:37 GMT', datetime(1970, 11, 10, 8, 49, 37)),\n+            (utcnow_1, 'Sunday, 06-Nov-94 08:49:37 GMT', datetime(1994, 11, 6, 8, 49, 37)),\n+            (utcnow_2, 'Wednesday, 31-Dec-70 08:49:37 GMT', datetime(2070, 12, 31, 8, 49, 37)),\n+            (utcnow_2, 'Friday, 31-Dec-71 08:49:37 GMT', datetime(1971, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Sunday, 31-Dec-00 08:49:37 GMT', datetime(2000, 12, 31, 8, 49, 37)),\n+            (utcnow_3, 'Friday, 31-Dec-99 08:49:37 GMT', datetime(1999, 12, 31, 8, 49, 37)),\n+        ]\n+\n+        for utcnow, rfc850str, expected_date in test_cases:\n+            with self.subTest(rfc850str=rfc850str):\n+                mocked_datetime.utcnow.return_value = utcnow\n+                parsed = parse_http_date(rfc850str)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n+\n import unittest\n from datetime import datetime\n \n from django.test import SimpleTestCase, ignore_warnings\n from django.utils.datastructures import MultiValueDict\n from django.utils.deprecation import RemovedInDjango40Warning\n+from unittest import mock\n from django.utils.http import (\n     base36_to_int, escape_leading_slashes, http_date, int_to_base36,\n     is_safe_url, is_same_domain, parse_etags, parse_http_date, quote_etag,\n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..77ff5a0 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -40,8 +40,27 @@ class Gender(models.TextChoices):\n     __empty__ = '(Undeclared)'\n \n \n+class MyChoice(models.TextChoices):\n+    FIRST_CHOICE = \"first\", _(\"The first choice, it is\")\n+    SECOND_CHOICE = \"second\", _(\"The second choice, it is\")\n+\n class ChoicesTests(SimpleTestCase):\n+    def test_textchoices_returns_correct_type(self):\n+        # Test the value type of TextChoices\n+        obj = MyChoice.FIRST_CHOICE\n+        self.assertIsInstance(obj, str)\n+        self.assertEqual(str(obj), \"first\")\n     def test_integerchoices(self):\n+        class Suit(models.IntegerChoices):\n+            DIAMOND = 1, 'Diamond'\n+            SPADE = 2, 'Spade'\n+            HEART = 3, 'Heart'\n+            CLUB = 4, 'Club'\n+\n+        # Verifying that accessing the field returns correct integer values\n+        self.assertIsInstance(Suit.DIAMOND, Suit)\n+        self.assertEqual(Suit.DIAMOND.value, 1)\n+        self.assertEqual(str(Suit.DIAMOND), \"1\")\n         self.assertEqual(Suit.choices, [(1, 'Diamond'), (2, 'Spade'), (3, 'Heart'), (4, 'Club')])\n         self.assertEqual(Suit.labels, ['Diamond', 'Spade', 'Heart', 'Club'])\n         self.assertEqual(Suit.values, [1, 2, 3, 4])\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..dc162fc 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -148,6 +148,9 @@ class ChoicesTests(SimpleTestCase):\n                 self.assertIsInstance(field.formfield(), forms.ChoiceField)\n \n \n+from django.test import SimpleTestCase\n+from django.db import models\n+\n class GetFieldDisplayTests(SimpleTestCase):\n \n     def test_choices_and_field_display(self):\n@@ -168,6 +171,24 @@ class GetFieldDisplayTests(SimpleTestCase):\n         self.assertIsInstance(val, str)\n         self.assertEqual(val, 'translated')\n \n+    def test_override_get_FIELD_display(self):\n+        \"\"\"\n+        Test that overriding the get_FIELD_display method works correctly.\n+        \"\"\"\n+        class TestModel(models.Model):\n+            # Define a field with choices\n+            status = models.CharField(max_length=10, choices=[('a', 'Alpha'), ('b', 'Beta')])\n+\n+            # Override the get_status_display method\n+            def get_status_display(self):\n+                return 'Custom Display'\n+\n+        # Create an instance of the model\n+        instance = TestModel(status='a')\n+        \n+        # Assert that the overridden method returns 'Custom Display'\n+        self.assertEqual(instance.get_status_display(), 'Custom Display')\n+\n     def test_iterator_choices(self):\n         \"\"\"\n         get_choices() works with Iterators.\n",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "",
  "django__django-12284": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex 7dc81d2..a946a70 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -1,3 +1,4 @@\n+\n import pickle\n \n from django import forms\n@@ -10,6 +11,7 @@ from .models import (\n     Bar, Choiceful, Foo, RenamedField, VerboseNameField, Whiz, WhizDelayed,\n     WhizIter, WhizIterEmpty,\n )\n+from django.test import TestCase\n \n \n class Nested:\n@@ -147,8 +149,31 @@ class ChoicesTests(SimpleTestCase):\n             with self.subTest(field=field):\n                 self.assertIsInstance(field.formfield(), forms.ChoiceField)\n \n-\n-class GetFieldDisplayTests(SimpleTestCase):\n+class InheritedChoicesGetDisplayTests(TestCase):\n+    \n+    def test_overriding_inherited_choices(self):\n+        \"\"\"\n+        Test if get_FIELD_display works correctly in inherited models\n+        overriding choices.\n+        \"\"\"\n+        class Base(models.Model):\n+            foo_choice = [('A', 'Base A'), ('B', 'Base B')]\n+            field_foo = models.CharField(max_length=254, choices=foo_choice)\n+            \n+            class Meta:\n+                abstract = True\n+        \n+        class Child(Base):\n+            foo_choice = [('A', 'Child A'), ('B', 'Child B'), ('C', 'Child C')]\n+            field_foo = models.CharField(max_length=254, choices=foo_choice)\n+        \n+        child_instance_a = Child(field_foo='A')\n+        child_instance_b = Child(field_foo='B')\n+        child_instance_c = Child(field_foo='C')\n+        \n+        self.assertEqual(child_instance_a.get_field_foo_display(), 'Child A')\n+        self.assertEqual(child_instance_b.get_field_foo_display(), 'Child B')\n+        self.assertEqual(child_instance_c.get_field_foo_display(), 'Child C')\n \n     def test_choices_and_field_display(self):\n         \"\"\"\n",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..a2ab0af 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,4 +1,6 @@\n+\n from django.core.checks import Error\n+from django.test import override_settings\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n     check_setting_languages, check_setting_languages_bidi,\n@@ -75,7 +77,21 @@ class TranslationCheckTests(SimpleTestCase):\n                     Error(msg % tag, id='translation.E003'),\n                 ])\n \n-    def test_inconsistent_language_settings(self):\n+    @override_settings(\n+        USE_I18N=True,\n+        LANGUAGES=[\n+            ('de', 'German'),\n+            ('es', 'Spanish'),\n+            ('fr', 'French'),\n+            ('ca', 'Catalan'),\n+        ],\n+    )\n+    def test_sub_language_with_base_language_available(self):\n+        \"\"\"Do not raise E004 when base language is available.\"\"\"\n+        valid_tags = ['de-at', 'fr-CA', 'ca-ES-valencia']\n+        for tag in valid_tags:\n+            with self.subTest(tag), self.settings(LANGUAGE_CODE=tag):\n+                self.assertEqual(check_language_settings_consistent(None), [])\n         msg = (\n             'You have provided a value for the LANGUAGE_CODE setting that is '\n             'not in the LANGUAGES setting.'\n",
  "django__django-12308": "",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..e35e74c 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,6 +1,8 @@\n+\n import copy\n from unittest import mock\n \n+from ..models import Object, ObjectReference\n from django.db import DEFAULT_DB_ALIAS, connection, connections\n from django.db.backends.base.creation import (\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n@@ -18,7 +20,67 @@ def get_connection_copy():\n     return test_connection\n \n \n-class TestDbSignatureTests(SimpleTestCase):\n+class TestDeserializeDbFromString(SimpleTestCase):\n+    databases = {'default'}\n+\n+    def test_circular_reference(self):\n+        # deserialize_db_from_string() handles circular references.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj_ref\": 1, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get()\n+        obj_ref = ObjectReference.objects.get()\n+        self.assertEqual(obj.obj_ref, obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n+\n+    def test_no_circular_reference(self):\n+        # Test with no circular reference to ensure normal data is also deserialized correctly.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 2,\n+                \"fields\": {\"obj_ref\": null, \"related_objects\": []}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get(pk=2)\n+        self.assertIsNone(obj.obj_ref)\n+\n+    def test_with_unrelated_objects(self):\n+        # Test deserializing unrelated objects to check transactions do not fail.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 3,\n+                \"fields\": {\"obj_ref\": null, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 2,\n+                \"fields\": {\"obj\": 3}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get(pk=3)\n+        obj_ref = ObjectReference.objects.get(pk=2)\n+        self.assertIsNone(obj.obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n     def test_default_name(self):\n         # A test db name isn't set.\n         prod_name = 'hodor'\n",
  "django__django-12497": "",
  "django__django-12700": "",
  "django__django-12708": "",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..be9fe77 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -697,7 +697,21 @@ class FastDeleteTests(TestCase):\n                 (0, {'delete.User': 0})\n             )\n \n-    def test_fast_delete_combined_relationships(self):\n+    def test_zero_objects_deleted_with_foreign_keys(self):\n+        \"\"\"\n+        Test that when zero objects are deleted for models with foreign keys,\n+        the returned dictionary should be consistent.\n+        \"\"\"\n+        result = HiddenUser.objects.filter(r__isnull=True).delete()\n+        self.assertEqual(result, (0, {'delete.HiddenUser': 0}))\n+\n+    def test_zero_objects_deleted_simple_model(self):\n+        \"\"\"\n+        Test that when zero objects are deleted for simple models without\n+        foreign keys, the returned dictionary is consistent.\n+        \"\"\"\n+        result = R.objects.filter(some_field='nonexistent').delete()\n+        self.assertEqual(result, (0, {'delete.R': 0}))\n         # The cascading fast-delete of SecondReferrer should be combined\n         # in a single DELETE WHERE referrer_id OR unique_field.\n         origin = Origin.objects.create()\n",
  "django__django-12856": "",
  "django__django-12915": "diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex 72f5bd1..8afb0d2 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -79,7 +79,51 @@ class ASGITest(SimpleTestCase):\n         # Allow response.close() to finish.\n         await communicator.wait()\n \n-    async def test_headers(self):\n+class TestASGIStaticFilesHandler(StaticFilesTestCase):\n+    async_request_factory = AsyncRequestFactory()\n+\n+    TEST_STATIC_ROOT = Path(__file__).parent / 'project' / 'static'\n+\n+    async def test_static_file_response(self):\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        scope = self.async_request_factory._base_scope(path='/static/file.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+\n+        file_path = self.TEST_STATIC_ROOT / 'file.txt'\n+        with open(file_path, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+            \n+        stat = file_path.stat()\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', str(len(test_file_contents)).encode('ascii')),\n+                (b'Content-Type', b'text/plain'),\n+                (b'Content-Disposition', b'inline; filename=\"file.txt\"'),\n+                (b'Last-Modified', http_date(stat.st_mtime).encode('ascii')),\n+            },\n+        )\n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], test_file_contents)\n+        await communicator.wait()\n+\n+    async def test_get_async_response(self):\n+        request = self.async_request_factory.get('/static/test/file.txt')\n+        handler = ASGIStaticFilesHandler(ASGIHandler())\n+        response = await handler.get_response_async(request)\n+        response.close()\n+        self.assertEqual(response.status_code, 200)\n+\n+    async def test_get_async_response_not_found(self):\n+        request = self.async_request_factory.get('/static/test/not-found.txt')\n+        handler = ASGIStaticFilesHandler(ASGIHandler())\n+        response = await handler.get_response_async(request)\n+        self.assertEqual(response.status_code, 404)\n         application = get_asgi_application()\n         communicator = ApplicationCommunicator(\n             application,\n",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..268911d 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -197,7 +197,28 @@ class TestUtilsText(SimpleTestCase):\n             ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True),\n             ('\u4f60\u597d', '\u4f60\u597d', True),\n             ('\u0130stanbul', 'istanbul', True),\n+            (' multiple---dash and  space ', 'multiple-dash-and-space', False),\n+            ('\\\\t whitespace-in-value \\\\n', 'whitespace-in-value', False),\n+            ('underscore_in-value', 'underscore_in-value', False),\n+            ('__strip__underscore-value___', 'strip__underscore-value', False),\n+            ('--strip-dash-value---', 'strip-dash-value', False),\n+            ('__strip-mixed-value---', 'strip-mixed-value', False),\n+            ('_ -strip-mixed-value _-', 'strip-mixed-value', False),\n         )\n+\n+        # Additional test cases for the new behavior to strip leading/trailing dashes and underscores\n+        new_items = (\n+            ('___This is a test ---', 'this-is-a-test', False),\n+            ('   Leading spaces and ---trailing dashes--   ', 'leading-spaces-and-trailing-dashes', False),\n+            (' ---Mixed--___Values___--- ', 'mixed-values', False),\n+            ('___only-underscores-', 'only-underscores', False),\n+            ('-_-__strip-it__-_-', 'strip-it', False),\n+            ('___Leading___Trailing---___', 'leading-trailing', False),\n+            ('Just_Normal_Text', 'just-normal-text', False),\n+            ('--Mixed--__Normal_Text__--', 'mixed-normal-text', False),\n+        )\n+        for value, output, is_unicode in new_items:\n+            self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n         for value, output, is_unicode in items:\n             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n         # interning the result may be useful, e.g. when fed to Path.\n",
  "django__django-13028": "",
  "django__django-13158": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex d5cabc8..7014f8e 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -416,7 +416,40 @@ class FormsTestCase(SimpleTestCase):\n <input type=\"text\" name=\"birthday\" id=\"birthday\" required></li>\"\"\"\n         )\n \n-    def test_various_boolean_values(self):\n+    def test_union_none_in_modelmultiplechoicefield(self):\n+        class Publication(models.Model):\n+            name = models.CharField(max_length=100)\n+\n+        class Article(models.Model):\n+            publications = models.ManyToManyField(to=Publication, blank=True, null=True)\n+\n+        class ArticleForm(forms.ModelForm):\n+            publications = forms.ModelMultipleChoiceField(\n+                queryset=Publication.objects.filter(id__lt=2).union(\n+                    Publication.objects.filter(id__gt=5)\n+                ),\n+                required=False,\n+            )\n+\n+            class Meta:\n+                model = Article\n+                fields = [\"publications\"]\n+\n+        Publication.objects.bulk_create([\n+            Publication(name=\"Pub1\"),\n+            Publication(name=\"Pub2\"),\n+            Publication(name=\"Pub3\"),\n+            Publication(name=\"Pub4\"),\n+            Publication(name=\"Pub5\"),\n+            Publication(name=\"Pub6\"),\n+            Publication(name=\"Pub7\"),\n+        ])\n+\n+        form_data = {'publications': []}\n+        form = ArticleForm(data=form_data)\n+        self.assertTrue(form.is_valid())\n+        self.assertEqual(form.cleaned_data['publications'].count(), 0,\n+                         \"Submitting an empty selection should result in no publications added.\")\n         class SignupForm(Form):\n             email = EmailField()\n             get_spam = BooleanField()\n",
  "django__django-13230": "",
  "django__django-13315": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 64b15bf..157ddf8 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2829,8 +2829,67 @@ class LimitChoicesToTests(TestCase):\n             StumpJokeForm()\n             self.assertEqual(today_callable_dict.call_count, 3)\n \n+@isolate_apps('model_forms')\n+class TestLimitChoicesToFormField(TestCase):\n+    def setUp(self):\n+        self.marley = Character.objects.create(username='Marley', last_action='2021-09-22')\n+        self.threepwood = Character.objects.create(username='Threepwood', last_action='2021-09-22')\n+\n+    def test_limit_choices_to_no_duplicates(self):\n+        joke1 = StumpJoke.objects.create(funny=True, most_recently_fooled=self.threepwood)\n+        joke2 = StumpJoke.objects.create(funny=True, most_recently_fooled=self.threepwood)\n+        joke3 = StumpJoke.objects.create(funny=True, most_recently_fooled=self.marley)\n+        StumpJoke.objects.create(funny=False, most_recently_fooled=self.marley)\n+        joke1.has_fooled_today.add(self.marley, self.threepwood)\n+        joke2.has_fooled_today.add(self.marley)\n+        joke3.has_fooled_today.add(self.marley, self.threepwood)\n+\n+        class CharacterDetails(models.Model):\n+            character1 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_fk_1',\n+            )\n+            character2 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to={\n+                    'jokes__funny': True,\n+                    'jokes_today__funny': True,\n+                },\n+                related_name='details_fk_2',\n+            )\n+            character3 = models.ManyToManyField(\n+                Character,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_m2m_1',\n+            )\n \n-class FormFieldCallbackTests(SimpleTestCase):\n+        class CharacterDetailsForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetails\n+                fields = '__all__'\n+\n+        form = CharacterDetailsForm()\n+        self.assertCountEqual(\n+            form.fields['character1'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character2'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character3'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n \n     def test_baseform_with_widgets_in_meta(self):\n         \"\"\"Regression for #13095: Using base forms with widgets defined in Meta should not raise errors.\"\"\"\n",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 536c423..d1d8868 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -11,7 +11,35 @@ from django.test.utils import isolate_apps\n \n @isolate_apps('model_inheritance')\n class AbstractInheritanceTests(SimpleTestCase):\n-    def test_single_parent(self):\n+    def test_abstract_inherited_fields(self):\n+        \"\"\"Field instances from abstract models are not equal across different children.\"\"\"\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritAbstractModel1(AbstractModel):\n+            pass\n+\n+        class InheritAbstractModel2(AbstractModel):\n+            pass\n+\n+        abstract_model_field = AbstractModel._meta.get_field('field')\n+        inherit1_model_field = InheritAbstractModel1._meta.get_field('field')\n+        inherit2_model_field = InheritAbstractModel2._meta.get_field('field')\n+\n+        self.assertNotEqual(abstract_model_field, inherit1_model_field)\n+        self.assertNotEqual(abstract_model_field, inherit2_model_field)\n+        self.assertNotEqual(inherit1_model_field, inherit2_model_field)\n+\n+        self.assertNotEqual(hash(abstract_model_field), hash(inherit1_model_field))\n+        self.assertNotEqual(hash(abstract_model_field), hash(inherit2_model_field))\n+        self.assertNotEqual(hash(inherit1_model_field), hash(inherit2_model_field))\n+\n+        self.assertLess(abstract_model_field, inherit1_model_field)\n+        self.assertLess(abstract_model_field, inherit2_model_field)\n+        self.assertLess(inherit1_model_field, inherit2_model_field)\n         class AbstractBase(models.Model):\n             name = models.CharField(max_length=30)\n \n@@ -347,4 +375,4 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('age', models.SmallIntegerField), ('concretemodel2_ptr', models.OneToOneField),\n                 ('name', models.CharField),\n             ]\n-        )\n+        )\n",
  "django__django-13447": "",
  "django__django-13551": "diff --git a/tests/auth_tests/models/__init__.py b/tests/auth_tests/models/__init__.py\nindex c6505e4..c48cecd 100644\n--- a/tests/auth_tests/models/__init__.py\n+++ b/tests/auth_tests/models/__init__.py\n@@ -1,3 +1,4 @@\n+\n from .custom_permissions import CustomPermissionsUser\n from .custom_user import (\n     CustomUser, CustomUserWithoutIsActiveField, ExtensionUser,\n@@ -8,6 +9,7 @@ from .minimal import MinimalUser\n from .no_password import NoPasswordUser\n from .proxy import Proxy, UserProxy\n from .uuid_pk import UUIDUser\n+from .with_custom_email_field import CustomEmailField\n from .with_foreign_key import CustomUserWithFK, Email\n from .with_integer_username import IntegerUsernameUser\n from .with_last_login_attr import UserWithDisabledLastLoginField\n@@ -22,4 +24,4 @@ __all__ = (\n     'IntegerUsernameUser', 'IsActiveTestUser1', 'MinimalUser',\n     'NoPasswordUser', 'Organization', 'Proxy', 'UUIDUser', 'UserProxy',\n     'UserWithDisabledLastLoginField',\n-)\n+)\n",
  "django__django-13590": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 0b4f73f..0e8ac98 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1,3 +1,6 @@\n+\n+from collections import namedtuple\n+\n import datetime\n import pickle\n import unittest\n@@ -875,6 +878,48 @@ class IterableLookupInnerExpressionsTests(TestCase):\n             ['<Company: 5020 Ltd>', '<Company: 5040 Ltd>', '<Company: 5050 Ltd>', '<Company: 5060 Ltd>'],\n             ordered=False\n         )\n+\n+    def test_range_lookup_namedtuple_edge_case(self):\n+        # A namedtuple to represent an inclusive range\n+        EmployeeRangeInclusive = namedtuple('EmployeeRangeInclusive', ['start', 'end'])\n+        emp_range = EmployeeRangeInclusive(start=20, end=60)\n+        \n+        qs = Company.objects.filter(\n+            num_employees__range=emp_range,\n+        )\n+        self.assertQuerysetEqual(\n+            qs,\n+            ['<Company: 5020 Ltd>', '<Company: 5040 Ltd>', '<Company: 5050 Ltd>', '<Company: 5060 Ltd>'],\n+            ordered=False\n+        )\n+\n+    def test_range_lookup_namedtuple_with_same_values(self):\n+        # A namedtuple with the same start and end values\n+        StaticRange = namedtuple('StaticRange', ['min', 'max'])\n+        static_range = StaticRange(min=99, max=99)\n+        \n+        qs = Company.objects.filter(\n+            num_employees__range=static_range,\n+        )\n+        self.assertQuerysetEqual(\n+            qs,\n+            ['<Company: 99300 Ltd>'],\n+            ordered=False\n+        )\n+\n+    def test_range_lookup_namedtuple_empty_result(self):\n+        # A namedtuple range where no company should be found\n+        EmptyRange = namedtuple('EmptyRange', ['low', 'high'])\n+        no_results_range = EmptyRange(low=300, high=400)\n+        \n+        qs = Company.objects.filter(\n+            num_employees__range=no_results_range,\n+        )\n+        self.assertQuerysetEqual(\n+            qs,\n+            [],\n+            ordered=False\n+        )\n         self.assertQuerysetEqual(\n             Company.objects.filter(num_employees__range=(1, 100)),\n             [\n@@ -884,6 +929,48 @@ class IterableLookupInnerExpressionsTests(TestCase):\n             ordered=False\n         )\n \n+    def test_range_lookup_namedtuple_edge_case(self):\n+        # A namedtuple to represent an inclusive range\n+        EmployeeRangeInclusive = namedtuple('EmployeeRangeInclusive', ['start', 'end'])\n+        emp_range = EmployeeRangeInclusive(start=20, end=60)\n+        \n+        qs = Company.objects.filter(\n+            num_employees__range=emp_range,\n+        )\n+        self.assertQuerysetEqual(\n+            qs,\n+            ['<Company: 5020 Ltd>', '<Company: 5040 Ltd>', '<Company: 5050 Ltd>', '<Company: 5060 Ltd>'],\n+            ordered=False\n+        )\n+\n+    def test_range_lookup_namedtuple_with_same_values(self):\n+        # A namedtuple with the same start and end values\n+        StaticRange = namedtuple('StaticRange', ['min', 'max'])\n+        static_range = StaticRange(min=99, max=99)\n+        \n+        qs = Company.objects.filter(\n+            num_employees__range=static_range,\n+        )\n+        self.assertQuerysetEqual(\n+            qs,\n+            ['<Company: 99300 Ltd>'],\n+            ordered=False\n+        )\n+\n+    def test_range_lookup_namedtuple_empty_result(self):\n+        # A namedtuple range where no company should be found\n+        EmptyRange = namedtuple('EmptyRange', ['low', 'high'])\n+        no_results_range = EmptyRange(low=300, high=400)\n+        \n+        qs = Company.objects.filter(\n+            num_employees__range=no_results_range,\n+        )\n+        self.assertQuerysetEqual(\n+            qs,\n+            [],\n+            ordered=False\n+        )\n+\n     @unittest.skipUnless(connection.vendor == 'sqlite',\n                          \"This defensive test only works on databases that don't validate parameter types\")\n     def test_complex_expressions_do_not_introduce_sql_injection_via_untrusted_string_inclusion(self):\n",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..fd37306 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -28,6 +28,7 @@ from django.core.management.commands.testserver import (\n )\n from django.db import ConnectionHandler, connection\n from django.db.migrations.recorder import MigrationRecorder\n+from unittest import mock\n from django.test import (\n     LiveServerTestCase, SimpleTestCase, TestCase, override_settings,\n )\n",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..e83f312 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,6 +1,8 @@\n+\n import sys\n import unittest\n from unittest import mock\n+import select\n \n from django import __version__\n from django.core.management import CommandError, call_command\n@@ -43,10 +45,50 @@ class ShellCommandTestCase(SimpleTestCase):\n         select.return_value = ([], [], [])\n         with self.assertRaisesMessage(CommandError, \"Couldn't import bpython interface.\"):\n             call_command('shell', interface='bpython')\n+    def test_command_option_globals(self):\n+        script_globals = 'print(\"__name__\" in globals())'\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        script_with_inline_function = (\n+            'import django\\n'\n+            'def f():\\n'\n+            '    print(django.__version__)\\n'\n+            'f()'\n+        )\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write('print(\"__name__\" in globals())')\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_inline_function_call(self, select):\n+        script_with_inline_function = (\n+            'import django\\n'\n+            'def f():\\n'\n+            '    print(django.__version__)\\n'\n+            'f()'\n+        )\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), __version__)\n \n     # [1] Patch select to prevent tests failing when when the test suite is run\n     # in parallel mode. The tests are run in a subprocess and the subprocess's\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "",
  "django__django-13757": "",
  "django__django-13768": "diff --git a/tests/dispatch/tests.py b/tests/dispatch/tests.py\nindex b1feefd..7cc71de 100644\n--- a/tests/dispatch/tests.py\n+++ b/tests/dispatch/tests.py\n@@ -161,7 +161,31 @@ class DispatcherTests(SimpleTestCase):\n         a_signal.disconnect(receiver_1_arg)\n         self.assertTestIsClean(a_signal)\n \n-    def test_send_robust_fail(self):\n+    def test_send_robust_logs_exceptions(self):\n+        def fails_with_logging(val, **kwargs):\n+            raise RuntimeError('logging test exception')\n+        \n+        a_signal.connect(fails_with_logging)\n+        \n+        # Set up logging capture\n+        with self.assertLogs('django.dispatch', level='ERROR') as log_capture:\n+            result = a_signal.send_robust(sender=self, val='test')\n+\n+        # Check if the correct exception and message were returned\n+        err = result[0][1]\n+        self.assertIsInstance(err, RuntimeError)\n+        self.assertEqual(err.args, ('logging test exception',))\n+\n+        # Validate the logging\n+        self.assertEqual(len(log_capture.records), 1)\n+        log_record = log_capture.records[0]\n+        self.assertIn('Error calling', log_record.getMessage())\n+        self.assertIsNotNone(log_record.exc_info)\n+        _, exc_value, _ = log_record.exc_info\n+        self.assertIsInstance(exc_value, RuntimeError)\n+        self.assertEqual(str(exc_value), 'logging test exception')\n+        \n+        a_signal.disconnect(fails_with_logging)\n         def fails(val, **kwargs):\n             raise ValueError('this')\n         a_signal.connect(fails)\n",
  "django__django-13925": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 6424d89..1a884bb 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -401,8 +401,67 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n             pass\n \n         self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+    def test_explicit_inherited_pk(self):\n+        class Parent(models.Model):\n+            id = models.AutoField(primary_key=True)\n \n-    def test_explicit_pk(self):\n+        class Child(Parent):\n+            pass\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n+    def test_explicit_inherited_parent_link(self):\n+        class Parent(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class Child(Parent):\n+            parent_ptr = models.OneToOneField(Parent, models.CASCADE, parent_link=True)\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n+    def test_auto_created_inherited_pk(self):\n+        class Parent(models.Model):\n+            pass\n+\n+        class Child(Parent):\n+            pass\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [\n+            Warning(\n+                \"Auto-created primary key used when not defining a primary \"\n+                \"key type, by default 'django.db.models.AutoField'.\",\n+                hint=(\n+                    \"Configure the DEFAULT_AUTO_FIELD setting or the \"\n+                    \"CheckDefaultPKConfig.default_auto_field attribute to \"\n+                    \"point to a subclass of AutoField, e.g. \"\n+                    \"'django.db.models.BigAutoField'.\"\n+                ),\n+                obj=Parent,\n+                id='models.W042',\n+            ),\n+        ])\n+\n+    def test_auto_created_inherited_parent_link(self):\n+        class Parent(models.Model):\n+            pass\n+\n+        class Child(Parent):\n+            parent_ptr = models.OneToOneField(Parent, models.CASCADE, parent_link=True)\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [\n+            Warning(\n+                \"Auto-created primary key used when not defining a primary \"\n+                \"key type, by default 'django.db.models.AutoField'.\",\n+                hint=(\n+                    \"Configure the DEFAULT_AUTO_FIELD setting or the \"\n+                    \"CheckDefaultPKConfig.default_auto_field attribute to \"\n+                    \"point to a subclass of AutoField, e.g. \"\n+                    \"'django.db.models.BigAutoField'.\"\n+                ),\n+                obj=Parent,\n+                id='models.W042',\n+            ),\n+        ])\n         class Model(models.Model):\n             id = models.BigAutoField(primary_key=True)\n \n@@ -414,4 +473,4 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n             class Meta:\n                 app_label = 'check_framework.apps.CheckPKConfig'\n \n-        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..c90b50d 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -281,8 +281,19 @@ class FormsErrorMessagesTestCase(SimpleTestCase, AssertFormErrorsMixin):\n             '</ul></li></ul>'\n         )\n \n+from django.forms import ModelChoiceField, ModelMultipleChoiceField\n+from django.test import TestCase\n+from tests.forms_tests.models import ChoiceModel\n \n-class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n+class AssertFormErrorsMixin:\n+    def assertFormErrors(self, expected_errors, clean_func, *args):\n+        try:\n+            clean_func(*args)\n+        except Exception as e:\n+            actual_errors = [str(e)]\n+            assert actual_errors == expected_errors, f\"Expected errors {expected_errors}, but got {actual_errors}\"\n+        else:\n+            assert False, \"Expected a validation error, but the clean operation succeeded.\"\n     def test_modelchoicefield(self):\n         # Create choices for the model choice field tests below.\n         ChoiceModel.objects.create(pk=1, name='a')\n@@ -298,13 +309,20 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['INVALID CHOICE'], f.clean, '4')\n \n-        # ModelMultipleChoiceField\n-        e = {\n-            'required': 'REQUIRED',\n-            'invalid_choice': '%(value)s IS INVALID CHOICE',\n-            'invalid_list': 'NOT A LIST OF VALUES',\n-        }\n-        f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n-        self.assertFormErrors(['REQUIRED'], f.clean, '')\n-        self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        # Additional test for checking invalid choice value in the error message for ModelChoiceField\n+        f = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            }\n+        )\n+        self.assertFormErrors(['\"invalid\" is not one of the available choices.'], f.clean, 'invalid')\n+\n+        # Adding a test for ModelMultipleChoiceField to verify invalid_choice value is shown\n+        f_multi = ModelMultipleChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            }\n+        )\n+        self.assertFormErrors(['\"invalid\" is not one of the available choices.'], f_multi.clean, ['invalid'])\n",
  "django__django-13964": "",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..012f4ba 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,8 +1,22 @@\n+\n from django.db.models import F, Q\n+from collections.abc import KeysView\n from django.test import SimpleTestCase\n \n \n class QTests(SimpleTestCase):\n+    def test_dict_keys_with_or_operator(self):\n+        # Test that using dict_keys with | operator does not raise TypeError\n+        q_dict_keys = Q(x__in={}.keys())\n+        self.assertEqual(q_dict_keys | Q(), q_dict_keys)\n+        self.assertEqual(Q() | q_dict_keys, q_dict_keys)\n+\n+        # Test with a non-empty dict keys\n+        test_dict = {'a': 1, 'b': 2}\n+        q_non_empty_dict_keys = Q(x__in=test_dict.keys())\n+        self.assertEqual(q_non_empty_dict_keys | Q(), q_non_empty_dict_keys)\n+        self.assertEqual(Q() | q_non_empty_dict_keys, q_non_empty_dict_keys)\n+\n     def test_combine_and_empty(self):\n         q = Q(x=1)\n         self.assertEqual(q & Q(), q)\n",
  "django__django-14017": "",
  "django__django-14155": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 0f968fa..1f7241d 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1137,7 +1137,25 @@ class ResolverMatchTests(SimpleTestCase):\n         request = HttpRequest()\n         self.assertIsNone(request.resolver_match)\n \n-    def test_repr(self):\n+    @override_settings(ROOT_URLCONF='urlpatterns_reverse.urls')\n+    def test_repr_functools_partial(self):\n+        tests = [\n+            ('partial', 'template.html'),\n+            ('partial_nested', 'nested_partial.html'),\n+            ('partial_wrapped', 'template.html'),\n+        ]\n+        for name, template_name in tests:\n+            with self.subTest(name=name):\n+                func = (\n+                    f\"functools.partial({views.empty_view!r}, \"\n+                    f\"template_name='{template_name}')\"\n+                )\n+                self.assertEqual(\n+                    repr(resolve(f'/{name}/')),\n+                    f\"ResolverMatch(func={func}, args=(), kwargs={{}}, \"\n+                    f\"url_name='{name}', app_names=[], namespaces=[], \"\n+                    f\"route='{name}/')\",\n+                )\n         self.assertEqual(\n             repr(resolve('/no_kwargs/42/37/')),\n             \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..51e2ebb 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,7 +1,11 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n from django.test.utils import isolate_apps\n+from django.db import models\n+from django.test import SimpleTestCase, override_settings\n+from django.test.utils import isolate_apps\n \n \n @isolate_apps('model_options')\n@@ -82,6 +86,28 @@ class TestDefaultPK(SimpleTestCase):\n \n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n \n+    class MyBigAutoField(models.BigAutoField):\n+        pass\n+\n+    class MySmallAutoField(models.SmallAutoField):\n+        pass\n+\n+    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class Model(models.Model):\n+            pass\n+        \n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class Model(models.Model):\n+            pass\n+        \n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n+\n     @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_m2m_default_auto_field_setting(self):\n",
  "django__django-14382": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex afeed3e..f726d7c 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2196,8 +2196,30 @@ class StartApp(AdminScriptTestCase):\n                     \"CommandError: '%s' is not a valid app directory. Please \"\n                     \"make sure the directory is a valid identifier.\" % bad_target\n                 )\n+    def test_trailing_slash_in_target_app_directory_name(self):\n+        \"\"\"\n+        Ensure `startapp` works correctly with a trailing slash in the target\n+        directory name.\n+        \"\"\"\n+        app_dir = os.path.join(self.test_dir, 'app_with_slash')\n+        os.makedirs(app_dir)\n+        # With trailing slash, should still succeed\n+        _, err = self.run_django_admin(['startapp', 'app_with_slash', os.path.join('app_with_slash', '')])\n+        self.assertNoOutput(err)\n+        self.assertTrue(os.path.exists(os.path.join(app_dir, 'apps.py')))\n \n-    def test_importable_target_name(self):\n+    def test_trailing_slash_invalid_directory_name(self):\n+        \"\"\"\n+        Ensure `startapp` raises an error with an invalid directory name\n+        containing trailing slash.\n+        \"\"\"\n+        invalid_app_dir = os.path.join(self.test_dir, '123invalid/')\n+        os.makedirs(invalid_app_dir)\n+        _, err = self.run_django_admin(['startapp', 'app', invalid_app_dir])\n+        self.assertOutput(\n+            err,\n+            \"CommandError: '123invalid' is not a valid app directory. Please make sure the directory is a valid identifier.\"\n+        )\n         _, err = self.run_django_admin(['startapp', 'app', 'os'])\n         self.assertOutput(\n             err,\n",
  "django__django-14411": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 331338c..7f72eae 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -14,6 +14,7 @@ from django.core import mail\n from django.core.exceptions import ValidationError\n from django.core.mail import EmailMultiAlternatives\n from django.forms.fields import CharField, Field, IntegerField\n+from django.forms import forms\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.utils import translation\n from django.utils.text import capfirst\n@@ -1020,6 +1021,23 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n             \"\"\"\n         )\n \n+    def test_readonly_password_hash_widget_label(self):\n+        \"\"\"\n+        Test that ReadOnlyPasswordHashWidget's label does not contain a 'for' attribute since\n+        there's no labelable element.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            hash_field = ReadOnlyPasswordHashField()\n+        \n+        bound_field = TestForm()['hash_field']\n+\n+        # The id_for_label should return None as there's no labelable element\n+        self.assertEqual(bound_field.field.widget.id_for_label('id'), None)\n+\n+        # The label tag should not include the 'for' attribute\n+        expected_label = '<label>Hash field:</label>'\n+        self.assertEqual(bound_field.label_tag(), expected_label)\n+\n     def test_readonly_field_has_changed(self):\n         field = ReadOnlyPasswordHashField()\n         self.assertIs(field.disabled, True)\n",
  "django__django-14580": "",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..7a28cf4 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -336,7 +336,10 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at most 1 form.'])\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>Please submit at most 1 form.</li></ul>'\n+        )\n \n     def test_formset_validate_min_flag(self):\n         \"\"\"\n@@ -358,7 +361,10 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, min_num=3, validate_min=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['Please submit at least 3 forms.'])\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>Please submit at least 3 forms.</li></ul>'\n+        )\n \n     def test_formset_validate_min_unchanged_forms(self):\n         \"\"\"\n@@ -982,7 +988,10 @@ class FormsFormsetTestCase(SimpleTestCase):\n         }\n         formset = FavoriteDrinksFormSet(data, prefix='drinks')\n         self.assertFalse(formset.is_valid())\n-        self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>You may only specify a drink once.</li></ul>'\n+        )\n \n     def test_formset_iteration(self):\n         \"\"\"Formset instances are iterable.\"\"\"\n",
  "django__django-14672": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex d9eaabe..23d341a 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -9,6 +9,48 @@ from .models import (\n     Invitation, Membership, Person, PersonSelfRefM2M, Recipe, RecipeIngredient,\n     Relationship, SymmetricalFriendship,\n )\n+from django.db import models\n+from django.core.checks import Error\n+\n+class ManyToManyThroughFieldsHashableTests(TestCase):\n+\n+    def test_m2m_through_fields_are_hashable_with_proxy(self):\n+        class Parent(models.Model):\n+            name = models.CharField(max_length=256)\n+\n+        class ProxyParent(Parent):\n+            class Meta:\n+                proxy = True\n+\n+        class Child(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE)\n+            many_to_many_field = models.ManyToManyField(\n+                to=Parent,\n+                through=\"ManyToManyModel\",\n+                through_fields=['child', 'parent'],\n+                related_name=\"something\"\n+            )\n+\n+        class ManyToManyModel(models.Model):\n+            parent = models.ForeignKey(Parent, on_delete=models.CASCADE, related_name='+')\n+            child = models.ForeignKey(Child, on_delete=models.CASCADE, related_name='+')\n+            second_child = models.ForeignKey(Child, on_delete=models.CASCADE, null=True, default=None)\n+\n+        try:\n+            self.assertIsNone(Child.check())\n+        finally:\n+            Parent._meta.apps.all_models['tests'].pop('parent', None)\n+            Parent._meta.apps.all_models['tests'].pop('proxyparent', None)\n+            Child._meta.apps.all_models['tests'].pop('child', None)\n+            ManyToManyModel._meta.apps.all_models['tests'].pop('manytomanymodel', None)\n+\n+    def test_reverse_inherited_m2m_with_through_fields_list_is_hashable(self):\n+        # This tests that the hash of inherited m2m fields behave correctly\n+        reverse_m2m = Person._meta.get_field('events_invited')\n+        inherited_reverse_m2m = PersonChild._meta.get_field('events_invited')\n+        self.assertEqual(reverse_m2m.through_fields, ['event', 'invitee'])\n+        self.assertEqual(inherited_reverse_m2m.through_fields, ['event', 'invitee'])\n+        self.assertEqual(hash(reverse_m2m), hash(inherited_reverse_m2m))\n \n \n class M2mThroughTests(TestCase):\n",
  "django__django-14752": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex 7ef6d86..d495fd6 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -292,6 +292,30 @@ class AutocompleteJsonViewTests(AdminViewBasicTestCase):\n             'results': [{'id': str(q.pk), 'text': q.question} for q in Question.objects.all()[PAGINATOR_SIZE:]],\n             'pagination': {'more': False},\n         })\n+    \n+    def test_custom_attributes_in_autocomplete(self):\n+        class CustomAutocompleteJsonView(AutocompleteJsonView):\n+            def serialize_result(self, obj, to_field_name):\n+                return super().serialize_result(obj, to_field_name) | {'custom_attr': obj.custom_attr}\n+        \n+        # Create test data\n+        Question.objects.create(question='Test Question 1', custom_attr='Value 1')\n+        Question.objects.create(question='Test Question 2', custom_attr='Value 2')\n+        \n+        request = self.factory.get(self.url, {'term': 'Test', **self.opts})\n+        request.user = self.superuser\n+        response = CustomAutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        \n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+\n+        expected_results = [\n+            {'id': str(q.pk), 'text': q.question, 'custom_attr': q.custom_attr}\n+            for q in Question.objects.order_by('question')  # Assuming a default ordering\n+        ]\n+\n+        self.assertEqual(data['results'], expected_results)\n+        self.assertFalse(data['pagination']['more'])\n \n \n @override_settings(ROOT_URLCONF='admin_views.urls')\n",
  "django__django-14787": "",
  "django__django-14855": "",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..350b8cc 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,10 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n+import json\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n",
  "django__django-14999": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 3e4c6c7..aa9f106 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -793,7 +793,60 @@ class OperationTests(OperationTestBase):\n         self.assertEqual(Rider.objects.count(), 2)\n         self.assertEqual(Pony._meta.get_field('riders').remote_field.through.objects.count(), 2)\n \n-    def test_rename_m2m_target_model(self):\n+    def test_rename_model_with_db_table_state_unchanged(self):\n+        app_label = 'test_rmwdbtn_state_check'\n+        project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+            migrations.CreateModel('Rider', fields=[\n+                ('id', models.AutoField(primary_key=True)),\n+            ], options={'db_table': 'rider'}),\n+        ])\n+        new_state = project_state.clone()\n+        operation = migrations.RenameModel('Rider', 'Runner')\n+        operation.state_forwards(app_label, new_state)\n+\n+        # Assert that the state is unchanged\n+        self.assertEqual(\n+            project_state.apps.get_model(app_label, 'Rider')._meta.db_table,\n+            new_state.apps.get_model(app_label, 'Rider')._meta.db_table,\n+        )\n+\n+    def test_rename_model_noop_on_foreign_key(self):\n+        if connection.vendor == 'postgresql':\n+            app_label = 'test_rmwdbtn_fk'\n+            project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+                migrations.CreateModel('Rider', fields=[\n+                    ('id', models.AutoField(primary_key=True)),\n+                ], options={'db_table': 'rider'}),\n+                migrations.CreateModel('Pony', fields=[\n+                    ('id', models.AutoField(primary_key=True)),\n+                    ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+                ]),\n+            ])\n+            new_state = project_state.clone()\n+            operation = migrations.RenameModel('Rider', 'Runner')\n+            operation.state_forwards(app_label, new_state)\n+\n+            # Ensure no queries run, especially no dropping of FK constraints\n+            with connection.schema_editor() as editor:\n+                with self.assertNumQueries(0):\n+                    operation.database_forwards(app_label, editor, project_state, new_state)\n+\n+    def test_rename_model_no_side_effects_sqlite(self):\n+        if connection.vendor == 'sqlite':\n+            app_label = 'test_rmwdbtn_sqlite_side_effects'\n+            project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+                migrations.CreateModel('Rider', fields=[\n+                    ('id', models.AutoField(primary_key=True)),\n+                ], options={'db_table': 'rider'}),\n+            ])\n+            new_state = project_state.clone()\n+            operation = migrations.RenameModel('Rider', 'Runner')\n+            operation.state_forwards(app_label, new_state)\n+\n+            # Ensure that there are no side effects\n+            with connection.schema_editor() as editor:\n+                with self.assertNumQueries(0):\n+                    operation.database_forwards(app_label, editor, project_state, new_state)\n         app_label = \"test_rename_m2m_target_model\"\n         project_state = self.apply_operations(app_label, ProjectState(), operations=[\n             migrations.CreateModel(\"Rider\", fields=[\n",
  "django__django-15061": "diff --git a/tests/forms_tests/field_tests/test_multivaluefield.py b/tests/forms_tests/field_tests/test_multivaluefield.py\nindex 53aee21..2080949 100644\n--- a/tests/forms_tests/field_tests/test_multivaluefield.py\n+++ b/tests/forms_tests/field_tests/test_multivaluefield.py\n@@ -136,6 +136,21 @@ class MultiValueFieldTest(SimpleTestCase):\n         f = MultiValueField(fields=(CharField(), CharField()), disabled=True)\n         self.assertIs(f.has_changed(['x', 'x'], ['y', 'y']), False)\n \n+    def test_multivaluefield_label_does_not_generate_for(self):\n+        class TestForm(Form):\n+            datetime = SplitDateTimeField()\n+        \n+        form = TestForm()\n+        self.assertHTMLEqual(\n+            form.as_table(),\n+            \"\"\"\n+            <tr><th><label>Datetime:</label></th><td>\n+            <input type=\"text\" name=\"datetime_0\" required id=\"id_datetime_0\">\n+            <input type=\"text\" name=\"datetime_1\" required id=\"id_datetime_1\">\n+            </td></tr>\n+            \"\"\"\n+        )\n+\n     def test_form_as_table(self):\n         form = ComplexFieldForm()\n         self.assertHTMLEqual(\n",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..dd49cdd 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -70,6 +70,9 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # IPv6.\n             ('http://[12:34::3a53]/', 'http://[12:34::3a53]/'),\n             ('http://[a34:9238::]:8080/', 'http://[a34:9238::]:8080/'),\n+            # Invalid URLs that should raise ValidationError due to ValueError in urlsplit(), see issue description.\n+            '////]@N.AN',\n+            '#@A.bO',\n         ]\n         for url, expected in tests:\n             with self.subTest(url=url):\n@@ -100,6 +103,9 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # even on domains that don't fail the domain label length check in\n             # the regex.\n             'http://%s' % (\"X\" * 200,),\n+            # Invalid URLs that should raise ValidationError due to ValueError in urlsplit(), see issue description.\n+            '////]@N.AN',\n+            '#@A.bO',\n         ]\n         msg = \"'Enter a valid URL.'\"\n         for value in tests:\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..d989b4c 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -262,7 +262,36 @@ class NonAggregateAnnotationTestCase(TestCase):\n             {'under_40': True, 'count_id': 6},\n         ])\n \n-    def test_aggregate_over_annotation(self):\n+    def test_expressionwrapper_with_negated_q_on_empty_list(self):\n+        # Test case focused on the ExpressionWrapper with ~Q(pk__in=[]) - the problematic case\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        )\n+        # Expect that all books should be selected, as ~Q(pk__in=[]) should imply \"not an empty list\"\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+        # Verify similar execution with an empty queryset instead of an empty list\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=Book.objects.none()), output_field=BooleanField()),\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_combined_expression_annotation_with_negated_q(self):\n+        # Combined annotation example with negated ~Q(pk__in=[])\n+        qs = Book.objects.filter(isbn='159059725').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in qs], [1])\n+\n+    def test_aggregate_over_expressionwrapper_negated_q(self):\n+        # Aggregating over an annotation using ExpressionWrapper with a negated Q expression.\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+        ).aggregate(total_selected=Sum('selected'))\n+        self.assertEqual(qs['total_selected'], Book.objects.count())\n         agg = Author.objects.annotate(other_age=F('age')).aggregate(otherage_sum=Sum('other_age'))\n         other_agg = Author.objects.aggregate(age_sum=Sum('age'))\n         self.assertEqual(agg['otherage_sum'], other_agg['age_sum'])\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..0d87416 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,6 @@\n+\n+from django.utils.safestring import SafeData, mark_safe\n+\n import json\n import random\n \n@@ -163,7 +166,25 @@ class CookieTests(BaseTests, SimpleTestCase):\n         decoded_messages = json.loads(value, cls=MessageDecoder)\n         self.assertEqual(messages, decoded_messages)\n \n-    def test_safedata(self):\n+    def test_extra_tags_serialization(self):\n+        \"\"\"\n+        Test that extra_tags attribute is correctly preserved when\n+        it is serialized and deserialized.\n+        \"\"\"\n+        storage = self.get_storage()\n+        \n+        cases = [\n+            ('message', '', ''),  # extra_tags is an empty string\n+            ('message', None, None),  # extra_tags is None\n+            ('message', 'some tags', 'some tags')  # extra_tags is 'some tags'\n+        ]\n+        \n+        for message, input_tags, expected_tags in cases:\n+            with self.subTest(extra_tags=input_tags):\n+                msg = Message(constants.DEBUG, message, extra_tags=input_tags)\n+                encoded = storage._encode(msg)\n+                decoded = storage._decode(encoded)\n+                self.assertEqual(decoded.extra_tags, expected_tags)\n         \"\"\"\n         A message containing SafeData is keeping its safe status when\n         retrieved from the message storage.\n",
  "django__django-15388": "",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..6872f89 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -184,6 +185,13 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"\n+        Test that was_modified_since handles an empty If-Modified-Since header correctly.\n+        \"\"\"\n+        # Assuming mtime is in the past, an empty header should mean no modification\n+        self.assertTrue(was_modified_since(header=\"\", mtime=1))\n+\n     def test_was_modified_since_fp(self):\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..eadbe99 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,5 +1,7 @@\n+\n import os\n from io import StringIO\n+from argparse import ArgumentDefaultsHelpFormatter\n from unittest import mock\n \n from admin_scripts.tests import AdminScriptTestCase\n@@ -411,12 +413,30 @@ class CommandTests(SimpleTestCase):\n         parser = BaseCommand().create_parser(\"prog_name\", \"subcommand\", epilog=epilog)\n         self.assertEqual(parser.epilog, epilog)\n \n-    def test_outputwrapper_flush(self):\n-        out = StringIO()\n-        with mock.patch.object(out, \"flush\") as mocked_flush:\n-            management.call_command(\"outputwrapper\", stdout=out)\n-        self.assertIn(\"Working...\", out.getvalue())\n-        self.assertIs(mocked_flush.called, True)\n+    def test_command_help_format(self):\n+        \"\"\"Test that the custom help text retains the expected format.\"\"\"\n+        class TestCommand(BaseCommand):\n+            help = \"\"\"\n+            Import a contract from tzkt.\n+            Example usage:\n+                ./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\n+            \"\"\"\n+            def add_arguments(self, parser):\n+                parser.add_argument('blockchain')\n+                parser.add_argument('target')\n+        \n+        # Create a parser using TestCommand and ArgumentDefaultsHelpFormatter\n+        test_cmd = TestCommand()\n+        parser = test_cmd.create_parser(\"manage.py\", \"tzkt_import\", formatter_class=ArgumentDefaultsHelpFormatter)\n+        expected_help_format = \"Import a contract from tzkt.\\nExample usage:\\n    ./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\"\n+        \n+        # Fetch the help message from the parser\n+        with mock.patch('sys.stdout', new=StringIO()) as output:\n+            parser.print_help()\n+            help_output = output.getvalue()\n+        \n+        # Check if the expected help format is part of the output\n+        self.assertIn(expected_help_format, help_output)\n \n \n class CommandRunTests(AdminScriptTestCase):\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..eaf7498 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,8 +1,10 @@\n+\n import os\n from datetime import datetime\n \n from django.test import SimpleTestCase\n from django.utils.functional import lazystr\n+from django.core.serializers.json import DjangoJSONEncoder\n from django.utils.html import (\n     conditional_escape,\n     escape,\n@@ -217,7 +219,42 @@ class TestUtilsHtml(SimpleTestCase):\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n         )\n \n-    def test_smart_urlquote(self):\n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"hello\": \"world\"}'\n+\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"hello\": \"world\"}</script>',\n+        )\n+    \n+    def test_json_script_default_encoder(self):\n+        # Test with the default encoder to ensure backward compatibility \n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}),\n+            '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n+        )\n+\n+    def test_json_script_with_custom_encoder_and_data(self):\n+        class CustomUpperDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return super().encode({k.upper(): v.upper() for k, v in o.items()})\n+\n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}, encoder=CustomUpperDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"KEY\": \"VALUE\"}</script>',\n+        )\n+\n+    def test_json_script_with_element_id_and_custom_encoder(self):\n+        class CustomPrefixDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"prefix\": ' + super().encode(o) + '}'\n+\n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}, element_id=\"my_id\", encoder=CustomPrefixDjangoJSONEncoder),\n+            '<script id=\"my_id\" type=\"application/json\">{\"prefix\": {\"key\": \"value\"}}</script>',\n+        )\n         items = (\n             (\"http://\u00f6\u00e4\u00fc.com/\", \"http://xn--4ca9at.com/\"),\n             (\"http://\u00f6\u00e4\u00fc.com/\u00f6\u00e4\u00fc/\", \"http://xn--4ca9at.com/%C3%B6%C3%A4%C3%BC/\"),\n",
  "django__django-15790": "diff --git a/tests/check_framework/test_templates.py b/tests/check_framework/test_templates.py\nindex 72e6cfe..646c230 100644\n--- a/tests/check_framework/test_templates.py\n+++ b/tests/check_framework/test_templates.py\n@@ -130,6 +130,54 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n             },\n         }\n \n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+        ]\n+    )\n+    def test_no_conflict_when_single_template_library_defined(self):\n+        \"\"\"Test no error when only one instance of a template library is defined.\"\"\"\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"unique_tags\", \"same_tags_app_1.templatetags.unique_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+            \"check_framework.template_test_apps.same_tags_app_2\",\n+        ]\n+    )\n+    def test_error_with_duplicate_template_libraries_in_templates_settings(self):\n+        \"\"\"Test that an error is reported when TEMPLATES setting explicitly lists duplicate template tags libraries.\"\"\"\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"dup_tags\", \"same_tags_app_1.templatetags.dup_tags\"\n+                ),\n+                self.get_settings(\n+                    \"dup_tags\", \"same_tags_app_2.templatetags.dup_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [\n+                    Error(\n+                        E003.msg.format(\n+                            \"'dup_tags'\",\n+                            \"'check_framework.template_test_apps.same_tags_app_1.templatetags.dup_tags', \"\n+                            \"'check_framework.template_test_apps.same_tags_app_2.templatetags.dup_tags'\",\n+                        ),\n+                        id=E003.id,\n+                    )\n+                ],\n+            )\n+\n     @override_settings(\n         INSTALLED_APPS=[\n             \"check_framework.template_test_apps.same_tags_app_1\",\n@@ -158,6 +206,54 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n                 [self.error_same_tags],\n             )\n \n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+        ]\n+    )\n+    def test_no_conflict_when_single_template_library_defined(self):\n+        \"\"\"Test no error when only one instance of a template library is defined.\"\"\"\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"unique_tags\", \"same_tags_app_1.templatetags.unique_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+            \"check_framework.template_test_apps.same_tags_app_2\",\n+        ]\n+    )\n+    def test_error_with_duplicate_template_libraries_in_templates_settings(self):\n+        \"\"\"Test that an error is reported when TEMPLATES setting explicitly lists duplicate template tags libraries.\"\"\"\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"dup_tags\", \"same_tags_app_1.templatetags.dup_tags\"\n+                ),\n+                self.get_settings(\n+                    \"dup_tags\", \"same_tags_app_2.templatetags.dup_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [\n+                    Error(\n+                        E003.msg.format(\n+                            \"'dup_tags'\",\n+                            \"'check_framework.template_test_apps.same_tags_app_1.templatetags.dup_tags', \"\n+                            \"'check_framework.template_test_apps.same_tags_app_2.templatetags.dup_tags'\",\n+                        ),\n+                        id=E003.id,\n+                    )\n+                ],\n+            )\n+\n     @override_settings(\n         INSTALLED_APPS=[\"check_framework.template_test_apps.same_tags_app_1\"]\n     )\n@@ -199,6 +295,54 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n         ):\n             self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n \n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+        ]\n+    )\n+    def test_no_conflict_when_single_template_library_defined(self):\n+        \"\"\"Test no error when only one instance of a template library is defined.\"\"\"\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"unique_tags\", \"same_tags_app_1.templatetags.unique_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+            \"check_framework.template_test_apps.same_tags_app_2\",\n+        ]\n+    )\n+    def test_error_with_duplicate_template_libraries_in_templates_settings(self):\n+        \"\"\"Test that an error is reported when TEMPLATES setting explicitly lists duplicate template tags libraries.\"\"\"\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"dup_tags\", \"same_tags_app_1.templatetags.dup_tags\"\n+                ),\n+                self.get_settings(\n+                    \"dup_tags\", \"same_tags_app_2.templatetags.dup_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [\n+                    Error(\n+                        E003.msg.format(\n+                            \"'dup_tags'\",\n+                            \"'check_framework.template_test_apps.same_tags_app_1.templatetags.dup_tags', \"\n+                            \"'check_framework.template_test_apps.same_tags_app_2.templatetags.dup_tags'\",\n+                        ),\n+                        id=E003.id,\n+                    )\n+                ],\n+            )\n+\n     @override_settings(\n         INSTALLED_APPS=[\n             \"check_framework.template_test_apps.same_tags_app_1\",\n@@ -206,4 +350,4 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n         ]\n     )\n     def test_template_tags_with_different_name(self):\n-        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..ddc9a97 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -398,6 +398,21 @@ class ProxyModelTests(TestCase):\n     def test_eq(self):\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n+    def test_select_related_only_proxy(self):\n+        \"\"\"\n+        Test that using select_related and only with a proxy model and its fields \n+        does not raise an error.\n+        \"\"\"\n+        # Setup test data\n+        custom_obj = ProxyCustomModel.objects.create(name=\"Custom Name\")\n+        another_obj = AnotherModel.objects.create(custom=custom_obj)\n+        \n+        # Perform the query\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+\n+        # Since we're checking for crashes, we assert that fetching the object works\n+        self.assertEqual(qs.get(), another_obj)\n+\n \n @override_settings(ROOT_URLCONF=\"proxy_models.urls\")\n class ProxyModelAdminTests(TestCase):\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..fd54384 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -151,6 +151,12 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             ),\n         )\n \n+    def test_parameters_order(self):\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"SELECT * FROM some_table;\"]),\n+            ([\"psql\", \"-c\", \"SELECT * FROM some_table;\", \"dbname\"], None),\n+        )\n+        \n     def test_parameters(self):\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n@@ -183,4 +189,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 44ea946..b43e4f4 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1901,7 +1901,30 @@ class AllValidTests(SimpleTestCase):\n class DeprecationTests(SimpleTestCase):\n     def test_warning(self):\n         from django.forms.utils import DEFAULT_TEMPLATE_DEPRECATION_MSG\n-\n+        from django.test import SimpleTestCase\n+        from django.forms import formset_factory, BaseFormSet\n+        from django.core.exceptions import RemovedInDjango50Warning\n+        from .forms import Choice  # Assuming Choice is defined in forms.py within forms_tests directory\n+        from django.test.utils import isolate_lru_cache, override_settings\n+        from django.forms.renderers import get_default_renderer\n+\n+        \n+        class TestManagementFormDeprecation(SimpleTestCase):\n+            def test_no_management_form_warning(self):\n+                \"\"\"\n+                Ensure no deprecation warning is raised for management forms of formsets.\n+                \"\"\"\n+                with isolate_lru_cache(get_default_renderer), override_settings(\n+                    FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n+                ):\n+                    ChoiceFormSet = formset_factory(Choice, formset=BaseFormSet)\n+                    formset = ChoiceFormSet()\n+                    # Rendering management form should not raise deprecation warning\n+                    with self.assertRaisesMessage(RemovedInDjango50Warning, DEFAULT_TEMPLATE_DEPRECATION_MSG):\n+                        render_str = str(formset.management_form)\n+                    # Ensure that no warning is raised by checking the rendered string \n+                    self.assertIn('input', render_str)\n+        \n         with isolate_lru_cache(get_default_renderer), self.settings(\n             FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n         ), self.assertRaisesMessage(\n@@ -1909,4 +1932,4 @@ class DeprecationTests(SimpleTestCase):\n         ):\n             ChoiceFormSet = formset_factory(Choice)\n             formset = ChoiceFormSet()\n-            str(formset)\n+            str(formset)\n",
  "django__django-16041": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex a34f3d3..ed4764a 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -173,6 +173,24 @@ class FormsFormsetTestCase(SimpleTestCase):\n             self.assertTrue(hasattr(form, \"custom_kwarg\"))\n             self.assertEqual(form.custom_kwarg, i)\n \n+    def test_empty_permitted_ignored_empty_form_true(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        formset = FormSet(form_kwargs={\"empty_permitted\": True})\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n+\n+    def test_empty_permitted_ignored_empty_form_false(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        formset = FormSet(form_kwargs={\"empty_permitted\": False})\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n+\n+    def test_empty_form_access_without_crash(self):\n+        MyModelFormSet = modelformset_factory(MyModel, fields=['a_field'])\n+        formset = MyModelFormSet(queryset=MyModel.objects.none(), form_kwargs={\"empty_permitted\": True})\n+        try:\n+            empty_form_html = str(formset.empty_form)\n+        except KeyError:\n+            self.fail(\"Rendering formset.empty_form raised KeyError unexpectedly!\")\n+\n     def test_form_kwargs_empty_form(self):\n         FormSet = formset_factory(CustomKwargForm)\n         formset = FormSet(form_kwargs={\"custom_kwarg\": 1})\n",
  "django__django-16046": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 41aae41..bf9a929 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -1,3 +1,4 @@\n+\n from decimal import Decimal\n from sys import float_info\n \n@@ -160,7 +161,18 @@ class TestNumberFormat(SimpleTestCase):\n                     nformat(Decimal(value), \".\", decimal_pos), expected_value\n                 )\n \n-    def test_decimal_subclass(self):\n+    def test_empty(self):\n+        # Test for empty string\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        # Test for None\n+        self.assertEqual(nformat(None, \".\"), \"None\")\n+        # Additional test cases\n+        # Test for Zero\n+        self.assertEqual(nformat(0, \".\"), \"0\")\n+        # Test for negative zero\n+        self.assertEqual(nformat(-0.0, \".\"), \"0\")\n+        # Test for negative decimal\n+        self.assertEqual(nformat(-1234.56, \".\", decimal_pos=1), \"-1234.5\")\n         class EuroDecimal(Decimal):\n             \"\"\"\n             Wrapper for Decimal which prefixes each amount with the \u20ac symbol.\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..4d4ae47 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -21,7 +22,9 @@ from django.core.exceptions import ValidationError\n from django.core.mail import EmailMultiAlternatives\n from django.forms import forms\n from django.forms.fields import CharField, Field, IntegerField\n+import urllib.parse\n from django.test import SimpleTestCase, TestCase, override_settings\n+from django.urls import reverse\n from django.utils import translation\n from django.utils.text import capfirst\n from django.utils.translation import gettext as _\n@@ -892,6 +895,37 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # value to render correctly\n         self.assertEqual(form.initial[\"password\"], form[\"password\"].value())\n \n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field_with_uuid(self):\n+        # Ensure that the URL for password reset is correctly generated when using a to_field.\n+        # Create a user instance\n+        user = User.objects.get(username=\"testclient\")\n+        # Instantiate the UserChangeForm with the user instance\n+        form = UserChangeForm(data={}, instance=user)\n+        # Extract the password help text with the link\n+        password_help_text = form.fields[\"password\"].help_text\n+        \n+        # Using regular expression to extract the href link from the help text\n+        matches = re.search(r'<a href=\"(.*?)\">', password_help_text)\n+        \n+        # Generate the expected admin URL for changing the user\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.uuid,)  # Retrieving instance based on uuid instead of pk\n+        )\n+        \n+        # Using the urljoin to make sure the formatted URL is correctly joined\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+        \n+        # The expected password change URL should still use the pk\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        \n+        # Comparing the joined URL and the expected password change URL\n+        self.assertEqual(joined_url, pw_change_url)\n+\n     def test_custom_form(self):\n         class CustomUserChangeForm(UserChangeForm):\n             class Meta(UserChangeForm.Meta):\n",
  "django__django-16255": "diff --git a/tests/sitemaps_tests/test_http.py b/tests/sitemaps_tests/test_http.py\nindex 1469efd..5c5d284 100644\n--- a/tests/sitemaps_tests/test_http.py\n+++ b/tests/sitemaps_tests/test_http.py\n@@ -507,8 +507,33 @@ class HTTPSitemapTests(SitemapTestsBase):\n         self.assertXMLEqual(index_response.content.decode(), expected_content_index)\n         self.assertXMLEqual(sitemap_response.content.decode(), expected_content_sitemap)\n \n+from django.contrib.sitemaps import Sitemap\n+from django.urls import path\n+from django.test import TestCase, override_settings\n+\n+class CallableLastmodNoItemsSitemap(Sitemap):\n+    location = \"/location/\"\n+\n+    def items(self):\n+        return []  # No items\n+\n+    def lastmod(self, obj):\n+        return obj.lastmod\n \n-# RemovedInDjango50Warning\n+class SitemapTestsBase(TestCase):\n+    def test_callable_sitemap_no_items_should_not_raise_error(self):\n+        \"\"\"\n+        Test a sitemap with callable lastmod and no items does not raise ValueError.\n+        \"\"\"\n+        response = self.client.get(\"/callable-lastmod-no-items/index.xml\")\n+        self.assertNotIn(\"Last-Modified\", response)\n+        expected_content_index = (\n+            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n'\n+            '<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\\n'\n+            '<sitemap><loc>http://example.com/simple/sitemap-callable-lastmod.xml</loc></sitemap>\\n'\n+            '</sitemapindex>'\n+        )\n+        self.assertXMLEqual(response.content.decode(), expected_content_index)\n class DeprecatedTests(SitemapTestsBase):\n     @override_settings(\n         TEMPLATES=[\n",
  "django__django-16379": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 014d28a..a87e379 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1,6 +1,11 @@\n+\n # Unit tests for cache framework\n # Uses whatever cache backend is set in the test settings file.\n-import copy\n+import unittest\n+from unittest import mock\n+from django.core.cache import caches\n+\n+cache = caches['default'] # Assuming 'default' is configured for FileBasedCache\n import io\n import os\n import pickle\n@@ -1755,7 +1760,37 @@ class FileBasedCacheTests(BaseCacheTests, TestCase):\n             with self.assertRaises(OSError):\n                 cache.get(\"foo\")\n \n-    def test_empty_cache_file_considered_expired(self):\n+    def test_has_key_race_handling(self):\n+        self.assertIs(cache.add(\"key\", \"value\"), True)\n+        with mock.patch(\"builtins.open\", side_effect=FileNotFoundError) as mocked_open:\n+            self.assertIs(cache.has_key(\"key\"), False)\n+            mocked_open.assert_called_once()\n+\n+    def test_concurrent_access_race_condition(self):\n+        # This test will simulate concurrent access to potentially reproduce the race condition.\n+        from threading import Thread\n+\n+        def access_cache():\n+            # Simulate concurrent access to has_key()\n+            try:\n+                cache.has_key(\"key\")\n+            except FileNotFoundError:\n+                passed = True\n+            else:\n+                passed = False\n+            return passed\n+\n+        # Add the key to the cache\n+        self.assertIs(cache.add(\"key\", \"value\"), True)\n+\n+        # Launch multiple threads to access the has_key method\n+        threads = [Thread(target=access_cache) for _ in range(10)]\n+\n+        for thread in threads:\n+            thread.start()\n+\n+        for thread in threads:\n+            thread.join()\n         cache_file = cache._key_to_file(\"foo\")\n         with open(cache_file, \"wb\") as fh:\n             fh.write(b\"\")\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..e06352b 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -11,6 +12,8 @@ from django.urls import reverse\n from .admin import ArticleAdmin, site\n from .models import Article, Question\n from .tests import AdminViewBasicTestCase\n+from django.contrib.auth import get_permission_codename\n+from .tests import get_perm\n \n \n class AdminTemplateTagsTest(AdminViewBasicTestCase):\n",
  "django__django-16595": "diff --git a/tests/migrations/test_optimizer.py b/tests/migrations/test_optimizer.py\nindex 3979e76..d338a84 100644\n--- a/tests/migrations/test_optimizer.py\n+++ b/tests/migrations/test_optimizer.py\n@@ -235,8 +235,36 @@ class OptimizerTests(SimpleTestCase):\n                 alter_bar,\n             ],\n         )\n-\n-    def test_alter_alter_table_model(self):\n+    \n+    def test_alter_alter_field_operations(self):\n+        \"\"\"\n+        Test that multiple AlterField operations on the same field\n+        are reduced to the last AlterField operation.\n+        \"\"\"\n+        field_1 = migrations.AlterField(\n+            model_name=\"book\",\n+            name=\"title\",\n+            field=models.CharField(max_length=256, null=True),\n+        )\n+        field_2 = migrations.AlterField(\n+            model_name=\"book\",\n+            name=\"title\",\n+            field=models.CharField(max_length=128, null=True),\n+        )\n+        field_3 = migrations.AlterField(\n+            model_name=\"book\",\n+            name=\"title\",\n+            field=models.CharField(max_length=128, null=True, help_text=\"help\"),\n+        )\n+        field_4 = migrations.AlterField(\n+            model_name=\"book\",\n+            name=\"title\",\n+            field=models.CharField(max_length=128, null=True, help_text=\"help\", default=None),\n+        )\n+        self.assertOptimizesTo(\n+            [field_1, field_2, field_3, field_4],\n+            [field_4],\n+        )\n         self._test_alter_alter_model(\n             migrations.AlterModelTable(\"Foo\", \"a\"),\n             migrations.AlterModelTable(\"Foo\", \"b\"),\n",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..6fa29fc 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,3 +1,4 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n@@ -26,7 +27,15 @@ class JoinTests(SimpleTestCase):\n         output = self.engine.render_to_string(\"join04\", {\"a\": [\"alpha\", \"beta & me\"]})\n         self.assertEqual(output, \"alpha &amp; beta & me\")\n \n-    # Joining with unsafe joiners doesn't result in unsafe strings.\n+    # Test case to ensure `join` filter does not escape when autoescape is off.\n+    @setup({\"join_autoescape_off\": '{% autoescape off %}{{ a|join:var }}{% endautoescape %}'})\n+    def test_join_autoescape_off(self):\n+        output = self.engine.render_to_string(\n+            \"join_autoescape_off\",\n+            {\"a\": [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"],\n+             \"var\": \"<br/>\"}\n+        )\n+        self.assertEqual(output, \"<p>Hello World!</p><br/>beta & me<br/><script>Hi!</script>\")\n     @setup({\"join05\": \"{{ a|join:var }}\"})\n     def test_join05(self):\n         output = self.engine.render_to_string(\n@@ -78,4 +87,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..47959a5 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -597,18 +597,117 @@ class BulkCreateTests(TestCase):\n             ],\n         )\n \n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        \"\"\"\n+        Ensure that IDs are returned when using bulk_create with update_conflicts=True.\n+        \"\"\"\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"a\"),\n+            TwoFields(f1=2, f2=2, name=\"b\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"c\"),\n+            TwoFields(f1=2, f2=2, name=\"d\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"c\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n+            ],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_two_fields_unique_fields_first(self):\n         self._test_update_conflicts_two_fields([\"f1\"])\n \n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        \"\"\"\n+        Ensure that IDs are returned when using bulk_create with update_conflicts=True.\n+        \"\"\"\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"a\"),\n+            TwoFields(f1=2, f2=2, name=\"b\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"c\"),\n+            TwoFields(f1=2, f2=2, name=\"d\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"c\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n+            ],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_two_fields_unique_fields_second(self):\n         self._test_update_conflicts_two_fields([\"f2\"])\n \n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        \"\"\"\n+        Ensure that IDs are returned when using bulk_create with update_conflicts=True.\n+        \"\"\"\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"a\"),\n+            TwoFields(f1=2, f2=2, name=\"b\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"c\"),\n+            TwoFields(f1=2, f2=2, name=\"d\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"c\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n+            ],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n@@ -642,6 +741,39 @@ class BulkCreateTests(TestCase):\n             ],\n         )\n \n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        \"\"\"\n+        Ensure that IDs are returned when using bulk_create with update_conflicts=True.\n+        \"\"\"\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"a\"),\n+            TwoFields(f1=2, f2=2, name=\"b\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"c\"),\n+            TwoFields(f1=2, f2=2, name=\"d\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"c\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n+            ],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n@@ -710,12 +842,78 @@ class BulkCreateTests(TestCase):\n             ],\n         )\n \n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        \"\"\"\n+        Ensure that IDs are returned when using bulk_create with update_conflicts=True.\n+        \"\"\"\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"a\"),\n+            TwoFields(f1=2, f2=2, name=\"b\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"c\"),\n+            TwoFields(f1=2, f2=2, name=\"d\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"c\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n+            ],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_unique_two_fields_unique_fields_both(self):\n         self._test_update_conflicts_unique_two_fields([\"iso_two_letter\", \"name\"])\n \n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        \"\"\"\n+        Ensure that IDs are returned when using bulk_create with update_conflicts=True.\n+        \"\"\"\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"a\"),\n+            TwoFields(f1=2, f2=2, name=\"b\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"c\"),\n+            TwoFields(f1=2, f2=2, name=\"d\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"c\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n+            ],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n@@ -776,6 +974,39 @@ class BulkCreateTests(TestCase):\n             ],\n         )\n \n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        \"\"\"\n+        Ensure that IDs are returned when using bulk_create with update_conflicts=True.\n+        \"\"\"\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"a\"),\n+            TwoFields(f1=2, f2=2, name=\"b\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"c\"),\n+            TwoFields(f1=2, f2=2, name=\"d\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"c\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n+            ],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n@@ -787,6 +1018,39 @@ class BulkCreateTests(TestCase):\n     def test_update_conflicts_no_unique_fields(self):\n         self._test_update_conflicts([])\n \n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        \"\"\"\n+        Ensure that IDs are returned when using bulk_create with update_conflicts=True.\n+        \"\"\"\n+        initial_objects = [\n+            TwoFields(f1=1, f2=1, name=\"a\"),\n+            TwoFields(f1=2, f2=2, name=\"b\"),\n+        ]\n+        TwoFields.objects.bulk_create(initial_objects)\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"c\"),\n+            TwoFields(f1=2, f2=2, name=\"d\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\", \"f2\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+        self.assertCountEqual(\n+            TwoFields.objects.values(\"f1\", \"f2\", \"name\"),\n+            [\n+                {\"f1\": 1, \"f2\": 1, \"name\": \"c\"},\n+                {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n+            ],\n+        )\n+        if connection.features.can_return_rows_from_bulk_insert:\n+            for instance in results:\n+                self.assertIsNotNone(instance.pk)\n+\n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n@@ -816,4 +1080,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..62a71d1 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -197,6 +197,29 @@ class OperationWriterTests(SimpleTestCase):\n             \"),\",\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -255,12 +278,58 @@ class WriterTests(SimpleTestCase):\n             decimal.Decimal(\"1.3\"), (\"Decimal('1.3')\", {\"from decimal import Decimal\"})\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n         self.assertSerializedEqual(Money(\"1.3\"))\n         self.assertSerializedResultEqual(\n             Money(\"1.3\"),\n             (\"migrations.test_writer.Money('1.3')\", {\"import migrations.test_writer\"}),\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -296,6 +365,29 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set()),\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r\"^foo$\")\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -306,6 +398,29 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\n@@ -313,6 +428,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\n@@ -320,10 +458,56 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -331,11 +515,57 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(\n             default=TextEnum.B, choices=[(m.value, m) for m in TextEnum]\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -344,10 +574,56 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -356,9 +632,55 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         field = models.CharField(\n             default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum]\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -367,9 +689,55 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         field = models.IntegerField(\n             default=IntEnum.A, choices=[(m.value, m) for m in IntEnum]\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -379,6 +747,29 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n@@ -387,6 +778,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n@@ -394,9 +808,55 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -405,6 +865,29 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A | IntFlagEnum.B,\n             (\n@@ -414,6 +897,29 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = \"A\", \"A value\"\n@@ -433,6 +939,29 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             (\"datetime.date(1969, 7, 20)\", {\"import datetime\"}),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         field = models.CharField(default=TextChoices.B, choices=TextChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -440,12 +969,58 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -456,6 +1031,29 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\",\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_nested_class(self):\n         for nested_cls in [self.NestedEnum, self.NestedChoices]:\n             cls_name = nested_cls.__name__\n@@ -478,14 +1076,83 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {\"import uuid\"}),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {\"import uuid\"}),\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n         field = models.UUIDField(\n             choices=((uuid_a, \"UUID A\"), (uuid_b, \"UUID B\")), default=uuid_a\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -495,6 +1162,29 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\",\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_pathlib(self):\n         # Pure path objects work in all platforms.\n         self.assertSerializedEqual(pathlib.PurePosixPath())\n@@ -523,6 +1213,29 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"models.FilePathField(path=pathlib.PurePosixPath('/home/user'))\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertIn(\"import pathlib\", imports)\n \n     def test_serialize_path_like(self):\n@@ -554,13 +1267,82 @@ class WriterTests(SimpleTestCase):\n         self.assertSerializedEqual(\n             datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone())\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedEqual(\n             datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180))\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {\"import datetime\"}),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc),\n             (\n@@ -568,6 +1350,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import datetime\"},\n             ),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             datetime.datetime(\n                 2012, 1, 1, 2, 1, tzinfo=zoneinfo.ZoneInfo(\"Europe/Paris\")\n@@ -578,12 +1383,58 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"}),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n@@ -593,20 +1444,112 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(\n             SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\")\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedResultEqual(\n             SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"}),\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)), (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -624,6 +1567,29 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.RegexValidator(message='hello')\"\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a compiled regex.\n@@ -633,6 +1599,29 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test a string regex with flag\n@@ -643,6 +1632,29 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[0-9]+$', \"\n             \"flags=re.RegexFlag['DOTALL'])\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n@@ -653,6 +1665,29 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', \"\n             \"'invalid')\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.serialize_round_trip(validator)\n \n         # Test with a subclass.\n@@ -661,6 +1696,29 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.EmailValidator(message='hello')\"\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.serialize_round_trip(validator)\n \n         validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(\n@@ -671,9 +1729,55 @@ class WriterTests(SimpleTestCase):\n             string, \"migrations.test_writer.EmailValidator(message='hello')\"\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n         validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(\n             message=\"hello\"\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n             MigrationWriter.serialize(validator)\n \n@@ -700,6 +1804,29 @@ class WriterTests(SimpleTestCase):\n             models.OrderBy(models.F(\"name\").desc()),\n             name=\"complex_func_index\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         string, imports = MigrationWriter.serialize(index)\n         self.assertEqual(\n             string,\n@@ -711,6 +1838,29 @@ class WriterTests(SimpleTestCase):\n             \"models.OrderBy(models.OrderBy(models.F('name'), descending=True)), \"\n             \"name='complex_func_index')\",\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertEqual(imports, {\"from django.db import models\"})\n \n     def test_serialize_empty_nonempty_tuple(self):\n@@ -762,6 +1912,29 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.models\"},\n             ),\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         self.assertSerializedEqual(FoodManager(\"a\", \"b\"))\n         self.assertSerializedEqual(FoodManager(\"x\", \"y\", c=3, d=4))\n \n@@ -772,6 +1945,29 @@ class WriterTests(SimpleTestCase):\n             frozenset(\"cba\"), (\"frozenset(['a', 'b', 'c'])\", set())\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_serialize_set(self):\n         self.assertSerializedEqual(set())\n         self.assertSerializedResultEqual(set(), (\"set()\", set()))\n@@ -809,6 +2005,29 @@ class WriterTests(SimpleTestCase):\n             (\"('models.Model', {'from django.db import models'})\", set()),\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -848,6 +2067,29 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [(\"testapp\", \"some_other_one\")],\n             },\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         # We don't test the output formatting - that's too fragile.\n@@ -887,6 +2129,29 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -896,6 +2161,29 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_sorted_dependencies(self):\n         migration = type(\n             \"Migration\",\n@@ -912,6 +2200,29 @@ class WriterTests(SimpleTestCase):\n                 ],\n             },\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         output = MigrationWriter(migration, include_header=False).as_string()\n         self.assertIn(\n             \"    dependencies = [\\n\"\n@@ -923,6 +2234,29 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -949,6 +2283,29 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -956,6 +2313,29 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -1001,6 +2381,29 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\"from django.db import migrations\\n\", output)\n@@ -1017,6 +2420,29 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\",\n         )\n \n+    class NestedProfile(models.Model):\n+        class Capability(models.TextChoices):\n+            BASIC = (\"BASIC\", \"Basic\")\n+            PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+            @classmethod\n+            def default(cls):\n+                return [cls.BASIC]\n+\n+        capabilities = ArrayField(\n+            models.CharField(choices=Capability.choices, max_length=30, blank=True),\n+            null=True,\n+            default=Capability.default\n+        )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        field = self.NestedProfile._meta.get_field('capabilities')\n+        string = MigrationWriter.serialize(field)[0]\n+        self.assertIn(\n+            \"default=migrations.test_writer.WriterTests.NestedProfile.Capability.default\",\n+            string\n+        )\n+\n     def test_register_serializer(self):\n         class ComplexSerializer(BaseSerializer):\n             def serialize(self):\n@@ -1032,4 +2458,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "matplotlib__matplotlib-22711": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex 39c625e..a9325f6 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1088,6 +1088,29 @@ def test_slider_reset():\n \n @pytest.mark.parametrize(\"orientation\", [\"horizontal\", \"vertical\"])\n def test_range_slider(orientation):\n+    # Test case for initializing values to specific values within bounds\n+    fig, ax = plt.subplots()\n+    slider = widgets.RangeSlider(\n+        ax=ax, label=\"\", valmin=0.0, valmax=1.0, orientation=orientation,\n+        valinit=[0.2, 0.8]\n+    )\n+    # Ensure initial values are set correctly\n+    assert_allclose(slider.val, (0.2, 0.8))\n+    box = slider.poly.get_extents().transformed(ax.transAxes.inverted())\n+    if orientation == \"vertical\":\n+        idx = [1, 0, 3, 2]\n+    else:\n+        idx = [0, 1, 2, 3]\n+    assert_allclose(box.get_points().flatten()[idx], [0.2, 0.25, 0.8, 0.75])\n+\n+    # Test setting valinit to an out-of-bounds value (it should be clamped)\n+    slider = widgets.RangeSlider(\n+        ax=ax, label=\"\", valmin=0.0, valmax=1.0, orientation=orientation,\n+        valinit=[-0.5, 1.5]\n+    )\n+    assert_allclose(slider.val, (0.0, 1.0))\n+    box = slider.poly.get_extents().transformed(ax.transAxes.inverted())\n+    assert_allclose(box.get_points().flatten()[idx], [0.0, 0.25, 1.0, 0.75])\n     if orientation == \"vertical\":\n         idx = [1, 0, 3, 2]\n     else:\n",
  "matplotlib__matplotlib-23299": "",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..132a19a 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -15,13 +15,28 @@ from matplotlib.patches import Circle\n \n import matplotlib.pyplot as plt\n import numpy as np\n+from matplotlib.testing.decorators import check_figures_equal\n \n \n mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n \n-def test_aspect_equal_error():\n+@check_figures_equal(extensions=[\"png\"])\n+def test_invisible_axes_3d(fig_test, fig_ref):\n+    # Create a 3D subplot in each figure\n+    ax_test = fig_test.add_subplot(1, 1, 1, projection='3d')\n+    ax_ref = fig_ref.add_subplot(1, 1, 1, projection='3d')\n+\n+    # Plot something on the 3D subplot\n+    ax_test.scatter(1, 1, 1, c='g')\n+    ax_ref.scatter(1, 1, 1, c='g')\n+\n+    # Make the test case 3D plot invisible\n+    ax_test.set_visible(False)\n+\n+    # The figure with the invisible subplot (ax_test) will be empty\n+    # As ax_ref is visible, its presence will cause failure if the bug isn't fixed.\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     with pytest.raises(NotImplementedError):\n",
  "matplotlib__matplotlib-23562": "",
  "matplotlib__matplotlib-23563": "",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..e3387e9 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -773,6 +773,8 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n     for text, color in zip(leg.get_texts(), ['r', 'g', 'b']):\n         assert mpl.colors.same_color(text.get_color(), color)\n \n+import matplotlib.pyplot as plt\n+import pytest\n \n def test_get_set_draggable():\n     legend = plt.legend()\n@@ -783,7 +785,21 @@ def test_get_set_draggable():\n     assert not legend.get_draggable()\n \n \n-def test_alpha_handles():\n+@pytest.mark.parametrize('draggable', (True, False))\n+def test_legend_draggable_initialization(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='sample')\n+    legend = ax.legend(draggable=draggable)\n+    assert legend.get_draggable() is draggable\n+\n+def test_legend_draggable_toggle():\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='sample')\n+    legend = ax.legend()\n+    legend.set_draggable(True)\n+    assert legend.get_draggable() is True\n+    legend.set_draggable(False)\n+    assert legend.get_draggable() is False\n     x, n, hh = plt.hist([1, 2, 3], alpha=0.25, label='data', color='red')\n     legend = plt.legend()\n     for lh in legend.legendHandles:\n",
  "matplotlib__matplotlib-23964": "diff --git a/lib/matplotlib/tests/test_backend_ps.py b/lib/matplotlib/tests/test_backend_ps.py\nindex a1caf1a..368a82f 100644\n--- a/lib/matplotlib/tests/test_backend_ps.py\n+++ b/lib/matplotlib/tests/test_backend_ps.py\n@@ -255,6 +255,16 @@ def test_linedash():\n \n     assert buf.tell() > 0\n \n+import io\n+from matplotlib.figure import Figure\n+\n+def test_empty_line():\n+    # Smoke-test for gh#23954\n+    figure = Figure()\n+    figure.text(0.5, 0.5, \"\\nfoo\\n\\n\")\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    figure.savefig(buf, format='ps')\n \n def test_no_duplicate_definition():\n \n",
  "matplotlib__matplotlib-23987": "",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 64ba766..dc05ef3 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -5723,8 +5723,42 @@ def test_set_get_ticklabels():\n     ax[0].set_yticks(range(10))\n     ax[0].set_xticklabels(['a', 'b', 'c', 'd'] + 6 * [''])\n     ax[0].set_yticklabels(['11', '12', '13', '14'] + 6 * [''])\n+import pytest\n+import matplotlib.pyplot as plt\n+\n+def test_set_ticks_kwargs_raise_error_without_labels():\n+    \"\"\"\n+    When labels=None and any kwarg is passed, axis.set_ticks() raises a\n+    ValueError.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [1, 2, 3]\n+    with pytest.raises(ValueError, match=\"Text properties are only applicable if labels are set\"):\n+        ax.xaxis.set_ticks(ticks, alpha=0.5)\n \n-    # set ticklabel to the other plot, expect the 2 plots have same label\n+def test_set_ticks_no_error_with_labels():\n+    \"\"\"\n+    When labels are provided, axis.set_ticks() accepts text properties\n+    without error.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [1, 2, 3]\n+    labels = ['a', 'b', 'c']\n+    try:\n+        ax.xaxis.set_ticks(ticks, labels=labels, color='red')\n+    except ValueError:\n+        pytest.fail(\"set_ticks raised ValueError unexpectedly!\")\n+\n+def test_set_ticks_invalid_kwarg_raises_error():\n+    \"\"\"\n+    When an invalid text property kwarg is passed, axis.set_ticks()\n+    raises a ValueError.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [1, 2, 3]\n+    labels = ['a', 'b', 'c']\n+    with pytest.raises(ValueError):\n+        ax.xaxis.set_ticks(ticks, labels=labels, not_a_property='value')\n     # setting pass get_ticklabels return value as ticklabels argument\n     ax[1].set_xticks(ax[0].get_xticks())\n     ax[1].set_yticks(ax[0].get_yticks())\n",
  "matplotlib__matplotlib-24970": "",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..97a0388 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -90,7 +91,36 @@ def _generate_complete_test_figure(fig_ref):\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n \n+import pickletools\n+\n @mpl.style.context(\"default\")\n+\n+def test_pickle_figure_with_draggable_legend():\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111)\n+\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40, 43, 45, 47, 48]\n+\n+    ax.plot(time, speed, label=\"speed\")\n+\n+    leg = ax.legend()\n+    leg.set_draggable(True)  # Test pickling of draggable legend\n+\n+    # Serialize the figure\n+    pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+\n+    # Check that there's no reference to FigureCanvasQTAgg (or similar non-picklable backend-specific) in the pickle stream.\n+    assert \"FigureCanvasQTAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+\n+    # Try loading the figure back\n+    loaded_fig = pickle.loads(pkl)\n+\n+    # Validate the loaded figure (for further assurance)\n+    assert isinstance(loaded_fig, plt.Figure)\n+    assert len(loaded_fig.axes) == 1\n+    assert loaded_fig.axes[0].get_legend() is not None\n+    assert loaded_fig.axes[0].get_legend().get_draggable() == True\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..b5bebe9 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -58,37 +58,244 @@ def _generate_complete_test_figure(fig_ref):\n     # Ensure lists also pickle correctly.\n     plt.subplot(3, 3, 1)\n     plt.plot(list(range(10)))\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n \n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n+\n+    plt.close(fig)\n     plt.subplot(3, 3, 2)\n     plt.contourf(data, hatches=['//', 'ooo'])\n     plt.colorbar()\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n \n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n+\n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n+\n+    plt.close(fig)\n     plt.subplot(3, 3, 3)\n     plt.pcolormesh(data)\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n \n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n+\n+    plt.close(fig)\n     plt.subplot(3, 3, 4)\n     plt.imshow(data)\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n \n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n+\n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n+\n+    plt.close(fig)\n     plt.subplot(3, 3, 5)\n     plt.pcolor(data)\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n \n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n+\n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n+\n+    plt.close(fig)\n     ax = plt.subplot(3, 3, 6)\n     ax.set_xlim(0, 7)\n     ax.set_ylim(0, 9)\n     plt.streamplot(x, y, u, v)\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n \n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n+\n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n+\n+    plt.close(fig)\n     ax = plt.subplot(3, 3, 7)\n     ax.set_xlim(0, 7)\n     ax.set_ylim(0, 9)\n     plt.quiver(x, y, u, v)\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n+\n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n \n+    plt.close(fig)\n     plt.subplot(3, 3, 8)\n     plt.scatter(x, x ** 2, label='$x^2$')\n     plt.legend(loc='upper left')\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n \n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n+\n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n+\n+    plt.close(fig)\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n+\n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n \n+    plt.close(fig)\n \n @mpl.style.context(\"default\")\n @check_figures_equal(extensions=[\"png\"])\n@@ -99,10 +306,56 @@ def test_complete(fig_test, fig_ref):\n     pickle.dump(fig_ref, pkl, pickle.HIGHEST_PROTOCOL)\n     loaded = pickle.loads(pkl.getbuffer())\n     loaded.canvas.draw()\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n \n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n+\n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n+\n+    plt.close(fig)\n     fig_test.set_size_inches(loaded.get_size_inches())\n     fig_test.figimage(loaded.canvas.renderer.buffer_rgba())\n+import matplotlib.pyplot as plt\n+import pickle\n+from io import BytesIO\n+\n+def test_pickle_figure_with_aligned_labels():\n+    fig, (ax1, ax2) = plt.subplots(2, 1)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call align_labels and then try to pickle the figure\n+    fig.align_labels()\n+\n+    try:\n+        pickle.dumps(fig)\n+    except TypeError as e:\n+        assert False, f\"Pickling failed with align_labels: {e}\"\n \n+    plt.close(fig)\n     plt.close(loaded)\n \n \n",
  "matplotlib__matplotlib-25442": "",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "",
  "mwaskom__seaborn-3190": "",
  "mwaskom__seaborn-3407": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\nindex b2e4a92..2f4cd5f 100644\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -1314,7 +1314,28 @@ class TestPairGrid:\n         for ax in g.diag_axes:\n             assert len(ax.collections) == n\n \n-    def test_pairplot_reg(self):\n+    def test_pairplot_column_multiindex(self):\n+\n+        # Setup a MultiIndex DataFrame as per original issue\n+        np.random.seed(0)\n+        data = {\n+            (\"A\", \"1\"): np.random.rand(100),\n+            (\"A\", \"2\"): np.random.rand(100),\n+            (\"B\", \"1\"): np.random.rand(100),\n+            (\"B\", \"2\"): np.random.rand(100)\n+        }\n+        df = pd.DataFrame(data)\n+\n+        # Try using pairplot with MultiIndex columns\n+        g = ag.pairplot(df)\n+        assert len(g.fig.axes) > 0  # Check that axes were created\n+\n+        # Additionally, check the diagonal vars to match the column structure\n+        inv_col_list = [\n+            df.columns.get_level_values(0).tolist(),\n+            df.columns.get_level_values(1).tolist()\n+        ]\n+        assert g.diag_vars == list(zip(*inv_col_list))\n \n         vars = [\"x\", \"y\", \"z\"]\n         g = ag.pairplot(self.df, diag_kind=\"hist\", kind=\"reg\")\n",
  "pallets__flask-4992": "",
  "psf__requests-1963": "",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..aad2cab 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1636,6 +1636,44 @@ def test_prepared_request_complete_copy():\n     assert_copy(p, p.copy())\n \n \n+import pytest\n+import requests\n+from requests.exceptions import DecodeError, Timeout\n+from requests.adapters import HTTPAdapter\n+from requests.sessions import Session\n+from requests.packages.urllib3.exceptions import DecodeError as Urllib3DecodeError\n+from requests.packages.urllib3.exceptions import TimeoutError as Urllib3TimeoutError\n+\n+def test_urllib3_decode_error_wrapped():\n+    s = requests.Session()\n+    adapter = HTTPAdapter()\n+\n+    # Create a mock function to raise DecodeError\n+    def mock_send(*args, **kwargs):\n+        raise Urllib3DecodeError(\"Mock decode error\")\n+\n+    # Replace the adapter's send function with the mock function\n+    adapter.send = mock_send\n+    s.mount('http://', adapter)\n+\n+    with pytest.raises(DecodeError):\n+        s.get('http://someurl.com')\n+\n+def test_urllib3_timeout_error_wrapped():\n+    s = requests.Session()\n+    adapter = HTTPAdapter()\n+\n+    # Create a mock function to raise TimeoutError\n+    def mock_send(*args, **kwargs):\n+        raise Urllib3TimeoutError(\"Mock timeout error\")\n+\n+    # Replace the adapter's send function with the mock function\n+    adapter.send = mock_send\n+    s.mount('http://', adapter)\n+\n+    with pytest.raises(Timeout):\n+        s.get('http://someurl.com')\n+\n def test_prepare_unicode_url():\n     p = PreparedRequest()\n     p.prepare(\n@@ -1663,4 +1701,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 52d1693..c154b83 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -980,7 +980,30 @@ class TestRequests:\n         chunks = r.iter_content(decode_unicode=True)\n         assert all(isinstance(chunk, str) for chunk in chunks)\n \n-    def test_response_chunk_size_int(self):\n+    def test_iter_content_decode_unicode_false(self):\n+        \"\"\"\n+        When called with decode_unicode=False, Response.iter_content should return bytes.\n+        \"\"\"\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'the content')\n+        r.encoding = 'ascii'\n+        \n+        chunks = r.iter_content(decode_unicode=False)\n+        assert all(isinstance(chunk, bytes) for chunk in chunks)\n+\n+    def test_iter_content_vs_text(self):\n+        \"\"\"\n+        Verifies iter_content and text content parity regarding encoding.\n+        \"\"\"\n+        r = requests.Response()\n+        r._content_consumed = True\n+        r._content = b'the content'\n+        r.encoding = 'ascii'\n+        \n+        iter_chunks = ''.join(r.iter_content(decode_unicode=True))\n+        text_content = r.text\n+        \n+        assert iter_chunks == text_content\n         \"\"\"Ensure that chunk_size is passed as an integer, otherwise\n         raise a TypeError.\n         \"\"\"\n",
  "psf__requests-863": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 0ee4333..4a196f4 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -744,7 +744,36 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n             assert 'foo' in response.text\n             assert 'bar' in response.text\n \n-    def test_session_persistent_cookies(self):\n+    def test_multiple_hooks_via_init(self):\n+        \"\"\"Test initializing Request with multiple hooks given as lists in hooks parameter.\"\"\"\n+        def add_foo_header(args):\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers'].update({'X-Foo': 'foo'})\n+            return args\n+\n+        def add_bar_header(args):\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers'].update({'X-Bar': 'bar'})\n+            return args\n+\n+        def assert_hooks_are_callable(hooks):\n+            for h in hooks['args']:\n+                assert callable(h) is True\n+\n+        hooks = {'args': [add_foo_header, add_bar_header]}\n+        r = requests.models.Request(hooks=hooks)\n+        assert_hooks_are_callable(r.hooks)\n+\n+        test_args = {}\n+        for hook in r.hooks['args']:\n+            test_args = hook(test_args)\n+\n+        assert 'X-Foo' in test_args['headers']\n+        assert test_args['headers']['X-Foo'] == 'foo'\n+        assert 'X-Bar' in test_args['headers']\n+        assert test_args['headers']['X-Bar'] == 'bar'\n \n         s = requests.session()\n \n",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..b59252c 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -385,10 +385,23 @@ repr_da = xr.DataArray(\n \n @pytest.mark.parametrize(\"dim\", [\"x\", \"y\", \"z\", \"month\"])\n @pytest.mark.parametrize(\"obj\", [repr_da, repr_da.to_dataset(name=\"a\")])\n+def test_groupby_str_no_trailing_space(obj):\n+    # Test to ensure there's no trailing whitespace at the end of the line\n+    groupby_repr = str(obj.groupby(\"x\"))\n+    # Ensure there is no trailing whitespace\n+    assert not groupby_repr.split(\"\\n\")[0].endswith(\" \")\n+    \n+    groupby_repr = str(obj.groupby(\"z\"))\n+    # Ensure there is no trailing whitespace\n+    assert not groupby_repr.split(\"\\n\")[0].endswith(\" \")\n+    \n+    groupby_repr = str(obj.groupby(\"month\"))\n+    # Ensure there is no trailing whitespace\n+    assert not groupby_repr.split(\"\\n\")[0].endswith(\" \")\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over %r \" % dim\n+    expected += \", grouped over %r\" % dim\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj[dim])))\n     if dim == \"x\":\n         expected += \"1, 2, 3, 4, 5.\"\n@@ -402,10 +415,23 @@ def test_groupby_repr(obj, dim):\n \n \n @pytest.mark.parametrize(\"obj\", [repr_da, repr_da.to_dataset(name=\"a\")])\n+def test_groupby_str_no_trailing_space(obj):\n+    # Test to ensure there's no trailing whitespace at the end of the line\n+    groupby_repr = str(obj.groupby(\"x\"))\n+    # Ensure there is no trailing whitespace\n+    assert not groupby_repr.split(\"\\n\")[0].endswith(\" \")\n+    \n+    groupby_repr = str(obj.groupby(\"z\"))\n+    # Ensure there is no trailing whitespace\n+    assert not groupby_repr.split(\"\\n\")[0].endswith(\" \")\n+    \n+    groupby_repr = str(obj.groupby(\"month\"))\n+    # Ensure there is no trailing whitespace\n+    assert not groupby_repr.split(\"\\n\")[0].endswith(\" \")\n def test_groupby_repr_datetime(obj):\n     actual = repr(obj.groupby(\"t.month\"))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over 'month' \"\n+    expected += \", grouped over 'month'\"\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj.t.dt.month)))\n     expected += \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.\"\n     assert actual == expected\n",
  "pylint-dev__pylint-5859": "",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..a61d4ff 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -71,12 +71,13 @@ def test_unknown_option_name(capsys: CaptureFixture) -> None:\n     assert \"E0015: Unrecognized option found: unknown-option=yes\" in output.out\n \n \n-def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n-    \"\"\"Check that we correctly raise a message on an unknown short option.\"\"\"\n-    with pytest.raises(_UnrecognizedOptionError):\n-        Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n+def test_unknown_short_option_name_no_traceback(capsys: CaptureFixture) -> None:\n+    \"\"\"Check that we get a user-friendly message and no traceback for an unknown short option.\"\"\"\n+    Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n     output = capsys.readouterr()\n     assert \"E0015: Unrecognized option found: Q\" in output.out\n+    assert \"Traceback\" not in output.out\n+    assert \"usage: pylint\" in output.out\n \n \n def test_unknown_confidence(capsys: CaptureFixture) -> None:\n",
  "pylint-dev__pylint-7080": "",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..8cdbe78 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -934,6 +934,18 @@ print(submodule1)\n             linter.check([\"submodule2.py\"])\n     assert not linter.stats.by_msg\n \n+def test_lint_directory_with_same_name_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test linting a directory where a module and its parent directory have the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"samedir/samedir.py\", \"samedir/other.py\"])\n+        with open(\"samedir/samedir.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"# Sample content\")\n+        with open(\"samedir/other.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"import samedir\")\n+        linter.check([\"samedir\"])\n+    assert \"parse-error\" not in linter.stats.by_msg\n+\n \n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n@@ -941,4 +953,16 @@ def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n+\n+def test_lint_directory_with_same_name_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test linting a directory where a module and its parent directory have the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"samedir/samedir.py\", \"samedir/other.py\"])\n+        with open(\"samedir/samedir.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"# Sample content\")\n+        with open(\"samedir/other.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"import samedir\")\n+        linter.check([\"samedir\"])\n+    assert \"parse-error\" not in linter.stats.by_msg\n",
  "pylint-dev__pylint-7993": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 6338072..965c0b9 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n@@ -113,6 +114,37 @@ def test_template_option_non_existing(linter) -> None:\n     assert out_lines[2] == \"my_mod:2::()\"\n \n \n+def test_template_with_custom_braces(linter: PyLinter) -> None:\n+    \"\"\"Test message template with custom braces.\"\"\"\n+    output = StringIO()\n+    linter.reporter.out = output\n+    linter.config.msg_template = '{{ \"Category\": \"{category}\" }}'\n+    linter.open()\n+    linter.set_current_module(\"module_test\")\n+\n+    # Adding messages\n+    linter.add_message(\"C0301\", line=1, args=())\n+    linter.add_message(\"E1101\", line=2, args=())\n+\n+    out_lines = output.getvalue().split(\"\\n\")\n+    assert out_lines[1] == '{ \"Category\": \"convention\" }'\n+    assert out_lines[2] == '{ \"Category\": \"error\" }'\n+\n+def test_template_with_unrecognized_argument(recwarn: WarningsRecorder, linter: PyLinter) -> None:\n+    \"\"\"Test message template with an unrecognized argument.\"\"\"\n+    output = StringIO()\n+    linter.reporter.out = output\n+    linter.config.msg_template = '{{ \"Category\": \"{unrecognized}\" }}'\n+    linter.open()\n+    linter.set_current_module(\"module_test\")\n+\n+    linter.add_message(\"C0301\", line=1, args=())\n+    warning = recwarn.pop()\n+    assert \"Don't recognize the argument 'unrecognized'\" in str(warning.message)\n+    \n+    out_lines = output.getvalue().split(\"\\n\")\n+    assert out_lines[1] == \"}\"\n+\n def test_deprecation_set_output(recwarn):\n     \"\"\"TODO remove in 3.0.\"\"\"\n     reporter = BaseReporter()\n",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "diff --git a/testing/acceptance_test.py b/testing/acceptance_test.py\nindex 0cc5057..0cff2e9 100644\n--- a/testing/acceptance_test.py\n+++ b/testing/acceptance_test.py\n@@ -1305,13 +1305,68 @@ def test_no_brokenpipeerror_message(pytester: Pytester) -> None:\n     # Cleanup.\n     popen.stderr.close()\n \n+from pathlib import Path\n+import sys\n+import pytest\n+from _pytest.pytester import Pytester\n+from typing import Iterator\n \n-def test_function_return_non_none_warning(pytester: Pytester) -> None:\n+def test_doctest_and_normal_imports_with_importlib(pytester: Pytester) -> None:\n+    \"\"\"\n+    Regression test for imports issue: Ensure that with import_mode=importlib,\n+    the same module object is returned and sys.modules state remains consistent.\n+    \"\"\"\n     pytester.makepyfile(\n+        **{\n+            \"pmxbot/commands.py\": \"from . import logging\",\n+            \"pmxbot/logging.py\": \"\",\n+            \"tests/__init__.py\": \"\",\n+            \"tests/test_commands.py\": \"\"\"\n+                import importlib\n+                from pmxbot import logging\n+\n+                class TestCommands:\n+                    def test_import_uniqueness(self):\n+                        assert importlib.import_module('pmxbot.logging') is logging\n+            \"\"\",\n+        }\n+    )\n+    pytester.makeini(\n         \"\"\"\n-        def test_stuff():\n-            return \"something\"\n+        [pytest]\n+        addopts =\n+            --doctest-modules\n+            --import-mode importlib\n+        \"\"\"\n+    )\n+    result = pytester.runpytest_subprocess()\n+    result.stdout.fnmatch_lines(\"*1 passed*\")\n+\n+def test_multiple_imports_does_not_duplicate(pytester: Pytester) -> None:\n+    \"\"\"\n+    Tests that even with multiple imports using importlib, no duplication occurs.\n     \"\"\"\n+    pytester.makepyfile(\n+        **{\n+            \"pmxbot/logging.py\": \"class Logger: pass\",\n+            \"tests/test_duplicate_imports.py\": \"\"\"\n+                import importlib\n+                import sys\n+                from pmxbot import logging\n+\n+                def test_no_duplicate_imports():\n+                    module = importlib.import_module('pmxbot.logging')\n+                    assert module is logging\n+                    assert sys.modules['pmxbot.logging'] is logging\n+            \"\"\",\n+        }\n     )\n-    res = pytester.runpytest()\n-    res.stdout.fnmatch_lines([\"*Did you mean to use `assert` instead of `return`?*\"])\n+    pytester.makeini(\n+        \"\"\"\n+        [pytest]\n+        addopts =\n+            --import-mode importlib\n+        \"\"\"\n+    )\n+    result = pytester.runpytest_subprocess()\n+    result.stdout.fnmatch_lines(\"*1 passed*\")\n",
  "pytest-dev__pytest-5227": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 1ebe9d0..01f354c 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -15,7 +15,7 @@ from _pytest.compat import dummy_context_manager\n from _pytest.config import create_terminal_writer\n from _pytest.pathlib import Path\n \n-DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n+DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n \n \n",
  "pytest-dev__pytest-5495": "",
  "pytest-dev__pytest-5692": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3392814..c4cb3fd 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1,4 +1,7 @@\n+\n import os\n+from datetime import datetime\n+import platform\n from xml.dom import minidom\n \n import py\n@@ -156,8 +159,30 @@ class TestPython:\n         tnode = node.find_first_by_tag(\"testcase\")\n         val = tnode[\"time\"]\n         assert round(float(val), 2) >= 0.03\n+    \n+    def test_hostname_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+            \"\"\"\n+        )\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        node.assert_attr(hostname=platform.node())\n \n-    @pytest.mark.parametrize(\"duration_report\", [\"call\", \"total\"])\n+    def test_timestamp_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+            \"\"\"\n+        )\n+        start_time = datetime.now()\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        timestamp = datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S.%f\")\n+        assert start_time <= timestamp < datetime.now()\n     def test_junit_duration_report(self, testdir, monkeypatch, duration_report):\n \n         # mock LogXML.node_reporter so it always sets a known duration to each test report object\n",
  "pytest-dev__pytest-7168": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 38e0b6b..6087fd8 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -143,6 +143,20 @@ def test_repr_on_newstyle():\n \n     assert saferepr(Function())\n \n+def test_broken_getattribute():\n+    \"\"\"saferepr() can create proper representations of classes with\n+    broken __getattribute__ and __repr__ (#7145)\"\"\"\n+\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError\n+\n+        def __repr__(self):\n+            raise RuntimeError\n+\n+    assert saferepr(SomeClass()).startswith(\n+        \"<[RuntimeError() raised in repr()] SomeClass object at 0x\"\n+    )\n \n def test_unicode():\n     val = \"\u00a3\u20ac\"\n@@ -153,4 +167,4 @@ def test_unicode():\n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n-    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n",
  "pytest-dev__pytest-7220": "diff --git a/testing/test_pytester.py b/testing/test_pytester.py\nindex 5ab5242..506bf27 100644\n--- a/testing/test_pytester.py\n+++ b/testing/test_pytester.py\n@@ -77,6 +77,31 @@ def test_parseconfig(testdir) -> None:\n     assert config2 is not config1\n \n \n+def test_failure_with_changed_cwd(testdir):\n+    \"\"\"Test correct path display when directory change occurs in fixture.\"\"\"\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import pytest\n+        import os\n+\n+        @pytest.fixture\n+        def private_dir():\n+            out_dir = 'ddd'\n+            os.mkdir(out_dir)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+\n+        def test_show_wrong_path(private_dir):\n+            assert False\n+        \"\"\"\n+    )\n+    \n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([str(p) + \":*: AssertionError\", \"*1 failed in *\"])\n+\n+\n def test_testdir_runs_with_plugin(testdir) -> None:\n     testdir.makepyfile(\n         \"\"\"\n",
  "pytest-dev__pytest-7373": "diff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 309636c..b20e3c8 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1,5 +1,72 @@\n import os\n import sys\n+def test_reevaluate_dynamic_expr(testdir):\n+    \"\"\"Test to validate caching problem described in issue #7360.\"\"\"\n+    py_file1 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr1=\"\"\"\n+        import pytest\n+\n+        skip = True\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_skip():\n+            assert True\n+    \"\"\"\n+    )\n+    py_file2 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr2=\"\"\"\n+        import pytest\n+\n+        skip = False\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_not_skip():\n+            assert True\n+    \"\"\"\n+    )\n+\n+    file_name1 = os.path.basename(py_file1.strpath)\n+    file_name2 = os.path.basename(py_file2.strpath)\n+    reprec = testdir.inline_run(file_name1, file_name2)\n+    reprec.assertoutcome(passed=1, skipped=1)\n+\n+def test_no_skip_condition_cache(testdir):\n+    \"\"\"Test different skip conditions in different modules without caching.\"\"\"\n+    py_file1 = testdir.makepyfile(\n+        test_no_skip_condition_cache_1=\"\"\"\n+        import pytest\n+        import sys\n+        \n+        skip_if_win = sys.platform == 'win32'\n+\n+        @pytest.mark.skipif(\"skip_if_win\")\n+        def test_skip_on_windows():\n+            assert True\n+    \"\"\"\n+    )\n+    py_file2 = testdir.makepyfile(\n+        test_no_skip_condition_cache_2=\"\"\"\n+        import pytest\n+        import sys\n+\n+        skip_if_linux = sys.platform == 'linux'\n+\n+        @pytest.mark.skipif(\"skip_if_linux\")\n+        def test_skip_on_linux():\n+            assert True\n+    \"\"\"\n+    )\n+\n+    file_name1 = os.path.basename(py_file1.strpath)\n+    file_name2 = os.path.basename(py_file2.strpath)\n+    reprec = testdir.inline_run(file_name1, file_name2)\n+\n+    expected_passed = 2 if sys.platform not in ['win32', 'linux'] else 1\n+    expected_skipped = 2 - expected_passed\n+    reprec.assertoutcome(passed=expected_passed, skipped=expected_skipped)\n+\n+import os\n+\n from unittest import mock\n \n import pytest\n",
  "pytest-dev__pytest-7432": "",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..ce6fe81 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,3 +1,4 @@\n+\n import sys\n \n import pytest\n@@ -397,6 +398,20 @@ class TestXFail:\n         result = testdir.runpytest(p, \"-rxX\")\n         result.stdout.fnmatch_lines([\"*XFAIL*test_this*\", \"*XPASS*test_that*\"])\n \n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # Reproduces the issue where a dynamically added xfail was not respected.\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p, \"-rxX\")\n+        result.assert_outcomes(xfailed=1)\n+\n     def test_dynamic_xfail_no_run(self, testdir):\n         p = testdir.makepyfile(\n             \"\"\"\n",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..36172e3 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,4 +1,7 @@\n+\n import os\n+from _pytest.monkeypatch import MonkeyPatch\n+from _pytest.tmpdir import TempPathFactory\n import stat\n import sys\n from pathlib import Path\n",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..ee79014 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -597,8 +597,37 @@ def test_ridgecv_store_cv_values():\n     r.fit(x, y)\n     assert_equal(r.cv_values_.shape, (n_samples, n_responses, n_alphas))\n \n-\n-def test_ridgecv_sample_weight():\n+def test_ridge_classifier_cv_store_cv_values():\n+    from sklearn.linear_model import RidgeClassifierCV\n+    from numpy.testing import assert_array_equal\n+    \n+    # Test: RidgeClassifierCV should now accept store_cv_values=True\n+    x = np.array([[-1.0, -1.0], [-1.0, 0.0], [-0.8, -1.0], [1.0, 1.0], [1.0, 0.0]])\n+    y = np.array([1, 1, 1, -1, -1])\n+    \n+    n_samples = x.shape[0]\n+    alphas = [1e-1, 1e0, 1e1]\n+    n_alphas = len(alphas)\n+    \n+    r = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+    \n+    # Test when y is 1-dimensional\n+    n_targets = 1\n+    r.fit(x, y)\n+    assert r.cv_values_.shape == (n_samples, n_targets, n_alphas)\n+    \n+    # Test when y is 2-dimensional\n+    y = np.array([[1, 1, 1, -1, -1], [1, -1, 1, -1, 1], [-1, -1, 1, -1, -1]]).T\n+    n_targets = y.shape[1]\n+    r.fit(x, y)\n+    assert r.cv_values_.shape == (n_samples, n_targets, n_alphas)\n+\n+    # Test ValueError is raised if cv is not None and store_cv_values is True\n+    try:\n+        RidgeClassifierCV(alphas=alphas, cv=3, store_cv_values=True)\n+        assert False, \"Expected ValueError\"\n+    except ValueError as e:\n+        assert \"cv!=None and store_cv_values=True are incompatible\" in str(e)\n     rng = np.random.RandomState(0)\n     alphas = (0.1, 1.0, 10.0)\n \n",
  "scikit-learn__scikit-learn-11281": "",
  "scikit-learn__scikit-learn-12471": "diff --git a/sklearn/preprocessing/tests/test_encoders.py b/sklearn/preprocessing/tests/test_encoders.py\nindex 3f9b211..7b5e88e 100644\n--- a/sklearn/preprocessing/tests/test_encoders.py\n+++ b/sklearn/preprocessing/tests/test_encoders.py\n@@ -260,7 +260,42 @@ def test_one_hot_encoder_not_fitted():\n         enc.transform(X)\n \n \n-def test_one_hot_encoder_no_categorical_features():\n+from sklearn.preprocessing import OneHotEncoder\n+import numpy as np\n+from numpy.testing import assert_array_equal\n+import pytest\n+\n+def test_one_hot_encoder_handle_unknown_strings():\n+    X = np.array(['11111111', '22', '333', '4444']).reshape((-1, 1))\n+    X2 = np.array(['55555', '22']).reshape((-1, 1))\n+    # Non Regression test for the issue #12470\n+    # Test the ignore option, when categories are numpy string dtype\n+    # particularly when the known category strings are larger\n+    # than the unknown category strings\n+    oh = OneHotEncoder(handle_unknown='ignore')\n+    oh.fit(X)\n+    X2_passed = X2.copy()\n+    assert_array_equal(\n+        oh.transform(X2_passed).toarray(),\n+        np.array([[0.,  0.,  0.,  0.], [0.,  1.,  0.,  0.]]))\n+    # ensure transformed data was not modified in place\n+    assert_array_equal(X2, X2_passed)\n+\n+def test_one_hot_encoder_handle_unknown_mixed():\n+    X = np.array(['cat', 'dog', 'bird']).reshape((-1, 1))\n+    X2 = np.array(['fish', 'dog']).reshape((-1, 1))\n+    oh = OneHotEncoder(handle_unknown='ignore')\n+    oh.fit(X)\n+    expected = np.array([[0., 0., 0.], [0., 1., 0.]])\n+    assert_array_equal(oh.transform(X2).toarray(), expected)\n+\n+def test_one_hot_encoder_handle_unknown_different_length():\n+    X = np.array(['a', 'bb', 'ccc']).reshape((-1, 1))\n+    X2 = np.array(['d', 'bb']).reshape((-1, 1))\n+    oh = OneHotEncoder(handle_unknown='ignore')\n+    oh.fit(X)\n+    expected = np.array([[0., 0., 0.], [0., 1., 0.]])\n+    assert_array_equal(oh.transform(X2).toarray(), expected)\n     X = np.array([[3, 2, 1], [0, 1, 1]], dtype='float64')\n \n     cat = [False, False, False]\n",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex f8e4d54..1bd5e56 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -597,8 +597,13 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_array_equal(Y_pred1, Y_pred2)\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n-\n-def test_gaussian_mixture_fit():\n+def test_gaussian_mixture_fit_predict_n_init():\n+    # Check that fit_predict is equivalent to fit.predict, when n_init > 1\n+    X = np.random.RandomState(0).randn(1000, 5)\n+    gm = GaussianMixture(n_components=5, n_init=5, random_state=0)\n+    y_pred1 = gm.fit_predict(X)\n+    y_pred2 = gm.predict(X)\n+    assert_array_equal(y_pred1, y_pred2)\n     # recover the ground truth\n     rng = np.random.RandomState(0)\n     rand_data = RandomData(rng)\n",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..bb3f451 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,3 +1,4 @@\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n@@ -7,14 +8,29 @@ from sklearn.utils.testing import (assert_array_almost_equal, assert_less,\n                                    assert_raises)\n \n from sklearn.decomposition import PCA, KernelPCA\n+from sklearn.utils.testing import assert_allclose\n from sklearn.datasets import make_circles\n from sklearn.linear_model import Perceptron\n from sklearn.pipeline import Pipeline\n from sklearn.model_selection import GridSearchCV\n from sklearn.metrics.pairwise import rbf_kernel\n \n-\n-def test_kernel_pca():\n+def test_kernel_pca_sign_flipping():\n+    # This test checks that KernelPCA outputs are consistent up to a sign flip\n+    rng = np.random.RandomState(42)\n+    X = rng.rand(10, 10)\n+\n+    kpca = KernelPCA(n_components=7, kernel='rbf', random_state=rng)\n+    X_transformed_1 = kpca.fit_transform(X)\n+    X_transformed_2 = kpca.fit_transform(X)\n+\n+    # The results should be identical up to a sign change\n+    for i in range(X_transformed_1.shape[1]):\n+        assert_allclose(\n+            np.abs(X_transformed_1[:, i]), \n+            np.abs(X_transformed_2[:, i]), \n+            err_msg=f\"Component {i} does not match in absolute values\"\n+        )\n     rng = np.random.RandomState(0)\n     X_fit = rng.random_sample((5, 4))\n     X_pred = rng.random_sample((2, 4))\n",
  "scikit-learn__scikit-learn-13439": "diff --git a/sklearn/tests/test_pipeline.py b/sklearn/tests/test_pipeline.py\nindex 318940e..e6d06f7 100644\n--- a/sklearn/tests/test_pipeline.py\n+++ b/sklearn/tests/test_pipeline.py\n@@ -1070,4 +1070,37 @@ def test_make_pipeline_memory():\n     pipeline = make_pipeline(DummyTransf(), SVC())\n     assert pipeline.memory is None\n \n-    shutil.rmtree(cachedir)\n+    shutil.rmtree(cachedir)\n+\n+\n+def test_pipeline_length():\n+    from sklearn.pipeline import Pipeline\n+    from sklearn.datasets import make_classification\n+    from sklearn.feature_selection import SelectKBest\n+    from sklearn.feature_selection import f_regression\n+    from sklearn.svm import SVC\n+\n+    # Generate some data\n+    X, y = make_classification(n_informative=5, n_redundant=0, random_state=42)\n+\n+    # Create steps\n+    anova_filter = SelectKBest(f_regression, k=5)\n+    clf = SVC(kernel='linear')\n+\n+    # Create a pipeline with two steps\n+    pipeline = Pipeline([('anova', anova_filter), ('svc', clf)])\n+\n+    # Test len function gives correct number of steps\n+    assert len(pipeline) == 2\n+\n+    # Create a pipeline with one step\n+    pipeline_single_step = Pipeline([('anova', anova_filter)])\n+    \n+    # Test len function gives correct number of steps for a single step pipeline\n+    assert len(pipeline_single_step) == 1\n+\n+    # Test an empty pipeline\n+    pipeline_empty = Pipeline([])\n+    \n+    # Test len function gives correct number of steps for an empty pipeline\n+    assert len(pipeline_empty) == 0\n",
  "scikit-learn__scikit-learn-13496": "",
  "scikit-learn__scikit-learn-13497": "diff --git a/sklearn/feature_selection/tests/test_mutual_info.py b/sklearn/feature_selection/tests/test_mutual_info.py\nindex f5a2908..b4a38af 100644\n--- a/sklearn/feature_selection/tests/test_mutual_info.py\n+++ b/sklearn/feature_selection/tests/test_mutual_info.py\n@@ -182,6 +182,39 @@ def test_mutual_info_options():\n     y = np.array([0, 1, 2, 2, 1], dtype=float)\n     X_csr = csr_matrix(X)\n \n+    for mutual_info in (mutual_info_regression, mutual_info_classif):\n+        # Check ValueError is raised for invalid 'manual' string\n+        assert_raises(ValueError, mutual_info, X, y, discrete_features='manual')\n+\n+        # Test for valid list of booleans\n+        mi_1 = mutual_info(X, y, discrete_features=[True, False, True], random_state=0)\n+        mi_2 = mutual_info(X, y, discrete_features=[0, 2], random_state=0)\n+        assert_array_equal(mi_1, mi_2)\n+\n+        # Test for valid list of indices larger than the feature set\n+        with raises(IndexError):\n+            mutual_info(X, y, discrete_features=[1, 4])\n+\n+        # Test when discrete_features boolean mask size does not match number of features\n+        with raises(IndexError):\n+            mutual_info(X, y, discrete_features=[True, False, True, False])\n+            \n+        mi_3 = mutual_info(X_csr, y, discrete_features='auto',\n+                           random_state=0)\n+        mi_4 = mutual_info(X_csr, y, discrete_features=True,\n+                           random_state=0)\n+\n+        assert_array_equal(mi_3, mi_4)\n+\n+    assert not np.allclose(mi_1, mi_3)\n+    X = np.array([[0, 0, 0],\n+                  [1, 1, 0],\n+                  [2, 0, 1],\n+                  [2, 0, 1],\n+                  [2, 0, 1]], dtype=float)\n+    y = np.array([0, 1, 2, 2, 1], dtype=float)\n+    X_csr = csr_matrix(X)\n+\n     for mutual_info in (mutual_info_regression, mutual_info_classif):\n         assert_raises(ValueError, mutual_info_regression, X_csr, y,\n                       discrete_features=False)\n@@ -197,4 +230,4 @@ def test_mutual_info_options():\n         assert_array_equal(mi_1, mi_2)\n         assert_array_equal(mi_3, mi_4)\n \n-    assert not np.allclose(mi_1, mi_3)\n+    assert not np.allclose(mi_1, mi_3)\n",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..585f8e5 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,3 +1,4 @@\n+\n import re\n from pprint import PrettyPrinter\n \n@@ -7,6 +8,8 @@ from sklearn.utils._pprint import _EstimatorPrettyPrinter\n from sklearn.pipeline import make_pipeline\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.feature_selection import SelectKBest, chi2\n+import numpy as np\n+from sklearn.linear_model import LogisticRegressionCV\n from sklearn import set_config\n \n \n@@ -214,8 +217,22 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n \n     set_config(print_changed_only=False)\n \n-\n-def test_pipeline():\n+def test_logistic_regression_cv_array_params():\n+    \"\"\"Test LogisticRegressionCV with array parameters to ensure correct repr with print_changed_only\"\"\"\n+    set_config(print_changed_only=True)\n+    try:\n+        # Test with Cs being an array\n+        repr_out = repr(LogisticRegressionCV(Cs=np.array([0.1, 1.])))\n+\n+        # We can check that the repr does not contain the entire array but something meaningful\n+        assert 'LogisticRegressionCV(' in repr_out\n+        assert 'Cs=array([' in repr_out\n+        assert '0.1' in repr_out\n+        assert '1.' in repr_out\n+\n+    finally:\n+        # Reset config to default\n+        set_config(print_changed_only=False)\n     # Render a pipeline object\n     pipeline = make_pipeline(StandardScaler(), LogisticRegression(C=999))\n     expected = \"\"\"\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..bdf53b2 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,3 +1,37 @@\n+\n+@pytest.mark.parametrize(\n+    \"X, y, voter\",\n+    [(datasets.load_iris(return_X_y=True), VotingClassifier(\n+        [('lr', LogisticRegression()), \n+         ('rf', RandomForestClassifier(n_estimators=5))])),\n+     (datasets.load_boston(return_X_y=True), VotingRegressor(\n+         [('lr', LinearRegression()), \n+          ('rf', RandomForestRegressor(n_estimators=5))]))]\n+)\n+def test_none_estimator_with_weights(X, y, voter):\n+    # Check that an estimator can be set to None and passing some weight\n+    # This is a regression test for the issue mentioned\n+    voter.fit(X, y, sample_weight=np.ones(y.shape))\n+    voter.set_params(lr=None)\n+    voter.fit(X, y, sample_weight=np.ones(y.shape))\n+    y_pred = voter.predict(X)\n+    assert y_pred.shape == y.shape\n+\n+\n+@pytest.mark.parametrize(\n+    \"X, y, voter\",\n+    [(datasets.load_iris(return_X_y=True), VotingClassifier(\n+        [('lr', LogisticRegression(solver='liblinear')), \n+         ('rf', RandomForestClassifier(n_estimators=5))]))]\n+)\n+def test_none_estimator_without_weights(X, y, voter):\n+    # Additional test to confirm fit works even without sample weights\n+    voter.fit(X, y)\n+    voter.set_params(lr=None)\n+    voter.fit(X, y)\n+    y_pred = voter.predict(X)\n+    assert y_pred.shape == y.shape\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n@@ -10,6 +44,8 @@ from sklearn.utils.testing import assert_raise_message\n from sklearn.exceptions import NotFittedError\n from sklearn.linear_model import LogisticRegression\n from sklearn.naive_bayes import GaussianNB\n+from sklearn.linear_model import LinearRegression\n+from sklearn.ensemble import RandomForestRegressor\n from sklearn.ensemble import RandomForestClassifier\n from sklearn.ensemble import VotingClassifier, VotingRegressor\n from sklearn.model_selection import GridSearchCV\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "diff --git a/sklearn/neighbors/tests/test_nca.py b/sklearn/neighbors/tests/test_nca.py\nindex 3963eca..6fa44ac 100644\n--- a/sklearn/neighbors/tests/test_nca.py\n+++ b/sklearn/neighbors/tests/test_nca.py\n@@ -119,6 +119,22 @@ def test_finite_differences():\n     np.testing.assert_almost_equal(rel_diff, 0., decimal=5)\n \n \n+@pytest.mark.parametrize('param, value', [\n+    ('n_components', np.int64(5)),\n+    ('max_iter', np.int64(200)),\n+    ('tol', np.float32(0.001)),\n+])\n+def test_numpy_types_in_grid_search(param, value):\n+    # Check that np.int64 and np.float32 types work fine in GridSearchCV\n+    X, y = iris_data, iris_target\n+    nca = NeighborhoodComponentsAnalysis()\n+    knn = KNeighborsClassifier()\n+    pipe = Pipeline([('nca', nca), ('knn', knn)])\n+    params = {f'nca__{param}': [value]}\n+    gs = GridSearchCV(estimator=pipe, param_grid=params, error_score='raise')\n+    gs.fit(X, y)\n+\n+\n def test_params_validation():\n     # Test that invalid parameters raise value error\n     X = np.arange(12).reshape(4, 3)\n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..7c42971 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -679,6 +679,22 @@ def test_unicode_kernel():\n                                 kernel='linear',\n                                 random_seed=0)\n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for #14893\n+    from scipy import sparse\n+    import numpy as np\n+    from sklearn import svm\n+    \n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    assert not model.support_vectors_.size, \"Support vectors should be empty\"\n+    assert not model.dual_coef_.size, \"Dual coefficients should be empty\"\n+\n \n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n",
  "scikit-learn__scikit-learn-14983": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex dd52c66..b7d26b9 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -972,8 +972,19 @@ def test_leave_one_p_group_out_error_on_fewer_number_of_groups():\n                          LeavePGroupsOut(n_groups=3).split(X, y, groups))\n \n \n+import pytest\n+\n @ignore_warnings\n-def test_repeated_cv_value_errors():\n+def test_repeated_cv_repr_correctness():\n+    # Testing the __repr__ method for RepeatedKFold and RepeatedStratifiedKFold\n+    parametrize_args = [RepeatedKFold, RepeatedStratifiedKFold]\n+    for RepeatedCV in parametrize_args:\n+        n_splits, n_repeats = 5, 10\n+        repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats)\n+        expected_repr = (\n+            f'{repeated_cv.__class__.__name__}(n_repeats=10, n_splits=5, random_state=None)'\n+        )\n+        assert repr(repeated_cv) == expected_repr\n     # n_repeats is not integer or <= 0\n     for cv in (RepeatedKFold, RepeatedStratifiedKFold):\n         assert_raises(ValueError, cv, n_repeats=0)\n",
  "scikit-learn__scikit-learn-15512": "",
  "scikit-learn__scikit-learn-15535": "diff --git a/sklearn/metrics/cluster/tests/test_common.py b/sklearn/metrics/cluster/tests/test_common.py\nindex 9991cff..27936c7 100644\n--- a/sklearn/metrics/cluster/tests/test_common.py\n+++ b/sklearn/metrics/cluster/tests/test_common.py\n@@ -162,6 +162,8 @@ def test_format_invariance(metric_name):\n         yield y, 'array of ints'\n         yield y.tolist(), 'list of ints'\n         yield [str(x) for x in y.tolist()], 'list of strs'\n+        yield [str(x) + \"-a\" for x in y.tolist()], 'list of modified strs'\n+        yield (np.array([str(x) + \"-a\" for x in y.tolist()], dtype=object), 'array of strs')\n         yield y - 1, 'including negative ints'\n         yield y + 1, 'strictly positive ints'\n \n",
  "scikit-learn__scikit-learn-25500": "diff --git a/sklearn/tests/test_isotonic.py b/sklearn/tests/test_isotonic.py\nindex 5021282..72ea385 100644\n--- a/sklearn/tests/test_isotonic.py\n+++ b/sklearn/tests/test_isotonic.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n import numpy as np\n import pickle\n@@ -668,6 +669,22 @@ def test_isotonic_regression_sample_weight_not_overwritten():\n \n \n @pytest.mark.parametrize(\"shape\", [\"1d\", \"2d\"])\n+def test_calibrated_classifier_isotonic_with_pandas():\n+    \"\"\"Test CalibratedClassifierCV with isotonic regression and pandas output config.\"\"\"\n+    X, y = make_classification(n_samples=100, n_features=20, random_state=42)\n+    \n+    with set_config(transform_output=\"pandas\"):\n+        base_clf = SGDClassifier(random_state=42)\n+        calibrated_clf = CalibratedClassifierCV(base_clf, method='isotonic', cv=3)\n+        \n+        # Fit the model\n+        calibrated_clf.fit(X, y)\n+\n+        # Try to predict probabilities\n+        proba = calibrated_clf.predict_proba(X)\n+        assert proba is not None\n+        assert isinstance(proba, np.ndarray)  # Output should be a numpy array as required\n+\n def test_get_feature_names_out(shape):\n     \"\"\"Check `get_feature_names_out` for `IsotonicRegression`.\"\"\"\n     X = np.arange(10)\n",
  "scikit-learn__scikit-learn-25570": "",
  "sphinx-doc__sphinx-10325": "diff --git a/tests/test_ext_autodoc_automodule.py b/tests/test_ext_autodoc_automodule.py\nindex 787cd0c..866bda0 100644\n--- a/tests/test_ext_autodoc_automodule.py\n+++ b/tests/test_ext_autodoc_automodule.py\n@@ -113,6 +113,86 @@ def test_automodule_special_members(app):\n     ]\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_automodule_inherited_members_multiple_classes(app):\n+    if sys.version_info < (3, 7):\n+        args = ''\n+    else:\n+        args = '(iterable=(), /)'\n+\n+    # Test case for multiple base classes where some should be ignored\n+    options = {\n+        'members': None,\n+        'undoc-members': None,\n+        'inherited-members': 'Base, list'\n+    }\n+    actual = do_autodoc(app, 'module', 'target.inheritance', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.inheritance',\n+        '',\n+        '',\n+        '.. py:class:: Base()',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedclassmeth()',\n+        '      :module: target.inheritance',\n+        '      :classmethod:',\n+        '',\n+        '      Inherited class method.',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedmeth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      Inherited function.',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedstaticmeth(cls)',\n+        '      :module: target.inheritance',\n+        '      :staticmethod:',\n+        '',\n+        '      Inherited static method.',\n+        '',\n+        '',\n+        '.. py:class:: Derived()',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: Derived.inheritedmeth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      Inherited function.',\n+        '',\n+        '',\n+        '.. py:class:: MyList%s' % args,\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: MyList.meth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_automodule_ignore_specific_inherited_classes(app):\n+    # Another test case to ignore inheritance from list, set, and tuple\n+    options = {\n+        'members': None,\n+        'undoc-members': None,\n+        'inherited-members': 'list, set, tuple'\n+    }\n+    actual = do_autodoc(app, 'module', 'target.other_inheritance', options)\n+    assert '.. py:class:: CustomList()' in actual\n+    assert '.. py:method:: CustomList.custom_meth()' in actual\n+    assert '.. py:method:: CustomList.append' not in actual  # Should not document list methods\n+    assert '.. py:method:: CustomList.add' not in actual  # Should not document set methods\n+    assert '.. py:method:: CustomList.count' not in actual  # Should not document tuple methods\n+\n+\n @pytest.mark.sphinx('html', testroot='ext-autodoc',\n                     confoverrides={'autodoc_mock_imports': ['missing_module',\n                                                             'missing_package1',\n@@ -125,4 +205,225 @@ def test_subclass_of_mocked_object(app):\n \n     options = {'members': None}\n     actual = do_autodoc(app, 'module', 'target.need_mocks', options)\n-    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n",
  "sphinx-doc__sphinx-7975": "",
  "sphinx-doc__sphinx-8435": "",
  "sphinx-doc__sphinx-8506": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 08bd595..aa15cad 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -91,6 +91,69 @@ def test_get_full_qualified_name():\n     assert domain.get_full_qualified_name(node) == 'ls.-l'\n \n \n+from sphinx import addnodes\n+from sphinx.testing.util import assert_node\n+from sphinx.util.docutils import new_document\n+import restructuredtext_lint\n+\n+def parse_rst(app, text):\n+    \"\"\"Helper function to parse reStructuredText.\"\"\"\n+    doc = new_document('test', app.env.settings)\n+    restructuredtext_lint.lint(text, filepath='test')\n+    app.env.prepare_settings(doc)\n+    return app.env.get_parsed_doctree('test', text)\n+\n+def test_cmd_option_with_optional_value(app):\n+    text = \".. option:: -j[=N]\"\n+    doctree = parse_rst(app, text)\n+    assert_node(doctree, (addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '-j'],\n+                                                                     [addnodes.desc_addname, '[=N]'])],\n+                                          [addnodes.desc_content, ()])))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('-j', '-j', 'cmdoption', 'index', 'cmdoption-j', 1) in objects\n+\n+def test_cmd_option_starting_with_bracket(app):\n+    text = \".. option:: [enable=]PATTERN\"\n+    doctree = parse_rst(app, text)\n+    assert_node(doctree, (addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '[enable'],\n+                                                                     [addnodes.desc_addname, '=]PATTERN'])],\n+                                          [addnodes.desc_content, ()])))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('[enable', '[enable', 'cmdoption', 'index', 'cmdoption-arg-enable', 1) in objects\n+\n+def test_cmd_option_with_no_value(app):\n+    text = \".. option:: --verbose\"\n+    doctree = parse_rst(app, text)\n+    assert_node(doctree, (addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '--verbose'])],\n+                                          [addnodes.desc_content, ()])))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('--verbose', '--verbose', 'cmdoption', 'index', 'cmdoption-verbose', 1) in objects\n+\n+def test_cmd_option_with_value(app):\n+    text = \".. option:: --output=FILE\"\n+    doctree = parse_rst(app, text)\n+    assert_node(doctree, (addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '--output'],\n+                                                                     [addnodes.desc_addname, '=FILE'])],\n+                                          [addnodes.desc_content, ()])))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('--output', '--output', 'cmdoption', 'index', 'cmdoption-output', 1) in objects\n+\n+def test_cmd_option_with_plus_prefix(app):\n+    text = \".. option:: +enable-feature\"\n+    doctree = parse_rst(app, text)\n+    assert_node(doctree, (addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '+enable-feature'])],\n+                                          [addnodes.desc_content, ()])))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('+enable-feature', '+enable-feature', 'cmdoption', 'index', 'cmdoption-enable-feature', 1) in objects\n+\n+def test_cmd_option_with_forward_slash(app):\n+    text = \".. option:: /CONFIG\"\n+    doctree = parse_rst(app, text)\n+    assert_node(doctree, (addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '/CONFIG'])],\n+                                          [addnodes.desc_content, ()])))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('/CONFIG', '/CONFIG', 'cmdoption', 'index', 'cmdoption-CONFIG', 1) in objects\n+\n def test_glossary(app):\n     text = (\".. glossary::\\n\"\n             \"\\n\"\n",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..51d941d 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -21,6 +21,7 @@ from sphinx.ext.autodoc import ALL, ModuleLevelDocumenter, Options\n from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n from sphinx.testing.util import SphinxTestApp, Struct  # NOQA\n from sphinx.util.docutils import LoggingReporter\n+from .test_ext_autodoc import do_autodoc\n \n try:\n     # Enable pyximport to test cython module\n@@ -45,6 +46,22 @@ def do_autodoc(app, objtype, name, options=None):\n     return bridge.result\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_autodoc_with_empty_all(app):\n+    \"\"\"\n+    Test case for verifying behavior when __all__ is empty.\n+    \"\"\"\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.example', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.example',\n+        '',\n+        # Since __all__ is empty, the members (foo, bar, baz) should not be documented.\n+        # Therefore, the list should only contain the module directive and nothing else.\n+    ]\n+\n+\n def make_directive_bridge(env):\n     options = Options(\n         inherited_members = False,\n",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..7e7c2f8 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -15,6 +16,7 @@ from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tup\n \n import pytest\n \n+from struct import Struct\n from sphinx.util.typing import restify, stringify\n \n \n@@ -48,6 +50,7 @@ def test_restify():\n \n def test_restify_type_hints_containers():\n     assert restify(List) == \":class:`List`\"\n+    assert restify(Struct) == \":class:`struct.Struct`\"\n     assert restify(Dict) == \":class:`Dict`\"\n     assert restify(List[int]) == \":class:`List`\\\\ [:class:`int`]\"\n     assert restify(List[str]) == \":class:`List`\\\\ [:class:`str`]\"\n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..50d8125 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1435,6 +1435,30 @@ class NumpyDocstringTest(BaseDocstringTest):\n         \"\"\")\n         self.assertEqual(expected, actual)\n \n+    def test_other_parameters_section(self):\n+        # Test when napoleon_use_param is False (default formatting)\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+\n+\"\"\"\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param2** (:class:`MyClass <name.space.MyClass>` instance)\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        # Test when napoleon_use_param is True (use :param: and :type:)\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param param2:\n+:type param2: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n     def test_parameters_with_class_reference(self):\n         docstring = \"\"\"\\\n Parameters\n",
  "sphinx-doc__sphinx-8721": "",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..3c4f624 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -354,6 +354,24 @@ def test_args():\n     # but this is ok because cycles imply that only those listed moved\n     assert Permutation(4, 5) == Permutation([0, 1, 2, 3, 5, 4])\n \n+def test_non_disjoint_cycles():\n+    # Test with non-disjoint cycles that should form the identity permutation\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n+    \n+    # Test with overlapping cycles applied in sequence\n+    assert Permutation([[0, 1], [1, 2]]) == Permutation([1, 2, 0])\n+    assert Permutation([[2, 3, 4], [3, 5]]) == Permutation([0, 1, 3, 5, 2, 4])\n+    \n+    # Test with multiple overlapping cycles\n+    assert Permutation([[0, 2], [1, 2], [1, 3]]) == Permutation([2, 3, 0, 1])\n+    \n+    # Test identity permutation with empty cycle\n+    assert Permutation([[]]) == Permutation([])\n+    assert Permutation([[], [0, 1]]) == Permutation([1, 0])\n+    \n+    # Ensure no error is raised for cycles that technically overlap but are redundant\n+    assert Permutation([[0, 2], [2, 0]]) == Permutation([0, 2])\n+    assert Permutation([[1, 3], [0, 1], [3, 1]]) == Permutation([1, 0, 2, 3])\n \n def test_Cycle():\n     assert str(Cycle()) == '()'\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..4050bb4 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -1,3 +1,4 @@\n+\n from sympy import Abs, S, Symbol, I, Rational, PurePoly\n from sympy.matrices import Matrix, SparseMatrix, eye, zeros, ShapeError\n from sympy.utilities.pytest import raises\n@@ -448,6 +449,21 @@ def test_sparse_matrix():\n     assert A.col_list() == [(0, 0, 18), (4, 2, 19), (6, 2, 12), (1, 4, 18), (2, 7, 16), (5, 7, 16), (9, 7, 18), (0, 9, 12), (3, 9, 12)]\n     assert SparseMatrix.eye(2).nnz() == 2\n \n+def test_issue_12345_hstack_vstack_zero_row_matrices():\n+    # Verify hstack behavior with zero-row matrices\n+    M1 = SparseMatrix.zeros(0, 0)\n+    M2 = SparseMatrix.zeros(0, 1)\n+    M3 = SparseMatrix.zeros(0, 2)\n+    M4 = SparseMatrix.zeros(0, 3)\n+    assert SparseMatrix.hstack(M1, M2, M3, M4) == SparseMatrix(0, 6, [])\n+\n+    # Verify vstack behavior with zero-column matrices\n+    M1 = SparseMatrix.zeros(1, 0)\n+    M2 = SparseMatrix.zeros(2, 0)\n+    M3 = SparseMatrix.zeros(3, 0)\n+    M4 = SparseMatrix.zeros(0, 0)\n+    assert SparseMatrix.vstack(M1, M2, M3, M4) == SparseMatrix(6, 0, [])\n+\n \n def test_transpose():\n     assert SparseMatrix(((1, 2), (3, 4))).transpose() == \\\n",
  "sympy__sympy-13471": "diff --git a/sympy/utilities/tests/test_pickling.py b/sympy/utilities/tests/test_pickling.py\nindex 52dcc20..ee285c6 100644\n--- a/sympy/utilities/tests/test_pickling.py\n+++ b/sympy/utilities/tests/test_pickling.py\n@@ -101,6 +101,15 @@ def test_core_symbol():\n \n \n def test_core_numbers():\n+    from sympy import symbols, Float\n+    import pickle\n+    \n+    x = symbols(\"x\")\n+    # Test pickling and unpickling an expression with a Float\n+    expr_p2 = pickle.dumps(x + 1.0, 2)\n+    expr_p3 = pickle.loads(expr_p2)\n+    \n+    assert expr_p3 == x + Float(1.0)\n     for c in (Integer(2), Rational(2, 3), Float(\"1.2\")):\n         check(c)\n \n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..7c9287e 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -267,6 +267,29 @@ def test_coth():\n \n     assert coth(x*I) == -cot(x)*I\n \n+    # Tests for issue with coth(log(tan(x)))\n+    from sympy import log, tan, coth, Symbol, pi, I\n+\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+\n+    # Test with integral values\n+    assert e.subs(x, 2) == coth(log(tan(2)))\n+    assert e.subs(x, 3) == coth(log(tan(3)))\n+    assert e.subs(x, 5) == coth(log(tan(5)))\n+    assert e.subs(x, 6) == coth(log(tan(6)))\n+    assert e.subs(x, 8) == coth(log(tan(8)))\n+    assert e.subs(x, 9) == coth(log(tan(9)))\n+    assert e.subs(x, 11) == coth(log(tan(11)))\n+    assert e.subs(x, 12) == coth(log(tan(12)))\n+    assert e.subs(x, 13) == coth(log(tan(13)))\n+    assert e.subs(x, 15) == coth(log(tan(15)))\n+    assert e.subs(x, 18) == coth(log(tan(18)))\n+\n+    # Additional check around problematic values\n+    assert e.subs(x, pi/2) == coth(log(tan(pi/2)))\n+    assert e.subs(x, pi*I/2) == coth(log(tan(pi*I/2)))\n+\n     assert coth(k*pi*I) == -cot(k*pi)*I\n     assert coth(17*k*pi*I) == -cot(17*k*pi)*I\n \n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..739d90d 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -201,6 +201,23 @@ def test_col_insert():\n         l.insert(i, 4)\n         assert flatten(zeros_Shaping(3).col_insert(i, c4).row(0).tolist()) == l\n \n+def test_matrix_col_insert():\n+    from sympy import Matrix, eye, ones\n+\n+    # Test case as described in the issue\n+    M = eye(6)\n+    V = 2 * ones(6, 2)\n+    result = M.col_insert(3, V)\n+    expected = Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    assert result == expected, f\"Expected {expected}, but got {result}\"\n+\n def test_extract():\n     m = ShapingOnlyMatrix(4, 3, lambda i, j: i*3 + j)\n     assert m.extract([0, 1, 3], [0, 1]) == Matrix(3, 2, [0, 1, 3, 4, 9, 10])\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..f6139ea 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -620,46 +620,46 @@ def test_latex_sequences():\n     s1 = SeqFormula(a**2, (0, oo))\n     s2 = SeqPer((1, 2))\n \n-    latex_str = r'\\left\\[0, 1, 4, 9, \\ldots\\right\\]'\n+    latex_str = r'[0, 1, 4, 9, \\ldots]'\n     assert latex(s1) == latex_str\n \n-    latex_str = r'\\left\\[1, 2, 1, 2, \\ldots\\right\\]'\n+    latex_str = r'[1, 2, 1, 2, \\ldots]'\n     assert latex(s2) == latex_str\n \n     s3 = SeqFormula(a**2, (0, 2))\n     s4 = SeqPer((1, 2), (0, 2))\n \n-    latex_str = r'\\left\\[0, 1, 4\\right\\]'\n+    latex_str = r'[0, 1, 4]'\n     assert latex(s3) == latex_str\n \n-    latex_str = r'\\left\\[1, 2, 1\\right\\]'\n+    latex_str = r'[1, 2, 1]'\n     assert latex(s4) == latex_str\n \n     s5 = SeqFormula(a**2, (-oo, 0))\n     s6 = SeqPer((1, 2), (-oo, 0))\n \n-    latex_str = r'\\left\\[\\ldots, 9, 4, 1, 0\\right\\]'\n+    latex_str = r'[\\ldots, 9, 4, 1, 0]'\n     assert latex(s5) == latex_str\n \n-    latex_str = r'\\left\\[\\ldots, 2, 1, 2, 1\\right\\]'\n+    latex_str = r'[\\ldots, 2, 1, 2, 1]'\n     assert latex(s6) == latex_str\n \n-    latex_str = r'\\left\\[1, 3, 5, 11, \\ldots\\right\\]'\n+    latex_str = r'[1, 3, 5, 11, \\ldots]'\n     assert latex(SeqAdd(s1, s2)) == latex_str\n \n-    latex_str = r'\\left\\[1, 3, 5\\right\\]'\n+    latex_str = r'[1, 3, 5]'\n     assert latex(SeqAdd(s3, s4)) == latex_str\n \n-    latex_str = r'\\left\\[\\ldots, 11, 5, 3, 1\\right\\]'\n+    latex_str = r'[\\ldots, 11, 5, 3, 1]'\n     assert latex(SeqAdd(s5, s6)) == latex_str\n \n-    latex_str = r'\\left\\[0, 2, 4, 18, \\ldots\\right\\]'\n+    latex_str = r'[0, 2, 4, 18, \\ldots]'\n     assert latex(SeqMul(s1, s2)) == latex_str\n \n-    latex_str = r'\\left\\[0, 2, 4\\right\\]'\n+    latex_str = r'[0, 2, 4]'\n     assert latex(SeqMul(s3, s4)) == latex_str\n \n-    latex_str = r'\\left\\[\\ldots, 18, 4, 2, 0\\right\\]'\n+    latex_str = r'[\\ldots, 18, 4, 2, 0]'\n     assert latex(SeqMul(s5, s6)) == latex_str\n \n \n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..9113420 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +7,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n@@ -188,6 +189,22 @@ def test_Domain_preprocess():\n \n     raises(OptionError, lambda: Domain.preprocess('Z()'))\n \n+    # Additional test cases for issue verification\n+    assert Domain.preprocess('RR[y]') == RR[y]\n+    assert Domain.preprocess('RR[y,z]') == RR[y, z]\n+    assert Domain.preprocess('CC[y,z]') == CC[y, z]\n+\n+    try:\n+        expr = 1.2*x*y*z\n+        poly = Poly(expr, x, domain='RR[y,z]')\n+        assert poly == Poly(expr, x, domain=RR[y, z])\n+    except OptionError as e:\n+        raise AssertionError(f\"Expected 'Poly' to succeed, but got an error: {e}\")\n+\n+    # Test error message improvement\n+    raises(OptionError, lambda: Domain.preprocess('NonExistentDomain'),\n+           match=\"expected a valid domain specification, got NonExistentDomain\")\n+\n     assert Domain.preprocess('Z(x)') == ZZ.frac_field(x)\n     assert Domain.preprocess('Q(x)') == QQ.frac_field(x)\n \n",
  "sympy__sympy-14774": "",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..0c2a5d3 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6111,7 +6111,21 @@ u(\"\"\"\\\n     assert upretty((1/y)*e.j) == ucode_str\n \n \n-def test_MatrixSymbol_printing():\n+from sympy import MatrixSymbol, pretty\n+\n+def test_MatrixSymbol_pretty_printing_issue_14814():\n+    # issue #14814 test cases\n+    n = 3  # assuming n as a known dimension\n+    x = MatrixSymbol('x', n, n)\n+    y_star = MatrixSymbol('y*', n, n)\n+\n+    # Test pretty printing with special character in the matrix symbol\n+    assert pretty(x + y_star) == \"x + y*\"\n+\n+    # Additional test to ensure minus sign works as expected\n+    a = MatrixSymbol('a', n, n)\n+    y = MatrixSymbol('y', n, n)\n+    assert pretty(-a*x + -2*y*y_star) == \"-a*x - 2*y*y*\"\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n     B = MatrixSymbol(\"B\", 3, 3)\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..e41b288 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -724,6 +724,27 @@ def test_dummification():\n     #Test that \\alpha was properly dummified\n     lam = lambdify((alpha, t), 2*alpha + t)\n     assert lam(2, 1) == 5\n+\n+def test_curly_matrix_symbol():\n+    # Issue #15009\n+    import sympy\n+    curlyv = sympy.MatrixSymbol(\"{v}\", 2, 1)\n+    \n+    # Test lambdify without dummify\n+    try:\n+        lam = sympy.lambdify(curlyv, curlyv)\n+        result = lam(1)\n+        assert result == 1\n+    except SyntaxError:\n+        assert False, \"SyntaxError raised unexpectedly without dummify.\"\n+\n+    # Test lambdify with dummify=True\n+    try:\n+        lam_dummified = sympy.lambdify(curlyv, curlyv, dummify=True)\n+        result_dummified = lam_dummified(1)\n+        assert result_dummified == 1\n+    except SyntaxError:\n+        assert False, \"SyntaxError raised unexpectedly with dummify=True.\"\n     raises(SyntaxError, lambda: lambdify(F(t) * G(t), F(t) * G(t) + 5))\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 2 * F(t) + 5))\n     raises(SyntaxError, lambda: lambdify(2 * F(t), 4 * F(t) + 5))\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..b2243b5 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n@@ -23,6 +24,16 @@ def test_Rational():\n     assert mcode(x + Rational(3, 7)) == \"x + 3/7\"\n     assert mcode(Rational(3, 7)*x) == \"(3/7)*x\"\n \n+def test_Max():\n+    # Test single Max with symbolic and numeric arguments\n+    assert mcode(Max(x, 2)) == \"Max[x, 2]\"\n+    # Test Max with multiple arguments\n+    assert mcode(Max(x, y, 3)) == \"Max[x, y, 3]\"\n+    # Ensure consistency when reordering arguments\n+    assert mcode(Max(3, x, y)) == \"Max[3, x, y]\"\n+    # Test with Min to check multiple functions\n+    assert mcode(Max(x, y) + Min(x, y)) == \"Max[x, y] + Min[x, y]\"\n+\n \n def test_Function():\n     assert mcode(f(x, y, z)) == \"f[x, y, z]\"\n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..827ad76 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1717,6 +1717,15 @@ def test_issue_13651():\n     assert latex(expr) == r\"c - \\left(a + b\\right)\"\n \n \n+def test_indexed_matrix_expression_printing():\n+    # Test for the issue with double subscript\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n+\n+from sympy import symbols, MatrixSymbol, latex\n+\n def test_latex_UnevaluatedExpr():\n     x = symbols(\"x\")\n     he = UnevaluatedExpr(1/x)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..a14831c 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, exp, Eq\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -21,7 +22,26 @@ def test_idiff():\n     assert idiff(x + t + y, [y, t], x) == -Derivative(t, x) - 1\n \n \n-def test_intersection():\n+def test_idiff_original_issue_cases():\n+    x = Symbol('x', real=True)\n+    y = Symbol('y', real=True)\n+    f = Function('f')\n+    g = Function('g')\n+\n+    # Test idiff with Eq (equation object)\n+    eq = Eq(y*exp(y), x*exp(x))\n+    result = idiff(eq, y, x)\n+    assert result == (x + 1)*exp(x - y)/(y + 1)\n+    \n+    # Test idiff with function\n+    eq_func = f(x)*exp(f(x)) - x*exp(x)\n+    result_func = idiff(eq_func, f(x), x)\n+    assert result_func == (x + 1)*exp(x - f(x))/(f(x) + 1)\n+\n+    # Additional test cases from original patch\n+    assert idiff(f(x) - y * exp(x), [f(x), y], x) == (y + Derivative(y, x)) * exp(x)\n+    assert idiff(f(x) - y * exp(x), [y, f(x)], x) == -y + exp(-x) * Derivative(f(x), x)\n+    assert idiff(f(x) - g(x), [f(x), g(x)], x) == Derivative(g(x), x)\n     assert intersection(Point(0, 0)) == []\n     raises(TypeError, lambda: intersection(Point(0, 0), 3))\n     assert intersection(\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_codegen.py b/sympy/utilities/tests/test_codegen.py\nindex 6bc2605..80a6670 100644\n--- a/sympy/utilities/tests/test_codegen.py\n+++ b/sympy/utilities/tests/test_codegen.py\n@@ -582,6 +582,17 @@ def test_ccode_cse():\n     )\n     assert source == expected\n \n+from sympy.utilities.autowrap import autowrap\n+from sympy import MatrixSymbol\n+import numpy as np\n+\n+def test_autowrap_unused_array_arg_cython():\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0  # x does not appear in the expression\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    result = f(np.array([[1.0], [2.0]]))\n+    assert result == 1.0\n+\n def test_empty_f_code():\n     code_gen = FCodeGen()\n     source = get_string(code_gen.dump_f95, [])\n",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..64446b6 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -339,6 +339,13 @@ def test_intersection():\n \n     assert Intersection(S.Complexes, FiniteSet(S.ComplexInfinity)) == S.EmptySet\n \n+    # Additional test cases for issue: Intersection should remove duplicates\n+    x = Symbol('x')\n+    assert Intersection({1}, {1}, {x}) == Intersection({1}, {x})\n+    assert Intersection({1}, {1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    assert Intersection({1, 1, 1}, {1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+    assert Intersection({1, 2, 3}, {1, 2}, {2, 3}) == {2}\n+\n     # issue 12178\n     assert Intersection() == S.UniversalSet\n \n",
  "sympy__sympy-17022": "diff --git a/sympy/printing/tests/test_numpy.py b/sympy/printing/tests/test_numpy.py\nindex fa5ed1f..aa21df3 100644\n--- a/sympy/printing/tests/test_numpy.py\n+++ b/sympy/printing/tests/test_numpy.py\n@@ -1,9 +1,14 @@\n+\n from sympy import (\n     Piecewise, lambdify, Equality, Unequality, Sum, Mod, cbrt, sqrt,\n     MatrixSymbol, BlockMatrix\n )\n from sympy import eye\n-from sympy.abc import x, i, j, a, b, c, d\n+from sympy.abc import x, i, j, a, b, c, d, n\n+from sympy import symbols, Identity\n+from sympy.utilities.pytest import raises\n+from sympy.matrices import MatrixSymbol\n+import numpy as np\n from sympy.codegen.cfunctions import log1p, expm1, hypot, log10, exp2, log2, Cbrt, Sqrt\n from sympy.codegen.array_utils import (CodegenArrayContraction,\n         CodegenArrayTensorProduct, CodegenArrayDiagonal,\n@@ -15,8 +20,21 @@ from sympy.utilities.pytest import skip\n from sympy.external import import_module\n \n np = import_module('numpy')\n+def test_lambdify_identity_matrix():\n+    if not np:\n+        skip(\"NumPy not installed\")\n \n-def test_numpy_piecewise_regression():\n+    # Test case for fixed behavior\n+    M = MatrixSymbol(\"M\", 2, 2)\n+    f = lambdify(M, M + Identity(2))\n+    ma = np.array([[1, 2], [3, 4]])\n+    mr = np.array([[2, 2], [3, 5]])\n+    assert (f(ma) == mr).all()\n+\n+    # Test case for correct error handling with symbolic dimensions\n+    n = symbols('n', integer=True)\n+    N = MatrixSymbol(\"N\", n, n)\n+    raises(NotImplementedError, lambda: lambdify(N, N + Identity(n)))\n     \"\"\"\n     NumPyPrinter needs to print Piecewise()'s choicelist as a list to avoid\n     breaking compatibility with numpy 1.8. This is not necessary in numpy 1.9+.\n",
  "sympy__sympy-17139": "",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..0f88626 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy import I, Rational, Symbol, pi, sqrt, S\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n@@ -5,8 +6,16 @@ from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.pytest import raises, warns\n \n+from sympy import sympify\n \n def test_point():\n+\n+    # Test multiplying Point by scalar (both orders)\n+    point1 = Point(0, 0)\n+    point2 = Point(1, 1)\n+\n+    assert point1 + point2 * sympify(2.0) == Point(2, 2)\n+    assert point1 + sympify(2.0) * point2 == Point(2, 2)\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..e0c641e 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1894,12 +1894,33 @@ def test_normal():\n     assert e.normal() == e\n \n \n+from sympy import Symbol, symbols, sympify\n+import pytest\n+\n def test_expr():\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n \n \n-def test_ExprBuilder():\n+def test_syms_eq_repr_issue():\n+    x = Symbol('x')\n+\n+    class C:\n+        def __repr__(self):\n+            return 'x.y'\n+    \n+    # This should not raise an AttributeError\n+    try:\n+        result = x == C()\n+    except AttributeError:\n+        pytest.fail(\"SymPy __eq__ method raised AttributeError unexpectedly!\")\n+\n+    class D:\n+        def __repr__(self):\n+            return 'x'\n+    \n+    # This should not incorrectly compare as equal\n+    assert (x == D()) is False, \"SymPy __eq__ method incorrectly evaluated __repr__ as equal to symbol.\"\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..33a5b94 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -547,8 +547,15 @@ def test_diophantine():\n     assert diophantine(x**2 + y**2 +3*x- 5, permute=True) == \\\n         set([(-1, 1), (-4, -1), (1, -1), (1, 1), (-4, 1), (-1, -1), (4, 1), (4, -1)])\n \n-    # issue 18122\n-    assert check_solutions(x**2-y)\n+    # issue 18186\n+    from sympy import symbols\n+    x, y = symbols('x y', integer=True)\n+    assert diophantine(y**4 + x**4 - 2**4 - 3**4, syms=(x, y), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+    assert diophantine(y**4 + x**4 - 2**4 - 3**4, syms=(y, x), permute=True) == \\\n+        set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+\n+    # Ensure consistency with other tests\n     assert check_solutions(y**2-x)\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n     assert diophantine((y**2-x), t) == set([(t**2, -t)])\n",
  "sympy__sympy-18532": "diff --git a/sympy/codegen/tests/test_cnodes.py b/sympy/codegen/tests/test_cnodes.py\nindex c30dccd..4ce73ec 100644\n--- a/sympy/codegen/tests/test_cnodes.py\n+++ b/sympy/codegen/tests/test_cnodes.py\n@@ -1,6 +1,7 @@\n+\n from sympy.core.symbol import symbols\n from sympy.printing.ccode import ccode\n-from sympy.codegen.ast import Declaration, Variable, float64, int64\n+from sympy.codegen.ast import Declaration, Variable, float64, int64, String, Basic\n from sympy.codegen.cnodes import (\n     alignof, CommaOperator, goto, Label, PreDecrement, PostDecrement, PreIncrement, PostIncrement,\n     sizeof, union, struct\n@@ -61,6 +62,15 @@ def test_PostIncrement():\n \n \n def test_sizeof():\n+    typename = 'unsigned int'\n+    sz = sizeof(typename)\n+    assert ccode(sz) == 'sizeof(%s)' % typename\n+    assert sz.func(*sz.args) == sz\n+    assert not sz.is_Atom\n+    # Modified test case to check for strings\n+    assert sz.atoms() == {String('unsigned int'), String('sizeof')}\n+\n+def test_atoms_correct_behavior():\n     typename = 'unsigned int'\n     sz = sizeof(typename)\n     assert ccode(sz) == 'sizeof(%s)' % typename\n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..902cf77 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,35 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_block_diag_matrix_single_block():\n+    # Import necessary function from sympy\n+    from sympy import Matrix, BlockDiagMatrix\n+\n+    # Test case for a single matrix element in BlockDiagMatrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    try:\n+        B = Matrix(D)\n+        assert B == M\n+    except Exception as e:\n+        assert False, f\"Exception occurred: {e}\"\n+\n+def test_block_diag_matrix_multiple_blocks():\n+    # Import necessary function from sympy\n+    from sympy import Matrix, BlockDiagMatrix\n+\n+    # Test case for multiple matrix elements in BlockDiagMatrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M, M)\n+    B = Matrix(D)\n+    expected = Matrix([\n+        [1, 2, 0, 0],\n+        [3, 4, 0, 0],\n+        [0, 0, 1, 2],\n+        [0, 0, 3, 4]\n+    ])\n+    assert B == expected\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..2c12028 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,7 +1,8 @@\n+\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n-from sympy.testing.pytest import raises\n+from sympy.testing.pytest import raises, XFAIL\n from sympy.matrices.expressions.matexpr import MatrixElement, MatrixExpr\n \n k, l, m, n = symbols('k l m n', integer=True)\n",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..3a4bcb9 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -200,7 +200,24 @@ def test_im():\n     X = FunctionMatrix(3, 3, Lambda((n, m), n + m*I))\n     assert im(X) == Matrix([[0, 1, 2], [0, 1, 2], [0, 1, 2]])\n \n+from sympy import sign, Abs, Piecewise, Symbol, Eq, I, S\n+\n def test_sign():\n+    # Test the rewrite of sign to Abs\n+    y = Symbol('y')\n+    assert sign(y).rewrite(Abs) == Piecewise((0, Eq(y, 0)), (y/Abs(y), True))\n+\n+    f = Symbol('f', complex=True)\n+    assert sign(f).rewrite(Abs) == Piecewise((0, Eq(f, 0)), (f/Abs(f), True))\n+\n+    x = Symbol('x', real=True)\n+    assert sign(x).rewrite(Abs) == Piecewise((0, Eq(x, 0)), (x/Abs(x), True))\n+\n+    x_nonzero = Symbol('x', real=True, nonzero=True)\n+    assert sign(x_nonzero).rewrite(Abs) == x_nonzero / Abs(x_nonzero)\n+\n+    x_zero = Symbol('x', real=True, zero=True)\n+    assert sign(x_zero).rewrite(Abs) == 0\n     assert sign(1.2) == 1\n     assert sign(-1.2) == -1\n     assert sign(3*I) == I\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..e4d3eaa 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -471,7 +471,22 @@ def test_multiset_permutations():\n         6\\n''')\n \n \n+from sympy.utilities.iterables import partitions\n+from sympy import S\n+\n def test_partitions():\n+    # Test to ensure that partitions() do not reuse the same output dictionary\n+    results = list(partitions(6, k=2))\n+    results_2 = list(partitions(6, k=2))\n+    assert all(p is not q for p, q in zip(results, results_2)), \"Dictionaries should not be reused.\"\n+\n+    results = list(partitions(6, k=3))\n+    results_2 = list(partitions(6, k=3))\n+    assert all(p is not q for p, q in zip(results, results_2)), \"Dictionaries should not be reused.\"\n+\n+    results = list(partitions(8, k=4, m=3))\n+    results_2 = list(partitions(8, k=4, m=3))\n+    assert all(p is not q for p, q in zip(results, results_2)), \"Dictionaries should not be reused.\"\n     ans = [[{}], [(0, {})]]\n     for i in range(2):\n         assert list(partitions(0, size=i)) == ans[i]\n",
  "sympy__sympy-20212": "diff --git a/sympy/core/tests/test_power.py b/sympy/core/tests/test_power.py\nindex 686973b..b66be46 100644\n--- a/sympy/core/tests/test_power.py\n+++ b/sympy/core/tests/test_power.py\n@@ -254,7 +254,10 @@ def test_power_rewrite_exp():\n                     (sin, cos, tan, sec, csc, sinh, cosh, tanh))\n \n \n-def test_zero():\n+def test_issue_19572():\n+    # Test issue where 0**-oo was incorrectly returning 0 instead of zoo\n+    assert 0**-oo == S.ComplexInfinity\n+    assert power(0, -oo) == S.ComplexInfinity\n     x = Symbol('x')\n     y = Symbol('y')\n     assert 0**x != 0\n",
  "sympy__sympy-20442": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 6a8906d..a37adbb 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (Abs, Add, Function, Number, Rational, S, Symbol,\n                    diff, exp, integrate, log, sin, sqrt, symbols)\n from sympy.physics.units import (amount_of_substance, convert_to, find_unit,\n@@ -41,6 +42,30 @@ def test_convert_to():\n     # assert (2*speed_of_light).convert_to(m / s) == 2 * 299792458 * m / s\n     assert day.convert_to(s) == 86400*s\n \n+    # Test cases for the convert_to issue with orthogonal units\n+\n+    # Test if converting joule*second to joule returns the original expression\n+    expr = joule * second\n+    conv = convert_to(expr, joule)\n+    assert conv == joule * second, f\"Expected joule*second, got {conv}\"\n+\n+    # Additional test cases to verify expected behavior\n+\n+    # Convert joule*second to joule*second (should return the same expression)\n+    conv = convert_to(expr, joule * second)\n+    assert conv == expr, f\"Expected {expr}, got {conv}\"\n+\n+    # Convert joule*second to base units (kg*m**2/s), expecting conversion to base units\n+    conv = convert_to(joule*second, kg*m**2/s)\n+    assert conv == kg*m**2/s, f\"Expected kg*m**2/s, got {conv}\"\n+\n+    # Convert joule*second to minutes, expecting an expression scaled appropriately\n+    from sympy import Rational\n+    minute = Rational(60) * second\n+    conv = convert_to(joule*second, minute)\n+    expected_result = joule * minute / 60\n+    assert conv == expected_result, f\"Expected {expected_result}, got {conv}\"\n+\n     # Wrong dimension to convert:\n     assert q.convert_to(s) == q\n     assert speed_of_light.convert_to(m) == speed_of_light\n",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..9de7864 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -28,6 +28,23 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+from sympy import Symbol\n+from pytest import raises\n+\n+def test_symbol_dict_presence():\n+    # Ensure that Symbol instances have a __dict__ attribute from version 1.7 onwards\n+    s = Symbol('s')\n+    assert hasattr(s, '__dict__')\n+    assert s.__dict__ == {}\n+\n+    # Ensure the __slots__ are still being used properly\n+    assert hasattr(s, '__slots__')\n+    assert 'name' in s.__slots__\n+\n+    # Verify that assigning to an invalid attribute raises an AttributeError\n+    with raises(AttributeError):\n+        s.some_random_attr = 1\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..fc4b784 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n                    atan, atan2, nan, Symbol, re, im, sign)\n from sympy.abc import w, x, y, z\n@@ -161,7 +162,20 @@ def test_sign():\n     assert refine(sign(x), Q.zero(x)) == 0\n \n \n-def test_func_args():\n+def test_arg():\n+    x = Symbol('x', complex=True)\n+    a = Symbol('a', positive=True, real=True)\n+    \n+    # Test if refine simplifies arg(x) under different assumptions\n+    assert refine(arg(x), Q.positive(x)) == 0\n+    assert refine(arg(x), Q.negative(x)) == pi\n+    assert refine(arg(a), Q.positive(a)) == 0\n+    assert refine(arg(-a), Q.positive(a)) == pi\n+\n+    # Additional tests for the specific issue\n+    J = Integral(sin(x) * exp(-a * x), (x, 0, oo))\n+    refined_result = refine(J.doit(), Q.positive(a))\n+    assert refined_result == 1 / (a**2 + 1), \"Failed to refine the integral under Q.positive(a)\"\n     class MyClass(Expr):\n         # A class with nontrivial .func\n \n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..da0a6b9 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -9,6 +10,31 @@ from sympy.testing.pytest import XFAIL\n from sympy.abc import a, x, y, z, t\n \n def test_subs():\n+    # Test for issue related to unexpected PolynomialError with subs\n+    from sympy.functions.elementary.hyperbolic import sinh\n+    from sympy.functions.elementary.piecewise import Piecewise\n+\n+    # Case 1: Symbols without assumptions\n+    x, y, z = symbols('x y z')\n+    expr = exp(sinh(Piecewise((x, y > x), (y, True)) / z))\n+    assert expr.subs({1: 1.0}) == expr.subs({1: 1.0}) # Should not raise\n+\n+    # Case 2: Real symbols for x and y\n+    x_real, y_real = symbols('x y', real=True)\n+    expr_real = exp(sinh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z))\n+    assert expr_real.subs({1: 1.0}) == expr_real.subs({1: 1.0}) # Should not raise\n+\n+    # Additional checks for other similar hyperbolic functions\n+    expr_cos = exp(cosh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z))\n+    assert expr_cos.subs({1: 1.0}) == expr_cos.subs({1: 1.0}) # Should not raise\n+\n+    expr_tan = exp(tanh(Piecewise((x_real, y_real > x_real), (y_real, True)) / z))\n+    assert expr_tan.subs({1: 1.0}) == expr_tan.subs({1: 1.0}) # Should not raise\n+\n+    # Ensure clearing cache does not affect results\n+    from sympy.core.cache import clear_cache\n+    clear_cache()\n+    assert expr_real.subs({1: 1.0}) == expr_real.subs({1: 1.0}) # Should not raise\n     n3 = Rational(3)\n     e = x\n     e = e.subs(x, n3)\n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..d10bc7d 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n@@ -45,6 +46,11 @@ def test_Matrix_kind():\n         m = cls.zeros(3, 2)\n         assert m.kind is MatrixKind(NumberKind)\n \n+def test_Derivative_kind_matrix():\n+    A = MatrixSymbol('A', 2, 2)\n+    d = Derivative(A, comm_x)\n+    assert d.kind is MatrixKind(NumberKind)\n+\n def test_MatMul_kind():\n     M = Matrix([[1,2],[3,4]])\n     assert MatMul(2, M).kind is MatrixKind(NumberKind)\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..d0f0de8 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -107,6 +107,18 @@ def test_monomials():\n     raises(ValueError, lambda: set(itermonomials([x, y, z], [0, 0, 3], [0, 1, 2])))\n \n     assert set(itermonomials([x], [0])) == {S.One}\n+\n+    # New test cases for itermonomials with min_degrees\n+    x1, x2, x3 = symbols('x1, x2, x3')\n+    assert set(itermonomials([x1, x2, x3], 3, 3)) == \\\n+        {x1**3, x1**2*x2, x1**2*x3, x1*x2**2, x1*x2*x3, x1*x3**2, x2**3, x2**2*x3, x2*x3**2, x3**3}\n+    assert set(itermonomials([x1, x2, x3], 4, 3)) == \\\n+        {x1**3, x1**2*x2, x1**2*x3, x1*x2**2, x1*x2*x3, x1*x3**2, x2**3, x2**2*x3, x2*x3**2, x3**3,\n+         x1**4, x1**3*x2, x1**3*x3, x1**2*x2**2, x1**2*x2*x3, x1**2*x3**2, x1*x2**3, x1*x2**2*x3,\n+         x1*x2*x3**2, x1*x3**3, x2**4, x2**3*x3, x2**2*x3**2, x2*x3**3, x3**4}\n+    assert set(itermonomials([x1, x2], 5, 2)) == \\\n+        {x1**2, x1*x2, x2**2, x1**3, x1**2*x2, x1*x2**2, x2**3, x1**4, x1**3*x2, x1**2*x2**2,\n+         x1*x2**3, x2**4, x1**5, x1**4*x2, x1**3*x2**2, x1**2*x2**3, x1*x2**4, x2**5}\n     assert set(itermonomials([x], [1])) == {S.One, x}\n     assert set(itermonomials([x], [2])) == {S.One, x, x**2}\n     assert set(itermonomials([x], [3])) == {S.One, x, x**2, x**3}\n",
  "sympy__sympy-22005": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 341f63c..95048ba 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n@@ -48,6 +49,16 @@ def test_solve_poly_system():\n     raises(NotImplementedError, lambda: solve_poly_system(\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\n     raises(PolynomialError, lambda: solve_poly_system([1/x], x))\n+    \n+    # Additional test cases for non-zero-dimensional systems to ensure the fix is caught\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [Poly(x**2 - 1, x, y)], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [Poly(y**2 - 1, x, y)], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [Poly(x*y - 1, x, y)], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [Poly(x*y, x, y)], (x, y, z)))\n \n \n def test_solve_biquadratic():\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..223bb12 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,5 @@\n+\n+from sympy.core.parameters import evaluate\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n@@ -440,6 +442,18 @@ def test_unit():\n     assert Point(1, 1).unit == Point(sqrt(2)/2, sqrt(2)/2)\n \n \n+def test_issue_22684():\n+    # Test to ensure Point2D does not throw an error with evaluate(False)\n+    with evaluate(False):\n+        p = Point2D(1, 2)\n+    assert p == Point(1, 2)\n+\n+def test_point2d_with_evaluate_false():\n+    # Test to ensure direct usage doesn't raise ValueError with evaluate(False)\n+    with evaluate(False):\n+        p = Point2D(S(1), S(2))\n+    assert p == Point(1, 2)\n+\n def test_dot():\n     raises(TypeError, lambda: Point(1, 2).dot(Line((0, 0), (1, 1))))\n \n",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..06b6e34 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -347,7 +347,15 @@ def test_cse_MatrixSymbol():\n     B = MatrixSymbol(\"B\", n, n)\n     assert cse(B) == ([], [B])\n \n-def test_cse_MatrixExpr():\n+def test_cse_MatrixSymbol_indexing():\n+    # Test case for MatrixSymbol indexing with cse\n+    a = MatrixSymbol('a', 4, 4)\n+    b = MatrixSymbol('b', 4, 4)\n+    expr = a[0, 0] * b[0, 0] + a[0, 1] * b[1, 0] + a[0, 2] * b[2, 0] + a[0, 3] * b[3, 0]\n+    replacements, reduced_expr = cse(expr)\n+    assert replacements == [(Symbol('x0'), a[0, 0]), (Symbol('x1'), b[0, 0]), (Symbol('x2'), a[0, 1]), (Symbol('x3'), b[1, 0]), \n+                            (Symbol('x4'), a[0, 2]), (Symbol('x5'), b[2, 0]), (Symbol('x6'), a[0, 3]), (Symbol('x7'), b[3, 0])]\n+    assert reduced_expr == [x0*x1 + x2*x3 + x4*x5 + x6*x7]\n     A = MatrixSymbol('A', 3, 3)\n     y = MatrixSymbol('y', 3, 1)\n \n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..2f7bc85 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -17,6 +18,12 @@ array_types = [\n     MutableSparseNDimArray\n ]\n \n+def test_issue_empty_array():\n+    for array_type in array_types:\n+        A = array_type([])\n+        assert isinstance(A, array_type)\n+        assert A.shape == (0,)\n+        assert list(A) == []\n \n def test_array_negative_indices():\n     for ArrayType in array_types:\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..2b88564 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,6 +1175,9 @@ def test_scipy_polys():\n \n \n \n+import inspect\n+from sympy import lambdify\n+\n def test_lambdify_inspect():\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n@@ -1197,6 +1200,21 @@ def test_issue_14941():\n     f3 = lambdify([x, y], [y, x], 'sympy')\n     assert f3(2, 3) == [3, 2]\n \n+def test_lambdify_single_element_tuple():\n+    # Ensure that lambdify correctly outputs a single-element tuple\n+    f2b = lambdify([], (1,))  # Test case for the issue\n+    assert f2b() == (1,)\n+    \n+    # Additional verification through inspect\n+    source_code = inspect.getsource(f2b)\n+    assert 'return (1,)' in source_code\n+\n+def test_lambdify_single_element_tuple_code_printer():\n+    # Test that the code printer respects single-element tuples\n+    function_source = inspect.getsource(lambdify([], (1,)))\n+    # Check if the comma is preserved in the code representation of the tuple\n+    assert 'return (1,)' in function_source\n+\n \n def test_lambdify_Derivative_arg_issue_16468():\n     f = Function('f')(x)\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..f53b752 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -528,6 +528,31 @@ def test_issue_22819():\n     assert Da.scale_factor == 1.66053906660000e-24\n \n \n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units import Dimension\n+    from sympy.physics.units.quantity import Quantity\n+    from sympy.physics.units.systems.si import SI\n+    from sympy import exp\n+\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n+\n def test_issue_20288():\n     from sympy.core.numbers import E\n     from sympy.physics.units import energy\n",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..1f2bade 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -45,8 +45,21 @@ def test_tensor_product_expand():\n     assert TP(A + B, B + C).expand(tensorproduct=True) == \\\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n-\n-def test_tensor_product_commutator():\n+def test_issue_tensor_product_expansion():\n+    # Test cases derived from the provided original test patch for issue #24142\n+    assert TP(A-B, B-A).expand(tensorproduct=True) == \\\n+        TP(A, B) - TP(A, A) - TP(B, B) + TP(B, A)\n+    assert TP(2*A + B, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A, A) + 2 * TP(A, B) + TP(B, A) + TP(B, B)\n+    assert TP(2 * A * B + A, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A*B, A) + 2 * TP(A*B, B) + TP(A, A) + TP(A, B)\n+\n+    # Additional test cases for thorough verification\n+    assert TP(U - U, U + V).expand(tensorproduct=True) == 0\n+    assert TP(U, 2 * V + U).expand(tensorproduct=True) == \\\n+        2 * TP(U, V) + TP(U, U)\n+    assert TP(U + V, V).expand(tensorproduct=True) == \\\n+        TP(U, V) + TP(V, V)\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n         TP(A*B, C) - TP(B*A, C)\n     assert Comm(TP(A, B), TP(B, C)).doit() == \\\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..d74bccc 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -562,7 +563,25 @@ def test_issue_24062():\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n \n-def test_prefixed_property():\n+def test_issue_24211():\n+    from sympy.physics.units import Quantity, time, velocity, acceleration, second, meter\n+    from sympy.physics.units.systems.si import SI\n+\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+\n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+\n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+\n+    expr1 = a1 * t1 + v1\n+    # Ensure that no ValueError is raised due to mismatched dimensions\n+    SI._collect_factor_and_dimension(expr1)\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..2aec04c 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, V, milli\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n@@ -23,6 +24,14 @@ def test_prefix_operations():\n     assert k / m == M\n \n     assert dodeca * dodeca == 144\n+\n+    # Additional test cases for milli prefix with W (Watts) and V (Volts)\n+    assert milli * W == W / 1000, \"milli times W should be milliwatts\"\n+    assert milli * V == V / 1000, \"milli times V should be millivolts\"\n+\n+    # Ensure the product is correctly identified\n+    assert W * milli == milli * W, \"Order of multiplication should not matter\"\n+    assert V * milli == milli * V, \"Order of multiplication should not matter\"\n     assert 1 / dodeca == S.One / 12\n     assert k / dodeca == S(1000) / 12\n     assert dodeca / dodeca == 1\n",
  "django__django-12470": "diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py\nindex 067de1c..ad17d3e 100644\n--- a/tests/model_inheritance/tests.py\n+++ b/tests/model_inheritance/tests.py\n@@ -1,5 +1,7 @@\n from operator import attrgetter\n \n+from django.apps import apps\n+\n from django.core.exceptions import FieldError, ValidationError\n from django.db import connection, models\n from django.test import SimpleTestCase, TestCase\n@@ -13,6 +15,19 @@ from .models import (\n \n \n class ModelInheritanceTests(TestCase):\n+    def test_child_ordering_inherited_from_parent(self):\n+        # Create instances of Parent which are parents of Child\n+        child1 = Child.objects.create(first_name='Alice', email='alice@example.com')\n+        child2 = Child.objects.create(first_name='Bob', email='bob@example.com')\n+        \n+        # Get all Child objects and check they are ordered by '-pk'\n+        children = list(Child.objects.all())\n+        self.assertSequenceEqual(children, [child2, child1], \"Children are not ordered by '-pk' as expected.\")\n+\n+        # Check that the query reflects the ordering by '-pk'\n+        query = str(Child.objects.all().query)\n+        expected_order_by_sql = f'ORDER BY {\"myapp_parent\"}.{\"id\"} DESC'\n+        self.assertIn(expected_order_by_sql, query, f\"Query should order by '-pk', found: {query}\")\n     def test_abstract(self):\n         # The Student and Worker models both have 'name' and 'age' fields on\n         # them and inherit the __str__() method, just as with normal Python\n",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..5fe28ce 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,6 +343,36 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n+    def test_order_by_self_referential_fk(self):\n+        author_1 = Author.objects.create(name=\"Author 1\")\n+        author_2 = Author.objects.create(name=\"Author 2\")\n+        \n+        article_1 = Article.objects.create(author=author_1, headline=\"Article 1\")\n+        article_2 = Article.objects.create(author=author_2, headline=\"Article 2\")\n+        \n+        # Test ordering by self-referential foreign key field author__editor\n+        # after applying fix for self-referential foreign key ordering issue\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'), \n+            ['Article 2', 'Article 1'], \n+            attrgetter('headline')\n+        )\n+        \n+        # Test workaround with annotation\n+        qs = Article.objects.filter(author__isnull=False).annotate(editor_id=F('author__editor_id')).order_by('editor_id')\n+        self.assertQuerysetEqual(\n+            qs,\n+            ['Article 1', 'Article 2'],\n+            attrgetter('headline')\n+        )\n+\n+        # Test ordering by author__editor_id specifically to ensure corrected behavior\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'),\n+            ['Article 2', 'Article 1'],\n+            attrgetter('headline')\n+        )\n+\n     def test_order_by_f_expression(self):\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n",
  "django__django-13265": "",
  "django__django-14534": "",
  "django__django-16400": "",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..8d983a9 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -640,6 +640,39 @@ def test_colorbar_format(fmt):\n             '$\\\\mathdefault{10^{-2}}$')\n \n \n+def test_update_colorbar_after_norm_change():\n+    import numpy as np\n+    import matplotlib.pyplot as plt\n+    from matplotlib.colors import LogNorm, Normalize\n+\n+    # Generate some test data\n+    img = 10 ** np.random.normal(1, 1, size=(50, 50))\n+\n+    fig, ax = plt.subplots()\n+    im = ax.imshow(img, cmap='gray')\n+    cbar = fig.colorbar(im, ax=ax)\n+\n+    # Change normalization to LogNorm\n+    im.norm = LogNorm()\n+    cbar.update_normal(im)\n+    fig.canvas.draw()\n+\n+    # Assert colorbar has log scale\n+    assert cbar.ax.yaxis.get_scale() == 'log'\n+\n+    # Verify the colorbar ticks reflect the LogNorm scale\n+    tick_labels = [label.get_text() for label in cbar.ax.yaxis.get_ticklabels()]\n+    assert all(tick.startswith('$\\\\mathdefault{10') for tick in tick_labels if tick)\n+\n+    # Change normalization back to Normalize\n+    im.norm = Normalize()\n+    cbar.update_normal(im)\n+    fig.canvas.draw()\n+\n+    # Assert colorbar has gone back to linear scale\n+    assert cbar.ax.yaxis.get_scale() == 'linear'\n+\n+\n def test_colorbar_scale_reset():\n     x, y = np.ogrid[-4:4:31j, -4:4:31j]\n     z = 120000*np.exp(-x**2 - y**2)\n",
  "pydata__xarray-4094": "diff --git a/xarray/tests/test_dataset.py b/xarray/tests/test_dataset.py\nindex a2826fa..8184e3d 100644\n--- a/xarray/tests/test_dataset.py\n+++ b/xarray/tests/test_dataset.py\n@@ -3045,7 +3045,13 @@ class TestDataset:\n         d0 = D.isel(x=0)\n         assert_identical(d0, x0)\n \n-    def test_to_stacked_array_to_unstacked_dataset_different_dimension(self):\n+    def test_to_stacked_array_single_dimension_to_unstacked_dataset(self):\n+        # single dimension: regression test for GH4049\n+        arr = xr.DataArray(np.arange(3), coords=[(\"x\", [0, 1, 2])])\n+        data = xr.Dataset({\"a\": arr, \"b\": arr})\n+        stacked = data.to_stacked_array(\"y\", sample_dims=[\"x\"])\n+        unstacked = stacked.to_unstacked_dataset(\"y\")\n+        assert_identical(unstacked, data)\n         # test when variables have different dimensionality\n         a, b = create_test_stacked_array()\n         sample_dims = [\"x\"]\n",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..c7698e4 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -259,4 +259,29 @@ def test_set_output_mro():\n     class C(A, B):\n         pass\n \n-    assert C().transform(None) == \"B\"\n+    assert C().transform(None) == \"B\"\n+\n+def test_feature_union_with_pandas_output():\n+    \"\"\"Test FeatureUnion with pandas output and a custom transformer that aggregates data.\"\"\"\n+    import pandas as pd\n+    from sklearn.pipeline import FeatureUnion\n+\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+\n+    class MyAggregator(BaseEstimator, TransformerMixin):\n+        def fit(self, X: pd.DataFrame, y: pd.Series | None = None, **kwargs):\n+            return self\n+\n+        def transform(self, X: pd.DataFrame, y: pd.Series | None = None) -> pd.DataFrame:\n+            return X[[\"date\", \"value\"]].groupby(\"date\").sum().reset_index()\n+\n+    union = FeatureUnion([(\"agg\", MyAggregator())])\n+    union.set_output(transform=\"pandas\")\n+\n+    transformed_data = union.fit_transform(data)\n+\n+    # Check that the transformation result is as expected\n+    expected_result = data.groupby(\"date\").sum().reset_index()\n+    pd.testing.assert_frame_equal(transformed_data, expected_result)\n",
  "sphinx-doc__sphinx-8801": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 37d6e17..369a6ac 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -106,6 +106,11 @@ def test_inherited_instance_variable(app):\n     ]\n \n \n+import pytest\n+import sys\n+from sphinx.testing.util import SphinxTestApp\n+from sphinx.ext.autodoc import do_autodoc\n+\n def test_decorators(app):\n     actual = do_autodoc(app, 'class', 'target.decorator.Baz')\n     assert list(actual) == [\n",
  "sympy__sympy-15346": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex cce4836..cccd447 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     symbols, sin, simplify, cos, trigsimp, rad, tan, exptrigsimp,sinh,\n     cosh, diff, cot, Subs, exp, tanh, exp, S, integrate, I,Matrix,\n@@ -9,8 +10,24 @@ from sympy.utilities.pytest import XFAIL\n from sympy.abc import x, y, z, t, a, b, c, d, e, f, g, h, i, k\n \n \n+def test_issue_rational_trigsimp():\n+    # Test simplification of standalone trigonometric expressions with Rational\n+    r = sin(Rational(1, 50)) * sin(Rational(1, 25)) + cos(Rational(1, 50)) * cos(Rational(1, 25))\n+    assert trigsimp(r) == cos(Rational(1, 25) - Rational(1, 50))\n+\n+    # Test simplification with acos\n+    s = acos(sin(Rational(1, 50)) * sin(Rational(1, 25)) + cos(Rational(1, 50)) * cos(Rational(1, 25)))\n+    assert trigsimp(s) == acos(cos(Rational(1, 25) - Rational(1, 50)))\n+\n+    # Ensure the original example from the issue remains simplified correctly\n+    t1 = Matrix([sin(Rational(1, 50)), cos(Rational(1, 50)), 0])\n+    t2 = Matrix([sin(Rational(1, 25)), cos(Rational(1, 25)), 0])\n+    r1 = t1.dot(t2)\n+    assert trigsimp(r1) == cos(S(1) / 50)\n \n-def test_trigsimp1():\n+    t3 = Matrix([cos(Rational(1, 25)), sin(Rational(1, 25)), 0])\n+    r2 = t1.dot(t3)\n+    assert trigsimp(r2) == sin(S(3) / 50)\n     x, y = symbols('x,y')\n \n     assert trigsimp(1 - sin(x)**2) == cos(x)**2\n",
  "sympy__sympy-16503": "",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "",
  "django__django-11797": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 7beeac3..5cd6cdf 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -1,9 +1,11 @@\n+\n import collections.abc\n from datetime import datetime\n from math import ceil\n from operator import attrgetter\n \n from django.core.exceptions import FieldError\n+from django.db.models import Max\n from django.db import connection\n from django.db.models.expressions import Exists, OuterRef\n from django.db.models.functions import Substr\n",
  "django__django-15320": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 35f7f03..e258eaf 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -545,6 +545,22 @@ class BasicExpressionsTests(TestCase):\n         self.assertCountEqual(subquery_test, [self.foobar_ltd, self.gmbh])\n         subquery_test2 = Company.objects.filter(pk=Subquery(small_companies.filter(num_employees=3)))\n         self.assertCountEqual(subquery_test2, [self.foobar_ltd])\n+        \n+    def test_subquery_as_sql_generates_valid_sql(self):\n+        # This test will verify if Subquery.as_sql() generates valid SQL\n+        employees = Employee.objects.all()\n+        employees_subquery = Subquery(employees)\n+        \n+        # Check that the subquery flag is set correctly\n+        self.assertIs(employees_subquery.query.subquery, True)\n+        \n+        # Compile the SQL for the subquery\n+        compiler = employees_subquery.query.get_compiler(connection=connection)\n+        sql, params = employees_subquery.as_sql(compiler, connection)\n+        \n+        # Ensure the generated SQL is correctly formatted\n+        self.assertTrue(sql.startswith('(SELECT '))\n+        self.assertTrue(sql.endswith(')'))\n \n     def test_uuid_pk_subquery(self):\n         u = UUIDPK.objects.create()\n",
  "django__django-15819": "diff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py\nindex 0ecd041..5048043 100644\n--- a/tests/inspectdb/tests.py\n+++ b/tests/inspectdb/tests.py\n@@ -422,6 +422,36 @@ class InspectDBTestCase(TestCase):\n         Introspection errors should not crash the command, and the error should\n         be visible in the output.\n         \"\"\"\n+\n+    def test_related_name_autogeneration_for_multiple_same_relations(self):\n+        \"\"\"\n+        Test that inspectdb generates related_name automatically for models\n+        with multiple foreign keys to the same model.\n+        \"\"\"\n+        with connection.cursor() as cursor:\n+            cursor.execute(\n+                \"CREATE TABLE inspectdb_multi_fk (\"\n+                \"    id serial NOT NULL PRIMARY KEY,\"\n+                \"    person_id integer NOT NULL,\"\n+                \"    reviewer_id integer NOT NULL,\"\n+                \"    CONSTRAINT person_fk FOREIGN KEY (person_id) REFERENCES inspectdb_people (id),\"\n+                \"    CONSTRAINT reviewer_fk FOREIGN KEY (reviewer_id) REFERENCES inspectdb_people (id)\"\n+                \")\"\n+            )\n+        \n+        out = StringIO()\n+        call_command(\"inspectdb\", \"inspectdb_multi_fk\", stdout=out)\n+        output = out.getvalue()\n+        \n+        # Check that both foreign keys have non-conflicting related_name\n+        self.assertIn(\n+            \"person = models.ForeignKey('InspectdbPeople', models.DO_NOTHING, related_name='inspectdbmultifk_person_set')\",\n+            output\n+        )\n+        self.assertIn(\n+            \"reviewer = models.ForeignKey('InspectdbPeople', models.DO_NOTHING, related_name='inspectdbmultifk_reviewer_set')\",\n+            output\n+        )\n         out = StringIO()\n         with mock.patch(\n             \"django.db.connection.introspection.get_table_list\",\n",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..028f388 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -152,6 +153,13 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n+    def test_wrong_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(PoolStyle.objects.annotate(\n+                tournament_pool=FilteredRelation('pool__tournament__pool'),\n+            ).select_related('tournament_pool', 'tournament_pool__tournament'))\n+            self.assertEqual(p[0].pool.tournament, p[0].tournament_pool.tournament)\n+\n     def test_reverse_fk_select_related_multiple(self):\n         with self.assertNumQueries(1):\n             ps = list(\n@@ -163,4 +171,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex ad1a5e1..176f2e9 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from datetime import datetime\n import io\n@@ -9,12 +10,37 @@ import warnings\n \n import numpy as np\n import pytest\n+import pickle\n from PIL import Image\n+from matplotlib.figure import Figure\n \n import matplotlib as mpl\n from matplotlib import gridspec, rcParams\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n-from matplotlib.axes import Axes\n+def test_unpickle_with_device_pixel_ratio():\n+    # Original test case\n+    fig = Figure(dpi=42)\n+    fig.canvas._set_device_pixel_ratio(7)\n+    assert fig.dpi == 42 * 7\n+    fig2 = pickle.loads(pickle.dumps(fig))\n+    assert fig2.dpi == 42\n+\n+def test_unpickle_dpi_preservation():\n+    # New test case to reproduce the issue\n+    fig = Figure(dpi=200)\n+    for _ in range(10):\n+        fig = pickle.loads(pickle.dumps(fig))\n+        assert fig.dpi == 200, f\"Expected DPI to remain 200, got {fig.dpi}\"\n+\n+def test_unpickle_dpi_overflow_error():\n+    # Additional test case to ensure no OverflowError occurs\n+    fig = Figure(dpi=2**28)  # Set a very high initial DPI\n+    try:\n+        for _ in range(10):\n+            fig = pickle.loads(pickle.dumps(fig))\n+        assert True, \"Successfully unpickled high DPI figure without OverflowError\"\n+    except OverflowError:\n+        assert False, \"OverflowError occurred during unpickle with high DPI\"\n from matplotlib.figure import Figure, FigureBase\n from matplotlib.layout_engine import (ConstrainedLayoutEngine,\n                                       TightLayoutEngine)\n",
  "mwaskom__seaborn-2848": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 5a5e126..6bf9e82 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -1,3 +1,4 @@\n+\n from itertools import product\n import numpy as np\n import matplotlib as mpl\n@@ -10,6 +11,7 @@ from numpy.testing import assert_array_equal\n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n \n+from seaborn import PairGrid\n from seaborn.relational import (\n     _RelationalPlotter,\n     _LinePlotter,\n@@ -1623,7 +1625,19 @@ class TestScatterPlotter(SharedAxesLevelTests, Helpers):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n-    def test_linewidths(self, long_df):\n+    def test_pairgrid_map_with_categorical_hue(self):\n+        import seaborn as sns\n+        import pytest\n+        iris = sns.load_dataset(\"iris\")\n+        \n+        # Create a PairGrid and map a scatterplot with categorical hue\n+        try:\n+            g = sns.PairGrid(iris, y_vars=[\"sepal_length\",\"sepal_width\"], x_vars=[\"petal_length\",\"petal_width\"])\n+            g.map(sns.scatterplot, hue=iris[\"species\"])\n+            g.map(sns.regplot, scatter=False)\n+            plt.close('all')  # Close the plot to avoid memory issues\n+        except Exception as e:\n+            pytest.fail(f\"PairGrid mapping with categorical hue failed: {e}\")\n \n         f, ax = plt.subplots()\n \n",
  "pytest-dev__pytest-5413": "diff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 226bfb9..a45096f 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -346,8 +346,15 @@ def test_excinfo_str():\n     assert s.endswith(\"ValueError\")\n     assert len(s.split(\":\")) >= 3  # on windows it's 4\n \n-\n-def test_excinfo_for_later():\n+def test_excinfo_raises_str_behavior():\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\"A\\nB\\nC\")\n+    \n+    # Check the behavior of str(excinfo)\n+    assert str(excinfo) == \"<ExceptionInfo LookupError tblen=2>\"\n+\n+    # Check the behavior of str(excinfo.value)\n+    assert str(excinfo.value) == \"A\\nB\\nC\"\n     e = ExceptionInfo.for_later()\n     assert \"for raises\" in repr(e)\n     assert \"for raises\" in str(e)\n",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..d16b2bb 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -405,6 +405,10 @@ class TestCustomConftests:\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n \n+        # Test using the proposed shortcut for --collect-only\n+        result = testdir.runpytest(\"-C\")\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+\n     def test_pytest_collect_file_from_sister_dir(self, testdir):\n         sub1 = testdir.mkpydir(\"sub1\")\n         sub2 = testdir.mkpydir(\"sub2\")\n",
  "sphinx-doc__sphinx-10451": "diff --git a/tests/roots/test-ext-autodoc/target/typehints.py b/tests/roots/test-ext-autodoc/target/typehints.py\nindex 100ea06..2a43317 100644\n--- a/tests/roots/test-ext-autodoc/target/typehints.py\n+++ b/tests/roots/test-ext-autodoc/target/typehints.py\n@@ -83,6 +83,28 @@ def complex_func(arg1, arg2, arg3=None, *args, **kwargs):\n     pass\n \n \n+def documented_star_args_and_kwargs(x: int, *args: int, **kwargs: int) -> None:\n+    \"\"\"\n+    Test function to verify *args and **kwargs are correctly documented.\n+\n+    :param x: An integer\n+    :param args: Additional integers\n+    :param kwargs: Additional named integers\n+    \"\"\"\n+    pass\n+\n+\n+class _ClassWithDocumentedInitAndStarArgs:\n+    \"\"\"Class docstring.\"\"\"\n+\n+    def __init__(self, x: int, *args: int, **kwargs: int) -> None:\n+        \"\"\"Init docstring.\n+\n+        :param x: Some integer\n+        :param *args: Some integer\n+        :param **kwargs: Some integer\n+        \"\"\"\n+\n def missing_attr(c,\n                  a,  # type: str\n                  b=None  # type: Optional[str]\n@@ -98,4 +120,4 @@ class _ClassWithDocumentedInit:\n         \"\"\"Init docstring.\n \n         :param x: Some integer\n-        \"\"\"\n+        \"\"\"\n",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..18b58f0 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -83,8 +83,15 @@ def test_Identity():\n     assert transpose(In) == In\n     assert In.inverse() == In\n     assert In.conjugate() == In\n+from sympy import Sum, symbols\n \n-def test_Identity_doit():\n+def test_Identity_sum_elements():\n+    n = symbols('n', integer=True, positive=True)\n+    In = Identity(n)\n+    \n+    # The sum of all elements in the identity matrix should be n (one in each diagonal position)\n+    total_sum = Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).doit()\n+    assert total_sum == n\n     Inn = Identity(Add(n, n, evaluate=False))\n     assert isinstance(Inn.rows, Add)\n     assert Inn.doit() == Identity(2*n)\n",
  "sympy__sympy-20049": "diff --git a/sympy/physics/vector/point.py b/sympy/physics/vector/point.py\nindex b711aa3..409270c 100644\n--- a/sympy/physics/vector/point.py\n+++ b/sympy/physics/vector/point.py\n@@ -518,9 +518,18 @@ class Point(object):\n         \"\"\"\n \n         _check_frame(frame)\n-        if not (frame in self._vel_dict):\n-            raise ValueError('Velocity of point ' + self.name + ' has not been'\n-                             ' defined in ReferenceFrame ' + frame.name)\n+        if frame not in self._vel_dict:\n+            velocity = None\n+            for point, pos_vector in self._pos_dict.items():\n+                try:\n+                    velocity = point.vel(frame) + pos_vector.dt(frame)\n+                    self.set_vel(frame, velocity)\n+                    break\n+                except ValueError:\n+                    pass\n+            if velocity is None:\n+                raise ValueError('Velocity of point ' + self.name + ' has not been'\n+                                 ' defined in ReferenceFrame ' + frame.name)\n         return self._vel_dict[frame]\n \n     def partial_velocity(self, frame, *gen_speeds):\n",
  "sympy__sympy-21612": "diff --git a/sympy/parsing/tests/test_latex.py b/sympy/parsing/tests/test_latex.py\nindex b252985..7ace0da 100644\n--- a/sympy/parsing/tests/test_latex.py\n+++ b/sympy/parsing/tests/test_latex.py\n@@ -251,7 +251,14 @@ def test_parseable():\n     for latex_str, sympy_expr in GOOD_PAIRS:\n         assert parse_latex(latex_str) == sympy_expr, latex_str\n \n-# These bad LaTeX strings should raise a LaTeXParsingError when parsed\n+def test_issue_latex_parsing():\n+    from sympy.parsing.latex import parse_latex\n+    from sympy import Symbol, Pow, Add, Rational\n+    a, b, c = Symbol('a'), Symbol('b'), Symbol('c')\n+    # Test the specific issue case\n+    latex_expr = \"\\\\frac{\\\\frac{a^3+b}{c}}{\\\\frac{1}{c^2}}\"\n+    expected_expr = ((a**3 + b)/c)/(1/(c**2))\n+    assert parse_latex(latex_expr) == expected_expr\n BAD_STRINGS = [\n     r\"(\",\n     r\")\",\n"
}