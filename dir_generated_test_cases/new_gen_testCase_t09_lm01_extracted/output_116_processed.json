{
  "astropy__astropy-12907": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 88711b0..7efab11 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -55,6 +55,26 @@ compound_models = {\n             )\n }\n \n+# Add new separability matrix test cases for nested compound models\n+def test_nested_compound_models_separability():\n+    # Original issue case\n+    cm = m.Linear1D(10) & m.Linear1D(5)\n+    nested_cm = m.Pix2Sky_TAN() & cm\n+    expected_matrix = np.array([[True,  True, False, False],\n+                                [True,  True, False, False],\n+                                [False, False, True,  True],\n+                                [False, False, True,  True]])\n+    assert_allclose(separability_matrix(nested_cm), expected_matrix)\n+\n+    # Additional nested compound model test\n+    complex_cm = (m.Pix2Sky_TAN() & m.Linear1D(10)) & (m.Linear1D(5) & m.Linear1D(3))\n+    expected_complex_matrix = np.array([[ True,  True,  False, False, False],\n+                                        [ True,  True,  False, False, False],\n+                                        [False, False,  True,  False,  False],\n+                                        [False, False,  False, True,  False],\n+                                        [False, False,  False, False, True]])\n+    assert_allclose(separability_matrix(complex_cm), expected_complex_matrix)\n+\n \n def test_coord_matrix():\n     c = _coord_matrix(p2, 'left', 2)\n",
  "astropy__astropy-14182": "",
  "astropy__astropy-14365": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 9b66109..9a604ce 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -43,6 +43,51 @@ def test_get_tables_from_qdp_file(tmp_path):\n     assert np.isclose(table2[\"MJD_nerr\"][0], -2.37847222222222e-05)\n \n \n+import pytest\n+from astropy.io.ascii.qdp import _read_table_qdp\n+\n+def lowercase_header(value):\n+    \"\"\"Make every non-comment line lower case.\"\"\"\n+    lines = []\n+    for line in value.splitlines():\n+        if not line.startswith(\"!\"):\n+            line = line.lower()\n+        lines.append(line)\n+    return \"\\n\".join(lines)\n+\n+\n+@pytest.mark.parametrize(\"lowercase\", [False, True])\n+def test_case_insensitivity(tmp_path, lowercase):\n+    example_qdp = \"\"\"\n+    ! Swift/XRT hardness ratio of trigger: XXXX, name: BUBU X-2\n+    ! Columns are as labelled\n+    READ TERR 1\n+    READ SERR 2\n+    ! WT -- hard data\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   NO       0.212439\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   0.000000        0.000000\n+    NO NO NO NO NO\n+    \"\"\"\n+\n+    if lowercase:\n+        example_qdp = lowercase_header(example_qdp)\n+\n+    path = str(tmp_path / \"test_case_insensitivity.qdp\")\n+\n+    with open(path, \"w\") as fp:\n+        print(example_qdp, file=fp)\n+\n+    # Read the QDP file\n+    with pytest.warns(AstropyUserWarning) as record:\n+        table = _read_table_qdp(path, names=[\"MJD\", \"Rate\"], table_id=0)\n+    assert np.any(\n+        [\n+            \"This file contains multiple command blocks\" in r.message.args[0]\n+            for r in record\n+        ]\n+    )\n+\n def test_roundtrip(tmp_path):\n     example_qdp = \"\"\"\n     ! Swift/XRT hardness ratio of trigger: XXXX, name: BUBU X-2\n",
  "astropy__astropy-14995": "diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py\nindex fc27f69..5d62f03 100644\n--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py\n+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py\n@@ -28,7 +28,47 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n         return False\n \n \n-# Test with Data covers:\n+import numpy as np\n+from astropy.nddata import NDDataRef\n+import pytest\n+\n+def test_nddata_bitmask_arithmetic():\n+    # NDData.mask is usually assumed to be boolean, but could be\n+    # a bitmask. Ensure bitmask works:\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_masked = NDDataRef(array, mask=mask)\n+\n+    # multiply no mask by constant (no mask * no mask)\n+    assert nref_nomask.multiply(1.0, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply no mask by itself (no mask * no mask)\n+    assert nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply masked by constant (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(1.0, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by itself (mask * mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_masked, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by no mask (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_nomask, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # check bitwise logic still works\n+    other_mask = np.array([[64, 1, 0], [2, 1, 0], [8, 0, 2]])\n+    nref_mask_other = NDDataRef(array, mask=other_mask)\n+    np.testing.assert_equal(\n+        nref_mask_other.multiply(nref_masked, handle_mask=np.bitwise_or).mask,\n+        np.bitwise_or(mask, other_mask),\n+    )\n # scalars, 1D, 2D and 3D\n # broadcasting between them\n @pytest.mark.filterwarnings(\"ignore:divide by zero encountered.*\")\n",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..2ff8eaf 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -300,7 +300,23 @@ class TestTableFunctions(FitsTestCase):\n         hdul.close()\n         a.close()\n \n-    def test_endianness(self):\n+    def test_d_exponent_replacement(self):\n+        # Create a FITS table with a column that uses the 'D' format\n+        r1 = np.array([1.234567890123456789, 9.876543210987654321])\n+        c1 = fits.Column(name='col1', format='D', array=r1)\n+        hdu = fits.TableHDU.from_columns([c1])\n+\n+        outfile = self.temp('test_d_exponent.fits')\n+        hdu.writeto(outfile, overwrite=True)\n+\n+        # Read the file back in and check the exponent\n+        with open(outfile, 'r') as f:\n+            content = f.read()\n+            assert '1.23456789012345677D+00' in content, \"D format exponent not found or incorrect\"\n+            assert '9.87654321098765432D+00' in content, \"D format exponent not found or incorrect\"\n+\n+        with fits.open(outfile) as hdul:\n+            assert comparerecords(hdu.data, hdul[1].data)\n         x = np.ndarray((1,), dtype=object)\n         channelsIn = np.array([3], dtype='uint8')\n         x[0] = channelsIn\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..78b1b4d 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1090,6 +1090,37 @@ class OverrideSettingsTests(SimpleTestCase):\n         base_url attribute of django.core.files.storage.default_storage.\n         \"\"\"\n         self.assertEqual(default_storage.base_location, '')\n+\n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        By default, FILE_UPLOAD_PERMISSIONS should be 0o644.\n+        \"\"\"\n+        self.assertEqual(default_storage.file_permissions_mode, 0o644)\n+\n+    def test_file_upload_permissions_on_temporary_file_storage(self):\n+        \"\"\"\n+        Check that uploaded file on a temporary file storage have permissions 0o644.\n+        \"\"\"\n+        with self.settings(FILE_UPLOAD_HANDLERS=[\n+            'django.core.files.uploadhandler.TemporaryFileUploadHandler',\n+        ]):\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n+\n+    def test_file_upload_permissions_on_large_file(self):\n+        \"\"\"\n+        Uploaded large files should have permissions 0o644.\n+        \"\"\"\n+        large_content = b'a' * 1024 * 1024  # Large content for testing\n+        temp_file = TemporaryUploadedFile('large_file', 'text/plain', 1024 * 1024, 'utf-8')\n+        temp_file.write(large_content)\n+        temp_file.seek(0)\n+\n+        with default_storage.open(temp_file.name, 'wb') as f:\n+            for chunk in temp_file.chunks():\n+                f.write(chunk)\n+\n+        # Check the permissions of the saved file\n+        self.assertEqual(default_storage.file_permissions_mode, 0o644)\n         with self.settings(MEDIA_URL='/test_value/'):\n             self.assertEqual(default_storage.base_url, '/test_value/')\n \n",
  "django__django-10924": "",
  "django__django-11001": "",
  "django__django-11039": "",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..eb40dd0 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -67,6 +67,28 @@ class TestSerialization(SimpleTestCase):\n \n class TestValidation(SimpleTestCase):\n \n+    def test_invalid_format_missing_seconds(self):\n+        field = models.DurationField()\n+        with self.assertRaises(exceptions.ValidationError) as cm:\n+            field.clean('1:30', None)\n+        self.assertEqual(cm.exception.code, 'invalid')\n+        self.assertEqual(\n+            cm.exception.message % cm.exception.params,\n+            \"'1:30' value has an invalid format. \"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n+        )\n+\n+    def test_invalid_format_only_minutes_provided(self):\n+        field = models.DurationField()\n+        with self.assertRaises(exceptions.ValidationError) as cm:\n+            field.clean('5', None)\n+        self.assertEqual(cm.exception.code, 'invalid')\n+        self.assertEqual(\n+            cm.exception.message % cm.exception.params,\n+            \"'5' value has an invalid format. \"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n+        )\n+\n     def test_invalid_string(self):\n         field = models.DurationField()\n         with self.assertRaises(exceptions.ValidationError) as cm:\n@@ -75,7 +97,7 @@ class TestValidation(SimpleTestCase):\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n             \"'not a datetime' value has an invalid format. \"\n-            \"It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n         )\n \n \n@@ -84,4 +106,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..2380e4a 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -237,7 +237,7 @@ class UsernameValidatorsTests(SimpleTestCase):\n         invalid_usernames = [\n             \"o'connell\", \"\u0639\u0628\u062f \u0627\u0644\",\n             \"zerowidth\\u200Bspace\", \"nonbreaking\\u00A0space\",\n-            \"en\\u2013dash\",\n+            \"en\\u2013dash\", 'trailingnewline\\n'\n         ]\n         v = validators.UnicodeUsernameValidator()\n         for valid in valid_usernames:\n@@ -258,4 +258,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..cac998a 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -356,6 +356,16 @@ class HttpResponseTests(unittest.TestCase):\n         r = HttpResponse()\n         self.assertIsNone(r.get('test'))\n \n+    def test_memoryview_content(self):\n+        # Test handling of memoryview objects in HttpResponse\n+        r = HttpResponse(memoryview(b\"My Content\"))\n+        self.assertEqual(r.content, b'My Content')\n+\n+        # Set content via the property and ensure it still handles memoryview correctly\n+        r = HttpResponse()\n+        r.content = memoryview(b\"Different Content\")\n+        self.assertEqual(r.content, b'Different Content')\n+        \n     def test_non_string_content(self):\n         # Bug 16494: HttpResponse should behave consistently with non-strings\n         r = HttpResponse(12345)\n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..df312db 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,6 +1,8 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n+from django.db.models.deletion import Collector\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n@@ -464,7 +466,27 @@ class FastDeleteTests(TestCase):\n         # 1 to delete t, 1 to fast-delete t's m_set\n         self.assertNumQueries(2, f.delete)\n \n-    def test_fast_delete_qs(self):\n+    def test_fast_delete_instance_set_pk_none(self):\n+        u = User.objects.create()\n+        # User can be fast-deleted.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        u.delete()\n+        self.assertIsNone(u.pk)\n+\n+    def test_fast_delete_instance_set_pk_none_other_model(self):\n+        a = Avatar.objects.create(desc='avatar_test')\n+        # Avatar can be fast-deleted.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(a))\n+        a.delete()\n+        self.assertIsNone(a.pk)\n+\n+    def test_fast_delete_instance_queryset_pk_none(self):\n+        users = User.objects.bulk_create([User(), User()])\n+        User.objects.all().delete()\n+        for user in users:\n+            self.assertIsNone(user.pk)\n         u1 = User.objects.create()\n         u2 = User.objects.create()\n         self.assertNumQueries(1, User.objects.filter(pk=u1.pk).delete)\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..02b4f5c 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,9 +1,12 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n from django.contrib.auth.models import Permission, User\n from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n+from django.db.utils import IntegrityError\n+from django.test.utils import captured_stdout\n \n from .models import Proxy, UserProxy\n \n@@ -140,7 +143,30 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n-    def test_user_keeps_same_permissions_after_migrating_backward(self):\n+    def test_migrate_with_existing_proxy_permissions(self):\n+        \"\"\"\n+        Test that migration auth.0011_update_proxy_permissions doesn't fail\n+        when there are already existing permissions for proxy models.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='change_proxy',\n+            name='Can change proxy',\n+        )\n+        with captured_stdout() as stdout:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        self.assertIn('A problem arose migrating proxy model permissions', stdout.getvalue())\n+        # After running the migration, ensure no IntegrityError occurs.\n+        try:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        except IntegrityError:\n+            self.fail(\"IntegrityError was raised when updating proxy permissions with existing entries.\")\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n         user.user_permissions.add(self.custom_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..e078d13 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -11,6 +11,8 @@ import weakref\n import zipfile\n from importlib import import_module\n from pathlib import Path\n+import sys\n+import os\n from unittest import mock, skip, skipIf\n \n from django.apps.registry import Apps\n",
  "django__django-11583": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 99e5edd..056b199 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -141,7 +141,31 @@ class TestIterModulesAndFiles(SimpleTestCase):\n         self.assertEqual(autoreload.iter_modules_and_files((fake_main,), frozenset()), frozenset())\n \n \n-class TestCommonRoots(SimpleTestCase):\n+class TestEnhancedPathHandling(SimpleTestCase):\n+    def test_various_paths_with_embedded_null_bytes(self):\n+        abusive_paths = [\n+            \"pre\\\\x00fix/more_path.py\",\n+            \"\\\\x00leading_null.py\",\n+            \"/completely\\\\x00invalid/path.py\"\n+        ]\n+        for path in abusive_paths:\n+            with self.subTest(path=path):\n+                self.assertEqual(\n+                    autoreload.iter_modules_and_files((), frozenset([path])),\n+                    frozenset(),\n+                )\n+\n+    def test_mixed_valid_and_invalid_paths(self):\n+        mixed_paths = [\n+            \"valid/path.py\",\n+            \"valid_path\\\\x00.py\",\n+            \"another/\\\\x00valid/path.py\"\n+        ]\n+        expected_valid_paths = {\"valid/path.py\"}\n+        # Simulate existing files\n+        with patch(\"pathlib.Path.resolve\", side_effect=lambda p: pathlib.Path(p) if '\\\\x00' not in p else ValueError(\"embedded null byte\")):\n+            resolved_paths = autoreload.iter_modules_and_files((), frozenset(mixed_paths))\n+            self.assertTrue(all(str(p) in expected_valid_paths for p in resolved_paths))\n     def test_common_roots(self):\n         paths = (\n             Path('/first/second'),\n",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..f09ef09 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1,5 +1,21 @@\n import importlib\n import inspect\n+class DebugConverterTests(SimpleTestCase):\n+    def test_technical_404_converter_raise_404(self):\n+        # Mocking the IntConverter's to_python method to raise Http404\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+            response = self.client.get('/path-post/1/')\n+            # Assert that the response contains 'Page not found' with a 404 status\n+            self.assertContains(response, 'Page not found', status_code=404)\n+\n+    def test_technical_404_contains_debug_info(self):\n+        # If DEBUG is True, we expect more detailed information in the 404 response\n+        with self.settings(DEBUG=True):\n+            with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+                response = self.client.get('/path-post/1/')\n+                # Check for technical debug information in the response content\n+                self.assertContains(response, \"You're seeing this error because you have DEBUG = True\", status_code=404)\n+\n import os\n import re\n import sys\n@@ -10,6 +26,9 @@ from pathlib import Path\n from unittest import mock\n \n from django.core import mail\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n+from unittest import mock\n from django.core.files.uploadedfile import SimpleUploadedFile\n from django.db import DatabaseError, connection\n from django.shortcuts import render\n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..e876b2d 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -162,8 +162,32 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E121'\n             ),\n         ])\n-\n-    def test_non_iterable_choices(self):\n+    \n+    def test_choices_in_max_length(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2, choices=[\n+                    ('ABC', 'Value Too Long!'), ('OK', 'Good')\n+                ],\n+            )\n+            group = models.CharField(\n+                max_length=2, choices=[\n+                    ('Nested', [('OK', 'Good'), ('Longer', 'Longer')]),\n+                    ('Grouped', [('Bad', 'Bad')]),\n+                ],\n+            )\n+        \n+        for name, choice_max_length in (('field', 3), ('group', 6)):\n+            with self.subTest(name):\n+                field = Model._meta.get_field(name)\n+                self.assertEqual(field.check(), [\n+                    Error(\n+                        \"'max_length' is too small to fit the longest value \"\n+                        \"in 'choices' (%d characters).\" % choice_max_length,\n+                        obj=field,\n+                        id='fields.E009',\n+                    ),\n+                ])\n         class Model(models.Model):\n             field = models.CharField(max_length=10, choices='bad')\n \n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..0403b34 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -252,7 +252,26 @@ class WriterTests(SimpleTestCase):\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n \n-    def test_serialize_enums(self):\n+    def test_serialize_translated_enum(self):\n+        class TextTranslatedEnum(enum.Enum):\n+            A = _('a-value')\n+            B = _('value-b')\n+\n+        field = models.CharField(\n+            default=TextTranslatedEnum.A,\n+            choices=[(m.value, m) for m in TextTranslatedEnum],\n+            max_length=128\n+        )\n+        serialized, imports = MigrationWriter.serialize(field)\n+\n+        self.assertEqual(\n+            serialized,\n+            \"models.CharField(choices=[\"\n+            \"('a-value', migrations.test_writer.TextTranslatedEnum['A']), \"\n+            \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n+            \"default=migrations.test_writer.TextTranslatedEnum['A'], \"\n+            \"max_length=128)\"\n+        )\n         class TextEnum(enum.Enum):\n             A = 'a-value'\n             B = 'value-b'\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..4db26a9 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,5 +1,7 @@\n+\n import unittest\n-from datetime import datetime\n+from datetime import datetime, timedelta\n+from unittest import mock\n \n from django.test import SimpleTestCase, ignore_warnings\n from django.utils.datastructures import MultiValueDict\n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..d18d204 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -30,9 +30,18 @@ class Vehicle(models.IntegerChoices):\n     JET_SKI = 3\n \n     __empty__ = _('(Unknown)')\n+from django.test import SimpleTestCase\n+from django.db import models\n+from django.utils.translation import gettext_lazy as _\n \n \n-class Gender(models.TextChoices):\n+class ChoicesTests(SimpleTestCase):\n+    def test_str(self):\n+        all_test_classes = [Gender, Suit, YearInSchool, Vehicle]\n+        for test_class in all_test_classes:\n+            for member in test_class:\n+                with self.subTest(member=member):\n+                    self.assertEqual(str(member), member.value)\n     MALE = 'M'\n     FEMALE = 'F'\n     NOT_SPECIFIED = 'X'\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..db96415 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -150,7 +150,18 @@ class ChoicesTests(SimpleTestCase):\n \n class GetFieldDisplayTests(SimpleTestCase):\n \n-    def test_choices_and_field_display(self):\n+    def test_overriding_FIELD_display(self):\n+        \"\"\"\n+        Verify that get_FIELD_display can be overridden in a Django model.\n+        \"\"\"\n+        class FooBar(models.Model):\n+            foo_bar = models.CharField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                return 'something'\n+\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), 'something')\n         \"\"\"\n         get_choices() interacts with get_FIELD_display() to return the expected\n         values.\n",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "",
  "django__django-12284": "",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..3ad64d0 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,3 +1,4 @@\n+\n from django.core.checks import Error\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n@@ -75,6 +76,25 @@ class TranslationCheckTests(SimpleTestCase):\n                     Error(msg % tag, id='translation.E003'),\n                 ])\n \n+    @override_settings(\n+        USE_I18N=True,\n+        LANGUAGES=[\n+            ('de', 'German'),\n+            ('fr', 'French'),\n+            ('es', 'Spanish'),\n+        ],\n+    )\n+    def test_base_language_available_no_error(self):\n+        \"\"\"Test that no error is raised if the base language is available.\"\"\"\n+        valid_sublanguages = [\n+            'de-at',  # Base 'de' is available\n+            'fr-ca',  # Base 'fr' is available\n+            'es-mx',  # Base 'es' is available\n+        ]\n+        for tag in valid_sublanguages:\n+            with self.subTest(tag), self.settings(LANGUAGE_CODE=tag):\n+                self.assertEqual(check_language_settings_consistent(None), [])\n+\n     def test_inconsistent_language_settings(self):\n         msg = (\n             'You have provided a value for the LANGUAGE_CODE setting that is '\n",
  "django__django-12308": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex acbcf33..9256e4a 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -176,6 +176,24 @@ class UtilsTests(SimpleTestCase):\n         display_value = display_for_field(None, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, self.empty_value)\n \n+    def test_json_display_for_field(self):\n+        tests = [\n+            ({'a': {'b': 'c'}}, '{\"a\": {\"b\": \"c\"}}'),\n+            (['a', 'b'], '[\"a\", \"b\"]'),\n+            ('a', '\"a\"'),\n+            ({('a', 'b'): 'c'}, \"{('a', 'b'): 'c'}\"),  # Invalid JSON.\n+            ('{\"foo\": \"bar\"}', '{\"foo\": \"bar\"}'), # Already valid JSON string.\n+            (123, '123'),  # Numeric value inside JSONField\n+            (None, 'null'),  # None type inside JSONField\n+            (True, 'true'),  # Boolean value inside JSONField\n+        ]\n+        for value, display_value in tests:\n+            with self.subTest(value=value):\n+                self.assertEqual(\n+                    display_for_field(value, models.JSONField(), self.empty_value),\n+                    display_value,\n+                )\n+\n     def test_number_formats_display_for_field(self):\n         display_value = display_for_field(12345.6789, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, '12345.6789')\n",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..5c2203f 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from unittest import mock\n \n@@ -5,7 +6,8 @@ from django.db import DEFAULT_DB_ALIAS, connection, connections\n from django.db.backends.base.creation import (\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, TestCase\n+from ..models import Object, ObjectReference\n \n \n def get_connection_copy():\n",
  "django__django-12497": "diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 057ec3a..4ed362c 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -128,6 +128,47 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n+    def test_multiple_foreign_keys_without_through_fields(self):\n+        class Author(models.Model):\n+            pass\n+\n+        class Book(models.Model):\n+            pass\n+\n+        class Publication(models.Model):\n+            author = models.ForeignKey(Author, models.CASCADE)\n+            first_book = models.ForeignKey(Book, models.CASCADE, related_name='first')\n+            second_book = models.ForeignKey(Book, models.CASCADE, related_name='second')\n+\n+        class Anthology(models.Model):\n+            publications = models.ManyToManyField('Author', through='Publication')\n+\n+        field = Anthology._meta.get_field('publications')\n+        self.assertEqual(field.check(from_model=Anthology), [\n+            Error(\n+                \"The model is used as an intermediate model by \"\n+                \"'invalid_models_tests.Anthology.publications', but it has more than one \"\n+                \"foreign key from 'Book', which is ambiguous. You must specify which foreign \"\n+                \"key Django should use via the through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"Publication\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n+\n+    def test_correct_hints_without_symmetrical(self):\n+        class Store(models.Model):\n+            owner = models.ForeignKey('self', on_delete=models.CASCADE, related_name='owned_stores')\n+            partner = models.ForeignKey(\n+                'self', on_delete=models.CASCADE, related_name='partner_stores', null=True\n+            )\n+\n+        self.assertEqual(Store._meta.get_field('owner').related_query_name(), 'owned_stores')\n+        self.assertEqual(Store._meta.get_field('partner').related_query_name(), 'partner_stores')\n+\n     def test_ambiguous_relationship_model(self):\n \n         class Person(models.Model):\n",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..a3c1216 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1241,6 +1241,66 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleansed_substitute,\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n+    def test_cleanse_setting_handles_nested_iterables(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            'level1': [\n+                {'PASSWORD': 'secret'},\n+                {'level2': [\n+                    {'TOKEN': 'abcd-1234'},\n+                    ['nested_list_password', 'another_secret'],\n+                ]},\n+            ],\n+        }\n+        cleansed = {\n+            'level1': [\n+                {'PASSWORD': reporter_filter.cleansed_substitute},\n+                {'level2': [\n+                    {'TOKEN': reporter_filter.cleansed_substitute},\n+                    [reporter_filter.cleansed_substitute, reporter_filter.cleansed_substitute],\n+                ]},\n+            ],\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('NESTED_SETTING', initial),\n+            cleansed,\n+        )\n+\n     def test_cleanse_setting_recurses_in_dictionary(self):\n         reporter_filter = SafeExceptionReporterFilter()\n         initial = {'login': 'cooper', 'password': 'secret'}\n@@ -1249,6 +1309,66 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n+    def test_cleanse_setting_handles_nested_iterables(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            'level1': [\n+                {'PASSWORD': 'secret'},\n+                {'level2': [\n+                    {'TOKEN': 'abcd-1234'},\n+                    ['nested_list_password', 'another_secret'],\n+                ]},\n+            ],\n+        }\n+        cleansed = {\n+            'level1': [\n+                {'PASSWORD': reporter_filter.cleansed_substitute},\n+                {'level2': [\n+                    {'TOKEN': reporter_filter.cleansed_substitute},\n+                    [reporter_filter.cleansed_substitute, reporter_filter.cleansed_substitute],\n+                ]},\n+            ],\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('NESTED_SETTING', initial),\n+            cleansed,\n+        )\n+\n     def test_request_meta_filtering(self):\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n@@ -1257,6 +1377,66 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleansed_substitute,\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n+    def test_cleanse_setting_handles_nested_iterables(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            'level1': [\n+                {'PASSWORD': 'secret'},\n+                {'level2': [\n+                    {'TOKEN': 'abcd-1234'},\n+                    ['nested_list_password', 'another_secret'],\n+                ]},\n+            ],\n+        }\n+        cleansed = {\n+            'level1': [\n+                {'PASSWORD': reporter_filter.cleansed_substitute},\n+                {'level2': [\n+                    {'TOKEN': reporter_filter.cleansed_substitute},\n+                    [reporter_filter.cleansed_substitute, reporter_filter.cleansed_substitute],\n+                ]},\n+            ],\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('NESTED_SETTING', initial),\n+            cleansed,\n+        )\n+\n     def test_exception_report_uses_meta_filtering(self):\n         response = self.client.get('/raises500/', HTTP_SECRET_HEADER='super_secret')\n         self.assertNotIn(b'super_secret', response.content)\n@@ -1265,6 +1445,66 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             HTTP_SECRET_HEADER='super_secret',\n             HTTP_ACCEPT='application/json',\n         )\n+\n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+        )\n+\n+    def test_cleanse_setting_handles_nested_iterables(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = {\n+            'level1': [\n+                {'PASSWORD': 'secret'},\n+                {'level2': [\n+                    {'TOKEN': 'abcd-1234'},\n+                    ['nested_list_password', 'another_secret'],\n+                ]},\n+            ],\n+        }\n+        cleansed = {\n+            'level1': [\n+                {'PASSWORD': reporter_filter.cleansed_substitute},\n+                {'level2': [\n+                    {'TOKEN': reporter_filter.cleansed_substitute},\n+                    [reporter_filter.cleansed_substitute, reporter_filter.cleansed_substitute],\n+                ]},\n+            ],\n+        }\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('NESTED_SETTING', initial),\n+            cleansed,\n+        )\n         self.assertNotIn(b'super_secret', response.content)\n \n \n",
  "django__django-12708": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 2df48a2..4abfc97 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1751,6 +1751,29 @@ class OperationTests(OperationTestBase):\n         self.assertIndexNotExists(\"test_alinto_pony\", [\"pink\", \"weight\"])\n         # And deconstruction\n         definition = operation.deconstruct()\n+\n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_alter_index_together_remove_with_unique_together(self):\n+        app_label = 'test_alintoremove_wunto'\n+        table_name = '%s_pony' % app_label\n+        project_state = self.set_up_test_model(app_label, unique_together=True)\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+        # Add index together.\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexExists(table_name, ['pink', 'weight'])\n+        # Remove index together.\n+        project_state = new_state\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', set())\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n         self.assertEqual(definition[0], \"AlterIndexTogether\")\n         self.assertEqual(definition[1], [])\n         self.assertEqual(definition[2], {'name': \"Pony\", 'index_together': {(\"pink\", \"weight\")}})\n",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..f912392 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -685,7 +685,23 @@ class FastDeleteTests(TestCase):\n         self.assertNumQueries(2, a.delete)\n         self.assertEqual(User.objects.count(), 0)\n \n-    def test_fast_delete_empty_no_update_can_self_select(self):\n+    def test_inconsistent_deleted_objects_format_zero_objects(self):\n+        \"\"\"\n+        Test to verify that if no objects are deleted, the format of the result \n+        is consistent between models with and without foreign keys: \n+        (0, {'model_label': 0}) or (0, {}).\n+        \"\"\"\n+        # Scenario for a model without foreign keys\n+        result_no_fk = BlockLibrary.objects.filter(id=-1).delete()\n+        self.assertEqual(result_no_fk, (0, {'delete.BlockLibrary': 0}))\n+\n+        # Scenario for a model with foreign keys\n+        result_with_fk = HiddenUser.objects.filter(id=-1).delete()\n+        self.assertEqual(result_with_fk, (0, {'delete.HiddenUser': 0}))\n+\n+        # Checking for other models to ensure consistent format\n+        result_hidden_user_profile = HiddenUserProfile.objects.filter(id=-1).delete()\n+        self.assertEqual(result_hidden_user_profile, (0, {'delete.HiddenUserProfile': 0}))\n         \"\"\"\n         #25932 - Fast deleting on backends that don't have the\n         `no_update_can_self_select` feature should work even if the specified\n",
  "django__django-12856": "",
  "django__django-12915": "diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex 72f5bd1..e9bead6 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -73,13 +73,79 @@ class ASGITest(SimpleTestCase):\n                 (b'Content-Disposition', b'inline; filename=\"urls.py\"'),\n             },\n         )\n-        response_body = await communicator.receive_output()\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        file_path = TEST_STATIC_ROOT / 'file.txt'\n+        with open(file_path, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+        stat = file_path.stat()\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', str(len(test_file_contents)).encode('ascii')),\n+                (b'Content-Type', b'text/plain'),\n+                (b'Content-Disposition', b'inline; filename=\"file.txt\"'),\n+                (b'Last-Modified', http_date(stat.st_mtime).encode('ascii')),\n+            },\n+        )\n         self.assertEqual(response_body['type'], 'http.response.body')\n         self.assertEqual(response_body['body'], test_file_contents)\n         # Allow response.close() to finish.\n         await communicator.wait()\n \n-    async def test_headers(self):\n+    async def test_asgi_static_file_response(self):\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        scope = self.async_request_factory._base_scope(path='/static/file.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        file_path = TEST_STATIC_ROOT / 'file.txt'\n+        with open(file_path, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+        stat = file_path.stat()\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', str(len(test_file_contents)).encode('ascii')),\n+                (b'Content-Type', b'text/plain'),\n+                (b'Content-Disposition', b'inline; filename=\"file.txt\"'),\n+                (b'Last-Modified', http_date(stat.st_mtime).encode('ascii')),\n+            },\n+        )\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        file_path = TEST_STATIC_ROOT / 'file.txt'\n+        with open(file_path, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+        stat = file_path.stat()\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', str(len(test_file_contents)).encode('ascii')),\n+                (b'Content-Type', b'text/plain'),\n+                (b'Content-Disposition', b'inline; filename=\"file.txt\"'),\n+                (b'Last-Modified', http_date(stat.st_mtime).encode('ascii')),\n+            },\n+        )\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], test_file_contents)\n+\n+    async def test_asgi_static_file_response_not_found(self):\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        scope = self.async_request_factory._base_scope(path='/static/nonexistent.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 404)\n         application = get_asgi_application()\n         communicator = ApplicationCommunicator(\n             application,\n",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..94549ed 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -197,6 +197,19 @@ class TestUtilsText(SimpleTestCase):\n             ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True),\n             ('\u4f60\u597d', '\u4f60\u597d', True),\n             ('\u0130stanbul', 'istanbul', True),\n+            # Test cases from the original test patch\n+            (' multiple---dash and  space ', 'multiple-dash-and-space', False),\n+            ('\\t whitespace-in-value \\n', 'whitespace-in-value', False),\n+            ('underscore_in-value', 'underscore_in-value', False),\n+            ('__strip__underscore-value___', 'strip-underscore-value', False),\n+            ('--strip-dash-value---', 'strip-dash-value', False),\n+            ('__strip-mixed-value---', 'strip-mixed-value', False),\n+            ('_ -strip-mixed-value _-', 'strip-mixed-value', False),\n+            # New test cases for issue fix verification\n+            ('---leading-and-trailing-dashes---', 'leading-and-trailing-dashes', False),\n+            ('___leading-and-trailing-underscores___', 'leading-and-trailing-underscores', False),\n+            ('---___mixed-underscores-and-dashes___---', 'mixed-underscores-and-dashes', False),\n+            ('_ mix of -- spaces___and---dashes _', 'mix-of-spaces-and-dashes', False),\n         )\n         for value, output, is_unicode in items:\n             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n",
  "django__django-13028": "",
  "django__django-13158": "diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py\nindex 070e08e..a20b765 100644\n--- a/tests/queries/test_qs_combinators.py\n+++ b/tests/queries/test_qs_combinators.py\n@@ -1,3 +1,4 @@\n+\n import operator\n \n from django.db import DatabaseError, NotSupportedError, connection\n@@ -86,7 +87,31 @@ class QuerySetSetOperationTests(TestCase):\n         reserved_name = qs1.difference(qs2).values_list('name', 'order', 'id').get()\n         self.assertEqual(reserved_name[:2], ('a', 2))\n \n-    def test_union_with_empty_qs(self):\n+    def test_union_with_none(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.filter(num__gte=8)\n+        qs3 = qs1.union(qs2)\n+        self.assertEqual(qs3.none().count(), 0)\n+\n+    def test_union_multiple_with_none(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.filter(num__gte=8)\n+        qs3 = Number.objects.filter(num=5)\n+        union_qs = qs1.union(qs2, qs3)\n+        self.assertEqual(union_qs.none().count(), 0)\n+\n+    def test_union_mixed_empty_and_nonempty_with_none(self):\n+        qs1 = Number.objects.filter(num__lte=1)\n+        qs2 = Number.objects.none()\n+        qs3 = Number.objects.filter(num=5)\n+        union_qs = qs1.union(qs2, qs3)\n+        self.assertEqual(union_qs.none().count(), 0)\n+\n+    def test_combination_with_none(self):\n+        qs1 = Number.objects.filter(num__lte=2)\n+        qs2 = Number.objects.filter(num__gt=7)\n+        combination = qs1.union(qs2)\n+        self.assertEqual(combination.none().count(), 0)\n         qs1 = Number.objects.all()\n         qs2 = Number.objects.none()\n         qs3 = Number.objects.filter(pk__in=[])\n@@ -313,4 +338,4 @@ class QuerySetSetOperationTests(TestCase):\n                         NotSupportedError,\n                         msg % (operation, combinator),\n                     ):\n-                        getattr(getattr(qs, combinator)(qs), operation)()\n+                        getattr(getattr(qs, combinator)(qs), operation)()\n",
  "django__django-13230": "",
  "django__django-13315": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 64b15bf..e5d0b2d 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2829,8 +2829,76 @@ class LimitChoicesToTests(TestCase):\n             StumpJokeForm()\n             self.assertEqual(today_callable_dict.call_count, 3)\n \n+class DuplicateChoiceInLimitChoicesTests(TestCase):\n+    def setUp(self):\n+        self.threepwood = Character.objects.create(username='Threepwood', last_action='2023-10-01T10:00:00Z')\n+        self.marley = Character.objects.create(username='Marley', last_action='2023-10-01T12:00:00Z')\n+\n+    @isolate_apps('model_forms')\n+    def test_limit_choices_to_no_duplicates(self):\n+        joke1 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.threepwood,\n+        )\n+        joke2 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.threepwood,\n+        )\n+        joke3 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.marley,\n+        )\n+        StumpJoke.objects.create(funny=False, most_recently_fooled=self.marley)\n+        joke1.has_fooled_today.add(self.marley, self.threepwood)\n+        joke2.has_fooled_today.add(self.marley)\n+        joke3.has_fooled_today.add(self.marley, self.threepwood)\n+\n+        class CharacterDetails(models.Model):\n+            character1 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_fk_1',\n+            )\n+            character2 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to={\n+                    'jokes__funny': True,\n+                    'jokes_today__funny': True,\n+                },\n+                related_name='details_fk_2',\n+            )\n+            character3 = models.ManyToManyField(\n+                Character,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_m2m_1',\n+            )\n \n-class FormFieldCallbackTests(SimpleTestCase):\n+        class CharacterDetailsForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetails\n+                fields = '__all__'\n+\n+        form = CharacterDetailsForm()\n+        self.assertCountEqual(\n+            form.fields['character1'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character2'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character3'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n \n     def test_baseform_with_widgets_in_meta(self):\n         \"\"\"Regression for #13095: Using base forms with widgets defined in Meta should not raise errors.\"\"\"\n",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 536c423..084e738 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -11,7 +11,35 @@ from django.test.utils import isolate_apps\n \n @isolate_apps('model_inheritance')\n class AbstractInheritanceTests(SimpleTestCase):\n-    def test_single_parent(self):\n+    def test_abstract_inherited_fields_equality(self):\n+        \"\"\"Field instances from different sibling classes aren't equal\"\"\"\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritAbstractModel1(AbstractModel):\n+            pass\n+\n+        class InheritAbstractModel2(AbstractModel):\n+            pass\n+\n+        field1 = InheritAbstractModel1._meta.get_field('field')\n+        field2 = InheritAbstractModel2._meta.get_field('field')\n+\n+        # Check they are not equal\n+        self.assertNotEqual(field1, field2)\n+\n+        # Check they can exist in a set separately\n+        field_set = {field1, field2}\n+        self.assertEqual(len(field_set), 2)\n+\n+        # Check hash values are not equal\n+        self.assertNotEqual(hash(field1), hash(field2))\n+\n+        # Check comparison using __lt__\n+        self.assertTrue(field1 < field2 or field2 < field1)\n         class AbstractBase(models.Model):\n             name = models.CharField(max_length=30)\n \n@@ -347,4 +375,4 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('age', models.SmallIntegerField), ('concretemodel2_ptr', models.OneToOneField),\n                 ('name', models.CharField),\n             ]\n-        )\n+        )\n",
  "django__django-13447": "diff --git a/tests/admin_views/test_adminsite.py b/tests/admin_views/test_adminsite.py\nindex 16a02bb..635d5ab 100644\n--- a/tests/admin_views/test_adminsite.py\n+++ b/tests/admin_views/test_adminsite.py\n@@ -46,6 +46,19 @@ class SiteEachContextTest(TestCase):\n         self.assertEqual(site.each_context(request)['site_url'], '/my-script-name/')\n \n     def test_available_apps(self):\n+        # Our additional test case to verify that the 'model' class is correctly available in the app_list context.\n+        ctx = self.ctx\n+        apps = ctx['available_apps']\n+\n+        # Verify the 'model' is part of the app_list for admin_views.Article\n+        admin_views = apps[0]\n+        article = admin_views['models'][0]\n+        self.assertEqual(article['model'], Article)\n+\n+        # Check for auth.User as well\n+        auth = apps[1]\n+        user = auth['models'][0]\n+        self.assertEqual(user['model'], User)\n         ctx = self.ctx\n         apps = ctx['available_apps']\n         # we have registered two models from two different apps\n",
  "django__django-13551": "",
  "django__django-13590": "",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..2a6b1f8 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -19,7 +19,9 @@ from django.conf import settings\n from django.core.management import (\n     BaseCommand, CommandError, call_command, color,\n )\n-from django.core.management.commands.loaddata import Command as LoaddataCommand\n+from unittest import mock\n+from django.core.management import execute_from_command_line\n+from django.test.utils import captured_stderr, captured_stdout\n from django.core.management.commands.runserver import (\n     Command as RunserverCommand,\n )\n",
  "django__django-13660": "",
  "django__django-13710": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 2d83d62..fb6b10f 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -962,9 +962,55 @@ class TestReadOnlyChangeViewInlinePermissions(TestCase):\n         response = self.client.get(self.change_url)\n         self.assertNotContains(response, 'id=\"id_question_set-0-text\"')\n \n+from django.contrib.admin.sites import site as admin_site\n+from django.test import TestCase, override_settings\n+from django.urls import reverse\n+from django.test import RequestFactory\n+from .models import Profile, VerboseNameProfile, VerboseNamePluralProfile, BothVerboseNameProfile, ProfileCollection\n+from django.contrib.admin import ModelAdmin, TabularInline\n \n @override_settings(ROOT_URLCONF='admin_inlines.urls')\n-class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n+class TestVerboseNameInlineForms(TestCase):\n+    factory = RequestFactory()\n+    superuser = User.objects.create_superuser(username='admin', password='password', email='admin@example.com')\n+\n+    def test_verbose_name_as_default_plural_inline(self):\n+        \"\"\"\n+        This test verifies that when only 'verbose_name' is specified for an\n+        inline, 'verbose_name_plural' defaults properly based on the 'verbose_name'.\n+        \"\"\"\n+        class VerboseNameOnlyInline(TabularInline):\n+            model = Profile\n+            verbose_name = 'Singular Child'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [VerboseNameOnlyInline,]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+        # Test only specifying verbose_name\n+        self.assertContains(response, '<h2>Singular Childs</h2>')\n+        self.assertContains(response, 'Add another Singular Child')\n+\n+    def test_inline_defaults(self):\n+        \"\"\"\n+        Ensure inline defaults to model's Meta attributes when no verbose names are set.\n+        \"\"\"\n+        class DefaultMetaProfileInline(TabularInline):\n+            model = Profile  # Assume the model's Meta has verbose_name and verbose_name_plural\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [DefaultMetaProfileInline,]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+        # The test checks Django's default pluralization behavior\n+        self.assertContains(response, '<h2>Profiles</h2>')  # Assuming 'Profiles' from the model's Meta\n+        self.assertContains(response, 'Add another Profile')  # Singular form\n     factory = RequestFactory()\n \n     def test_verbose_name_plural_inline(self):\n",
  "django__django-13757": "",
  "django__django-13768": "",
  "django__django-13925": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 6424d89..8998dbe 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -370,6 +370,11 @@ def mocked_is_overridden(self, setting):\n         self.DEFAULT_AUTO_FIELD != 'django.db.models.AutoField'\n     )\n \n+from django.core.checks import Warning\n+import django.core.checks as checks\n+from django.test import SimpleTestCase\n+import unittest.mock as mock\n+from django.test.utils import override_settings\n \n @mock.patch('django.conf.UserSettingsHolder.is_overridden', mocked_is_overridden)\n @override_settings(DEFAULT_AUTO_FIELD='django.db.models.AutoField')\n@@ -402,7 +407,23 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n \n         self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n \n-    def test_explicit_pk(self):\n+    def test_inherited_explicit_pk(self):\n+        class Parent(models.Model):\n+            id = models.BigAutoField(primary_key=True)\n+\n+        class Child(Parent):\n+            pass\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+        \n+    def test_inherited_explicit_pk_with_parent_link(self):\n+        class Parent(models.Model):\n+            id = models.BigAutoField(primary_key=True)\n+\n+        class Child(Parent):\n+            parent_ptr = models.OneToOneField(Parent, models.CASCADE, parent_link=True)\n+\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n         class Model(models.Model):\n             id = models.BigAutoField(primary_key=True)\n \n@@ -414,4 +435,4 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n             class Meta:\n                 app_label = 'check_framework.apps.CheckPKConfig'\n \n-        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..6dd3e4e 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -281,8 +281,37 @@ class FormsErrorMessagesTestCase(SimpleTestCase, AssertFormErrorsMixin):\n             '</ul></li></ul>'\n         )\n \n+from django.test import TestCase\n+from .models import ChoiceModel\n+from django.forms import ModelChoiceField, ModelMultipleChoiceField\n+from .utils import AssertFormErrorsMixin\n \n class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n+    def test_modelchoicefield_value_placeholder(self):\n+        f = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            },\n+        )\n+        self.assertFormErrors(\n+            ['\"invalid\" is not one of the available choices.'],\n+            f.clean,\n+            'invalid',\n+        )\n+\n+    def test_modelmultiplechoicefield_value_placeholder(self):\n+        f = ModelMultipleChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            },\n+        )\n+        self.assertFormErrors(\n+            ['\"invalid\" is not one of the available choices.'],\n+            f.clean,\n+            ['invalid'],\n+        )\n     def test_modelchoicefield(self):\n         # Create choices for the model choice field tests below.\n         ChoiceModel.objects.create(pk=1, name='a')\n@@ -307,4 +336,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "diff --git a/tests/many_to_one/tests.py b/tests/many_to_one/tests.py\nindex 8af1b8e..affed52 100644\n--- a/tests/many_to_one/tests.py\n+++ b/tests/many_to_one/tests.py\n@@ -1,10 +1,11 @@\n+\n import datetime\n from copy import deepcopy\n \n from django.core.exceptions import FieldError, MultipleObjectsReturned\n from django.db import IntegrityError, models, transaction\n from django.test import TestCase\n-from django.utils.translation import gettext_lazy\n+from django.db.utils import IntegrityError\n \n from .models import (\n     Article, Category, Child, ChildNullableParent, City, Country, District,\n@@ -549,7 +550,45 @@ class ManyToOneTests(TestCase):\n         self.assertEqual(child.parent, parent)\n         self.assertEqual(child.parent_id, parent.name)\n \n-    def test_fk_to_bigautofield(self):\n+    def test_save_fk_after_parent_with_non_numeric_pk_set_on_child_with_unsaved_parent(self):\n+        # Following the example described in the issue\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey()\n+            child = ChildStringPrimaryKeyParent()\n+            child.parent = parent\n+            child.parent.name = 'foo'\n+            child.parent.save()  # Parent is saved with name set\n+            child.save()  # Child should save successfully\n+            child.refresh_from_db()  # Refresh to get updated instance\n+            self.assertEqual(child.parent, parent)  # Ensure the parent's set\n+            self.assertEqual(child.parent_id, parent.name)  # Ensure IDs match\n+\n+    def test_unsaved_parent_with_non_numeric_pk_without_saving_parent(self):\n+        # Check behavior if parent is not saved\n+        with transaction.atomic():\n+            parent = ParentStringPrimaryKey(name='foo')\n+            child = ChildStringPrimaryKeyParent()\n+            child.parent = parent\n+            with self.assertRaises(IntegrityError):\n+                child.save()  # Expect failure, as parent wasn't saved\n+\n+    def test_setting_fk_with_saved_parent_and_child(self):\n+        parent = ParentStringPrimaryKey.objects.create(name='foo')\n+        child = ChildStringPrimaryKeyParent.objects.create(parent=parent)\n+        self.assertEqual(child.parent, parent)\n+        self.assertEqual(child.parent_id, parent.name)\n+\n+    def test_resetting_parent_before_saving_child(self):\n+        parent1 = ParentStringPrimaryKey.objects.create(name='foo')\n+        parent2 = ParentStringPrimaryKey(name='bar')  # Unsaved instance\n+        child = ChildStringPrimaryKeyParent(parent=parent1)\n+        child.save()\n+        child.parent = parent2\n+        parent2.save()  # Save the new parent before saving the child again\n+        child.save()  # Now save the child with the new parent association\n+        child.refresh_from_db()\n+        self.assertEqual(child.parent, parent2)\n+        self.assertEqual(child.parent_id, parent2.name)\n         ch = City.objects.create(name='Chicago')\n         District.objects.create(city=ch, name='Far South')\n         District.objects.create(city=ch, name='North')\n",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..ab83949 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import F, Q\n from django.test import SimpleTestCase\n \n@@ -16,10 +17,18 @@ class QTests(SimpleTestCase):\n         self.assertEqual(q | Q(), q)\n         self.assertEqual(Q() | q, q)\n \n-    def test_combine_or_both_empty(self):\n+    def test_dict_keys_with_or_operator(self):\n+        q = Q(x__in={}.keys())  # Using dict_keys\n+        # Test combining with empty Q() using OR\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n         self.assertEqual(Q() | Q(), Q())\n \n-    def test_combine_not_q_object(self):\n+    def test_dict_keys_with_and_operator(self):\n+        q = Q(x__in={}.keys())  # Using dict_keys\n+        # Test combining with empty Q() using AND\n+        self.assertEqual(q & Q(), q)\n+        self.assertEqual(Q() & q, q)\n         obj = object()\n         q = Q(x=1)\n         with self.assertRaisesMessage(TypeError, str(obj)):\n",
  "django__django-14017": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 707f339..8355575 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -25,6 +25,7 @@ from django.db.models.functions import (\n from django.db.models.sql import constants\n from django.db.models.sql.datastructures import Join\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n+from django.db.models import Exists, OuterRef, Q\n from django.test.utils import (\n     Approximate, CaptureQueriesContext, isolate_apps, register_lookup,\n )\n@@ -794,7 +795,23 @@ class BasicExpressionsTests(TestCase):\n         )\n         self.assertCountEqual(qs, [self.example_inc.ceo, self.foobar_ltd.ceo, self.max])\n \n-    def test_boolean_expression_combined(self):\n+    def test_q_exists_commutativity(self):\n+        # This test is specifically designed to ensure Q and Exists combination is commutative\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+\n+        tests = [\n+            (Exists(is_ceo) & Q(), [self.example_inc.ceo]),\n+            (Q() & Exists(is_ceo), [self.example_inc.ceo]),\n+            (Exists(is_poc) & Q(), [self.max]),\n+            (Q() & Exists(is_poc), [self.max]),\n+        ]\n+        \n+        for conditions, expected in tests:\n+            with self.subTest(conditions=conditions):\n+                self.assertCountEqual(Employee.objects.filter(conditions), expected)\n         is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n         is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n         self.gmbh.point_of_contact = self.max\n",
  "django__django-14155": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 0f968fa..0485bf9 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1127,8 +1127,33 @@ class ResolverMatchTests(SimpleTestCase):\n                 self.assertEqual(match[0], func)\n                 self.assertEqual(match[1], args)\n                 self.assertEqual(match[2], kwargs)\n+    import functools\n+    from django.urls import resolve\n+    from . import views\n \n-    def test_resolver_match_on_request(self):\n+    @override_settings(ROOT_URLCONF='urlpatterns_reverse.urls')\n+    def test_repr_functools_partial(self):\n+        \"\"\"\n+        Test that ResolverMatch.__repr__ correctly handles views passed as functools.partial objects.\n+        \"\"\"\n+        partial_view = functools.partial(views.empty_view, template_name='template.html')\n+        expected_repr = (\n+            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+            \"args=(), kwargs={'template_name': 'template.html'}, url_name=None, \"\n+            \"app_names=[], namespaces=[], route=None)\"\n+        )\n+        # Assuming you have a URL pattern that resolves to `partial_view` without additional args\n+        self.assertEqual(repr(resolve('/partial-view-path/')), expected_repr)\n+\n+        # Test with additional arguments in the partial\n+        partial_with_args = functools.partial(views.empty_view, 'partial_arg', template_name='template.html')\n+        expected_repr_with_args = (\n+            \"ResolverMatch(func=urlpatterns_reverse.views.empty_view, \"\n+            \"args=('partial_arg',), kwargs={'template_name': 'template.html'}, url_name=None, \"\n+            \"app_names=[], namespaces=[], route=None)\"\n+        )\n+        # Assuming you have a URL pattern that resolves to `partial_with_args` with additional args\n+        self.assertEqual(repr(resolve('/partial-view-args-path/')), expected_repr_with_args)\n         response = self.client.get('/resolver_match/')\n         resolver_match = response.resolver_match\n         self.assertEqual(resolver_match.url_name, 'test-resolver-match')\n",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..9438bb9 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,4 +1,6 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n+from django.test import override_settings\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n from django.test.utils import isolate_apps\n@@ -66,7 +68,29 @@ class TestDefaultPK(SimpleTestCase):\n             class Model(models.Model):\n                 pass\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        # Verify the primary key is an instance of MyBigAutoField\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        # Verify the primary key is an instance of MySmallAutoField\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n@@ -82,7 +106,29 @@ class TestDefaultPK(SimpleTestCase):\n \n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        # Verify the primary key is an instance of MyBigAutoField\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        # Verify the primary key is an instance of MySmallAutoField\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_m2m_default_auto_field_setting(self):\n         class M2MModel(models.Model):\n",
  "django__django-14382": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex afeed3e..c7264e5 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2197,6 +2197,16 @@ class StartApp(AdminScriptTestCase):\n                     \"make sure the directory is a valid identifier.\" % bad_target\n                 )\n \n+    def test_trailing_slash_in_target_app_directory_name(self):\n+        \"\"\"\n+        Test startapp command with a trailing slash in the directory name.\n+        \"\"\"\n+        app_dir = os.path.join(self.test_dir, 'apps', 'app1')\n+        os.makedirs(app_dir)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', 'app1', '')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n+\n     def test_importable_target_name(self):\n         _, err = self.run_django_admin(['startapp', 'app', 'os'])\n         self.assertOutput(\n",
  "django__django-14411": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 331338c..8e5c65a 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -14,6 +14,7 @@ from django.core import mail\n from django.core.exceptions import ValidationError\n from django.core.mail import EmailMultiAlternatives\n from django.forms.fields import CharField, Field, IntegerField\n+from django.forms import forms\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.utils import translation\n from django.utils.text import capfirst\n@@ -1020,6 +1021,21 @@ class ReadOnlyPasswordHashTest(SimpleTestCase):\n             \"\"\"\n         )\n \n+    def test_readonly_field_without_for_attribute(self):\n+        \"\"\"\n+        Ensure that the ReadOnlyPasswordHashWidget label does not have a 'for' attribute.\n+        \"\"\"\n+        class TestForm(forms.Form):\n+            hash_field = ReadOnlyPasswordHashField()\n+\n+        bound_field = TestForm()['hash_field']\n+        \n+        # Ensure the id_for_label method returns None, meaning there's no labelable element.\n+        self.assertIsNone(bound_field.field.widget.id_for_label('id'))\n+        \n+        # Ensure the label tag does not contain a 'for' attribute.\n+        self.assertEqual(bound_field.label_tag(), '<label>Hash field:</label>')\n+\n     def test_readonly_field_has_changed(self):\n         field = ReadOnlyPasswordHashField()\n         self.assertIs(field.disabled, True)\n",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..b20954f 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -655,6 +655,30 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(result.args, value.args)\n         self.assertEqual(result.keywords, value.keywords)\n \n+    def test_serialize_custom_field_and_mixin(self):\n+        \"\"\"\n+        Test that migrations with custom fields and mixins serialize correctly.\n+        \"\"\"\n+        # Define a mock setup similar to the reported issue\n+        class MyField(models.TextField):\n+            pass\n+\n+        class MyBaseModel(models.Model):\n+            class Meta:\n+                abstract = True\n+\n+        class MyMixin:\n+            pass\n+\n+        class MyModel(MyMixin, MyBaseModel):\n+            name = MyField(primary_key=True)\n+\n+        # Run makemigrations and check the result\n+        migration_writer = MigrationWriter()\n+        serialized = migration_writer.serialize(MyModel)\n+        self.assertIn(\"('models.Model',\", serialized)\n+        self.assertIn(\"'from django.db import models'\", serialized)\n+\n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n \n",
  "django__django-14608": "diff --git a/tests/admin_views/tests.py b/tests/admin_views/tests.py\nindex 0b8d2fa..31136a3 100644\n--- a/tests/admin_views/tests.py\n+++ b/tests/admin_views/tests.py\n@@ -3349,6 +3349,8 @@ class AdminViewListEditable(TestCase):\n         non_form_errors = response.context['cl'].formset.non_form_errors()\n         self.assertIsInstance(non_form_errors, ErrorList)\n         self.assertEqual(str(non_form_errors), str(ErrorList([\"Grace is not a Zombie\"])))\n+        # New test to verify the CSS class 'nonform' is present\n+        self.assertIn('nonform', non_form_errors.as_ul())\n \n     def test_list_editable_ordering(self):\n         collector = Collector.objects.create(id=1, name=\"Frederick Clegg\")\n",
  "django__django-14672": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex d9eaabe..f7ac63d 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -11,6 +11,9 @@ from .models import (\n )\n \n \n+from django.test import TestCase\n+from .models import Person, Group, Membership, Invitation, Event\n+\n class M2mThroughTests(TestCase):\n     @classmethod\n     def setUpTestData(cls):\n@@ -31,7 +34,15 @@ class M2mThroughTests(TestCase):\n             attrgetter(\"name\")\n         )\n \n-    def test_get_on_intermediate_model(self):\n+    \n+    def test_m2m_through_fields_list_hashable(self):\n+        reverse_m2m = Person._meta.get_field('events_invited')\n+        self.assertEqual(reverse_m2m.through_fields, ['event', 'invitee'])\n+        \n+        # Add a check to compare hash of inherited relations\n+        inherited_reverse_m2m = Person.objects.create(name='Child')\n+        event_field = Event._meta.get_field('invitees')\n+        self.assertEqual(hash(reverse_m2m), hash(event_field))\n         Membership.objects.create(person=self.jane, group=self.rock)\n \n         queryset = Membership.objects.get(person=self.jane, group=self.rock)\n",
  "django__django-14752": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex 7ef6d86..8a320cc 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -281,7 +281,44 @@ class AutocompleteJsonViewTests(AdminViewBasicTestCase):\n             'results': [{'id': str(q.pk), 'text': q.question} for q in Question.objects.all()[:PAGINATOR_SIZE]],\n             'pagination': {'more': True},\n         })\n-        # The second page of results.\n+import json\n+from django.urls import path\n+from django.test import TestCase, RequestFactory\n+from django.contrib.auth.models import User\n+from django.http import JsonResponse\n+from django.test.utils import override_settings\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+from .models import Question\n+\n+class TestAutocompleteJsonView(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        cls.superuser = User.objects.create_superuser(\n+            username='super', password='secret', email='super@example.com',\n+        )\n+        Question.objects.create(question='First Question', notes='Notes 1')\n+        Question.objects.create(question='Second Question', notes='Notes 2')\n+        cls.factory = RequestFactory()\n+        cls.url = '/autocomplete/'\n+        cls.opts = {'model_name': 'question'}\n+\n+    def test_serialize_result_custom_fields(self):\n+        class CustomAutocompleteJsonView(AutocompleteJsonView):\n+            def serialize_result(self, obj, to_field_name):\n+                result = super().serialize_result(obj, to_field_name)\n+                result['notes'] = obj.notes  # Adding custom attribute\n+                return result\n+        \n+        request = self.factory.get(self.url, {'term': 'Question', **self.opts})\n+        request.user = self.superuser\n+        response = CustomAutocompleteJsonView.as_view(admin_site=None)(request)\n+        self.assertEqual(response.status_code, 200)\n+        data = json.loads(response.content.decode('utf-8'))\n+        expected_results = [\n+            {'id': str(q.pk), 'text': q.question, 'notes': q.notes} for q in Question.objects.all()\n+        ]\n+        self.assertEqual(data['results'], expected_results)\n+        self.assertFalse(data['pagination']['more'])\n         request = self.factory.get(self.url, {'term': '', 'page': '2', **self.opts})\n         request.user = self.superuser\n         with model_admin(Question, PKOrderingQuestionAdmin):\n",
  "django__django-14787": "",
  "django__django-14855": "",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..06ab29c 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,9 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n@@ -341,7 +342,33 @@ class ModelChoiceFieldTests(TestCase):\n </div>\"\"\" % (self.c1.pk, self.c2.pk, self.c3.pk),\n         )\n \n-    def test_choices_not_fetched_when_not_rendering(self):\n+    def test_choice_value_hash(self):\n+        # Assuming self.c1 and self.c2 are objects with a primary key attribute.\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+\n+        # Test: Hash of a value should be consistent if the primary key is the same\n+        self.assertEqual(hash(value_1), hash(ModelChoiceIteratorValue(self.c1.pk, None)))\n+\n+        # Test: Different primary keys should result in different hashes\n+        self.assertNotEqual(hash(value_1), hash(value_2))\n+\n+    def test_model_choice_iterator_value_equality(self):\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        same_value = ModelChoiceIteratorValue(self.c1.pk, None)\n+        different_value = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+\n+        # Test: ModelChoiceIteratorValues with the same value should be equal\n+        self.assertEqual(value_1, same_value)\n+\n+        # Test: ModelChoiceIteratorValues with different values should not be equal\n+        self.assertNotEqual(value_1, different_value)\n+\n+    def test_model_choice_iterator_value_str(self):\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        \n+        # Test: String representation should be the string of the value (primary key)\n+        self.assertEqual(str(value_1), str(self.c1.pk))\n         with self.assertNumQueries(1):\n             field = forms.ModelChoiceField(Category.objects.order_by('-name'))\n             self.assertEqual('Entertainment', field.clean(self.c1.pk).name)\n",
  "django__django-14999": "",
  "django__django-15061": "",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..60f4ea7 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -70,6 +70,10 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # IPv6.\n             ('http://[12:34::3a53]/', 'http://[12:34::3a53]/'),\n             ('http://[a34:9238::]:8080/', 'http://[a34:9238::]:8080/'),\n+            # Added test cases for issue where URLField should raise ValidationError instead of ValueError\n+            # when faced with invalid URLs.\n+            ('////]@N.AN', \"'Enter a valid URL.'\"), # Invalid IPv6 URL case as cited in the issue\n+            ('#@A.bO', \"'Enter a valid URL.'\"),      # Empty hostname case\n         ]\n         for url, expected in tests:\n             with self.subTest(url=url):\n@@ -100,6 +104,10 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # even on domains that don't fail the domain label length check in\n             # the regex.\n             'http://%s' % (\"X\" * 200,),\n+            # Added test cases for issue where URLField should raise ValidationError instead of ValueError\n+            # when faced with invalid URLs.\n+            ('////]@N.AN', \"'Enter a valid URL.'\"), # Invalid IPv6 URL case as cited in the issue\n+            ('#@A.bO', \"'Enter a valid URL.'\"),      # Empty hostname case\n         ]\n         msg = \"'Enter a valid URL.'\"\n         for value in tests:\n@@ -107,7 +115,23 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n                 with self.assertRaisesMessage(ValidationError, msg):\n                     f.clean(value)\n \n-    def test_urlfield_clean_required(self):\n+    def test_urlfield_clean_value_error(self):\n+        # Test the case where ValueError was thrown to ensure ValidationError is now raised\n+        f = URLField()\n+        # URLs expected to raise ValidationError\n+        invalid_urls = [\n+            '////]@N.AN',\n+            '#@A.bO',\n+            # Added test cases for issue where URLField should raise ValidationError instead of ValueError\n+            # when faced with invalid URLs.\n+            ('////]@N.AN', \"'Enter a valid URL.'\"), # Invalid IPv6 URL case as cited in the issue\n+            ('#@A.bO', \"'Enter a valid URL.'\"),      # Empty hostname case\n+        ]\n+        msg = \"'Enter a valid URL.'\"\n+        for url in invalid_urls:\n+            with self.subTest(url=url):\n+                with self.assertRaisesMessage(ValidationError, msg):\n+                    f.clean(url)\n         f = URLField()\n         msg = \"'This field is required.'\"\n         with self.assertRaisesMessage(ValidationError, msg):\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..84f6f16 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -5,7 +5,7 @@ from django.core.exceptions import FieldDoesNotExist, FieldError\n from django.db.models import (\n     BooleanField, Case, CharField, Count, DateTimeField, DecimalField, Exists,\n     ExpressionWrapper, F, FloatField, Func, IntegerField, Max, OuterRef, Q,\n-    Subquery, Sum, Value, When,\n+    Subquery, Sum, Value, When, ExpressionWrapper, BooleanField\n )\n from django.db.models.expressions import RawSQL\n from django.db.models.functions import (\n@@ -52,31 +52,169 @@ class NonAggregateAnnotationTestCase(TestCase):\n             pages=447, rating=4.5, price=Decimal('30.00'), contact=cls.a1, publisher=cls.p1,\n             pubdate=datetime.date(2007, 12, 6)\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         cls.b2 = Book.objects.create(\n             isbn='067232959', name='Sams Teach Yourself Django in 24 Hours',\n             pages=528, rating=3.0, price=Decimal('23.09'), contact=cls.a3, publisher=cls.p2,\n             pubdate=datetime.date(2008, 3, 3)\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         cls.b3 = Book.objects.create(\n             isbn='159059996', name='Practical Django Projects',\n             pages=300, rating=4.0, price=Decimal('29.69'), contact=cls.a4, publisher=cls.p1,\n             pubdate=datetime.date(2008, 6, 23)\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         cls.b4 = Book.objects.create(\n             isbn='013235613', name='Python Web Development with Django',\n             pages=350, rating=4.0, price=Decimal('29.69'), contact=cls.a5, publisher=cls.p3,\n             pubdate=datetime.date(2008, 11, 3)\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         cls.b5 = Book.objects.create(\n             isbn='013790395', name='Artificial Intelligence: A Modern Approach',\n             pages=1132, rating=4.0, price=Decimal('82.80'), contact=cls.a8, publisher=cls.p3,\n             pubdate=datetime.date(1995, 1, 15)\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         cls.b6 = Book.objects.create(\n             isbn='155860191', name='Paradigms of Artificial Intelligence Programming: Case Studies in Common Lisp',\n             pages=946, rating=5.0, price=Decimal('75.00'), contact=cls.a8, publisher=cls.p4,\n             pubdate=datetime.date(1991, 10, 15)\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         cls.b1.authors.add(cls.a1, cls.a2)\n         cls.b2.authors.add(cls.a3)\n         cls.b3.authors.add(cls.a4)\n@@ -89,16 +227,85 @@ class NonAggregateAnnotationTestCase(TestCase):\n             original_opening=datetime.datetime(1994, 4, 23, 9, 17, 42),\n             friday_night_closing=datetime.time(23, 59, 59)\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         cls.s2 = Store.objects.create(\n             name='Books.com',\n             original_opening=datetime.datetime(2001, 3, 15, 11, 23, 37),\n             friday_night_closing=datetime.time(23, 59, 59)\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         cls.s3 = Store.objects.create(\n             name=\"Mamma and Pappa's Books\",\n             original_opening=datetime.datetime(1945, 4, 25, 16, 24, 14),\n             friday_night_closing=datetime.time(21, 30)\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         cls.s1.books.add(cls.b1, cls.b2, cls.b3, cls.b4, cls.b5, cls.b6)\n         cls.s2.books.add(cls.b1, cls.b3, cls.b5, cls.b6)\n         cls.s3.books.add(cls.b3, cls.b4, cls.b6)\n@@ -146,6 +353,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n         employees = Employee.objects.annotate(\n             store_opened_year=F('store__original_opening__year'),\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         for employee in employees:\n             self.assertEqual(\n                 employee.store_opened_year,\n@@ -201,12 +431,58 @@ class NonAggregateAnnotationTestCase(TestCase):\n         books = Book.objects.annotate(\n             selected=ExpressionWrapper(Q(pk__in=[]), output_field=BooleanField())\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         self.assertEqual(len(books), Book.objects.count())\n         self.assertTrue(all(not book.selected for book in books))\n \n         books = Book.objects.annotate(\n             selected=ExpressionWrapper(Q(pk__in=Book.objects.none()), output_field=BooleanField())\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         self.assertEqual(len(books), Book.objects.count())\n         self.assertTrue(all(not book.selected for book in books))\n \n@@ -214,6 +490,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n         qs = Author.objects.annotate(\n             empty=Subquery(Author.objects.values('id').none())\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         self.assertIsNone(qs.first().empty)\n \n     def test_annotate_with_aggregation(self):\n@@ -274,6 +573,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             original_opening=datetime.datetime.now(),\n             friday_night_closing=datetime.time(21, 00, 00),\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         names = [\n             'Theodore Roosevelt',\n             'Eleanor Roosevelt',\n@@ -347,11 +669,57 @@ class NonAggregateAnnotationTestCase(TestCase):\n             age=23,\n             salary=salary,\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         self.assertEqual(\n             Employee.objects.annotate(new_salary=F('salary') / 10).get().new_salary,\n             salary / 10,\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_filter_decimal_annotation(self):\n         qs = Book.objects.annotate(new_price=F('price') + 1).filter(new_price=Decimal(31)).values_list('new_price')\n         self.assertEqual(qs.get(), (Decimal(31),))\n@@ -391,6 +759,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             lambda b: b.store_name\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_values_annotation(self):\n         \"\"\"\n         Annotations can reference fields in a values clause,\n@@ -454,6 +845,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             chain='Westfield'\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n         books = Book.objects.filter(rating__gt=4)\n         for b in books:\n             d.books.add(b)\n@@ -473,6 +887,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             lambda d: (d.other_name, d.other_chain, d.is_open, d.book_isbn)\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_null_annotation(self):\n         \"\"\"\n         Annotating None onto a model round-trips\n@@ -489,6 +926,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             lambda a: a.other_age\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_order_by_aggregate(self):\n         authors = Author.objects.values('age').annotate(age_count=Count('age')).order_by('age_count', 'age')\n         self.assertQuerysetEqual(\n@@ -498,6 +958,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             lambda a: (a['age'], a['age_count'])\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_raw_sql_with_inherited_field(self):\n         DepartmentStore.objects.create(\n             name='Angus & Robinson',\n@@ -506,11 +989,57 @@ class NonAggregateAnnotationTestCase(TestCase):\n             chain='Westfield',\n             area=123,\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         tests = (\n             ('name', 'Angus & Robinson'),\n             ('surface', 123),\n             (\"case when name='Angus & Robinson' then chain else name end\", 'Westfield'),\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         for sql, expected_result in tests:\n             with self.subTest(sql=sql):\n                 self.assertSequenceEqual(\n@@ -546,6 +1075,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             annotated_value=Value(17),\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n         rows = [\n             (1, 'Max', True, 42, 'Paine', 23, Decimal(50000.00), store.name, 17),\n             (2, 'Buffy', False, 42, 'Summers', 18, Decimal(40000.00), store.name, 17)\n@@ -570,6 +1122,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             annotated_value=Value(17),\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n         rows = [\n             (1, 'Max', True, 42, 'Paine', 23, Decimal(50000.00), store.name, 17),\n             (2, 'Buffy', False, 42, 'Summers', 18, Decimal(40000.00), store.name, 17)\n@@ -608,6 +1183,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             lambda c: (c.name, c.tagline)\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_custom_functions_can_ref_other_functions(self):\n         Company(name='Apple', motto=None, ticker_name='APPL', description='Beautiful Devices').save()\n         Company(name='Django Software Foundation', motto=None, ticker_name=None, description=None).save()\n@@ -642,12 +1240,58 @@ class NonAggregateAnnotationTestCase(TestCase):\n             lambda c: (c.name, c.tagline_lower)\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_boolean_value_annotation(self):\n         books = Book.objects.annotate(\n             is_book=Value(True, output_field=BooleanField()),\n             is_pony=Value(False, output_field=BooleanField()),\n             is_none=Value(None, output_field=BooleanField(null=True)),\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         self.assertGreater(len(books), 0)\n         for book in books:\n             self.assertIs(book.is_book, True)\n@@ -662,6 +1306,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             .annotate(multiplied_value_sum=Sum(F('multiplier') * F('num_awards')))\n             .order_by()\n         )\n+\n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n         self.assertCountEqual(\n             qs, [\n                 {'multiplied_value_sum': 9, 'name': 'Apress'},\n@@ -672,6 +1339,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             ]\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_arguments_must_be_expressions(self):\n         msg = 'QuerySet.annotate() received non-expression(s): %s.'\n         with self.assertRaisesMessage(TypeError, msg % BooleanField()):\n@@ -697,6 +1387,29 @@ class NonAggregateAnnotationTestCase(TestCase):\n             [{'jacob_name': 'Jacob Kaplan-Moss', 'james_name': 'James Bennett'}],\n         )\n \n+    def test_expressionwrapper_with_empty_q_object(self):\n+        # Test ExpressionWrapper with ~Q(pk__in=[]) should not crash\n+        books = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        )\n+        self.assertEqual(len(books), Book.objects.count())\n+        self.assertTrue(all(book.selected for book in books))\n+\n+    def test_expressionwrapper_negation_with_aggregation(self):\n+        # Test ExpressionWrapper with aggregation using ~Q(pk__in=[])\n+        books = Book.objects.filter(isbn='067232959').annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField()),\n+            rating_count=Count('rating'),\n+        )\n+        self.assertEqual([book.rating_count for book in books], [1])\n+\n+    def test_aggregate_negation_expressionwrapper(self):\n+        # Test aggregate with ExpressionWrapper using ~Q(pk__in=[])\n+        qs = Book.objects.annotate(\n+            selected=ExpressionWrapper(~Q(pk__in=[]), output_field=BooleanField())\n+        ).aggregate(Sum('selected'))\n+        self.assertEqual(qs['selected__sum'], Book.objects.count())\n+\n     def test_annotation_filter_with_subquery(self):\n         long_books_qs = Book.objects.filter(\n             publisher=OuterRef('pk'),\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..53b7df6 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,4 @@\n+\n import json\n import random\n \n@@ -8,6 +9,7 @@ from django.contrib.messages.storage.cookie import (\n     CookieStorage, MessageDecoder, MessageEncoder,\n )\n from django.test import SimpleTestCase, override_settings\n+from django.utils.safestring import mark_safe, SafeData\n from django.utils.crypto import get_random_string\n from django.utils.safestring import SafeData, mark_safe\n \n@@ -61,7 +63,24 @@ class CookieTests(BaseTests, SimpleTestCase):\n         self.assertEqual(list(storage), example_messages)\n \n     @override_settings(SESSION_COOKIE_SAMESITE='Strict')\n-    def test_cookie_setings(self):\n+    def test_extra_tags_preservation(self):\n+        \"\"\"\n+        Test that a message's extra_tags attribute is preserved correctly when\n+        retrieved from the message storage after serialization and deserialization.\n+        \"\"\"\n+        storage = self.get_storage()\n+        test_cases = [\n+            {\"extra_tags\": \"\", \"description\": \"Empty string extra_tags\"},\n+            {\"extra_tags\": None, \"description\": \"None extra_tags\"},\n+            {\"extra_tags\": \"tag1\", \"description\": \"Single tag extra_tags\"},\n+            {\"extra_tags\": \"tag1 tag2\", \"description\": \"Multiple tags extra_tags\"},\n+        ]\n+        for case in test_cases:\n+            with self.subTest(description=case[\"description\"]):\n+                message = Message(constants.INFO, \"Test message\", extra_tags=case[\"extra_tags\"])\n+                encoded = storage._encode(message)\n+                decoded_message = storage._decode(encoded)\n+                self.assertEqual(decoded_message.extra_tags, case[\"extra_tags\"])\n         \"\"\"\n         CookieStorage honors SESSION_COOKIE_DOMAIN, SESSION_COOKIE_SECURE, and\n         SESSION_COOKIE_HTTPONLY (#15618, #20972).\n",
  "django__django-15388": "diff --git a/tests/template_tests/test_autoreloader.py b/tests/template_tests/test_autoreloader.py\nindex 42ab5ba..3dd0cf2 100644\n--- a/tests/template_tests/test_autoreloader.py\n+++ b/tests/template_tests/test_autoreloader.py\n@@ -2,6 +2,13 @@ from pathlib import Path\n from unittest import mock\n \n from django.template import autoreload\n+from django.conf import settings\n+from django.core.management import call_command\n+import threading\n+import time\n+import os\n+import tempfile\n+import shutil\n from django.test import SimpleTestCase, override_settings\n from django.test.utils import require_jinja2\n \n@@ -39,7 +46,40 @@ class TemplateReloadTests(SimpleTestCase):\n         self.assertIsNone(autoreload.template_changed(None, Path(__file__)))\n         mock_reset.assert_not_called()\n \n-    def test_watch_for_template_changes(self):\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    def test_dev_server_restart_when_base_dir_in_template_dirs(self, mock_reset):\n+        # Setting up the test environment\n+        temp_dir = tempfile.mkdtemp()\n+        try:\n+            # Change BASE_DIR in settings for this test to the temp_dir\n+            with override_settings(BASE_DIR=temp_dir, TEMPLATES=[{\n+                'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+                'DIRS': [temp_dir],\n+                'APP_DIRS': True\n+            }]):\n+                # Start the dev server in a separate thread\n+                server_thread = threading.Thread(\n+                    target=call_command, args=('runserver',),\n+                    kwargs={'use_reloader': True}\n+                )\n+                server_thread.start()\n+                time.sleep(3)  # Allow some time for the server to start\n+\n+                # Simulate a file change in the BASE_DIR\n+                test_file = os.path.join(temp_dir, 'test_change.txt')\n+                with open(test_file, 'w') as f:\n+                    f.write('test')\n+\n+                time.sleep(3)  # Allow some time to check if the server reacts\n+\n+                # Check if the autoreload.reset_loaders() was called indicating a restart\n+                mock_reset.assert_called_once()\n+\n+                # Clean up and stop the server\n+                os.remove(test_file)\n+                server_thread.join(0)  # Ensure the thread exits\n+        finally:\n+            shutil.rmtree(temp_dir)\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n         self.assertSequenceEqual(\n@@ -88,7 +128,40 @@ class TemplateReloadTests(SimpleTestCase):\n @require_jinja2\n @override_settings(INSTALLED_APPS=['template_tests'])\n class Jinja2TemplateReloadTests(SimpleTestCase):\n-    def test_watch_for_template_changes(self):\n+    @mock.patch('django.template.autoreload.reset_loaders')\n+    def test_dev_server_restart_when_base_dir_in_template_dirs(self, mock_reset):\n+        # Setting up the test environment\n+        temp_dir = tempfile.mkdtemp()\n+        try:\n+            # Change BASE_DIR in settings for this test to the temp_dir\n+            with override_settings(BASE_DIR=temp_dir, TEMPLATES=[{\n+                'BACKEND': 'django.template.backends.django.DjangoTemplates',\n+                'DIRS': [temp_dir],\n+                'APP_DIRS': True\n+            }]):\n+                # Start the dev server in a separate thread\n+                server_thread = threading.Thread(\n+                    target=call_command, args=('runserver',),\n+                    kwargs={'use_reloader': True}\n+                )\n+                server_thread.start()\n+                time.sleep(3)  # Allow some time for the server to start\n+\n+                # Simulate a file change in the BASE_DIR\n+                test_file = os.path.join(temp_dir, 'test_change.txt')\n+                with open(test_file, 'w') as f:\n+                    f.write('test')\n+\n+                time.sleep(3)  # Allow some time to check if the server reacts\n+\n+                # Check if the autoreload.reset_loaders() was called indicating a restart\n+                mock_reset.assert_called_once()\n+\n+                # Clean up and stop the server\n+                os.remove(test_file)\n+                server_thread.join(0)  # Ensure the thread exits\n+        finally:\n+            shutil.rmtree(temp_dir)\n         mock_reloader = mock.MagicMock()\n         autoreload.watch_for_template_changes(mock_reloader)\n         self.assertSequenceEqual(\n",
  "django__django-15400": "diff --git a/tests/utils_tests/test_lazyobject.py b/tests/utils_tests/test_lazyobject.py\nindex f0097c4..800b1c6 100644\n--- a/tests/utils_tests/test_lazyobject.py\n+++ b/tests/utils_tests/test_lazyobject.py\n@@ -332,6 +332,34 @@ class SimpleLazyObjectTestCase(LazyObjectTestCase):\n         finally:\n             sys.settrace(old_trace_func)\n \n+    def test_add(self):\n+        obj1 = self.lazy_wrap(1)\n+        self.assertEqual(obj1 + 1, 2)\n+        obj2 = self.lazy_wrap(2)\n+        self.assertEqual(obj2 + obj1, 3)\n+        self.assertEqual(obj1 + obj2, 3)\n+\n+    def test_radd(self):\n+        obj1 = self.lazy_wrap(1)\n+        self.assertEqual(1 + obj1, 2)\n+        \n+    def test_radd_with_different_types(self):\n+        obj1 = self.lazy_wrap(3)\n+        \n+        # Verify reverse addition with integer\n+        self.assertEqual(2 + obj1, 5)\n+        \n+        # Verify reverse addition with float\n+        self.assertEqual(2.5 + obj1, 5.5)\n+        \n+        # Verify reverse addition with string \n+        obj2 = self.lazy_wrap(\"World\")\n+        self.assertEqual(\"Hello \" + obj2, \"Hello World\")\n+        \n+        # Verify reverse addition with list\n+        obj3 = self.lazy_wrap([3, 4])\n+        self.assertEqual([1, 2] + obj3, [1, 2, 3, 4])\n+\n     def test_none(self):\n         i = [0]\n \n",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..ade2a00 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -184,6 +185,18 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"\n+        Ensure that an empty string for the If-Modified-Since header is handled correctly.\n+        \"\"\"\n+        # Test with an empty string; expected behavior will depend on the implementation.\n+        # Assuming the correct behavior should return True or False without an exception.\n+        try:\n+            result = was_modified_since(header=\"\", mtime=1)\n+            self.assertIsNotNone(result, \"Function should return a boolean, not None.\")\n+        except Exception as e:\n+            self.fail(f\"was_modified_since raised an unexpected exception for empty string: {e}\")\n+\n     def test_was_modified_since_fp(self):\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..5a01ffc 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,3 +1,4 @@\n+\n import os\n from io import StringIO\n from unittest import mock\n@@ -8,6 +9,8 @@ from django.apps import apps\n from django.core import management\n from django.core.checks import Tags\n from django.core.management import BaseCommand, CommandError, find_commands\n+from argparse import ArgumentDefaultsHelpFormatter\n+from io import StringIO\n from django.core.management.utils import (\n     find_command,\n     get_random_secret_key,\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..f1d0897 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,8 +1,10 @@\n+\n import os\n from datetime import datetime\n \n from django.test import SimpleTestCase\n from django.utils.functional import lazystr\n+from django.core.serializers.json import DjangoJSONEncoder\n from django.utils.html import (\n     conditional_escape,\n     escape,\n@@ -217,7 +219,35 @@ class TestUtilsHtml(SimpleTestCase):\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n         )\n \n-    def test_smart_urlquote(self):\n+    def test_json_script_custom_encoder_on_existing_functionality(self):\n+        class UpperCaseJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"KEY\": \"VALUE\"}'\n+\n+        # Testing with a custom encoder that uppercases key-value pairs.\n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}, encoder=UpperCaseJSONEncoder),\n+            '<script type=\"application/json\">{\"KEY\": \"VALUE\"}</script>',\n+        )\n+\n+    def test_json_script_default_encoder_compatibility(self):\n+        # Verifying json_script still functions with the default encoder.\n+        result = json_script({\"key\": \"value\"})\n+        self.assertHTMLEqual(\n+            result,\n+            '<script type=\"application/json\">{\"key\": \"value\"}</script>'\n+        )\n+\n+    def test_json_script_with_custom_id_and_encoder(self):\n+        class StaticJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"static\": \"content\"}'\n+\n+        # Testing with a custom JSON encoder and an HTML element ID.\n+        self.assertHTMLEqual(\n+            json_script({\"irrelevant\": \"data\"}, element_id=\"test_id\", encoder=StaticJSONEncoder),\n+            '<script id=\"test_id\" type=\"application/json\">{\"static\": \"content\"}</script>'\n+        )\n         items = (\n             (\"http://\u00f6\u00e4\u00fc.com/\", \"http://xn--4ca9at.com/\"),\n             (\"http://\u00f6\u00e4\u00fc.com/\u00f6\u00e4\u00fc/\", \"http://xn--4ca9at.com/%C3%B6%C3%A4%C3%BC/\"),\n",
  "django__django-15790": "diff --git a/tests/check_framework/test_templates.py b/tests/check_framework/test_templates.py\nindex 72e6cfe..62ae1fa 100644\n--- a/tests/check_framework/test_templates.py\n+++ b/tests/check_framework/test_templates.py\n@@ -103,9 +103,68 @@ class CheckTemplateStringIfInvalidTest(SimpleTestCase):\n         with self.settings(TEMPLATES=TEMPLATES):\n             self.assertEqual(check_string_if_invalid_is_string(None), [self.error1])\n \n+from django.test import override_settings, SimpleTestCase\n+from django.core.checks import Error\n+from django.conf import settings\n+from django.utils.module_loading import import_string\n+from collections import defaultdict\n \n class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n-    @classmethod\n+    @override_settings(\n+        INSTALLED_APPS=[\"check_framework.template_test_apps.same_tags_app_1\"]\n+    )\n+    def test_no_issues_with_unique_library_names(self):\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"unique_tags_1\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                []\n+            )\n+\n+    @override_settings(\n+        INSTALLED_APPS=[\n+            \"check_framework.template_test_apps.same_tags_app_1\",\n+            \"check_framework.template_test_apps.same_tags_app_2\",\n+            \"check_framework.template_test_apps.different_tags_app\",\n+        ]\n+    )\n+    def test_multiple_duplicates(self):\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"same_tags\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+                self.get_settings(\n+                    \"same_tags\", \"same_tags_app_2.templatetags.same_tags\"\n+                ),\n+                self.get_settings(\n+                    \"same_tags\", \"different_tags_app.templatetags.same_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [\n+                    self.error_same_tags,\n+                    Error(\n+                        E003.msg.format(\n+                            \"'same_tags'\",\n+                            \"'check_framework.template_test_apps.different_tags_app.\"\n+                            \"templatetags.same_tags', \"\n+                            \"'check_framework.template_test_apps.same_tags_app_1.\"\n+                            \"templatetags.same_tags', \"\n+                            \"'check_framework.template_test_apps.same_tags_app_2.\"\n+                            \"templatetags.same_tags'\",\n+                        ),\n+                        id=E003.id,\n+                    ),\n+                ]\n+            )\n     def setUpClass(cls):\n         super().setUpClass()\n         cls.error_same_tags = Error(\n@@ -206,4 +265,4 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n         ]\n     )\n     def test_template_tags_with_different_name(self):\n-        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..045e773 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -394,6 +394,18 @@ class ProxyModelTests(TestCase):\n         management.call_command(\"loaddata\", \"mypeople.json\", verbosity=0)\n         p = MyPerson.objects.get(pk=100)\n         self.assertEqual(p.name, \"Elvis Presley\")\n+    def test_select_related_only_proxy_model(self):\n+        # Create instances for proxy and related models\n+        custom_obj = CustomModel.objects.create(name=\"Proxy Name\")\n+        proxy_obj = ProxyCustomModel.objects.get(pk=custom_obj.pk)\n+        another_obj = AnotherModel.objects.create(custom=proxy_obj)\n+        \n+        # Query using select_related and only on proxy model\n+        qs = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\")\n+        result = qs.get(pk=another_obj.pk)\n+        \n+        # Assert the correct related proxy object's name is fetched\n+        self.assertEqual(result.custom.name, \"Proxy Name\")\n \n     def test_eq(self):\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..d029083 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -151,6 +151,13 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             ),\n         )\n \n+    def test_parameter_order(self):\n+        # Test to verify that additional parameters are correctly placed before the dbname\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"select * from some_table;\"]),\n+            ([\"psql\", \"-c\", \"select * from some_table;\", \"dbname\"], None),\n+        )\n+\n     def test_parameters(self):\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n@@ -183,4 +190,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 44ea946..a2b2f26 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1901,12 +1901,47 @@ class AllValidTests(SimpleTestCase):\n class DeprecationTests(SimpleTestCase):\n     def test_warning(self):\n         from django.forms.utils import DEFAULT_TEMPLATE_DEPRECATION_MSG\n-\n-        with isolate_lru_cache(get_default_renderer), self.settings(\n-            FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n-        ), self.assertRaisesMessage(\n-            RemovedInDjango50Warning, DEFAULT_TEMPLATE_DEPRECATION_MSG\n-        ):\n-            ChoiceFormSet = formset_factory(Choice)\n-            formset = ChoiceFormSet()\n-            str(formset)\n+        from django.test import TestCase\n+        from django.forms import formset_factory, BaseFormSet\n+        from yourapp.forms import Choice  # Assuming Choice is defined here\n+        from yourapp.tests.utils import isolate_lru_cache, get_default_renderer  # Assuming helper functions are defined here\n+        \n+        class ManagementFormWarningTests(TestCase):\n+            def test_no_management_form_warning(self):\n+                \"\"\"\n+                Management forms should not trigger the 'default.html' deprecation warning\n+                because they use a fixed template that does not affect rendering output.\n+                \"\"\"\n+                with isolate_lru_cache(get_default_renderer), self.settings(\n+                    FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n+                ):\n+                    ChoiceFormSet = formset_factory(Choice, formset=BaseFormSet)\n+                    formset = ChoiceFormSet()\n+                    # Rendering the management form should NOT raise a deprecation warning\n+                    str(formset.management_form)\n+\n+            def test_management_form_with_different_renderer(self):\n+                \"\"\"\n+                Ensure that changing the form renderer does not inadvertently cause warnings\n+                when rendering the management form.\n+                \"\"\"\n+                with isolate_lru_cache(get_default_renderer), self.settings(\n+                    FORM_RENDERER=\"django.forms.renderers.Jinja2\"\n+                ):\n+                    ChoiceFormSet = formset_factory(Choice, formset=BaseFormSet)\n+                    formset = ChoiceFormSet()\n+                    # Rendering the management form should still NOT raise any warning\n+                    str(formset.management_form)\n+\n+            def test_formset_without_warning(self):\n+                \"\"\"\n+                Rendering a formset that does not explicitly render individual forms should \n+                also respect the removal of the warning.\n+                \"\"\"\n+                with isolate_lru_cache(get_default_renderer), self.settings(\n+                    FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n+                ):\n+                    ChoiceFormSet = formset_factory(Choice, formset=BaseFormSet)\n+                    formset = ChoiceFormSet()\n+                    # Attempt to render the entire formset; ensure no warning is raised\n+                    str(formset)  # Entire formset rendering\n",
  "django__django-16041": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex a34f3d3..025375a 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -178,10 +178,12 @@ class FormsFormsetTestCase(SimpleTestCase):\n         formset = FormSet(form_kwargs={\"custom_kwarg\": 1})\n         self.assertTrue(hasattr(formset.empty_form, \"custom_kwarg\"))\n         self.assertEqual(formset.empty_form.custom_kwarg, 1)\n-\n-    def test_formset_validation(self):\n-        # FormSet instances can also have an error attribute if validation failed for\n-        # any of the forms.\n+    def test_empty_permitted_ignored_empty_form(self):\n+        # Ensure that setting 'empty_permitted' in form_kwargs does not affect empty_form\n+        ArticleFormSet = modelformset_factory(MyModel, fields=['a_field'])\n+        formset = ArticleFormSet(form_kwargs={\"empty_permitted\": False})\n+        # The empty_form's empty_permitted should still be True, as it's irrelevant in this context.\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n         formset = self.make_choiceformset([(\"Calexico\", \"\")])\n         self.assertFalse(formset.is_valid())\n         self.assertEqual(formset.errors, [{\"votes\": [\"This field is required.\"]}])\n",
  "django__django-16046": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 41aae41..f8597d3 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -1,3 +1,4 @@\n+\n from decimal import Decimal\n from sys import float_info\n \n@@ -160,7 +161,9 @@ class TestNumberFormat(SimpleTestCase):\n                     nformat(Decimal(value), \".\", decimal_pos), expected_value\n                 )\n \n-    def test_decimal_subclass(self):\n+    def test_empty(self):\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        self.assertEqual(nformat(None, \".\"), \"None\")\n         class EuroDecimal(Decimal):\n             \"\"\"\n             Wrapper for Decimal which prefixes each amount with the \u20ac symbol.\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..18928ef 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -24,6 +25,8 @@ from django.forms.fields import CharField, Field, IntegerField\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.utils import translation\n from django.utils.text import capfirst\n+import urllib.parse\n+from django.urls import reverse\n from django.utils.translation import gettext as _\n \n from .models.custom_user import (\n@@ -892,6 +895,26 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # value to render correctly\n         self.assertEqual(form.initial[\"password\"], form[\"password\"].value())\n \n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search(r'<a href=\"(.*?)\">', password_help_text)\n+        \n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.username,),\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+        \n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n     def test_custom_form(self):\n         class CustomUserChangeForm(UserChangeForm):\n             class Meta(UserChangeForm.Meta):\n",
  "django__django-16255": "",
  "django__django-16379": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 014d28a..0065c7e 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1,3 +1,4 @@\n+\n # Unit tests for cache framework\n # Uses whatever cache backend is set in the test settings file.\n import copy\n@@ -7,6 +8,9 @@ import pickle\n import re\n import shutil\n import sys\n+from unittest import mock\n+from django.core.cache import caches\n+from django.test import TestCase\n import tempfile\n import threading\n import time\n@@ -1755,7 +1759,35 @@ class FileBasedCacheTests(BaseCacheTests, TestCase):\n             with self.assertRaises(OSError):\n                 cache.get(\"foo\")\n \n-    def test_empty_cache_file_considered_expired(self):\n+    def test_has_key_race_handling(self):\n+        cache = caches['default']\n+        self.assertIs(cache.add(\"key\", \"value\"), True)\n+        # Mock 'open' to simulate a FileNotFoundError being raised due to a race condition.\n+        with mock.patch(\"builtins.open\", side_effect=FileNotFoundError) as mocked_open:\n+            self.assertIs(cache.has_key(\"key\"), False)\n+            mocked_open.assert_called_once()\n+\n+    def test_has_key_race_condition_multiple_threads(self):\n+        cache = caches['default']\n+        key = \"race_test_key\"\n+        self.assertIs(cache.add(key, \"value\"), True)\n+        \n+        # Mock os.path.exists to quickly simulate race conditions\n+        def mock_exists(path):\n+            # Simulate the race condition where the file existed then was deleted\n+            return True\n+        \n+        with mock.patch('os.path.exists', side_effect=mock_exists):\n+            with mock.patch(\"builtins.open\", side_effect=FileNotFoundError) as mocked_open:\n+                self.assertIs(cache.has_key(key), False)\n+                mocked_open.assert_called_once()\n+\n+    def test_has_key_no_existent_file(self):\n+        cache = caches['default']\n+        key = \"non_existent_key\"\n+\n+        # Assure the key is not in cache\n+        self.assertIs(cache.has_key(key), False)\n         cache_file = cache._key_to_file(\"foo\")\n         with open(cache_file, \"wb\") as fh:\n             fh.write(b\"\")\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..6790e71 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -8,7 +9,9 @@ from django.contrib.auth.models import User\n from django.test import RequestFactory, TestCase\n from django.urls import reverse\n \n+from django.contrib.auth import get_permission_codename\n from .admin import ArticleAdmin, site\n+from .tests import get_perm\n from .models import Article, Question\n from .tests import AdminViewBasicTestCase\n \n",
  "django__django-16595": "",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..63e5d43 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,6 +1,8 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n+from django.template.defaultfilters import escape\n \n from ..utils import setup\n \n@@ -78,4 +80,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..4dbbb00 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -596,18 +596,99 @@ class BulkCreateTests(TestCase):\n                 {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n             ],\n         )\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\"\n+    )\n+    def test_bulk_create_update_conflicts_returns_ids(self):\n+        # Initial bulk_create to set up the data in the database.\n+        MyModel.objects.bulk_create([\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\")\n+        ])\n+        \n+        conflicting_objects = [\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\"),\n+            MyModel(name=\"new_entry\")\n+        ]\n+\n+        results = MyModel.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"name\"],\n+            update_fields=[]\n+        )\n+\n+        # Check if IDs are set in the returned queryset objects\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        for obj in results:\n+            self.assertIsNotNone(obj.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_two_fields_unique_fields_first(self):\n         self._test_update_conflicts_two_fields([\"f1\"])\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\"\n+    )\n+    def test_bulk_create_update_conflicts_returns_ids(self):\n+        # Initial bulk_create to set up the data in the database.\n+        MyModel.objects.bulk_create([\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\")\n+        ])\n+        \n+        conflicting_objects = [\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\"),\n+            MyModel(name=\"new_entry\")\n+        ]\n+\n+        results = MyModel.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"name\"],\n+            update_fields=[]\n+        )\n+\n+        # Check if IDs are set in the returned queryset objects\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        for obj in results:\n+            self.assertIsNotNone(obj.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_two_fields_unique_fields_second(self):\n         self._test_update_conflicts_two_fields([\"f2\"])\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\"\n+    )\n+    def test_bulk_create_update_conflicts_returns_ids(self):\n+        # Initial bulk_create to set up the data in the database.\n+        MyModel.objects.bulk_create([\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\")\n+        ])\n+        \n+        conflicting_objects = [\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\"),\n+            MyModel(name=\"new_entry\")\n+        ]\n+\n+        results = MyModel.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"name\"],\n+            update_fields=[]\n+        )\n+\n+        # Check if IDs are set in the returned queryset objects\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        for obj in results:\n+            self.assertIsNotNone(obj.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -641,6 +722,33 @@ class BulkCreateTests(TestCase):\n                 {\"f1\": 2, \"f2\": 2, \"name\": \"d\"},\n             ],\n         )\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\"\n+    )\n+    def test_bulk_create_update_conflicts_returns_ids(self):\n+        # Initial bulk_create to set up the data in the database.\n+        MyModel.objects.bulk_create([\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\")\n+        ])\n+        \n+        conflicting_objects = [\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\"),\n+            MyModel(name=\"new_entry\")\n+        ]\n+\n+        results = MyModel.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"name\"],\n+            update_fields=[]\n+        )\n+\n+        # Check if IDs are set in the returned queryset objects\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        for obj in results:\n+            self.assertIsNotNone(obj.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -709,12 +817,66 @@ class BulkCreateTests(TestCase):\n                 },\n             ],\n         )\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\"\n+    )\n+    def test_bulk_create_update_conflicts_returns_ids(self):\n+        # Initial bulk_create to set up the data in the database.\n+        MyModel.objects.bulk_create([\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\")\n+        ])\n+        \n+        conflicting_objects = [\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\"),\n+            MyModel(name=\"new_entry\")\n+        ]\n+\n+        results = MyModel.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"name\"],\n+            update_fields=[]\n+        )\n+\n+        # Check if IDs are set in the returned queryset objects\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        for obj in results:\n+            self.assertIsNotNone(obj.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n     )\n     def test_update_conflicts_unique_two_fields_unique_fields_both(self):\n         self._test_update_conflicts_unique_two_fields([\"iso_two_letter\", \"name\"])\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\"\n+    )\n+    def test_bulk_create_update_conflicts_returns_ids(self):\n+        # Initial bulk_create to set up the data in the database.\n+        MyModel.objects.bulk_create([\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\")\n+        ])\n+        \n+        conflicting_objects = [\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\"),\n+            MyModel(name=\"new_entry\")\n+        ]\n+\n+        results = MyModel.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"name\"],\n+            update_fields=[]\n+        )\n+\n+        # Check if IDs are set in the returned queryset objects\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        for obj in results:\n+            self.assertIsNotNone(obj.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -775,6 +937,33 @@ class BulkCreateTests(TestCase):\n                 {\"number\": 4, \"rank\": 4, \"name\": \"Mark\"},\n             ],\n         )\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\"\n+    )\n+    def test_bulk_create_update_conflicts_returns_ids(self):\n+        # Initial bulk_create to set up the data in the database.\n+        MyModel.objects.bulk_create([\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\")\n+        ])\n+        \n+        conflicting_objects = [\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\"),\n+            MyModel(name=\"new_entry\")\n+        ]\n+\n+        results = MyModel.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"name\"],\n+            update_fields=[]\n+        )\n+\n+        # Check if IDs are set in the returned queryset objects\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        for obj in results:\n+            self.assertIsNotNone(obj.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -786,6 +975,33 @@ class BulkCreateTests(TestCase):\n     @skipIfDBFeature(\"supports_update_conflicts_with_target\")\n     def test_update_conflicts_no_unique_fields(self):\n         self._test_update_conflicts([])\n+    @skipUnlessDBFeature(\n+        \"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\"\n+    )\n+    def test_bulk_create_update_conflicts_returns_ids(self):\n+        # Initial bulk_create to set up the data in the database.\n+        MyModel.objects.bulk_create([\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\")\n+        ])\n+        \n+        conflicting_objects = [\n+            MyModel(name=\"existing1\"),\n+            MyModel(name=\"existing2\"),\n+            MyModel(name=\"new_entry\")\n+        ]\n+\n+        results = MyModel.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"name\"],\n+            update_fields=[]\n+        )\n+\n+        # Check if IDs are set in the returned queryset objects\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        for obj in results:\n+            self.assertIsNotNone(obj.pk)\n \n     @skipUnlessDBFeature(\n         \"supports_update_conflicts\", \"supports_update_conflicts_with_target\"\n@@ -816,4 +1032,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "",
  "matplotlib__matplotlib-22711": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex 39c625e..a0e664a 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1120,6 +1120,27 @@ def test_range_slider(orientation):\n     assert_allclose(slider.val, [0.1, 0.34])\n \n \n+def test_range_slider_initial_val():\n+    fig, ax = plt.subplots()\n+\n+    # Attempt to initialize the RangeSlider with explicitly set initial values\n+    slider = widgets.RangeSlider(ax=ax, label=\"Initial Test\", valmin=0.0, valmax=1.0, valinit=[0.3, 0.7])\n+\n+    # Check if the initial values are set correctly and no error occurs\n+    assert_allclose(slider.val, (0.3, 0.7))\n+    \n+    # Verify poly elements for the given initial value\n+    idx = [0, 1, 2, 3]  # assuming horizontal orientation\n+    box = slider.poly.get_extents().transformed(ax.transAxes.inverted())\n+    assert_allclose(box.get_points().flatten()[idx], [0.3, 0.25, 0.7, 0.75])\n+\n+    slider.set_val((0.5, 0.8))\n+    assert_allclose(slider.val, (0.5, 0.8))\n+\n+    slider.reset()\n+    assert_allclose(slider.val, [0.3, 0.7])\n+\n+\n def check_polygon_selector(event_sequence, expected_result, selections_count,\n                            **kwargs):\n     \"\"\"\n",
  "matplotlib__matplotlib-23299": "",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..b951724 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -20,8 +20,27 @@ import numpy as np\n mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n+@check_figures_equal(extensions=[\"png\"])\n+def test_3d_set_visible(fig_test, fig_ref):\n+    ax_test = fig_test.add_subplot(projection='3d')\n+    ax_test.scatter([1], [1], [1])\n+    ax_test.set_visible(False)\n+\n+    ax_ref = fig_ref.add_subplot(projection='3d')\n+    ax_ref.scatter([1], [1], [1])\n+    ax_ref.set_visible(True)\n+\n \n-def test_aspect_equal_error():\n+@check_figures_equal(extensions=[\"png\"])\n+def test_multiple_subplots_3d_set_visible(fig_test, fig_ref):\n+    ax1_test = fig_test.add_subplot(121, projection='3d')\n+    ax2_test = fig_test.add_subplot(122, projection='3d')\n+    ax1_test.set_visible(False)\n+\n+    ax1_ref = fig_ref.add_subplot(121, projection='3d')\n+    ax2_ref = fig_ref.add_subplot(122, projection='3d')\n+    ax1_ref.set_visible(True)\n+    ax2_ref.set_visible(True)\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     with pytest.raises(NotImplementedError):\n",
  "matplotlib__matplotlib-23562": "",
  "matplotlib__matplotlib-23563": "",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..cb12f55 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -774,6 +774,17 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n         assert mpl.colors.same_color(text.get_color(), color)\n \n \n+@pytest.mark.parametrize('draggable', (True, False))\n+def test_legend_draggable(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='example')\n+    leg = ax.legend(draggable=draggable)\n+    assert leg.get_draggable() is draggable\n+\n+\n+import matplotlib.pyplot as plt\n+import pytest\n+\n def test_get_set_draggable():\n     legend = plt.legend()\n     assert not legend.get_draggable()\n",
  "matplotlib__matplotlib-23964": "diff --git a/lib/matplotlib/tests/test_backend_ps.py b/lib/matplotlib/tests/test_backend_ps.py\nindex a1caf1a..6f26f7d 100644\n--- a/lib/matplotlib/tests/test_backend_ps.py\n+++ b/lib/matplotlib/tests/test_backend_ps.py\n@@ -246,7 +246,41 @@ def test_fonttype(fonttype):\n \n def test_linedash():\n     \"\"\"Test that dashed lines do not break PS output\"\"\"\n-    fig, ax = plt.subplots()\n+import io\n+from matplotlib.figure import Figure\n+from matplotlib import pyplot as plt\n+\n+def test_empty_line():\n+    # Smoke-test for gh#23954\n+    figure = Figure()\n+    figure.text(0.5, 0.5, \"\\nfoo\\n\\n\")\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    assert buf.getvalue() is not None  # Ensure that the buffer is not empty\n+    figure.savefig(buf, format='ps')\n+    assert buf.getvalue() is not None  # Ensure that the buffer is not empty\n+\n+def test_annotate_empty_line():\n+    # Test annotation with empty line\n+    figure = Figure()\n+    ax = figure.add_subplot(111)\n+    ax.annotate(text='\\nLower label', xy=(0, 0))\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    assert buf.getvalue() is not None  # Ensure that the buffer is not empty\n+    figure.savefig(buf, format='ps')\n+    assert buf.getvalue() is not None  # Ensure that the buffer is not empty\n+\n+def test_title_empty_line():\n+    # Test title with empty line\n+    figure = Figure()\n+    ax = figure.add_subplot(111)\n+    ax.set_title('\\nLower title')\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    assert buf.getvalue() is not None  # Ensure that the buffer is not empty\n+    figure.savefig(buf, format='ps')\n+    assert buf.getvalue() is not None  # Ensure that the buffer is not empty\n \n     ax.plot([0, 1], linestyle=\"--\")\n \n",
  "matplotlib__matplotlib-23987": "diff --git a/lib/matplotlib/tests/test_constrainedlayout.py b/lib/matplotlib/tests/test_constrainedlayout.py\nindex 41fdfa1..0f927e0 100644\n--- a/lib/matplotlib/tests/test_constrainedlayout.py\n+++ b/lib/matplotlib/tests/test_constrainedlayout.py\n@@ -649,10 +649,27 @@ def test_compressed1():\n \n     fig.colorbar(pc, ax=axs)\n     fig.draw_without_rendering()\n-\n+import pytest\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import warnings\n+\n+@pytest.mark.parametrize('constrained', [True, False])\n+def test_constrained_layout_warning_suppression(constrained):\n+    a = np.linspace(0, 2 * np.pi, 100)\n+    b = np.sin(a)\n+    c = np.cos(a)\n+    fig, ax = plt.subplots(1, 2, figsize=(8, 2), constrained_layout=constrained)\n+    ax[0].plot(a, b)\n+    ax[1].plot(a, c)\n+\n+    with warnings.catch_warnings(record=True) as w:\n+        plt.subplots_adjust(wspace=0)\n+        if not constrained:\n+            assert not any(\"UserWarning: This figure was using a layout engine\" in str(warning.message) for warning in w), \"Warning was incorrectly issued for constrained_layout=False\"\n     pos = axs[0, 0].get_position()\n     np.testing.assert_allclose(pos.x0, 0.06195, atol=1e-3)\n     np.testing.assert_allclose(pos.y1, 0.8537, atol=1e-3)\n     pos = axs[1, 2].get_position()\n     np.testing.assert_allclose(pos.x1, 0.8618, atol=1e-3)\n-    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n+    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "",
  "matplotlib__matplotlib-24970": "diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex 2be14fe..3011aca 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -30,7 +30,25 @@ def test_create_lookup_table(N, result):\n     assert_array_almost_equal(mcolors._create_lookup_table(N, data), result)\n \n \n-def test_resampled():\n+import matplotlib.pyplot as plt\n+import numpy as np\n+import pytest\n+import matplotlib.colors as mcolors\n+from numpy.testing import assert_array_equal, assert_array_almost_equal\n+\n+@pytest.mark.parametrize(\"dtype\", [np.uint8, int, np.float16, float])\n+def test_index_dtype_no_deprecation_warnings(dtype):\n+    \"\"\"\n+    Test that using various dtypes in colormap indexing does not produce \n+    deprecation warnings in newer versions of NumPy.\n+    \"\"\"\n+    cm = plt.get_cmap(\"viridis\")\n+    with pytest.warns(None) as record:\n+        cm(dtype(0))\n+        cm(dtype(1))\n+        cm(dtype(256))  # this is an out-of-bound value for uint8\n+    # Ensure that no warnings were captured.\n+    assert len(record) == 0\n     \"\"\"\n     GitHub issue #6025 pointed to incorrect ListedColormap.resampled;\n     here we test the method for LinearSegmentedColormap as well.\n",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..d9f5185 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,8 +1,9 @@\n+\n from io import BytesIO\n import ast\n import pickle\n-\n import numpy as np\n+import pickletools\n import pytest\n \n import matplotlib as mpl\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..b0ac95f 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -89,6 +89,35 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n+import matplotlib.pyplot as plt\n+import pickle\n+\n+def test_pickle_figure_with_aligned_labels():\n+    # Create a new figure\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    \n+    # Sample data\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    \n+    # Plot data\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+    \n+    # Align labels\n+    fig.align_labels()\n+    \n+    # Attempt to pickle the figure\n+    try:\n+        pickle.dumps(fig)\n+        print(\"Pickle successful\")\n+    except Exception as e:\n+        print(f\"Pickle failed: {e}\")\n \n @mpl.style.context(\"default\")\n @check_figures_equal(extensions=[\"png\"])\n",
  "matplotlib__matplotlib-25442": "",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\nindex 9aa3203..068de68 100644\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -1,4 +1,5 @@\n \n+\n import numpy as np\n import pandas as pd\n \n@@ -8,9 +9,26 @@ from numpy.testing import assert_array_equal, assert_array_almost_equal\n from seaborn._core.groupby import GroupBy\n from seaborn._stats.regression import PolyFit\n \n+from pandas.testing import assert_frame_equal\n \n class TestPolyFit:\n \n+    def test_missing_data_with_none(self, df):\n+        # Test case to handle None values in the data\n+        df_with_none = df.copy()\n+        df_with_none.loc[5:10, 'x'] = None  # Introduce None values in the dataset\n+        df_with_none.loc[5:10, 'y'] = None\n+\n+        groupby = GroupBy([\"group\"])\n+        \n+        try:\n+            # Expect no exception and successful handling of None values\n+            res1 = PolyFit()(df_with_none, groupby, \"x\", {})\n+            res2 = PolyFit()(df_with_none.dropna(), groupby, \"x\", {})\n+            assert_frame_equal(res1, res2)\n+        except Exception as e:\n+            pytest.fail(f\"PolyFit failed with None values in data: {e}\")\n+\n     @pytest.fixture\n     def df(self, rng):\n \n",
  "mwaskom__seaborn-3190": "",
  "mwaskom__seaborn-3407": "",
  "pallets__flask-4992": "diff --git a/tests/test_config.py b/tests/test_config.py\nindex 179b09c..f68dc27 100644\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -1,8 +1,9 @@\n+\n import json\n import os\n import textwrap\n-\n import pytest\n+import os\n \n import flask\n \n",
  "psf__requests-1963": "",
  "psf__requests-2317": "",
  "psf__requests-2674": "",
  "psf__requests-3362": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 52d1693..78596d7 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -973,6 +973,20 @@ class TestRequests:\n         chunks = r.iter_content(decode_unicode=True)\n         assert all(isinstance(chunk, str) for chunk in chunks)\n \n+        # test with encoding None, should return bytes\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'the content')\n+        r.encoding = None\n+        chunks = r.iter_content(decode_unicode=True)\n+        assert all(isinstance(chunk, bytes) for chunk in chunks), \"Chunks with encoding None should be bytes\"\n+\n+        # Test with decode_unicode=False, chunks should be bytes\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'the content')\n+        r.encoding = 'utf-8'\n+        chunks = r.iter_content(decode_unicode=False)\n+        assert all(isinstance(chunk, bytes) for chunk in chunks), \"Chunks with decode_unicode=False should be bytes\"\n+\n         # also for streaming\n         r = requests.Response()\n         r.raw = io.BytesIO(b'the content')\n",
  "psf__requests-863": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 0ee4333..71359f7 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -743,8 +743,43 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n             assert 'foo' in response.text\n             assert 'bar' in response.text\n+    \n+    def test_list_hooks_register_hook(self):\n+        \"\"\"Additional test for issue 785 to verify proper behavior with lists as hooks.\"\"\"\n \n-    def test_session_persistent_cookies(self):\n+        def modify_header_one(args):\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers']['X-Test-One'] = 'one'\n+            return args\n+\n+        def modify_header_two(args):\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers']['X-Test-Two'] = 'two'\n+            return args\n+\n+        def assert_all_hooks_callable(hooks):\n+            for func in hooks['args']:\n+                assert callable(func) is True\n+\n+        # Use a list of hooks to test the register_hook method directly\n+        hooks_list = [modify_header_one, modify_header_two]\n+        request_instance = requests.models.Request()\n+        request_instance.register_hook('args', hooks_list)\n+        assert_all_hooks_callable(request_instance.hooks)\n+\n+        # Also test the hooks passed during Request instantiation\n+        request_instance = requests.models.Request(hooks={'args': hooks_list})\n+        assert_all_hooks_callable(request_instance.hooks)\n+\n+        # Check if the hooks can modify request headers correctly\n+        headers = {}\n+        for hook in hooks_list:\n+            headers = hook({'headers': headers})['headers']\n+        \n+        assert headers['X-Test-One'] == 'one'\n+        assert headers['X-Test-Two'] == 'two'\n \n         s = requests.session()\n \n",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..d643487 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -410,8 +410,19 @@ def test_groupby_repr_datetime(obj):\n     expected += \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.\"\n     assert actual == expected\n \n+# Test to ensure there is no trailing whitespace in the groupby representation\n+@pytest.mark.parametrize(\"dim\", [\"x\", \"y\", \"z\", \"month\"])\n+@pytest.mark.parametrize(\"obj\", [repr_da, repr_da.to_dataset(name=\"a\")])\n+def test_groupby_repr_no_trailing_whitespace(obj, dim):\n+    actual = repr(obj.groupby(dim))\n+    lines = actual.split('\\n')\n+    assert all(not line.endswith(' ') for line in lines), \"Found trailing whitespace in groupby representation\"\n \n-def test_groupby_drops_nans():\n+@pytest.mark.parametrize(\"obj\", [repr_da, repr_da.to_dataset(name=\"a\")])\n+def test_groupby_repr_datetime_no_trailing_whitespace(obj):\n+    actual = repr(obj.groupby(\"t.month\"))\n+    lines = actual.split('\\n')\n+    assert all(not line.endswith(' ') for line in lines), \"Found trailing whitespace in groupby datetime representation\"\n     # GH2383\n     # nan in 2D data variable (requires stacking)\n     ds = xr.Dataset(\n",
  "pylint-dev__pylint-5859": "",
  "pylint-dev__pylint-6506": "",
  "pylint-dev__pylint-7080": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex fa7078d..2799a78 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1324,11 +1324,27 @@ class TestRunTC:\n                 if not os.path.basename(path) == \"regrtest_data\"\n             ]\n             with _test_cwd():\n-                os.chdir(join(HERE, \"regrtest_data\", \"directory\", \"subdirectory\"))\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n+                # Original test to check if '.' and 'ignored_subdirectory/' are correctly ignored\n                 self._runtest(\n-                    [\".\", \"--recursive=y\"],\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^ignored_subdirectory/.*\"],\n                     code=0,\n                 )\n+                # New test to ensure a deeper directory in ignored paths is not scanned\n+                self._runtest(\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^ignored_subdirectory/deeper_ignore/.*\"],\n+                    code=0,\n+                )\n+                # New test to ensure the command-line argument for ignoring path takes precedence over config file\n+                self._runtest(\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^commandline_ignore/.*\"],\n+                    code=0,\n+                )\n+                # New test to ensure that paths that should not be ignored are indeed checked\n+                self._runtest(\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^ignored_but_existing_path/.*\"],\n+                    code=1, # Assuming ignored_but_existing_path/ contains lint errors\n+                )\n \n     def test_regression_recursive_current_dir(self):\n         with _test_sys_path():\n",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..250a16d 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -935,10 +935,54 @@ print(submodule1)\n     assert not linter.stats.by_msg\n \n \n+def test_lint_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for an identically named module within a package.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        linter.check([\"a\"])\n+    assert not linter.stats.by_msg\n+\n+def test_lint_module_resolution_with_same_name(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for module resolution when modules have the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"from a import b\\n\")\n+        # Check module 'a' and 'r' together\n+        linter.check([\"r\", \"a\"])\n+    # Verify no errors regarding missing 'b' in 'a' and no parse errors\n+    assert not linter.stats.by_msg.get(\"no-name-in-module\", [])\n+    assert not linter.stats.by_msg.get(\"parse-error\", [])\n+\n+\n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n     linter = initialized_linter\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n+\n+\n+def test_lint_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for an identically named module within a package.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        linter.check([\"a\"])\n+    assert not linter.stats.by_msg\n+\n+def test_lint_module_resolution_with_same_name(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for module resolution when modules have the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"from a import b\\n\")\n+        # Check module 'a' and 'r' together\n+        linter.check([\"r\", \"a\"])\n+    # Verify no errors regarding missing 'b' in 'a' and no parse errors\n+    assert not linter.stats.by_msg.get(\"no-name-in-module\", [])\n+    assert not linter.stats.by_msg.get(\"parse-error\", [])\n",
  "pylint-dev__pylint-7993": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 6338072..da2aa32 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n@@ -103,14 +104,21 @@ def test_template_option_non_existing(linter) -> None:\n         in records[1].message.args[0]\n     )\n \n+def test_template_with_custom_braces(linter: PyLinter) -> None:\n+    \"\"\"Test message template with custom braces for ensuring backward compatibility.\"\"\"\n+    output = StringIO()\n+    linter.reporter.out = output\n+    linter.config.msg_template = '{{ \"Category\": \"{category}\" }}'\n+    linter.open()\n+    linter.set_current_module(\"my_mod\")\n+\n     linter.add_message(\"C0301\", line=1, args=(1, 2))\n-    linter.add_message(\n-        \"line-too-long\", line=2, end_lineno=2, end_col_offset=4, args=(3, 4)\n-    )\n+    linter.add_message(\"C0301\", line=2, args=(3, 4))\n \n-    out_lines = output.getvalue().split(\"\\n\")\n-    assert out_lines[1] == \"my_mod:1::()\"\n-    assert out_lines[2] == \"my_mod:2::()\"\n+    out_lines = output.getvalue().strip().split(\"\\n\")\n+    assert out_lines[0] == \"************* Module my_mod\"\n+    assert out_lines[1] == '{ \"Category\": \"convention\" }'\n+    assert out_lines[2] == '{ \"Category\": \"convention\" }'\n \n \n def test_deprecation_set_output(recwarn):\n",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "",
  "pytest-dev__pytest-5227": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 1ebe9d0..01f354c 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -15,7 +15,7 @@ from _pytest.compat import dummy_context_manager\n from _pytest.config import create_terminal_writer\n from _pytest.pathlib import Path\n \n-DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n+DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n \n \n",
  "pytest-dev__pytest-5495": "diff --git a/testing/test_assertion.py b/testing/test_assertion.py\nindex b05f85c..9091e36 100644\n--- a/testing/test_assertion.py\n+++ b/testing/test_assertion.py\n@@ -525,6 +525,22 @@ class TestAssert_reprcompare:\n         assert \"-\" + repr(nums_x) in expl\n         assert \"+\" + repr(nums_y) in expl\n \n+    def test_bytes_diff_empty_vs_nonempty(self):\n+        \"\"\"Test assertion message when comparing an empty byte string with a non-empty byte string.\"\"\"\n+        diff = callequal(b\"\", b\"42\", verbose=True)\n+        assert diff[1] == \"Right contains more items, first extra item: 52\"\n+        assert \"Full diff:\" in diff\n+        assert \"- b''\" in diff\n+        assert \"+ b'42'\" in diff\n+\n+    def test_bytes_diff_single_char(self):\n+        \"\"\"Test assertion message when comparing an empty byte string with a single character byte string.\"\"\"\n+        diff = callequal(b\"\", b\"1\", verbose=True)\n+        assert diff[1] == \"Right contains more items, first extra item: 49\"\n+        assert \"Full diff:\" in diff\n+        assert \"- b''\" in diff\n+        assert \"+ b'1'\" in diff\n+\n     def test_list_bad_repr(self):\n         class A:\n             def __repr__(self):\n",
  "pytest-dev__pytest-5692": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3392814..7bafeb5 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1,4 +1,6 @@\n+\n import os\n+import platform\n from xml.dom import minidom\n \n import py\n@@ -157,7 +159,29 @@ class TestPython:\n         val = tnode[\"time\"]\n         assert round(float(val), 2) >= 0.03\n \n-    @pytest.mark.parametrize(\"duration_report\", [\"call\", \"total\"])\n+    def test_hostname_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+            \"\"\"\n+        )\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        node.assert_attr(hostname=platform.node())\n+\n+    def test_timestamp_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+            \"\"\"\n+        )\n+        start_time = datetime.now()\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        timestamp = datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S.%f\")\n+        assert start_time <= timestamp < datetime.now()\n     def test_junit_duration_report(self, testdir, monkeypatch, duration_report):\n \n         # mock LogXML.node_reporter so it always sets a known duration to each test report object\n",
  "pytest-dev__pytest-7168": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 38e0b6b..5976bfb 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -144,6 +144,45 @@ def test_repr_on_newstyle():\n     assert saferepr(Function())\n \n \n+def test_broken_getattribute():\n+    \"\"\" saferepr() can create proper representations of classes with\n+    broken __getattribute__ (#7145)\n+    \"\"\"\n+\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError\n+\n+        def __repr__(self):\n+            raise RuntimeError\n+\n+    assert saferepr(SomeClass()).startswith(\n+        \"<[RuntimeError() raised in repr()] SomeClass object at 0x\"\n+    )\n+\n+\n+def test_exception_in_repr():\n+    \"\"\" Test that saferepr can handle exceptions raised in __repr__ \"\"\"\n+\n+    class ExceptionalRepr:\n+        def __repr__(self):\n+            raise ValueError(\"An exception occurred in __repr__\")\n+\n+    assert saferepr(ExceptionalRepr()).startswith(\n+        \"<[ValueError('An exception occurred in __repr__')] ExceptionalRepr object at 0x\"\n+    )\n+\n+\n+def test_no_exception():\n+    \"\"\" Test saferepr works normally without exception \"\"\"\n+\n+    class NormalClass:\n+        def __repr__(self):\n+            return \"NormalClass()\"\n+\n+    assert saferepr(NormalClass()) == \"NormalClass()\"\n+\n+\n def test_unicode():\n     val = \"\u00a3\u20ac\"\n     reprval = \"'\u00a3\u20ac'\"\n@@ -153,4 +192,4 @@ def test_unicode():\n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n-    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n",
  "pytest-dev__pytest-7220": "diff --git a/testing/test_pytester.py b/testing/test_pytester.py\nindex 5ab5242..c4be40c 100644\n--- a/testing/test_pytester.py\n+++ b/testing/test_pytester.py\n@@ -288,7 +288,32 @@ class TestInlineRunModulesCleanup:\n         assert imported.data == 42\n \n \n-def test_assert_outcomes_after_pytest_error(testdir) -> None:\n+def test_displayed_path_with_directory_change(testdir) -> None:\n+    \"\"\"Ensure that changing the working directory in a fixture does not alter the displayed file path in error messages.\"\"\"\n+\n+    # Create a test file with a fixture that changes the working directory\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import os\n+        import pytest\n+\n+        @pytest.fixture\n+        def private_dir():\n+            out_dir = 'temp_dir'\n+            os.mkdir(out_dir)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+\n+        def test_failure_with_cwd(private_dir):\n+            assert False\n+        \"\"\"\n+    )\n+\n+    # Run pytest and check the output\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([str(p) + \":*: AssertionError\", \"*1 failed in *\"])\n     testdir.makepyfile(\"def test_foo(): assert True\")\n \n     result = testdir.runpytest(\"--unexpected-argument\")\n",
  "pytest-dev__pytest-7373": "diff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 309636c..4cd101e 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1,6 +1,7 @@\n import os\n import sys\n from unittest import mock\n+import os\n \n import pytest\n from _pytest.config import ExitCode\n@@ -11,6 +12,35 @@ from _pytest.nodes import Node\n \n \n class TestMark:\n+    def test_reevaluate_dynamic_expr(self, testdir):\n+        \"\"\"#7360\"\"\"\n+        py_file1 = testdir.makepyfile(\n+            test_reevaluate_dynamic_expr1=\"\"\"\n+            import pytest\n+\n+            skip = True\n+\n+            @pytest.mark.skipif(\"skip\")\n+            def test_should_skip():\n+                assert True\n+            \"\"\"\n+        )\n+        py_file2 = testdir.makepyfile(\n+            test_reevaluate_dynamic_expr2=\"\"\"\n+            import pytest\n+\n+            skip = False\n+\n+            @pytest.mark.skipif(\"skip\")\n+            def test_should_not_skip():\n+                assert True\n+            \"\"\"\n+        )\n+\n+        file_name1 = os.path.basename(py_file1.strpath)\n+        file_name2 = os.path.basename(py_file2.strpath)\n+        reprec = testdir.inline_run(file_name1, file_name2)\n+        reprec.assertoutcome(passed=1, skipped=1)\n     @pytest.mark.parametrize(\"attr\", [\"mark\", \"param\"])\n     @pytest.mark.parametrize(\"modulename\", [\"py.test\", \"pytest\"])\n     def test_pytest_exists_in_namespace_all(self, attr: str, modulename: str) -> None:\n",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..cbd8c0c 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -422,6 +422,22 @@ class TestXFail:\n         result = testdir.runpytest(p)\n         result.stdout.fnmatch_lines([matchline])\n \n+    def test_skip_with_runxfail(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+\n+            @pytest.mark.skip\n+            def test_simple_skip():\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(\"-rs\")\n+        result.stdout.fnmatch_lines([\"SKIPPED *test_simple_skip*unconditional skip\", \"*1 skipped*\"])\n+\n+        result = testdir.runpytest(\"-rs\", \"--runxfail\")\n+        result.stdout.fnmatch_lines([\"SKIPPED *test_simple_skip*unconditional skip\", \"*1 skipped*\"])\n+\n     def test_strict_sanity(self, testdir):\n         \"\"\"sanity check for xfail(strict=True): a failing test should behave\n         exactly like a normal xfail.\n",
  "pytest-dev__pytest-7490": "",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..312a832 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,5 +1,39 @@\n+\n import os\n import stat\n+from _pytest.monkeypatch import MonkeyPatch\n+\n+def test_tmp_path_factory_handles_invalid_dir_characters(\n+    tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch\n+) -> None:\n+    # Simulate an environment where getpass.getuser() returns an invalid username\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"os/<:*?;>agnostic\")\n+    # _basetemp / _given_basetemp are cached / set in parallel runs, patch them\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"pytest-of-unknown\" in str(p)\n+\n+def test_tmpdir_factory_with_invalid_username(tmpdir_factory: TempdirFactory, monkeypatch: MonkeyPatch):\n+    # Here, 'contoso\\john_doe' simulates a problematic username with a backslash\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"contoso\\\\john_doe\")\n+    # Reset cached directories for testing\n+    monkeypatch.setattr(tmpdir_factory, \"_tmppath_factory._basetemp\", None)\n+    monkeypatch.setattr(tmpdir_factory, \"_tmppath_factory._given_basetemp\", None)\n+    # Create a temporary directory\n+    temp_dir = tmpdir_factory.mktemp(\"foobar\")\n+    assert temp_dir.exists()\n+\n+def test_tmpdir_factory_with_special_characters_username(tmpdir_factory: TempdirFactory, monkeypatch: MonkeyPatch):\n+    # Fake a username with special characters not allowed in Windows directories\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"user<invalid>\")\n+    # Ensure base temporary paths are reset\n+    monkeypatch.setattr(tmpdir_factory, \"_tmppath_factory._basetemp\", None)\n+    monkeypatch.setattr(tmpdir_factory, \"_tmppath_factory._given_basetemp\", None)\n+    # Ensure tempdir creation succeeds\n+    temp_dir = tmpdir_factory.mktemp(\"foobar\")\n+    assert temp_dir.exists()\n+\n import sys\n from pathlib import Path\n from typing import Callable\n",
  "scikit-learn__scikit-learn-10297": "",
  "scikit-learn__scikit-learn-11281": "diff --git a/sklearn/mixture/tests/test_bayesian_mixture.py b/sklearn/mixture/tests/test_bayesian_mixture.py\nindex a9d82b7..f3f8bd1 100644\n--- a/sklearn/mixture/tests/test_bayesian_mixture.py\n+++ b/sklearn/mixture/tests/test_bayesian_mixture.py\n@@ -5,16 +5,16 @@\n import numpy as np\n from scipy.special import gammaln\n \n-from sklearn.utils.testing import assert_raise_message\n+from sklearn.utils.testing import assert_raise_message, assert_greater\n from sklearn.utils.testing import assert_almost_equal\n \n from sklearn.mixture.bayesian_mixture import _log_dirichlet_norm\n from sklearn.mixture.bayesian_mixture import _log_wishart_norm\n \n-from sklearn.mixture import BayesianGaussianMixture\n+from sklearn.mixture import BayesianGaussianMixture, GaussianMixture\n \n from sklearn.mixture.tests.test_gaussian_mixture import RandomData\n-from sklearn.exceptions import ConvergenceWarning\n+from sklearn.exceptions import ConvergenceWarning, NotFittedError\n from sklearn.utils.testing import assert_greater_equal, ignore_warnings\n \n \n",
  "scikit-learn__scikit-learn-12471": "",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex f8e4d54..cf8d85c 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -597,8 +597,26 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_array_equal(Y_pred1, Y_pred2)\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n+from sklearn.mixture import GaussianMixture\n+from numpy.testing import assert_array_equal\n+import numpy as np\n \n-def test_gaussian_mixture_fit():\n+def test_gaussian_mixture_fit_predict_n_init_random_state():\n+    # Check the consistency of fit_predict and predict with different random states\n+    X = np.random.RandomState(42).randn(1000, 5)\n+    for random_state in [0, 1, 42]:\n+        gm = GaussianMixture(n_components=5, n_init=5, random_state=random_state)\n+        y_pred1 = gm.fit_predict(X)\n+        y_pred2 = gm.predict(X)\n+        assert_array_equal(y_pred1, y_pred2)\n+\n+def test_gaussian_mixture_fit_predict_n_init_large_components():\n+    # Check the consistency of fit_predict and predict with a large number of components\n+    X = np.random.RandomState(0).randn(1000, 5)\n+    gm = GaussianMixture(n_components=10, n_init=10, random_state=0)\n+    y_pred1 = gm.fit_predict(X)\n+    y_pred2 = gm.predict(X)\n+    assert_array_equal(y_pred1, y_pred2)\n     # recover the ground truth\n     rng = np.random.RandomState(0)\n     rand_data = RandomData(rng)\n",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..0fc9222 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,3 +1,4 @@\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n@@ -70,6 +71,25 @@ def test_kernel_pca_consistent_transform():\n     transformed2 = kpca.transform(X_copy)\n     assert_array_almost_equal(transformed1, transformed2)\n \n+def test_kernel_pca_sign_consistency():\n+    rng = np.random.RandomState(42)\n+    X = rng.rand(10, 10)\n+\n+    kpca = KernelPCA(n_components=7, kernel='rbf', random_state=rng)\n+    transformed1 = kpca.fit_transform(X)\n+\n+    consistent_signs = True\n+    for _ in range(10):\n+        kpca = KernelPCA(n_components=7, kernel='rbf', random_state=rng)\n+        transformed2 = kpca.fit_transform(X)\n+        \n+        # Check if the transformation results are consistent in sign\n+        if not (np.allclose(transformed1, transformed2) or np.allclose(transformed1, -transformed2)):\n+            consistent_signs = False\n+            break\n+\n+    assert consistent_signs, \"KernelPCA results have inconsistent signs across runs\"\n+\n \n def test_kernel_pca_sparse():\n     rng = np.random.RandomState(0)\n",
  "scikit-learn__scikit-learn-13439": "",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..88a84d4 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -13,6 +14,8 @@ import numpy as np\n from sklearn.utils.testing import assert_array_equal\n from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_raises\n+from sklearn.ensemble import IsolationForest\n+from sklearn.utils import check_random_state\n from sklearn.utils.testing import assert_raises_regex\n from sklearn.utils.testing import assert_warns_message\n from sklearn.utils.testing import assert_equal\n@@ -297,6 +300,34 @@ def test_score_samples():\n \n @pytest.mark.filterwarnings('ignore:default contamination')\n @pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n+def test_iforest_warm_start_increment():\n+    \"\"\"Test iterative addition of iTrees and their impact on predictions.\"\"\"\n+    \n+    rng = check_random_state(42)\n+    X_train = rng.normal(size=(100, 2))\n+    X_test = rng.normal(size=(10, 2))\n+    \n+    # Initial fit with 10 trees\n+    clf = IsolationForest(n_estimators=10, max_samples=20,\n+                          random_state=rng, warm_start=True)\n+    clf.fit(X_train)\n+    scores_10 = clf.decision_function(X_test)\n+    \n+    # Add 10 more trees to the existing model\n+    clf.set_params(n_estimators=20)\n+    clf.fit(X_train)\n+    scores_20 = clf.decision_function(X_test)\n+    \n+    # Add 20 more trees to the existing model\n+    clf.set_params(n_estimators=40)\n+    clf.fit(X_train)\n+    scores_40 = clf.decision_function(X_test)\n+    \n+    # Verify that scores change as more trees are added\n+    assert not np.array_equal(scores_10, scores_20), \"Scores should change when adding trees\"\n+    assert not np.array_equal(scores_20, scores_40), \"Scores should change when adding more trees\"\n+    assert clf.estimators_[0] is clf.estimators_[0]\n+@pytest.mark.filterwarnings('ignore:behaviour=\"old\"')\n def test_deprecation():\n     X = [[0.0], [1.0]]\n     clf = IsolationForest()\n",
  "scikit-learn__scikit-learn-13497": "",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..3f9cee5 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,3 +1,4 @@\n+\n import re\n from pprint import PrettyPrinter\n \n@@ -8,6 +9,7 @@ from sklearn.pipeline import make_pipeline\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.feature_selection import SelectKBest, chi2\n from sklearn import set_config\n+from sklearn.linear_model import LogisticRegressionCV\n \n \n # Ignore flake8 (lots of line too long issues)\n@@ -207,7 +209,21 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n     expected = \"\"\"SimpleImputer(missing_values=0)\"\"\"\n     assert imputer.__repr__() == expected\n \n-    # Defaults to np.NaN, trying with float('NaN')\n+    # Test LogisticRegressionCV with print_changed_only=True and array parameter\n+    set_config(print_changed_only=True)\n+    try:\n+        repr_lr_cv = repr(LogisticRegressionCV(Cs=np.array([0.1, 1])))\n+        assert \"Cs=array([0.1, 1. ])\" in repr_lr_cv\n+    except ValueError as e:\n+        assert False, f\"Unexpected ValueError raised: {str(e)}\"\n+\n+    # Test LogisticRegressionCV with print_changed_only=False and array parameter\n+    set_config(print_changed_only=False)\n+    repr_lr_cv_full = repr(LogisticRegressionCV(Cs=np.array([0.1, 1])))\n+    assert \"Cs=array([0.1, 1. ])\" in repr_lr_cv_full\n+\n+    # Reset to default config for further tests\n+    set_config(print_changed_only=False)\n     imputer = SimpleImputer(missing_values=float('NaN'))\n     expected = \"\"\"SimpleImputer()\"\"\"\n     assert imputer.__repr__() == expected\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..87e3924 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n@@ -16,6 +17,8 @@ from sklearn.model_selection import GridSearchCV\n from sklearn import datasets\n from sklearn.model_selection import cross_val_score, train_test_split\n from sklearn.datasets import make_multilabel_classification\n+from sklearn.linear_model import LinearRegression\n+from sklearn.ensemble import RandomForestRegressor\n from sklearn.svm import SVC\n from sklearn.multiclass import OneVsRestClassifier\n from sklearn.neighbors import KNeighborsClassifier\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..7d4f9ab 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -679,6 +679,31 @@ def test_unicode_kernel():\n                                 kernel='linear',\n                                 random_seed=0)\n \n+def test_sparse_fit_support_vectors_empty():\n+    # Import necessary libraries\n+    import numpy as np\n+    from scipy import sparse\n+    from sklearn import svm\n+\n+    # Regression test for #14893\n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+\n+    # Ensure that the support_vectors_ attribute is empty\n+    assert not model.support_vectors_.data.size\n+    # Ensure that the dual_coef_ attribute is also empty\n+    assert not model.dual_coef_.data.size\n+\n+    # Additional check: Ensure that the model does not throw an error with a new sparse input\n+    X_test = sparse.csr_matrix([[0, 0, 0, 0]])  # No support vectors expected\n+    prediction = model.predict(X_test)\n+    assert prediction.shape == (1,)  # Make sure it predicts a scalar value correctly\n+\n \n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n",
  "scikit-learn__scikit-learn-14983": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex dd52c66..4efb7e0 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -972,8 +972,19 @@ def test_leave_one_p_group_out_error_on_fewer_number_of_groups():\n                          LeavePGroupsOut(n_groups=3).split(X, y, groups))\n \n \n+import pytest\n+from sklearn.model_selection import RepeatedKFold, RepeatedStratifiedKFold\n+\n @ignore_warnings\n-def test_repeated_cv_value_errors():\n+@pytest.mark.parametrize(\n+    \"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold]\n+)\n+def test_repeated_cv_repr(RepeatedCV):\n+    n_splits, n_repeats = 2, 6\n+    repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats)\n+    repeated_cv_repr = ('{}(n_repeats=6, n_splits=2, random_state=None)'\n+                        .format(repeated_cv.__class__.__name__))\n+    assert repeated_cv_repr == repr(repeated_cv)\n     # n_repeats is not integer or <= 0\n     for cv in (RepeatedKFold, RepeatedStratifiedKFold):\n         assert_raises(ValueError, cv, n_repeats=0)\n",
  "scikit-learn__scikit-learn-15512": "",
  "scikit-learn__scikit-learn-15535": "diff --git a/sklearn/metrics/cluster/tests/test_common.py b/sklearn/metrics/cluster/tests/test_common.py\nindex 9991cff..61bb45d 100644\n--- a/sklearn/metrics/cluster/tests/test_common.py\n+++ b/sklearn/metrics/cluster/tests/test_common.py\n@@ -166,6 +166,20 @@ def test_format_invariance(metric_name):\n         yield y + 1, 'strictly positive ints'\n \n     if metric_name in SUPERVISED_METRICS:\n+        if metric_name == \"mutual_info_score\":\n+            string_labels = np.random.choice(['a', 'b'], size=20).astype(object)\n+            # Test case for input as array of strings\n+            try:\n+                metric(string_labels, string_labels)\n+            except ValueError as e:\n+                assert False, f\"mutual_info_score raised ValueError unexpectedly: {e}\"\n+\n+            # Test case for input as list of strings\n+            string_labels_list = list(string_labels)\n+            try:\n+                metric(string_labels_list, string_labels_list)\n+            except ValueError as e:\n+                assert False, f\"mutual_info_score raised ValueError unexpectedly: {e}\"\n         metric = SUPERVISED_METRICS[metric_name]\n         score_1 = metric(y_true, y_pred)\n         y_true_gen = generate_formats(y_true)\n",
  "scikit-learn__scikit-learn-25500": "",
  "scikit-learn__scikit-learn-25570": "",
  "sphinx-doc__sphinx-10325": "",
  "sphinx-doc__sphinx-7975": "diff --git a/tests/test_environment_indexentries.py b/tests/test_environment_indexentries.py\nindex 9775484..4768f85 100644\n--- a/tests/test_environment_indexentries.py\n+++ b/tests/test_environment_indexentries.py\n@@ -15,6 +15,27 @@ from sphinx.testing import restructuredtext\n \n \n @pytest.mark.sphinx('dummy', freshenv=True)\n+def test_symbols_index_entries(app):\n+    text = (\".. index:: @mention\\n\"\n+            \".. index:: \u00a3currency\\n\"\n+            \".. index:: \u2190arrow\\n\"\n+            \".. index:: normal\\n\"\n+            \".. index:: other\\n\")\n+    restructuredtext.parse(app, text)\n+    index = IndexEntries(app.env).create_index(app.builder)\n+    \n+    # Verify that there is only one 'Symbols' section\n+    assert len([entry for entry in index if entry[0] == 'Symbols']) == 1\n+    \n+    # Verify the 'Symbols' section contains the entries in the expected order\n+    assert index[0] == ('Symbols', [('@mention', [[('', '#index-0')], [], None]),\n+                                     ('\u00a3currency', [[('', '#index-1')], [], None]),\n+                                     ('\u2190arrow', [[('', '#index-2')], [], None])])\n+\n+    # Verify other sections\n+    assert index[1] == ('N', [('normal', [[('', '#index-3')], [], None])])\n+    assert index[2] == ('O', [('other', [[('', '#index-4')], [], None])])\n+\n def test_create_single_index(app):\n     text = (\".. index:: docutils\\n\"\n             \".. index:: Python\\n\"\n",
  "sphinx-doc__sphinx-8435": "",
  "sphinx-doc__sphinx-8506": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 08bd595..18541fa 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -91,7 +91,51 @@ def test_get_full_qualified_name():\n     assert domain.get_full_qualified_name(node) == 'ls.-l'\n \n \n-def test_glossary(app):\n+import pytest\n+from sphinx.testing.util import assert_node\n+from sphinx import addnodes\n+from docutils import nodes\n+\n+def test_cmd_option_with_optional_value(app):\n+    text = \".. option:: -j[=N]\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (addnodes.index,\n+                          [addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '-j'],\n+                                                                     [addnodes.desc_addname, '[=N]'])],\n+                                           [addnodes.desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('-j', '-j', 'cmdoption', 'index', 'cmdoption-j', 1) in objects\n+\n+def test_cmd_option_starting_with_bracket(app):\n+    text = \".. option:: [enable=]PATTERN\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (addnodes.index,\n+                          [addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '[enable'],\n+                                                                     [addnodes.desc_addname, '=]PATTERN'])],\n+                                           [addnodes.desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('[enable', '[enable', 'cmdoption', 'index', 'cmdoption-arg-enable', 1) in objects\n+\n+def test_cmd_option_with_unconventional_syntax(app):\n+    # This test checks if unconventional option syntax is accepted\n+    text = \".. option:: --foo=<bar>\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (addnodes.index,\n+                          [addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, '--foo'],\n+                                                                     [addnodes.desc_addname, '=<bar>'])],\n+                                           [addnodes.desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('--foo', '--foo', 'cmdoption', 'index', 'cmdoption-foo', 1) in objects\n+\n+def test_cmd_option_with_no_leading_dashes(app):\n+    # Test for options without leading dashes\n+    text = \".. option:: COMMAND\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (addnodes.index,\n+                          [addnodes.desc, ([addnodes.desc_signature, ([addnodes.desc_name, 'COMMAND'], [])],\n+                                           [addnodes.desc_content, ()])]))\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('COMMAND', 'COMMAND', 'cmdoption', 'index', 'cmdoption-command', 1) in objects\n     text = (\".. glossary::\\n\"\n             \"\\n\"\n             \"   term1\\n\"\n",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..39584bc 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -21,6 +21,7 @@ from sphinx.ext.autodoc import ALL, ModuleLevelDocumenter, Options\n from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n from sphinx.testing.util import SphinxTestApp, Struct  # NOQA\n from sphinx.util.docutils import LoggingReporter\n+from .test_ext_autodoc import do_autodoc\n \n try:\n     # Enable pyximport to test cython module\n@@ -45,6 +46,62 @@ def do_autodoc(app, objtype, name, options=None):\n     return bridge.result\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_autodoc_with_empty_all(app):\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.empty_all_module', options)\n+    expected_output = [\n+        '',\n+        '.. py:module:: target.empty_all_module',\n+        '',\n+        'docstring of empty_all module.',\n+        '',\n+    ]\n+    assert list(actual) == expected_output\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_autodoc_with_non_empty_all(app):\n+    mod_content = '''\n+    \"\"\"Example module with non-empty __all__.\"\"\"\n+    __all__ = ['foo', 'bar']\n+\n+    def foo():\n+        \"\"\"docstring for foo\"\"\"\n+        pass\n+\n+    def bar():\n+        \"\"\"docstring for bar\"\"\"\n+        pass\n+\n+    def baz():\n+        \"\"\"docstring for baz\"\"\"\n+        pass\n+    '''\n+    with open(app.srcdir / 'target' / 'non_empty_all_module.py', 'w') as f:\n+        f.write(mod_content)\n+    \n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.non_empty_all_module', options)\n+    expected_output = [\n+        '',\n+        '.. py:module:: target.non_empty_all_module',\n+        '',\n+        'Example module with non-empty __all__.',\n+        '',\n+        '.. py:function:: foo()',\n+        '   :module: target.non_empty_all_module',\n+        '',\n+        '   docstring for foo',\n+        '',\n+        '.. py:function:: bar()',\n+        '   :module: target.non_empty_all_module',\n+        '',\n+        '   docstring for bar',\n+        ''\n+    ]\n+    assert list(actual) == expected_output\n+\n+\n def make_directive_bridge(env):\n     options = Options(\n         inherited_members = False,\n",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..dece3ba 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -10,6 +11,7 @@\n \n import sys\n from numbers import Integral\n+from struct import Struct\n from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tuple, TypeVar,\n                     Union)\n \n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..5a5d3e7 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1458,7 +1458,29 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n \"\"\"\n         self.assertEqual(expected, actual)\n \n-    def test_multiple_parameters(self):\n+    def test_other_parameters_with_and_without_napoleon_use_param(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+    Description of param2\n+\n+\"\"\"\n+\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param2** (:class:`MyClass <name.space.MyClass>` instance)\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param param2:\n+:type param2: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n         docstring = \"\"\"\\\n Parameters\n ----------\n",
  "sphinx-doc__sphinx-8721": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\nindex d4fba47..2657a00 100644\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -60,8 +60,28 @@ def test_linkcode(app, status, warning):\n     assert 'http://foobar/c/' in stuff\n     assert 'http://foobar/cpp/' in stuff\n \n+import pytest\n+from pathlib import Path\n+\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode')\n+def test_viewcode_epub_default(app, status, warning):\n+    app.builder.build_all()\n+\n+    assert not (app.outdir / '_modules/spam/mod1.xhtml').exists()\n+\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode',\n+                    confoverrides={'viewcode_enable_epub': True})\n+def test_viewcode_epub_enabled(app, status, warning):\n+    app.builder.build_all()\n+\n+    assert (app.outdir / '_modules/spam/mod1.xhtml').exists()\n+\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode',\n+                    confoverrides={'viewcode_enable_epub': False})\n+def test_viewcode_epub_disabled(app, status, warning):\n+    app.builder.build_all()\n \n-@pytest.mark.sphinx(testroot='ext-viewcode-find')\n+    assert not (app.outdir / '_modules/spam/mod1.xhtml').exists()\n def test_local_source_files(app, status, warning):\n     def find_source(app, modname):\n         if modname == 'not_a_package':\n",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..a38a4e1 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -322,6 +322,24 @@ def test_mul():\n         assert h == h2\n \n \n+def test_non_disjoint_cycles():\n+    # Non-disjoint cycles should be applied in left-to-right order\n+\n+    # Example where the cycles should cancel each other out, resulting in identity\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n+\n+    # Non-disjoint cycles modifying different elements\n+    assert Permutation([[0, 1], [1, 2]]) == Permutation([1, 2, 0])\n+\n+    # Larger non-disjoint cycles, should be equivalent to just the first\n+    assert Permutation([[0, 1, 2], [1, 2]]) == Permutation([1, 2, 0])\n+\n+    # Cycles that interact partially, affecting only some elements\n+    assert Permutation([[0, 2], [1, 2], [2, 3]]) == Permutation([2, 3, 1, 0])\n+\n+    # Test for identity with three repetitive non-disjoint cycles\n+    assert Permutation([[0, 1], [0, 1], [0, 1]]) == Permutation([0, 1])\n+\n def test_args():\n     p = Permutation([(0, 3, 1, 2), (4, 5)])\n     assert p._cyclic_form is None\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..57145b0 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -1,3 +1,4 @@\n+\n from sympy import Abs, S, Symbol, I, Rational, PurePoly\n from sympy.matrices import Matrix, SparseMatrix, eye, zeros, ShapeError\n from sympy.utilities.pytest import raises\n@@ -448,6 +449,21 @@ def test_sparse_matrix():\n     assert A.col_list() == [(0, 0, 18), (4, 2, 19), (6, 2, 12), (1, 4, 18), (2, 7, 16), (5, 7, 16), (9, 7, 18), (0, 9, 12), (3, 9, 12)]\n     assert SparseMatrix.eye(2).nnz() == 2\n \n+    # Additional test cases for issue verification\n+    # Testing horizontal stacking with zero-row matrices\n+    M1 = SparseMatrix.zeros(0, 0)\n+    M2 = SparseMatrix.zeros(0, 1)\n+    M3 = SparseMatrix.zeros(0, 2)\n+    M4 = SparseMatrix.zeros(0, 3)\n+    assert SparseMatrix.hstack(M1, M2, M3, M4).shape == (0, 6)\n+\n+    # Testing vertical stacking with zero-column matrices\n+    M1 = SparseMatrix.zeros(1, 0)\n+    M2 = SparseMatrix.zeros(2, 0)\n+    M3 = SparseMatrix.zeros(3, 0)\n+    M4 = SparseMatrix.zeros(4, 0)\n+    assert SparseMatrix.vstack(M1, M2, M3, M4).shape == (10, 0)\n+\n \n def test_transpose():\n     assert SparseMatrix(((1, 2), (3, 4))).transpose() == \\\n",
  "sympy__sympy-13471": "diff --git a/sympy/utilities/tests/test_pickling.py b/sympy/utilities/tests/test_pickling.py\nindex 52dcc20..9011e92 100644\n--- a/sympy/utilities/tests/test_pickling.py\n+++ b/sympy/utilities/tests/test_pickling.py\n@@ -99,8 +99,18 @@ def test_core_symbol():\n             Symbol(\"_issue_3130\", commutative=False), Wild, Wild(\"x\")):\n         check(c)\n \n-\n-def test_core_numbers():\n+import pickle\n+from sympy import Float, symbols\n+\n+def test_pickle_float_expression_py2_to_py3():\n+    # Simulate a pickled float expression from Python 2\n+    python2_pickled_data = b'\\x80\\x02csympy.core.numbers\\nFloat\\nq\\x00X\\x01\\x00\\x00\\x00\\x301q\\x01\\x85q\\x02Rq\\x03.'\n+    \n+    # Load it in Python 3 and assert it is as expected\n+    x = symbols('x')\n+    expected = x + Float('1.0')\n+    loaded = pickle.loads(python2_pickled_data)\n+    assert loaded == expected\n     for c in (Integer(2), Rational(2, 3), Float(\"1.2\")):\n         check(c)\n \n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..7400496 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -279,6 +279,16 @@ def test_coth_series():\n         1/x + x/3 - x**3/45 + 2*x**5/945 - x**7/4725 + O(x**8)\n \n \n+def test_coth_subs_integral_values():\n+    from sympy import Symbol, coth, log, tan, I, pi\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+\n+    # Test for the specific integral values mentioned in the issue\n+    integral_values = [2, 3, 5, 6, 8, 9, 11, 12, 13, 15, 18]\n+    for value in integral_values:\n+        assert e.subs(x, value)  # This should not raise an error\n+\n def test_csch():\n     x, y = symbols('x,y')\n \n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..d751aae 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -201,7 +201,29 @@ def test_col_insert():\n         l.insert(i, 4)\n         assert flatten(zeros_Shaping(3).col_insert(i, c4).row(0).tolist()) == l\n \n-def test_extract():\n+def test_col_insert_issue_13643():\n+    from sympy import Matrix, eye, ones\n+    # Reproducing the issue with a 6x6 identity matrix and inserting a column of twos\n+    M = eye(6)\n+    V = 2 * ones(6, 2)\n+    assert M.col_insert(3, V) == Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    \n+    # Additional test with a different size matrix and value\n+    M2 = eye(4)\n+    V2 = ones(4, 1)\n+    assert M2.col_insert(2, V2) == Matrix([\n+        [1, 0, 1, 0, 0],\n+        [0, 1, 1, 0, 0],\n+        [0, 0, 1, 1, 0],\n+        [0, 0, 1, 0, 1]\n+    ])\n     m = ShapingOnlyMatrix(4, 3, lambda i, j: i*3 + j)\n     assert m.extract([0, 1, 3], [0, 1]) == Matrix(3, 2, [0, 1, 3, 4, 9, 10])\n     assert m.extract([0, 3], [0, 0, 2]) == Matrix(2, 3, [0, 0, 2, 9, 9, 11])\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..28aa2d8 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -620,6 +620,51 @@ def test_latex_sequences():\n     s1 = SeqFormula(a**2, (0, oo))\n     s2 = SeqPer((1, 2))\n \n+    # Ensure brackets are not improperly escaped.\n+    latex_str = r'[0, 1, 4, 9, \\ldots]'\n+    assert latex(s1) == latex_str\n+\n+    latex_str = r'[1, 2, 1, 2, \\ldots]'\n+    assert latex(s2) == latex_str\n+\n+    s3 = SeqFormula(a**2, (0, 2))\n+    s4 = SeqPer((1, 2), (0, 2))\n+\n+    latex_str = r'[0, 1, 4]'\n+    assert latex(s3) == latex_str\n+\n+    latex_str = r'[1, 2, 1]'\n+    assert latex(s4) == latex_str\n+\n+    s5 = SeqFormula(a**2, (-oo, 0))\n+    s6 = SeqPer((1, 2), (-oo, 0))\n+\n+    latex_str = r'[\\ldots, 9, 4, 1, 0]'\n+    assert latex(s5) == latex_str\n+\n+    latex_str = r'[\\ldots, 2, 1, 2, 1]'\n+    assert latex(s6) == latex_str\n+\n+    latex_str = r'[1, 3, 5, 11, \\ldots]'\n+    assert latex(SeqAdd(s1, s2)) == latex_str\n+\n+    latex_str = r'[1, 3, 5]'\n+    assert latex(SeqAdd(s3, s4)) == latex_str\n+\n+    latex_str = r'[\\ldots, 11, 5, 3, 1]'\n+    assert latex(SeqAdd(s5, s6)) == latex_str\n+\n+    latex_str = r'[0, 2, 4, 18, \\ldots]'\n+    assert latex(SeqMul(s1, s2)) == latex_str\n+\n+    latex_str = r'[0, 2, 4]'\n+    assert latex(SeqMul(s3, s4)) == latex_str\n+\n+    latex_str = r'[\\ldots, 18, 4, 2, 0]'\n+    assert latex(SeqMul(s5, s6)) == latex_str\n+    s1 = SeqFormula(a**2, (0, oo))\n+    s2 = SeqPer((1, 2))\n+\n     latex_str = r'\\left\\[0, 1, 4, 9, \\ldots\\right\\]'\n     assert latex(s1) == latex_str\n \n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..534ab69 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,25 @@\n+\n+def test_Domain_preprocess_RR_CC():\n+    # Existing tests\n+    assert Domain.preprocess('R[x]') == RR[x]\n+    assert Domain.preprocess('C[x]') == CC[x]\n+    assert Domain.preprocess('RR[x]') == RR[x]\n+    assert Domain.preprocess('CC[x]') == CC[x]\n+    assert Domain.preprocess('R[x,y]') == RR[x, y]\n+    assert Domain.preprocess('C[x,y]') == CC[x, y]\n+    assert Domain.preprocess('RR[x,y]') == RR[x, y]\n+    assert Domain.preprocess('CC[x,y]') == CC[x, y]\n+\n+    # New tests for issue verification\n+    assert Domain.preprocess('RR[y,z]') == RR[y, z]\n+    assert Domain.preprocess('CC[y,z]') == CC[y, z]\n+\n+    # Edge cases and error handling\n+    raises(OptionError, lambda: Domain.preprocess('RR()'))\n+    raises(OptionError, lambda: Domain.preprocess('CC()'))\n+    raises(OptionError, lambda: Domain.preprocess('RR<>'))\n+    raises(OptionError, lambda: Domain.preprocess('CC<>'))\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +28,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX  # Added RR and CC for real and complex number domains\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n",
  "sympy__sympy-14774": "",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..38230ff 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6111,6 +6111,31 @@ u(\"\"\"\\\n     assert upretty((1/y)*e.j) == ucode_str\n \n \n+from sympy import symbols, MatrixSymbol, pretty\n+\n+n, a = symbols('n a')\n+\n+def test_pretty_print_MatAdd():\n+    # issue #14814\n+    x = MatrixSymbol('x', n, n)\n+    y = MatrixSymbol('y*', n, n)\n+\n+    # Test case to verify fix for error while pretty printing MatAdd\n+    assert pretty(x + y) == \"x + y*\"\n+\n+    # Additional test cases to verify handling with negative and complex expressions\n+    A = MatrixSymbol('A', n, n)\n+    B = MatrixSymbol('B', n, n)\n+    assert pretty(-A + B) == \"-A + B\"\n+    assert pretty(x - A) == \"-A + x\"\n+    assert pretty(-a*x + -2*y*y) == \"-a*x - 2*y**y*\"\n+    assert pretty(A + B + x - y) == \"A + B + x - y*\"\n+\n+    # Test edge cases with zero or empty matrices\n+    zero_matrix = MatrixSymbol('0', 0, 0)\n+    assert pretty(zero_matrix + x) == \"x\"\n+    assert pretty(A + zero_matrix) == \"A\"\n+\n def test_MatrixSymbol_printing():\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..0414f9c 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -720,6 +720,24 @@ def test_dummification():\n     lam = lambdify((F(t), G(t)), some_expr)\n     assert lam(3, 9) == 2\n     lam = lambdify(sin(t), 2 * sin(t)**2)\n+\n+def test_curly_matrix_symbol():\n+    # Issue #15009\n+    import sympy as sy\n+    curlyv = sy.MatrixSymbol(\"{v}\", 2, 1)\n+    \n+    # Attempt to create a lambda without dummification\n+    try:\n+        lam = lambdify(curlyv, curlyv)\n+        # If no exception is raised, test invocation\n+        assert (lam([[1], [2]]) == [[1], [2]])\n+    except SyntaxError:\n+        assert False, \"Unexpected SyntaxError with curly braces and MatrixSymbol\"\n+\n+    # Create a lambda with dummification\n+    lam_dummified = lambdify(curlyv, curlyv, dummify=True)\n+    result = lam_dummified([[1], [2]])\n+    assert (result == [[1], [2]]), f\"Expected [[1], [2]], but got {result}\"\n     assert lam(F(t)) == 2 * F(t)**2\n     #Test that \\alpha was properly dummified\n     lam = lambdify((alpha, t), 2*alpha + t)\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..87d4e28 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n@@ -29,8 +30,22 @@ def test_Function():\n     assert mcode(sin(x) ** cos(x)) == \"Sin[x]^Cos[x]\"\n     assert mcode(conjugate(x)) == \"Conjugate[x]\"\n \n-\n-def test_Pow():\n+def test_Max_Min():\n+    # Test single Max function with two arguments, ensuring proper order\n+    assert mcode(Max(x, 2)) == \"Max[x, 2]\"\n+    assert mcode(Max(2, x)) == \"Max[2, x]\"\n+    \n+    # Test Max function with more than two arguments\n+    assert mcode(Max(x, y, z)) == \"Max[x, y, z]\"\n+    assert mcode(Max(z, y, x)) == \"Max[z, y, x]\"\n+    \n+    # Test Max within a more complex expression\n+    assert mcode(Max(x, 2) * Min(y, x)) == \"Max[x, 2]*Min[y, x]\"\n+    assert mcode(Max(x, Min(y, z))) == \"Max[x, Min[y, z]]\"\n+    \n+    # Test nested Max functions\n+    assert mcode(Max(Max(x, y), z)) == \"Max[Max[x, y], z]\"\n+    assert mcode(Max(x, Max(y, z))) == \"Max[x, Max[y, z]]\"\n     assert mcode(x**3) == \"x^3\"\n     assert mcode(x**(y**3)) == \"x^(y^3)\"\n     assert mcode(1/(f(x)*3.5)**(x - y**x)/(x**2 + y)) == \\\n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..67c8766 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1717,6 +1717,27 @@ def test_issue_13651():\n     assert latex(expr) == r\"c - \\left(a + b\\right)\"\n \n \n+from sympy import symbols, MatrixSymbol, latex\n+\n+def test_indexed_matrix_expression_latex_printer():\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    # Verifying the fix for the issue with double subscripts\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n+\n+    # Additional test case: checking latex output for different indices\n+    l, m = symbols(\"l m\")\n+    P = MatrixSymbol(\"P\", l, l)\n+    Q = MatrixSymbol(\"Q\", l, l)\n+    assert latex((P*Q)[m, j]) == r'\\sum_{i_{1}=0}^{l - 1} P_{m, i_{1}} Q_{i_{1}, j}'\n+    \n+    # Additional test case: higher dimensional matrices\n+    r, s, t = symbols(\"r s t\")\n+    R = MatrixSymbol(\"R\", r, s)\n+    S = MatrixSymbol(\"S\", s, t)\n+    assert latex((R*S)[i, j]) == r'\\sum_{i_{1}=0}^{s - 1} R_{i, i_{1}} S_{i_{1}, j}'\n+\n def test_latex_UnevaluatedExpr():\n     x = symbols(\"x\")\n     he = UnevaluatedExpr(1/x)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..9b7eff7 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, exp, Eq\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -9,7 +10,19 @@ def test_idiff():\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     t = Symbol('t', real=True)\n-    # the use of idiff in ellipse also provides coverage\n+    f = Function('f')\n+    g = Function('g')\n+\n+    # Test cases from the original patch, to check f(x) expressions.\n+    assert idiff(f(x) * exp(f(x)) - x * exp(x), f(x), x) == (x + 1) * exp(x - f(x))/(f(x) + 1)\n+    assert idiff(f(x) - y * exp(x), [f(x), y], x) == (y + Derivative(y, x)) * exp(x)\n+    assert idiff(f(x) - y * exp(x), [y, f(x)], x) == -y + exp(-x) * Derivative(f(x), x)\n+    assert idiff(f(x) - g(x), [f(x), g(x)], x) == Derivative(g(x), x)\n+\n+    # New test cases for using Eq with idiff().\n+    assert idiff(Eq(y*exp(y), x*exp(x)), y, x) == (x + 1) * exp(x - y)/(y + 1)\n+    eq_test = Eq(f(x)*exp(f(x)), x*exp(x))\n+    assert idiff(eq_test, f(x), x) == (x + 1) * exp(x - f(x))/(f(x) + 1)\n     circ = x**2 + y**2 - 4\n     ans = -3*x*(x**2 + y**2)/y**5\n     assert ans == idiff(circ, y, x, 3).simplify()\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_codegen.py b/sympy/utilities/tests/test_codegen.py\nindex 6bc2605..0178014 100644\n--- a/sympy/utilities/tests/test_codegen.py\n+++ b/sympy/utilities/tests/test_codegen.py\n@@ -582,6 +582,41 @@ def test_ccode_cse():\n     )\n     assert source == expected\n \n+def test_ccode_unused_array_arg():\n+    from sympy.utilities.codegen import codegen, CCodeGen\n+    from sympy import MatrixSymbol\n+\n+    x = MatrixSymbol('x', 2, 1)\n+    # x does not appear in output\n+    name_expr = (\"test\", 1.0)\n+    generator = CCodeGen()\n+    result = codegen(name_expr, code_gen=generator, header=False, empty=False, argument_sequence=(x,))\n+    source = result[0][1]\n+    # note: x should appear as (double *)\n+    expected = (\n+        '#include \"test.h\"\\n'\n+        '#include <math.h>\\n'\n+        'double test(double *x) {\\n'\n+        '   double test_result;\\n'\n+        '   test_result = 1.0;\\n'\n+        '   return test_result;\\n'\n+        '}\\n'\n+    )\n+    assert source == expected\n+\n+def test_autowrap_cython_with_unused_array_arg():\n+    from sympy.utilities.autowrap import autowrap\n+    from sympy import MatrixSymbol\n+    import numpy as np\n+\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0\n+    f = autowrap(expr, args=(x,), backend='cython')\n+\n+    result = f(np.array([[1.0], [2.0]]))\n+    expected_result = 1.0\n+    assert result == expected_result\n+\n def test_empty_f_code():\n     code_gen = FCodeGen()\n     source = get_string(code_gen.dump_f95, [])\n",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..11df318 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -343,7 +343,33 @@ def test_intersection():\n     assert Intersection() == S.UniversalSet\n \n \n-def test_issue_9623():\n+def test_intersection_duplicates():\n+    x = Symbol('x')\n+\n+    # Test cases from the issue\n+    assert Intersection({1}, {1}, {x}) == Intersection({1}, {x})\n+    assert Intersection({1}, {x}) == Piecewise(({1}, Eq(x, 1)), (S.EmptySet, True))\n+\n+    # Additional test cases\n+    assert Intersection({1, 1}, {2, 2}, {3, 3}) == S.EmptySet\n+    assert Intersection({1, 2, 2}, {2, 3, 3}) == {2}\n+    assert Intersection({1, 2, 2}, {2, 3, 3}, {2}) == {2}\n+\n+    # Check if the intersection is unevaluated if symbolic\n+    assert isinstance(Intersection({1}, {1}, {x}, evaluate=False), Intersection)\n+\n+    # Check behavior with empty sets\n+    assert Intersection(S.EmptySet, {1, 1}) == S.EmptySet\n+    assert Intersection(S.EmptySet, {1, 2, 3}) == S.EmptySet\n+\n+    # Check behavior with UniversalSet\n+    assert Intersection(S.UniversalSet, {1, 1}) == {1}\n+    assert Intersection(S.UniversalSet, S.UniversalSet) == S.UniversalSet\n+\n+    # Check behavior with symbolic entries\n+    y = Symbol('y')\n+    assert Intersection({x, y}, {y}) == {y}\n+    assert Intersection({x, y, y}, {y, y}) == {y}\n     n = Symbol('n')\n \n     a = S.Reals\n",
  "sympy__sympy-17022": "diff --git a/sympy/printing/tests/test_numpy.py b/sympy/printing/tests/test_numpy.py\nindex fa5ed1f..273d400 100644\n--- a/sympy/printing/tests/test_numpy.py\n+++ b/sympy/printing/tests/test_numpy.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Piecewise, lambdify, Equality, Unequality, Sum, Mod, cbrt, sqrt,\n     MatrixSymbol, BlockMatrix\n@@ -10,13 +11,29 @@ from sympy.codegen.array_utils import (CodegenArrayContraction,\n         CodegenArrayPermuteDims, CodegenArrayElementwiseAdd)\n from sympy.printing.lambdarepr import NumPyPrinter\n \n-from sympy.utilities.pytest import warns_deprecated_sympy\n+from sympy.utilities.pytest import warns_deprecated_sympy, raises\n+from sympy.matrices import MatrixSymbol, Identity\n from sympy.utilities.pytest import skip\n from sympy.external import import_module\n \n np = import_module('numpy')\n \n-def test_numpy_piecewise_regression():\n+def test_issue_17006():\n+    if not np:\n+        skip(\"NumPy not installed\")\n+\n+    M = MatrixSymbol(\"M\", 2, 2)\n+    f = lambdify(M, M + Identity(2), 'numpy')\n+    ma = np.array([[1, 2], [3, 4]])\n+    mr = np.array([[2, 2], [3, 5]])\n+    \n+    assert (f(ma) == mr).all()\n+\n+    # Test with symbolic dimensions\n+    from sympy import symbols\n+    n = symbols('n', integer=True)\n+    N = MatrixSymbol(\"M\", n, n)\n+    raises(NotImplementedError, lambda: lambdify(N, N + Identity(n)))\n     \"\"\"\n     NumPyPrinter needs to print Piecewise()'s choicelist as a list to avoid\n     breaking compatibility with numpy 1.8. This is not necessary in numpy 1.9+.\n",
  "sympy__sympy-17139": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex daf5f69..273fd27 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -808,10 +808,22 @@ def test_issue_15965():\n     bnew = y*Integral(x, x)\n     assert simplify(A + B) == anew + bnew\n     assert simplify(A) == anew\n+\n+def test_issue_17137():\n+    x = Symbol('x')\n+    # Test the specific case that caused the original issue\n+    assert simplify(cos(x)**I) == cos(x)**I\n+    assert simplify(cos(x)**(2 + 3*I)) == cos(x)**(2 + 3*I)\n+    # Additional cases\n+    assert simplify(sin(x)**I) == sin(x)**I\n+    assert simplify(sin(x)**(2 + 3*I)) == sin(x)**(2 + 3*I)\n+    assert simplify(tan(x)**I) == tan(x)**I\n+    assert simplify(exp(x)**I) == exp(x)**I\n+    assert simplify((x + 1)**I) == (x + 1)**I\n     assert simplify(B) == bnew\n \n \n def test_issue_7971():\n     z = Integral(x, (x, 1, 1))\n     assert z != 0\n-    assert simplify(z) is S.Zero\n+    assert simplify(z) is S.Zero\n",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..fc853cc 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,4 +1,5 @@\n-from sympy import I, Rational, Symbol, pi, sqrt, S\n+\n+from sympy import I, Rational, Symbol, pi, sqrt, S, sympify\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n from sympy.matrices import Matrix\n@@ -93,6 +94,16 @@ def test_point():\n     assert p4 * 5 == Point(5, 5)\n     assert p4 / 5 == Point(0.2, 0.2)\n \n+    # Test multiplication order\n+    point1 = Point(0, 0)\n+    point2 = Point(1, 1)\n+    assert point1 + point2 * sympify(2.0) == Point(2, 2)\n+    assert point1 + sympify(2.0) * point2 == Point(2, 2)\n+\n+    # Ensure original test patch is covered\n+    assert 5 * p4 == Point(5, 5)\n+    assert 5 * Point3D(1, 1, 1) == Point3D(5, 5, 5)\n+\n     raises(ValueError, lambda: Point(0, 0) + 10)\n \n     # Point differences should be simplified\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..1378620 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1894,7 +1894,30 @@ def test_normal():\n     assert e.normal() == e\n \n \n-def test_expr():\n+def test_non_string_equality_issue():\n+    # Test case to verify that __eq__ does not wrongly interpret repr strings\n+    x = symbols('x')\n+\n+    # Check that repr leading to code execution does not cause issues:\n+    class C:\n+        def __repr__(self):\n+            return 'x.y'\n+    assert (x == C()) is False\n+    assert (x != C()) is True\n+\n+    class BadRepr:\n+        def __repr__(self):\n+            return 'x'\n+\n+    # Ensure that objects with misleading repr don't compare as equal.\n+    assert (x == BadRepr()) is False\n+    assert (x != BadRepr()) is True\n+\n+    # Ensuring symbols do not mistakenly compare with strings\n+    assert (x == 'x') is False\n+    assert (x != 'x') is True\n+\n+# Original test function\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n \n@@ -1902,4 +1925,4 @@ def test_expr():\n def test_ExprBuilder():\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..a2018bc 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -547,7 +547,11 @@ def test_diophantine():\n     assert diophantine(x**2 + y**2 +3*x- 5, permute=True) == \\\n         set([(-1, 1), (-4, -1), (1, -1), (1, 1), (-4, 1), (-1, -1), (4, 1), (4, -1)])\n \n-    # issue 18122\n+    # issue 18186\n+    assert diophantine(x**4 + y**4 - 2**4 - 3**4, syms=(x, y), permute=True) == \\\n+        {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n+    assert diophantine(x**4 + y**4 - 2**4 - 3**4, syms=(y, x), permute=True) == \\\n+        {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n     assert check_solutions(x**2-y)\n     assert check_solutions(y**2-x)\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n",
  "sympy__sympy-18532": "diff --git a/sympy/codegen/tests/test_cnodes.py b/sympy/codegen/tests/test_cnodes.py\nindex c30dccd..03dd0ab 100644\n--- a/sympy/codegen/tests/test_cnodes.py\n+++ b/sympy/codegen/tests/test_cnodes.py\n@@ -1,6 +1,7 @@\n+\n from sympy.core.symbol import symbols\n from sympy.printing.ccode import ccode\n-from sympy.codegen.ast import Declaration, Variable, float64, int64\n+from sympy.codegen.ast import Declaration, Variable, float64, int64, String\n from sympy.codegen.cnodes import (\n     alignof, CommaOperator, goto, Label, PreDecrement, PostDecrement, PreIncrement, PostIncrement,\n     sizeof, union, struct\n@@ -66,7 +67,7 @@ def test_sizeof():\n     assert ccode(sz) == 'sizeof(%s)' % typename\n     assert sz.func(*sz.args) == sz\n     assert not sz.is_Atom\n-    assert all(atom == typename for atom in sz.atoms())\n+    assert sz.atoms() == {String('unsigned int'), String('sizeof')}\n \n \n def test_struct():\n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..55ddcdd 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,13 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_BlockDiagMatrix_single_element_conversion():\n+    from sympy import Matrix, BlockDiagMatrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    B = Matrix(D)\n+    assert B == Matrix([[1, 2], [3, 4]])\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..7f9125b 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,7 +1,8 @@\n+\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n-from sympy.testing.pytest import raises\n+from sympy.testing.pytest import raises, XFAIL\n from sympy.matrices.expressions.matexpr import MatrixElement, MatrixExpr\n \n k, l, m, n = symbols('k l m n', integer=True)\n@@ -65,8 +66,19 @@ def test_Identity_index():\n     assert I[i, 0].delta_range == (0, 2)\n     raises(IndexError, lambda: I[3, 3])\n \n+def test_block_index_symbolic_issue():\n+    n, i = symbols('n i', integer=True)\n+    A = MatrixSymbol('A', 1, 1)\n+    B = MatrixSymbol('B', n, 1)\n+    C = BlockMatrix([[A], [B]])\n+\n+    # Test that symbolic index returns MatrixElement, not simplified form\n+    assert C[i, 0] == MatrixElement(C, i, 0)\n \n-def test_block_index():\n+    # Explicit tests that C[0, 0] equals A[0, 0] and C[1, 0] equals B[0, 0] (if n > 0)\n+    assert C[0, 0] == A[0, 0]\n+    if C.shape[0] > 1:\n+        assert C[1, 0] == B[0, 0]\n     I = Identity(3)\n     Z = ZeroMatrix(3, 3)\n     B = BlockMatrix([[I, I], [I, I]])\n",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..a8fcd99 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -317,7 +317,20 @@ def test_sign():\n     assert sign(d).func is sign or sign(d) == 0\n \n \n-def test_as_real_imag():\n+def test_rewrite_sign_as_abs():\n+    from sympy import sign, Abs, Piecewise, Symbol, Eq\n+    x = Symbol('x')\n+    y = Symbol('y')\n+    \n+    # Test the rewriting of sign in terms of Abs\n+    assert sign(x).rewrite(Abs) == Piecewise((0, Eq(x, 0)), (x / Abs(x), True))\n+    assert sign(y).rewrite(Abs) == Piecewise((0, Eq(y, 0)), (y / Abs(y), True))\n+    assert sign(0).rewrite(Abs) == 0\n+    assert sign(1).rewrite(Abs) == 1\n+    assert sign(-1).rewrite(Abs) == -1\n+\n+    f = Symbol('f', real=True)\n+    assert sign(f*y).rewrite(Abs) == Piecewise((0, Eq(f*y, 0)), (f*y / Abs(f*y), True))\n     n = pi**1000\n     # the special code for working out the real\n     # and complex parts of a power with Integer exponent\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..cf6e376 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -472,6 +472,23 @@ def test_multiset_permutations():\n \n \n def test_partitions():\n+    def get_deep_copy_partitions(*args, **kwargs):\n+        return [p.copy() for p in partitions(*args, **kwargs)]\n+\n+    # Test that each partition is distinct\n+    part1 = get_deep_copy_partitions(5)\n+    part2 = get_deep_copy_partitions(5)\n+    for p1, p2 in zip(part1, part2):\n+        assert p1 == p2\n+        assert p1 is not p2\n+\n+    # Explicitly test non-mutation by modifying first set and checking second\n+    part1 = get_deep_copy_partitions(4)\n+    part2 = get_deep_copy_partitions(4)\n+    # Modify the first partition set\n+    part1[0][1] = 100\n+    for p2 in part2:\n+        assert 1 not in p2 or p2[1] != 100  # Ensure second set is not affected\n     ans = [[{}], [(0, {})]]\n     for i in range(2):\n         assert list(partitions(0, size=i)) == ans[i]\n",
  "sympy__sympy-20212": "diff --git a/sympy/core/tests/test_power.py b/sympy/core/tests/test_power.py\nindex 686973b..8d8f4aa 100644\n--- a/sympy/core/tests/test_power.py\n+++ b/sympy/core/tests/test_power.py\n@@ -254,7 +254,14 @@ def test_power_rewrite_exp():\n                     (sin, cos, tan, sec, csc, sinh, cosh, tanh))\n \n \n+from sympy import S, oo, zoo\n+\n def test_zero():\n+    # Test for issue regarding 0**-oo\n+    # `0**-oo` should yield `zoo` as per the documentation\n+    assert (S.Zero**-S.Infinity) == S.ComplexInfinity\n+    # Using the `power` function directly\n+    assert Pow(S.Zero, -oo) == zoo\n     x = Symbol('x')\n     y = Symbol('y')\n     assert 0**x != 0\n",
  "sympy__sympy-20442": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 6a8906d..13e277e 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (Abs, Add, Function, Number, Rational, S, Symbol,\n                    diff, exp, integrate, log, sin, sqrt, symbols)\n from sympy.physics.units import (amount_of_substance, convert_to, find_unit,\n@@ -46,7 +47,46 @@ def test_convert_to():\n     assert speed_of_light.convert_to(m) == speed_of_light\n \n \n-def test_Quantity_definition():\n+def test_issue_convert_to_orthogonal_units():\n+    from sympy.physics.units import joule\n+    # This is the original test case provided\n+    expr = joule * second\n+    conv = convert_to(expr, joule)\n+    assert conv == expr\n+\n+    # Additional test cases\n+    # Converting to base units\n+    expr = joule * second\n+    conv = convert_to(expr, kg * m**2 / s)\n+    assert conv == expr\n+\n+    # Converting to an unrelated unit\n+    expr = joule * second\n+    conv = convert_to(expr, minute)\n+    assert conv == joule * minute / 60\n+\n+    # Convert when target_units can't express the original units\n+    expr = joule * second\n+    conv = convert_to(expr, volume)\n+    assert conv == expr\n+\n+    # Test the correct behavior when converting to same unit\n+    expr = joule * second\n+    conv = convert_to(expr, joule * second)\n+    assert conv == expr\n+\n+    # More tests to ensure the function's behavior is consistent\n+    expr = 3 * joule * second\n+    conv = convert_to(expr, joule)\n+    assert conv == 3 * expr\n+\n+    expr = 5 * joule * minute\n+    conv = convert_to(expr, joule)\n+    assert conv == 5 * joule * minute\n+\n+    expr = 2 * joule * second\n+    conv = convert_to(expr, kilogram * meter**2 / second)\n+    assert conv == 2 * kilogram * meter**2 / second\n     q = Quantity(\"s10\", abbrev=\"sabbr\")\n     q.set_global_relative_scale_factor(10, second)\n     u = Quantity(\"u\", abbrev=\"dam\")\n",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..a3b40b9 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -28,6 +28,21 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+import sympy\n+from sympy import Symbol\n+from pytest import raises\n+\n+def test_symbol_no_dict_in_previous_versions():\n+    # This is to verify the behavior prior to version 1.7\n+    s = Symbol('s')\n+    assert not hasattr(s, '__dict__'), \"Symbol instance unexpectedly has a __dict__\"\n+\n+def test_symbol_dict_in_current_versions():\n+    # This is to verify the behavior since version 1.7\n+    s = Symbol('s')\n+    if hasattr(s, '__dict__'):\n+        assert s.__dict__ == {}, \"__dict__ should be an empty dictionary for Symbol\"\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..cd58f2b 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,5 +1,6 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n-                   atan, atan2, nan, Symbol, re, im, sign)\n+                   atan, atan2, nan, Symbol, re, im, sign, arg)\n from sympy.abc import w, x, y, z\n from sympy.core.relational import Eq, Ne\n from sympy.functions.elementary.piecewise import Piecewise\n",
  "sympy__sympy-21379": "",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..7c5fa2e 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n@@ -34,7 +35,10 @@ def test_Symbol_kind():\n     assert comm_x.kind is NumberKind\n     assert noncomm_x.kind is UndefinedKind\n \n-def test_Integral_kind():\n+def test_Derivative_kind():\n+    A = MatrixSymbol('A', 2, 2)\n+    assert Derivative(comm_x, comm_x).kind is NumberKind\n+    assert Derivative(A, comm_x).kind is MatrixKind(NumberKind)\n     A = MatrixSymbol('A', 2,2)\n     assert Integral(comm_x, comm_x).kind is NumberKind\n     assert Integral(A, comm_x).kind is MatrixKind(NumberKind)\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..1bebd2a 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -111,6 +111,22 @@ def test_monomials():\n     assert set(itermonomials([x], [2])) == {S.One, x, x**2}\n     assert set(itermonomials([x], [3])) == {S.One, x, x**2, x**3}\n \n+    # New test cases for min_degrees and max_degrees issue\n+    from sympy import symbols\n+    from sympy.polys.monomials import itermonomials\n+\n+    x, y, z = symbols('x y z')\n+\n+    # Test case to check that monomials of total degree 3 are returned correctly\n+    assert set(itermonomials([x, y, z], 3, 3)) == {x**3, x**2*y, x**2*z, x*y**2, x*y*z, x*z**2, y**3, y**2*z, y*z**2, z**3, y**2*x, z**2*x, z**2*y}\n+\n+    # Test case with differing max and min degrees\n+    assert set(itermonomials([x, y], 3, 2)) == {x**2, x*y, y**2, x**3, x**2*y, x*y**2, y**3, y**2*x, x**2*y, x*y, y*x, y**2}\n+\n+    # Test case with min_degrees less than max_degrees\n+    assert set(itermonomials([i, j, k], 2, 2)) == {k*i, i**2, i*j, j*k, j*i, k**2, j**2, k*j, i*k}\n+    assert set(itermonomials([i, j, k], 3, 2)) == {j*k**2, i*k**2, k*i*j, k*i**2, k**2, j*k*j, i*k*i, j*i*k, j**3, i**3, i**2*j, i*j**2, k*j*i, k*j**2, j*i, j*k*i, j*i**2, k**2*i, i*j*k, j*k}\n+\n     assert set(itermonomials([x], [3], [1])) == {x, x**3, x**2}\n     assert set(itermonomials([x], [3], [2])) == {x**3, x**2}\n \n",
  "sympy__sympy-22005": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 341f63c..8b2242e 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n@@ -49,6 +50,16 @@ def test_solve_poly_system():\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\n     raises(PolynomialError, lambda: solve_poly_system([1/x], x))\n \n+def test_infinite_solution_detection():\n+    from sympy import Poly\n+\n+    # Both cases should raise NotImplementedError as they represent infinite solutions\n+    raises(NotImplementedError, lambda: solve_poly_system((x - 1,), x, y))\n+    raises(NotImplementedError, lambda: solve_poly_system((y - 1,), x, y))\n+\n+    # Adding additional checks with Poly objects\n+    raises(NotImplementedError, lambda: solve_poly_system(Poly(x - 1, x, y), (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system(Poly(y - 1, x, y), (x, y)))\n \n def test_solve_biquadratic():\n     x0, y0, x1, y1, r = symbols('x0 y0 x1 y1 r')\n",
  "sympy__sympy-22714": "",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..15267df 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -346,8 +346,37 @@ def test_cse_MatrixSymbol():\n     n = symbols('n', integer=True)\n     B = MatrixSymbol(\"B\", n, n)\n     assert cse(B) == ([], [B])\n-\n-def test_cse_MatrixExpr():\n+def test_cse_MatrixSymbol_indexing_issue():\n+    import sympy as sp\n+    from sympy import MatrixSymbol, symbols, cse\n+    from sympy.utilities.pytest import raises\n+\n+    def sub_in_matrixsymbols(exp, matrices):\n+        for matrix in matrices:\n+            for i in range(matrix.shape[0]):\n+                for j in range(matrix.shape[1]):\n+                    name = \"%s_%d_%d\" % (matrix.name, i, j)\n+                    sym = sp.symbols(name)\n+                    exp = exp.subs(sym, matrix[i, j])\n+        return exp\n+\n+    def t44(name):\n+        return sp.Matrix(4, 4, lambda i, j: sp.symbols('%s_%d_%d' % (name, i, j)))\n+\n+    a = t44(\"a\")\n+    b = t44(\"b\")\n+    e = a * b\n+    e2 = sub_in_matrixsymbols(e, [MatrixSymbol(\"a\", 4, 4), MatrixSymbol(\"b\", 4, 4)])\n+\n+    cse_subs, cse_reduced = cse(e2)\n+\n+    # The test asserts that x0 and x2 should not be simple copies of a and b respectively\n+    # This checks if the cse is using matrix's elements instead of whole matrix\n+    for sym, expr in cse_subs:\n+        if sym.name == 'x0':\n+            assert not (expr == MatrixSymbol(\"a\", 4, 4))\n+        if sym.name == 'x2':\n+            assert not (expr == MatrixSymbol(\"b\", 4, 4))\n     A = MatrixSymbol('A', 3, 3)\n     y = MatrixSymbol('y', 3, 1)\n \n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..1525f5f 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -9,6 +10,8 @@ from sympy.tensor.array.sparse_ndim_array import (\n     ImmutableSparseNDimArray, MutableSparseNDimArray)\n \n from sympy.abc import x, y\n+from sympy.testing.pytest import raises\n+from sympy.tensor.array import Array\n \n array_types = [\n     ImmutableDenseNDimArray,\n@@ -37,8 +40,12 @@ def test_array_negative_indices():\n \n         assert test_array[-1, -1] == 10\n \n-\n-def test_issue_18361():\n+def test_issue_sympy_array_empty():\n+    for ArrayType in array_types:\n+        A = ArrayType([])\n+        assert isinstance(A, ArrayType)\n+        assert A.shape == (0,)\n+        assert list(A) == []\n     A = Array([sin(2 * x) - 2 * sin(x) * cos(x)])\n     B = Array([sin(x)**2 + cos(x)**2, 0])\n     C = Array([(x + x**2)/(x*sin(y)**2 + x*cos(y)**2), 2*sin(x)*cos(x)])\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..d26cddb 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,6 +1175,28 @@ def test_scipy_polys():\n \n \n \n+def test_tuple_with_one_element():\n+    # Test that a tuple with one element is correctly generated as (1,)\n+    f2b = lambdify([], (1,))  # As per issue gh-23224\n+    assert f2b() == (1,)\n+    \n+    # Inspect the generated source to ensure it is correct\n+    source = inspect.getsource(f2b)\n+    assert 'return (1,)' in source\n+\n+def test_tuple_with_two_elements():\n+    # Test that a tuple with two elements is correctly generated\n+    f2c = lambdify([], (1, 2))\n+    assert f2c() == (1, 2)\n+    \n+    # Inspect the generated source to ensure it is correct\n+    source = inspect.getsource(f2c)\n+    assert 'return (1, 2)' in source\n+\n+import inspect\n+from sympy import lambdify\n+from sympy.core import Dummy\n+\n def test_lambdify_inspect():\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n",
  "sympy__sympy-24066": "",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..5e8658c 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -52,8 +52,33 @@ def test_tensor_product_commutator():\n     assert Comm(TP(A, B), TP(B, C)).doit() == \\\n         TP(A, B)*TP(B, C) - TP(B, C)*TP(A, B)\n \n-\n-def test_tensor_product_simp():\n+def test_issue_24142_expansion():\n+    # Tests for fix of incomplete expansion in TensorProduct (as described in issue #24142)\n+\n+    U = Operator('U')\n+    V = Operator('V')\n+    \n+    # Original issue example\n+    P = TP(2*U - V, U + V)\n+    expanded_P = P.expand(tensorproduct=True)\n+    assert expanded_P == (2*TP(U, U) + 2*TP(U, V) - TP(V, U) - TP(V, V))\n+\n+    # Additional test cases to check different scalar factors\n+    assert TP(U, V + 3*U).expand(tensorproduct=True) == TP(U, V) + 3*TP(U, U)\n+    assert TP(3*U + V, 2*U - V).expand(tensorproduct=True) == 6*TP(U, U) - 3*TP(U, V) + 2*TP(V, U) - TP(V, V)\n+    \n+    # Check if expansion works with zero factor\n+    assert TP(U-U, U+V).expand(tensorproduct=True) == TP(0, U+V)\n+\n+    # Complex scalar factors\n+    assert TP(1.5*U + 2.5*V, U).expand(tensorproduct=True) == 1.5*TP(U, U) + 2.5*TP(V, U)\n+\n+    # Verify multiple expansions\n+    assert TP(2*U + 3*V, 4*U + 5*V).expand(tensorproduct=True) == 8*TP(U, U) + 10*TP(U, V) + 12*TP(V, U) + 15*TP(V, V)\n+\n+# Include original assertions from the initial test patch\n+def test_tensor_product_abstract():\n+    ...\n     assert tensor_product_simp(TP(A, B)*TP(B, C)) == TP(A*B, B*C)\n     # tests for Pow-expressions\n     assert tensor_product_simp(TP(A, B)**x) == TP(A**x, B**x)\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..48ac3f0 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -562,6 +563,55 @@ def test_issue_24062():\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n \n+def test_issue_24211():\n+    from sympy.physics.units import time, velocity, acceleration, second, meter, Quantity\n+    from sympy.physics.units.systems.si import SI\n+\n+    # Original test patch\n+    V1 = Quantity('V1')\n+    SI.set_quantity_dimension(V1, velocity)\n+    SI.set_quantity_scale_factor(V1, 1 * meter / second)\n+\n+    A1 = Quantity('A1')\n+    SI.set_quantity_dimension(A1, acceleration)\n+    SI.set_quantity_scale_factor(A1, 1 * meter / second**2)\n+\n+    T1 = Quantity('T1')\n+    SI.set_quantity_dimension(T1, time)\n+    SI.set_quantity_scale_factor(T1, 1 * second)\n+\n+    expr = A1*T1 + V1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr)\n+\n+    # Additional test cases to ensure the fix works in more scenarios\n+\n+    # Test with different scale factors\n+    A2 = Quantity('A2')\n+    SI.set_quantity_dimension(A2, acceleration)\n+    SI.set_quantity_scale_factor(A2, 9.8 * meter / second**2)\n+\n+    T2 = Quantity('T2')\n+    SI.set_quantity_dimension(T2, time)\n+    SI.set_quantity_scale_factor(T2, 2 * second)\n+\n+    expr2 = A2*T2 + V1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr2)\n+\n+    # Test with negative scale factor\n+    A3 = Quantity('A3')\n+    SI.set_quantity_dimension(A3, acceleration)\n+    SI.set_quantity_scale_factor(A3, -9.8 * meter / second**2)\n+\n+    T3 = Quantity('T3')\n+    SI.set_quantity_dimension(T3, time)\n+    SI.set_quantity_scale_factor(T3, 3 * second)\n+\n+    expr3 = A3*T3 + V1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr3)\n+\n def test_prefixed_property():\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..511ff85 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,9 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, milli, kilo, volt\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n@@ -23,6 +24,12 @@ def test_prefix_operations():\n     assert k / m == M\n \n     assert dodeca * dodeca == 144\n+\n+    # New test cases for verifying the milli prefix issue\n+    assert milli * W == W / 1000  # Expected to resolve to milli watt or mW\n+    assert W * milli == W / 1000  # Should be same as milli * W\n+    assert milli * kilo == 1 / 1000  # milli times kilo should resolve to 1/1000\n+    assert milli * volt == volt / 1000  # milli * volt should resolve to mV\n     assert 1 / dodeca == S.One / 12\n     assert k / dodeca == S(1000) / 12\n     assert dodeca / dodeca == 1\n",
  "django__django-12470": "diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py\nindex 067de1c..85296e1 100644\n--- a/tests/model_inheritance/tests.py\n+++ b/tests/model_inheritance/tests.py\n@@ -11,8 +11,25 @@ from .models import (\n     Supplier, Title, Worker,\n )\n \n+from .models import Parent, Child\n \n class ModelInheritanceTests(TestCase):\n+    def test_inherited_ordering_pk_desc(self):\n+        # Create instances of the Child model\n+        c1 = Child.objects.create(first_name='Alice', email='alice@email.com')\n+        c2 = Child.objects.create(first_name='Bob', email='bob@email.com')\n+        \n+        # Query all Child instances and verify the order is by '-pk'\n+        expected_order = [c2, c1]\n+        qs = Child.objects.all()\n+        self.assertSequenceEqual(qs, expected_order)\n+        \n+        # Check the SQL query to ensure it's ordering by DESC\n+        expected_order_by_sql = 'ORDER BY %s.%s DESC' % (\n+            connection.ops.quote_name(Parent._meta.db_table),\n+            connection.ops.quote_name(Parent._meta.pk.column),\n+        )\n+        self.assertIn(expected_order_by_sql, str(qs.query))\n     def test_abstract(self):\n         # The Student and Worker models both have 'name' and 'age' fields on\n         # them and inherit the __str__() method, just as with normal Python\n",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..353eb6e 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -342,8 +342,39 @@ class OrderingTests(TestCase):\n             ],\n             attrgetter(\"headline\")\n         )\n+    def test_order_by_self_referential_fk(self):\n+        # Create instances of OneModel for testing\n+        root_instance = OneModel.objects.create(oneval=1)\n+        self_ref_instance_1 = OneModel.objects.create(root=root_instance, oneval=2)\n+        self_ref_instance_2 = OneModel.objects.create(root=root_instance, oneval=3)\n+\n+        # Create instances of TwoModel that reference OneModel instances\n+        two_model_instance_1 = TwoModel.objects.create(record=self_ref_instance_1, twoval=100)\n+        two_model_instance_2 = TwoModel.objects.create(record=self_ref_instance_2, twoval=200)\n+\n+        # Assert the query results with problematic ordering\n+        result_qs_1 = TwoModel.objects.filter(record__oneval__in=[2, 3]).order_by(\"record__root_id\")\n+        self.assertSequenceEqual(\n+            list(result_qs_1),\n+            [two_model_instance_1, two_model_instance_2],\n+            \"Ordering by record__root_id should have been ascendant since the issue was fixed.\"\n+        )\n \n-    def test_order_by_f_expression(self):\n+        # Assert the query results with inverse ordering\n+        result_qs_2 = TwoModel.objects.filter(record__oneval__in=[2, 3]).order_by(\"-record__root_id\")\n+        self.assertSequenceEqual(\n+            list(result_qs_2),\n+            [two_model_instance_2, two_model_instance_1],\n+            \"Ordering by -record__root_id should have been descendant correctly.\"\n+        )\n+\n+        # Check query with annotation workaround\n+        result_qs_3 = TwoModel.objects.filter(record__oneval__in=[2, 3]).annotate(root_id=F('record__root_id')).order_by('root_id')\n+        self.assertSequenceEqual(\n+            list(result_qs_3),\n+            [two_model_instance_1, two_model_instance_2],\n+            \"Annotated ordering should match the expected ascendant order.\"\n+        )\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n                 \"Article 1\",\n",
  "django__django-13265": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..ce2d09a 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3201,8 +3201,49 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         form = SomeForm()\n         self.assertEqual(form['field'].id_for_label, 'myCustomID')\n         self.assertEqual(form['field_none'].id_for_label, 'id_field_none')\n+    def test_boundfield_subwidget_id_for_label(self):\n+        \"\"\"\n+        If auto_id is provided when initializing the form, the generated ID in\n+        subwidgets must reflect that prefix.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple,\n+            )\n+\n+        form = SomeForm(auto_id='prefix_%s')\n+        subwidgets = form['field'].subwidgets\n+        self.assertEqual(subwidgets[0].id_for_label, 'prefix_field_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'prefix_field_1')\n \n-    def test_boundfield_widget_type(self):\n+    def test_boundwidget_id_for_label_uses_attrs_id(self):\n+        \"\"\"\n+        Verify that the id_for_label method uses the id from the widget's attrs\n+        if it's available, as expected.\n+        \"\"\"\n+        widget_data = {\n+            'name': 'field',\n+            'index': 1,\n+            'attrs': {'id': 'custom_id'},\n+            'label': 'Label'\n+        }\n+        widget = BoundWidget(None, widget_data, None)\n+        self.assertEqual(widget.id_for_label, 'custom_id')\n+\n+    def test_boundwidget_id_for_label_default_behavior(self):\n+        \"\"\"\n+        Verify that the id_for_label method falls back to default behavior when\n+        no id is present in attrs.\n+        \"\"\"\n+        widget_data = {\n+            'name': 'field',\n+            'index': 1,\n+            'attrs': {},\n+            'label': 'Label'\n+        }\n+        widget = BoundWidget(None, widget_data, None)\n+        self.assertEqual(widget.id_for_label, 'id_field_1')\n         class SomeForm(Form):\n             first_name = CharField()\n             birthday = SplitDateTimeField(widget=SplitHiddenDateTimeWidget)\n",
  "django__django-16400": "diff --git a/tests/auth_tests/test_management.py b/tests/auth_tests/test_management.py\nindex de2502e..f0b2ead 100644\n--- a/tests/auth_tests/test_management.py\n+++ b/tests/auth_tests/test_management.py\n@@ -1476,12 +1476,38 @@ class CreatePermissionsTests(TestCase):\n         A proxy model's permissions use its own content type rather than the\n         content type of the concrete model.\n         \"\"\"\n-        opts = UserProxy._meta\n-        codename = get_permission_codename(\"add\", opts)\n-        self.assertTrue(\n-            Permission.objects.filter(\n-                content_type__model=opts.model_name,\n-                content_type__app_label=opts.app_label,\n-                codename=codename,\n-            ).exists()\n-        )\n+from django.db import connections\n+from django.test import override_settings\n+from django.core.management import call_command\n+from io import StringIO\n+from django.contrib.auth.models import Permission\n+from django.apps import apps\n+import sys\n+\n+@override_settings(DATABASE_ROUTERS=[DefaultDBRouter()])\n+class CreatePermissionsDatabaseRespectTests(TestCase):\n+    databases = {\"default\", \"other\"}\n+\n+    def test_migrate_command_respects_database_parameter(self):\n+        # Run migrations on 'other' database\n+        out = StringIO()\n+        call_command('migrate', database='other', stdout=out)\n+        \n+        # Check if permissions are created in 'other' database\n+        other_count = Permission.objects.using('other').count()\n+        default_count = Permission.objects.using('default').count()\n+        \n+        self.assertGreater(other_count, 0, \"Permissions should be created in the 'other' database.\")\n+        self.assertEqual(default_count, 0, \"Permissions should not be created in the 'default' database.\")\n+\n+        # Ensure the output does not indicate any cross-database actions\n+        out.seek(0)\n+        output = out.read()\n+        self.assertNotIn(\"default\", output, \"Migrate output should not mention 'default' database operations.\")\n+\n+    def test_no_permissions_in_default_by_default(self):\n+        # Ensure 'default' database is clean\n+        Permission.objects.using('default').delete()\n+        \n+        # Check that there's nothing left in default database\n+        self.assertEqual(Permission.objects.using('default').count(), 0)\n",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..d82b391 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -657,8 +657,32 @@ def test_colorbar_scale_reset():\n \n     assert cbar.outline.get_edgecolor() == mcolors.to_rgba('red')\n \n+def test_colorbar_update_norm():\n+    import matplotlib.pyplot as plt\n+    from matplotlib.colors import LogNorm, Normalize\n+    import numpy as np\n+\n+    # Create data and plot it with a colorbar\n+    img = 10**np.random.normal(1, 1, size=(50, 50))\n+    fig, ax = plt.subplots(1, 1)\n+    plot = ax.imshow(img, cmap='gray')\n+    cb = fig.colorbar(plot, ax=ax)\n+\n+    # Change the norm to LogNorm, which should affect the colorbar\n+    plot.set_norm(LogNorm())\n+    cb.update_normal(plot)\n+    fig.canvas.draw()\n+\n+    # Check that the colorbar ticks have updated to reflect the LogNorm\n+    assert cb.ax.yaxis.get_scale() == 'log'\n+\n+    # Change the norm back to Normalize, which should also affect the colorbar\n+    plot.set_norm(Normalize())\n+    cb.update_normal(plot)\n+    fig.canvas.draw()\n \n-def test_colorbar_get_ticks_2():\n+    # Check that the colorbar ticks have updated to reflect the Normalize\n+    assert cb.ax.yaxis.get_scale() == 'linear'\n     plt.rcParams['_internal.classic_mode'] = False\n     fig, ax = plt.subplots()\n     pc = ax.pcolormesh([[.05, .95]])\n",
  "pydata__xarray-4094": "",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..252ec81 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -259,4 +259,43 @@ def test_set_output_mro():\n     class C(A, B):\n         pass\n \n-    assert C().transform(None) == \"B\"\n+    assert C().transform(None) == \"B\"\n+\n+@pytest.mark.parametrize(\"set_output\", [\"default\", \"pandas\"])\n+def test_feature_union_with_custom_transformer(set_output):\n+    \"\"\"Test FeatureUnion with a custom transformer and pandas output.\n+\n+    This test ensures that using a custom transformer in a FeatureUnion\n+    does not raise an error when 'pandas' output is selected.\n+    \"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+    from sklearn.pipeline import FeatureUnion\n+    from sklearn.base import BaseEstimator, TransformerMixin\n+    from sklearn.utils._set_output import _safe_set_output\n+\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+\n+    class MyTransformer(BaseEstimator, TransformerMixin):\n+        def fit(self, X: pd.DataFrame, y: pd.Series | None = None, **kwargs):\n+            return self\n+\n+        def transform(self, X: pd.DataFrame, y: pd.Series | None = None) -> pd.DataFrame:\n+            return X[\"value\"].groupby(X[\"date\"]).sum().to_frame()\n+\n+        def get_feature_names_out(self, input_features=None):\n+            return pd.Index([\"value_sum\"])\n+\n+    # Create and test FeatureUnion\n+    union = FeatureUnion([\n+        (\"custom\", MyTransformer())\n+    ])\n+    _safe_set_output(union, transform=set_output)\n+    result = union.fit_transform(data)\n+\n+    assert isinstance(result, (np.ndarray, pd.DataFrame))\n+    if set_output == \"pandas\":\n+        assert isinstance(result, pd.DataFrame)\n+        assert list(result.columns) == [\"custom__value_sum\"]\n+        assert len(result) == len(data[\"date\"].unique())\n",
  "sphinx-doc__sphinx-8801": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 37d6e17..83db7ed 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -106,6 +106,40 @@ def test_inherited_instance_variable(app):\n     ]\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_superclass_attribute(app):\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n+import sys\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+from test_ext_autodoc import do_autodoc\n+\n def test_decorators(app):\n     actual = do_autodoc(app, 'class', 'target.decorator.Baz')\n     assert list(actual) == [\n@@ -115,6 +149,35 @@ def test_decorators(app):\n         '',\n     ]\n \n+\n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_superclass_attribute(app):\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n     actual = do_autodoc(app, 'class', 'target.decorator.Qux')\n     assert list(actual) == [\n         '',\n@@ -132,6 +195,35 @@ def test_decorators(app):\n     ]\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_superclass_attribute(app):\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n def test_slots_attribute(app):\n     options = {\"members\": None}\n",
  "sympy__sympy-15346": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex cce4836..661d514 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     symbols, sin, simplify, cos, trigsimp, rad, tan, exptrigsimp,sinh,\n     cosh, diff, cot, Subs, exp, tanh, exp, S, integrate, I,Matrix,\n@@ -357,8 +358,32 @@ def test_issue_2827_trigsimp_methods():\n     eq = 1/sqrt(E) + E\n     assert exptrigsimp(eq) == eq\n \n-\n-def test_exptrigsimp():\n+def test_issue_15129_trigsimp_methods():\n+    t1 = Matrix([sin(Rational(1, 50)), cos(Rational(1, 50)), 0])\n+    t2 = Matrix([sin(Rational(1, 25)), cos(Rational(1, 25)), 0])\n+    t3 = Matrix([cos(Rational(1, 25)), sin(Rational(1, 25)), 0])\n+    r1 = t1.dot(t2)\n+    r2 = t1.dot(t3)\n+    assert trigsimp(r1) == cos(S(1)/50)\n+    assert trigsimp(r2) == sin(S(3)/50)\n+\n+def test_trigsimp_rational():\n+    # Test simplification of sin(x)*sin(y) + cos(x)*cos(y) = cos(x - y)\n+    x, y = symbols('x y', real=True)\n+    expr = sin(x)*sin(y) + cos(x)*cos(y)\n+    assert simplify(expr) == cos(x - y)\n+\n+    # Test rational simplification\n+    r = Rational(1, 50) - Rational(1, 25)\n+    assert simplify(r) == -Rational(1, 50)\n+    \n+    # New test with rational angle trigonometric simplification\n+    r = sin(Rational(1, 50))*sin(Rational(1, 25)) + cos(Rational(1, 50))*cos(Rational(1, 25))\n+    assert trigsimp(r) == cos(S(1)/50 - S(1)/25)\n+\n+    # New test for acos of the simplified expression\n+    acos_expr = acos(r)\n+    assert simplify(acos_expr) == acos(cos(S(1)/50 - S(1)/25))\n     def valid(a, b):\n         from sympy.utilities.randtest import verify_numerically as tn\n         if not (tn(a, b) and a == b):\n",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..21ab4ad 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4862,8 +4862,23 @@ k = \u2500\u2500\u2500\u2500\u2500                                \\n\\\n     assert pretty(expr) == ascii_str\n     assert upretty(expr) == ucode_str\n \n-\n-def test_units():\n+def test_sum_pretty_print_alignment():\n+    from sympy import Sum, pprint\n+    from sympy.abc import x\n+    \n+    expr = Sum(x, (x, 1, oo)) + 3\n+    ucode_str_corrected = \\\n+    u(\"\"\"\\\n+  \u221e     \\n\\\n+ ___    \\n\\\n+ \u2572      \\n\\\n+  \u2572   x \\n\\\n+  \u2571     \\n\\\n+ \u2571   + 3\\n\\\n+ \u203e\u203e\u203e    \\n\\\n+x = 1   \\\n+\"\"\")\n+    assert upretty(expr) == ucode_str_corrected\n     expr = joule\n     ascii_str1 = \\\n \"\"\"\\\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex b2b6202..a46f63d 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -704,6 +704,18 @@ def test_uniq():\n     assert list(uniq([2, 3, 2, 4, [2], [1], [2], [3], [1]])) == \\\n         [2, 3, 4, [2], [1], [3]]\n \n+    # Testing that modifying a list during iteration with uniq raises RuntimeError\n+    f = [1]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    f = [[1]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+\n+    # Additional test cases for checking the correct behavior after the fix\n+    assert list(uniq([])) == []\n+    assert list(uniq([1, 1, 1, 1])) == [1]\n+    assert list(uniq(['a', 'b', 'a', 'c', 'b'])) == ['a', 'b', 'c']\n+    assert list(uniq([[1, 2], [1, 2], [2, 1]])) == [[1, 2], [2, 1]]\n+\n \n def test_kbins():\n     assert len(list(kbins('1123', 2, ordered=1))) == 24\n",
  "django__django-11797": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 7beeac3..200d6e4 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -1,3 +1,4 @@\n+\n import collections.abc\n from datetime import datetime\n from math import ceil\n@@ -6,6 +7,7 @@ from operator import attrgetter\n from django.core.exceptions import FieldError\n from django.db import connection\n from django.db.models.expressions import Exists, OuterRef\n+from django.db.models import Max\n from django.db.models.functions import Substr\n from django.test import TestCase, skipUnlessDBFeature\n \n",
  "django__django-15320": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 35f7f03..6da0e1b 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -546,6 +546,35 @@ class BasicExpressionsTests(TestCase):\n         subquery_test2 = Company.objects.filter(pk=Subquery(small_companies.filter(num_employees=3)))\n         self.assertCountEqual(subquery_test2, [self.foobar_ltd])\n \n+    def test_subquery_initial_state(self):\n+        # Testing the initial state of Subquery without setting subquery explicitly\n+        small_companies = Company.objects.filter(num_employees__lt=200).values('pk')\n+        subquery = Subquery(small_companies)\n+        \n+        # Verify that the subquery attribute is not True by default\n+        self.assertIs(subquery.query.subquery, False)\n+        \n+        compiler = subquery.query.get_compiler(connection=connection)\n+        sql, _ = subquery.as_sql(compiler, connection)\n+        \n+        # Validate the SQL structure is not what we expect (exhibits the issue)\n+        self.assertNotIn('(SELECT ', sql)\n+\n+    def test_subquery_with_explicit_setting(self):\n+        # Testing the subquery behavior with the subquery attribute explicitly set to True\n+        small_companies = Company.objects.filter(num_employees__lt=200).values('pk')\n+        subquery = Subquery(small_companies)\n+        subquery.query.subquery = True\n+        \n+        # Verify that setting the subquery attribute works\n+        self.assertIs(subquery.query.subquery, True)\n+        \n+        compiler = subquery.query.get_compiler(connection=connection)\n+        sql, _ = subquery.as_sql(compiler, connection)\n+        \n+        # Validate the SQL structure is as expected\n+        self.assertIn('(SELECT ', sql)\n+\n     def test_uuid_pk_subquery(self):\n         u = UUIDPK.objects.create()\n         UUID.objects.create(uuid_fk=u)\n",
  "django__django-15819": "",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..94dec73 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -152,6 +153,33 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n+    def test_wrong_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(PoolStyle.objects.annotate(\n+                tournament_pool=FilteredRelation('pool__tournament__pool'),\n+            ).select_related('tournament_pool', 'tournament_pool__tournament'))\n+            self.assertEqual(p[0].pool.tournament, p[0].tournament_pool.tournament)\n+\n+    def test_multilevel_reverse_fk_cyclic_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation(\"pool__tournament__pool\"),\n+                ).select_related(\"tournament_pool\", \"tournament_pool__tournament\")\n+            )\n+            self.assertEqual(p[0].tournament_pool.tournament, p[0].pool.tournament)\n+\n+    def test_multilevel_reverse_fk_select_related(self):\n+        with self.assertNumQueries(2):\n+            p = list(\n+                Tournament.objects.filter(id=self.t2.id)\n+                .annotate(\n+                    style=FilteredRelation(\"pool__another_style\"),\n+                )\n+                .select_related(\"style\")\n+            )\n+            self.assertEqual(p[0].style.another_pool, self.p3)\n+\n     def test_reverse_fk_select_related_multiple(self):\n         with self.assertNumQueries(1):\n             ps = list(\n@@ -163,4 +191,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex ad1a5e1..1b6e17f 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from datetime import datetime\n import io\n@@ -14,7 +15,8 @@ from PIL import Image\n import matplotlib as mpl\n from matplotlib import gridspec, rcParams\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n-from matplotlib.axes import Axes\n+from matplotlib import pyplot as plt\n+import pickle\n from matplotlib.figure import Figure, FigureBase\n from matplotlib.layout_engine import (ConstrainedLayoutEngine,\n                                       TightLayoutEngine)\n",
  "mwaskom__seaborn-2848": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 5a5e126..b8558cc 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -1,3 +1,4 @@\n+\n from itertools import product\n import numpy as np\n import matplotlib as mpl\n@@ -10,6 +11,8 @@ from numpy.testing import assert_array_equal\n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n \n+import pytest\n+import seaborn as sns\n from seaborn.relational import (\n     _RelationalPlotter,\n     _LinePlotter,\n@@ -1623,7 +1626,17 @@ class TestScatterPlotter(SharedAxesLevelTests, Helpers):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n-    def test_linewidths(self, long_df):\n+    def test_pairgrid_map_with_hue(self):\n+        # Test to verify that using the `hue` parameter in the `map` method works correctly.\n+        iris = sns.load_dataset(\"iris\")\n+        g = sns.PairGrid(iris, y_vars=[\"sepal_length\", \"sepal_width\"], x_vars=[\"petal_length\", \"petal_width\"])\n+        \n+        # This should work without raising errors.\n+        try:\n+            g.map(sns.scatterplot, hue=iris[\"species\"])\n+            g.map(sns.regplot, scatter=False)  # Ensure regplot can still be used without scatter.\n+        except Exception as e:\n+            pytest.fail(f\"PairGrid map with hue raised an unexpected exception: {e}\")\n \n         f, ax = plt.subplots()\n \n",
  "pytest-dev__pytest-5413": "",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..c5b5d8e 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -404,6 +404,11 @@ class TestCustomConftests:\n         testdir.makepyfile(\"def test_x(): pass\")\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+        \n+        # New test for shortcut\n+        result_shortcut = testdir.runpytest(\"-c\")\n+        result_shortcut.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n \n     def test_pytest_collect_file_from_sister_dir(self, testdir):\n         sub1 = testdir.mkpydir(\"sub1\")\n@@ -434,6 +439,11 @@ class TestCustomConftests:\n         p.copy(sub1.join(p.basename))\n         p.copy(sub2.join(p.basename))\n         result = testdir.runpytest(\"--collect-only\")\n+        result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+        \n+        # New test for shortcut\n+        result_shortcut = testdir.runpytest(\"-c\")\n+        result_shortcut.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n         result.stdout.fnmatch_lines([\"*MyModule1*\", \"*MyModule2*\", \"*test_x*\"])\n \n \n",
  "sphinx-doc__sphinx-10451": "",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..22e4d56 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -83,8 +83,11 @@ def test_Identity():\n     assert transpose(In) == In\n     assert In.inverse() == In\n     assert In.conjugate() == In\n-\n-def test_Identity_doit():\n+def test_Identity_sum_elements():\n+    n_value = 3  # testing with a specific value for clarity\n+    In = Identity(n_value)\n+    total_sum = sum(sum(In[i, j] for j in range(n_value)) for i in range(n_value))\n+    assert total_sum == n_value, f\"Expected sum: {n_value}, got: {total_sum}\"\n     Inn = Identity(Add(n, n, evaluate=False))\n     assert isinstance(Inn.rows, Add)\n     assert Inn.doit() == Identity(2*n)\n",
  "sympy__sympy-20049": "",
  "sympy__sympy-21612": "diff --git a/sympy/parsing/tests/test_latex.py b/sympy/parsing/tests/test_latex.py\nindex b252985..8e46e75 100644\n--- a/sympy/parsing/tests/test_latex.py\n+++ b/sympy/parsing/tests/test_latex.py\n@@ -251,7 +251,10 @@ def test_parseable():\n     for latex_str, sympy_expr in GOOD_PAIRS:\n         assert parse_latex(latex_str) == sympy_expr, latex_str\n \n-# These bad LaTeX strings should raise a LaTeXParsingError when parsed\n+def test_issue_21537():\n+    from sympy.parsing.latex import parse_latex\n+    expr = parse_latex(\"\\\\frac{\\\\frac{a^3+b}{c}}{\\\\frac{1}{c^2}}\")\n+    assert expr == ((a**3 + b)/c)/(1/(c**2)), f\"Expected: {((a**3 + b)/c)/(1/(c**2))}, but got: {expr}\"\n BAD_STRINGS = [\n     r\"(\",\n     r\")\",\n"
}