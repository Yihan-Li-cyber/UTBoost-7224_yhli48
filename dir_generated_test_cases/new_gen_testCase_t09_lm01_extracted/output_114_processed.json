{
  "astropy__astropy-12907": "",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..94f3103 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,6 +1,70 @@\n+\n+def test_rst_with_header_rows():\n+    \"\"\"Round-trip a table with header_rows specified\"\"\"\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct     \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\",\n+    ]\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"wave\"].dtype == np.float64\n+    assert tbl[\"response\"].dtype == np.float32\n+    assert tbl[\"ints\"].dtype == np.int8\n+\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert out.getvalue().splitlines() == lines\n+\n+\n+def test_rst_with_single_header_row():\n+    \"\"\"Test writing with a single header row for units.\"\"\"\n+    expected_lines = [\n+        \"===== ========\",\n+        \"wave response\",\n+        \" nm      ct  \",\n+        \"===== ========\",\n+        \"350.0      0.7\",\n+        \"950.0      1.2\",\n+        \"===== ========\",\n+    ]\n+    \n+    tbl = QTable({'wave': [350, 950]*u.nm, 'response': [0.7, 1.2]*u.count})\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"unit\"])\n+    \n+    assert out.getvalue().splitlines() == expected_lines\n+\n+\n+def test_rst_with_no_header_rows():\n+    \"\"\"Test writing with no additional header rows.\"\"\"\n+    expected_lines = [\n+        \"===== ========\",\n+        \"wave response\",\n+        \"===== ========\",\n+        \"350.0      0.7\",\n+        \"950.0      1.2\",\n+        \"===== ========\",\n+    ]\n+    \n+    tbl = QTable({'wave': [350, 950], 'response': [0.7, 1.2]})\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\")\n+    \n+    assert out.getvalue().splitlines() == expected_lines\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n from io import StringIO\n+import numpy as np\n+import astropy.units as u\n+from astropy.table import QTable\n \n from astropy.io import ascii\n \n",
  "astropy__astropy-14365": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 9b66109..8658d21 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -43,6 +43,11 @@ def test_get_tables_from_qdp_file(tmp_path):\n     assert np.isclose(table2[\"MJD_nerr\"][0], -2.37847222222222e-05)\n \n \n+import pytest\n+import numpy as np\n+from astropy.io.ascii.qdp import _read_table_qdp, _write_table_qdp\n+from astropy.utils.exceptions import AstropyUserWarning\n+\n def test_roundtrip(tmp_path):\n     example_qdp = \"\"\"\n     ! Swift/XRT hardness ratio of trigger: XXXX, name: BUBU X-2\n",
  "astropy__astropy-14995": "diff --git a/astropy/nddata/mixins/tests/test_ndarithmetic.py b/astropy/nddata/mixins/tests/test_ndarithmetic.py\nindex fc27f69..17b4829 100644\n--- a/astropy/nddata/mixins/tests/test_ndarithmetic.py\n+++ b/astropy/nddata/mixins/tests/test_ndarithmetic.py\n@@ -28,9 +28,44 @@ class StdDevUncertaintyUncorrelated(StdDevUncertainty):\n         return False\n \n \n-# Test with Data covers:\n-# scalars, 1D, 2D and 3D\n-# broadcasting between them\n+import numpy as np\n+from astropy.nddata import NDDataRef\n+\n+def test_nddata_mask_propagation():\n+    array = np.array([[0, 1, 0], [1, 0, 1], [0, 1, 0]])\n+    mask = np.array([[0, 1, 64], [8, 0, 1], [2, 1, 0]])\n+\n+    nref_nomask = NDDataRef(array)\n+    nref_masked = NDDataRef(array, mask=mask)\n+\n+    # multiply no mask by constant (no mask * no mask)\n+    assert nref_nomask.multiply(1.0, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply no mask by itself (no mask * no mask)\n+    assert nref_nomask.multiply(nref_nomask, handle_mask=np.bitwise_or).mask is None\n+\n+    # multiply masked by constant (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(1.0, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by itself (mask * mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_masked, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # multiply masked by no mask (mask * no mask)\n+    np.testing.assert_equal(\n+        nref_masked.multiply(nref_nomask, handle_mask=np.bitwise_or).mask, mask\n+    )\n+\n+    # check bitwise logic still works\n+    other_mask = np.array([[64, 1, 0], [2, 1, 0], [8, 0, 2]])\n+    nref_mask_other = NDDataRef(array, mask=other_mask)\n+    np.testing.assert_equal(\n+        nref_mask_other.multiply(nref_masked, handle_mask=np.bitwise_or).mask,\n+        np.bitwise_or(mask, other_mask),\n+    )\n @pytest.mark.filterwarnings(\"ignore:divide by zero encountered.*\")\n @pytest.mark.parametrize(\n     (\"data1\", \"data2\"),\n",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..9929ecf 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -253,6 +253,21 @@ class TestTableFunctions(FitsTestCase):\n         # When there are scaled columns, the raw data are in data._parent\n \n         t.close()\n+        \n+    def test_d_exponent_replacement(self):\n+        # Test case to verify the fix for D exponent replacement\n+        r1 = np.array([1.23e2, 4.56e3])\n+        c1 = fits.Column(name='test', format='D', array=r1)\n+        hdu = fits.TableHDU.from_columns([c1])\n+        hdu.writeto(self.temp('test_exponent.fits'), overwrite=True)\n+        \n+        with open(self.temp('test_exponent.fits')) as f:\n+            content = f.read()\n+            # Check that the numbers are written with 'D' exponent\n+            assert '1.23D+02' in content\n+            assert '4.56D+03' in content\n+        with fits.open(self.temp('test_exponent.fits')) as hdul:\n+            assert comparerecords(hdu.data, hdul[1].data)\n \n     def test_ascii_table(self):\n         # ASCII table\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..5627e86 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1090,6 +1090,13 @@ class OverrideSettingsTests(SimpleTestCase):\n         base_url attribute of django.core.files.storage.default_storage.\n         \"\"\"\n         self.assertEqual(default_storage.base_location, '')\n+\n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        By default, the FILE_UPLOAD_PERMISSIONS setting should use 0o644.\n+        \"\"\"\n+        with self.settings(FILE_UPLOAD_PERMISSIONS=None):\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n         with self.settings(MEDIA_URL='/test_value/'):\n             self.assertEqual(default_storage.base_url, '/test_value/')\n \n@@ -1103,6 +1110,26 @@ class OverrideSettingsTests(SimpleTestCase):\n         with self.settings(FILE_UPLOAD_PERMISSIONS=0o777):\n             self.assertEqual(default_storage.file_permissions_mode, 0o777)\n \n+    def test_temporary_file_upload_permissions(self):\n+        \"\"\"\n+        Uploaded files should have consistent permissions when stored in the file system.\n+        \"\"\"\n+        temp_storage = FileSystemStorage(location=tempfile.gettempdir())\n+        temp_file = tempfile.NamedTemporaryFile(delete=False)\n+        try:\n+            temp_file.write(b'Test content')\n+            temp_file.flush()\n+            os.fchmod(temp_file.fileno(), 0o600)  # Simulate restrictive temp file permissions\n+            temp_file.close()\n+\n+            saved_name = temp_storage.save('test_file.txt', File(open(temp_file.name, 'rb')))\n+            saved_file_path = temp_storage.path(saved_name)\n+            \n+            self.assertEqual(oct(os.stat(saved_file_path).st_mode & 0o777), '0o644')\n+        finally:\n+            os.remove(saved_file_path)\n+            os.remove(temp_file.name)\n+\n     def test_override_file_upload_directory_permissions(self):\n         \"\"\"\n         Overriding the FILE_UPLOAD_DIRECTORY_PERMISSIONS setting should be\n",
  "django__django-10924": "",
  "django__django-11001": "",
  "django__django-11039": "diff --git a/tests/migrations/test_commands.py b/tests/migrations/test_commands.py\nindex dbcbef0..3990559 100644\n--- a/tests/migrations/test_commands.py\n+++ b/tests/migrations/test_commands.py\n@@ -514,6 +514,22 @@ class MigrateTests(MigrationTestBase):\n             out.getvalue()\n         )\n \n+    @override_settings(MIGRATION_MODULES={\"migrations\": \"migrations.test_migrations\"})\n+    def test_sqlmigrate_for_non_transactional_databases(self):\n+        \"\"\"\n+        Ensure sqlmigrate does not show transaction wrappers for databases\n+        that don't support transactional DDL.\n+        \"\"\"\n+        out = io.StringIO()\n+        with mock.patch.object(connection.features, 'can_rollback_ddl', False):\n+            call_command('sqlmigrate', 'migrations', '0001', stdout=out)\n+        output = out.getvalue().lower()\n+        queries = [q.strip() for q in output.splitlines()]\n+        start_transaction_sql = connection.ops.start_transaction_sql()\n+        if start_transaction_sql:\n+            self.assertNotIn(start_transaction_sql.lower(), queries)\n+        self.assertNotIn(connection.ops.end_transaction_sql().lower(), queries)\n+\n     @override_settings(INSTALLED_APPS=['migrations.migrations_test_apps.unmigrated_app'])\n     def test_showmigrations_plan_app_label_no_migrations(self):\n         out = io.StringIO()\n",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..f1c82ab 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -75,7 +75,7 @@ class TestValidation(SimpleTestCase):\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n             \"'not a datetime' value has an invalid format. \"\n-            \"It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n         )\n \n \n@@ -84,4 +84,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..ef8fcae 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -237,7 +237,7 @@ class UsernameValidatorsTests(SimpleTestCase):\n         invalid_usernames = [\n             \"o'connell\", \"\u0639\u0628\u062f \u0627\u0644\",\n             \"zerowidth\\u200Bspace\", \"nonbreaking\\u00A0space\",\n-            \"en\\u2013dash\",\n+            \"en\\u2013dash\", 'trailingnewline\\n', 'trailingnewline\\u000A'\n         ]\n         v = validators.UnicodeUsernameValidator()\n         for valid in valid_usernames:\n@@ -247,10 +247,18 @@ class UsernameValidatorsTests(SimpleTestCase):\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n                     v(invalid)\n+        v = validators.UnicodeUsernameValidator()\n+        for valid in valid_usernames:\n+            with self.subTest(valid=valid):\n+                v(valid)\n+        for invalid in invalid_usernames:\n+            with self.subTest(invalid=invalid):\n+                with self.assertRaises(ValidationError):\n+                    v(invalid)\n \n     def test_ascii_validator(self):\n         valid_usernames = ['glenn', 'GLEnN', 'jean-marc']\n-        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\"]\n+        invalid_usernames = [\"o'connell\", '\u00c9ric', 'jean marc', \"\u0623\u062d\u0645\u062f\", 'trailingnewline\\n', 'trailingnewline\\u000A']\n         v = validators.ASCIIUsernameValidator()\n         for valid in valid_usernames:\n             with self.subTest(valid=valid):\n@@ -258,4 +266,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11133": "diff --git a/tests/httpwrappers/tests.py b/tests/httpwrappers/tests.py\nindex 32aaf3b..e654efc 100644\n--- a/tests/httpwrappers/tests.py\n+++ b/tests/httpwrappers/tests.py\n@@ -366,7 +366,9 @@ class HttpResponseTests(unittest.TestCase):\n         r.content = 12345\n         self.assertEqual(r.content, b'12345')\n \n-    def test_iter_content(self):\n+    def test_memoryview_content(self):\n+        r = HttpResponse(memoryview(b'memoryview'))\n+        self.assertEqual(r.content, b'memoryview')\n         r = HttpResponse(['abc', 'def', 'ghi'])\n         self.assertEqual(r.content, b'abcdefghi')\n \n",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..3d661ba 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,9 +1,11 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n+from django.db.models.deletion import Collector\n from .models import (\n     MR, A, Avatar, Base, Child, HiddenUser, HiddenUserProfile, M, M2MFrom,\n     M2MTo, MRNull, Parent, R, RChild, S, T, User, create_a, get_default_r,\n@@ -471,6 +473,24 @@ class FastDeleteTests(TestCase):\n         self.assertEqual(User.objects.count(), 1)\n         self.assertTrue(User.objects.filter(pk=u2.pk).exists())\n \n+    def test_fast_delete_instance_set_pk_none(self):\n+        user = User.objects.create()\n+        # Ensure User can be fast-deleted.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(user))\n+        # Delete the user and check that the pk is set to None.\n+        user.delete()\n+        self.assertIsNone(user.pk)\n+        \n+    def test_delete_instance_without_dependencies(self):\n+        avatar = Avatar.objects.create(desc='Test Avatar')\n+        # Ensure Avatar can be fast-deleted as it has no dependencies.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(avatar))\n+        # Delete the avatar and check that the pk is set to None.\n+        avatar.delete()\n+        self.assertIsNone(avatar.pk)\n+\n     def test_fast_delete_joined_qs(self):\n         a = Avatar.objects.create(desc='a')\n         User.objects.create(avatar=a)\n@@ -481,6 +501,24 @@ class FastDeleteTests(TestCase):\n         self.assertEqual(User.objects.count(), 1)\n         self.assertTrue(User.objects.filter(pk=u2.pk).exists())\n \n+    def test_fast_delete_instance_set_pk_none(self):\n+        user = User.objects.create()\n+        # Ensure User can be fast-deleted.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(user))\n+        # Delete the user and check that the pk is set to None.\n+        user.delete()\n+        self.assertIsNone(user.pk)\n+        \n+    def test_delete_instance_without_dependencies(self):\n+        avatar = Avatar.objects.create(desc='Test Avatar')\n+        # Ensure Avatar can be fast-deleted as it has no dependencies.\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(avatar))\n+        # Delete the avatar and check that the pk is set to None.\n+        avatar.delete()\n+        self.assertIsNone(avatar.pk)\n+\n     def test_fast_delete_inheritance(self):\n         c = Child.objects.create()\n         p = Parent.objects.create()\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..47487fc 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,9 +1,11 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n from django.contrib.auth.models import Permission, User\n from django.contrib.contenttypes.models import ContentType\n from django.test import TestCase\n+from django.core.exceptions import ValidationError\n \n from .models import Proxy, UserProxy\n \n@@ -140,7 +142,42 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n-    def test_user_keeps_same_permissions_after_migrating_backward(self):\n+    def test_migration_with_existing_proxy_permissions(self):\n+        \"\"\"\n+        Ensure that the migration does not fail when permissions for\n+        proxy models already exist in the database.\n+        \"\"\"\n+        proxy_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_content_type,\n+            codename='change_proxy',\n+            name='Can change proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_content_type,\n+            codename='delete_proxy',\n+            name='Can delete proxy',\n+        )\n+        with captured_stdout() as stdout:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        self.assertNotIn('duplicate key value violates unique constraint', stdout.getvalue())\n+\n+    def test_migration_with_no_proxy_permissions_existing(self):\n+        \"\"\"\n+        Ensure that the migration correctly creates permissions when none exist\n+        for the proxy models initially.\n+        \"\"\"\n+        proxy_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        permissions = set(Permission.objects.filter(content_type=proxy_content_type).values_list('codename', flat=True))\n+        expected_permissions = {'add_proxy', 'change_proxy', 'delete_proxy'}\n+\n+        self.assertTrue(expected_permissions.issubset(permissions))\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n         user.user_permissions.add(self.custom_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..910f3b5 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -9,6 +9,7 @@ import time\n import types\n import weakref\n import zipfile\n+import sys\n from importlib import import_module\n from pathlib import Path\n from unittest import mock, skip, skipIf\n",
  "django__django-11583": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex 99e5edd..352f0f8 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -140,6 +140,29 @@ class TestIterModulesAndFiles(SimpleTestCase):\n         fake_main = types.ModuleType('__main__')\n         self.assertEqual(autoreload.iter_modules_and_files((fake_main,), frozenset()), frozenset())\n \n+    def test_path_with_embedded_null_bytes(self):\n+        # Testing paths with embedded null bytes to verify the function's robustness\n+        paths_with_null_byte = [\n+            'embedded_null_byte\\x00.py',\n+            'dir\\x00/embedded_null_byte.py',\n+            '/root/invalid\\x00path',\n+            '\\x00/leading_null_byte.py',\n+            '/root/\\x00/mid_null_byte.py',\n+            '/root/trailing_null_byte.py\\x00',\n+        ]\n+        for path in paths_with_null_byte:\n+            with self.subTest(path=path):\n+                self.assertEqual(\n+                    autoreload.iter_modules_and_files((), frozenset([path])),\n+                    frozenset(),\n+                )\n+\n+    def test_sys_files_without_location(self):\n+        # Mock a module without a location to simulate the conditions\n+        module_without_location = types.ModuleType('module_without_location')\n+        module_without_location.__spec__ = types.SimpleNamespace(has_location=False)\n+        self.assertEqual(autoreload.iter_modules_and_files((module_without_location,), frozenset()), frozenset())\n+\n \n class TestCommonRoots(SimpleTestCase):\n     def test_common_roots(self):\n",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..3fc5de1 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -6,6 +6,8 @@ import sys\n import tempfile\n import threading\n from io import StringIO\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n from pathlib import Path\n from unittest import mock\n \n@@ -242,7 +244,36 @@ class DebugViewQueriesAllowedTests(SimpleTestCase):\n     # May need a query to initialize MySQL connection\n     databases = {'default'}\n \n-    def test_handle_db_exception(self):\n+    def test_technical_404_converter_raise_404(self):\n+        \"\"\"\n+        Ensure that raising Http404 in a path converter's to_python method\n+        results in a technical 404 page when DEBUG is True.\n+        \"\"\"\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+            response = self.client.get('/path-post/1/')\n+            self.assertContains(response, 'Page not found', status_code=404)\n+\n+    def test_technical_404_converter_with_valueerror(self):\n+        \"\"\"\n+        Ensure that raising ValueError in a path converter's to_python method\n+        doesn't result in a technical 404 when DEBUG is True, but rather\n+        a 'Django tried these URL patterns' message as it indicates the\n+        path doesn't match.\n+        \"\"\"\n+        with mock.patch.object(IntConverter, 'to_python', side_effect=ValueError):\n+            response = self.client.get('/path-post/1/')\n+            self.assertContains(response, 'Django tried these URL patterns', status_code=404)\n+\n+    def test_technical_404_converter_raise_404_debug_off(self):\n+        \"\"\"\n+        Ensure that raising Http404 in a path converter's to_python method results\n+        in a plain 404 response when DEBUG is False.\n+        \"\"\"\n+        with self.settings(DEBUG=False):\n+            with mock.patch.object(IntConverter, 'to_python', side_effect=Http404):\n+                response = self.client.get('/path-post/1/')\n+                self.assertNotContains(response, 'Django tried these URL patterns', status_code=404)\n+                self.assertContains(response, 'Page not found', status_code=404)\n         \"\"\"\n         Ensure the debug view works when a database exception is raised by\n         performing an invalid query and passing the exception to the debug view.\n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..c546b89 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -163,7 +163,40 @@ class CharFieldTests(SimpleTestCase):\n             ),\n         ])\n \n-    def test_non_iterable_choices(self):\n+    def test_choices_max_length_too_small(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2, \n+                choices=[('ABC', 'Value Too Long!'), ('OK', 'Good')]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+    def test_choices_nested_group_max_length_too_small(self):\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2, \n+                choices=[\n+                    ('Nested', [('OK', 'Good'), ('Longer', 'Longer')]),\n+                    ('Grouped', [('Bad', 'Bad')])\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (6 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n         class Model(models.Model):\n             field = models.CharField(max_length=10, choices='bad')\n \n",
  "django__django-11815": "",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..528d83d 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,5 +1,7 @@\n+\n import unittest\n from datetime import datetime\n+from unittest import mock\n \n from django.test import SimpleTestCase, ignore_warnings\n from django.utils.datastructures import MultiValueDict\n@@ -323,8 +325,35 @@ class HttpDateProcessingTests(unittest.TestCase):\n     def test_parsing_asctime(self):\n         parsed = parse_http_date('Sun Nov  6 08:49:37 1994')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n-\n-    def test_parsing_year_less_than_70(self):\n+    \n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850_two_digit_years(self, mocked_datetime):\n+        # Mock current year to validate parsing logic year boundaries\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+        \n+        # Define different current years for testing\n+        test_years = [\n+            (datetime(2019, 11, 6, 8, 49, 37), [\n+                ('Tuesday, 31-Dec-69 08:49:37 GMT', datetime(2069, 12, 31, 8, 49, 37)),\n+                ('Tuesday, 10-Nov-70 08:49:37 GMT', datetime(1970, 11, 10, 8, 49, 37)),\n+            ]),\n+            (datetime(2048, 11, 6, 8, 49, 37), [\n+                ('Sunday, 06-Nov-94 08:49:37 GMT', datetime(1994, 11, 6, 8, 49, 37)),\n+                ('Friday, 31-Dec-99 08:49:37 GMT', datetime(1999, 12, 31, 8, 49, 37)),\n+            ]),\n+            (datetime(2070, 11, 6, 8, 49, 37), [\n+                ('Tuesday, 31-Dec-69 08:49:37 GMT', datetime(2069, 12, 31, 8, 49, 37)),\n+                ('Wednesday, 31-Dec-70 08:49:37 GMT', datetime(1970, 12, 31, 8, 49, 37)),\n+            ])\n+        ]\n+\n+        for current_time, cases in test_years:\n+            mocked_datetime.utcnow.return_value = current_time\n+            for rfc850str, expected_date in cases:\n+                with self.subTest(rfc850str=rfc850str):\n+                    parsed = parse_http_date(rfc850str)\n+                    self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n         parsed = parse_http_date('Sun Nov  6 08:49:37 0037')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(2037, 11, 6, 8, 49, 37))\n \n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..693f385 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -41,7 +41,17 @@ class Gender(models.TextChoices):\n \n \n class ChoicesTests(SimpleTestCase):\n-    def test_integerchoices(self):\n+    def test_textchoices_field_type(self):\n+        # Create an object with the TextChoices field\n+        obj = MyObject.objects.create(my_str_value=MyChoice.FIRST_CHOICE)\n+        # Test that the value is stored as a string\n+        self.assertIsInstance(obj.my_str_value, str)\n+        self.assertEqual(obj.my_str_value, \"first\")\n+        \n+        # Retrieve the object and ensure the value is a string\n+        retrieved_obj = MyObject.objects.get(pk=obj.pk)\n+        self.assertIsInstance(retrieved_obj.my_str_value, str)\n+        self.assertEqual(retrieved_obj.my_str_value, \"first\")\n         self.assertEqual(Suit.choices, [(1, 'Diamond'), (2, 'Spade'), (3, 'Heart'), (4, 'Club')])\n         self.assertEqual(Suit.labels, ['Diamond', 'Spade', 'Heart', 'Club'])\n         self.assertEqual(Suit.values, [1, 2, 3, 4])\n",
  "django__django-11999": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex a9aa33c..7093980 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -148,6 +148,8 @@ class ChoicesTests(SimpleTestCase):\n                 self.assertIsInstance(field.formfield(), forms.ChoiceField)\n \n \n+from django.db import models\n+\n class GetFieldDisplayTests(SimpleTestCase):\n \n     def test_choices_and_field_display(self):\n@@ -162,7 +164,18 @@ class GetFieldDisplayTests(SimpleTestCase):\n         self.assertEqual(Whiz(c='').get_c_display(), '')        # Empty value\n         self.assertEqual(WhizDelayed(c=0).get_c_display(), 'Other')  # Delayed choices\n \n-    def test_get_FIELD_display_translated(self):\n+    def test_overriding_get_FIELD_display(self):\n+        \"\"\"\n+        Test that overriding get_FIELD_display works.\n+        \"\"\"\n+        class FooBar(models.Model):\n+            foo_bar = models.IntegerField(choices=[(1, 'foo'), (2, 'bar')])\n+\n+            def get_foo_bar_display(self):\n+                return 'something'\n+\n+        f = FooBar(foo_bar=1)\n+        self.assertEqual(f.get_foo_bar_display(), 'something')\n         \"\"\"A translated display value is coerced to str.\"\"\"\n         val = Whiz(c=5).get_c_display()\n         self.assertIsInstance(val, str)\n",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "diff --git a/tests/urlpatterns/path_urls.py b/tests/urlpatterns/path_urls.py\nindex 12487f2..9f7c3a6 100644\n--- a/tests/urlpatterns/path_urls.py\n+++ b/tests/urlpatterns/path_urls.py\n@@ -12,6 +12,7 @@ urlpatterns = [\n     path('included_urls/', include('urlpatterns.included_urls')),\n     re_path(r'^regex/(?P<pk>[0-9]+)/$', views.empty_view, name='regex'),\n     re_path(r'^regex_optional/(?P<arg1>\\d+)/(?:(?P<arg2>\\d+)/)?', views.empty_view, name='regex_optional'),\n+    re_path(r'^module/(?P<format>(html|json|xml))?/?$', views.empty_view, name='modules'),\n     path('', include('urlpatterns.more_urls')),\n     path('<lang>/<path:url>/', views.empty_view, name='lang-and-path'),\n-]\n+]\n",
  "django__django-12284": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex 7dc81d2..e18e491 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -1,3 +1,4 @@\n+\n import pickle\n \n from django import forms\n@@ -147,8 +148,32 @@ class ChoicesTests(SimpleTestCase):\n             with self.subTest(field=field):\n                 self.assertIsInstance(field.formfield(), forms.ChoiceField)\n \n+from django.test import TestCase\n+\n+class OverrideFieldChoicesTests(TestCase):\n \n-class GetFieldDisplayTests(SimpleTestCase):\n+    def test_overriding_inherited_field_display(self):\n+        \"\"\"\n+        Test that get_FIELD_display() works correctly with overridden choices\n+        in a child model.\n+        \"\"\"\n+        class BaseModel(models.Model):\n+            foo = models.CharField(max_length=255, choices=[('A', 'Base A')])\n+\n+            class Meta:\n+                abstract = True\n+        \n+        class ChildModel(BaseModel):\n+            foo = models.CharField(max_length=255, choices=[('A', 'Child A'), ('B', 'Child B'), ('C', 'Child C')])\n+\n+        # Testing the outputs for each choice\n+        child_instance_a = ChildModel(foo='A')\n+        child_instance_b = ChildModel(foo='B')\n+        child_instance_c = ChildModel(foo='C')\n+        \n+        self.assertEqual(child_instance_a.get_foo_display(), 'Child A')\n+        self.assertEqual(child_instance_b.get_foo_display(), 'Child B')\n+        self.assertEqual(child_instance_c.get_foo_display(), 'Child C')\n \n     def test_choices_and_field_display(self):\n         \"\"\"\n",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..2305c2a 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,9 +1,10 @@\n+\n from django.core.checks import Error\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n     check_setting_languages, check_setting_languages_bidi,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, override_settings\n \n \n class TranslationCheckTests(SimpleTestCase):\n@@ -75,6 +76,26 @@ class TranslationCheckTests(SimpleTestCase):\n                     Error(msg % tag, id='translation.E003'),\n                 ])\n \n+    @override_settings(\n+        USE_I18N=True,\n+        LANGUAGES=[\n+            ('de', 'German'),\n+            ('es', 'Spanish'),\n+            ('fr', 'French'),\n+            ('en', 'English'),\n+        ],\n+    )\n+    def test_base_language_fallback(self):\n+        \"\"\"Test that the base language is correctly used without raising E004.\"\"\"\n+        tests = [\n+            'de-at',  # Austrian German (de base)\n+            'es-mx',  # Mexican Spanish (es base)\n+            'fr-ca',  # Canadian French (fr base)\n+        ]\n+        for tag in tests:\n+            with self.subTest(tag=tag), self.settings(LANGUAGE_CODE=tag):\n+                self.assertEqual(check_language_settings_consistent(None), [])\n+\n     def test_inconsistent_language_settings(self):\n         msg = (\n             'You have provided a value for the LANGUAGE_CODE setting that is '\n",
  "django__django-12308": "",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..b773dc6 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from unittest import mock\n \n@@ -6,6 +7,7 @@ from django.db.backends.base.creation import (\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n from django.test import SimpleTestCase\n+from ..models import Object, ObjectReference\n \n \n def get_connection_copy():\n@@ -17,6 +19,31 @@ def get_connection_copy():\n     )\n     return test_connection\n \n+class TestDeserializeDbFromStringWithCircularRefs(SimpleTestCase):\n+    databases = {'default'}\n+\n+    def test_foreign_key_ordering(self):\n+        # Ensure deserialize_db_from_string correctly handles foreign key ordering.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            },\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"related_objects\": []}\n+            }\n+        ]\n+        \"\"\"\n+        # Deserialize the data and verify the objects are correctly linked\n+        connection.creation.deserialize_db_from_string(data)\n+        obj1 = Object.objects.get(pk=1)\n+        obj_ref = ObjectReference.objects.get(pk=1)\n+        self.assertEqual(obj_ref.obj, obj1)\n+\n \n class TestDbSignatureTests(SimpleTestCase):\n     def test_default_name(self):\n",
  "django__django-12497": "diff --git a/tests/invalid_models_tests/test_relative_fields.py b/tests/invalid_models_tests/test_relative_fields.py\nindex 057ec3a..0175373 100644\n--- a/tests/invalid_models_tests/test_relative_fields.py\n+++ b/tests/invalid_models_tests/test_relative_fields.py\n@@ -128,7 +128,57 @@ class RelativeFieldTests(SimpleTestCase):\n             ),\n         ])\n \n-    def test_ambiguous_relationship_model(self):\n+    def test_recursive_relationship_without_through_fields(self):\n+        from django.core.checks import Error\n+        from django.db import models\n+\n+        class Person(models.Model):\n+            pass\n+\n+        class Group(models.Model):\n+            field = models.ManyToManyField('Person', through=\"AmbiguousRelationship\")\n+\n+        class AmbiguousRelationship(models.Model):\n+            person = models.ForeignKey(Person, models.CASCADE)\n+            first_group = models.ForeignKey(Group, models.CASCADE, related_name='first')\n+            second_group = models.ForeignKey(Group, models.CASCADE, related_name='second')\n+\n+        field = Group._meta.get_field('field')\n+        self.assertEqual(field.check(from_model=Group), [\n+            Error(\n+                \"The model is used as an intermediate model by 'invalid_models_tests.Group.field', \"\n+                \"but it has more than one foreign key from 'Group', which is ambiguous. \"\n+                \"You must specify which foreign key Django should use via the \"\n+                \"through_fields keyword argument.\",\n+                hint=(\n+                    'If you want to create a recursive relationship, use '\n+                    'ManyToManyField(\"self\", through=\"AmbiguousRelationship\").'\n+                ),\n+                obj=field,\n+                id='fields.E334',\n+            ),\n+        ])\n+\n+    def test_recursive_relationship_with_proper_through_fields(self):\n+        from django.core.checks import Warning\n+        from django.db import models\n+\n+        class Person(models.Model):\n+            pass\n+\n+        class Group(models.Model):\n+            field = models.ManyToManyField(\n+                'Person',\n+                through=\"AmbiguousRelationship\",\n+                through_fields=('group', 'person')\n+            )\n+\n+        class AmbiguousRelationship(models.Model):\n+            group = models.ForeignKey(Group, models.CASCADE)\n+            person = models.ForeignKey(Person, models.CASCADE)\n+\n+        field = Group._meta.get_field('field')\n+        self.assertEqual(field.check(from_model=Group), [])\n \n         class Person(models.Model):\n             pass\n",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..e7b10e1 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1241,10 +1241,84 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleansed_substitute,\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+            reporter_filter.cleanse_setting('password', 'super_secret'),\n+            reporter_filter.cleansed_substitute,\n+        )\n+\n     def test_cleanse_setting_recurses_in_dictionary(self):\n         reporter_filter = SafeExceptionReporterFilter()\n         initial = {'login': 'cooper', 'password': 'secret'}\n         self.assertEqual(\n+            reporter_filter.cleanse_setting('password', 'super_secret'),\n+            reporter_filter.cleansed_substitute,\n+        )\n+\n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n             reporter_filter.cleanse_setting('SETTING_NAME', initial),\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n@@ -1253,6 +1327,43 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n         self.assertEqual(\n+            reporter_filter.cleanse_setting('password', 'super_secret'),\n+            reporter_filter.cleansed_substitute,\n+        )\n+\n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n             reporter_filter.get_safe_request_meta(request)['HTTP_SECRET_HEADER'],\n             reporter_filter.cleansed_substitute,\n         )\n",
  "django__django-12708": "",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..1252a95 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -685,6 +685,29 @@ class FastDeleteTests(TestCase):\n         self.assertNumQueries(2, a.delete)\n         self.assertEqual(User.objects.count(), 0)\n \n+    def test_queryset_delete_returns_consistent_when_zero_objects_deleted(self):\n+        \"\"\"\n+        The QuerySet.delete() method should return a consistent result format\n+        when zero objects are deleted, regardless of foreign key presence.\n+        \"\"\"\n+        # Assuming BlockLibrary is a simple model without a foreign key\n+        # Setup: Ensure there are no records to delete\n+        self.assertEqual(BlockLibrary.objects.count(), 0)\n+        # Test: Delete operation on an empty queryset\n+        deleted, deleted_objs = BlockLibrary.objects.all().delete()\n+        # Expected: Should return (0, {}) for consistency\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {})\n+\n+        # Assuming FileAccess and File relate via foreign keys\n+        # Setup: Ensure there are no records to delete\n+        self.assertEqual(FileAccess.objects.count(), 0)\n+        # Test: Delete operation on an empty queryset\n+        deleted, deleted_objs = FileAccess.objects.all().delete()\n+        # Expected: Should return (0, {}) for consistency\n+        self.assertEqual(deleted, 0)\n+        self.assertEqual(deleted_objs, {})\n+\n     def test_fast_delete_empty_no_update_can_self_select(self):\n         \"\"\"\n         #25932 - Fast deleting on backends that don't have the\n",
  "django__django-12856": "",
  "django__django-12915": "",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..8effeb4 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -197,6 +197,12 @@ class TestUtilsText(SimpleTestCase):\n             ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True),\n             ('\u4f60\u597d', '\u4f60\u597d', True),\n             ('\u0130stanbul', 'istanbul', True),\n+            # New test cases to verify the issue correction\n+            ('___This is a test ---', 'this-is-a-test', False),\n+            ('__strip__underscore-value___', 'strip-underscore-value', False),\n+            ('--strip-dash-value---', 'strip-dash-value', False),\n+            ('__strip-mixed--value--__', 'strip-mixed-value', False),\n+            ('_-This value has mixed-__', 'this-value-has-mixed', False),\n         )\n         for value, output, is_unicode in items:\n             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n",
  "django__django-13028": "",
  "django__django-13158": "",
  "django__django-13230": "",
  "django__django-13315": "",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex e39d03e..7e34243 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -80,7 +80,30 @@ class BasicFieldTests(SimpleTestCase):\n         f = Foo._meta.get_field('a')\n         self.assertEqual(str(f), 'model_fields.Foo.a')\n \n-    def test_field_ordering(self):\n+    def test_abstract_inherited_fields_not_equal_across_models(self):\n+        \"\"\"\n+        Field instances with the same creation_counter should not be equal if from different models.\n+        \"\"\"\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritModel1(AbstractModel):\n+            pass\n+\n+        class InheritModel2(AbstractModel):\n+            pass\n+\n+        field1 = InheritModel1._meta.get_field('field')\n+        field2 = InheritModel2._meta.get_field('field')\n+\n+        self.assertNotEqual(field1, field2)\n+        self.assertNotEqual(hash(field1), hash(field2))\n+        # Assume we want to test order; this just needs `__lt__` implemented correctly\n+        if field1 != field2:  # if they are not equal, one of them must be less than the other\n+            self.assertTrue(field1 < field2 or field2 < field1)\n         \"\"\"Fields are ordered based on their creation.\"\"\"\n         f1 = models.Field()\n         f2 = models.Field(auto_created=True)\n@@ -103,6 +126,9 @@ class BasicFieldTests(SimpleTestCase):\n         self.assertEqual(path, 'model_fields.tests.Nested.Field')\n \n \n+from django.db import models\n+from django.test import SimpleTestCase\n+\n class ChoicesTests(SimpleTestCase):\n \n     @classmethod\n",
  "django__django-13447": "diff --git a/tests/admin_views/test_adminsite.py b/tests/admin_views/test_adminsite.py\nindex 16a02bb..a3deeaf 100644\n--- a/tests/admin_views/test_adminsite.py\n+++ b/tests/admin_views/test_adminsite.py\n@@ -45,14 +45,40 @@ class SiteEachContextTest(TestCase):\n         request.user = self.u1\n         self.assertEqual(site.each_context(request)['site_url'], '/my-script-name/')\n \n-    def test_available_apps(self):\n+from django.apps import apps\n+from django.contrib.auth.models import User\n+from .models import Article\n+\n+class AdminSiteTests(TestCase):\n+    def test_model_class_accessibility(self):\n         ctx = self.ctx\n         apps = ctx['available_apps']\n-        # we have registered two models from two different apps\n-        self.assertEqual(len(apps), 2)\n-\n         # admin_views.Article\n         admin_views = apps[0]\n+        article = admin_views['models'][0]\n+\n+        # Ensure the model class is accessible\n+        self.assertEqual(article['model'], Article)\n+\n+        # auth.User\n+        auth = apps[1]\n+        user = auth['models'][0]\n+        self.assertEqual(user['model'], User)\n+\n+    def test_build_app_dict(self):\n+        request = HttpRequest()\n+        app_dict = self.admin_site._build_app_dict(request)\n+        \n+        # Check the app_dict structure for admin_views\n+        admin_views = app_dict.get('admin_views')\n+        self.assertIsNotNone(admin_views)\n+        article = admin_views['models'][0]\n+        self.assertEqual(article['object_name'], 'Article')\n+        self.assertEqual(article['model'], Article)\n+\n+        # Check the app_dict structure for auth\n+        auth = app_dict.get('auth')\n+        admin_views = apps[0]\n         self.assertEqual(admin_views['app_label'], 'admin_views')\n         self.assertEqual(len(admin_views['models']), 1)\n         self.assertEqual(admin_views['models'][0]['object_name'], 'Article')\n",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..2c928e9 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,8 +1,10 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n from django.contrib.auth.models import User\n from django.contrib.auth.tokens import PasswordResetTokenGenerator\n+from .models import CustomEmailField\n from django.test import TestCase\n from django.test.utils import ignore_warnings\n from django.utils.deprecation import RemovedInDjango40Warning\n",
  "django__django-13590": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 0b4f73f..5bca81c 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1,4 +1,6 @@\n+\n import datetime\n+from collections import namedtuple\n import pickle\n import unittest\n import uuid\n",
  "django__django-13658": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex be37800..48b0f15 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -23,6 +23,8 @@ from django.core.management.commands.loaddata import Command as LoaddataCommand\n from django.core.management.commands.runserver import (\n     Command as RunserverCommand,\n )\n+from unittest import mock\n+from django.core.management import execute_from_command_line\n from django.core.management.commands.testserver import (\n     Command as TestserverCommand,\n )\n",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..b9c8f92 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,3 +1,4 @@\n+\n import sys\n import unittest\n from unittest import mock\n@@ -6,6 +7,8 @@ from django import __version__\n from django.core.management import CommandError, call_command\n from django.test import SimpleTestCase\n from django.test.utils import captured_stdin, captured_stdout\n+import django\n+from django.core.management.commands.shell import ShellCommand\n \n \n class ShellCommandTestCase(SimpleTestCase):\n@@ -30,14 +33,94 @@ class ShellCommandTestCase(SimpleTestCase):\n             call_command('shell')\n         self.assertEqual(stdout.getvalue().strip(), '100')\n \n-    @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n+    \n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), django.__version__)\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), django.__version__)\n     @mock.patch.dict('sys.modules', {'IPython': None})\n     def test_shell_with_ipython_not_installed(self, select):\n         select.return_value = ([], [], [])\n         with self.assertRaisesMessage(CommandError, \"Couldn't import ipython interface.\"):\n             call_command('shell', interface='ipython')\n \n-    @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n+    script_globals = 'print(\"__name__\" in globals())'\n+    script_with_inline_function = (\n+        'import django\\n'\n+        'def f():\\n'\n+        '    print(django.__version__)\\n'\n+        'f()'\n+    )\n+    \n+    def test_command_option_globals(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    def test_command_option_inline_function_call(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_with_inline_function)\n+        self.assertEqual(stdout.getvalue().strip(), django.__version__)\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_globals(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(\n+        sys.platform == 'win32',\n+        \"Windows select() doesn't support file descriptors.\",\n+    )\n+    @mock.patch('django.core.management.commands.shell.select')  # [1]\n+    def test_stdin_read_inline_function_call(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_with_inline_function)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), django.__version__)\n     @mock.patch.dict('sys.modules', {'bpython': None})\n     def test_shell_with_bpython_not_installed(self, select):\n         select.return_value = ([], [], [])\n@@ -49,4 +132,4 @@ class ShellCommandTestCase(SimpleTestCase):\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 2d83d62..0d7504b 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -1013,7 +1013,53 @@ class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n         self.assertContains(response, 'Add another Model with both - name')\n         self.assertNotContains(response, '<h2>Model with both - plural name</h2>')\n \n-    def test_both_verbose_names_inline(self):\n+    def test_verbose_name_inline(self):\n+        class NonVerboseProfileInline(TabularInline):\n+            model = Profile\n+            verbose_name = 'Non-verbose childs'\n+\n+        class VerboseNameProfileInline(TabularInline):\n+            model = VerboseNameProfile\n+            verbose_name = 'Childs with verbose name'\n+\n+        class VerboseNamePluralProfileInline(TabularInline):\n+            model = VerboseNamePluralProfile\n+            verbose_name = 'Childs with verbose name plural'\n+\n+        class BothVerboseNameProfileInline(TabularInline):\n+            model = BothVerboseNameProfile\n+            verbose_name = 'Childs with both verbose names'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [\n+            NonVerboseProfileInline,\n+            VerboseNameProfileInline,\n+            VerboseNamePluralProfileInline,\n+            BothVerboseNameProfileInline,\n+        ]\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+        # Non-verbose model.\n+        self.assertContains(response, '<h2>Non-verbose childss</h2>')\n+        self.assertContains(response, 'Add another Non-verbose child')\n+        self.assertNotContains(response, '<h2>Profiles</h2>')\n+        # Model with verbose name.\n+        self.assertContains(response, '<h2>Childs with verbose names</h2>')\n+        self.assertContains(response, 'Add another Childs with verbose name')\n+        self.assertNotContains(response, '<h2>Model with verbose name onlys</h2>')\n+        self.assertNotContains(response, 'Add another Model with verbose name only')\n+        # Model with verbose name plural.\n+        self.assertContains(response, '<h2>Childs with verbose name plurals</h2>')\n+        self.assertContains(response, 'Add another Childs with verbose name plural')\n+        self.assertNotContains(response, '<h2>Model with verbose name plural only</h2>')\n+        # Model with both verbose names.\n+        self.assertContains(response, '<h2>Childs with both verbose namess</h2>')\n+        self.assertContains(response, 'Add another Childs with both verbose names')\n+        self.assertNotContains(response, '<h2>Model with both - plural name</h2>')\n+        self.assertNotContains(response, 'Add another Model with both - name')\n         class NonVerboseProfileInline(TabularInline):\n             model = Profile\n             verbose_name = 'Non-verbose childs - name'\n",
  "django__django-13757": "diff --git a/tests/model_fields/test_jsonfield.py b/tests/model_fields/test_jsonfield.py\nindex f53ff8c..0298a8f 100644\n--- a/tests/model_fields/test_jsonfield.py\n+++ b/tests/model_fields/test_jsonfield.py\n@@ -595,7 +595,20 @@ class TestQuerying(TestCase):\n             [self.objs[4]],\n         )\n \n-    def test_isnull_key_or_none(self):\n+    def test_isnull_key_additional(self):\n+        # Test to ensure __isnull=True only matches missing keys, not keys with null values.\n+        # Assuming objs contain relevant data setup where JSON key `f` and `g` could be missing or set to null.\n+        \n+        # Testing on `f` key, expecting only objects missing the key `f`.\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__f__isnull=True),\n+            self.objs[:2] + self.objs[5:],  # Make sure to customize based on the objects setup\n+        )\n+        # Testing on `g` key\n+        self.assertSequenceEqual(\n+            NullableJSONModel.objects.filter(value__g__isnull=True),\n+            [self.objs[0], self.objs[1], self.objs[3], self.objs[5]],  # Customize this list as per data\n+        )\n         obj = NullableJSONModel.objects.create(value={'a': None})\n         self.assertSequenceEqual(\n             NullableJSONModel.objects.filter(Q(value__a__isnull=True) | Q(value__a=None)),\n",
  "django__django-13768": "",
  "django__django-13925": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 6424d89..735270d 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -370,6 +370,26 @@ def mocked_is_overridden(self, setting):\n         self.DEFAULT_AUTO_FIELD != 'django.db.models.AutoField'\n     )\n \n+    def test_inherited_manual_primary_key(self):\n+        class BaseModel(models.Model):\n+            custom_id = models.AutoField(primary_key=True)\n+\n+        class InheritedModel(BaseModel):\n+            pass\n+\n+        # There should be no W042 warning as the primary key is explicitly specified.\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n+    def test_inherited_manual_primary_key_with_extra_field(self):\n+        class BaseModel(models.Model):\n+            custom_id = models.AutoField(primary_key=True)\n+\n+        class InheritedModel(BaseModel):\n+            new_field = models.CharField(max_length=100)\n+\n+        # No W042 warning expected since the primary key is explicitly defined in the base model.\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n \n @mock.patch('django.conf.UserSettingsHolder.is_overridden', mocked_is_overridden)\n @override_settings(DEFAULT_AUTO_FIELD='django.db.models.AutoField')\n@@ -414,4 +434,4 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n             class Meta:\n                 app_label = 'check_framework.apps.CheckPKConfig'\n \n-        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n",
  "django__django-13933": "diff --git a/tests/forms_tests/tests/test_error_messages.py b/tests/forms_tests/tests/test_error_messages.py\nindex 881a5a8..8ec3ffe 100644\n--- a/tests/forms_tests/tests/test_error_messages.py\n+++ b/tests/forms_tests/tests/test_error_messages.py\n@@ -281,8 +281,45 @@ class FormsErrorMessagesTestCase(SimpleTestCase, AssertFormErrorsMixin):\n             '</ul></li></ul>'\n         )\n \n+from django.test import TestCase\n+from django.forms import ModelChoiceField, ModelMultipleChoiceField\n+from .models import ChoiceModel\n+from .asserts import AssertFormErrorsMixin\n+\n \n class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n+    def test_modelchoicefield_value_placeholder(self):\n+        # Ensure the invalid choice value is included in the error message\n+        f = ModelChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+            },\n+        )\n+        \n+        # Test with an invalid value\n+        self.assertFormErrors(\n+            ['\"invalid\" is not one of the available choices.'],\n+            f.clean,\n+            'invalid',\n+        )\n+\n+    def test_modelmultiplechoicefield_value_placeholder(self):\n+        # Ensure invalid list values are included in the error message\n+        f = ModelMultipleChoiceField(\n+            queryset=ChoiceModel.objects.all(),\n+            error_messages={\n+                'invalid_choice': '\"%(value)s\" is not one of the available choices.',\n+                'invalid_list': 'Enter a list of values.',\n+            },\n+        )\n+\n+        # Test with a list of invalid values\n+        self.assertFormErrors(\n+            ['\"invalid\" is not one of the available choices.'],\n+            f.clean,\n+            ['invalid'],\n+        )\n     def test_modelchoicefield(self):\n         # Create choices for the model choice field tests below.\n         ChoiceModel.objects.create(pk=1, name='a')\n@@ -307,4 +344,4 @@ class ModelChoiceFieldErrorMessagesTestCase(TestCase, AssertFormErrorsMixin):\n         f = ModelMultipleChoiceField(queryset=ChoiceModel.objects.all(), error_messages=e)\n         self.assertFormErrors(['REQUIRED'], f.clean, '')\n         self.assertFormErrors(['NOT A LIST OF VALUES'], f.clean, '3')\n-        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n+        self.assertFormErrors(['4 IS INVALID CHOICE'], f.clean, ['4'])\n",
  "django__django-13964": "",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..3f9a6cb 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,9 +1,18 @@\n+\n from django.db.models import F, Q\n from django.test import SimpleTestCase\n \n \n class QTests(SimpleTestCase):\n-    def test_combine_and_empty(self):\n+    def test_non_pickleable_keys_or_operator(self):\n+        # Ensure Q object handles dict_keys without raising TypeError\n+        q1 = Q(x__in={}.keys())\n+        q2 = Q(x__in={1: 'a'}.keys())  # Non-empty dict_keys\n+        self.assertEqual(q1 | Q(), q1)\n+        self.assertEqual(Q() | q1, q1)\n+        self.assertEqual(q1 | q2, Q(x__in={}.keys()) | Q(x__in={1: 'a'}.keys()))\n+        self.assertEqual(q2 | Q(), q2)\n+        self.assertEqual(Q() | q2, q2)\n         q = Q(x=1)\n         self.assertEqual(q & Q(), q)\n         self.assertEqual(Q() & q, q)\n",
  "django__django-14017": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 707f339..54da980 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -25,6 +25,7 @@ from django.db.models.functions import (\n from django.db.models.sql import constants\n from django.db.models.sql.datastructures import Join\n from django.test import SimpleTestCase, TestCase, skipUnlessDBFeature\n+from django.db.models import Q, Exists, OuterRef\n from django.test.utils import (\n     Approximate, CaptureQueriesContext, isolate_apps, register_lookup,\n )\n@@ -43,6 +44,21 @@ class BasicExpressionsTests(TestCase):\n             name=\"Example Inc.\", num_employees=2300, num_chairs=5,\n             ceo=Employee.objects.create(firstname=\"Joe\", lastname=\"Smith\", salary=10)\n         )\n+\n+    def test_q_and_exists_commutative(self):\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        test_cases = [\n+            (Exists(is_poc) & Q(), [self.max]),\n+            (Q() & Exists(is_poc), [self.max]),\n+            (Exists(is_ceo) | Q(), [self.example_inc.ceo, self.foobar_ltd.ceo, self.max]),\n+            (Q() | Exists(is_ceo), [self.example_inc.ceo, self.foobar_ltd.ceo, self.max])\n+        ]\n+        for condition, expected in test_cases:\n+            with self.subTest(condition=condition):\n+                self.assertCountEqual(Employee.objects.filter(condition), expected)\n         cls.foobar_ltd = Company.objects.create(\n             name=\"Foobar Ltd.\", num_employees=3, num_chairs=4, based_in_eu=True,\n             ceo=Employee.objects.create(firstname=\"Frank\", lastname=\"Meyer\", salary=20)\n@@ -792,6 +808,21 @@ class BasicExpressionsTests(TestCase):\n                 output_field=BooleanField(),\n             ),\n         )\n+\n+    def test_q_and_exists_commutative(self):\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        test_cases = [\n+            (Exists(is_poc) & Q(), [self.max]),\n+            (Q() & Exists(is_poc), [self.max]),\n+            (Exists(is_ceo) | Q(), [self.example_inc.ceo, self.foobar_ltd.ceo, self.max]),\n+            (Q() | Exists(is_ceo), [self.example_inc.ceo, self.foobar_ltd.ceo, self.max])\n+        ]\n+        for condition, expected in test_cases:\n+            with self.subTest(condition=condition):\n+                self.assertCountEqual(Employee.objects.filter(condition), expected)\n         self.assertCountEqual(qs, [self.example_inc.ceo, self.foobar_ltd.ceo, self.max])\n \n     def test_boolean_expression_combined(self):\n@@ -803,6 +834,21 @@ class BasicExpressionsTests(TestCase):\n             Employee.objects.filter(Exists(is_ceo) | Exists(is_poc)),\n             [self.example_inc.ceo, self.foobar_ltd.ceo, self.max],\n         )\n+\n+    def test_q_and_exists_commutative(self):\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        self.gmbh.point_of_contact = self.max\n+        self.gmbh.save()\n+        test_cases = [\n+            (Exists(is_poc) & Q(), [self.max]),\n+            (Q() & Exists(is_poc), [self.max]),\n+            (Exists(is_ceo) | Q(), [self.example_inc.ceo, self.foobar_ltd.ceo, self.max]),\n+            (Q() | Exists(is_ceo), [self.example_inc.ceo, self.foobar_ltd.ceo, self.max])\n+        ]\n+        for condition, expected in test_cases:\n+            with self.subTest(condition=condition):\n+                self.assertCountEqual(Employee.objects.filter(condition), expected)\n         self.assertCountEqual(\n             Employee.objects.filter(Exists(is_ceo) & Exists(is_poc)),\n             [self.max],\n",
  "django__django-14155": "diff --git a/tests/urlpatterns_reverse/tests.py b/tests/urlpatterns_reverse/tests.py\nindex 0f968fa..4cda4b9 100644\n--- a/tests/urlpatterns_reverse/tests.py\n+++ b/tests/urlpatterns_reverse/tests.py\n@@ -1145,6 +1145,30 @@ class ResolverMatchTests(SimpleTestCase):\n             \"namespaces=[], route=^no_kwargs/([0-9]+)/([0-9]+)/$)\",\n         )\n \n+    @override_settings(ROOT_URLCONF='urlpatterns_reverse.urls')\n+    def test_repr_functools_partial(self):\n+        # Test case for functools.partial function in views\n+        def mock_view(request, template_name):\n+            pass\n+\n+        partial_mock_view = functools.partial(mock_view, template_name='template.html')\n+        resolver_match = resolve('/partial/')\n+        \n+        self.assertEqual(\n+            repr(ResolverMatch(\n+                partial_mock_view, args=(), kwargs={}, \n+                url_name='partial', app_names=[], namespaces=[], route='partial/'\n+            )),\n+            \"ResolverMatch(func=%s.%s, args=(), kwargs={}, url_name=partial, app_names=[], namespaces=[], route=partial/)\" % (\n+                mock_view.__module__, mock_view.__name__\n+            )\n+        )\n+\n+\n+import functools\n+from django.test import override_settings\n+from django.urls import resolve, path\n+from . import views\n \n @override_settings(ROOT_URLCONF='urlpatterns_reverse.erroneous_urls')\n class ErroneousViewTests(SimpleTestCase):\n",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..9f7f769 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,3 +1,4 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n@@ -66,7 +67,27 @@ class TestDefaultPK(SimpleTestCase):\n             class Model(models.Model):\n                 pass\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n@@ -82,7 +103,27 @@ class TestDefaultPK(SimpleTestCase):\n \n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_m2m_default_auto_field_setting(self):\n         class M2MModel(models.Model):\n",
  "django__django-14382": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex afeed3e..63c3081 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2168,8 +2168,35 @@ class StartApp(AdminScriptTestCase):\n                     \"sure the name is a valid identifier.\".format(bad_name)\n                 )\n                 self.assertFalse(os.path.exists(testproject_dir))\n+        \n+    def test_trailing_slash_in_target_app_directory_name(self):\n+        app_dir = os.path.join(self.test_dir, 'apps', 'app1')\n+        os.makedirs(app_dir)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', 'app1', '')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n+\n+    def test_multiple_trailing_slashes_in_target_app_directory_name(self):\n+        app_dir = os.path.join(self.test_dir, 'apps', 'app2')\n+        os.makedirs(app_dir)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', 'app2', '////')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n+\n+    def test_no_trailing_slash_in_target_app_directory_name(self):\n+        app_dir = os.path.join(self.test_dir, 'apps', 'app3')\n+        os.makedirs(app_dir)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', 'app3')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n+\n+    def test_invalid_directory_name_with_trailing_slash(self):\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', '')])\n+        self.assertIn(\"CommandError: '' is not a valid app directory.\", err)\n \n-    def test_importable_name(self):\n+    def test_invalid_multiple_slash_directory_name(self):\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('////')])\n+        self.assertIn(\"CommandError: '' is not a valid app directory.\", err)\n         \"\"\"\n         startapp validates that app name doesn't clash with existing Python\n         modules.\n",
  "django__django-14411": "",
  "django__django-14580": "",
  "django__django-14608": "",
  "django__django-14672": "diff --git a/tests/m2m_through/tests.py b/tests/m2m_through/tests.py\nindex d9eaabe..b0bcc03 100644\n--- a/tests/m2m_through/tests.py\n+++ b/tests/m2m_through/tests.py\n@@ -9,6 +9,9 @@ from .models import (\n     Invitation, Membership, Person, PersonSelfRefM2M, Recipe, RecipeIngredient,\n     Relationship, SymmetricalFriendship,\n )\n+from django.db import models\n+from django.core.checks import Error\n+from .models import Person, Event, Invitation\n \n \n class M2mThroughTests(TestCase):\n",
  "django__django-14752": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex 7ef6d86..d5de0cc 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -294,6 +294,56 @@ class AutocompleteJsonViewTests(AdminViewBasicTestCase):\n         })\n \n \n+import json\n+from django.http import JsonResponse\n+from django.urls import path\n+from django.core.exceptions import PermissionDenied\n+from django.test import TestCase, RequestFactory\n+from django.contrib.auth.models import User\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+from admin_views.models import Question\n+import datetime\n+\n+class AutocompleteJsonViewTests(TestCase):\n+\n+    def setUp(self):\n+        self.factory = RequestFactory()\n+        self.superuser = User.objects.create_superuser(\n+            username='admin', password='pass', email='admin@example.com'\n+        )\n+        self.url = '/admin/autocomplete/'\n+        self.opts = {'app_label': 'admin_views', 'model_name': 'question'}\n+        self.as_view_args = {'extra_context': None, 'admin_site': None}\n+\n+    def test_serialize_result_with_extra_field(self):\n+        class CustomAutocompleteJsonView(AutocompleteJsonView):\n+            def serialize_result(self, obj, to_field_name):\n+                result = super().serialize_result(obj, to_field_name)\n+                result['posted'] = str(obj.posted)\n+                return result\n+\n+        # Add test data\n+        Question.objects.create(question='Question 1', posted=datetime.date(2021, 8, 9))\n+        Question.objects.create(question='Question 2', posted=datetime.date(2021, 8, 7))\n+\n+        # Make the request\n+        request = self.factory.get(self.url, {'term': 'question', **self.opts})\n+        request.user = self.superuser\n+\n+        # Get response\n+        response = CustomAutocompleteJsonView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+\n+        # Check response content\n+        data = json.loads(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [\n+                {'id': str(q.pk), 'text': q.question, 'posted': str(q.posted)}\n+                for q in Question.objects.order_by('-posted')\n+            ],\n+            'pagination': {'more': False},\n+        })\n+\n @override_settings(ROOT_URLCONF='admin_views.urls')\n class SeleniumTests(AdminSeleniumTestCase):\n     available_apps = ['admin_views'] + AdminSeleniumTestCase.available_apps\n",
  "django__django-14787": "diff --git a/tests/decorators/tests.py b/tests/decorators/tests.py\nindex 5ea3da6..d9f96cf 100644\n--- a/tests/decorators/tests.py\n+++ b/tests/decorators/tests.py\n@@ -426,6 +426,35 @@ class MethodDecoratorTests(SimpleTestCase):\n                     return \"tests\"\n \n \n+    def test_partial_wrapper_preservation(self):\n+        \"\"\"Test method_decorator with partial objects to preserve wrapper attributes.\"\"\"\n+        from functools import partial, wraps\n+        import logging\n+\n+        logger = logging.getLogger(__name__)\n+\n+        def logger_decorator(func):\n+            @wraps(func)\n+            def inner(*args, **kwargs):\n+                try:\n+                    result = func(*args, **kwargs)\n+                except Exception as e:\n+                    result = str(e)\n+                finally:\n+                    logger.debug(f\"{func.__name__} called with args: {args} and kwargs: {kwargs} resulting: {result}\")\n+                return result\n+            return inner\n+\n+        class PartialTest:\n+            @method_decorator(logger_decorator)\n+            def partial_method(self):\n+                return \"partial method test\"\n+\n+        # Ensure that the name and module are correctly preserved\n+        decorated_method = PartialTest().partial_method\n+        self.assertEqual(decorated_method.__name__, \"partial_method\")\n+        self.assertIsNotNone(decorated_method.__module__)\n+\n class XFrameOptionsDecoratorsTests(TestCase):\n     \"\"\"\n     Tests for the X-Frame-Options decorators.\n",
  "django__django-14855": "",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..8bb77cc 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,9 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n",
  "django__django-14999": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 3e4c6c7..a3e5d2d 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -792,8 +792,60 @@ class OperationTests(OperationTestBase):\n         self.assertEqual(Pony.objects.count(), 2)\n         self.assertEqual(Rider.objects.count(), 2)\n         self.assertEqual(Pony._meta.get_field('riders').remote_field.through.objects.count(), 2)\n+    from django.db import connection\n+    from django.db.migrations.state import ProjectState\n+    from django.db import migrations, models\n+    \n+    \n+    class RenameModelWithDbTableTests(TestCase):\n+        def test_rename_model_with_db_table_noop(self):\n+            app_label = 'test_rmwdbtn'\n+            project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+                migrations.CreateModel('Rider', fields=[\n+                    ('id', models.AutoField(primary_key=True)),\n+                ], options={'db_table': 'rider'}),\n+                migrations.CreateModel('Pony', fields=[\n+                    ('id', models.AutoField(primary_key=True)),\n+                    ('rider', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+                ]),\n+            ])\n+            new_state = project_state.clone()\n+            operation = migrations.RenameModel('Rider', 'Runner')\n+            operation.state_forwards(app_label, new_state)\n+        \n+            with connection.schema_editor() as editor:\n+                with self.assertNumQueries(0):\n+                    operation.database_forwards(app_label, editor, project_state, new_state)\n+            with connection.schema_editor() as editor:\n+                with self.assertNumQueries(0):\n+                    operation.database_backwards(app_label, editor, new_state, project_state)\n+        \n+        def test_no_unnecessary_table_recreation(self):\n+            # This test further verifies that no unnecessary table recreations happen.\n+            app_label = 'test_rmwdbtn'\n+            project_state = self.apply_operations(app_label, ProjectState(), operations=[\n+                migrations.CreateModel('Rider', fields=[\n+                    ('id', models.AutoField(primary_key=True)),\n+                ], options={'db_table': 'rider'}),\n+                migrations.CreateModel('Car', fields=[\n+                    ('id', models.AutoField(primary_key=True)),\n+                    ('owner', models.ForeignKey('%s.Rider' % app_label, models.CASCADE)),\n+                ]),\n+            ])\n+            new_state = project_state.clone()\n+            operation = migrations.RenameModel('Rider', 'Runner')\n+            operation.state_forwards(app_label, new_state)\n \n-    def test_rename_m2m_target_model(self):\n+            with connection.schema_editor() as editor:\n+                with self.assertNumQueries(0):\n+                    operation.database_forwards(app_label, editor, project_state, new_state)\n+                # Verify the table name in the db hasn't changed\n+                tables = connection.introspection.table_names()\n+                self.assertIn('rider', tables)\n+                self.assertNotIn('runner', tables)\n+            with connection.schema_editor() as editor:\n+                with self.assertNumQueries(0):\n+                    operation.database_backwards(app_label, editor, new_state, project_state)\n         app_label = \"test_rename_m2m_target_model\"\n         project_state = self.apply_operations(app_label, ProjectState(), operations=[\n             migrations.CreateModel(\"Rider\", fields=[\n",
  "django__django-15061": "diff --git a/tests/forms_tests/field_tests/test_multivaluefield.py b/tests/forms_tests/field_tests/test_multivaluefield.py\nindex 53aee21..bf29750 100644\n--- a/tests/forms_tests/field_tests/test_multivaluefield.py\n+++ b/tests/forms_tests/field_tests/test_multivaluefield.py\n@@ -153,6 +153,10 @@ class MultiValueFieldTest(SimpleTestCase):\n             <input type=\"text\" name=\"field1_2_1\" id=\"id_field1_2_1\" required></td></tr>\n             \"\"\",\n         )\n+    def test_multivaluefield_no_for_attribute_in_label(self):\n+        form = ComplexFieldForm()\n+        self.assertNotIn('for=\"id_field1_0\"', form.as_table())\n+        self.assertIn('<label>Field1:</label>', form.as_table())\n \n     def test_form_as_table_data(self):\n         form = ComplexFieldForm({\n",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..de8de7e 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -90,6 +90,12 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             'http://inv-.alid-.com',\n             'http://inv-.-alid.com',\n             '[a',\n+            # Original and additional cases to test for ValueError handling.\n+            '////]@N.AN',  # Original test case in the issue\n+            '#@A.bO',  # Original test case in the issue\n+            'http://[::1]',  # Properly formatted IPv6 for comparison\n+            'http://[::192.9.5.5]/ipng',  # IPv6 with embedded IPv4 \n+            'http://[2001:db8:85a3:8d3:1319:8a2e:370:7348]',  # Another valid IPv6\n             'http://[a',\n             # Non-string.\n             23,\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..38359f6 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -5,13 +5,13 @@ from django.core.exceptions import FieldDoesNotExist, FieldError\n from django.db.models import (\n     BooleanField, Case, CharField, Count, DateTimeField, DecimalField, Exists,\n     ExpressionWrapper, F, FloatField, Func, IntegerField, Max, OuterRef, Q,\n-    Subquery, Sum, Value, When,\n+    Subquery, Sum, Value, When, QuerySet\n )\n from django.db.models.expressions import RawSQL\n from django.db.models.functions import (\n     Coalesce, ExtractYear, Floor, Length, Lower, Trim,\n )\n-from django.test import TestCase, skipUnlessDBFeature\n+from django.test import TestCase, skipUnlessDBFeature, skipIfDBFeature\n from django.test.utils import register_lookup\n \n from .models import (\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..fbcdfdb 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,4 @@\n+\n import json\n import random\n \n@@ -163,7 +164,25 @@ class CookieTests(BaseTests, SimpleTestCase):\n         decoded_messages = json.loads(value, cls=MessageDecoder)\n         self.assertEqual(messages, decoded_messages)\n \n-    def test_safedata(self):\n+    def test_extra_tags_serialization(self):\n+        \"\"\"\n+        Test that extra_tags is correctly preserved as an empty string\n+        when serialized and then deserialized.\n+        \"\"\"\n+        def encode_decode_extra_tags(extra_tags):\n+            message = Message(constants.INFO, \"Test message\", extra_tags=extra_tags)\n+            encoded = MessageEncoder().encode(message)\n+            decoded = MessageDecoder().decode(encoded)\n+            return decoded.extra_tags\n+\n+        # Check for empty string\n+        self.assertEqual(encode_decode_extra_tags(\"\"), \"\")\n+\n+        # Check for None\n+        self.assertIsNone(encode_decode_extra_tags(None))\n+\n+        # Check for some tags\n+        self.assertEqual(encode_decode_extra_tags(\"some tags\"), \"some tags\")\n         \"\"\"\n         A message containing SafeData is keeping its safe status when\n         retrieved from the message storage.\n",
  "django__django-15388": "",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..8fb2cbe 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -184,7 +185,40 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n-    def test_was_modified_since_fp(self):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"\n+        Test that an empty string for the If-Modified-Since header does not raise an exception.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=\"\", mtime=1))\n+\n+    def test_was_modified_since_none(self):\n+        \"\"\"\n+        Test that a None value for the If-Modified-Since header is handled gracefully.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=None, mtime=1))\n+\n+    def test_was_modified_since_invalid_date(self):\n+        \"\"\"\n+        Test that an invalid date string for the If-Modified-Since header is handled gracefully.\n+        \"\"\"\n+        self.assertTrue(was_modified_since(header=\"invalid-date\", mtime=1))\n+\n+    def test_was_modified_since_valid_date_unmodified(self):\n+        \"\"\"\n+        Test with a valid date string that matches the mtime exactly.\n+        \"\"\"\n+        mtime = 1343416141\n+        header = http_date(mtime)\n+        self.assertFalse(was_modified_since(header, mtime))\n+\n+    def test_was_modified_since_valid_date_modified(self):\n+        \"\"\"\n+        Test with a valid date string that is earlier than the mtime.\n+        \"\"\"\n+        earlier_mtime = 1343416140\n+        current_mtime = 1343416141\n+        header = http_date(earlier_mtime)\n+        self.assertTrue(was_modified_since(header, current_mtime))\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n         \"\"\"\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..439bb41 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,3 +1,4 @@\n+\n import os\n from io import StringIO\n from unittest import mock\n@@ -7,6 +8,7 @@ from admin_scripts.tests import AdminScriptTestCase\n from django.apps import apps\n from django.core import management\n from django.core.checks import Tags\n+from argparse import ArgumentDefaultsHelpFormatter\n from django.core.management import BaseCommand, CommandError, find_commands\n from django.core.management.utils import (\n     find_command,\n@@ -410,8 +412,14 @@ class CommandTests(SimpleTestCase):\n         epilog = \"some epilog text\"\n         parser = BaseCommand().create_parser(\"prog_name\", \"subcommand\", epilog=epilog)\n         self.assertEqual(parser.epilog, epilog)\n-\n-    def test_outputwrapper_flush(self):\n+    \n+    def test_command_help_formatter(self):\n+        \"\"\"Test if the command help formatter is set correctly\"\"\"\n+        epilog = \"Example usage: ./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\"\n+        command = BaseCommand()\n+        parser = command.create_parser(\"manage.py\", \"tzkt_import\", epilog=epilog, formatter_class=ArgumentDefaultsHelpFormatter)\n+        self.assertEqual(parser.formatter_class, ArgumentDefaultsHelpFormatter)\n+        self.assertIn(epilog, parser.format_help())\n         out = StringIO()\n         with mock.patch.object(out, \"flush\") as mocked_flush:\n             management.call_command(\"outputwrapper\", stdout=out)\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..1610844 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,7 +1,10 @@\n+\n import os\n from datetime import datetime\n \n+from django.core.serializers.json import DjangoJSONEncoder\n from django.test import SimpleTestCase\n+import json\n from django.utils.functional import lazystr\n from django.utils.html import (\n     conditional_escape,\n@@ -217,7 +220,41 @@ class TestUtilsHtml(SimpleTestCase):\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n         )\n \n-    def test_smart_urlquote(self):\n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"hello\": \"world\"}'\n+\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"hello\": \"world\"}</script>',\n+        )\n+    \n+    def test_json_script_with_element_id(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return '{\"foo\": \"bar\"}'\n+\n+        self.assertHTMLEqual(\n+            json_script({\"test\": \"data\"}, element_id=\"custom_id\", encoder=CustomDjangoJSONEncoder),\n+            '<script id=\"custom_id\" type=\"application/json\">{\"foo\": \"bar\"}</script>',\n+        )\n+\n+    def test_json_script_default_encoder(self):\n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}),\n+            '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n+        )\n+\n+    def test_json_script_with_escaping(self):\n+        original_data = {\n+            \"a\": \"<script>alert('xss')</script>\",\n+            \"b\": \"&<>\"\n+        }\n+        expected_output = '<script type=\"application/json\">' \\\n+                          '{\"a\": \"\\\\u003Cscript\\\\u003Ealert(\\'xss\\')\\\\u003C/script\\\\u003E\", \"b\": \"\\\\u0026\\\\u003C\\\\u003E\"}' \\\n+                          '</script>'\n+        self.assertHTMLEqual(json_script(original_data), expected_output)\n         items = (\n             (\"http://\u00f6\u00e4\u00fc.com/\", \"http://xn--4ca9at.com/\"),\n             (\"http://\u00f6\u00e4\u00fc.com/\u00f6\u00e4\u00fc/\", \"http://xn--4ca9at.com/%C3%B6%C3%A4%C3%BC/\"),\n",
  "django__django-15790": "",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..49ff6d9 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -382,7 +382,12 @@ class ProxyModelTests(TestCase):\n             repr(resp), \"<ProxyImprovement: ProxyImprovement:improve that>\"\n         )\n \n-        # Select related + filter on a related proxy of proxy field\n+        # Non-crashing use of select_related and only with proxy models\n+    def test_select_related_only_on_proxy(self):\n+        proxy_custom = ProxyCustomModel.objects.create(name='John Doe')\n+        another_model = AnotherModel.objects.create(custom=proxy_custom)\n+        qs = AnotherModel.objects.select_related('custom').only('custom__name')\n+        self.assertEqual(qs.get(), another_model)\n         resp = ProxyImprovement.objects.select_related().get(\n             associated_bug__summary__icontains=\"fix\"\n         )\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..3069d04 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -157,7 +157,32 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n             ([\"psql\", \"dbname\", \"--help\"], None),\n         )\n \n-    @skipUnless(connection.vendor == \"postgresql\", \"Requires a PostgreSQL connection\")\n+    def test_parameters_order(self):\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env(\n+                {\n+                    \"NAME\": \"dbname\",\n+                    \"USER\": \"someuser\",\n+                    \"PASSWORD\": \"somepassword\",\n+                    \"HOST\": \"somehost\",\n+                    \"PORT\": \"444\",\n+                },\n+                [\"-c\", \"select * from some_table;\"]\n+            ),\n+            (\n+                [\"psql\", \"-U\", \"someuser\", \"-h\", \"somehost\", \"-p\", \"444\", \"-c\", \"select * from some_table;\", \"dbname\"],\n+                {\"PGPASSWORD\": \"somepassword\"},\n+            ),\n+        )\n+\n+    def test_parameters_only(self):\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({}, [\"-c\", \"select 1\"]),\n+            (\n+                [\"psql\", \"-c\", \"select 1\", \"postgres\"],\n+                None,\n+            ),\n+        )\n     def test_sigint_handler(self):\n         \"\"\"SIGINT is ignored in Python and passed to psql to abort queries.\"\"\"\n \n@@ -183,4 +208,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "",
  "django__django-16041": "",
  "django__django-16046": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 41aae41..f8597d3 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -1,3 +1,4 @@\n+\n from decimal import Decimal\n from sys import float_info\n \n@@ -160,7 +161,9 @@ class TestNumberFormat(SimpleTestCase):\n                     nformat(Decimal(value), \".\", decimal_pos), expected_value\n                 )\n \n-    def test_decimal_subclass(self):\n+    def test_empty(self):\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        self.assertEqual(nformat(None, \".\"), \"None\")\n         class EuroDecimal(Decimal):\n             \"\"\"\n             Wrapper for Decimal which prefixes each amount with the \u20ac symbol.\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..c600a18 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import re\n from unittest import mock\n@@ -24,6 +25,8 @@ from django.forms.fields import CharField, Field, IntegerField\n from django.test import SimpleTestCase, TestCase, override_settings\n from django.utils import translation\n from django.utils.text import capfirst\n+import urllib.parse\n+from django.urls import reverse\n from django.utils.translation import gettext as _\n \n from .models.custom_user import (\n@@ -884,7 +887,27 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # original hashed password contains $\n         self.assertIn(\"$\", form.cleaned_data[\"password\"])\n \n-    def test_bug_19349_bound_password_field(self):\n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field(self):\n+        user = User.objects.create(username=\"testuser\", uuid='22222222-3333-4444-5555-666677778888')\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search(r'<a href=\"(.*?)\">', password_help_text)\n+\n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.uuid,),\n+            current_app=user._meta.app_label,\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+            current_app=user._meta.app_label,\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n         user = User.objects.get(username=\"testclient\")\n         form = UserChangeForm(data={}, instance=user)\n         # When rendering the bound password field,\n",
  "django__django-16255": "",
  "django__django-16379": "",
  "django__django-16527": "",
  "django__django-16595": "",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..58cd502 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,3 +1,4 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n@@ -55,8 +56,23 @@ class JoinTests(SimpleTestCase):\n         )\n         self.assertEqual(output, \"alpha & beta &amp; me\")\n \n-\n-class FunctionTests(SimpleTestCase):\n+    @setup({\"join_autoescape_off\": '{% autoescape off %}{{ some_list|join:some_var }}{% endautoescape %}'})\n+    def test_join_autoescape_off(self):\n+        some_list = [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"]\n+        some_var = \"<br/>\"\n+        context = {\"some_list\": some_list, \"some_var\": some_var}\n+        output = self.engine.render_to_string(\"join_autoescape_off\", context)\n+        expected_result = \"<p>Hello World!</p><br/>beta & me<br/><script>Hi!</script>\"\n+        self.assertEqual(output, expected_result)\n+\n+    @setup({\"join_autoescape_on\": '{{ some_list|join:some_var }}'})\n+    def test_join_autoescape_on(self):\n+        some_list = [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"]\n+        some_var = \"<br/>\"\n+        context = {\"some_list\": some_list, \"some_var\": some_var}\n+        output = self.engine.render_to_string(\"join_autoescape_on\", context)\n+        expected_result = \"<p>Hello World!</p>&lt;br/&gt;beta & me&lt;br/&gt;<script>Hi!</script>\"\n+        self.assertEqual(output, expected_result)\n     def test_list(self):\n         self.assertEqual(join([0, 1, 2], \"glue\"), \"0glue1glue2\")\n \n@@ -78,4 +94,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..e87b8f7 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -569,7 +569,30 @@ class BulkCreateTests(TestCase):\n                 unique_fields=[\"big_auto_fields\"],\n             )\n \n-    def _test_update_conflicts_two_fields(self, unique_fields):\n+    @skipUnlessDBFeature(\"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\")\n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        TwoFields.objects.bulk_create(\n+            [\n+                TwoFields(f1=1, f2=1, name=\"initial1\"),\n+                TwoFields(f1=2, f2=2, name=\"initial2\"),\n+            ]\n+        )\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"updated1\"),\n+            TwoFields(f1=2, f2=2, name=\"updated2\"),\n+        ]\n+\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            update_fields=[\"name\"],\n+            unique_fields=[\"f1\", \"f2\"],\n+        )\n+        \n+        self.assertEqual(len(results), 2)\n+        for instance in results:\n+            self.assertIsNotNone(instance.pk)\n         TwoFields.objects.bulk_create(\n             [\n                 TwoFields(f1=1, f2=1, name=\"a\"),\n@@ -654,7 +677,29 @@ class BulkCreateTests(TestCase):\n     def test_update_conflicts_two_fields_no_unique_fields(self):\n         self._test_update_conflicts_two_fields([])\n \n-    def _test_update_conflicts_unique_two_fields(self, unique_fields):\n+    @skipUnlessDBFeature(\"supports_update_conflicts\", \"can_return_rows_from_bulk_insert\")\n+    def test_bulk_create_with_update_conflicts_returns_ids_new_rows(self):\n+        initial_data = [\n+            UpsertConflict(number=1, rank=1, name=\"John\"),\n+            UpsertConflict(number=2, rank=2, name=\"Mary\"),\n+        ]\n+        UpsertConflict.objects.bulk_create(initial_data)\n+\n+        updated_data = [\n+            UpsertConflict(number=1, rank=1, name=\"Steve\"),  # Conflict, update name\n+            UpsertConflict(number=3, rank=3, name=\"Hannah\"),  # New row\n+        ]\n+\n+        results = UpsertConflict.objects.bulk_create(\n+            updated_data,\n+            update_conflicts=True,\n+            update_fields=[\"name\"],\n+            unique_fields=[\"number\"],\n+        )\n+\n+        self.assertEqual(len(results), 2)\n+        for instance in results:\n+            self.assertIsNotNone(instance.pk)\n         Country.objects.bulk_create(self.data)\n         self.assertEqual(Country.objects.count(), 4)\n \n@@ -816,4 +861,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..6a58ff0 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -197,6 +197,35 @@ class OperationWriterTests(SimpleTestCase):\n             \"),\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -255,12 +284,70 @@ class WriterTests(SimpleTestCase):\n             decimal.Decimal(\"1.3\"), (\"Decimal('1.3')\", {\"from decimal import Decimal\"})\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n         self.assertSerializedEqual(Money(\"1.3\"))\n         self.assertSerializedResultEqual(\n             Money(\"1.3\"),\n             (\"migrations.test_writer.Money('1.3')\", {\"import migrations.test_writer\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -296,6 +383,35 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r\"^foo$\")\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -306,6 +422,35 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\n@@ -313,6 +458,35 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\n@@ -320,10 +494,68 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -331,11 +563,69 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(\n             default=TextEnum.B, choices=[(m.value, m) for m in TextEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -344,10 +634,68 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -356,9 +704,67 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         field = models.CharField(\n             default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -367,9 +773,67 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         field = models.IntegerField(\n             default=IntEnum.A, choices=[(m.value, m) for m in IntEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -379,6 +843,35 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n@@ -387,6 +880,35 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n@@ -394,9 +916,67 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -405,6 +985,35 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A | IntFlagEnum.B,\n             (\n@@ -414,6 +1023,35 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = \"A\", \"A value\"\n@@ -433,6 +1071,35 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             (\"datetime.date(1969, 7, 20)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         field = models.CharField(default=TextChoices.B, choices=TextChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -440,12 +1107,70 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -456,6 +1181,35 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_nested_class(self):\n         for nested_cls in [self.NestedEnum, self.NestedChoices]:\n             cls_name = nested_cls.__name__\n@@ -478,14 +1232,101 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {\"import uuid\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {\"import uuid\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n         field = models.UUIDField(\n             choices=((uuid_a, \"UUID A\"), (uuid_b, \"UUID B\")), default=uuid_a\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -495,6 +1336,35 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_pathlib(self):\n         # Pure path objects work in all platforms.\n         self.assertSerializedEqual(pathlib.PurePosixPath())\n@@ -523,6 +1393,35 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"models.FilePathField(path=pathlib.PurePosixPath('/home/user'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertIn(\"import pathlib\", imports)\n \n     def test_serialize_path_like(self):\n@@ -554,13 +1453,100 @@ class WriterTests(SimpleTestCase):\n         self.assertSerializedEqual(\n             datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone())\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedEqual(\n             datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180))\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc),\n             (\n@@ -568,6 +1554,35 @@ class WriterTests(SimpleTestCase):\n                 {\"import datetime\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             datetime.datetime(\n                 2012, 1, 1, 2, 1, tzinfo=zoneinfo.ZoneInfo(\"Europe/Paris\")\n@@ -578,12 +1593,70 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n@@ -593,20 +1666,136 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(\n             SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\")\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedResultEqual(\n             SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)), (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -624,6 +1813,35 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.RegexValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.serialize_round_trip(validator)\n \n         # Test with a compiled regex.\n@@ -633,6 +1851,35 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.serialize_round_trip(validator)\n \n         # Test a string regex with flag\n@@ -643,6 +1890,35 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[0-9]+$', \"\n             \"flags=re.RegexFlag['DOTALL'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n@@ -653,6 +1929,35 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', \"\n             \"'invalid')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.serialize_round_trip(validator)\n \n         # Test with a subclass.\n@@ -661,6 +1966,35 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.EmailValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.serialize_round_trip(validator)\n \n         validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(\n@@ -671,9 +2005,67 @@ class WriterTests(SimpleTestCase):\n             string, \"migrations.test_writer.EmailValidator(message='hello')\"\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n         validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(\n             message=\"hello\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n             MigrationWriter.serialize(validator)\n \n@@ -700,6 +2092,35 @@ class WriterTests(SimpleTestCase):\n             models.OrderBy(models.F(\"name\").desc()),\n             name=\"complex_func_index\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         string, imports = MigrationWriter.serialize(index)\n         self.assertEqual(\n             string,\n@@ -711,6 +2132,35 @@ class WriterTests(SimpleTestCase):\n             \"models.OrderBy(models.OrderBy(models.F('name'), descending=True)), \"\n             \"name='complex_func_index')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertEqual(imports, {\"from django.db import models\"})\n \n     def test_serialize_empty_nonempty_tuple(self):\n@@ -762,6 +2212,35 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.models\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         self.assertSerializedEqual(FoodManager(\"a\", \"b\"))\n         self.assertSerializedEqual(FoodManager(\"x\", \"y\", c=3, d=4))\n \n@@ -772,6 +2251,35 @@ class WriterTests(SimpleTestCase):\n             frozenset(\"cba\"), (\"frozenset(['a', 'b', 'c'])\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_serialize_set(self):\n         self.assertSerializedEqual(set())\n         self.assertSerializedResultEqual(set(), (\"set()\", set()))\n@@ -809,6 +2317,35 @@ class WriterTests(SimpleTestCase):\n             (\"('models.Model', {'from django.db import models'})\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -848,6 +2385,35 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [(\"testapp\", \"some_other_one\")],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         # We don't test the output formatting - that's too fragile.\n@@ -887,6 +2453,35 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -896,6 +2491,35 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_sorted_dependencies(self):\n         migration = type(\n             \"Migration\",\n@@ -912,6 +2536,35 @@ class WriterTests(SimpleTestCase):\n                 ],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         output = MigrationWriter(migration, include_header=False).as_string()\n         self.assertIn(\n             \"    dependencies = [\\n\"\n@@ -923,6 +2576,35 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -949,6 +2631,35 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -956,6 +2667,35 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -1001,6 +2741,35 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\"from django.db import migrations\\n\", output)\n@@ -1017,6 +2786,35 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls) -> list:\n+                    return [cls.BASIC]\n+\n+            capabilities = models.ArrayField(\n+                models.CharField(\n+                    max_length=30,\n+                    choices=Capability.choices,\n+                    blank=True,\n+                ),\n+                null=True,\n+                default=Capability.default,\n+            )\n+\n+        field_string, field_imports = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))\n+        self.assertEqual(\n+            field_string,\n+            \"migrations.test_writer.Profile.Capability.default\"\n+        )\n+        self.assertIn(\"import migrations.test_writer\", field_imports)\n+        \n+        self.serialize_round_trip(Profile.Capability.default)\n+\n     def test_register_serializer(self):\n         class ComplexSerializer(BaseSerializer):\n             def serialize(self):\n@@ -1032,4 +2830,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "matplotlib__matplotlib-22711": "",
  "matplotlib__matplotlib-23299": "",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..c28c588 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -11,7 +11,7 @@ from matplotlib import colors as mcolors\n from matplotlib.testing.decorators import image_comparison, check_figures_equal\n from matplotlib.testing.widgets import mock_event\n from matplotlib.collections import LineCollection, PolyCollection\n-from matplotlib.patches import Circle\n+from matplotlib.testing.decorators import check_figures_equal\n \n import matplotlib.pyplot as plt\n import numpy as np\n@@ -20,8 +20,14 @@ import numpy as np\n mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n+@check_figures_equal(extensions=[\"png\"])\n+def test_set_visible_3d_projection(fig_test, fig_ref):\n+    # Create a 3D subplot and set its visibility to False\n+    ax_test = fig_test.add_subplot(111, projection='3d')\n+    ax_test.set_visible(False)\n+    fig_ref.subplots()  # No 3D subplot for reference\n \n-def test_aspect_equal_error():\n+    # The test succeeds if the function behaves as expected\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     with pytest.raises(NotImplementedError):\n",
  "matplotlib__matplotlib-23562": "",
  "matplotlib__matplotlib-23563": "",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..feb65bb 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -774,6 +774,9 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n         assert mpl.colors.same_color(text.get_color(), color)\n \n \n+import matplotlib.pyplot as plt\n+import pytest\n+\n def test_get_set_draggable():\n     legend = plt.legend()\n     assert not legend.get_draggable()\n",
  "matplotlib__matplotlib-23964": "diff --git a/lib/matplotlib/tests/test_backend_ps.py b/lib/matplotlib/tests/test_backend_ps.py\nindex a1caf1a..2da7a2d 100644\n--- a/lib/matplotlib/tests/test_backend_ps.py\n+++ b/lib/matplotlib/tests/test_backend_ps.py\n@@ -246,7 +246,50 @@ def test_fonttype(fonttype):\n \n def test_linedash():\n     \"\"\"Test that dashed lines do not break PS output\"\"\"\n-    fig, ax = plt.subplots()\n+import io\n+from matplotlib.figure import Figure\n+import matplotlib.pyplot as plt\n+\n+def test_empty_line():\n+    # Smoke-test for gh#23954\n+    figure = Figure()\n+    figure.text(0.5, 0.5, \"\\nfoo\\n\\n\")\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='eps')\n+    buf.seek(0)\n+    assert buf.tell() > 0\n+    buf = io.BytesIO()\n+    figure.savefig(buf, format='ps')\n+    buf.seek(0)\n+    assert buf.tell() > 0\n+\n+def test_empty_line_in_annotation():\n+    # Test with annotation containing an empty line\n+    fig = Figure()\n+    ax = fig.add_subplot(111)\n+    ax.annotate(text='\\nLower label\\nLine after', xy=(0.5, 0.5))\n+    buf = io.BytesIO()\n+    fig.savefig(buf, format='eps')\n+    buf.seek(0)\n+    assert buf.tell() > 0\n+    buf = io.BytesIO()\n+    fig.savefig(buf, format='ps')\n+    buf.seek(0)\n+    assert buf.tell() > 0\n+\n+def test_title_with_empty_line():\n+    # Test with title containing an empty line\n+    fig = Figure()\n+    ax = fig.add_subplot(111)\n+    ax.set_title('Upper title\\n\\nLower title')\n+    buf = io.BytesIO()\n+    fig.savefig(buf, format='eps')\n+    buf.seek(0)\n+    assert buf.tell() > 0\n+    buf = io.BytesIO()\n+    fig.savefig(buf, format='ps')\n+    buf.seek(0)\n+    assert buf.tell() > 0\n \n     ax.plot([0, 1], linestyle=\"--\")\n \n",
  "matplotlib__matplotlib-23987": "diff --git a/lib/matplotlib/tests/test_constrainedlayout.py b/lib/matplotlib/tests/test_constrainedlayout.py\nindex 41fdfa1..bf5db7b 100644\n--- a/lib/matplotlib/tests/test_constrainedlayout.py\n+++ b/lib/matplotlib/tests/test_constrainedlayout.py\n@@ -647,7 +647,27 @@ def test_compressed1():\n     for ax in axs.flat:\n         pc = ax.imshow(np.random.randn(20, 20))\n \n-    fig.colorbar(pc, ax=axs)\n+import matplotlib.pyplot as plt\n+import pytest\n+\n+@pytest.mark.parametrize('params', [\n+    {'constrained_layout': False, 'expected_warning': False},\n+    {'constrained_layout': True, 'expected_warning': True},\n+    {'constrained_layout': {}, 'expected_warning': True},\n+])\n+def test_constrained_layout_with_subplots_adjust(params):\n+    fig, ax = plt.subplots(1, 2, figsize=(8, 2), constrained_layout=params['constrained_layout'])\n+    ax[0].plot(range(10), range(10))\n+    ax[1].plot(range(10), range(10))\n+\n+    # Check if warning is raised when subplots_adjust is called\n+    with pytest.warns(UserWarning, match=\"This figure was using a layout engine that is incompatible\") as record:\n+        plt.subplots_adjust(wspace=0)\n+\n+    if params['expected_warning']:\n+        assert len(record) > 0, \"Expected a UserWarning but none was raised.\"\n+    else:\n+        assert len(record) == 0, \"Expected no UserWarning but one was raised.\"\n     fig.draw_without_rendering()\n \n     pos = axs[0, 0].get_position()\n@@ -655,4 +675,4 @@ def test_compressed1():\n     np.testing.assert_allclose(pos.y1, 0.8537, atol=1e-3)\n     pos = axs[1, 2].get_position()\n     np.testing.assert_allclose(pos.x1, 0.8618, atol=1e-3)\n-    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n+    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "diff --git a/lib/matplotlib/tests/test_axes.py b/lib/matplotlib/tests/test_axes.py\nindex 64ba766..bde3747 100644\n--- a/lib/matplotlib/tests/test_axes.py\n+++ b/lib/matplotlib/tests/test_axes.py\n@@ -5732,7 +5732,33 @@ def test_set_get_ticklabels():\n     ax[1].set_yticklabels(ax[0].get_yticklabels())\n \n \n-@check_figures_equal(extensions=[\"png\"])\n+\n+def test_set_ticks_without_kwargs_or_labels():\n+    \"\"\"\n+    When no labels and no kwargs are passed, axis.set_ticks() should succeed.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [1, 2, 3]\n+    try:\n+        ax.xaxis.set_ticks(ticks)\n+    except Exception as e:\n+        pytest.fail(f\"set_ticks raised {type(e).__name__} unexpectedly!\")\n+\n+def test_set_ticks_with_valid_labels_and_kwargs():\n+    \"\"\"\n+    When valid labels and kwargs are passed, axis.set_ticks() should succeed\n+    and apply the text properties.\n+    \"\"\"\n+    fig, ax = plt.subplots()\n+    ticks = [1, 2, 3]\n+    labels = ['a', 'b', 'c']\n+    try:\n+        ax.xaxis.set_ticks(ticks, labels=labels, fontsize=12)\n+    except Exception as e:\n+        pytest.fail(f\"set_ticks raised {type(e).__name__} unexpectedly!\")\n+import pytest\n+import matplotlib.pyplot as plt\n+\n def test_set_ticks_with_labels(fig_test, fig_ref):\n     \"\"\"\n     Test that these two are identical::\n",
  "matplotlib__matplotlib-24970": "",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..c9a6944 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -106,7 +107,27 @@ def test_complete(fig_test, fig_ref):\n     plt.close(loaded)\n \n \n-def _pickle_load_subprocess():\n+def test_pickle_draggable_legend():\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111)\n+\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40, 43, 45, 47, 48]\n+\n+    ax.plot(time, speed, label=\"speed\")\n+    leg = ax.legend()\n+    leg.set_draggable(True)  # This line makes the legend draggable\n+    \n+    import pickletools\n+    pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+    \n+    # Ensure the non-picklable FigureCanvasQTAgg does not appear in the pickle stream\n+    assert \"FigureCanvasQTAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+    \n+    loaded_fig = pickle.loads(pkl)\n+    assert loaded_fig is not None  # Ensure the figure is loaded successfully\n+    \n+    plt.close(loaded_fig)\n     import os\n     import pickle\n \n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..2044d48 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -89,8 +89,32 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n+import matplotlib.pyplot as plt\n+import pickle\n+import pytest\n+from io import BytesIO\n \n-@mpl.style.context(\"default\")\n+@pytest.mark.parametrize(\"align_method\", [\"align_labels\", \"align_ylabels\"])\n+def test_pickle_with_aligned_labels(align_method):\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+\n+    # Call the alignment method to test pickling\n+    getattr(fig, align_method)()\n+\n+    # Attempt to pickle the figure\n+    pkl = BytesIO()\n+    pickle.dump(fig, pkl, pickle.HIGHEST_PROTOCOL)\n+    loaded = pickle.loads(pkl.getvalue())\n+    assert loaded is not None  # Ensure the figure is loaded successfully\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25442": "diff --git a/lib/matplotlib/tests/test_offsetbox.py b/lib/matplotlib/tests/test_offsetbox.py\nindex 204af9c..6d22628 100644\n--- a/lib/matplotlib/tests/test_offsetbox.py\n+++ b/lib/matplotlib/tests/test_offsetbox.py\n@@ -449,4 +449,40 @@ def test_paddedbox():\n     ta = TextArea(\"foobar\")\n     pb = PaddedBox(ta, pad=15, draw_frame=True)\n     ab = AnchoredOffsetbox('lower right', child=pb)\n-    ax.add_artist(ab)\n+    ax.add_artist(ab)\n+\n+import numpy as np\n+import matplotlib.pyplot as plt\n+import mplcursors\n+import pytest\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+@check_figures_equal()\n+def test_mplcursor_selection(fig_test, fig_ref):\n+    # Setup the figure and axes\n+    x = np.arange(1, 11)\n+    y1 = x\n+    \n+    ax_test = fig_test.add_subplot()\n+    ax_ref = fig_ref.add_subplot()\n+    \n+    # Create the test plot\n+    ax_test.scatter(x, y1)\n+    ax_ref.scatter(x, y1)\n+    \n+    # Initialize mplcursors\n+    cursor_test = mplcursors.cursor(ax_test)\n+    \n+    # Simulate clicking on points in the test plot\n+    for i in range(1, 4):\n+        event = MouseEvent('button_press_event', fig_test.canvas, x[i], y1[i])\n+        cursor_test._update(event)\n+    \n+    # Expected behavior: should not raise an error\n+    # The reference plot does nothing since we are not testing mplcursors there\n+    ax_ref.set_title(\"Reference Plot\")\n+    ax_test.set_title(\"Plot with mplcursors selections\")\n+\n+    # Assertions or checks would go here if needed\n+    # For example: Check no exceptions\n+    assert ax_test.get_title() == \"Plot with mplcursors selections\"\n",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\nindex 9aa3203..dc10a4a 100644\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -1,4 +1,5 @@\n \n+\n import numpy as np\n import pandas as pd\n \n@@ -10,11 +11,28 @@ from seaborn._stats.regression import PolyFit\n \n \n class TestPolyFit:\n+    from pandas.testing import assert_frame_equal\n \n     @pytest.fixture\n-    def df(self, rng):\n+    def df_with_nan(self, df):\n+        # Modify the original fixture to include NaN values\n+        df_with_nan = df.copy()\n+        df_with_nan.loc[df_with_nan.index[5:10], ['x', 'y']] = np.nan\n+        return df_with_nan\n+\n+    def test_missing_data(self, df_with_nan):\n+        \"\"\"Test PolyFit with missing data to ensure consistent results\"\"\"\n+\n+        groupby = GroupBy([\"group\"])\n+\n+        # Attempt PolyFit on data with NaNs\n+        res_with_nan = PolyFit()(df_with_nan[[\"x\", \"y\"]], groupby, \"x\", {})\n+\n+        # Perform PolyFit on data with NaNs removed\n+        res_without_nan = PolyFit()(df_with_nan[[\"x\", \"y\"]].dropna(), groupby, \"x\", {})\n \n-        n = 100\n+        # Verify that results are equal, meaning the NaN entries were handled correctly\n+        assert_frame_equal(res_with_nan, res_without_nan)\n         return pd.DataFrame(dict(\n             x=rng.normal(0, 1, n),\n             y=rng.normal(0, 1, n),\n",
  "mwaskom__seaborn-3190": "",
  "mwaskom__seaborn-3407": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\nindex b2e4a92..90a9ad2 100644\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -717,6 +717,32 @@ class TestPairGrid:\n                            a=np.repeat(list(\"abc\"), 20),\n                            b=np.repeat(list(\"abcdefghijkl\"), 5)))\n \n+    def test_multiindex_dataframe_pairplot(self):\n+        \"\"\"Test that a MultiIndex DataFrame does not raise KeyError with pairplot.\"\"\"\n+\n+        import numpy as np\n+        import pandas as pd\n+        import seaborn as sns\n+\n+        # Create a MultiIndex DataFrame\n+        data = {\n+            (\"A\", \"1\"): np.random.rand(100),\n+            (\"A\", \"2\"): np.random.rand(100),\n+            (\"B\", \"1\"): np.random.rand(100),\n+            (\"B\", \"2\"): np.random.rand(100),\n+        }\n+        df = pd.DataFrame(data)\n+        \n+        # Attempt to use pairplot on the MultiIndex DataFrame\n+        try:\n+            g = sns.pairplot(df)\n+        except KeyError as e:\n+            pytest.fail(f\"pairplot raised KeyError: {e}\")\n+\n+        # Ensure that the diagonal variables match the DataFrame columns\n+        expected_diag_vars = [(\"A\", \"1\"), (\"A\", \"2\"), (\"B\", \"1\"), (\"B\", \"2\")]\n+        assert g.diag_vars == expected_diag_vars\n+\n     def test_self_data(self):\n \n         g = ag.PairGrid(self.df)\n",
  "pallets__flask-4992": "",
  "psf__requests-1963": "",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..f7ce2d6 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1655,7 +1655,41 @@ def test_urllib3_retries():\n     with pytest.raises(RetryError):\n         s.get(httpbin('status/500'))\n \n-def test_vendor_aliases():\n+def test_urllib3_decode_error_wrapped():\n+    \"\"\"Test that a DecodeError from urllib3 is wrapped by requests' exceptions.\"\"\"\n+    import requests\n+    from requests.adapters import HTTPAdapter\n+    from requests.exceptions import ContentDecodingError\n+    from urllib3.exceptions import DecodeError\n+    import pytest\n+\n+    class MockHTTPAdapter(HTTPAdapter):\n+        def send(self, request, **kwargs):\n+            raise DecodeError(\"Mock DecodeError\")\n+\n+    s = requests.Session()\n+    s.mount('http://', MockHTTPAdapter())\n+\n+    with pytest.raises(ContentDecodingError):\n+        s.get('http://test_url_that_throws_mock_decode_error.org/')\n+\n+def test_urllib3_timeout_error_wrapped():\n+    \"\"\"Test that a TimeoutError from urllib3 is wrapped by requests' exceptions.\"\"\"\n+    import requests\n+    from requests.adapters import HTTPAdapter\n+    from requests.exceptions import ReadTimeout\n+    from urllib3.exceptions import TimeoutError\n+    import pytest\n+\n+    class MockHTTPAdapter(HTTPAdapter):\n+        def send(self, request, **kwargs):\n+            raise TimeoutError(\"Mock TimeoutError\")\n+\n+    s = requests.Session()\n+    s.mount('http://', MockHTTPAdapter())\n+\n+    with pytest.raises(ReadTimeout):\n+        s.get('http://test_url_that_throws_mock_timeout_error.org/')\n     from requests.packages import urllib3\n     from requests.packages import chardet\n \n@@ -1663,4 +1697,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 52d1693..64807c3 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -980,7 +980,38 @@ class TestRequests:\n         chunks = r.iter_content(decode_unicode=True)\n         assert all(isinstance(chunk, str) for chunk in chunks)\n \n-    def test_response_chunk_size_int(self):\n+    def test_iter_content_unicode_json(self):\n+        \"\"\"\n+        Test if iter_content returns unicode for a JSON mimetype with decode_unicode=True\n+        \"\"\"\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'{\"key\": \"value\"}')\n+        r.encoding = 'utf-8'\n+        chunks = list(r.iter_content(decode_unicode=True))\n+        assert ''.join(chunks) == '{\"key\": \"value\"}'\n+        assert all(isinstance(chunk, str) for chunk in chunks)\n+\n+    def test_iter_content_bytes_json(self):\n+        \"\"\"\n+        Test if iter_content returns bytes for a JSON mimetype with decode_unicode=False\n+        \"\"\"\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'{\"key\": \"value\"}')\n+        r.encoding = 'utf-8'\n+        chunks = list(r.iter_content(decode_unicode=False))\n+        assert ''.join(map(lambda x: x.decode('utf-8'), chunks)) == '{\"key\": \"value\"}'\n+        assert all(isinstance(chunk, bytes) for chunk in chunks)\n+\n+    def test_iter_content_no_encoding(self):\n+        \"\"\"\n+        Test iter_content with no encoding specified.\n+        \"\"\"\n+        r = requests.Response()\n+        r.raw = io.BytesIO(b'the content')\n+        r.encoding = None\n+        chunks = list(r.iter_content(decode_unicode=True))\n+        assert ''.join(chunks) == 'the content'\n+        assert all(isinstance(chunk, str) for chunk in chunks)\n         \"\"\"Ensure that chunk_size is passed as an integer, otherwise\n         raise a TypeError.\n         \"\"\"\n",
  "psf__requests-863": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 0ee4333..d133e31 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -743,8 +743,59 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n             assert 'foo' in response.text\n             assert 'bar' in response.text\n+    def test_hook_order_execution(self):\n+        \"\"\"Test that hooks are executed in the order they are added.\"\"\"\n+        execution_order = []\n \n-    def test_session_persistent_cookies(self):\n+        def first_hook(args):\n+            execution_order.append('first')\n+            return args\n+\n+        def second_hook(args):\n+            execution_order.append('second')\n+            return args\n+\n+        hooks = [first_hook, second_hook]\n+        r = requests.models.Request()\n+        r.register_hook('args', hooks)\n+        for hook in r.hooks['args']:\n+            hook({})  # Call hooks with empty dict for simplicity\n+\n+        assert execution_order == ['first', 'second'], f\"Expected execution order to be ['first', 'second'], but got {execution_order}\"\n+\n+    def test_hooks_with_varied_return_data(self):\n+        \"\"\"Test that hooks can handle situations where they modify their arguments differently.\"\"\"\n+        def add_foo_header(args):\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers']['X-Foo'] = 'foo'\n+            return args\n+\n+        def change_foo_to_bar(args):\n+            if 'headers' in args and 'X-Foo' in args['headers']:\n+                args['headers']['X-Foo'] = 'bar'\n+            return args\n+\n+        hooks = [add_foo_header, change_foo_to_bar]\n+        r = requests.models.Request(hooks={'args': hooks})\n+        result = {}\n+        for hook in r.hooks['args']:\n+            result = hook(result)\n+\n+        assert 'X-Foo' in result['headers'] and result['headers']['X-Foo'] == 'bar', f\"Expected hook modification to have 'X-Foo': 'bar', but got {result}\"\n+\n+    def test_no_hooks_called_with_empty_list(self):\n+        \"\"\"Ensure no hooks are called if an empty list is provided.\"\"\"\n+        def add_foo_header(args):\n+            assert False, \"This hook should not be called\"\n+\n+        hooks = []\n+        r = requests.models.Request(hooks={'args': hooks})\n+\n+        for hook in r.hooks['args']:\n+            hook({})  # Should not call any hooks\n+\n+        # If no assertion failure, the test passes\n \n         s = requests.session()\n \n",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..6c4a2a9 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -388,7 +388,7 @@ repr_da = xr.DataArray(\n def test_groupby_repr(obj, dim):\n     actual = repr(obj.groupby(dim))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over %r \" % dim\n+    expected += \", grouped over %r\" % dim\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj[dim])))\n     if dim == \"x\":\n         expected += \"1, 2, 3, 4, 5.\"\n@@ -405,7 +405,7 @@ def test_groupby_repr(obj, dim):\n def test_groupby_repr_datetime(obj):\n     actual = repr(obj.groupby(\"t.month\"))\n     expected = \"%sGroupBy\" % obj.__class__.__name__\n-    expected += \", grouped over 'month' \"\n+    expected += \", grouped over 'month'\"\n     expected += \"\\n%r groups with labels \" % (len(np.unique(obj.t.dt.month)))\n     expected += \"1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12.\"\n     assert actual == expected\n",
  "pylint-dev__pylint-5859": "",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..2e17162 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -79,6 +79,15 @@ def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n     assert \"E0015: Unrecognized option found: Q\" in output.out\n \n \n+\n+def test_no_traceback_for_unrecognized_option(capsys: CaptureFixture) -> None:\n+    \"\"\"Ensure no traceback is printed for unrecognized options.\"\"\"\n+    with pytest.raises(SystemExit):\n+        Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n+    output = capsys.readouterr()\n+    assert \"E0015: Unrecognized option found: Q\" in output.out\n+    assert \"Traceback\" not in output.err\n+\n def test_unknown_confidence(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly error an unknown confidence value.\"\"\"\n     with pytest.raises(SystemExit):\n",
  "pylint-dev__pylint-7080": "",
  "pylint-dev__pylint-7114": "diff --git a/tests/lint/unittest_lint.py b/tests/lint/unittest_lint.py\nindex 0dc6d1b..9db57b7 100644\n--- a/tests/lint/unittest_lint.py\n+++ b/tests/lint/unittest_lint.py\n@@ -934,6 +934,25 @@ print(submodule1)\n             linter.check([\"submodule2.py\"])\n     assert not linter.stats.by_msg\n \n+def test_lint_nested_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for the issue where pylint fails \n+    if a module contains a module of the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        linter.check([\"a\"])\n+    assert not linter.stats.by_msg\n+    \n+def test_lint_resolved_import(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for module import resolution issue with identically named module.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"from a import b\\n\")\n+        linter.check([\"r\", \"a\"])\n+    assert not linter.stats.by_msg\n+\n \n def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     \"\"\"Regression test for https://github.com/PyCQA/pylint/issues/1667\"\"\"\n@@ -941,4 +960,23 @@ def test_lint_namespace_package_under_dir(initialized_linter: PyLinter) -> None:\n     with tempdir():\n         create_files([\"outer/namespace/__init__.py\", \"outer/namespace/module.py\"])\n         linter.check([\"outer.namespace\"])\n-    assert not linter.stats.by_msg\n+    assert not linter.stats.by_msg\n+\n+def test_lint_nested_identically_named_module(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for the issue where pylint fails \n+    if a module contains a module of the same name.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\"])\n+        linter.check([\"a\"])\n+    assert not linter.stats.by_msg\n+    \n+def test_lint_resolved_import(initialized_linter: PyLinter) -> None:\n+    \"\"\"Test case for module import resolution issue with identically named module.\"\"\"\n+    linter = initialized_linter\n+    with tempdir():\n+        create_files([\"a/a.py\", \"a/b.py\", \"r.py\"])\n+        with open(\"r.py\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(\"from a import b\\n\")\n+        linter.check([\"r\", \"a\"])\n+    assert not linter.stats.by_msg\n",
  "pylint-dev__pylint-7993": "",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "diff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\nindex 9989033..5be5198 100644\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -298,6 +298,35 @@ class TestImportPath:\n         assert \"_src\" in sys.modules\n         assert \"_src.tests\" in sys.modules\n \n+    def test_importlib_does_not_double_imports(self, pytester: Pytester) -> None:\n+        \"\"\"Test that modules are not imported twice when using importlib.\"\"\"\n+        pytester.makepyfile(\n+            **{\n+                \"pmxbot/logging.py\": \"class Logger: store = 10\",\n+                \"tests/__init__.py\": \"\",\n+                \"tests/test_double_import.py\": \"\"\"\n+                    import importlib\n+                    from pmxbot import logging\n+                    \n+                    def test_logger_import():\n+                        mod = importlib.import_module('pmxbot.logging')\n+                        assert mod is logging\n+                        assert hasattr(logging.Logger, 'store')\n+                \"\"\"\n+            }\n+        )\n+\n+        pytester.makeini(\n+            \"\"\"\n+            [pytest]\n+            addopts=\n+                --doctest-modules\n+                --import-mode importlib\n+            \"\"\"\n+        )\n+        result = pytester.runpytest_subprocess()\n+        result.stdout.fnmatch_lines([\"*1 passed*\"])\n+\n     def test_importmode_twice_is_different_module(\n         self, simple_module: Path, tmp_path: Path\n     ) -> None:\n",
  "pytest-dev__pytest-5227": "diff --git a/src/_pytest/logging.py b/src/_pytest/logging.py\nindex 1ebe9d0..01f354c 100644\n--- a/src/_pytest/logging.py\n+++ b/src/_pytest/logging.py\n@@ -15,7 +15,7 @@ from _pytest.compat import dummy_context_manager\n from _pytest.config import create_terminal_writer\n from _pytest.pathlib import Path\n \n-DEFAULT_LOG_FORMAT = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n+DEFAULT_LOG_FORMAT = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n DEFAULT_LOG_DATE_FORMAT = \"%H:%M:%S\"\n \n \n",
  "pytest-dev__pytest-5495": "",
  "pytest-dev__pytest-5692": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3392814..a676e23 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1,7 +1,9 @@\n+\n import os\n from xml.dom import minidom\n \n-import py\n+import platform\n+from datetime import datetime\n \n import pytest\n from _pytest.junitxml import LogXML\n",
  "pytest-dev__pytest-7168": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 38e0b6b..b14e74a 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -144,6 +144,47 @@ def test_repr_on_newstyle():\n     assert saferepr(Function())\n \n \n+def test_broken_getattribute():\n+    \"\"\"saferepr() can create proper representations of classes with\n+    broken __getattribute__ (#7145)\n+    \"\"\"\n+\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError\n+\n+        def __repr__(self):\n+            raise RuntimeError\n+\n+    assert saferepr(SomeClass()).startswith(\n+        \"<[RuntimeError() raised in repr()] SomeClass object at 0x\"\n+    )\n+\n+\n+def test_broken_repr_only():\n+    \"\"\"Test saferepr with classes that have only __repr__ broken.\"\"\"\n+\n+    class OnlyBrokenRepr:\n+        def __repr__(self):\n+            raise RuntimeError(\"This is a broken __repr__\")\n+\n+    assert saferepr(OnlyBrokenRepr()).startswith(\n+        \"<[RuntimeError('This is a broken __repr__') raised in repr()] OnlyBrokenRepr object at 0x\"\n+    )\n+\n+\n+def test_broken_getattribute_only():\n+    \"\"\"Test saferepr with classes that have only __getattribute__ broken.\"\"\"\n+\n+    class OnlyBrokenGetAttribute:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError(\"This is a broken __getattribute__\")\n+\n+    assert saferepr(OnlyBrokenGetAttribute()).startswith(\n+        \"<[RuntimeError('This is a broken __getattribute__') raised in repr()] OnlyBrokenGetAttribute object at 0x\"\n+    )\n+\n+\n def test_unicode():\n     val = \"\u00a3\u20ac\"\n     reprval = \"'\u00a3\u20ac'\"\n@@ -153,4 +194,4 @@ def test_unicode():\n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n-    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n",
  "pytest-dev__pytest-7220": "diff --git a/testing/test_pytester.py b/testing/test_pytester.py\nindex 5ab5242..afa3e07 100644\n--- a/testing/test_pytester.py\n+++ b/testing/test_pytester.py\n@@ -71,6 +71,33 @@ def test_make_hook_recorder(testdir) -> None:\n     pytest.raises(ValueError, recorder.getfailures)\n \n \n+def test_failure_with_changed_cwd(testdir) -> None:\n+    \"\"\"\n+    Test failure lines should use absolute paths if cwd has changed since\n+    invocation, so the path is correct (#6428).\n+    \"\"\"\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import os\n+        import pytest\n+\n+        @pytest.fixture\n+        def private_dir():\n+            out_dir = 'ddd'\n+            os.mkdir(out_dir)\n+            old_dir = os.getcwd()\n+            os.chdir(out_dir)\n+            yield out_dir\n+            os.chdir(old_dir)\n+\n+        def test_show_wrong_path(private_dir):\n+            assert False\n+        \"\"\"\n+    )\n+    result = testdir.runpytest()\n+    result.stdout.fnmatch_lines([str(p) + \":*: AssertionError\", \"*1 failed in *\"])\n+\n+\n def test_parseconfig(testdir) -> None:\n     config1 = testdir.parseconfig()\n     config2 = testdir.parseconfig()\n",
  "pytest-dev__pytest-7373": "diff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 309636c..71d7d12 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -1,5 +1,7 @@\n import os\n import sys\n+import os\n+\n from unittest import mock\n \n import pytest\n",
  "pytest-dev__pytest-7432": "",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..6c966f7 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,3 +1,4 @@\n+\n import sys\n \n import pytest\n@@ -545,7 +546,30 @@ class TestXFail:\n         assert result.ret == (1 if strict else 0)\n \n \n-class TestXFailwithSetupTeardown:\n+def test_dynamic_xfail_set_during_runtest_failed(testdir: Testdir) -> None:\n+    # Issue related to adding xfail marker dynamically during test run\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import pytest\n+        def test_this(request):\n+            request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+            assert 0\n+        \"\"\"\n+    )\n+    result = testdir.runpytest(p)\n+    result.assert_outcomes(xfailed=1)\n+\n+def test_dynamic_xfail_set_during_runtest_passed_strict(testdir: Testdir) -> None:\n+    # Ensure that a strict xfail set dynamically causes a failure\n+    p = testdir.makepyfile(\n+        \"\"\"\n+        import pytest\n+        def test_this(request):\n+            request.node.add_marker(pytest.mark.xfail(reason=\"xfail\", strict=True))\n+        \"\"\"\n+    )\n+    result = testdir.runpytest(p)\n+    result.assert_outcomes(failed=1)\n     def test_failing_setup_issue9(self, testdir):\n         testdir.makepyfile(\n             \"\"\"\n",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..adf6d2e 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,5 +1,46 @@\n+\n import os\n import stat\n+from _pytest.monkeypatch import MonkeyPatch\n+from _pytest.tmpdir import TempPathFactory\n+import pytest\n+\n+# Existing test from the original patch\n+def test_tmp_path_factory_handles_invalid_dir_characters(\n+    tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch\n+) -> None:\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"os/<:*?;>agnostic\")\n+    # _basetemp / _given_basetemp are cached / set in parallel runs, patch them\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"pytest-of-unknown\" in str(p)\n+\n+# Additional test for domain-style usernames\n+def test_tmpdir_factory_with_domain_usernames(tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch) -> None:\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"contoso\\\\john_doe\")\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"pytest-of-john_doe\" in str(p)\n+\n+# Test for handling environment variable override\n+def test_tmpdir_factory_with_env_override(tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch) -> None:\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"user_with_specials\")\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    monkeypatch.setenv(\"PYTEST_DEBUG_TEMPROOT\", \"custom_basetemp\")\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"custom_basetemp\" in str(p)\n+\n+# Test simple username without illegal characters to ensure existing functionality is unaffected\n+def test_tmpdir_factory_simple_username(tmp_path_factory: TempPathFactory, monkeypatch: MonkeyPatch) -> None:\n+    monkeypatch.setattr(\"getpass.getuser\", lambda: \"simple_user\")\n+    monkeypatch.setattr(tmp_path_factory, \"_basetemp\", None)\n+    monkeypatch.setattr(tmp_path_factory, \"_given_basetemp\", None)\n+    p = tmp_path_factory.getbasetemp()\n+    assert \"pytest-of-simple_user\" in str(p)\n+\n import sys\n from pathlib import Path\n from typing import Callable\n",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..7455ceb 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -597,6 +597,43 @@ def test_ridgecv_store_cv_values():\n     r.fit(x, y)\n     assert_equal(r.cv_values_.shape, (n_samples, n_responses, n_alphas))\n \n+def test_ridge_classifier_cv_store_cv_values():\n+    from sklearn.linear_model import RidgeClassifierCV\n+    import numpy as np\n+\n+    # Test data setup\n+    x = np.array([[-1.0, -1.0], [-1.0, 0], [-0.8, -1.0],\n+                  [1.0, 1.0], [1.0, 0.0]])\n+    y = np.array([1, 1, 1, -1, -1])\n+\n+    n_samples = x.shape[0]\n+    alphas = [1e-1, 1e0, 1e1]\n+    n_alphas = len(alphas)\n+\n+    # Instantiate RidgeClassifierCV with store_cv_values=True\n+    r = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+\n+    # When y has one target (1D array)\n+    n_targets = 1\n+    r.fit(x, y)\n+    assert r.cv_values_.shape == (n_samples, n_targets, n_alphas), \\\n+           \"cv_values_ shape mismatch for 1D y\"\n+\n+    # When y has multiple targets (2D array)\n+    y = np.array([[1, 1, 1, -1, -1],\n+                  [1, -1, 1, -1, 1],\n+                  [-1, -1, 1, -1, -1]]).transpose()\n+    n_targets = y.shape[1]\n+    r.fit(x, y)\n+    assert r.cv_values_.shape == (n_samples, n_targets, n_alphas), \\\n+           \"cv_values_ shape mismatch for 2D y\"\n+\n+    # Test when cv is not None and store_cv_values is True (should raise error)\n+    try:\n+        r = RidgeClassifierCV(alphas=alphas, store_cv_values=True, cv=3)\n+        r.fit(x, y)\n+    except ValueError as e:\n+        assert str(e).startswith(\"cv!=None and store_cv_values=True are incompatible\")\n \n def test_ridgecv_sample_weight():\n     rng = np.random.RandomState(0)\n",
  "scikit-learn__scikit-learn-11281": "diff --git a/sklearn/mixture/tests/test_bayesian_mixture.py b/sklearn/mixture/tests/test_bayesian_mixture.py\nindex a9d82b7..3fc8686 100644\n--- a/sklearn/mixture/tests/test_bayesian_mixture.py\n+++ b/sklearn/mixture/tests/test_bayesian_mixture.py\n@@ -8,7 +8,8 @@ from scipy.special import gammaln\n from sklearn.utils.testing import assert_raise_message\n from sklearn.utils.testing import assert_almost_equal\n \n-from sklearn.mixture.bayesian_mixture import _log_dirichlet_norm\n+from sklearn.metrics.cluster import adjusted_rand_score\n+from sklearn.utils.testing import assert_array_equal, assert_raise_message, assert_greater_equal\n from sklearn.mixture.bayesian_mixture import _log_wishart_norm\n \n from sklearn.mixture import BayesianGaussianMixture\n",
  "scikit-learn__scikit-learn-12471": "",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex f8e4d54..cf54d43 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -598,7 +598,13 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n \n-def test_gaussian_mixture_fit():\n+def test_gaussian_mixture_fit_predict_n_init():\n+    # Check that fit_predict is equivalent to fit.predict, when n_init > 1\n+    X = np.random.RandomState(0).randn(1000, 5)\n+    gm = GaussianMixture(n_components=5, n_init=5, random_state=0)\n+    y_pred1 = gm.fit_predict(X)\n+    y_pred2 = gm.predict(X)\n+    assert_array_equal(y_pred1, y_pred2)\n     # recover the ground truth\n     rng = np.random.RandomState(0)\n     rand_data = RandomData(rng)\n",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..e2a525e 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,10 +1,11 @@\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n \n from sklearn.utils.testing import (assert_array_almost_equal, assert_less,\n                                    assert_equal, assert_not_equal,\n-                                   assert_raises)\n+                                   assert_raises, assert_allclose)\n \n from sklearn.decomposition import PCA, KernelPCA\n from sklearn.datasets import make_circles\n@@ -70,8 +71,18 @@ def test_kernel_pca_consistent_transform():\n     transformed2 = kpca.transform(X_copy)\n     assert_array_almost_equal(transformed1, transformed2)\n \n-\n-def test_kernel_pca_sparse():\n+def test_kernel_pca_sign_invariance():\n+    rng = np.random.RandomState(42)\n+    X = rng.rand(10, 10)\n+    \n+    kpca = KernelPCA(n_components=7, kernel='rbf', random_state=42)\n+    transformed1 = kpca.fit_transform(X)\n+    \n+    # Running again to check for sign invariance\n+    kpca = KernelPCA(n_components=7, kernel='rbf', random_state=42)\n+    transformed2 = kpca.fit_transform(X)\n+\n+    assert_allclose(np.abs(transformed1), np.abs(transformed2), atol=1e-7)\n     rng = np.random.RandomState(0)\n     X_fit = sp.csr_matrix(rng.random_sample((5, 4)))\n     X_pred = sp.csr_matrix(rng.random_sample((2, 4)))\n",
  "scikit-learn__scikit-learn-13439": "diff --git a/sklearn/tests/test_pipeline.py b/sklearn/tests/test_pipeline.py\nindex 318940e..c45226a 100644\n--- a/sklearn/tests/test_pipeline.py\n+++ b/sklearn/tests/test_pipeline.py\n@@ -1058,6 +1058,27 @@ def test_pipeline_memory():\n         shutil.rmtree(cachedir)\n \n \n+def test_pipeline_length():\n+    from sklearn.pipeline import Pipeline\n+    from sklearn.feature_selection import SelectKBest\n+    from sklearn.feature_selection import f_regression\n+    from sklearn.svm import SVC\n+\n+    anova_filter = SelectKBest(f_regression, k=5)\n+    clf = SVC(kernel='linear')\n+    pipeline = Pipeline([('anova', anova_filter), ('svc', clf)])\n+\n+    # Test the length of the pipeline\n+    assert len(pipeline) == 2\n+\n+    # Test length with a single step\n+    single_step_pipeline = Pipeline([('svc', clf)])\n+    assert len(single_step_pipeline) == 1\n+\n+    # Test length with no steps\n+    no_step_pipeline = Pipeline([])\n+    assert len(no_step_pipeline) == 0\n+\n def test_make_pipeline_memory():\n     cachedir = mkdtemp()\n     if LooseVersion(joblib_version) < LooseVersion('0.12'):\n@@ -1070,4 +1091,4 @@ def test_make_pipeline_memory():\n     pipeline = make_pipeline(DummyTransf(), SVC())\n     assert pipeline.memory is None\n \n-    shutil.rmtree(cachedir)\n+    shutil.rmtree(cachedir)\n",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..f4289c2 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -9,6 +10,8 @@ Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n import pytest\n \n import numpy as np\n+from sklearn.ensemble import IsolationForest\n+from sklearn.utils import check_random_state\n \n from sklearn.utils.testing import assert_array_equal\n from sklearn.utils.testing import assert_array_almost_equal\n",
  "scikit-learn__scikit-learn-13497": "diff --git a/sklearn/feature_selection/tests/test_mutual_info.py b/sklearn/feature_selection/tests/test_mutual_info.py\nindex f5a2908..237b2ce 100644\n--- a/sklearn/feature_selection/tests/test_mutual_info.py\n+++ b/sklearn/feature_selection/tests/test_mutual_info.py\n@@ -172,8 +172,30 @@ def test_mutual_info_classif_mixed():\n         # The MI should be the same\n         assert_equal(mi_nn[2], mi[2])\n \n+def test_mutual_info_with_discrete_features():\n+    X = np.array([[0, 1, 2],\n+                  [1, 0, 1],\n+                  [2, 1, 0],\n+                  [1, 1, 1],\n+                  [0, 0, 0]], dtype=float)\n+    y = np.array([1, 0, 1, 0, 1], dtype=float)\n+    X_csr = csr_matrix(X)\n+\n+    for mutual_info in (mutual_info_regression, mutual_info_classif):\n+        # Test with an array of indices\n+        mi_1 = mutual_info(X, y, discrete_features=[0, 2], random_state=0)\n+        mi_2 = mutual_info(X, y, discrete_features=[True, False, True], random_state=0)\n+        assert_array_equal(mi_1, mi_2)\n+\n+        # Test with a boolean mask that has too many values\n+        assert_raises(IndexError, mutual_info, X, y, discrete_features=[True, False, True, False])\n+\n+        # Test with an invalid index\n+        assert_raises(IndexError, mutual_info, X, y, discrete_features=[1, 4])\n \n-def test_mutual_info_options():\n+        # Test with sparse matrix and boolean mask\n+        mi_3 = mutual_info(X_csr, y, discrete_features=[True, False, True], random_state=0)\n+        assert_array_equal(mi_2, mi_3)\n     X = np.array([[0, 0, 0],\n                   [1, 1, 0],\n                   [2, 0, 1],\n@@ -197,4 +219,4 @@ def test_mutual_info_options():\n         assert_array_equal(mi_1, mi_2)\n         assert_array_equal(mi_3, mi_4)\n \n-    assert not np.allclose(mi_1, mi_3)\n+    assert not np.allclose(mi_1, mi_3)\n",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..16187d5 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,3 +1,4 @@\n+\n import re\n from pprint import PrettyPrinter\n \n@@ -214,6 +215,17 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n \n     set_config(print_changed_only=False)\n \n+def test_logistic_regression_cv_array():\n+    \"\"\"Test LogisticRegressionCV with array input for Cs doesn't raise ValueError.\"\"\"\n+    from sklearn.linear_model import LogisticRegressionCV\n+    import numpy as np\n+    import sklearn\n+\n+    sklearn.set_config(print_changed_only=True)\n+    repr_str = repr(LogisticRegressionCV(Cs=np.array([0.1, 1])))\n+    assert isinstance(repr_str, str)\n+    assert 'Cs=array([0.1, 1.0])' in repr_str\n+\n \n def test_pipeline():\n     # Render a pipeline object\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..dd60272 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n@@ -8,6 +9,7 @@ from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_equal\n from sklearn.utils.testing import assert_raise_message\n from sklearn.exceptions import NotFittedError\n+from sklearn.datasets import load_iris, load_diabetes\n from sklearn.linear_model import LogisticRegression\n from sklearn.naive_bayes import GaussianNB\n from sklearn.ensemble import RandomForestClassifier\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "diff --git a/sklearn/neighbors/tests/test_nca.py b/sklearn/neighbors/tests/test_nca.py\nindex 3963eca..271734c 100644\n--- a/sklearn/neighbors/tests/test_nca.py\n+++ b/sklearn/neighbors/tests/test_nca.py\n@@ -161,7 +161,27 @@ def test_params_validation():\n                          NCA(n_components=n_components).fit, X, y)\n \n \n-def test_transformation_dimensions():\n+import pytest\n+import numpy as np\n+from sklearn.neighbors import NeighborhoodComponentsAnalysis\n+from sklearn.utils.testing import assert_raises\n+\n+@pytest.mark.parametrize(\"param, value\", [\n+    ('tol', np.float64(1.0)),\n+    ('tol', np.int64(1)),  # should be cast to float\n+    ('n_components', np.int64(5)),  # should be cast to int\n+    ('max_iter', np.int64(100)),  # should be cast to int\n+])\n+def test_nca_accepts_numpy_types(param, value):\n+    # Test that NCA accepts numpy types without raising TypeError\n+    X = np.random.random((10, 5))\n+    y = np.random.randint(0, 2, 10)\n+    nca_params = {param: value}\n+    nca = NeighborhoodComponentsAnalysis(**nca_params)\n+    try:\n+        nca.fit(X, y)\n+    except TypeError as e:\n+        pytest.fail(f\"NCA raised TypeError unexpectedly for param {param} with value {value}: {e}\")\n     X = np.arange(12).reshape(4, 3)\n     y = [1, 1, 2, 2]\n \n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..7ef2098 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -679,6 +679,50 @@ def test_unicode_kernel():\n                                 kernel='linear',\n                                 random_seed=0)\n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for #14893\n+    import numpy as np\n+    from scipy import sparse\n+    from sklearn import svm\n+\n+    X_train = sparse.csr_matrix([[0, 1, 0, 0],\n+                                 [0, 0, 0, 1],\n+                                 [0, 0, 1, 0],\n+                                 [0, 0, 0, 1]])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    assert not model.support_vectors_.data.size\n+    assert not model.dual_coef_.data.size\n+\n+def test_sparse_fit_empty_data():\n+    # Test SVM with entirely empty sparse dataset\n+    import numpy as np\n+    from scipy import sparse\n+    from sklearn import svm\n+\n+    X_train = sparse.csr_matrix((0, 4))  # Empty sparse matrix with 4 features\n+    y_train = np.array([])  # Empty labels\n+    model = svm.SVR(kernel='linear')\n+\n+    try:\n+        model.fit(X_train, y_train)\n+    except ValueError as e:\n+        assert \"has 0 samples\" in str(e)\n+\n+def test_sparse_fit_single_sample():\n+    # Test SVM with a single sample in sparse format\n+    import numpy as np\n+    from scipy import sparse\n+    from sklearn import svm\n+\n+    X_train = sparse.csr_matrix([[0, 0, 0, 1]])  # Single sample sparse matrix\n+    y_train = np.array([0.1])  # Single label\n+    model = svm.SVR(kernel='linear')\n+    model.fit(X_train, y_train)\n+    assert model.support_vectors_.data.size == 1\n+    assert model.dual_coef_.data.size == 1\n+\n \n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n",
  "scikit-learn__scikit-learn-14983": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex dd52c66..525cc20 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -972,7 +972,16 @@ def test_leave_one_p_group_out_error_on_fewer_number_of_groups():\n                          LeavePGroupsOut(n_groups=3).split(X, y, groups))\n \n \n-@ignore_warnings\n+import pytest\n+from sklearn.model_selection import RepeatedKFold, RepeatedStratifiedKFold\n+\n+@pytest.mark.parametrize(\"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold])\n+def test_repeated_cv_repr(RepeatedCV):\n+    n_splits, n_repeats = 2, 6\n+    repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats)\n+    repeated_cv_repr = ('{}(n_repeats=6, n_splits=2, random_state=None)'\n+                        .format(repeated_cv.__class__.__name__))\n+    assert repeated_cv_repr == repr(repeated_cv)\n def test_repeated_cv_value_errors():\n     # n_repeats is not integer or <= 0\n     for cv in (RepeatedKFold, RepeatedStratifiedKFold):\n",
  "scikit-learn__scikit-learn-15512": "",
  "scikit-learn__scikit-learn-15535": "",
  "scikit-learn__scikit-learn-25500": "diff --git a/sklearn/tests/test_isotonic.py b/sklearn/tests/test_isotonic.py\nindex 5021282..a55ffa7 100644\n--- a/sklearn/tests/test_isotonic.py\n+++ b/sklearn/tests/test_isotonic.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n import numpy as np\n import pickle\n@@ -6,6 +7,8 @@ import copy\n import pytest\n \n from sklearn.datasets import make_regression\n+from sklearn import set_config\n+from sklearn.datasets import make_classification\n from sklearn.isotonic import (\n     check_increasing,\n     isotonic_regression,\n@@ -679,4 +682,25 @@ def test_get_feature_names_out(shape):\n     names = iso.get_feature_names_out()\n     assert isinstance(names, np.ndarray)\n     assert names.dtype == object\n+\n+\n+def test_calibrated_classifier_with_isotonic_and_pandas_output():\n+    \"\"\"Test CalibratedClassifierCV with isotonic regression and pandas output.\"\"\"\n+    import pandas as pd  # Import pandas for type checking\n+    from sklearn.linear_model import SGDClassifier\n+    from sklearn.calibration import CalibratedClassifierCV\n+\n+    set_config(transform_output=\"pandas\")\n+    X, y = make_classification(n_samples=30, n_features=3, random_state=42)\n+    model = CalibratedClassifierCV(SGDClassifier(), method='isotonic')\n+    model.fit(X, y)\n+\n+    # Ensure that predict_proba works without errors and returns a DataFrame\n+    proba = model.predict_proba(X)\n+    assert isinstance(proba, np.ndarray)\n+\n+    # Ensure that predict works without errors\n+    preds = model.predict(X)\n+    assert isinstance(preds, np.ndarray)\n+    assert preds.shape == (X.shape[0],)\n     assert_array_equal([\"isotonicregression0\"], names)\n",
  "scikit-learn__scikit-learn-25570": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex 23e3b97..516f4e1 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -2121,6 +2121,34 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n     with pytest.raises(AttributeError, match=\"not provide get_feature_names_out\"):\n         ct.get_feature_names_out()\n \n+@pytest.mark.parametrize(\n+    \"empty_selection\",\n+    [[], np.array([False, False, False]), [False, False, False]],\n+    ids=[\"empty_list\", \"empty_np_bool_array\", \"empty_bool_list\"],\n+)\n+def test_empty_selection_column_transformer_with_pandas_output(empty_selection):\n+    \"\"\"Check that pandas output works when there is an empty selection.\n+\n+    Ensures transformers with no features are ignored properly.\n+    \"\"\"\n+    pd = pytest.importorskip(\"pandas\")\n+\n+    X = pd.DataFrame([[5.0, 6.0, 7.0], [8.0, 9.0, 10.0]], columns=[\"a\", \"b\", \"c\"])\n+    ct = ColumnTransformer(\n+        [\n+            (\"categorical\", \"passthrough\", empty_selection),\n+            (\"numerical\", StandardScaler(), [\"a\", \"b\", \"c\"]),\n+        ],\n+        verbose_feature_names_out=True,\n+    )\n+    ct.set_output(transform=\"pandas\")\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"numerical__a\", \"numerical__b\", \"numerical__c\"])\n+\n+    ct.set_params(verbose_feature_names_out=False)\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"a\", \"b\", \"c\"])\n+\n     # The feature names are prefixed because verbose_feature_names_out=True is default\n     ct.set_output(transform=\"pandas\")\n     X_trans_df0 = ct.fit_transform(X_df)\n@@ -2128,4 +2156,4 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n \n     ct.set_params(verbose_feature_names_out=False)\n     X_trans_df1 = ct.fit_transform(X_df)\n-    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n+    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n",
  "sphinx-doc__sphinx-10325": "diff --git a/tests/test_ext_autodoc_automodule.py b/tests/test_ext_autodoc_automodule.py\nindex 787cd0c..7f1ac6b 100644\n--- a/tests/test_ext_autodoc_automodule.py\n+++ b/tests/test_ext_autodoc_automodule.py\n@@ -113,6 +113,66 @@ def test_automodule_special_members(app):\n     ]\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_automodule_inherited_members_multiple_classes(app):\n+    \"\"\"Test if automodule can ignore multiple classes for inherited members.\"\"\"\n+    options = {\n+        'members': None,\n+        'undoc-members': None,\n+        'inherited-members': 'Base, list, tuple'\n+    }\n+    actual = do_autodoc(app, 'module', 'target.inheritance', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.inheritance',\n+        '',\n+        '',\n+        '.. py:class:: Base()',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedclassmeth()',\n+        '      :module: target.inheritance',\n+        '      :classmethod:',\n+        '',\n+        '      Inherited class method.',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedmeth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      Inherited function.',\n+        '',\n+        '',\n+        '   .. py:method:: Base.inheritedstaticmeth(cls)',\n+        '      :module: target.inheritance',\n+        '      :staticmethod:',\n+        '',\n+        '      Inherited static method.',\n+        '',\n+        '',\n+        '.. py:class:: Derived()',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        '   .. py:method:: Derived.inheritedmeth()',\n+        '      :module: target.inheritance',\n+        '',\n+        '      Inherited function.',\n+        '',\n+        '',\n+        '.. py:class:: MyList',\n+        '   :module: target.inheritance',\n+        '',\n+        '',\n+        \"   .. py:method:: MyList.meth()\",\n+        '      :module: target.inheritance',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+\n @pytest.mark.sphinx('html', testroot='ext-autodoc',\n                     confoverrides={'autodoc_mock_imports': ['missing_module',\n                                                             'missing_package1',\n@@ -125,4 +185,225 @@ def test_subclass_of_mocked_object(app):\n \n     options = {'members': None}\n     actual = do_autodoc(app, 'module', 'target.need_mocks', options)\n-    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+    assert '.. py:class:: Inherited(*args: ~typing.Any, **kwargs: ~typing.Any)' in actual\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n",
  "sphinx-doc__sphinx-7975": "",
  "sphinx-doc__sphinx-8435": "diff --git a/tests/test_ext_autodoc_configs.py b/tests/test_ext_autodoc_configs.py\nindex 21b6a7e..c632473 100644\n--- a/tests/test_ext_autodoc_configs.py\n+++ b/tests/test_ext_autodoc_configs.py\n@@ -714,7 +714,7 @@ def test_autodoc_type_aliases(app):\n         '',\n     ]\n \n-    # define aliases\n+    # define aliases for myint\n     app.config.autodoc_type_aliases = {'myint': 'myint'}\n     actual = do_autodoc(app, 'module', 'target.annotations', options)\n     assert list(actual) == [\n",
  "sphinx-doc__sphinx-8506": "",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..ca3f377 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -21,6 +21,7 @@ from sphinx.ext.autodoc import ALL, ModuleLevelDocumenter, Options\n from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n from sphinx.testing.util import SphinxTestApp, Struct  # NOQA\n from sphinx.util.docutils import LoggingReporter\n+from .test_ext_autodoc import do_autodoc\n \n try:\n     # Enable pyximport to test cython module\n@@ -45,6 +46,20 @@ def do_autodoc(app, objtype, name, options=None):\n     return bridge.result\n \n \n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_empty_all_correctness(app):\n+    \"\"\"Test that an empty __all__ attribute causes no module members to be documented.\"\"\"\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.empty_all', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.empty_all',\n+        '',\n+        'docsting of empty_all module.',\n+        '',\n+    ]\n+\n+\n def make_directive_bridge(env):\n     options = Options(\n         inherited_members = False,\n",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..2ae4800 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -10,6 +11,7 @@\n \n import sys\n from numbers import Integral\n+from struct import Struct\n from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tuple, TypeVar,\n                     Union)\n \n@@ -44,6 +46,8 @@ def test_restify():\n     assert restify(None) == \":obj:`None`\"\n     assert restify(Integral) == \":class:`numbers.Integral`\"\n     assert restify(Any) == \":obj:`Any`\"\n+    # Test for struct.Struct resolution\n+    assert restify(Struct) == \":class:`struct.Struct`\"\n \n \n def test_restify_type_hints_containers():\n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..d223f75 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1455,10 +1455,34 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n         expected = \"\"\"\\\n :param param1:\n :type param1: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+    def test_other_parameters_with_config(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+    Description of param2.\n+\n+\"\"\"\n+\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param2** (:class:`MyClass <name.space.MyClass>` instance)\n+    Description of param2.\n \"\"\"\n         self.assertEqual(expected, actual)\n \n-    def test_multiple_parameters(self):\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters:  \n+:param param2:\n+:type param2: :class:`MyClass <name.space.MyClass>` instance\n+    Description of param2.\n+\"\"\"\n+        self.assertEqual(expected, actual)\n         docstring = \"\"\"\\\n Parameters\n ----------\n",
  "sphinx-doc__sphinx-8721": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\nindex d4fba47..a254701 100644\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -60,6 +60,16 @@ def test_linkcode(app, status, warning):\n     assert 'http://foobar/c/' in stuff\n     assert 'http://foobar/cpp/' in stuff\n \n+import pytest\n+from pathlib import Path\n+\n+@pytest.mark.sphinx('epub', testroot='ext-viewcode', confoverrides={'viewcode_enable_epub': False})\n+def test_viewcode_epub_disabled(app, status, warning):\n+    # Build the epub with viewcode disabled for epub\n+    app.builder.build_all()\n+    \n+    # The '_modules/spam/mod1.xhtml' file should not exist when viewcode is disabled\n+    assert not (app.outdir / '_modules/spam/mod1.xhtml').exists(), \"viewcode files should not be present in epub when disabled\"\n \n @pytest.mark.sphinx(testroot='ext-viewcode-find')\n def test_local_source_files(app, status, warning):\n",
  "sympy__sympy-12481": "diff --git a/sympy/combinatorics/tests/test_permutations.py b/sympy/combinatorics/tests/test_permutations.py\nindex 58cf643..be1069f 100644\n--- a/sympy/combinatorics/tests/test_permutations.py\n+++ b/sympy/combinatorics/tests/test_permutations.py\n@@ -321,8 +321,35 @@ def test_mul():\n         h2 = _af_rmuln(*a[:i + 1])\n         assert h == h2\n \n-\n-def test_args():\n+def test_non_disjoint_cycles():\n+    # Test with overlapping cycles that should result in the identity permutation\n+    assert Permutation([[0, 1], [0, 1]]) == Permutation([0, 1])\n+    \n+    # Test with overlapping cycles that should result in a specific permutation\n+    assert Permutation([[0, 1], [1, 2]]) == Permutation([1, 2, 0])\n+\n+    # Test with non-disjoint but non-overlapping cycles\n+    assert Permutation([[0, 2], [1, 3], [2, 4]]) == Permutation([2, 0, 4, 3, 1])\n+\n+    # Test with disjoint cycles to ensure they still work\n+    assert Permutation([[0, 1], [2, 3]]) == Permutation([1, 0, 3, 2])\n+    \n+    # Test with multiple cycles affecting the same element\n+    assert Permutation([[0, 1], [1, 2], [2, 3]]) == Permutation([1, 2, 3, 0])\n+\n+    # Test with identity cycles\n+    assert Permutation([[0, 0], [1, 1]]) == Permutation([0, 1])\n+    \n+    # Larger cycle mixed with smaller cycle\n+    assert Permutation([[0, 1, 2, 3], [2, 4]]) == Permutation([1, 2, 4, 0, 3])\n+\n+    # Single-element cycles (should remain unchanged)\n+    assert Permutation([[0], [1], [2]]) == Permutation([0, 1, 2])\n+\n+    # Test if size overrides correctly\n+    assert Permutation([[0, 1]], size=3) == Permutation([1, 0, 2])\n+\n+    raises(ValueError, lambda: Permutation([[1, 2], [2, 1]]))  # Ensure duplicate elements still raise an error\n     p = Permutation([(0, 3, 1, 2), (4, 5)])\n     assert p._cyclic_form is None\n     assert Permutation(p) == p\n",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..fd99d48 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -1,3 +1,4 @@\n+\n from sympy import Abs, S, Symbol, I, Rational, PurePoly\n from sympy.matrices import Matrix, SparseMatrix, eye, zeros, ShapeError\n from sympy.utilities.pytest import raises\n@@ -448,6 +449,22 @@ def test_sparse_matrix():\n     assert A.col_list() == [(0, 0, 18), (4, 2, 19), (6, 2, 12), (1, 4, 18), (2, 7, 16), (5, 7, 16), (9, 7, 18), (0, 9, 12), (3, 9, 12)]\n     assert SparseMatrix.eye(2).nnz() == 2\n \n+def test_hstack_vstack_issue():\n+    # Test hstack with 0 x n matrices\n+    sparse_matrices = [SparseMatrix.zeros(0, n) for n in range(4)]\n+    assert SparseMatrix.hstack(*sparse_matrices).shape == (0, 6)  # Expected correct shape\n+\n+    # Test hstack with 1 x n matrices for control\n+    sparse_matrices = [SparseMatrix.zeros(1, n) for n in range(4)]\n+    assert SparseMatrix.hstack(*sparse_matrices).shape == (1, 6)  # Control case\n+\n+    # Test vstack with n x 0 matrices\n+    sparse_matrices = [SparseMatrix.zeros(n, 0) for n in range(4)]\n+    assert SparseMatrix.vstack(*sparse_matrices).shape == (6, 0)  # Expected correct shape\n+\n+    # Test vstack with n x 1 matrices for control\n+    sparse_matrices = [SparseMatrix.zeros(n, 1) for n in range(4)]\n+    assert SparseMatrix.vstack(*sparse_matrices).shape == (6, 1)  # Control case\n \n def test_transpose():\n     assert SparseMatrix(((1, 2), (3, 4))).transpose() == \\\n",
  "sympy__sympy-13471": "diff --git a/sympy/utilities/tests/test_pickling.py b/sympy/utilities/tests/test_pickling.py\nindex 52dcc20..e53f637 100644\n--- a/sympy/utilities/tests/test_pickling.py\n+++ b/sympy/utilities/tests/test_pickling.py\n@@ -115,7 +115,26 @@ def test_core_relational():\n         check(c)\n \n \n-def test_core_add():\n+def test_pickle_float_across_versions():\n+    import subprocess\n+    import sympy\n+\n+    # Prepare the Python 2 dump command\n+    python2_command = [\n+        \"python2\",\n+        \"-c\",\n+        'import pickle; import sympy; x = sympy.symbols(\"x\"); print pickle.dumps(x + 1.0, 2)'\n+    ]\n+\n+    # Execute the Python 2 command and get the pickled data\n+    pickle_data = subprocess.check_output(python2_command)\n+\n+    # Load the pickled data in Python 3\n+    expr = pickle.loads(pickle_data)\n+    \n+    # Verify the loaded expression is as expected\n+    x = sympy.symbols(\"x\")\n+    assert expr == x + 1.0\n     x = Symbol(\"x\")\n     for c in (Add, Add(x, 4)):\n         check(c)\n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..6fbf7dc 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -262,6 +262,14 @@ def test_coth():\n \n     assert coth(pi*I/105) == -cot(pi/105)*I\n     assert coth(-pi*I/105) == cot(pi/105)*I\n+    \n+    # Test for issue with coth(log(tan(x))) substitution\n+    x = Symbol('x')\n+    e = coth(log(tan(x)))\n+    # Verify that substitution does not raise an error\n+    integral_values = [2, 3, 5, 6, 8, 9, 11, 12, 13, 15, 18]\n+    for val in integral_values:\n+        e.subs(x, val)  # Ensure no error occurs\n \n     assert coth(2 + 3*I) == coth(2 + 3*I)\n \n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..aedd0e6 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -201,7 +201,25 @@ def test_col_insert():\n         l.insert(i, 4)\n         assert flatten(zeros_Shaping(3).col_insert(i, c4).row(0).tolist()) == l\n \n-def test_extract():\n+def test_issue_13643():\n+    # This test case validates the issue described where \n+    # Matrix.col_insert does not correctly insert the columns\n+    from sympy import Matrix, eye, ones\n+    \n+    M = eye(6)\n+    V = 2 * ones(6, 2)\n+    result = M.col_insert(3, V)\n+    \n+    expected = Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1],\n+    ])\n+    \n+    assert result == expected\n     m = ShapingOnlyMatrix(4, 3, lambda i, j: i*3 + j)\n     assert m.extract([0, 1, 3], [0, 1]) == Matrix(3, 2, [0, 1, 3, 4, 9, 10])\n     assert m.extract([0, 3], [0, 0, 2]) == Matrix(2, 3, [0, 0, 2, 9, 9, 11])\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..97c7ddd 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -615,15 +615,19 @@ def test_latex_Range():\n \n     assert latex(Range(-2, -oo, -1)) == r'\\left\\{-2, -3, \\ldots, -\\infty\\right\\}'\n \n+from sympy import SeqFormula, SeqPer, SeqAdd, SeqMul, symbols, oo, latex\n+\n+a = symbols('a')\n \n def test_latex_sequences():\n     s1 = SeqFormula(a**2, (0, oo))\n     s2 = SeqPer((1, 2))\n \n-    latex_str = r'\\left\\[0, 1, 4, 9, \\ldots\\right\\]'\n+    # Correct the strings to properly formatted LaTeX without double backslashes\n+    latex_str = r'[0, 1, 4, 9, \\ldots]'\n     assert latex(s1) == latex_str\n \n-    latex_str = r'\\left\\[1, 2, 1, 2, \\ldots\\right\\]'\n+    latex_str = r'[1, 2, 1, 2, \\ldots]'\n     assert latex(s2) == latex_str\n \n     s3 = SeqFormula(a**2, (0, 2))\n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..4e53ede 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,28 @@\n+\n+def test_Domain_preprocess_extended():\n+    # Additional test cases for RR and CC domains with multiple variables\n+    assert Domain.preprocess('R[x]') == RR[x]\n+    assert Domain.preprocess('C[x]') == CC[x]\n+    assert Domain.preprocess('RR[x]') == RR[x]\n+    assert Domain.preprocess('CC[x]') == CC[x]\n+    assert Domain.preprocess('R[x,y]') == RR[x, y]\n+    assert Domain.preprocess('C[x,y]') == CC[x, y]\n+    assert Domain.preprocess('RR[x,y]') == RR[x, y]\n+    assert Domain.preprocess('CC[x,y]') == CC[x, y]\n+\n+def test_Poly_RR_domain():\n+    # Test for Poly with RR[y,z] domain\n+    from sympy import Poly\n+    from sympy.abc import x, y, z\n+    assert Poly(1.2*x*y*z, x).domain == RR[y, z]\n+    assert Poly(1.2*x*y*z, x, domain='RR[y,z]').domain == RR[y, z]\n+\n+def test_invalid_domain():\n+    # Test for invalid domain specification to ensure appropriate error messages\n+    raises(OptionError, lambda: Domain.preprocess('INVALID'))\n+    raises(OptionError, lambda: Domain.preprocess('RR()'))\n+    raises(OptionError, lambda: Domain.preprocess('CC<>'))\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +31,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n",
  "sympy__sympy-14774": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 48a5cf2..2745a2c 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Add, Abs, Chi, Ci, CosineTransform, Dict, Ei, Eq, FallingFactorial,\n     FiniteSet, Float, FourierTransform, Function, IndexedBase, Integral,\n@@ -300,6 +301,11 @@ def test_latex_functions():\n     assert latex(asin(x)**2) == r\"\\operatorname{asin}^{2}{\\left (x \\right )}\"\n     assert latex(asin(x)**2, inv_trig_style=\"full\") == \\\n         r\"\\arcsin^{2}{\\left (x \\right )}\"\n+\n+    assert latex(acsc(x), inv_trig_style=\"full\") == \\\n+        r\"\\operatorname{arccsc}{\\left (x \\right )}\"\n+    assert latex(asec(x), inv_trig_style=\"full\") == \\\n+        r\"\\operatorname{arcsec}{\\left (x \\right )}\"\n     assert latex(asin(x)**2, inv_trig_style=\"power\") == \\\n         r\"\\sin^{-1}{\\left (x \\right )}^{2}\"\n     assert latex(asin(x**2), inv_trig_style=\"power\",\n",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..da5ad57 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6111,6 +6111,28 @@ u(\"\"\"\\\n     assert upretty((1/y)*e.j) == ucode_str\n \n \n+def test_issue_14814_pretty_print_MatAdd():\n+    # Re-create the scenario described in the issue\n+    x = MatrixSymbol('x', n, n)\n+    y_star = MatrixSymbol('y*', n, n)\n+    \n+    # Ensure the pretty printing works without errors\n+    assert pretty(x + y_star) == 'x + y*'\n+    assert pretty(-a * x + -2 * y_star * y_star) == '-a*x -2*y**y*'\n+    \n+    # Additional test cases to cover more variations\n+    y_dash = MatrixSymbol(\"y'\", n, n)\n+    assert pretty(x + y_dash) == \"x + y'\"\n+    assert pretty(a * x - y_dash) == \"a*x -y'\"\n+    \n+    # Test with other special characters in symbols\n+    z_hat = MatrixSymbol('z^', n, n)\n+    assert pretty(x + z_hat) == \"x + z^\"\n+    assert pretty(-x + z_hat) == \"-x + z^\"\n+\n+from sympy import MatrixSymbol, pretty\n+from sympy.abc import a, n\n+\n def test_MatrixSymbol_printing():\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n",
  "sympy__sympy-15011": "",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..5a1cfae 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,24 @@\n+\n+def test_Max_Min():\n+    # Original test case\n+    assert mcode(Max(x, y, z) * Min(y, z)) == \"Max[x, y, z]*Min[y, z]\"\n+    \n+    # Test case specifically for the issue\n+    assert mcode(Max(x, 2)) == \"Max[x, 2]\"\n+    assert mcode(Max(2, x)) == \"Max[2, x]\"  # Should also handle this form correctly\n+\n+    # Additional test cases for coverage\n+    assert mcode(Max(1, x, 3)) == \"Max[1, x, 3]\"\n+    assert mcode(Max(x, 2, y)) == \"Max[x, 2, y]\"\n+    assert mcode(Max(Min(x, 2), 3)) == \"Max[Min[x, 2], 3]\"\n+    assert mcode(Max(x + y, z)) == \"Max[x + y, z]\"\n+    assert mcode(Min(Max(x, y), z)) == \"Min[Max[x, y], z]\"\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..5fe9045 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1717,6 +1717,18 @@ def test_issue_13651():\n     assert latex(expr) == r\"c - \\left(a + b\\right)\"\n \n \n+from sympy import symbols, MatrixSymbol, latex\n+\n+...\n+\n+def test_issue_indexed_matrix_expression_latex():\n+    # Test case for verifying the fix of the LaTeX compilation issue\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    expected_latex = r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n+    assert latex((M*N)[i, j]) == expected_latex\n+\n def test_latex_UnevaluatedExpr():\n     x = symbols(\"x\")\n     he = UnevaluatedExpr(1/x)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..e4c813a 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, Eq, exp\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -20,8 +21,18 @@ def test_idiff():\n     assert True in [sol.diff(x, 3).equals(explicit) for sol in solve(circ, y)]\n     assert idiff(x + t + y, [y, t], x) == -Derivative(t, x) - 1\n \n+    f = Function('f')\n+    g = Function('g')\n+\n+    # Test with Eq and expression inputs\n+    assert idiff(Eq(y*exp(y), x*exp(x)), y, x).simplify() == (x + 1)*exp(x - y)/(y + 1)\n+    assert idiff(f(x)*exp(f(x)) - x*exp(x), f(x), x).simplify() == (x + 1)*exp(x - f(x))/(f(x) + 1)\n+    assert idiff(y*exp(y) - x*exp(x), y, x).simplify() == (x + 1)*exp(x - y)/(y + 1)\n \n-def test_intersection():\n+    # Test multiple dependent functions\n+    assert idiff(f(x) - y*exp(x), [f(x), y], x).simplify() == (y + Derivative(y, x)) * exp(x)\n+    assert idiff(f(x) - y*exp(x), [y, f(x)], x).simplify() == -y + exp(-x) * Derivative(f(x), x)\n+    assert idiff(f(x) - g(x), [f(x), g(x)], x).simplify() == Derivative(g(x), x)\n     assert intersection(Point(0, 0)) == []\n     raises(TypeError, lambda: intersection(Point(0, 0), 3))\n     assert intersection(\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_codegen.py b/sympy/utilities/tests/test_codegen.py\nindex 6bc2605..7eb2728 100644\n--- a/sympy/utilities/tests/test_codegen.py\n+++ b/sympy/utilities/tests/test_codegen.py\n@@ -582,6 +582,40 @@ def test_ccode_cse():\n     )\n     assert source == expected\n \n+def test_ccode_unused_array_arg():\n+    from sympy.utilities.codegen import codegen, CCodeGen\n+    from sympy import MatrixSymbol\n+    x = MatrixSymbol('x', 2, 1)\n+    # x does not appear in output\n+    name_expr = (\"test\", 1.0)\n+    generator = CCodeGen()\n+    result = codegen(name_expr, code_gen=generator, header=False, empty=False, argument_sequence=(x,))\n+    source = result[0][1]\n+    # note: x should appear as (double *)\n+    expected = (\n+        '#include \"test.h\"\\n'\n+        '#include <math.h>\\n'\n+        'double test(double *x) {\\n'\n+        '   double test_result;\\n'\n+        '   test_result = 1.0;\\n'\n+        '   return test_result;\\n'\n+        '}\\n'\n+    )\n+    assert source == expected\n+\n+def test_autowrap_cython_with_unused_arg():\n+    from sympy.utilities.autowrap import autowrap\n+    from sympy import MatrixSymbol\n+    import numpy as np\n+\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0\n+    f = autowrap(expr, args=(x,), backend='cython')\n+\n+    # Ensure that the function correctly returns 1.0\n+    result = f(np.array([[1.0, 2.0]]))\n+    assert abs(result - 1.0) < 1e-12\n+\n def test_empty_f_code():\n     code_gen = FCodeGen()\n     source = get_string(code_gen.dump_f95, [])\n",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..7880418 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -339,7 +339,17 @@ def test_intersection():\n \n     assert Intersection(S.Complexes, FiniteSet(S.ComplexInfinity)) == S.EmptySet\n \n-    # issue 12178\n+    # Test for removing duplicates in Intersection inputs\n+    x = Symbol('x')\n+    assert Intersection({1}, {1}, {x}) == Intersection({1}, {x})\n+    assert Intersection({1}, {1}) == FiniteSet(1)\n+    assert Intersection({1, 1, 1}, {1, 1}) == FiniteSet(1)\n+    assert Intersection({x, 1}, {1, 1, x}) == FiniteSet(1, x)\n+    assert Intersection({1, 2, 3}, {3, 2, 1}, {1, 2, 3, 3, 2, 1}) == FiniteSet(1, 2, 3)\n+    # Test for Piecewise behavior when symbols are involved\n+    result = Intersection({1}, {1}, {x})\n+    expected = Piecewise((FiniteSet(1), Eq(x, 1)), (S.EmptySet, True))\n+    assert result == expected\n     assert Intersection() == S.UniversalSet\n \n \n",
  "sympy__sympy-17022": "diff --git a/sympy/printing/tests/test_numpy.py b/sympy/printing/tests/test_numpy.py\nindex fa5ed1f..4bca090 100644\n--- a/sympy/printing/tests/test_numpy.py\n+++ b/sympy/printing/tests/test_numpy.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Piecewise, lambdify, Equality, Unequality, Sum, Mod, cbrt, sqrt,\n     MatrixSymbol, BlockMatrix\n@@ -10,7 +11,11 @@ from sympy.codegen.array_utils import (CodegenArrayContraction,\n         CodegenArrayPermuteDims, CodegenArrayElementwiseAdd)\n from sympy.printing.lambdarepr import NumPyPrinter\n \n-from sympy.utilities.pytest import warns_deprecated_sympy\n+from sympy.utilities.pytest import warns_deprecated_sympy, raises\n+from sympy import Identity\n+from sympy.external import import_module\n+\n+np = import_module('numpy')\n from sympy.utilities.pytest import skip\n from sympy.external import import_module\n \n@@ -26,7 +31,31 @@ def test_numpy_piecewise_regression():\n     assert NumPyPrinter().doprint(p) == 'numpy.select([numpy.less(x, 0),True], [1,0], default=numpy.nan)'\n \n \n-def test_sum():\n+def test_issue_17006():\n+    if not np:\n+        skip(\"NumPy not installed\")\n+\n+    M = MatrixSymbol(\"M\", 2, 2)\n+\n+    # Test using an identity matrix with specific size\n+    f = lambdify(M, M + Identity(2), modules='numpy')\n+    ma = np.array([[1, 2], [3, 4]])\n+    mr = np.array([[2, 2], [3, 5]])\n+\n+    assert (f(ma) == mr).all()\n+\n+    from sympy import symbols\n+    n = symbols('n', integer=True)\n+    N = MatrixSymbol(\"N\", n, n)\n+    raises(NotImplementedError, lambda: lambdify(N, N + Identity(n), modules='numpy'))\n+\n+    # Test with symbolic dimensions\n+    P = MatrixSymbol(\"P\", 3, 3)\n+    g = lambdify(P, P + Identity(3), modules='numpy')\n+    pa = np.array([[0, 0, 0], [0, 0, 0], [0, 0, 0]])\n+    pr = np.eye(3)\n+\n+    assert (g(pa) == pr).all()\n     if not np:\n         skip(\"NumPy not installed\")\n \n",
  "sympy__sympy-17139": "diff --git a/sympy/simplify/tests/test_simplify.py b/sympy/simplify/tests/test_simplify.py\nindex daf5f69..0e2a7c4 100644\n--- a/sympy/simplify/tests/test_simplify.py\n+++ b/sympy/simplify/tests/test_simplify.py\n@@ -814,4 +814,16 @@ def test_issue_15965():\n def test_issue_7971():\n     z = Integral(x, (x, 1, 1))\n     assert z != 0\n-    assert simplify(z) is S.Zero\n+    assert simplify(z) is S.Zero\n+\n+def test_issue_17137():\n+    from sympy import Symbol, I, simplify, cos\n+    x = Symbol('x')\n+    # Test cases from original patch\n+    assert simplify(cos(x)**I) == cos(x)**I\n+    assert simplify(cos(x)**(2 + 3*I)) == cos(x)**(2 + 3*I)\n+    \n+    # Additional complex power test cases\n+    assert simplify(cos(x)**(3*I)) == cos(x)**(3*I)\n+    assert simplify(cos(x)**(-I)) == cos(x)**(-I)\n+    assert simplify(cos(x)**(1 + I)) == cos(x)**(1 + I)\n",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..3ffa130 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,12 +1,21 @@\n-from sympy import I, Rational, Symbol, pi, sqrt, S\n+\n+from sympy import I, Rational, Symbol, pi, sqrt, S, sympify\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.pytest import raises, warns\n \n-\n-def test_point():\n+def test_multiplication_with_scalar():\n+    from sympy.geometry import Point\n+    p1 = Point(0, 0)\n+    p2 = Point(1, 1)\n+    scalar = sympify(2.0)\n+    \n+    # Both forms should work without any exceptions\n+    # Issue: point1 + sympy.sympify(2.0) * point2\n+    assert p1 + p2 * scalar == Point(2, 2)\n+    assert p1 + scalar * p2 == Point(2, 2)\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..4a061f6 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1894,6 +1894,46 @@ def test_normal():\n     assert e.normal() == e\n \n \n+from sympy import symbols, sympify, Symbol\n+from sympy.testing.pytest import raises\n+\n+def test_non_string_equality():\n+    # Expressions should not compare equal to strings\n+    x = symbols('x')\n+    one = sympify(1)\n+    assert (x == 'x') is False\n+    assert (x != 'x') is True\n+    assert (one == '1') is False\n+    assert (one != '1') is True\n+    assert (x + 1 == 'x + 1') is False\n+    assert (x + 1 != 'x + 1') is True\n+\n+    # Make sure == doesn't try to convert the resulting expression to a string\n+    # (e.g., by calling sympify() instead of _sympify())\n+\n+    class BadRepr(object):\n+        def __repr__(self):\n+            raise RuntimeError\n+\n+    assert (x == BadRepr()) is False\n+    assert (x != BadRepr()) is True\n+    \n+    # Additional test cases for the specific issue\n+    class C:\n+        def __repr__(self):\n+            return 'x.y'\n+    \n+    assert (x == C()) is False\n+    assert (x != C()) is True\n+\n+    # Related issue test case\n+    class C2:\n+        def __repr__(self):\n+            return 'x'\n+    \n+    assert (x == C2()) is False\n+    assert (x != C2()) is True\n+\n def test_expr():\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n@@ -1902,4 +1942,4 @@ def test_expr():\n def test_ExprBuilder():\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..3982935 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -553,8 +553,19 @@ def test_diophantine():\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n     assert diophantine((y**2-x), t) == set([(t**2, -t)])\n \n+def test_diophantine_issue_18186():\n+    from sympy import diophantine\n+    from sympy.abc import x, y\n \n-def test_general_pythagorean():\n+    # Test case for issue 18186\n+    expr1 = x**4 + y**4 - 2**4 - 3**4\n+\n+    # Expected to get all permutations with permute=True\n+    expected_result = set([(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)])\n+\n+    # Test for both orders of symbols\n+    assert diophantine(expr1, syms=(x, y), permute=True) == expected_result\n+    assert diophantine(expr1, syms=(y, x), permute=True) == expected_result\n     from sympy.abc import a, b, c, d, e\n \n     assert check_solutions(a**2 + b**2 + c**2 - d**2)\n",
  "sympy__sympy-18532": "diff --git a/sympy/codegen/tests/test_cnodes.py b/sympy/codegen/tests/test_cnodes.py\nindex c30dccd..49a7ec5 100644\n--- a/sympy/codegen/tests/test_cnodes.py\n+++ b/sympy/codegen/tests/test_cnodes.py\n@@ -1,6 +1,7 @@\n+\n from sympy.core.symbol import symbols\n from sympy.printing.ccode import ccode\n-from sympy.codegen.ast import Declaration, Variable, float64, int64\n+from sympy.codegen.ast import Declaration, Variable, float64, int64, String, Basic\n from sympy.codegen.cnodes import (\n     alignof, CommaOperator, goto, Label, PreDecrement, PostDecrement, PreIncrement, PostIncrement,\n     sizeof, union, struct\n@@ -66,7 +67,8 @@ def test_sizeof():\n     assert ccode(sz) == 'sizeof(%s)' % typename\n     assert sz.func(*sz.args) == sz\n     assert not sz.is_Atom\n-    assert all(atom == typename for atom in sz.atoms())\n+    # Updated test to verify atoms only contains objects with no .args\n+    assert sz.atoms() == {String('unsigned int'), String('sizeof')}\n \n \n def test_struct():\n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..dc4c63b 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,27 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_issue_single_element_BlockDiagMatrix():\n+    # Test case for the issue with single-element BlockDiagMatrix.\n+    from sympy import Matrix, BlockDiagMatrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    B = Matrix(D)\n+    assert B == M\n+\n+def test_issue_multiple_elements_BlockDiagMatrix():\n+    # Verify it works with multiple elements, as originally described\n+    from sympy import Matrix, BlockDiagMatrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M, M)\n+    B = Matrix(D)\n+    assert B == Matrix([\n+        [1, 2, 0, 0],\n+        [3, 4, 0, 0],\n+        [0, 0, 1, 2],\n+        [0, 0, 3, 4]\n+    ])\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..8e6196b 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,7 +1,8 @@\n+\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n-from sympy.testing.pytest import raises\n+from sympy.testing.pytest import raises, XFAIL\n from sympy.matrices.expressions.matexpr import MatrixElement, MatrixExpr\n \n k, l, m, n = symbols('k l m n', integer=True)\n@@ -83,7 +84,12 @@ def test_block_index():\n     assert BI.as_explicit().equals(eye(6))\n \n \n-def test_slicing():\n+def test_issue_block_index_symbolic():\n+    n, i = symbols('n i', integer=True)\n+    A = MatrixSymbol('A', 1, 1)\n+    B = MatrixSymbol('B', n, 1)\n+    C = BlockMatrix([[A], [B]])\n+    assert C[i, 0] == MatrixElement(C, i, 0)  # Ensure no invalid simplification\n     A.as_explicit()[0, :]  # does not raise an error\n \n \n",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..8b443f1 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -316,8 +316,27 @@ def test_sign():\n     d = p - q\n     assert sign(d).func is sign or sign(d) == 0\n \n+def test_sign_rewrite_abs():\n+    from sympy import Symbol, Abs, Piecewise, Eq, sign\n+    \n+    x = Symbol('x')\n+    assert sign(x).rewrite(Abs) == Piecewise((0, Eq(x, 0)), (x / Abs(x), True))\n+    \n+    y = Symbol('y', real=True)\n+    assert sign(y).rewrite(Abs) == Piecewise((0, Eq(y, 0)), (y / Abs(y), True))\n+    \n+    z = Symbol('z', complex=True, nonzero=True)\n+    assert sign(z).rewrite(Abs) == z / Abs(z)\n+    \n+    zero = 0\n+    assert sign(zero).rewrite(Abs) == 0\n \n-def test_as_real_imag():\n+    nz = Symbol('nz', nonzero=True, integer=True)\n+    assert sign(nz).rewrite(Abs) == nz / Abs(nz)\n+\n+    # Additional test with function\n+    f = Function('f')\n+    assert sign(f(x)).rewrite(Abs) == Piecewise((0, Eq(f(x), 0)), (f(x) / Abs(f(x)), True))\n     n = pi**1000\n     # the special code for working out the real\n     # and complex parts of a power with Integer exponent\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..f133c4e 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -513,8 +513,31 @@ def test_partitions():\n             i += 1\n         assert i == RGS_enum(n)\n \n+def test_partitions_no_reuse():\n+    # Test to ensure that the output dictionaries from partitions are not reused.\n+    \n+    # Function to generate a list of partitions without reuse.\n+    def generate_non_reused_partitions(n, k):\n+        return [p.copy() for p in partitions(n, k)]\n+\n+    # Get partitions with copying to ensure no reuse\n+    partitions_6_k2 = generate_non_reused_partitions(6, 2)\n+    partitions_6_k3 = generate_non_reused_partitions(6, 3)\n+\n+    # Check if the partitions generated are consistent and not reused.\n+    assert partitions_6_k2 == [{2: 3}, {1: 2, 2: 2}, {1: 4, 2: 1}, {1: 6}]\n+    assert partitions_6_k3 == [\n+        {3: 2}, {1: 1, 2: 1, 3: 1}, {1: 3, 3: 1},\n+        {2: 3}, {1: 2, 2: 2}, {1: 4, 2: 1}, {1: 6}\n+    ]\n+\n+    # Test for independence of result dictionaries; modify one and check the \n+    # effect on the list.\n+    p_first = partitions_6_k2[0]\n+    p_first[2] = 4\n \n-def test_binary_partitions():\n+    assert partitions_6_k2 != generate_non_reused_partitions(6, 2)\n+    assert partitions_6_k3 == generate_non_reused_partitions(6, 3)\n     assert [i[:] for i in binary_partitions(10)] == [[8, 2], [8, 1, 1],\n         [4, 4, 2], [4, 4, 1, 1], [4, 2, 2, 2], [4, 2, 2, 1, 1],\n         [4, 2, 1, 1, 1, 1], [4, 1, 1, 1, 1, 1, 1], [2, 2, 2, 2, 2],\n",
  "sympy__sympy-20212": "",
  "sympy__sympy-20442": "",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..8019211 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -28,6 +28,19 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+import pytest\n+from sympy import Symbol\n+\n+def test_symbol_no_dict():\n+    s = Symbol('s')\n+    # Ensure that a Symbol instance does not have a __dict__ attribute.\n+    with pytest.raises(AttributeError):\n+        _ = s.__dict__\n+        \n+    # Verify that __slots__ contains the expected attributes\n+    assert hasattr(s, '__slots__')\n+    assert 'name' in s.__slots__\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..124a8ad 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n                    atan, atan2, nan, Symbol, re, im, sign)\n from sympy.abc import w, x, y, z\n@@ -161,7 +162,23 @@ def test_sign():\n     assert refine(sign(x), Q.zero(x)) == 0\n \n \n-def test_func_args():\n+def test_arg():\n+    x = Symbol('x', complex=True)\n+    assert refine(arg(x), Q.positive(x)) == 0\n+    assert refine(arg(x), Q.negative(x)) == pi\n+\n+    a = Symbol('a', real=True)\n+    expr = Integral(sin(x) * exp(-a * x), (x, 0, oo)).doit()\n+    assert refine(expr, Q.positive(a)) == 1/(a**2 + 1)\n+\n+    expr_with_arg = arg(a * I + 1)\n+    assert refine(expr_with_arg, Q.positive(a)) == pi/2\n+\n+    a = Symbol('a', positive=True)\n+    assert refine(arg(a), Q.positive(a)) == 0\n+\n+    a = Symbol('a', negative=True)\n+    assert refine(arg(a), Q.negative(a)) == pi\n     class MyClass(Expr):\n         # A class with nontrivial .func\n \n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..fd39cda 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -20,6 +21,32 @@ def test_subs():\n     assert e == Rational(6)\n \n \n+def test_issue_polynomial_error_with_subs():\n+    from sympy import sinh, exp, Piecewise, symbols, clears_cache\n+\n+    # Clear cache for each test to simulate the original issue conditions\n+    clears_cache()\n+\n+    # Create real symbols\n+    x_r, y_r, z_r = symbols('x_r y_r z_r', real=True)\n+\n+    # Expression that was causing the PolynomialError\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+\n+    # Substitute integer 1 with float 1.0\n+    try:\n+        expr.subs({1: 1.0})\n+        print(\"Test Passed: No PolynomialError was raised.\")\n+    except Exception as e:\n+        print(f\"Test Failed: An unexpected error was raised: {e}\")\n+\n+    # Clear cache again for a repeated test\n+    clears_cache()\n+\n+    # Ensure that the cache clearing and subsequent expression creation/substitution does not fail\n+    expr = exp(sinh(Piecewise((x_r, y_r > x_r), (y_r, True)) / z_r))\n+    assert expr.subs({1: 1.0})  # This should not raise any error\n+\n def test_subs_Matrix():\n     z = zeros(2)\n     z1 = ZeroMatrix(2, 2)\n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..ff1c188 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n@@ -45,6 +46,13 @@ def test_Matrix_kind():\n         m = cls.zeros(3, 2)\n         assert m.kind is MatrixKind(NumberKind)\n \n+def test_Derivative_kind():\n+    A = MatrixSymbol('A', 2, 2)\n+    assert Derivative(comm_x, comm_x).kind is NumberKind\n+    assert Derivative(A, comm_x).kind is MatrixKind(NumberKind)\n+    assert Derivative(A, noncomm_x).kind is MatrixKind(UndefinedKind)\n+    assert Derivative(noncomm_x, comm_x).kind is UndefinedKind\n+\n def test_MatMul_kind():\n     M = Matrix([[1,2],[3,4]])\n     assert MatMul(2, M).kind is MatrixKind(NumberKind)\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..7679541 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -131,6 +131,10 @@ def test_monomials():\n     assert set(itermonomials([x, y], [2, 2])) == \\\n             {S.One, y**2, x*y**2, x, x*y, x**2, x**2*y**2, y, x**2*y}\n \n+    assert set(itermonomials([x, y, z], 3, 3)) == {x**3, x**2*y, x*y**2, y**3, x**2*z, x*z**2, z**3, y**2*z, y*z**2, y**3, y*z*x, x*z**2, x*y*z, y**2*x, z**2*x, y*x**2, z*x**2, z**2*y, z**3}\n+    assert set(itermonomials([x1, x2, x3], 3, 3)) == {x1**3, x1**2*x2, x1*x2**2, x2**3, x1**2*x3, x1*x3**2, x3**3, x2**2*x3, x2*x3**2, x2**3, x2*x3*x1, x1*x3**2, x1*x2*x3, x2**2*x1, x3**2*x1, x2*x1**2, x3*x1**2, x3**2*x2, x3**3}\n+    assert set(itermonomials([x, y], 3, 2)) == {x**3, x**2*y, x*y**2, y**3, x**2, y**2, x*y}\n+    \n     i, j, k = symbols('i j k', commutative=False)\n     assert set(itermonomials([i, j, k], [0, 0, 0])) == {S.One}\n     assert set(itermonomials([i, j, k], [0, 0, 1])) == {1, k}\n",
  "sympy__sympy-22005": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 341f63c..6fcb093 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n@@ -49,8 +50,14 @@ def test_solve_poly_system():\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\n     raises(PolynomialError, lambda: solve_poly_system([1/x], x))\n \n-\n-def test_solve_biquadratic():\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [x - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [y - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [x**2 + y**2 - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [x**2 + y**2 - 1, x - y], (x, y)))\n     x0, y0, x1, y1, r = symbols('x0 y0 x1 y1 r')\n \n     f_1 = (x - 1)**2 + (y - 1)**2 - r**2\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..7057531 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n@@ -9,6 +10,7 @@ from sympy.geometry.entity import rotate, scale, translate, GeometryEntity\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.misc import Undecidable\n+from sympy.core.parameters import evaluate\n from sympy.testing.pytest import raises, warns\n \n \n",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..a599df7 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -337,6 +337,25 @@ def test_cse_Indexed():\n     replacements, reduced_exprs = cse([expr1, expr2])\n     assert len(replacements) > 0\n \n+def test_cse_matrixsymbol_indexing():\n+    A = MatrixSymbol('A', 4, 4)\n+    B = MatrixSymbol('B', 4, 4)\n+    expr = A * B\n+\n+    # Substitute elements with indexed MatrixSymbols to check CSE behavior\n+    expr_sub = expr.subs({A[i, j]: symbols(f'A_{i}_{j}') for i in range(4) for j in range(4)})\n+    expr_sub = expr_sub.subs({B[i, j]: symbols(f'B_{i}_{j}') for i in range(4) for j in range(4)})\n+    \n+    cse_subs, cse_reduced = cse(expr_sub)\n+\n+    # Expect no redundancy for indexed elements\n+    for i in range(4):\n+        for j in range(4):\n+            assert expr_sub[i, j] == cse_reduced[0][i, j]\n+\n+    # Verify that there are no unnecessary substitutions created for simple indexing\n+    assert all(isinstance(s, tuple) and len(s) == 2 for s in cse_subs)\n+\n \n def test_cse_MatrixSymbol():\n     # MatrixSymbols have non-Basic args, so make sure that works\n@@ -356,6 +375,25 @@ def test_cse_MatrixExpr():\n     replacements, reduced_exprs = cse([expr1, expr2])\n     assert len(replacements) > 0\n \n+def test_cse_matrixsymbol_indexing():\n+    A = MatrixSymbol('A', 4, 4)\n+    B = MatrixSymbol('B', 4, 4)\n+    expr = A * B\n+\n+    # Substitute elements with indexed MatrixSymbols to check CSE behavior\n+    expr_sub = expr.subs({A[i, j]: symbols(f'A_{i}_{j}') for i in range(4) for j in range(4)})\n+    expr_sub = expr_sub.subs({B[i, j]: symbols(f'B_{i}_{j}') for i in range(4) for j in range(4)})\n+    \n+    cse_subs, cse_reduced = cse(expr_sub)\n+\n+    # Expect no redundancy for indexed elements\n+    for i in range(4):\n+        for j in range(4):\n+            assert expr_sub[i, j] == cse_reduced[0][i, j]\n+\n+    # Verify that there are no unnecessary substitutions created for simple indexing\n+    assert all(isinstance(s, tuple) and len(s) == 2 for s in cse_subs)\n+\n     replacements, reduced_exprs = cse([expr1 + expr2, expr1])\n     assert replacements\n \n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..ae0ecfc 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -37,6 +38,12 @@ def test_array_negative_indices():\n \n         assert test_array[-1, -1] == 10\n \n+def test_issue_17851_empty_Array():\n+    for array_type in array_types:\n+        A = array_type([])\n+        assert isinstance(A, array_type)\n+        assert A.shape == (0,)\n+        assert list(A) == []\n \n def test_issue_18361():\n     A = Array([sin(2 * x) - 2 * sin(x) * cos(x)])\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..2058dcb 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1175,6 +1175,23 @@ def test_scipy_polys():\n \n \n \n+def test_lambdify_single_element_tuple():\n+    # Test case for single-element tuple\n+    f = lambdify([], (1,))\n+    source_code = inspect.getsource(f)\n+    assert 'return (1,)' in source_code\n+    assert f() == (1,)\n+\n+def test_lambdify_two_element_tuple():\n+    # Test case for a tuple with two elements\n+    f = lambdify([], (1, 2))\n+    source_code = inspect.getsource(f)\n+    assert 'return (1, 2)' in source_code\n+    assert f() == (1, 2)\n+\n+import inspect\n+from sympy import lambdify\n+\n def test_lambdify_inspect():\n     f = lambdify(x, x**2)\n     # Test that inspect.getsource works but don't hard-code implementation\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..1d8742b 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -530,7 +530,8 @@ def test_issue_22819():\n \n def test_issue_20288():\n     from sympy.core.numbers import E\n-    from sympy.physics.units import energy\n+    from sympy.physics.units import energy, exp, impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units.systems.si import SI\n     u = Quantity('u')\n     v = Quantity('v')\n     SI.set_quantity_dimension(u, energy)\n@@ -540,6 +541,32 @@ def test_issue_20288():\n     expr = 1 + exp(u**2/v**2)\n     assert SI._collect_factor_and_dimension(expr) == (1 + E, Dimension(1))\n \n+def test_issue_24062():\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n+\n+def test_additional_dimensionless_cases():\n+    # Check if expressions with zero dimension result in correct handling\n+    expr = 2 + exp(0)\n+    assert SI._collect_factor_and_dimension(expr) == (3, Dimension(1))\n+\n+    expr = 1 + exp(second / (farad * ohm))\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n \n def test_prefixed_property():\n     assert not meter.is_prefixed\n",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..0c8d68d 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -45,8 +45,27 @@ def test_tensor_product_expand():\n     assert TP(A + B, B + C).expand(tensorproduct=True) == \\\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n-\n-def test_tensor_product_commutator():\n+def test_tensor_product_expand():\n+    # Tests for fix of issue #24142\n+    assert TP(A - B, B - A).expand(tensorproduct=True) == \\\n+        TP(A, B) - TP(A, A) - TP(B, B) + TP(B, A)\n+    assert TP(2 * A + B, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A, A) + 2 * TP(A, B) + TP(B, A) + TP(B, B)\n+    assert TP(2 * A * B + A, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A*B, A) + 2 * TP(A*B, B) + TP(A, A) + TP(A, B)\n+\n+    # New test cases\n+    # Case with zero factor\n+    assert TP(U - U, U + V).expand(tensorproduct=True) == 0\n+\n+    # Case with nested tensor products\n+    nested = TP(TP(A, 2*B), C + D)\n+    expanded_nested = TP(A, 2*TP(B, C)) + TP(A, 2*TP(B, D))\n+    assert nested.expand(tensorproduct=True) == expanded_nested\n+\n+    # Ensure expansion is correct when scalar multiplication is involved\n+    assert TP(3*(A + B), 4*(C + D)).expand(tensorproduct=True) == \\\n+        12 * TP(A, C) + 12 * TP(A, D) + 12 * TP(B, C) + 12 * TP(B, D)\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n         TP(A*B, C) - TP(B*A, C)\n     assert Comm(TP(A, B), TP(B, C)).doit() == \\\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..98beb6f 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -8,6 +9,8 @@ from sympy.core.symbol import (Symbol, symbols)\n from sympy.functions.elementary.complexes import Abs\n from sympy.functions.elementary.exponential import (exp, log)\n from sympy.functions.elementary.miscellaneous import sqrt\n+from sympy.physics.units import time, velocity, acceleration, second, meter, Quantity\n+from sympy.physics.units.systems.si import SI\n from sympy.functions.elementary.trigonometric import sin\n from sympy.integrals.integrals import integrate\n from sympy.physics.units import (amount_of_substance, area, convert_to, find_unit,\n@@ -561,8 +564,45 @@ def test_issue_24062():\n     exp_expr = 1 + exp(expr)\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n+def test_issue_24211():\n+    V1 = Quantity('V1')\n+    SI.set_quantity_dimension(V1, velocity)\n+    SI.set_quantity_scale_factor(V1, 1 * meter / second)\n+    A1 = Quantity('A1')\n+    SI.set_quantity_dimension(A1, acceleration)\n+    SI.set_quantity_scale_factor(A1, 1 * meter / second**2)\n+    T1 = Quantity('T1')\n+    SI.set_quantity_dimension(T1, time)\n+    SI.set_quantity_scale_factor(T1, 1 * second)\n+    \n+    # Original test to ensure no ValueError is raised\n+    expr = A1 * T1 + V1\n+    SI._collect_factor_and_dimension(expr)\n+\n+    # Additional test cases\n+    # Test with negative scale factor\n+    V2 = Quantity('V2')\n+    SI.set_quantity_dimension(V2, velocity)\n+    SI.set_quantity_scale_factor(V2, -1 * meter / second)\n+\n+    expr2 = A1 * T1 + V2\n+    SI._collect_factor_and_dimension(expr2)\n+\n+    # Test with different time scale\n+    T2 = Quantity('T2')\n+    SI.set_quantity_dimension(T2, time)\n+    SI.set_quantity_scale_factor(T2, 2 * second)\n+\n+    expr3 = A1 * T2 + V1\n+    SI._collect_factor_and_dimension(expr3)\n+\n+    # Test with velocity expressed in terms of km/h\n+    V3 = Quantity('V3')\n+    SI.set_quantity_dimension(V3, velocity)\n+    SI.set_quantity_scale_factor(V3, 3.6 * (meter / second))\n \n-def test_prefixed_property():\n+    expr4 = A1 * T1 + V3\n+    SI._collect_factor_and_dimension(expr4)\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..3f0342f 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,10 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, milli, volt\n+from sympy.physics.units.util import convert_to\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n@@ -27,6 +29,23 @@ def test_prefix_operations():\n     assert k / dodeca == S(1000) / 12\n     assert dodeca / dodeca == 1\n \n+    # Test for milli prefix with Watts\n+    assert milli * W == W / 1000\n+    assert convert_to(milli * W, W) == W / 1000  # milli*W should convert to mW\n+\n+    # Test for milli prefix with Volts\n+    assert milli * volt == volt / 1000\n+    assert convert_to(milli * volt, volt) == volt / 1000  # milli*volt should convert to mV\n+\n+    # Additional tests to ensure other prefixes work correctly\n+    micro = PREFIXES['u']\n+    assert micro * W == W / 1000000\n+    assert convert_to(micro * W, W) == W / 1000000  # micro*W should convert to uW\n+\n+    # Checking direct mult and division with milli\n+    assert milli / milli == S.One\n+    assert milli * milli == Prefix('micro', '\u03bc', -6, 10)\n+\n     m = Quantity(\"fake_meter\")\n     SI.set_quantity_dimension(m, S.One)\n     SI.set_quantity_scale_factor(m, S.One)\n",
  "django__django-12470": "diff --git a/tests/model_inheritance/models.py b/tests/model_inheritance/models.py\nindex 5dd5a37..cd55394 100644\n--- a/tests/model_inheritance/models.py\n+++ b/tests/model_inheritance/models.py\n@@ -185,6 +185,8 @@ class GrandParent(models.Model):\n \n \n class Parent(GrandParent):\n+    class Meta:\n+        ordering = ['-pk']\n     pass\n \n \n",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..1a86228 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,6 +343,41 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n+    def test_self_referencing_fk_ordering(self):\n+        # Create OneModel instances\n+        one1 = OneModel.objects.create(oneval=1)\n+        one2 = OneModel.objects.create(oneval=2, root=one1)\n+        one3 = OneModel.objects.create(oneval=3, root=one2)\n+\n+        # Create TwoModel instances\n+        two1 = TwoModel.objects.create(record=one1, twoval=10)\n+        two2 = TwoModel.objects.create(record=one2, twoval=20)\n+        two3 = TwoModel.objects.create(record=one3, twoval=30)\n+\n+        # Check ordering by record__root_id\n+        queryset = TwoModel.objects.filter(record__oneval__in=[1,2,3]).order_by('record__root_id')\n+        self.assertQuerysetEqual(\n+            queryset,\n+            [two1.pk, two2.pk, two3.pk],\n+            transform=lambda x: x.pk\n+        )\n+\n+        # Check workaround with annotation and ordering\n+        queryset = TwoModel.objects.filter(record__oneval__in=[1,2,3]).annotate(root_id=F('record__root_id')).order_by('root_id')\n+        self.assertQuerysetEqual(\n+            queryset,\n+            [two1.pk, two2.pk, two3.pk],\n+            transform=lambda x: x.pk\n+        )\n+\n+        # Check ordering by -record__root_id\n+        queryset = TwoModel.objects.filter(record__oneval__in=[1,2,3]).order_by('-record__root_id')\n+        self.assertQuerysetEqual(\n+            queryset,\n+            [two3.pk, two2.pk, two1.pk],\n+            transform=lambda x: x.pk\n+        ) \n+\n     def test_order_by_f_expression(self):\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n",
  "django__django-13265": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..a88fd4c 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3201,8 +3201,26 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         form = SomeForm()\n         self.assertEqual(form['field'].id_for_label, 'myCustomID')\n         self.assertEqual(form['field_none'].id_for_label, 'id_field_none')\n+    \n+    def test_boundfield_subwidget_id_for_label_with_attrs_override(self):\n+        \"\"\"\n+        If an id is provided in the subwidget's `attrs`, it overrides the auto-generated ID.\n+        \"\"\"\n+        class SomeForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('a', 'A'), ('b', 'B')],\n+                widget=CheckboxSelectMultiple,\n+            )\n \n-    def test_boundfield_widget_type(self):\n+        form = SomeForm()\n+        subwidgets = form['field'].subwidgets\n+        # Simulate overriding the id in a subwidget's attrs\n+        subwidgets[0].data['attrs']['id'] = 'custom_id_0'\n+        subwidgets[1].data['attrs']['id'] = 'custom_id_1'\n+\n+        # Validate that this custom id is respected in id_for_label\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_0')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_1')\n         class SomeForm(Form):\n             first_name = CharField()\n             birthday = SplitDateTimeField(widget=SplitHiddenDateTimeWidget)\n",
  "django__django-16400": "diff --git a/tests/auth_tests/test_management.py b/tests/auth_tests/test_management.py\nindex de2502e..f20edbc 100644\n--- a/tests/auth_tests/test_management.py\n+++ b/tests/auth_tests/test_management.py\n@@ -1484,4 +1484,39 @@ class CreatePermissionsTests(TestCase):\n                 content_type__app_label=opts.app_label,\n                 codename=codename,\n             ).exists()\n-        )\n+        )\n+\n+from django.db import connection\n+from django.test import override_settings, TestCase\n+from django.contrib.auth.models import Permission\n+from django.apps import apps\n+from django.core.management import call_command\n+from io import StringIO\n+\n+@override_settings(DATABASE_ROUTERS=['utils.tenant_db_router.TenantDatabaseRouter'])\n+class MigrateCommandDatabaseParameterTests(TestCase):\n+    databases = {\"default\", \"other\"}\n+\n+    def setUp(self):\n+        self.out = StringIO()\n+\n+    def test_migrate_respects_database_parameter(self):\n+        # Delete permissions in the other database to isolate the test\n+        Permission.objects.using(\"other\").delete()\n+\n+        # Run migrate command with database parameter set to \"other\"\n+        call_command('migrate', database='other', stdout=self.out)\n+\n+        # Check if any permissions exist in the \"other\" database\n+        self.assertGreater(Permission.objects.using(\"other\").count(), 0)\n+\n+        # Ensure that no permissions were incorrectly added to the \"default\" database\n+        self.assertEqual(Permission.objects.using(\"default\").count(), 0)\n+\n+    def test_migrate_command_output(self):\n+        call_command('migrate', database='other', stdout=self.out)\n+        output = self.out.getvalue()\n+\n+        # Check that the output contains a reference to using the 'other' database\n+        self.assertIn(\"Running migrations:\", output)\n+        self.assertIn(\"  No migrations to apply.\", output)\n",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..4de88ff 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -658,7 +658,28 @@ def test_colorbar_scale_reset():\n     assert cbar.outline.get_edgecolor() == mcolors.to_rgba('red')\n \n \n-def test_colorbar_get_ticks_2():\n+def test_update_colorbar_after_changing_norm():\n+    import matplotlib.pyplot as plt\n+    from matplotlib.colors import LogNorm\n+    import numpy as np\n+\n+    # Create an image with values ranging over several orders of magnitude\n+    img = 10**np.random.normal(1, 1, size=(50, 50))\n+\n+    # Plot the image\n+    fig, ax = plt.subplots()\n+    im = ax.imshow(img, cmap='gray')\n+    cbar = fig.colorbar(im, ax=ax)\n+\n+    # Change the normalization of the image\n+    im.set_norm(LogNorm())\n+\n+    # The colorbar should update correctly after changing the norm\n+    fig.canvas.draw()  # Trigger any updates without encountering an error\n+\n+    # Check that the colorbar ticks have updated to log scale\n+    tick_labels = [label.get_text() for label in cbar.ax.yaxis.get_ticklabels()]\n+    assert any('1e' in label for label in tick_labels), \"Colorbar tick labels are not in log scale after norm update.\"\n     plt.rcParams['_internal.classic_mode'] = False\n     fig, ax = plt.subplots()\n     pc = ax.pcolormesh([[.05, .95]])\n",
  "pydata__xarray-4094": "",
  "scikit-learn__scikit-learn-25747": "",
  "sphinx-doc__sphinx-8801": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 37d6e17..7775ee3 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -106,6 +106,38 @@ def test_inherited_instance_variable(app):\n     ]\n \n \n+@pytest.mark.skipif(sys.version_info < (3, 6), reason='py36+ is available since python3.6.')\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_annotation_only_member_in_superclass(app: SphinxTestApp):\n+    options = {\"members\": None,\n+               \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'example.Bar', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: example',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n+\n+import sys\n+import pytest\n+from sphinx.testing.util import SphinxTestApp\n+from target.util import do_autodoc\n+\n def test_decorators(app):\n     actual = do_autodoc(app, 'class', 'target.decorator.Baz')\n     assert list(actual) == [\n",
  "sympy__sympy-15346": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex cce4836..0653487 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     symbols, sin, simplify, cos, trigsimp, rad, tan, exptrigsimp,sinh,\n     cosh, diff, cot, Subs, exp, tanh, exp, S, integrate, I,Matrix,\n@@ -358,6 +359,30 @@ def test_issue_2827_trigsimp_methods():\n     assert exptrigsimp(eq) == eq\n \n \n+def test_issue_15129_trigsimp_methods():\n+    # Original test cases\n+    t1 = Matrix([sin(Rational(1, 50)), cos(Rational(1, 50)), 0])\n+    t2 = Matrix([sin(Rational(1, 25)), cos(Rational(1, 25)), 0])\n+    t3 = Matrix([cos(Rational(1, 25)), sin(Rational(1, 25)), 0])\n+    r1 = t1.dot(t2)\n+    r2 = t1.dot(t3)\n+    assert trigsimp(r1) == cos(S(1)/50)\n+    assert trigsimp(r2) == sin(S(3)/50)\n+\n+    # Additional test cases\n+    # Check direct simplification of trigonometric expression with Rationals\n+    r = sin(Rational(1, 50))*sin(Rational(1, 25)) + cos(Rational(1, 50))*cos(Rational(1, 25))\n+    assert simplify(r) == cos(Rational(1, 50) - Rational(1, 25))\n+    assert trigsimp(r) == cos(Rational(1, 50) - Rational(1, 25))\n+\n+    # Test acos simplification\n+    simplified_expr = cos(Rational(1, 50) - Rational(1, 25))\n+    assert simplify(acos(simplified_expr)) == abs(Rational(1, 50) - Rational(1, 25))\n+\n+    # Check with angles resulting in zero using trigonometric identities\n+    angle_zero = sin(Rational(1, 50))*cos(Rational(1, 50)) - cos(Rational(1, 50))*sin(Rational(1, 50))\n+    assert simplify(angle_zero) == 0\n+\n def test_exptrigsimp():\n     def valid(a, b):\n         from sympy.utilities.randtest import verify_numerically as tn\n",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..b44fd63 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4862,8 +4862,34 @@ k = \u2500\u2500\u2500\u2500\u2500                                \\n\\\n     assert pretty(expr) == ascii_str\n     assert upretty(expr) == ucode_str\n \n-\n-def test_units():\n+def test_sum_pretty_print_alignment():\n+    from sympy import Sum, pprint, oo\n+    from sympy.abc import x\n+\n+    expr = Sum(x, (x, 1, oo)) + 3\n+    expected_output_ascii = (\n+        '  oo\\n'\n+        ' ___\\n'\n+        '  \\\\\\n'\n+        '   )  x + 3\\n'\n+        '  /\\n'\n+        ' / \\n'\n+        '---\\n'\n+        'x = 1\\n'\n+    )\n+    expected_output_ucode = (\n+        '  \u221e\\n'\n+        ' ___\\n'\n+        ' \u2572\\n'\n+        '  \u2572  x + 3\\n'\n+        '  \u2571\\n'\n+        ' \u2571\\n'\n+        ' \u203e\u203e\u203e\\n'\n+        'x = 1\\n'\n+    )\n+    # We expect the `+ 3` to be aligned with `x`\n+    assert pretty(expr) == expected_output_ascii\n+    assert upretty(expr) == expected_output_ucode\n     expr = joule\n     ascii_str1 = \\\n \"\"\"\\\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex b2b6202..59ed5c1 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -692,7 +692,19 @@ def test_reshape():\n     raises(ValueError, lambda: reshape([0, 1], [-1]))\n     raises(ValueError, lambda: reshape([0, 1], [3]))\n \n+from sympy.utilities.iterables import uniq\n+from sympy.utilities.pytest import raises\n+\n def test_uniq():\n+    f = [1]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    f = [[1]]\n+    raises(RuntimeError, lambda: [f.remove(i) for i in uniq(f)])\n+    # Additional test cases\n+    g = list('THISTLE')\n+    raises(RuntimeError, lambda: [g.remove(i) for i in uniq(g)])\n+    h = [1, 2, 3, 1, 2, 3]\n+    raises(RuntimeError, lambda: [h.pop() for i in uniq(h)])\n     assert list(uniq(p.copy() for p in partitions(4))) == \\\n         [{4: 1}, {1: 1, 3: 1}, {2: 2}, {1: 2, 2: 1}, {1: 4}]\n     assert list(uniq(x % 2 for x in range(5))) == [0, 1]\n",
  "django__django-11797": "",
  "django__django-15320": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 35f7f03..c9f978b 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -546,6 +546,28 @@ class BasicExpressionsTests(TestCase):\n         subquery_test2 = Company.objects.filter(pk=Subquery(small_companies.filter(num_employees=3)))\n         self.assertCountEqual(subquery_test2, [self.foobar_ltd])\n \n+    def test_subquery_sql(self):\n+        # Testing the SQL generation of Subquery with and without setting the 'subquery' attribute.\n+        from django.db import connection\n+        from apps.models import App\n+        \n+        # Case 1: Subquery without explicitly setting 'subquery' attribute should be incorrect.\n+        apps_subquery = Subquery(App.objects.all())\n+        compiler = apps_subquery.query.get_compiler(connection=connection)\n+        sql, _ = apps_subquery.as_sql(compiler, connection)\n+        self.assertTrue(sql.startswith('SELECT '))  # This should fail as per the issue statement\n+\n+        # Fix by setting subquery attribute\n+        apps_subquery.query.subquery = True\n+        sql, _ = apps_subquery.as_sql(compiler, connection)\n+        self.assertTrue(sql.startswith('(SELECT '))\n+        self.assertTrue(sql.endswith(')'))\n+\n+        # Case 2: Ensure setting 'subquery' attribute on queryset doesn't affect the main query.\n+        queryset = App.objects.all()\n+        self.assertFalse(queryset.query.subquery)\n+        self.assertRaises(AttributeError, lambda: queryset.as_sql(compiler, connection))\n+\n     def test_uuid_pk_subquery(self):\n         u = UUIDPK.objects.create()\n         UUID.objects.create(uuid_fk=u)\n",
  "django__django-15819": "",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..c66de4a 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -152,6 +153,26 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n+    def test_multilevel_reverse_fk_cyclic_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation(\"pool__tournament__pool\"),\n+                ).select_related(\"tournament_pool\", \"tournament_pool__tournament\")\n+            )\n+            self.assertEqual(p[0].tournament_pool.tournament, p[0].pool.tournament)\n+\n+    def test_multilevel_reverse_fk_select_related(self):\n+        with self.assertNumQueries(2):\n+            p = list(\n+                Tournament.objects.filter(id=self.t2.id)\n+                .annotate(\n+                    style=FilteredRelation(\"pool__another_style\"),\n+                )\n+                .select_related(\"style\")\n+            )\n+            self.assertEqual(p[0].style.another_pool, self.p3)\n+\n     def test_reverse_fk_select_related_multiple(self):\n         with self.assertNumQueries(1):\n             ps = list(\n@@ -163,4 +184,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex ad1a5e1..73d875e 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from datetime import datetime\n import io\n@@ -7,7 +8,10 @@ from threading import Timer\n from types import SimpleNamespace\n import warnings\n \n+import pickle\n import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.figure import Figure\n import pytest\n from PIL import Image\n \n",
  "mwaskom__seaborn-2848": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 5a5e126..c14601b 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -1,3 +1,4 @@\n+\n from itertools import product\n import numpy as np\n import matplotlib as mpl\n@@ -9,7 +10,7 @@ from numpy.testing import assert_array_equal\n \n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n-\n+import seaborn as sns\n from seaborn.relational import (\n     _RelationalPlotter,\n     _LinePlotter,\n@@ -1623,7 +1624,35 @@ class TestScatterPlotter(SharedAxesLevelTests, Helpers):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n-    def test_linewidths(self, long_df):\n+    def test_pairgrid_hue_issue(self):\n+        # Load the iris dataset\n+        iris = sns.load_dataset(\"iris\")\n+        \n+        # Create PairGrid as per the issue description\n+        g = sns.PairGrid(iris, y_vars=[\"sepal_length\", \"sepal_width\"], x_vars=[\"petal_length\", \"petal_width\"])\n+        \n+        try:\n+            # Attempt to map scatterplot with hue\n+            g.map(sns.scatterplot, hue=iris[\"species\"])\n+            g.map(sns.regplot, scatter=False)\n+            plotted = True\n+        except Exception as e:\n+            print(f\"Error occurred: {e}\")\n+            plotted = False\n+        \n+        assert plotted, \"PairGrid with mapped hue should not raise an error.\"\n+        \n+        # Check another valid case where 'hue' is passed during PairGrid creation\n+        try:\n+            g = sns.PairGrid(iris, y_vars=[\"sepal_length\", \"sepal_width\"], x_vars=[\"petal_length\", \"petal_width\"], hue=\"species\")\n+            g.map(sns.scatterplot)\n+            g.map(sns.regplot, scatter=False)\n+            plotted_with_hue = True\n+        except Exception as e:\n+            print(f\"Error with hue in PairGrid: {e}\")\n+            plotted_with_hue = False\n+        \n+        assert plotted_with_hue, \"PairGrid with hue parameter should not raise an error.\"\n \n         f, ax = plt.subplots()\n \n",
  "pytest-dev__pytest-5413": "diff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 226bfb9..337fb13 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -347,7 +347,32 @@ def test_excinfo_str():\n     assert len(s.split(\":\")) >= 3  # on windows it's 4\n \n \n-def test_excinfo_for_later():\n+def test_excinfo_for_raises_context():\n+    import pytest\n+\n+    # Test str() on a normal exception captured by a try-except block\n+    try:\n+        raise LookupError(\n+            f\"A\\n\"\n+            f\"B\\n\"\n+            f\"C\"\n+        )\n+    except LookupError as e:\n+        assert str(e) == \"A\\nB\\nC\"  # This is the expected behavior\n+\n+    # Test str() on the exception using pytest.raises, should not match above\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\n+            f\"A\\n\"\n+            f\"B\\n\"\n+            f\"C\"\n+        )\n+\n+    assert str(excinfo) != \"A\\nB\\nC\"  # Direct str on excinfo gives a different format\n+    assert str(excinfo.value) == \"A\\nB\\nC\"  # Correct way to access the message\n+\n+    # Check if the .value is of correct exception type\n+    assert isinstance(excinfo.value, LookupError)\n     e = ExceptionInfo.for_later()\n     assert \"for raises\" in repr(e)\n     assert \"for raises\" in str(e)\n",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..1a5ac97 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -404,6 +404,10 @@ class TestCustomConftests:\n         testdir.makepyfile(\"def test_x(): pass\")\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n+        \n+        # New test for the shortcut -C\n+        result_shortcut = testdir.runpytest(\"-C\")\n+        result_shortcut.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n \n     def test_pytest_collect_file_from_sister_dir(self, testdir):\n         sub1 = testdir.mkpydir(\"sub1\")\n",
  "sphinx-doc__sphinx-10451": "diff --git a/tests/roots/test-ext-autodoc/target/typehints.py b/tests/roots/test-ext-autodoc/target/typehints.py\nindex 100ea06..1cef0c9 100644\n--- a/tests/roots/test-ext-autodoc/target/typehints.py\n+++ b/tests/roots/test-ext-autodoc/target/typehints.py\n@@ -94,8 +94,14 @@ def missing_attr(c,\n class _ClassWithDocumentedInit:\n     \"\"\"Class docstring.\"\"\"\n \n-    def __init__(self, x: int) -> None:\n+    def __init__(self, x: int, *args: int, **kwargs: int) -> None:\n         \"\"\"Init docstring.\n \n         :param x: Some integer\n-        \"\"\"\n+        :param *args: Some additional integers\n+        :param **kwargs: Some additional keyword arguments\n+        \"\"\"\n+        \"\"\"Init docstring.\n+\n+        :param x: Some integer\n+        \"\"\"\n",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..e883e26 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -84,7 +84,21 @@ def test_Identity():\n     assert In.inverse() == In\n     assert In.conjugate() == In\n \n-def test_Identity_doit():\n+def test_sum_of_identity_matrix_elements():\n+    from sympy import Symbol, symbols, MatrixSymbol, Sum, Q as Query, assuming, ask, refine\n+\n+    n = Symbol('n', integer=True, positive=True)\n+    i, j = symbols('i j', integer=True)\n+    M = MatrixSymbol('M', n, n)\n+\n+    with assuming(Query.orthogonal(M)):\n+        e = refine((M.T * M).doit())\n+\n+    # Check if the sum of all elements is 'n'\n+    assert Sum(Sum(e[i, j], (i, 0, n-1)), (j, 0, n-1)).doit() == n\n+\n+    # Check if the sum of diagonal elements is 'n'\n+    assert Sum(e[i, i], (i, 0, n-1)).doit() == n\n     Inn = Identity(Add(n, n, evaluate=False))\n     assert isinstance(Inn.rows, Add)\n     assert Inn.doit() == Identity(2*n)\n",
  "sympy__sympy-20049": "",
  "sympy__sympy-21612": ""
}