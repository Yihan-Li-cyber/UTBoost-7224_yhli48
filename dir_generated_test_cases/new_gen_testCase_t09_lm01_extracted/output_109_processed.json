{
  "astropy__astropy-12907": "diff --git a/astropy/modeling/tests/test_separable.py b/astropy/modeling/tests/test_separable.py\nindex 88711b0..9a50a24 100644\n--- a/astropy/modeling/tests/test_separable.py\n+++ b/astropy/modeling/tests/test_separable.py\n@@ -134,8 +134,30 @@ def test_separable(compound_model, result):\n     assert_allclose(is_separable(compound_model), result[0])\n     assert_allclose(separability_matrix(compound_model), result[1])\n \n-\n-def test_custom_model_separable():\n+def test_nested_compound_model_separability():\n+    \"\"\"\n+    Test the separability_matrix for nested CompoundModels to verify \n+    the bug-related issue with nested compound models.\n+    \"\"\"\n+    # Import models required for these tests\n+    from astropy.modeling import models as m\n+    from astropy.modeling.separable import separability_matrix\n+\n+    # Define models for testing\n+    linear = m.Linear1D(10) & m.Linear1D(5)\n+    pix2sky_tan = m.Pix2Sky_TAN()\n+\n+    # Test nested compound models\n+    nested_model = pix2sky_tan & linear\n+    expected_separability_nested = np.array([\n+        [ True,  True, False, False],\n+        [ True,  True, False, False],\n+        [False, False,  True,  True],\n+        [False, False,  True,  True]\n+    ])\n+\n+    # Assert on the separability matrix to see if the fix is verified\n+    assert_allclose(separability_matrix(nested_model), expected_separability_nested)\n     @custom_model\n     def model_a(x):\n         return x\n",
  "astropy__astropy-14182": "diff --git a/astropy/io/ascii/tests/test_rst.py b/astropy/io/ascii/tests/test_rst.py\nindex e786c06..b0ec982 100644\n--- a/astropy/io/ascii/tests/test_rst.py\n+++ b/astropy/io/ascii/tests/test_rst.py\n@@ -1,8 +1,13 @@\n+\n # Licensed under a 3-clause BSD style license - see LICENSE.rst\n \n from io import StringIO\n \n from astropy.io import ascii\n+from astropy.table import QTable\n+import astropy.units as u\n+import numpy as np\n+from io import StringIO\n \n from .common import assert_almost_equal, assert_equal\n \n@@ -184,4 +189,62 @@ Col1      Col2 Col3 Col4\n  2.4 's worlds    2    2\n ==== ========= ==== ====\n \"\"\",\n-    )\n+    )\n+\n+def test_rst_with_header_rows():\n+    \"\"\"Test writing and reading a table with header_rows specified in RST format.\"\"\"\n+    # Define lines for an input RST format table with header rows\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct     \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\",\n+    ]\n+    \n+    # Read the table using header_rows for name, unit, and dtype\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    \n+    # Verify the units and data types are correctly interpreted\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"wave\"].dtype == np.float64\n+    assert tbl[\"response\"].dtype == np.float32\n+    assert tbl[\"ints\"].dtype == np.int8\n+\n+    # Write the table back to RST format and verify output matches the original\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"dtype\"])\n+    assert out.getvalue().splitlines() == lines\n+\n+def test_rst_multilevel_header():\n+    \"\"\"Test reading and writing with multiple header rows in RST format.\"\"\"\n+    # Define multiple lines for an input RST format table with multiple header rows\n+    lines = [\n+        \"======= ======== ====\",\n+        \"   wave response ints\",\n+        \"     nm       ct   - \",\n+        \"  meter     count -- \",\n+        \"float64  float32 int8\",\n+        \"======= ======== ====\",\n+        \"  350.0      1.0    1\",\n+        \"  950.0      2.0    2\",\n+        \"======= ======== ====\",\n+    ]\n+\n+    # Read the table using header_rows, interpreting additional unit-like rows\n+    tbl = QTable.read(lines, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"alt_unit\", \"dtype\"])\n+    \n+    # Ensure the table is read correctly across all headers\n+    assert tbl[\"wave\"].unit == u.nm\n+    assert tbl[\"response\"].unit == u.ct\n+    assert tbl[\"wave\"].dtype == np.float64\n+    assert tbl[\"response\"].dtype == np.float32\n+\n+    # Write the table, checking restructured text handling for multilayer headers\n+    out = StringIO()\n+    tbl.write(out, format=\"ascii.rst\", header_rows=[\"name\", \"unit\", \"alt_unit\", \"dtype\"])\n+    assert out.getvalue().splitlines() == lines\n",
  "astropy__astropy-14365": "diff --git a/astropy/io/ascii/tests/test_qdp.py b/astropy/io/ascii/tests/test_qdp.py\nindex 9b66109..7c46d58 100644\n--- a/astropy/io/ascii/tests/test_qdp.py\n+++ b/astropy/io/ascii/tests/test_qdp.py\n@@ -42,8 +42,35 @@ def test_get_tables_from_qdp_file(tmp_path):\n     assert table2.meta[\"comments\"][0].startswith(\"WT -- hardness\")\n     assert np.isclose(table2[\"MJD_nerr\"][0], -2.37847222222222e-05)\n \n+import pytest\n+import numpy as np\n+from astropy.table import Table\n+from astropy.utils.exceptions import AstropyUserWarning\n+\n+def test_lowercase_commands(tmp_path):\n+    example_qdp = \"\"\"\n+    ! Test lowercase commands\n+    read terr 1\n+    read serr 2\n+    ! Data block comment\n+    !MJD            Err (pos)       Err(neg)        Rate            Error\n+    53000.123456 2.37847222222222e-05    -2.37847222222222e-05   NO       0.212439\n+    55045.099887 1.14467592592593e-05    -1.14467592592593e-05   0.000000        0.000000\n+    NO NO NO NO NO\n+    \"\"\"\n+\n+    path = str(tmp_path / \"test_lowercase.qdp\")\n+\n+    with open(path, \"w\") as fp:\n+        fp.write(example_qdp)\n+\n+    # Expect no exceptions and correct reading\n+    with pytest.warns(AstropyUserWarning):\n+        table = Table.read(path, format='ascii.qdp')\n \n-def test_roundtrip(tmp_path):\n+    assert len(table) == 2  # Check number of data rows\n+    assert table['MJD'][0] == 53000.123456\n+    assert np.isclose(table['Rate'][1], 0.0)\n     example_qdp = \"\"\"\n     ! Swift/XRT hardness ratio of trigger: XXXX, name: BUBU X-2\n     ! Columns are as labelled\n",
  "astropy__astropy-14995": "",
  "astropy__astropy-6938": "diff --git a/astropy/io/fits/tests/test_table.py b/astropy/io/fits/tests/test_table.py\nindex 485705a..f4a4331 100644\n--- a/astropy/io/fits/tests/test_table.py\n+++ b/astropy/io/fits/tests/test_table.py\n@@ -251,9 +251,26 @@ class TestTableFunctions(FitsTestCase):\n         assert (t[1].data.field(0) == np.array([1, 2])).all()\n \n         # When there are scaled columns, the raw data are in data._parent\n-\n         t.close()\n \n+    def test_d_exponent_in_fits(self):\n+        \"\"\"Test writing and reading a FITS file with 'D' exponent.\"\"\"\n+\n+        r1 = np.array([11.0, 12.0, 13.5])\n+        c1 = fits.Column(name='col1', format='D', array=r1)\n+        hdu = fits.TableHDU.from_columns([c1])\n+\n+        hdu.writeto(self.temp('d_exponent.fits'), overwrite=True)\n+        with open(self.temp('d_exponent.fits')) as f:\n+            content = f.read()\n+            # Check that 'D' is used as the exponent character\n+            assert '1.1000000000000000D+01' in content\n+            assert '1.2000000000000000D+01' in content\n+            assert '1.3500000000000000D+01' in content\n+\n+        with fits.open(self.temp('d_exponent.fits')) as hdul:\n+            assert comparerecords(hdu.data, hdul[1].data)\n+\n     def test_ascii_table(self):\n         # ASCII table\n         a = fits.open(self.data('ascii.fits'))\n",
  "django__django-10914": "diff --git a/tests/test_utils/tests.py b/tests/test_utils/tests.py\nindex 3760491..5280103 100644\n--- a/tests/test_utils/tests.py\n+++ b/tests/test_utils/tests.py\n@@ -1090,6 +1090,16 @@ class OverrideSettingsTests(SimpleTestCase):\n         base_url attribute of django.core.files.storage.default_storage.\n         \"\"\"\n         self.assertEqual(default_storage.base_location, '')\n+\n+    def test_default_file_upload_permissions(self):\n+        \"\"\"\n+        Ensure the default FILE_UPLOAD_PERMISSIONS is set to 0o644.\n+        This checks if the default_storage.file_permissions_mode is 0o644\n+        when FILE_UPLOAD_PERMISSIONS is not explicitly set.\n+        \"\"\"\n+        default_permission = getattr(settings, 'FILE_UPLOAD_PERMISSIONS', None)\n+        if default_permission is None:\n+            self.assertEqual(default_storage.file_permissions_mode, 0o644)\n         with self.settings(MEDIA_URL='/test_value/'):\n             self.assertEqual(default_storage.base_url, '/test_value/')\n \n",
  "django__django-10924": "",
  "django__django-11001": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 4e3940c..a8669c3 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -367,7 +367,66 @@ class BasicExpressionsTests(TestCase):\n         )\n         self.assertEqual(str(qs.query).count('JOIN'), 1)\n \n-    def test_ticket_18375_chained_filters(self):\n+    def test_order_by_multiline_sql_similar_clauses(self):\n+        \"\"\"Test ordering in queries with multiline RawSQL with similar trailing lines to ensure they aren't incorrectly treated as duplicates.\"\"\"\n+        raw_order_by = (\n+            RawSQL('''\n+                CASE WHEN status = 'active'\n+                     THEN 3\n+                     ELSE 1 END\n+            ''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN status = 'pending'\n+                     THEN 2\n+                     ELSE 1 END\n+            ''', []).asc(),\n+            RawSQL('''\n+                CASE WHEN status = 'inactive'\n+                     THEN 4\n+                     ELSE 1 END\n+            ''', []).asc()\n+        )\n+        # Assuming the models have the following status order: ['inactive', 'active', 'pending']\n+        expected_order = [self.foobar_ltd, self.example_inc, self.gmbh]\n+        for qs in (\n+            Company.objects.all(),\n+            Company.objects.distinct(),\n+        ):\n+            with self.subTest(qs=qs):\n+                self.assertSequenceEqual(\n+                    qs.order_by(*raw_order_by),\n+                    expected_order,\n+                )\n+\n+    def test_order_by_with_trailing_variation(self):\n+        \"\"\"Test if adding a small differentiation in similar multiline RawSQL doesn't affect order identification.\"\"\"\n+        raw_order_by = (\n+            RawSQL('''\n+                CASE WHEN status = 'archived'\n+                     THEN 5\n+                     ELSE 1 END\n+            ''', []).desc(),\n+            RawSQL('''\n+                CASE WHEN status = 'deleted'\n+                     THEN 6\n+                     ELSE 1 END -- small comment to differentiate\n+            ''', []).asc(),\n+            RawSQL('''\n+                CASE WHEN status = 'archived'\n+                     THEN 4\n+                     ELSE 1 END\n+            ''', []).asc()\n+        )\n+        # Test assumes no archived/deleted entries at this time\n+        for qs in (\n+            Company.objects.all(),\n+            Company.objects.distinct(),\n+        ):\n+            with self.subTest(qs=qs):\n+                self.assertSequenceEqual(\n+                    qs.order_by(*raw_order_by),\n+                    [self.example_inc, self.gmbh, self.foobar_ltd],  # Assuming current order unchanged by empty archived/deleted\n+                )\n         # F() expressions do not reuse joins from previous filter.\n         qs = Employee.objects.filter(\n             company_ceo_set__num_employees=F('pk')\n",
  "django__django-11039": "",
  "django__django-11049": "diff --git a/tests/model_fields/test_durationfield.py b/tests/model_fields/test_durationfield.py\nindex e5c5e39..f7df551 100644\n--- a/tests/model_fields/test_durationfield.py\n+++ b/tests/model_fields/test_durationfield.py\n@@ -72,10 +72,33 @@ class TestValidation(SimpleTestCase):\n         with self.assertRaises(exceptions.ValidationError) as cm:\n             field.clean('not a datetime', None)\n         self.assertEqual(cm.exception.code, 'invalid')\n+        expected_error_message = (\n+            \"'not a datetime' value has an invalid format. \"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n+        )\n         self.assertEqual(\n             cm.exception.message % cm.exception.params,\n-            \"'not a datetime' value has an invalid format. \"\n-            \"It must be in [DD] [HH:[MM:]]ss[.uuuuuu] format.\"\n+            expected_error_message\n+        )\n+\n+    def test_correct_error_message_for_invalid_duration(self):\n+        field = models.DurationField()\n+        # Test the wrong format: Missing seconds\n+        with self.assertRaises(exceptions.ValidationError) as cm:\n+            field.clean('1:30', None)\n+        self.assertEqual(\n+            cm.exception.message % cm.exception.params,\n+            \"'1:30' value has an invalid format. \"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n+        )\n+        \n+        # Test the correct format but invalid duration as string\n+        with self.assertRaises(exceptions.ValidationError) as cm:\n+            field.clean('invalid', None)\n+        self.assertEqual(\n+            cm.exception.message % cm.exception.params,\n+            \"'invalid' value has an invalid format. \"\n+            \"It must be in [DD] [[HH:]MM:]ss[.uuuuuu] format.\"\n         )\n \n \n@@ -84,4 +107,4 @@ class TestFormField(SimpleTestCase):\n \n     def test_formfield(self):\n         field = models.DurationField()\n-        self.assertIsInstance(field.formfield(), forms.DurationField)\n+        self.assertIsInstance(field.formfield(), forms.DurationField)\n",
  "django__django-11099": "diff --git a/tests/auth_tests/test_validators.py b/tests/auth_tests/test_validators.py\nindex 688e6ff..90c661b 100644\n--- a/tests/auth_tests/test_validators.py\n+++ b/tests/auth_tests/test_validators.py\n@@ -238,6 +238,8 @@ class UsernameValidatorsTests(SimpleTestCase):\n             \"o'connell\", \"\u0639\u0628\u062f \u0627\u0644\",\n             \"zerowidth\\u200Bspace\", \"nonbreaking\\u00A0space\",\n             \"en\\u2013dash\",\n+            'trailingnewline\\n',\n+            'newline\\u000A',\n         ]\n         v = validators.UnicodeUsernameValidator()\n         for valid in valid_usernames:\n@@ -258,4 +260,4 @@ class UsernameValidatorsTests(SimpleTestCase):\n         for invalid in invalid_usernames:\n             with self.subTest(invalid=invalid):\n                 with self.assertRaises(ValidationError):\n-                    v(invalid)\n+                    v(invalid)\n",
  "django__django-11133": "",
  "django__django-11179": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 4966d82..1e96593 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -1,7 +1,9 @@\n+\n from math import ceil\n \n from django.db import IntegrityError, connection, models\n from django.db.models.sql.constants import GET_ITERATOR_CHUNK_SIZE\n+from django.db.models.deletion import Collector\n from django.test import TestCase, skipIfDBFeature, skipUnlessDBFeature\n \n from .models import (\n@@ -471,6 +473,17 @@ class FastDeleteTests(TestCase):\n         self.assertEqual(User.objects.count(), 1)\n         self.assertTrue(User.objects.filter(pk=u2.pk).exists())\n \n+    def test_fast_delete_instance_set_pk_none(self):\n+        # Create a User instance\n+        u = User.objects.create()\n+        # Verify that the Collector can fast delete the User instance\n+        collector = Collector(using='default')\n+        self.assertTrue(collector.can_fast_delete(u))\n+        # Delete the User instance\n+        u.delete()\n+        # Check if the PK is set to None after deletion\n+        self.assertIsNone(u.pk)\n+\n     def test_fast_delete_joined_qs(self):\n         a = Avatar.objects.create(desc='a')\n         User.objects.create(avatar=a)\n",
  "django__django-11283": "diff --git a/tests/auth_tests/test_migrations.py b/tests/auth_tests/test_migrations.py\nindex 3d9b0fc..1c12e6b 100644\n--- a/tests/auth_tests/test_migrations.py\n+++ b/tests/auth_tests/test_migrations.py\n@@ -1,3 +1,4 @@\n+\n from importlib import import_module\n \n from django.apps import apps\n@@ -140,6 +141,44 @@ class ProxyModelWithSameAppLabelTests(TestCase):\n         self.custom_permission.refresh_from_db()\n         self.assertEqual(self.custom_permission.content_type, self.concrete_content_type)\n \n+    def test_migration_with_existing_proxy_permissions(self):\n+        \"\"\"\n+        Test migrations handling when permissions for proxy models already exist.\n+        This should handle duplicates without causing integrity errors.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='add_proxy',\n+            name='Can add proxy',\n+        )\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='change_proxy',\n+            name='Can change proxy',\n+        )\n+        try:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+            output_message = \"Migration of proxy permissions completed without errors.\"\n+        except IntegrityError:\n+            output_message = \"IntegrityError detected during proxy permissions migration.\"\n+        self.assertIn(\"completed without errors\", output_message)\n+\n+    def test_captured_stdout_for_proxy_permission_issues(self):\n+        \"\"\"\n+        Capture standard output to confirm that a message is logged \n+        about existing permissions when updating proxy model permissions.\n+        \"\"\"\n+        proxy_model_content_type = ContentType.objects.get_for_model(Proxy, for_concrete_model=False)\n+        Permission.objects.create(\n+            content_type=proxy_model_content_type,\n+            codename='delete_proxy',\n+            name='Can delete proxy',\n+        )\n+        with captured_stdout() as stdout:\n+            update_proxy_permissions.update_proxy_model_permissions(apps, None)\n+        self.assertIn('A problem arose migrating proxy model permissions', stdout.getvalue())\n+\n     def test_user_keeps_same_permissions_after_migrating_backward(self):\n         user = User.objects.create()\n         user.user_permissions.add(self.default_permission)\n",
  "django__django-11422": "diff --git a/tests/utils_tests/test_autoreload.py b/tests/utils_tests/test_autoreload.py\nindex d8e4469..eb3f042 100644\n--- a/tests/utils_tests/test_autoreload.py\n+++ b/tests/utils_tests/test_autoreload.py\n@@ -13,6 +13,7 @@ from importlib import import_module\n from pathlib import Path\n from unittest import mock, skip, skipIf\n \n+import sys\n from django.apps.registry import Apps\n from django.test import SimpleTestCase\n from django.test.utils import extend_sys_path\n@@ -56,7 +57,21 @@ class TestIterModulesAndFiles(SimpleTestCase):\n         self.addCleanup(shutil.rmtree, dirname)\n         return Path(dirname) / filename\n \n-    def test_paths_are_pathlib_instances(self):\n+    def test_main_module_is_resolved(self):\n+        main_module = sys.modules['__main__']\n+        self.assertFileFound(Path(main_module.__file__))\n+\n+    def test_manage_py_change_triggers_reload(self):\n+        \"\"\"\n+        Edit the manage.py and verify it's detected by autoreload.\n+        \"\"\"\n+        filename = Path(sys.modules['__main__'].__file__).resolve()\n+        self.clear_autoreload_caches()\n+        self.assertFileFound(filename)\n+        # Simulate a change in the manage.py file\n+        with open(filename, 'a') as f:\n+            f.write(\"\\n# Test change\\n\")\n+        self.assertFileFound(filename)\n         for filename in autoreload.iter_all_python_module_files():\n             self.assertIsInstance(filename, Path)\n \n",
  "django__django-11583": "",
  "django__django-11620": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 485796f..981244e 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -6,6 +6,8 @@ import sys\n import tempfile\n import threading\n from io import StringIO\n+from django.http import Http404\n+from django.urls.converters import IntConverter\n from pathlib import Path\n from unittest import mock\n \n",
  "django__django-11742": "diff --git a/tests/invalid_models_tests/test_ordinary_fields.py b/tests/invalid_models_tests/test_ordinary_fields.py\nindex fc2ea82..5c8dfa7 100644\n--- a/tests/invalid_models_tests/test_ordinary_fields.py\n+++ b/tests/invalid_models_tests/test_ordinary_fields.py\n@@ -79,6 +79,63 @@ class BinaryFieldTests(SimpleTestCase):\n                 id='fields.E170',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n \n @isolate_apps('invalid_models_tests')\n@@ -110,6 +167,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E120',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     def test_negative_max_length(self):\n         class Model(models.Model):\n@@ -123,6 +237,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E121',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     def test_bad_max_length_value(self):\n         class Model(models.Model):\n@@ -136,6 +307,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E121',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     def test_str_max_length_value(self):\n         class Model(models.Model):\n@@ -149,6 +377,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E121',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     def test_str_max_length_type(self):\n         class Model(models.Model):\n@@ -162,6 +447,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E121'\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     def test_non_iterable_choices(self):\n         class Model(models.Model):\n@@ -175,6 +517,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E004',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     def test_non_iterable_choices_two_letters(self):\n         \"\"\"Two letters isn't a valid choice pair.\"\"\"\n@@ -190,6 +589,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E005',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     def test_iterable_of_iterable_choices(self):\n         class ThingItem:\n@@ -271,6 +727,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E005',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     def test_choices_named_group_bad_structure(self):\n         class Model(models.Model):\n@@ -292,6 +805,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E005',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     def test_choices_named_group_lazy(self):\n         class Model(models.Model):\n@@ -316,6 +886,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E006',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     def test_bad_validators(self):\n         class Model(models.Model):\n@@ -333,6 +960,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='fields.E008',\n             ),\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n     @unittest.skipUnless(connection.vendor == 'mysql',\n                          \"Test valid only for MySQL\")\n@@ -351,6 +1035,63 @@ class CharFieldTests(SimpleTestCase):\n                 id='mysql.E001',\n             )\n         ])\n+    \n+    def test_max_length_to_fit_longest_choice(self):\n+        # Test a normal case where max_length fits the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+        \n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [])\n+\n+    def test_max_length_too_small_for_choices(self):\n+        # Test cases where max_length is too small for the longest choice\n+        class Model(models.Model):\n+            field = models.CharField(\n+                max_length=2,\n+                choices=[\n+                    ('OK', 'Good'),\n+                    ('BAD', 'Bad'),\n+                ]\n+            )\n+\n+        field = Model._meta.get_field('field')\n+        self.assertEqual(field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (3 characters).\",\n+                obj=field,\n+                id='fields.E009',\n+            ),\n+        ])\n+\n+        class NestedModel(models.Model):\n+            field = models.CharField(\n+                max_length=3,\n+                choices=[\n+                    ('Nested', [\n+                        ('OK', 'Good'),\n+                        ('BAD', 'Badly')\n+                    ]),\n+                    ('Group', [\n+                        ('TOOLONG', 'No Way'),\n+                    ])\n+                ]\n+            )\n+\n+        nested_field = NestedModel._meta.get_field('field')\n+        self.assertEqual(nested_field.check(), [\n+            Error(\n+                \"'max_length' is too small to fit the longest value in 'choices' (7 characters).\",\n+                obj=nested_field,\n+                id='fields.E009',\n+            ),\n+        ])\n \n \n @isolate_apps('invalid_models_tests')\n",
  "django__django-11815": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex eec2872..5b73dfc 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -251,8 +251,30 @@ class WriterTests(SimpleTestCase):\n         pattern = re.compile(r'^foo$')\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n         self.assertEqual(self.serialize_round_trip(lazy_pattern), pattern)\n-\n-    def test_serialize_enums(self):\n+    \n+    def test_serialize_translated_enums(self):\n+        # Setup a translated Enum \n+        class TranslatedEnum(Enum):\n+            APPLE = _('Apple')  # This is meant to be translated\n+            ORANGE = _('Orange')\n+\n+        # This represents a CharField instance using TranslatedEnum with a default value.\n+        field = models.CharField(default=TranslatedEnum.APPLE, max_length=128)\n+        \n+        # Serialize the field\n+        serialized_data, imports = MigrationWriter.serialize(field)\n+\n+        # Expected behavior is that the serialized form uses the Enum name, not its value.\n+        expected_serialization = (\n+            \"models.CharField(default=migrations.test_writer.TranslatedEnum['APPLE'], \"\n+            \"max_length=128)\"\n+        )\n+\n+        # Assert that the serialization matches the expected form\n+        self.assertEqual(serialized_data, expected_serialization)\n+        \n+        # Ensure that the necessary imports are also correctly serialized\n+        self.assertIn(\"import migrations.test_writer\", imports)\n         class TextEnum(enum.Enum):\n             A = 'a-value'\n             B = 'value-b'\n",
  "django__django-11848": "diff --git a/tests/utils_tests/test_http.py b/tests/utils_tests/test_http.py\nindex f59e0ec..7fac517 100644\n--- a/tests/utils_tests/test_http.py\n+++ b/tests/utils_tests/test_http.py\n@@ -1,3 +1,4 @@\n+\n import unittest\n from datetime import datetime\n \n@@ -312,7 +313,28 @@ class HttpDateProcessingTests(unittest.TestCase):\n         t = 1167616461.0\n         self.assertEqual(http_date(t), 'Mon, 01 Jan 2007 01:54:21 GMT')\n \n-    def test_parsing_rfc1123(self):\n+    @mock.patch('django.utils.http.datetime.datetime')\n+    def test_parsing_rfc850_with_edge_cases(self, mocked_datetime):\n+        mocked_datetime.side_effect = datetime\n+        mocked_datetime.utcnow = mock.Mock()\n+\n+        current_dates = [\n+            datetime(2049, 1, 1),\n+            datetime(2050, 1, 1),\n+            datetime(2051, 1, 1),\n+        ]\n+        test_cases = [\n+            (current_dates[0], 'Saturday, 01-Jan-50 00:00:00 GMT', datetime(1950, 1, 1, 0, 0, 0)),\n+            (current_dates[1], 'Saturday, 01-Jan-50 00:00:00 GMT', datetime(2050, 1, 1, 0, 0, 0)),\n+            (current_dates[2], 'Saturday, 01-Jan-51 00:00:00 GMT', datetime(1951, 1, 1, 0, 0, 0)),\n+            (current_dates[0], 'Friday, 31-Dec-49 23:59:59 GMT', datetime(2049, 12, 31, 23, 59, 59)),\n+        ]\n+\n+        for current_date, input_date, expected_date in test_cases:\n+            with self.subTest(input_date=input_date):\n+                mocked_datetime.utcnow.return_value = current_date\n+                parsed = parse_http_date(input_date)\n+                self.assertEqual(datetime.utcfromtimestamp(parsed), expected_date)\n         parsed = parse_http_date('Sun, 06 Nov 1994 08:49:37 GMT')\n         self.assertEqual(datetime.utcfromtimestamp(parsed), datetime(1994, 11, 6, 8, 49, 37))\n \n",
  "django__django-11964": "diff --git a/tests/model_enums/tests.py b/tests/model_enums/tests.py\nindex 837d657..9124c9e 100644\n--- a/tests/model_enums/tests.py\n+++ b/tests/model_enums/tests.py\n@@ -32,6 +32,38 @@ class Vehicle(models.IntegerChoices):\n     __empty__ = _('(Unknown)')\n \n \n+from django.test import TestCase\n+from django.db import models\n+from django.utils.translation import gettext_lazy as _\n+\n+# Adding model and test to simulate original issue\n+\n+class MyChoice(models.TextChoices):\n+    FIRST_CHOICE = \"first\", _(\"The first choice, it is\")\n+    SECOND_CHOICE = \"second\", _(\"The second choice, it is\")\n+\n+class MyObject(models.Model):\n+    my_str_value = models.CharField(max_length=10, choices=MyChoice.choices)\n+\n+class EnumTest(TestCase):\n+    def setUp(self) -> None:\n+        self.my_object = MyObject.objects.create(my_str_value=MyChoice.FIRST_CHOICE)\n+\n+    def test_created_object_is_str(self):\n+        my_object = self.my_object\n+        self.assertIsInstance(my_object.my_str_value, str)\n+        self.assertEqual(str(my_object.my_str_value), \"first\")\n+\n+    def test_retrieved_object_is_str(self):\n+        my_object = MyObject.objects.last()\n+        self.assertIsInstance(my_object.my_str_value, str)\n+        self.assertEqual(str(my_object.my_str_value), \"first\")\n+\n+    def test_enum_object_str_conversion(self):\n+        # Test that str conversion of Enum returns the correct value\n+        self.assertEqual(str(MyChoice.FIRST_CHOICE), \"first\")\n+        self.assertEqual(MyChoice.FIRST_CHOICE.value, \"first\")\n+\n class Gender(models.TextChoices):\n     MALE = 'M'\n     FEMALE = 'F'\n",
  "django__django-11999": "",
  "django__django-12113": "",
  "django__django-12125": "",
  "django__django-12184": "",
  "django__django-12284": "diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py\nindex 7dc81d2..95730b5 100644\n--- a/tests/model_fields/tests.py\n+++ b/tests/model_fields/tests.py\n@@ -1,3 +1,7 @@\n+\n+from django.db import models\n+from django.test import TestCase\n+\n import pickle\n \n from django import forms\n",
  "django__django-12286": "diff --git a/tests/check_framework/test_translation.py b/tests/check_framework/test_translation.py\nindex 7c90b94..97c5563 100644\n--- a/tests/check_framework/test_translation.py\n+++ b/tests/check_framework/test_translation.py\n@@ -1,9 +1,10 @@\n+\n from django.core.checks import Error\n from django.core.checks.translation import (\n     check_language_settings_consistent, check_setting_language_code,\n     check_setting_languages, check_setting_languages_bidi,\n )\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, override_settings\n \n \n class TranslationCheckTests(SimpleTestCase):\n@@ -75,6 +76,24 @@ class TranslationCheckTests(SimpleTestCase):\n                     Error(msg % tag, id='translation.E003'),\n                 ])\n \n+    @override_settings(\n+        USE_I18N=True,\n+        LANGUAGES=[\n+            ('de', 'German'),\n+            ('es', 'Spanish'),\n+            ('fr', 'French'),\n+            ('ca', 'Catalan'),\n+        ],\n+    )\n+    def test_base_language_available(self):\n+        tests = [\n+            'de-at',     # sublanguage where base (de) is available\n+            'fr-ca',     # sublanguage where base (fr) is available\n+        ]\n+        for tag in tests:\n+            with self.subTest(tag), self.settings(LANGUAGE_CODE=tag):\n+                self.assertEqual(check_language_settings_consistent(None), [])\n+\n     def test_inconsistent_language_settings(self):\n         msg = (\n             'You have provided a value for the LANGUAGE_CODE setting that is '\n",
  "django__django-12308": "diff --git a/tests/admin_utils/tests.py b/tests/admin_utils/tests.py\nindex acbcf33..bcf8edb 100644\n--- a/tests/admin_utils/tests.py\n+++ b/tests/admin_utils/tests.py\n@@ -176,7 +176,21 @@ class UtilsTests(SimpleTestCase):\n         display_value = display_for_field(None, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, self.empty_value)\n \n-    def test_number_formats_display_for_field(self):\n+    def test_jsonfield_display_for_field(self):\n+        tests = [\n+            ({'a': {'b': 'c'}}, '{\"a\": {\"b\": \"c\"}}'),\n+            (['a', 'b'], '[\"a\", \"b\"]'),\n+            ('a', '\"a\"'),\n+            # The following case will check if invalid JSON are handled\n+            # Proper JSON serialization should handle this scenario\n+            ({('a', 'b'): 'c'}, '{(\"a\", \"b\"): \"c\"}'),  # Invalid JSON.\n+        ]\n+        for value, display_value in tests:\n+            with self.subTest(value=value):\n+                self.assertEqual(\n+                    display_for_field(value, models.JSONField(), self.empty_value),\n+                    display_value,\n+                )\n         display_value = display_for_field(12345.6789, models.FloatField(), self.empty_value)\n         self.assertEqual(display_value, '12345.6789')\n \n",
  "django__django-12453": "diff --git a/tests/backends/base/test_creation.py b/tests/backends/base/test_creation.py\nindex 7186dae..429edd8 100644\n--- a/tests/backends/base/test_creation.py\n+++ b/tests/backends/base/test_creation.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from unittest import mock\n \n@@ -6,6 +7,7 @@ from django.db.backends.base.creation import (\n     TEST_DATABASE_PREFIX, BaseDatabaseCreation,\n )\n from django.test import SimpleTestCase\n+from ..models import Object, ObjectReference\n \n \n def get_connection_copy():\n@@ -18,7 +20,56 @@ def get_connection_copy():\n     return test_connection\n \n \n-class TestDbSignatureTests(SimpleTestCase):\n+class TestDeserializeDbFromString(SimpleTestCase):\n+    databases = {'default'}\n+\n+    def test_circular_reference(self):\n+        # deserialize_db_from_string() handles circular references.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj_ref\": 1, \"related_objects\": []}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 1}\n+            }\n+        ]\n+        \"\"\"\n+        connection.creation.deserialize_db_from_string(data)\n+        obj = Object.objects.get()\n+        obj_ref = ObjectReference.objects.get()\n+        self.assertEqual(obj.obj_ref, obj_ref)\n+        self.assertEqual(obj_ref.obj, obj)\n+\n+    def test_empty_data(self):\n+        # Test that deserializing empty data does not raise errors.\n+        data = \"[]\"\n+        connection.creation.deserialize_db_from_string(data)\n+        self.assertEqual(Object.objects.count(), 0)\n+        self.assertEqual(ObjectReference.objects.count(), 0)\n+\n+    def test_missing_foreign_key_reference(self):\n+        # Test that a missing foreign key reference raises an error.\n+        data = \"\"\"\n+        [\n+            {\n+                \"model\": \"backends.object\",\n+                \"pk\": 1,\n+                \"fields\": {}\n+            },\n+            {\n+                \"model\": \"backends.objectreference\",\n+                \"pk\": 1,\n+                \"fields\": {\"obj\": 2}\n+            }\n+        ]\n+        \"\"\"\n+        with self.assertRaises(Exception):\n+            connection.creation.deserialize_db_from_string(data)\n     def test_default_name(self):\n         # A test db name isn't set.\n         prod_name = 'hodor'\n",
  "django__django-12497": "",
  "django__django-12700": "diff --git a/tests/view_tests/tests/test_debug.py b/tests/view_tests/tests/test_debug.py\nindex 010daca..e7b10e1 100644\n--- a/tests/view_tests/tests/test_debug.py\n+++ b/tests/view_tests/tests/test_debug.py\n@@ -1241,10 +1241,84 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n             reporter_filter.cleansed_substitute,\n         )\n \n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n+            reporter_filter.cleanse_setting('password', 'super_secret'),\n+            reporter_filter.cleansed_substitute,\n+        )\n+\n     def test_cleanse_setting_recurses_in_dictionary(self):\n         reporter_filter = SafeExceptionReporterFilter()\n         initial = {'login': 'cooper', 'password': 'secret'}\n         self.assertEqual(\n+            reporter_filter.cleanse_setting('password', 'super_secret'),\n+            reporter_filter.cleansed_substitute,\n+        )\n+\n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n             reporter_filter.cleanse_setting('SETTING_NAME', initial),\n             {'login': 'cooper', 'password': reporter_filter.cleansed_substitute},\n         )\n@@ -1253,6 +1327,43 @@ class ExceptionReporterFilterTests(ExceptionReportTestMixin, LoggingCaptureMixin\n         request = self.rf.get('/', HTTP_SECRET_HEADER='super_secret')\n         reporter_filter = SafeExceptionReporterFilter()\n         self.assertEqual(\n+            reporter_filter.cleanse_setting('password', 'super_secret'),\n+            reporter_filter.cleansed_substitute,\n+        )\n+\n+    def test_cleanse_setting_recurses_in_list_tuples(self):\n+        reporter_filter = SafeExceptionReporterFilter()\n+        initial = [\n+            {\n+                'login': 'cooper',\n+                'password': 'secret',\n+                'apps': (\n+                    {'name': 'app1', 'api_key': 'a06b-c462cffae87a'},\n+                    {'name': 'app2', 'api_key': 'a9f4-f152e97ad808'},\n+                ),\n+                'tokens': ['98b37c57-ec62-4e39', '8690ef7d-8004-4916'],\n+            },\n+            {'SECRET_KEY': 'c4d77c62-6196-4f17-a06b-c462cffae87a'},\n+        ]\n+        cleansed = [\n+            {\n+                'login': 'cooper',\n+                'password': reporter_filter.cleansed_substitute,\n+                'apps': (\n+                    {'name': 'app1', 'api_key': reporter_filter.cleansed_substitute},\n+                    {'name': 'app2', 'api_key': reporter_filter.cleansed_substitute},\n+                ),\n+                'tokens': reporter_filter.cleansed_substitute,\n+            },\n+            {'SECRET_KEY': reporter_filter.cleansed_substitute},\n+        ]\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', initial),\n+            cleansed,\n+        )\n+        self.assertEqual(\n+            reporter_filter.cleanse_setting('SETTING_NAME', tuple(initial)),\n+            tuple(cleansed),\n             reporter_filter.get_safe_request_meta(request)['HTTP_SECRET_HEADER'],\n             reporter_filter.cleansed_substitute,\n         )\n",
  "django__django-12708": "diff --git a/tests/migrations/test_operations.py b/tests/migrations/test_operations.py\nindex 2df48a2..e4664ed 100644\n--- a/tests/migrations/test_operations.py\n+++ b/tests/migrations/test_operations.py\n@@ -1759,7 +1759,34 @@ class OperationTests(OperationTestBase):\n         operation = migrations.AlterIndexTogether(\"Pony\", None)\n         self.assertEqual(operation.describe(), \"Alter index_together for Pony (0 constraint(s))\")\n \n-    @skipUnlessDBFeature('supports_table_check_constraints')\n+    @skipUnlessDBFeature('allows_multiple_constraints_on_same_fields')\n+    def test_alter_index_together_with_unique_together(self):\n+        app_label = 'test_al_index_with_unique'\n+        table_name = '%s_pony' % app_label\n+        project_state = self.set_up_test_model(app_label, unique_together=True)\n+        \n+        # Initial unique_together exists check.\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n+        \n+        # Add index_together with the same fields as unique_together.\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', [('pink', 'weight')])\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexExists(table_name, ['pink', 'weight'])\n+        \n+        # Attempt to remove index_together only.\n+        project_state = new_state\n+        new_state = project_state.clone()\n+        operation = migrations.AlterIndexTogether('Pony', set())\n+        operation.state_forwards(app_label, new_state)\n+        with connection.schema_editor() as editor:\n+            operation.database_forwards(app_label, editor, project_state, new_state)\n+        self.assertIndexNotExists(table_name, ['pink', 'weight'])\n+        \n+        # Ensure unique_together constraint still exists.\n+        self.assertUniqueConstraintExists(table_name, ['pink', 'weight'])\n     def test_add_constraint(self):\n         project_state = self.set_up_test_model(\"test_addconstraint\")\n         gt_check = models.Q(pink__gt=2)\n",
  "django__django-12747": "diff --git a/tests/delete/tests.py b/tests/delete/tests.py\nindex 8fb8c27..b79dc3a 100644\n--- a/tests/delete/tests.py\n+++ b/tests/delete/tests.py\n@@ -685,6 +685,22 @@ class FastDeleteTests(TestCase):\n         self.assertNumQueries(2, a.delete)\n         self.assertEqual(User.objects.count(), 0)\n \n+    def test_queryset_delete_zero_objects(self):\n+        \"\"\"\n+        Test QuerySet.delete() returns a consistent result format when zero objects are to be deleted.\n+        \"\"\"\n+        # Test for a simple model with no foreign key\n+        simple_model_deleted, simple_model_deleted_objs = SimpleModel.objects.filter(id=-1).delete()\n+        self.assertEqual(simple_model_deleted, 0)\n+        self.assertCountEqual(simple_model_deleted_objs, {SimpleModel._meta.label: 0})\n+\n+        # Test for a model with a foreign key\n+        foreign_key_model_deleted, foreign_key_model_deleted_objs = ForeignKeyModel.objects.filter(id=-1).delete()\n+        self.assertEqual(foreign_key_model_deleted, 0)\n+        self.assertCountEqual(foreign_key_model_deleted_objs, {ForeignKeyModel._meta.label: 0})\n+\n+        # If fixed, both cases should have a dictionary with model label keys and zero values.\n+\n     def test_fast_delete_empty_no_update_can_self_select(self):\n         \"\"\"\n         #25932 - Fast deleting on backends that don't have the\n",
  "django__django-12856": "",
  "django__django-12915": "diff --git a/tests/asgi/tests.py b/tests/asgi/tests.py\nindex 72f5bd1..909ccb8 100644\n--- a/tests/asgi/tests.py\n+++ b/tests/asgi/tests.py\n@@ -79,6 +79,58 @@ class ASGITest(SimpleTestCase):\n         # Allow response.close() to finish.\n         await communicator.wait()\n \n+    @modify_settings(INSTALLED_APPS={'append': 'django.contrib.staticfiles'})\n+    @override_settings(\n+        STATIC_URL='/static/',\n+        STATIC_ROOT=TEST_STATIC_ROOT,\n+        STATICFILES_DIRS=[TEST_STATIC_ROOT],\n+        STATICFILES_FINDERS=[\n+            'django.contrib.staticfiles.finders.FileSystemFinder',\n+        ],\n+    )\n+    async def test_static_file_response(self):\n+        application = ASGIStaticFilesHandler(get_asgi_application())\n+        # Construct HTTP request.\n+        scope = self.async_request_factory._base_scope(path='/static/file.txt')\n+        communicator = ApplicationCommunicator(application, scope)\n+        await communicator.send_input({'type': 'http.request'})\n+        # Get the file content.\n+        file_path = TEST_STATIC_ROOT / 'file.txt'\n+        with open(file_path, 'rb') as test_file:\n+            test_file_contents = test_file.read()\n+        # Read the response.\n+        stat = file_path.stat()\n+        response_start = await communicator.receive_output()\n+        self.assertEqual(response_start['type'], 'http.response.start')\n+        self.assertEqual(response_start['status'], 200)\n+        self.assertEqual(\n+            set(response_start['headers']),\n+            {\n+                (b'Content-Length', str(len(test_file_contents)).encode('ascii')),\n+                (b'Content-Type', b'text/plain'),\n+                (b'Content-Disposition', b'inline; filename=\"file.txt\"'),\n+                (b'Last-Modified', http_date(stat.st_mtime).encode('ascii')),\n+            },\n+        )\n+        response_body = await communicator.receive_output()\n+        self.assertEqual(response_body['type'], 'http.response.body')\n+        self.assertEqual(response_body['body'], test_file_contents)\n+        # Allow response.close() to finish.\n+        await communicator.wait()\n+\n+    async def test_get_async_response(self):\n+        request = self.async_request_factory.get('/static/test/file.txt')\n+        handler = ASGIStaticFilesHandler(ASGIHandler())\n+        response = await handler.get_response_async(request)\n+        response.close()\n+        self.assertEqual(response.status_code, 200)\n+\n+    async def test_get_async_response_not_found(self):\n+        request = self.async_request_factory.get('/static/test/not-found.txt')\n+        handler = ASGIStaticFilesHandler(ASGIHandler())\n+        response = await handler.get_response_async(request)\n+        self.assertEqual(response.status_code, 404)\n+\n     async def test_headers(self):\n         application = get_asgi_application()\n         communicator = ApplicationCommunicator(\n",
  "django__django-12983": "diff --git a/tests/utils_tests/test_text.py b/tests/utils_tests/test_text.py\nindex bb1d0a3..c2818d4 100644\n--- a/tests/utils_tests/test_text.py\n+++ b/tests/utils_tests/test_text.py\n@@ -187,6 +187,8 @@ class TestUtilsText(SimpleTestCase):\n         lazy_numeric = lazystr(text.phone2numeric('0800 flowers'))\n         self.assertEqual(lazy_numeric, '0800 3569377')\n \n+    from django.utils import text\n+    \n     def test_slugify(self):\n         items = (\n             # given - expected - Unicode?\n@@ -197,6 +199,12 @@ class TestUtilsText(SimpleTestCase):\n             ('    foo \u0131\u00e7 bar', 'foo-\u0131\u00e7-bar', True),\n             ('\u4f60\u597d', '\u4f60\u597d', True),\n             ('\u0130stanbul', 'istanbul', True),\n+            # Test cases to verify the fix for stripping leading/trailing dashes and underscores\n+            ('___This is a test ---', 'this-is-a-test', False),\n+            ('---Leading and trailing dashes---', 'leading-and-trailing-dashes', False),\n+            ('___Leading and trailing underscores___', 'leading-and-trailing-underscores', False),\n+            ('---Mixed---____---', 'mixed', False),\n+            ('_--Complex_--Example--_', 'complex-example', False),\n         )\n         for value, output, is_unicode in items:\n             self.assertEqual(text.slugify(value, allow_unicode=is_unicode), output)\n",
  "django__django-13028": "",
  "django__django-13158": "",
  "django__django-13230": "",
  "django__django-13315": "diff --git a/tests/model_forms/tests.py b/tests/model_forms/tests.py\nindex 64b15bf..4999e07 100644\n--- a/tests/model_forms/tests.py\n+++ b/tests/model_forms/tests.py\n@@ -2829,8 +2829,76 @@ class LimitChoicesToTests(TestCase):\n             StumpJokeForm()\n             self.assertEqual(today_callable_dict.call_count, 3)\n \n+@isolate_apps('model_forms')\n+class LimitChoicesToTests(TestCase):\n+    def setUp(self):\n+        self.marley = Character.objects.create(username=\"Marley\", last_action=\"2023-10-01\")\n+        self.threepwood = Character.objects.create(username=\"Threepwood\", last_action=\"2023-10-01\")\n+\n+    def test_limit_choices_to_no_duplicates(self):\n+        joke1 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.threepwood,\n+        )\n+        joke2 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.threepwood,\n+        )\n+        joke3 = StumpJoke.objects.create(\n+            funny=True,\n+            most_recently_fooled=self.marley,\n+        )\n+        StumpJoke.objects.create(funny=False, most_recently_fooled=self.marley)\n+        joke1.has_fooled_today.add(self.marley, self.threepwood)\n+        joke2.has_fooled_today.add(self.marley)\n+        joke3.has_fooled_today.add(self.marley, self.threepwood)\n+\n+        class CharacterDetails(models.Model):\n+            character1 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_fk_1',\n+            )\n+            character2 = models.ForeignKey(\n+                Character,\n+                models.CASCADE,\n+                limit_choices_to={\n+                    'jokes__funny': True,\n+                    'jokes_today__funny': True,\n+                },\n+                related_name='details_fk_2',\n+            )\n+            character3 = models.ManyToManyField(\n+                Character,\n+                limit_choices_to=models.Q(\n+                    jokes__funny=True,\n+                    jokes_today__funny=True,\n+                ),\n+                related_name='details_m2m_1',\n+            )\n+\n+        class CharacterDetailsForm(forms.ModelForm):\n+            class Meta:\n+                model = CharacterDetails\n+                fields = '__all__'\n \n-class FormFieldCallbackTests(SimpleTestCase):\n+        form = CharacterDetailsForm()\n+        self.assertCountEqual(\n+            form.fields['character1'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character2'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n+        self.assertCountEqual(\n+            form.fields['character3'].queryset,\n+            [self.marley, self.threepwood],\n+        )\n \n     def test_baseform_with_widgets_in_meta(self):\n         \"\"\"Regression for #13095: Using base forms with widgets defined in Meta should not raise errors.\"\"\"\n",
  "django__django-13321": "",
  "django__django-13401": "diff --git a/tests/model_inheritance/test_abstract_inheritance.py b/tests/model_inheritance/test_abstract_inheritance.py\nindex 536c423..0176515 100644\n--- a/tests/model_inheritance/test_abstract_inheritance.py\n+++ b/tests/model_inheritance/test_abstract_inheritance.py\n@@ -5,13 +5,41 @@ from django.contrib.contenttypes.models import ContentType\n from django.core.checks import Error\n from django.core.exceptions import FieldDoesNotExist, FieldError\n from django.db import models\n-from django.test import SimpleTestCase\n+from django.test import SimpleTestCase, TestCase\n from django.test.utils import isolate_apps\n \n \n @isolate_apps('model_inheritance')\n class AbstractInheritanceTests(SimpleTestCase):\n-    def test_single_parent(self):\n+    def test_abstract_inherited_fields(self):\n+        \"\"\"Field instances from abstract models are not equal.\"\"\"\n+        class AbstractModel(models.Model):\n+            field = models.IntegerField()\n+\n+            class Meta:\n+                abstract = True\n+\n+        class InheritAbstractModel1(AbstractModel):\n+            pass\n+\n+        class InheritAbstractModel2(AbstractModel):\n+            pass\n+\n+        abstract_model_field = AbstractModel._meta.get_field('field')\n+        inherit1_model_field = InheritAbstractModel1._meta.get_field('field')\n+        inherit2_model_field = InheritAbstractModel2._meta.get_field('field')\n+\n+        self.assertNotEqual(abstract_model_field, inherit1_model_field)\n+        self.assertNotEqual(abstract_model_field, inherit2_model_field)\n+        self.assertNotEqual(inherit1_model_field, inherit2_model_field)\n+\n+        self.assertLess(abstract_model_field, inherit1_model_field)\n+        self.assertLess(abstract_model_field, inherit2_model_field)\n+        self.assertLess(inherit1_model_field, inherit2_model_field)\n+\n+        self.assertNotEqual(hash(abstract_model_field), hash(inherit1_model_field))\n+        self.assertNotEqual(hash(abstract_model_field), hash(inherit2_model_field))\n+        self.assertNotEqual(hash(inherit1_model_field), hash(inherit2_model_field))\n         class AbstractBase(models.Model):\n             name = models.CharField(max_length=30)\n \n@@ -347,4 +375,4 @@ class AbstractInheritanceTests(SimpleTestCase):\n                 ('age', models.SmallIntegerField), ('concretemodel2_ptr', models.OneToOneField),\n                 ('name', models.CharField),\n             ]\n-        )\n+        )\n",
  "django__django-13447": "",
  "django__django-13551": "diff --git a/tests/auth_tests/test_tokens.py b/tests/auth_tests/test_tokens.py\nindex a6c14e0..350999e 100644\n--- a/tests/auth_tests/test_tokens.py\n+++ b/tests/auth_tests/test_tokens.py\n@@ -1,9 +1,11 @@\n+\n from datetime import datetime, timedelta\n \n from django.conf import settings\n from django.contrib.auth.models import User\n from django.contrib.auth.tokens import PasswordResetTokenGenerator\n from django.test import TestCase\n+from .with_custom_email_field import CustomEmailField\n from django.test.utils import ignore_warnings\n from django.utils.deprecation import RemovedInDjango40Warning\n \n@@ -37,6 +39,47 @@ class TokenGeneratorTest(TestCase):\n         tk2 = p0.make_token(user_reload)\n         self.assertEqual(tk1, tk2)\n \n+    def test_token_with_different_email(self):\n+        \"\"\"Updating the user email address invalidates the token.\"\"\"\n+        tests = [\n+            (CustomEmailField, None),\n+            (CustomEmailField, 'test4@example.com'),\n+            (User, 'test4@example.com'),\n+        ]\n+        for model, email in tests:\n+            with self.subTest(model=model.__qualname__, email=email):\n+                user = model.objects.create_user(\n+                    'changeemailuser',\n+                    email=email,\n+                    password='testpw',\n+                )\n+                p0 = PasswordResetTokenGenerator()\n+                tk1 = p0.make_token(user)\n+                self.assertIs(p0.check_token(user, tk1), True)\n+                setattr(user, user.get_email_field_name(), 'test4new@example.com')\n+                user.save()\n+                self.assertIs(p0.check_token(user, tk1), False)\n+\n+    def test_token_for_user_without_email(self):\n+        \"\"\"\n+        Token should remain valid if user does not have an email and hasn't changed email.\n+        \"\"\"\n+        tests = [\n+            (CustomEmailField, None),\n+        ]\n+        for model, email in tests:\n+            with self.subTest(model=model.__qualname__, email=email):\n+                user = model.objects.create_user(\n+                    'noemailuser',\n+                    email=email,\n+                    password='testpw',\n+                )\n+                p0 = PasswordResetTokenGenerator()\n+                tk1 = p0.make_token(user)\n+                self.assertIs(p0.check_token(user, tk1), True)\n+                # No email to change, token should remain valid\n+                self.assertIs(p0.check_token(user, tk1), True)\n+\n     def test_timeout(self):\n         \"\"\"The token is valid after n seconds, but no greater.\"\"\"\n         # Uses a mocked version of PasswordResetTokenGenerator so we can change\n",
  "django__django-13590": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 0b4f73f..4107bc8 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n import pickle\n import unittest\n@@ -875,6 +876,51 @@ class IterableLookupInnerExpressionsTests(TestCase):\n             ['<Company: 5020 Ltd>', '<Company: 5040 Ltd>', '<Company: 5050 Ltd>', '<Company: 5060 Ltd>'],\n             ordered=False\n         )\n+        \n+    def test_range_lookup_namedtuple(self):\n+        from collections import namedtuple\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        \n+        # Creating a company instance for testing\n+        ceo = Employee.objects.create(name='John Doe')\n+        c7 = Company.objects.create(name='Sample Company Ltd', num_employees=75, num_chairs=80, ceo=ceo)\n+        \n+        # Use the named tuple in the range filter\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=50, maximum=100)\n+        )\n+        \n+        # Check that the created object is correctly retrieved\n+        self.assertSequenceEqual(qs, [c7])\n+        \n+    def test_range_lookup_namedtuple_empty(self):\n+        from collections import namedtuple\n+        # Create named tuple with range not matching any Company employees\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        \n+        # Filter for a range with no companies\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=101, maximum=200)\n+        )\n+        \n+        # Ensure no companies are returned\n+        self.assertSequenceEqual(qs, [])\n+        \n+    def test_range_lookup_with_different_namedtuple(self):\n+        from collections import namedtuple\n+        OtherRange = namedtuple('OtherRange', ['start', 'end'])\n+        \n+        # Attempt to use a different named tuple structure\n+        qs = Company.objects.filter(\n+            num_employees__range=OtherRange(start=50, end=100)\n+        )\n+        \n+        # Ensure no runtime errors and correct retrieval\n+        self.assertQuerysetEqual(\n+            qs,\n+            ['<Company: Sample Company Ltd>'],\n+            ordered=False\n+        )\n         self.assertQuerysetEqual(\n             Company.objects.filter(num_employees__range=(1, 100)),\n             [\n@@ -883,6 +929,51 @@ class IterableLookupInnerExpressionsTests(TestCase):\n             ],\n             ordered=False\n         )\n+        \n+    def test_range_lookup_namedtuple(self):\n+        from collections import namedtuple\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        \n+        # Creating a company instance for testing\n+        ceo = Employee.objects.create(name='John Doe')\n+        c7 = Company.objects.create(name='Sample Company Ltd', num_employees=75, num_chairs=80, ceo=ceo)\n+        \n+        # Use the named tuple in the range filter\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=50, maximum=100)\n+        )\n+        \n+        # Check that the created object is correctly retrieved\n+        self.assertSequenceEqual(qs, [c7])\n+        \n+    def test_range_lookup_namedtuple_empty(self):\n+        from collections import namedtuple\n+        # Create named tuple with range not matching any Company employees\n+        EmployeeRange = namedtuple('EmployeeRange', ['minimum', 'maximum'])\n+        \n+        # Filter for a range with no companies\n+        qs = Company.objects.filter(\n+            num_employees__range=EmployeeRange(minimum=101, maximum=200)\n+        )\n+        \n+        # Ensure no companies are returned\n+        self.assertSequenceEqual(qs, [])\n+        \n+    def test_range_lookup_with_different_namedtuple(self):\n+        from collections import namedtuple\n+        OtherRange = namedtuple('OtherRange', ['start', 'end'])\n+        \n+        # Attempt to use a different named tuple structure\n+        qs = Company.objects.filter(\n+            num_employees__range=OtherRange(start=50, end=100)\n+        )\n+        \n+        # Ensure no runtime errors and correct retrieval\n+        self.assertQuerysetEqual(\n+            qs,\n+            ['<Company: Sample Company Ltd>'],\n+            ordered=False\n+        )\n \n     @unittest.skipUnless(connection.vendor == 'sqlite',\n                          \"This defensive test only works on databases that don't validate parameter types\")\n",
  "django__django-13658": "",
  "django__django-13660": "diff --git a/tests/shell/tests.py b/tests/shell/tests.py\nindex fd9932f..12a5b65 100644\n--- a/tests/shell/tests.py\n+++ b/tests/shell/tests.py\n@@ -1,3 +1,4 @@\n+\n import sys\n import unittest\n from unittest import mock\n@@ -29,15 +30,51 @@ class ShellCommandTestCase(SimpleTestCase):\n             stdin.seek(0)\n             call_command('shell')\n         self.assertEqual(stdout.getvalue().strip(), '100')\n+    script_globals_with_import = '''\n+import django\n+def f():\n+    print(\"django\" in globals())\n+f()\n+'''\n+\n+    def test_command_option_globals_preserved(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals_with_import)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n \n-    @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_globals_preserved(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals_with_import)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n     @mock.patch.dict('sys.modules', {'IPython': None})\n     def test_shell_with_ipython_not_installed(self, select):\n         select.return_value = ([], [], [])\n         with self.assertRaisesMessage(CommandError, \"Couldn't import ipython interface.\"):\n             call_command('shell', interface='ipython')\n+    script_globals_with_import = '''\n+import django\n+def f():\n+    print(\"django\" in globals())\n+f()\n+'''\n \n-    @mock.patch('django.core.management.commands.shell.select.select')  # [1]\n+    def test_command_option_globals_preserved(self):\n+        with captured_stdout() as stdout:\n+            call_command('shell', command=self.script_globals_with_import)\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n+\n+    @unittest.skipIf(sys.platform == 'win32', \"Windows select() doesn't support file descriptors.\")\n+    @mock.patch('django.core.management.commands.shell.select')\n+    def test_stdin_read_globals_preserved(self, select):\n+        with captured_stdin() as stdin, captured_stdout() as stdout:\n+            stdin.write(self.script_globals_with_import)\n+            stdin.seek(0)\n+            call_command('shell')\n+        self.assertEqual(stdout.getvalue().strip(), 'True')\n     @mock.patch.dict('sys.modules', {'bpython': None})\n     def test_shell_with_bpython_not_installed(self, select):\n         select.return_value = ([], [], [])\n@@ -49,4 +86,4 @@ class ShellCommandTestCase(SimpleTestCase):\n     # stdin is closed and replaced by /dev/null. Reading from /dev/null always\n     # returns EOF and so select always shows that sys.stdin is ready to read.\n     # This causes problems because of the call to select.select() towards the\n-    # end of shell's handle() method.\n+    # end of shell's handle() method.\n",
  "django__django-13710": "diff --git a/tests/admin_inlines/tests.py b/tests/admin_inlines/tests.py\nindex 2d83d62..3248f52 100644\n--- a/tests/admin_inlines/tests.py\n+++ b/tests/admin_inlines/tests.py\n@@ -1013,7 +1013,22 @@ class TestVerboseNameInlineForms(TestDataMixin, TestCase):\n         self.assertContains(response, 'Add another Model with both - name')\n         self.assertNotContains(response, '<h2>Model with both - plural name</h2>')\n \n-    def test_both_verbose_names_inline(self):\n+    def test_default_verbose_name_plural_to_verbose_name(self):\n+        class InlineWithOnlyVerboseName(TabularInline):\n+            model = Profile\n+            verbose_name = 'Single Child'\n+\n+        modeladmin = ModelAdmin(ProfileCollection, admin_site)\n+        modeladmin.inlines = [InlineWithOnlyVerboseName]\n+\n+        obj = ProfileCollection.objects.create()\n+        url = reverse('admin:admin_inlines_profilecollection_change', args=(obj.pk,))\n+        request = self.factory.get(url)\n+        request.user = self.superuser\n+        response = modeladmin.changeform_view(request)\n+        # Should show \"Single Childs\" based on `verbose_name`\n+        self.assertContains(response, '<h2>Single Childs</h2>')\n+        self.assertContains(response, 'Add another Single Child')\n         class NonVerboseProfileInline(TabularInline):\n             model = Profile\n             verbose_name = 'Non-verbose childs - name'\n",
  "django__django-13757": "",
  "django__django-13768": "",
  "django__django-13925": "diff --git a/tests/check_framework/test_model_checks.py b/tests/check_framework/test_model_checks.py\nindex 6424d89..d758dcd 100644\n--- a/tests/check_framework/test_model_checks.py\n+++ b/tests/check_framework/test_model_checks.py\n@@ -371,6 +371,11 @@ def mocked_is_overridden(self, setting):\n     )\n \n \n+from django.db import models\n+from django.core.checks import Warning\n+from django.test import SimpleTestCase, override_settings\n+from django.test.utils import isolate_apps\n+\n @mock.patch('django.conf.UserSettingsHolder.is_overridden', mocked_is_overridden)\n @override_settings(DEFAULT_AUTO_FIELD='django.db.models.AutoField')\n @isolate_apps('check_framework.apps.CheckDefaultPKConfig', attr_name='apps')\n@@ -409,9 +414,73 @@ class ModelDefaultAutoFieldTests(SimpleTestCase):\n         self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n \n     @isolate_apps('check_framework.apps.CheckPKConfig', kwarg_name='apps')\n-    def test_app_default_auto_field(self, apps):\n+    def test_explicit_inherited_pk(self):\n+        class Parent(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class Child(Parent):\n+            pass\n+\n+        # No warnings should be raised for explicitly defined PK in inheritance\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+\n+    def test_explicit_inherited_parent_link(self):\n+        class Parent(models.Model):\n+            id = models.AutoField(primary_key=True)\n+\n+        class Child(Parent):\n+            parent_ptr = models.OneToOneField(Parent, models.CASCADE, parent_link=True)\n+\n+        # No warnings should be raised for explicitly defined PK with parent link\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [])\n+ \n+    def test_auto_created_inherited_pk(self):\n+        class Parent(models.Model):\n+            pass\n+\n+        class Child(Parent):\n+            pass\n+\n+        # Warning should be raised for auto-created PK\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [\n+            Warning(\n+                \"Auto-created primary key used when not defining a primary \"\n+                \"key type, by default 'django.db.models.AutoField'.\",\n+                hint=(\n+                    \"Configure the DEFAULT_AUTO_FIELD setting or the \"\n+                    \"CheckDefaultPKConfig.default_auto_field attribute to \"\n+                    \"point to a subclass of AutoField, e.g. \"\n+                    \"'django.db.models.BigAutoField'.\"\n+                ),\n+                obj=Parent,\n+                id='models.W042',\n+            ),\n+        ])\n+\n+    def test_auto_created_inherited_parent_link(self):\n+        class Parent(models.Model):\n+            pass\n+\n+        class Child(Parent):\n+            parent_ptr = models.OneToOneField(Parent, models.CASCADE, parent_link=True)\n+\n+        # Warning should be raised for auto-created PK with parent link\n+        self.assertEqual(checks.run_checks(app_configs=self.apps.get_app_configs()), [\n+            Warning(\n+                \"Auto-created primary key used when not defining a primary \"\n+                \"key type, by default 'django.db.models.AutoField'.\",\n+                hint=(\n+                    \"Configure the DEFAULT_AUTO_FIELD setting or the \"\n+                    \"CheckDefaultPKConfig.default_auto_field attribute to \"\n+                    \"point to a subclass of AutoField, e.g. \"\n+                    \"'django.db.models.BigAutoField'.\"\n+                ),\n+                obj=Parent,\n+                id='models.W042',\n+            ),\n+        ])\n         class ModelWithPkViaAppConfig(models.Model):\n             class Meta:\n                 app_label = 'check_framework.apps.CheckPKConfig'\n \n-        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n+        self.assertEqual(checks.run_checks(app_configs=apps.get_app_configs()), [])\n",
  "django__django-13933": "",
  "django__django-13964": "",
  "django__django-14016": "diff --git a/tests/queries/test_q.py b/tests/queries/test_q.py\nindex c0384a9..6b0c6c2 100644\n--- a/tests/queries/test_q.py\n+++ b/tests/queries/test_q.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import F, Q\n from django.test import SimpleTestCase\n \n@@ -16,6 +17,15 @@ class QTests(SimpleTestCase):\n         self.assertEqual(q | Q(), q)\n         self.assertEqual(Q() | q, q)\n \n+    def test_dict_keys_in_q_object(self):\n+        # Test that combining Q objects with dict_keys using the | operator does not raise a TypeError.\n+        empty_dict_keys = {}.keys()\n+        # Create Q objects with dict_keys\n+        q = Q(x__in=empty_dict_keys)\n+        # The Q object should work as expected when combined with another Q object.\n+        self.assertEqual(q | Q(), q)\n+        self.assertEqual(Q() | q, q)\n+\n     def test_combine_or_both_empty(self):\n         self.assertEqual(Q() | Q(), Q())\n \n",
  "django__django-14017": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 707f339..50d85d8 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -36,6 +36,9 @@ from .models import (\n )\n \n \n+from django.db.models import Q, OuterRef\n+from django.db.models.expressions import Exists\n+\n class BasicExpressionsTests(TestCase):\n     @classmethod\n     def setUpTestData(cls):\n@@ -794,7 +797,24 @@ class BasicExpressionsTests(TestCase):\n         )\n         self.assertCountEqual(qs, [self.example_inc.ceo, self.foobar_ltd.ceo, self.max])\n \n-    def test_boolean_expression_combined(self):\n+    def test_q_exists_commutativity(self):\n+        is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n+        is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n+        \n+        combinations = [\n+            Exists(is_ceo) & Q(),\n+            Q() & Exists(is_ceo),\n+            Exists(is_ceo) | Q(),\n+            Q() | Exists(is_ceo),\n+            Exists(is_poc) & Q(),\n+            Q() & Exists(is_poc),\n+            Exists(is_poc) | Q(),\n+            Q() | Exists(is_poc),\n+        ]\n+        \n+        for comb in combinations:\n+            with self.subTest(combination=comb):\n+                Employee.objects.filter(comb)\n         is_ceo = Company.objects.filter(ceo=OuterRef('pk'))\n         is_poc = Company.objects.filter(point_of_contact=OuterRef('pk'))\n         self.gmbh.point_of_contact = self.max\n",
  "django__django-14155": "",
  "django__django-14238": "diff --git a/tests/model_options/test_default_pk.py b/tests/model_options/test_default_pk.py\nindex 6d8c5d8..a96b525 100644\n--- a/tests/model_options/test_default_pk.py\n+++ b/tests/model_options/test_default_pk.py\n@@ -1,7 +1,11 @@\n+\n from django.core.exceptions import ImproperlyConfigured\n from django.db import models\n from django.test import SimpleTestCase, override_settings\n from django.test.utils import isolate_apps\n+from django.db import models\n+from django.test import SimpleTestCase, override_settings\n+from django.test.utils import isolate_apps\n \n \n @isolate_apps('model_options')\n@@ -66,7 +70,27 @@ class TestDefaultPK(SimpleTestCase):\n             class Model(models.Model):\n                 pass\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_default_auto_field_setting(self):\n         class Model(models.Model):\n@@ -82,7 +106,27 @@ class TestDefaultPK(SimpleTestCase):\n \n         self.assertIsInstance(Model._meta.pk, models.SmallAutoField)\n \n-    @isolate_apps('model_options.apps.ModelDefaultPKConfig')\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MyBigAutoField')\n+    def test_default_auto_field_setting_bigautofield_subclass(self):\n+        class MyBigAutoField(models.BigAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MyBigAutoField)\n+\n+    @isolate_apps('model_options')\n+    @override_settings(DEFAULT_AUTO_FIELD='model_options.test_default_pk.MySmallAutoField')\n+    def test_default_auto_field_setting_smallautofield_subclass(self):\n+        class MySmallAutoField(models.SmallAutoField):\n+            pass\n+\n+        class Model(models.Model):\n+            pass\n+\n+        self.assertIsInstance(Model._meta.pk, MySmallAutoField)\n     @override_settings(DEFAULT_AUTO_FIELD='django.db.models.SmallAutoField')\n     def test_m2m_default_auto_field_setting(self):\n         class M2MModel(models.Model):\n",
  "django__django-14382": "diff --git a/tests/admin_scripts/tests.py b/tests/admin_scripts/tests.py\nindex afeed3e..79d8d3d 100644\n--- a/tests/admin_scripts/tests.py\n+++ b/tests/admin_scripts/tests.py\n@@ -2168,8 +2168,28 @@ class StartApp(AdminScriptTestCase):\n                     \"sure the name is a valid identifier.\".format(bad_name)\n                 )\n                 self.assertFalse(os.path.exists(testproject_dir))\n+    def test_trailing_slash_in_target_app_directory_name(self):\n+        \"\"\"\n+        Test startapp with a trailing slash in the target directory name.\n+        \"\"\"\n+        app_dir = os.path.join(self.test_dir, 'apps', 'app1')\n+        os.makedirs(app_dir)\n+        _, err = self.run_django_admin(['startapp', 'app', os.path.join('apps', 'app1', '')])\n+        self.assertNoOutput(err)\n+        self.assertIs(os.path.exists(os.path.join(app_dir, 'apps.py')), True)\n \n-    def test_importable_name(self):\n+    def test_trailing_slash_with_existing_directory(self):\n+        \"\"\"\n+        Test startapp when target directory with trailing slash already exists.\n+        \"\"\"\n+        app_dir = os.path.join(self.test_dir, 'apps', 'existing_app')\n+        os.makedirs(app_dir)\n+        out, err = self.run_django_admin(['startapp', 'app2', os.path.join('apps', 'existing_app', '')])\n+        self.assertOutput(\n+            err,\n+            \"already exists. Overlaying an app into an existing directory \"\n+            \"won't replace conflicting files.\"\n+        )\n         \"\"\"\n         startapp validates that app name doesn't clash with existing Python\n         modules.\n",
  "django__django-14411": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex 331338c..178b859 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,6 +1,8 @@\n import datetime\n import re\n from unittest import mock\n+from django.forms import Form\n+from django.forms import CharField\n \n from django.contrib.auth.forms import (\n     AdminPasswordChangeForm, AuthenticationForm, PasswordChangeForm,\n",
  "django__django-14580": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex dc4f94a..82db026 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -658,7 +658,28 @@ class WriterTests(SimpleTestCase):\n     def test_serialize_type_none(self):\n         self.assertSerializedEqual(type(None))\n \n-    def test_simple_migration(self):\n+    def test_missing_models_import(self):\n+        class MyField(models.TextField):\n+            pass\n+\n+        class MyMixin:\n+            pass\n+\n+        class MyModel(MyMixin, models.Model):\n+            name = MyField(primary_key=True)\n+\n+        # Create a MigrationWriter instance for MyModel\n+        writer = MigrationWriter(MyModel)\n+        migration_code = writer.serialize(MyModel)\n+        \n+        # Check if the generated code includes 'from django.db import models'\n+        self.assertIn(\"from django.db import models\", migration_code)\n+\n+        # Check if the 'bases' attribute is correctly written\n+        self.assertIn(\"bases=(MyApp.models.MyMixin, models.Model)\", migration_code)\n+        \n+        # Ensure our custom field is correctly serialized\n+        self.assertIn(\"MyField(primary_key=True, serialize=False)\", migration_code)\n         \"\"\"\n         Tests serializing a simple migration.\n         \"\"\"\n",
  "django__django-14608": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 8d2f689..d8fb52b 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -336,6 +336,11 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, max_num=1, validate_max=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n+        # Check if nonform CSS class is applied\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>Please submit at most 1 form.</li></ul>'\n+        )\n         self.assertEqual(formset.non_form_errors(), ['Please submit at most 1 form.'])\n \n     def test_formset_validate_min_flag(self):\n@@ -358,6 +363,11 @@ class FormsFormsetTestCase(SimpleTestCase):\n         ChoiceFormSet = formset_factory(Choice, extra=1, min_num=3, validate_min=True)\n         formset = ChoiceFormSet(data, auto_id=False, prefix='choices')\n         self.assertFalse(formset.is_valid())\n+        # Check if nonform CSS class is applied\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>Please submit at least 3 forms.</li></ul>'\n+        )\n         self.assertEqual(formset.non_form_errors(), ['Please submit at least 3 forms.'])\n \n     def test_formset_validate_min_unchanged_forms(self):\n@@ -982,6 +992,11 @@ class FormsFormsetTestCase(SimpleTestCase):\n         }\n         formset = FavoriteDrinksFormSet(data, prefix='drinks')\n         self.assertFalse(formset.is_valid())\n+        # Check if nonform CSS class is applied\n+        self.assertEqual(\n+            str(formset.non_form_errors()),\n+            '<ul class=\"errorlist nonform\"><li>You may only specify a drink once.</li></ul>'\n+        )\n         self.assertEqual(formset.non_form_errors(), ['You may only specify a drink once.'])\n \n     def test_formset_iteration(self):\n",
  "django__django-14672": "",
  "django__django-14752": "diff --git a/tests/admin_views/test_autocomplete_view.py b/tests/admin_views/test_autocomplete_view.py\nindex 7ef6d86..5c43f65 100644\n--- a/tests/admin_views/test_autocomplete_view.py\n+++ b/tests/admin_views/test_autocomplete_view.py\n@@ -294,6 +294,49 @@ class AutocompleteJsonViewTests(AdminViewBasicTestCase):\n         })\n \n \n+import datetime\n+from django.test import TestCase\n+from django.urls import reverse\n+from django.contrib.auth.models import User\n+from django.http import JsonResponse\n+\n+from .models import Question\n+from django.contrib.admin.views.autocomplete import AutocompleteJsonView\n+\n+class AutocompleteJsonSerializeResultView(AutocompleteJsonView):\n+    def serialize_result(self, obj, to_field_name):\n+        return {\n+            **super().serialize_result(obj, to_field_name),\n+            'posted': str(obj.posted),\n+        }\n+\n+class AutocompleteViewTests(TestCase):\n+    def setUp(self):\n+        self.superuser = User.objects.create_superuser('superuser', 'superuser@example.com', 'password')\n+        self.factory = RequestFactory()\n+        self.as_view_args = {'admin_site': admin.site}\n+        self.url = reverse('test_autocomplete')\n+        self.opts = {'app_label': 'admin_views', 'model_name': 'question'}\n+\n+    def test_serialize_result_custom_field(self):\n+        # Create some test data\n+        Question.objects.create(question='Question 1', posted=datetime.date(2021, 8, 9))\n+        Question.objects.create(question='Question 2', posted=datetime.date(2021, 8, 7))\n+\n+        request = self.factory.get(self.url, {'term': 'question', **self.opts})\n+        request.user = self.superuser\n+        response = AutocompleteJsonSerializeResultView.as_view(**self.as_view_args)(request)\n+        self.assertEqual(response.status_code, 200)\n+\n+        data = JsonResponse(response.content.decode('utf-8'))\n+        self.assertEqual(data, {\n+            'results': [\n+                {'id': str(q.pk), 'text': q.question, 'posted': str(q.posted)}\n+                for q in Question.objects.order_by('-posted')\n+            ],\n+            'pagination': {'more': False},\n+        })\n+\n @override_settings(ROOT_URLCONF='admin_views.urls')\n class SeleniumTests(AdminSeleniumTestCase):\n     available_apps = ['admin_views'] + AdminSeleniumTestCase.available_apps\n",
  "django__django-14787": "diff --git a/tests/decorators/tests.py b/tests/decorators/tests.py\nindex 5ea3da6..89c60b3 100644\n--- a/tests/decorators/tests.py\n+++ b/tests/decorators/tests.py\n@@ -426,7 +426,45 @@ class MethodDecoratorTests(SimpleTestCase):\n                     return \"tests\"\n \n \n-class XFrameOptionsDecoratorsTests(TestCase):\n+    def test_preserve_wrapper_assignments_partial(self):\n+        \"\"\"@method_decorator should handle functools.partial correctly.\"\"\"\n+        from functools import partial\n+        from django.utils.decorators import method_decorator\n+\n+        captured_name = None\n+        captured_module = None\n+        \n+        def some_decorator(func):\n+            @wraps(func)\n+            def wrapper(*args, **kwargs):\n+                nonlocal captured_name, captured_module\n+                captured_name = getattr(func, '__name__', None)\n+                captured_module = getattr(func, '__module__', None)\n+                return func(*args, **kwargs)\n+            return wrapper\n+\n+        class TestClass:\n+            @method_decorator(some_decorator)\n+            def some_method(self):\n+                return \"Hello, world!\"\n+        \n+        instance = TestClass()\n+        self.assertEqual(instance.some_method(), \"Hello, world!\")\n+        self.assertEqual(captured_name, 'some_method')\n+        self.assertIsNotNone(captured_module)\n+\n+        # Testing with functools.partial as a method\n+        class TestClassWithPartial:\n+            @method_decorator(some_decorator)\n+            def another_method(self, greeting=\"Hi\"):\n+                return greeting\n+\n+            wrapped_partial = method_decorator(some_decorator)(partial(another_method, greeting=\"Hello there\"))\n+\n+        partial_instance = TestClassWithPartial()\n+        self.assertEqual(partial_instance.wrapped_partial(), \"Hello there\")\n+        self.assertEqual(captured_name, 'another_method')\n+        self.assertIsNotNone(captured_module)\n     \"\"\"\n     Tests for the X-Frame-Options decorators.\n     \"\"\"\n",
  "django__django-14855": "",
  "django__django-14915": "diff --git a/tests/model_forms/test_modelchoicefield.py b/tests/model_forms/test_modelchoicefield.py\nindex dbab026..e629115 100644\n--- a/tests/model_forms/test_modelchoicefield.py\n+++ b/tests/model_forms/test_modelchoicefield.py\n@@ -1,8 +1,9 @@\n+\n import datetime\n \n from django import forms\n from django.core.exceptions import ValidationError\n-from django.forms.models import ModelChoiceIterator\n+from django.forms.models import ModelChoiceIterator, ModelChoiceIteratorValue\n from django.forms.widgets import CheckboxSelectMultiple\n from django.template import Context, Template\n from django.test import TestCase\n@@ -346,6 +347,31 @@ class ModelChoiceFieldTests(TestCase):\n             field = forms.ModelChoiceField(Category.objects.order_by('-name'))\n             self.assertEqual('Entertainment', field.clean(self.c1.pk).name)\n \n+    def test_choice_value_hash(self):\n+        \"\"\"\n+        Test that ModelChoiceIteratorValue is hashable\n+        and behaves correctly in dictionary and set contexts.\n+        \"\"\"\n+        value_1 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+        value_2 = ModelChoiceIteratorValue(self.c2.pk, self.c2)\n+        value_3 = ModelChoiceIteratorValue(self.c1.pk, self.c1)\n+\n+        # Test hashing - two objects with the same primary key should have the same hash\n+        self.assertEqual(hash(value_1), hash(value_3))\n+        self.assertNotEqual(hash(value_1), hash(value_2))\n+\n+        # Test dictionary usage\n+        test_dict = {value_1: 'first_option', value_2: 'second_option'}\n+        self.assertEqual(test_dict[value_1], 'first_option')\n+        self.assertEqual(test_dict[value_3], 'first_option')  # value_3 should resolve to the same as value_1\n+\n+        # Test set usage\n+        test_set = {value_1, value_2, value_3}\n+        self.assertEqual(len(test_set), 2)\n+        self.assertIn(value_1, test_set)\n+        self.assertIn(value_2, test_set)\n+        self.assertIn(value_3, test_set)\n+\n     def test_queryset_manager(self):\n         f = forms.ModelChoiceField(Category.objects)\n         self.assertEqual(len(f.choices), 4)\n",
  "django__django-14999": "",
  "django__django-15061": "",
  "django__django-15202": "diff --git a/tests/forms_tests/field_tests/test_urlfield.py b/tests/forms_tests/field_tests/test_urlfield.py\nindex acda5dd..c95b1f1 100644\n--- a/tests/forms_tests/field_tests/test_urlfield.py\n+++ b/tests/forms_tests/field_tests/test_urlfield.py\n@@ -70,6 +70,10 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # IPv6.\n             ('http://[12:34::3a53]/', 'http://[12:34::3a53]/'),\n             ('http://[a34:9238::]:8080/', 'http://[a34:9238::]:8080/'),\n+            # URL that previously caused a ValueError instead of a ValidationError.\n+            ('////]@N.AN', 'Enter a valid URL.'),\n+            # Another case with an empty hostname.\n+            ('#@A.bO', 'Enter a valid URL.'),\n         ]\n         for url, expected in tests:\n             with self.subTest(url=url):\n@@ -100,6 +104,10 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n             # even on domains that don't fail the domain label length check in\n             # the regex.\n             'http://%s' % (\"X\" * 200,),\n+            # URL that previously caused a ValueError instead of a ValidationError.\n+            ('////]@N.AN', 'Enter a valid URL.'),\n+            # Another case with an empty hostname.\n+            ('#@A.bO', 'Enter a valid URL.'),\n         ]\n         msg = \"'Enter a valid URL.'\"\n         for value in tests:\n@@ -107,7 +115,21 @@ class URLFieldTest(FormFieldAssertionsMixin, SimpleTestCase):\n                 with self.assertRaisesMessage(ValidationError, msg):\n                     f.clean(value)\n \n-    def test_urlfield_clean_required(self):\n+    def test_urlfield_invalid_hostname_cases(self):\n+        f = URLField()\n+        invalid_urls = [\n+            '////]@N.AN',\n+            '#@A.bO',\n+            # URL that previously caused a ValueError instead of a ValidationError.\n+            ('////]@N.AN', 'Enter a valid URL.'),\n+            # Another case with an empty hostname.\n+            ('#@A.bO', 'Enter a valid URL.'),\n+        ]\n+        msg = \"'Enter a valid URL.'\"\n+        for url in invalid_urls:\n+            with self.subTest(url=url):\n+                with self.assertRaisesMessage(ValidationError, msg):\n+                    f.clean(url)\n         f = URLField()\n         msg = \"'This field is required.'\"\n         with self.assertRaisesMessage(ValidationError, msg):\n",
  "django__django-15213": "diff --git a/tests/annotations/tests.py b/tests/annotations/tests.py\nindex a07e97b..d039c21 100644\n--- a/tests/annotations/tests.py\n+++ b/tests/annotations/tests.py\n@@ -12,6 +12,7 @@ from django.db.models.functions import (\n     Coalesce, ExtractYear, Floor, Length, Lower, Trim,\n )\n from django.test import TestCase, skipUnlessDBFeature\n+from django.db.models import Decimal, IntegerField\n from django.test.utils import register_lookup\n \n from .models import (\n",
  "django__django-15347": "diff --git a/tests/messages_tests/test_cookie.py b/tests/messages_tests/test_cookie.py\nindex b756f61..78d7492 100644\n--- a/tests/messages_tests/test_cookie.py\n+++ b/tests/messages_tests/test_cookie.py\n@@ -1,3 +1,4 @@\n+\n import json\n import random\n \n@@ -143,7 +144,16 @@ class CookieTests(BaseTests, SimpleTestCase):\n         for illegal in non_compliant_chars:\n             self.assertEqual(encoded.find(illegal), -1)\n \n-    def test_json_encoder_decoder(self):\n+    def test_extra_tags_empty_string(self):\n+        \"\"\"\n+        Test that a message's extra_tags attribute remains an empty string after\n+        being encoded and then decoded.\n+        \"\"\"\n+        storage = self.get_storage()\n+        message = Message(constants.INFO, \"Test message with empty extra_tags\", extra_tags=\"\")\n+        encoded = storage._encode(message)\n+        decoded = storage._decode(encoded)\n+        self.assertEqual(decoded.extra_tags, \"\")\n         \"\"\"\n         A complex nested data structure containing Message\n         instances is properly encoded/decoded by the custom JSON\n",
  "django__django-15388": "",
  "django__django-15400": "",
  "django__django-15498": "diff --git a/tests/view_tests/tests/test_static.py b/tests/view_tests/tests/test_static.py\nindex 3cb5428..e35a755 100644\n--- a/tests/view_tests/tests/test_static.py\n+++ b/tests/view_tests/tests/test_static.py\n@@ -1,3 +1,4 @@\n+\n import mimetypes\n import unittest\n from os import path\n@@ -184,7 +185,17 @@ class StaticHelperTest(StaticTests):\n \n \n class StaticUtilsTests(unittest.TestCase):\n-    def test_was_modified_since_fp(self):\n+    def test_was_modified_since_empty_string(self):\n+        \"\"\"\n+        An empty string as If-Modified-Since header should not raise an exception.\n+        Ensure it handles gracefully and behaves as expected.\n+        \"\"\"\n+        mtime = 1  # arbitrary modification time\n+        try:\n+            result = was_modified_since(\"\", mtime)\n+            self.assertTrue(result)  # Check the expected behavior with an empty header\n+        except Exception as e:\n+            self.fail(f\"was_modified_since raised an exception with an empty string: {str(e)}\")\n         \"\"\"\n         A floating point mtime does not disturb was_modified_since (#18675).\n         \"\"\"\n",
  "django__django-15781": "diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py\nindex 29530a0..1ff93d8 100644\n--- a/tests/user_commands/tests.py\n+++ b/tests/user_commands/tests.py\n@@ -1,5 +1,7 @@\n+\n import os\n from io import StringIO\n+from argparse import ArgumentDefaultsHelpFormatter\n from unittest import mock\n \n from admin_scripts.tests import AdminScriptTestCase\n@@ -411,7 +413,30 @@ class CommandTests(SimpleTestCase):\n         parser = BaseCommand().create_parser(\"prog_name\", \"subcommand\", epilog=epilog)\n         self.assertEqual(parser.epilog, epilog)\n \n-    def test_outputwrapper_flush(self):\n+    def test_custom_formatter_usage(self):\n+        \"\"\"\n+        Test that the ArgumentDefaultsHelpFormatter is used and custom help\n+        formatter produces the expected output format.\n+        \"\"\"\n+        class CustomCommand(BaseCommand):\n+            help = \"\"\"Import a contract from tzkt.\\nExample usage:\\n\\t./manage.py tzkt_import 'Tezos Mainnet' KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\"\"\"\n+\n+        command = CustomCommand()\n+        parser = command.create_parser(\"manage.py\", \"tzkt_import\", formatter_class=ArgumentDefaultsHelpFormatter)\n+        expected_help_output = (\n+            \"usage: manage.py tzkt_import [-h] [--api API] [--version] [-v {0,1,2,3}] \"\n+            \"[--settings SETTINGS] [--pythonpath PYTHONPATH] [--traceback] [--no-color] \"\n+            \"[--force-color] [--skip-checks] blockchain target\\n\\n\"\n+            \"Import a contract from tzkt.\\n\\nExample usage:\\n\\t\"\n+            \"./manage.py tzkt_import 'Tezos Mainnet' \"\n+            \"KT1HTDtMBRCKoNHjfWEEvXneGQpCfPAt6BRe\\n\\n\"\n+            \"positional arguments:\\n  blockchain\\tName of the blockchain to import into\\n\"\n+            \"  target\\tId of the contract to import\\n\"\n+        )\n+\n+        with mock.patch('sys.stdout', new_callable=StringIO) as mock_stdout:\n+            parser.print_help()\n+            self.assertEqual(expected_help_output.strip(), mock_stdout.getvalue().strip())\n         out = StringIO()\n         with mock.patch.object(out, \"flush\") as mocked_flush:\n             management.call_command(\"outputwrapper\", stdout=out)\n",
  "django__django-15789": "diff --git a/tests/utils_tests/test_html.py b/tests/utils_tests/test_html.py\nindex f300e4f..3b2cf4c 100644\n--- a/tests/utils_tests/test_html.py\n+++ b/tests/utils_tests/test_html.py\n@@ -1,8 +1,10 @@\n+\n import os\n from datetime import datetime\n \n from django.test import SimpleTestCase\n-from django.utils.functional import lazystr\n+from django.core.serializers.json import DjangoJSONEncoder\n+import json\n from django.utils.html import (\n     conditional_escape,\n     escape,\n@@ -217,7 +219,34 @@ class TestUtilsHtml(SimpleTestCase):\n             '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n         )\n \n-    def test_smart_urlquote(self):\n+    def test_json_script_custom_encoder(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                return json.dumps({'custom': 'output'})\n+\n+        self.assertHTMLEqual(\n+            json_script({}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"custom\": \"output\"}</script>',\n+        )\n+\n+    def test_json_script_custom_encoder_with_data(self):\n+        class CustomDjangoJSONEncoder(DjangoJSONEncoder):\n+            def encode(self, o):\n+                # Custom encoder to output keys in sorted order\n+                return json.dumps(o, sort_keys=True)\n+\n+        # Testing custom encoder with actual data\n+        self.assertHTMLEqual(\n+            json_script({\"b\": 1, \"a\": 2}, encoder=CustomDjangoJSONEncoder),\n+            '<script type=\"application/json\">{\"a\": 2, \"b\": 1}</script>',\n+        )\n+\n+    def test_json_script_default_encoder(self):\n+        # Verifying that default encoder works the same as before\n+        self.assertHTMLEqual(\n+            json_script({\"key\": \"value\"}),\n+            '<script type=\"application/json\">{\"key\": \"value\"}</script>',\n+        )\n         items = (\n             (\"http://\u00f6\u00e4\u00fc.com/\", \"http://xn--4ca9at.com/\"),\n             (\"http://\u00f6\u00e4\u00fc.com/\u00f6\u00e4\u00fc/\", \"http://xn--4ca9at.com/%C3%B6%C3%A4%C3%BC/\"),\n",
  "django__django-15790": "diff --git a/tests/check_framework/test_templates.py b/tests/check_framework/test_templates.py\nindex 72e6cfe..105e7ea 100644\n--- a/tests/check_framework/test_templates.py\n+++ b/tests/check_framework/test_templates.py\n@@ -161,7 +161,42 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n     @override_settings(\n         INSTALLED_APPS=[\"check_framework.template_test_apps.same_tags_app_1\"]\n     )\n-    def test_template_tags_with_same_library_name_and_module_name(self):\n+    def test_template_tags_with_same_library_and_multiple_occurrences(self):\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"same_library\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+                self.get_settings(\n+                    \"same_library\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(\n+                check_for_template_tags_with_the_same_name(None),\n+                [\n+                    Error(\n+                        E003.msg.format(\n+                            \"'same_library'\",\n+                            \"'check_framework.template_test_apps.same_tags_app_1.\"\n+                            \"templatetags.same_tags', \"\n+                            \"'check_framework.template_test_apps.same_tags_app_1.\"\n+                            \"templatetags.same_tags'\",\n+                        ),\n+                        id=E003.id,\n+                    )\n+                ],\n+            )\n+\n+    def test_template_tags_same_library_in_installed_apps_libraries(self):\n+        with self.settings(\n+            TEMPLATES=[\n+                self.get_settings(\n+                    \"same_tags\", \"same_tags_app_1.templatetags.same_tags\"\n+                ),\n+            ]\n+        ):\n+            self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n         with self.settings(\n             TEMPLATES=[\n                 self.get_settings(\n@@ -206,4 +241,4 @@ class CheckTemplateTagLibrariesWithSameName(SimpleTestCase):\n         ]\n     )\n     def test_template_tags_with_different_name(self):\n-        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n+        self.assertEqual(check_for_template_tags_with_the_same_name(None), [])\n",
  "django__django-15814": "diff --git a/tests/proxy_models/tests.py b/tests/proxy_models/tests.py\nindex bcc4684..b8de6e7 100644\n--- a/tests/proxy_models/tests.py\n+++ b/tests/proxy_models/tests.py\n@@ -398,9 +398,24 @@ class ProxyModelTests(TestCase):\n     def test_eq(self):\n         self.assertEqual(MyPerson(id=100), Person(id=100))\n \n+from django.test import TestCase, override_settings\n+from .models import CustomModel, ProxyCustomModel, AnotherModel\n+\n \n-@override_settings(ROOT_URLCONF=\"proxy_models.urls\")\n-class ProxyModelAdminTests(TestCase):\n+class ProxyModelQuerySetTests(TestCase):\n+    @classmethod\n+    def setUpTestData(cls):\n+        proxy_model_instance = ProxyCustomModel.objects.create(name=\"Proxy Instance\")\n+        AnotherModel.objects.create(custom=proxy_model_instance)\n+\n+    def test_select_related_only_on_proxy_model(self):\n+        # Check if select_related and only() do not crash with proxy models.\n+        try:\n+            queryset = AnotherModel.objects.select_related(\"custom\").only(\"custom__name\").all()\n+            results = list(queryset)\n+            self.assertTrue(results)\n+        except Exception as e:\n+            self.fail(f\"select_related() with only() on proxy models raised an exception: {e}\")\n     @classmethod\n     def setUpTestData(cls):\n         cls.superuser = AuthUser.objects.create(is_superuser=True, is_staff=True)\n",
  "django__django-15851": "diff --git a/tests/dbshell/test_postgresql.py b/tests/dbshell/test_postgresql.py\nindex d629a04..eda9835 100644\n--- a/tests/dbshell/test_postgresql.py\n+++ b/tests/dbshell/test_postgresql.py\n@@ -154,7 +154,24 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n     def test_parameters(self):\n         self.assertEqual(\n             self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"--help\"]),\n-            ([\"psql\", \"dbname\", \"--help\"], None),\n+            ([\"psql\", \"--help\", \"dbname\"], None),\n+        )\n+        \n+    def test_parameters_before_dbname(self):\n+        # New test case to verify that additional parameters come before the database name\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env({\"NAME\": \"dbname\"}, [\"-c\", \"SELECT * FROM table;\"]),\n+            ([\"psql\", \"-c\", \"SELECT * FROM table;\", \"dbname\"], None),\n+        )\n+\n+    def test_multiple_parameters(self):\n+        # Test with multiple parameters to ensure all are positioned correctly before the dbname\n+        self.assertEqual(\n+            self.settings_to_cmd_args_env(\n+                {\"NAME\": \"dbname\"},\n+                [\"-c\", \"SELECT * FROM irrelevant_table;\", \"--echo-errors\"]\n+            ),\n+            ([\"psql\", \"-c\", \"SELECT * FROM irrelevant_table;\", \"--echo-errors\", \"dbname\"], None),\n         )\n \n     @skipUnless(connection.vendor == \"postgresql\", \"Requires a PostgreSQL connection\")\n@@ -183,4 +200,4 @@ class PostgreSqlDbshellCommandTestCase(SimpleTestCase):\n         args[0:1] = [sys.executable, str(fake_client)]\n         with self.assertRaises(subprocess.CalledProcessError) as ctx:\n             subprocess.run(args, check=True, env=env)\n-        self.assertNotIn(\"somepassword\", str(ctx.exception))\n+        self.assertNotIn(\"somepassword\", str(ctx.exception))\n",
  "django__django-15902": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex 44ea946..b151b7a 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -1901,12 +1901,31 @@ class AllValidTests(SimpleTestCase):\n class DeprecationTests(SimpleTestCase):\n     def test_warning(self):\n         from django.forms.utils import DEFAULT_TEMPLATE_DEPRECATION_MSG\n+        from django.forms.formsets import formset_factory, BaseFormSet\n+        from myapp.forms import Choice\n+        from unittest.mock import patch\n \n-        with isolate_lru_cache(get_default_renderer), self.settings(\n-            FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n-        ), self.assertRaisesMessage(\n-            RemovedInDjango50Warning, DEFAULT_TEMPLATE_DEPRECATION_MSG\n-        ):\n-            ChoiceFormSet = formset_factory(Choice)\n-            formset = ChoiceFormSet()\n-            str(formset)\n+        def test_no_management_form_warning(self):\n+            \"\"\"\n+            Ensure management forms do not trigger deprecation warnings for default.html.\n+            \"\"\"\n+            with isolate_lru_cache(get_default_renderer), self.settings(\n+                FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n+            ), patch('django.forms.Form._render', return_value=''):\n+                ChoiceFormSet = formset_factory(Choice, formset=BaseFormSet)\n+                formset = ChoiceFormSet()\n+                # Specifically test the rendering of the management form\n+                with self.assertRaisesMessage(RemovedInDjango50Warning, DEFAULT_TEMPLATE_DEPRECATION_MSG):\n+                    str(formset.management_form)\n+\n+        def test_no_deprecation_warning_when_rendering_other_forms(self):\n+            \"\"\"\n+            Ensure that rendering other forms still does not trigger deprecation warnings\n+            when properly using the div template.\n+            \"\"\"\n+            with isolate_lru_cache(get_default_renderer), self.settings(\n+                FORM_RENDERER=\"django.forms.renderers.DjangoTemplates\"\n+            ), patch('django.forms.Form._render', return_value=''):\n+                FormSet = formset_factory(Choice)\n+                formset = FormSet()\n+                str(formset)\n",
  "django__django-16041": "diff --git a/tests/forms_tests/tests/test_formsets.py b/tests/forms_tests/tests/test_formsets.py\nindex a34f3d3..e44c003 100644\n--- a/tests/forms_tests/tests/test_formsets.py\n+++ b/tests/forms_tests/tests/test_formsets.py\n@@ -173,6 +173,21 @@ class FormsFormsetTestCase(SimpleTestCase):\n             self.assertTrue(hasattr(form, \"custom_kwarg\"))\n             self.assertEqual(form.custom_kwarg, i)\n \n+    def test_empty_permitted_ignored_empty_form_true(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        formset = FormSet(form_kwargs={\"empty_permitted\": True})\n+        # We are testing that the empty_form does not raise an error and\n+        # that the empty_permitted attribute is True by default (should be irrelevant to empty_form)\n+        self.assertTrue(hasattr(formset.empty_form, \"_errors\"))  # Ensure no crash\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n+\n+    def test_empty_permitted_ignored_empty_form_false(self):\n+        FormSet = formset_factory(CustomKwargForm)\n+        formset = FormSet(form_kwargs={\"empty_permitted\": False})\n+        # Similar test to ensure behavior matches for False as well\n+        self.assertTrue(hasattr(formset.empty_form, \"_errors\"))  # Ensure no crash\n+        self.assertIs(formset.empty_form.empty_permitted, True)\n+\n     def test_form_kwargs_empty_form(self):\n         FormSet = formset_factory(CustomKwargForm)\n         formset = FormSet(form_kwargs={\"custom_kwarg\": 1})\n",
  "django__django-16046": "diff --git a/tests/utils_tests/test_numberformat.py b/tests/utils_tests/test_numberformat.py\nindex 41aae41..9c9d791 100644\n--- a/tests/utils_tests/test_numberformat.py\n+++ b/tests/utils_tests/test_numberformat.py\n@@ -1,3 +1,4 @@\n+\n from decimal import Decimal\n from sys import float_info\n \n@@ -160,7 +161,15 @@ class TestNumberFormat(SimpleTestCase):\n                     nformat(Decimal(value), \".\", decimal_pos), expected_value\n                 )\n \n-    def test_decimal_subclass(self):\n+    def test_empty(self):\n+        # Test empty string input\n+        self.assertEqual(nformat(\"\", \".\"), \"\")\n+        \n+        # Test None input\n+        self.assertEqual(nformat(None, \".\"), \"None\")\n+        \n+        # Test negative as an empty string, should handle gracefully\n+        self.assertEqual(nformat(\"-\", \".\"), \"-\")\n         class EuroDecimal(Decimal):\n             \"\"\"\n             Wrapper for Decimal which prefixes each amount with the \u20ac symbol.\n",
  "django__django-16139": "diff --git a/tests/auth_tests/test_forms.py b/tests/auth_tests/test_forms.py\nindex bf048c1..aab9825 100644\n--- a/tests/auth_tests/test_forms.py\n+++ b/tests/auth_tests/test_forms.py\n@@ -1,4 +1,5 @@\n-import datetime\n+\n+import urllib.parse\n import re\n from unittest import mock\n \n@@ -22,6 +23,7 @@ from django.core.mail import EmailMultiAlternatives\n from django.forms import forms\n from django.forms.fields import CharField, Field, IntegerField\n from django.test import SimpleTestCase, TestCase, override_settings\n+from django.urls import reverse\n from django.utils import translation\n from django.utils.text import capfirst\n from django.utils.translation import gettext as _\n@@ -892,6 +894,46 @@ class UserChangeFormTest(TestDataMixin, TestCase):\n         # value to render correctly\n         self.assertEqual(form.initial[\"password\"], form[\"password\"].value())\n \n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_link_to_password_reset_in_helptext_via_to_field(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search('<a href=\"(.*?)\">', password_help_text)\n+        \n+        # URL to UserChangeForm in admin via to_field (instead of pk).\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.username,),\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n+    @override_settings(ROOT_URLCONF=\"auth_tests.urls_admin\")\n+    def test_password_reset_link_with_pk_access(self):\n+        user = User.objects.get(username=\"testclient\")\n+        form = UserChangeForm(data={}, instance=user)\n+        password_help_text = form.fields[\"password\"].help_text\n+        matches = re.search('<a href=\"(.*?)\">', password_help_text)\n+\n+        # URL to UserChangeForm in admin via pk.\n+        admin_user_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_change\",\n+            args=(user.pk,),\n+        )\n+        joined_url = urllib.parse.urljoin(admin_user_change_url, matches.group(1))\n+\n+        pw_change_url = reverse(\n+            f\"admin:{user._meta.app_label}_{user._meta.model_name}_password_change\",\n+            args=(user.pk,),\n+        )\n+        self.assertEqual(joined_url, pw_change_url)\n+\n     def test_custom_form(self):\n         class CustomUserChangeForm(UserChangeForm):\n             class Meta(UserChangeForm.Meta):\n",
  "django__django-16255": "",
  "django__django-16379": "diff --git a/tests/cache/tests.py b/tests/cache/tests.py\nindex 014d28a..3b49927 100644\n--- a/tests/cache/tests.py\n+++ b/tests/cache/tests.py\n@@ -1,3 +1,4 @@\n+\n # Unit tests for cache framework\n # Uses whatever cache backend is set in the test settings file.\n import copy\n@@ -7,6 +8,7 @@ import pickle\n import re\n import shutil\n import sys\n+from unittest import mock\n import tempfile\n import threading\n import time\n@@ -1755,7 +1757,34 @@ class FileBasedCacheTests(BaseCacheTests, TestCase):\n             with self.assertRaises(OSError):\n                 cache.get(\"foo\")\n \n-    def test_empty_cache_file_considered_expired(self):\n+    def test_has_key_race_handling(self):\n+        self.assertIs(cache.add(\"key\", \"value\"), True)\n+        with mock.patch(\"builtins.open\", side_effect=FileNotFoundError) as mocked_open:\n+            self.assertIs(cache.has_key(\"key\"), False)\n+            mocked_open.assert_called_once()\n+    \n+    def test_has_key_with_multiple_threads(self):\n+        # Define a function to simulate cache access\n+        def access_cache():\n+            result = cache.has_key(\"key\")\n+            return result\n+\n+        self.assertIs(cache.add(\"key\", \"value\"), True)\n+\n+        # Start multiple threads to simulate concurrent accesses\n+        threads = [threading.Thread(target=access_cache) for _ in range(10)]\n+\n+        for thread in threads:\n+            thread.start()\n+\n+        for thread in threads:\n+            thread.join()\n+\n+    def test_has_key_after_deletion(self):\n+        # Add a key and then simulate its deletion before checking\n+        self.assertIs(cache.add(\"key-to-delete\", \"value\"), True)\n+        cache.delete(\"key-to-delete\")\n+        self.assertIs(cache.has_key(\"key-to-delete\"), False)\n         cache_file = cache._key_to_file(\"foo\")\n         with open(cache_file, \"wb\") as fh:\n             fh.write(b\"\")\n",
  "django__django-16527": "diff --git a/tests/admin_views/test_templatetags.py b/tests/admin_views/test_templatetags.py\nindex eb51f4c..e06352b 100644\n--- a/tests/admin_views/test_templatetags.py\n+++ b/tests/admin_views/test_templatetags.py\n@@ -1,3 +1,4 @@\n+\n import datetime\n \n from django.contrib.admin import ModelAdmin\n@@ -11,6 +12,8 @@ from django.urls import reverse\n from .admin import ArticleAdmin, site\n from .models import Article, Question\n from .tests import AdminViewBasicTestCase\n+from django.contrib.auth import get_permission_codename\n+from .tests import get_perm\n \n \n class AdminTemplateTagsTest(AdminViewBasicTestCase):\n",
  "django__django-16595": "",
  "django__django-16873": "diff --git a/tests/template_tests/filter_tests/test_join.py b/tests/template_tests/filter_tests/test_join.py\nindex 1b66eaa..c33db93 100644\n--- a/tests/template_tests/filter_tests/test_join.py\n+++ b/tests/template_tests/filter_tests/test_join.py\n@@ -1,3 +1,4 @@\n+\n from django.template.defaultfilters import join\n from django.test import SimpleTestCase\n from django.utils.safestring import mark_safe\n@@ -26,7 +27,13 @@ class JoinTests(SimpleTestCase):\n         output = self.engine.render_to_string(\"join04\", {\"a\": [\"alpha\", \"beta & me\"]})\n         self.assertEqual(output, \"alpha &amp; beta & me\")\n \n-    # Joining with unsafe joiners doesn't result in unsafe strings.\n+    @setup({\"join_autoescape_off\": '{% autoescape off %}{{ a|join:var }}{% endautoescape %}'})\n+    def test_join_autoescape_off(self):\n+        output = self.engine.render_to_string(\n+            \"join_autoescape_off\", {\"a\": [\"<p>Hello World!</p>\", \"beta & me\", \"<script>Hi!</script>\"], \"var\": \"<br/>\"}\n+        )\n+        expected_result = \"<p>Hello World!</p><br/>beta & me<br/><script>Hi!</script>\"\n+        self.assertEqual(output, expected_result)\n     @setup({\"join05\": \"{{ a|join:var }}\"})\n     def test_join05(self):\n         output = self.engine.render_to_string(\n@@ -78,4 +85,4 @@ class FunctionTests(SimpleTestCase):\n \n     def test_noniterable_arg_autoescape_off(self):\n         obj = object()\n-        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n+        self.assertEqual(join(obj, \"<br>\", autoescape=False), obj)\n",
  "django__django-17051": "diff --git a/tests/bulk_create/tests.py b/tests/bulk_create/tests.py\nindex c425030..a66c5f8 100644\n--- a/tests/bulk_create/tests.py\n+++ b/tests/bulk_create/tests.py\n@@ -569,7 +569,29 @@ class BulkCreateTests(TestCase):\n                 unique_fields=[\"big_auto_fields\"],\n             )\n \n-    def _test_update_conflicts_two_fields(self, unique_fields):\n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_bulk_create_with_update_conflicts_returns_ids_two_fields(self):\n+        TwoFields.objects.bulk_create(\n+            [\n+                TwoFields(f1=1, f2=1, name=\"a\"),\n+                TwoFields(f1=2, f2=2, name=\"b\"),\n+            ]\n+        )\n+        self.assertEqual(TwoFields.objects.count(), 2)\n+\n+        conflicting_objects = [\n+            TwoFields(f1=1, f2=1, name=\"c\"),\n+            TwoFields(f1=2, f2=2, name=\"d\"),\n+        ]\n+        results = TwoFields.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            unique_fields=[\"f1\"],\n+            update_fields=[\"name\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        for instance in results:\n+            self.assertIsNotNone(instance.pk)\n         TwoFields.objects.bulk_create(\n             [\n                 TwoFields(f1=1, f2=1, name=\"a\"),\n@@ -654,7 +676,26 @@ class BulkCreateTests(TestCase):\n     def test_update_conflicts_two_fields_no_unique_fields(self):\n         self._test_update_conflicts_two_fields([])\n \n-    def _test_update_conflicts_unique_two_fields(self, unique_fields):\n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_bulk_create_with_update_conflicts_returns_ids_unique_two_fields(self):\n+        Country.objects.bulk_create(self.data)\n+        self.assertEqual(Country.objects.count(), 4)\n+\n+        new_data = [\n+            Country(name=\"Germany\", iso_two_letter=\"DE\", description=\"Germany is a country in Central Europe.\"),\n+            Country(name=\"Czech Republic\", iso_two_letter=\"CZ\", description=\"The Czech Republic is a landlocked country in Central Europe.\"),\n+            Country(name=\"Australia\", iso_two_letter=\"AU\"),\n+            Country(name=\"Japan\", iso_two_letter=\"JP\", description=\"Japan is an island country in East Asia.\"),\n+        ]\n+        results = Country.objects.bulk_create(\n+            new_data,\n+            update_conflicts=True,\n+            update_fields=[\"description\"],\n+            unique_fields=[\"iso_two_letter\", \"name\"],\n+        )\n+        self.assertEqual(len(results), len(new_data))\n+        for instance in results:\n+            self.assertIsNotNone(instance.pk)\n         Country.objects.bulk_create(self.data)\n         self.assertEqual(Country.objects.count(), 4)\n \n@@ -728,7 +769,31 @@ class BulkCreateTests(TestCase):\n     def test_update_conflicts_unique_two_fields_unique_no_unique_fields(self):\n         self._test_update_conflicts_unique_two_fields([])\n \n-    def _test_update_conflicts(self, unique_fields):\n+    @skipUnlessDBFeature(\"can_return_rows_from_bulk_insert\")\n+    def test_bulk_create_with_update_conflicts_returns_ids(self):\n+        UpsertConflict.objects.bulk_create(\n+            [\n+                UpsertConflict(number=1, rank=1, name=\"John\"),\n+                UpsertConflict(number=2, rank=2, name=\"Mary\"),\n+                UpsertConflict(number=3, rank=3, name=\"Hannah\"),\n+            ]\n+        )\n+        self.assertEqual(UpsertConflict.objects.count(), 3)\n+\n+        conflicting_objects = [\n+            UpsertConflict(number=1, rank=4, name=\"Steve\"),\n+            UpsertConflict(number=2, rank=2, name=\"Olivia\"),\n+            UpsertConflict(number=3, rank=1, name=\"Hannah\"),\n+        ]\n+        results = UpsertConflict.objects.bulk_create(\n+            conflicting_objects,\n+            update_conflicts=True,\n+            update_fields=[\"name\", \"rank\"],\n+            unique_fields=[\"number\"],\n+        )\n+        self.assertEqual(len(results), len(conflicting_objects))\n+        for instance in results:\n+            self.assertIsNotNone(instance.pk)\n         UpsertConflict.objects.bulk_create(\n             [\n                 UpsertConflict(number=1, rank=1, name=\"John\"),\n@@ -816,4 +881,4 @@ class BulkCreateTests(TestCase):\n                 {\"rank\": 1, \"name\": \"c\"},\n                 {\"rank\": 2, \"name\": \"d\"},\n             ],\n-        )\n+        )\n",
  "django__django-17087": "diff --git a/tests/migrations/test_writer.py b/tests/migrations/test_writer.py\nindex a812969..2f9a000 100644\n--- a/tests/migrations/test_writer.py\n+++ b/tests/migrations/test_writer.py\n@@ -197,6 +197,28 @@ class OperationWriterTests(SimpleTestCase):\n             \"),\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n \n class WriterTests(SimpleTestCase):\n     \"\"\"\n@@ -255,12 +277,56 @@ class WriterTests(SimpleTestCase):\n             decimal.Decimal(\"1.3\"), (\"Decimal('1.3')\", {\"from decimal import Decimal\"})\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n         self.assertSerializedEqual(Money(\"1.3\"))\n         self.assertSerializedResultEqual(\n             Money(\"1.3\"),\n             (\"migrations.test_writer.Money('1.3')\", {\"import migrations.test_writer\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_constants(self):\n         self.assertSerializedEqual(None)\n         self.assertSerializedEqual(True)\n@@ -296,6 +362,28 @@ class WriterTests(SimpleTestCase):\n             (\"[list, tuple, dict, set, frozenset]\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_lazy_objects(self):\n         pattern = re.compile(r\"^foo$\")\n         lazy_pattern = SimpleLazyObject(lambda: pattern)\n@@ -306,6 +394,28 @@ class WriterTests(SimpleTestCase):\n             TextEnum.A,\n             (\"migrations.test_writer.TextEnum['A']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             TextTranslatedEnum.A,\n             (\n@@ -313,6 +423,28 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             BinaryEnum.A,\n             (\n@@ -320,10 +452,54 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             IntEnum.B,\n             (\"migrations.test_writer.IntEnum['B']\", {\"import migrations.test_writer\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             self.NestedEnum.A,\n             (\n@@ -331,11 +507,55 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedEqual(self.NestedEnum.A)\n \n         field = models.CharField(\n             default=TextEnum.B, choices=[(m.value, m) for m in TextEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -344,10 +564,54 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextEnum['B'])], \"\n             \"default=migrations.test_writer.TextEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         field = models.CharField(\n             default=TextTranslatedEnum.A,\n             choices=[(m.value, m) for m in TextTranslatedEnum],\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -356,9 +620,53 @@ class WriterTests(SimpleTestCase):\n             \"('value-b', migrations.test_writer.TextTranslatedEnum['B'])], \"\n             \"default=migrations.test_writer.TextTranslatedEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         field = models.CharField(\n             default=BinaryEnum.B, choices=[(m.value, m) for m in BinaryEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -367,9 +675,53 @@ class WriterTests(SimpleTestCase):\n             \"(b'value-b', migrations.test_writer.BinaryEnum['B'])], \"\n             \"default=migrations.test_writer.BinaryEnum['B'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         field = models.IntegerField(\n             default=IntEnum.A, choices=[(m.value, m) for m in IntEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -379,6 +731,28 @@ class WriterTests(SimpleTestCase):\n             \"default=migrations.test_writer.IntEnum['A'])\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_enum_flags(self):\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A,\n@@ -387,6 +761,28 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             IntFlagEnum.B,\n             (\n@@ -394,9 +790,53 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.test_writer\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         field = models.IntegerField(\n             default=IntFlagEnum.A, choices=[(m.value, m) for m in IntFlagEnum]\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -405,6 +845,28 @@ class WriterTests(SimpleTestCase):\n             \"(2, migrations.test_writer.IntFlagEnum['B'])], \"\n             \"default=migrations.test_writer.IntFlagEnum['A'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             IntFlagEnum.A | IntFlagEnum.B,\n             (\n@@ -414,6 +876,28 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_choices(self):\n         class TextChoices(models.TextChoices):\n             A = \"A\", \"A value\"\n@@ -433,6 +917,28 @@ class WriterTests(SimpleTestCase):\n             DateChoices.DATE_1,\n             (\"datetime.date(1969, 7, 20)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         field = models.CharField(default=TextChoices.B, choices=TextChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -440,12 +946,56 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(choices=[('A', 'A value'), ('B', 'B value')], \"\n             \"default='B')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         field = models.IntegerField(default=IntegerChoices.B, choices=IntegerChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n             \"models.IntegerField(choices=[(1, 'One'), (2, 'Two')], default=2)\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         field = models.DateField(default=DateChoices.DATE_2, choices=DateChoices)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n@@ -456,6 +1006,28 @@ class WriterTests(SimpleTestCase):\n             \"default=datetime.date(1969, 11, 19))\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_nested_class(self):\n         for nested_cls in [self.NestedEnum, self.NestedChoices]:\n             cls_name = nested_cls.__name__\n@@ -478,14 +1050,80 @@ class WriterTests(SimpleTestCase):\n             uuid_a,\n             (\"uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8')\", {\"import uuid\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             uuid_b,\n             (\"uuid.UUID('c7853ec1-2ea3-4359-b02d-b54e8f1bcee2')\", {\"import uuid\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n         field = models.UUIDField(\n             choices=((uuid_a, \"UUID A\"), (uuid_b, \"UUID B\")), default=uuid_a\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         string = MigrationWriter.serialize(field)[0]\n         self.assertEqual(\n             string,\n@@ -495,6 +1133,28 @@ class WriterTests(SimpleTestCase):\n             \"default=uuid.UUID('5c859437-d061-4847-b3f7-e6b78852f8c8'))\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_pathlib(self):\n         # Pure path objects work in all platforms.\n         self.assertSerializedEqual(pathlib.PurePosixPath())\n@@ -523,6 +1183,28 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"models.FilePathField(path=pathlib.PurePosixPath('/home/user'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertIn(\"import pathlib\", imports)\n \n     def test_serialize_path_like(self):\n@@ -554,13 +1236,79 @@ class WriterTests(SimpleTestCase):\n         self.assertSerializedEqual(\n             datetime.datetime(2014, 1, 1, 1, 1, tzinfo=get_default_timezone())\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedEqual(\n             datetime.datetime(2013, 12, 31, 22, 1, tzinfo=get_fixed_timezone(180))\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             datetime.datetime(2014, 1, 1, 1, 1),\n             (\"datetime.datetime(2014, 1, 1, 1, 1)\", {\"import datetime\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             datetime.datetime(2012, 1, 1, 1, 1, tzinfo=datetime.timezone.utc),\n             (\n@@ -568,6 +1316,28 @@ class WriterTests(SimpleTestCase):\n                 {\"import datetime\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             datetime.datetime(\n                 2012, 1, 1, 2, 1, tzinfo=zoneinfo.ZoneInfo(\"Europe/Paris\")\n@@ -578,12 +1348,56 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_fields(self):\n         self.assertSerializedFieldEqual(models.CharField(max_length=255))\n         self.assertSerializedResultEqual(\n             models.CharField(max_length=255),\n             (\"models.CharField(max_length=255)\", {\"from django.db import models\"}),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedFieldEqual(models.TextField(null=True, blank=True))\n         self.assertSerializedResultEqual(\n             models.TextField(null=True, blank=True),\n@@ -593,20 +1407,108 @@ class WriterTests(SimpleTestCase):\n             ),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_settings(self):\n         self.assertSerializedEqual(\n             SettingsReference(settings.AUTH_USER_MODEL, \"AUTH_USER_MODEL\")\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedResultEqual(\n             SettingsReference(\"someapp.model\", \"AUTH_USER_MODEL\"),\n             (\"settings.AUTH_USER_MODEL\", {\"from django.conf import settings\"}),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_iterators(self):\n         self.assertSerializedResultEqual(\n             ((x, x * x) for x in range(3)), (\"((0, 0), (1, 1), (2, 4))\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_compiled_regex(self):\n         \"\"\"\n         Make sure compiled regex can be serialized.\n@@ -624,6 +1526,28 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.RegexValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.serialize_round_trip(validator)\n \n         # Test with a compiled regex.\n@@ -633,6 +1557,28 @@ class WriterTests(SimpleTestCase):\n             string,\n             \"django.core.validators.RegexValidator(regex=re.compile('^\\\\\\\\w+$'))\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.serialize_round_trip(validator)\n \n         # Test a string regex with flag\n@@ -643,6 +1589,28 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[0-9]+$', \"\n             \"flags=re.RegexFlag['DOTALL'])\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.serialize_round_trip(validator)\n \n         # Test message and code\n@@ -653,6 +1621,28 @@ class WriterTests(SimpleTestCase):\n             \"django.core.validators.RegexValidator('^[-a-zA-Z0-9_]+$', 'Invalid', \"\n             \"'invalid')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.serialize_round_trip(validator)\n \n         # Test with a subclass.\n@@ -661,6 +1651,28 @@ class WriterTests(SimpleTestCase):\n         self.assertEqual(\n             string, \"django.core.validators.EmailValidator(message='hello')\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.serialize_round_trip(validator)\n \n         validator = deconstructible(path=\"migrations.test_writer.EmailValidator\")(\n@@ -671,9 +1683,53 @@ class WriterTests(SimpleTestCase):\n             string, \"migrations.test_writer.EmailValidator(message='hello')\"\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n         validator = deconstructible(path=\"custom.EmailValidator\")(EmailValidator)(\n             message=\"hello\"\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         with self.assertRaisesMessage(ImportError, \"No module named 'custom'\"):\n             MigrationWriter.serialize(validator)\n \n@@ -700,6 +1756,28 @@ class WriterTests(SimpleTestCase):\n             models.OrderBy(models.F(\"name\").desc()),\n             name=\"complex_func_index\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         string, imports = MigrationWriter.serialize(index)\n         self.assertEqual(\n             string,\n@@ -711,6 +1789,28 @@ class WriterTests(SimpleTestCase):\n             \"models.OrderBy(models.OrderBy(models.F('name'), descending=True)), \"\n             \"name='complex_func_index')\",\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertEqual(imports, {\"from django.db import models\"})\n \n     def test_serialize_empty_nonempty_tuple(self):\n@@ -762,6 +1862,28 @@ class WriterTests(SimpleTestCase):\n                 {\"import migrations.models\"},\n             ),\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         self.assertSerializedEqual(FoodManager(\"a\", \"b\"))\n         self.assertSerializedEqual(FoodManager(\"x\", \"y\", c=3, d=4))\n \n@@ -772,6 +1894,28 @@ class WriterTests(SimpleTestCase):\n             frozenset(\"cba\"), (\"frozenset(['a', 'b', 'c'])\", set())\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_serialize_set(self):\n         self.assertSerializedEqual(set())\n         self.assertSerializedResultEqual(set(), (\"set()\", set()))\n@@ -809,6 +1953,28 @@ class WriterTests(SimpleTestCase):\n             (\"('models.Model', {'from django.db import models'})\", set()),\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_simple_migration(self):\n         \"\"\"\n         Tests serializing a simple migration.\n@@ -848,6 +2014,28 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [(\"testapp\", \"some_other_one\")],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         # We don't test the output formatting - that's too fragile.\n@@ -887,6 +2075,28 @@ class WriterTests(SimpleTestCase):\n                 \"dependencies\": [],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         result = self.safe_exec(output)\n@@ -896,6 +2106,28 @@ class WriterTests(SimpleTestCase):\n             result[\"custom_migration_operations\"].more_operations.TestOperation,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_sorted_dependencies(self):\n         migration = type(\n             \"Migration\",\n@@ -912,6 +2144,28 @@ class WriterTests(SimpleTestCase):\n                 ],\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         output = MigrationWriter(migration, include_header=False).as_string()\n         self.assertIn(\n             \"    dependencies = [\\n\"\n@@ -923,6 +2177,28 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_sorted_imports(self):\n         \"\"\"\n         #24155 - Tests ordering of imports.\n@@ -949,6 +2225,28 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\n@@ -956,6 +2254,28 @@ class WriterTests(SimpleTestCase):\n             output,\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_migration_file_header_comments(self):\n         \"\"\"\n         Test comments at top of file.\n@@ -1001,6 +2321,28 @@ class WriterTests(SimpleTestCase):\n                 ]\n             },\n         )\n+\n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n         writer = MigrationWriter(migration)\n         output = writer.as_string()\n         self.assertIn(\"from django.db import migrations\\n\", output)\n@@ -1017,6 +2359,28 @@ class WriterTests(SimpleTestCase):\n             \"models.CharField(default=migrations.test_writer.DeconstructibleInstances)\",\n         )\n \n+    def test_serialize_nested_class_method_as_default(self):\n+        \"\"\"\n+        Test that a class method from a nested class can be correctly serialized\n+        as a field default and referred properly in migrations.\n+        \"\"\"\n+        class Profile(models.Model):\n+            class Capability(models.TextChoices):\n+                BASIC = (\"BASIC\", \"Basic\")\n+                PROFESSIONAL = (\"PROFESSIONAL\", \"Professional\")\n+\n+                @classmethod\n+                def default(cls):\n+                    return [cls.BASIC]\n+\n+            capabilities = models.CharField(\n+                choices=Capability.choices, max_length=30, default=Capability.default\n+            )\n+\n+        # Serialize the field to ensure the default is correctly represented\n+        serialized_field = MigrationWriter.serialize(Profile._meta.get_field('capabilities'))[0]\n+        self.assertIn(\"default=migrations.test_writer.Profile.Capability.default\", serialized_field)\n+\n     def test_register_serializer(self):\n         class ComplexSerializer(BaseSerializer):\n             def serialize(self):\n@@ -1032,4 +2396,4 @@ class WriterTests(SimpleTestCase):\n         with self.assertRaisesMessage(\n             ValueError, \"'TestModel1' must inherit from 'BaseSerializer'.\"\n         ):\n-            MigrationWriter.register_serializer(complex, TestModel1)\n+            MigrationWriter.register_serializer(complex, TestModel1)\n",
  "matplotlib__matplotlib-22711": "diff --git a/lib/matplotlib/tests/test_widgets.py b/lib/matplotlib/tests/test_widgets.py\nindex 39c625e..f99bade 100644\n--- a/lib/matplotlib/tests/test_widgets.py\n+++ b/lib/matplotlib/tests/test_widgets.py\n@@ -1119,6 +1119,20 @@ def test_range_slider(orientation):\n     slider.reset()\n     assert_allclose(slider.val, [0.1, 0.34])\n \n+def test_range_slider_initial_values():\n+    fig, ax = plt.subplots()\n+    valinit = [0.0, 0.0]\n+    slider = widgets.RangeSlider(ax=ax, label=\"\", valmin=-1.0, valmax=1.0, valinit=valinit)\n+    \n+    # Check initial value\n+    assert_allclose(slider.val, valinit)\n+\n+    slider.set_val((0.5, 0.8))\n+    assert_allclose(slider.val, (0.5, 0.8))\n+\n+    slider.reset()\n+    assert_allclose(slider.val, valinit)\n+\n \n def check_polygon_selector(event_sequence, expected_result, selections_count,\n                            **kwargs):\n",
  "matplotlib__matplotlib-23299": "",
  "matplotlib__matplotlib-23314": "diff --git a/lib/mpl_toolkits/tests/test_mplot3d.py b/lib/mpl_toolkits/tests/test_mplot3d.py\nindex 44c19e7..a609fab 100644\n--- a/lib/mpl_toolkits/tests/test_mplot3d.py\n+++ b/lib/mpl_toolkits/tests/test_mplot3d.py\n@@ -20,8 +20,21 @@ import numpy as np\n mpl3d_image_comparison = functools.partial(\n     image_comparison, remove_text=True, style='default')\n \n-\n-def test_aspect_equal_error():\n+@check_figures_equal(extensions=[\"png\"])\n+def test_3d_axes_set_visible_false(fig_test, fig_ref):\n+    ax_test = fig_test.add_subplot(121, projection='3d')\n+    ax_ref = fig_ref.add_subplot(121, projection='3d')\n+    ax_test.scatter(1, 1, 1)\n+    ax_ref.scatter(1, 1, 1)\n+    ax_test.set_visible(False)\n+\n+    ax_test2 = fig_test.add_subplot(122, projection='3d')\n+    ax_ref2 = fig_ref.add_subplot(122, projection='3d')\n+    ax_test2.scatter(2, 2, 2, c='r')\n+    ax_ref2.scatter(2, 2, 2, c='r')\n+\n+    # In fig_test, the first subplot should be invisible, but not in fig_ref\n+    ax_ref.set_visible(True)  # Ensure ax_ref remains visible for comparison\n     fig = plt.figure()\n     ax = fig.add_subplot(projection='3d')\n     with pytest.raises(NotImplementedError):\n",
  "matplotlib__matplotlib-23562": "",
  "matplotlib__matplotlib-23563": "",
  "matplotlib__matplotlib-23913": "diff --git a/lib/matplotlib/tests/test_legend.py b/lib/matplotlib/tests/test_legend.py\nindex f4787c8..a1ffdcc 100644\n--- a/lib/matplotlib/tests/test_legend.py\n+++ b/lib/matplotlib/tests/test_legend.py\n@@ -774,7 +774,26 @@ def test_legend_labelcolor_rcparam_markerfacecolor_short():\n         assert mpl.colors.same_color(text.get_color(), color)\n \n \n-def test_get_set_draggable():\n+@pytest.mark.parametrize('draggable', [True, False])\n+def test_legend_draggable(draggable):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='test_label')\n+    legend = ax.legend(draggable=draggable)\n+    assert legend.get_draggable() is draggable\n+\n+def test_legend_default_not_draggable():\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='test_label')\n+    legend = ax.legend()\n+    assert not legend.get_draggable()\n+\n+@pytest.mark.parametrize('loc', ['upper right', 'lower left'])\n+def test_legend_location_and_draggable(loc):\n+    fig, ax = plt.subplots()\n+    ax.plot(range(10), label='test_label')\n+    legend = ax.legend(loc=loc, draggable=True)\n+    assert legend.get_draggable()\n+    assert legend._loc == loc\n     legend = plt.legend()\n     assert not legend.get_draggable()\n     legend.set_draggable(True)\n",
  "matplotlib__matplotlib-23964": "diff --git a/lib/matplotlib/tests/test_backend_ps.py b/lib/matplotlib/tests/test_backend_ps.py\nindex a1caf1a..7739c06 100644\n--- a/lib/matplotlib/tests/test_backend_ps.py\n+++ b/lib/matplotlib/tests/test_backend_ps.py\n@@ -246,14 +246,31 @@ def test_fonttype(fonttype):\n \n def test_linedash():\n     \"\"\"Test that dashed lines do not break PS output\"\"\"\n-    fig, ax = plt.subplots()\n-\n-    ax.plot([0, 1], linestyle=\"--\")\n-\n-    buf = io.BytesIO()\n-    fig.savefig(buf, format=\"ps\")\n+import io\n+from matplotlib.figure import Figure\n \n-    assert buf.tell() > 0\n+def test_multiline_text_label_with_empty_line():\n+    # Test saving a figure with a multi-line text label with empty lines\n+    figure = Figure()\n+    ax = figure.add_subplot(111)\n+    ax.annotate(text='\\nFirst Line\\n\\nThird Line', xy=(0, 0))\n+    buf_eps = io.BytesIO()\n+    buf_ps = io.BytesIO()\n+    figure.savefig(buf_eps, format='eps')\n+    figure.savefig(buf_ps, format='ps')\n+    assert buf_eps.tell() > 0\n+    assert buf_ps.tell() > 0\n+\n+def test_empty_line():\n+    # Smoke-test for gh#23954\n+    figure = Figure()\n+    figure.text(0.5, 0.5, \"\\nfoo\\n\\n\")\n+    buf_eps = io.BytesIO()\n+    buf_ps = io.BytesIO()\n+    figure.savefig(buf_eps, format='eps')\n+    figure.savefig(buf_ps, format='ps')\n+    assert buf_eps.tell() > 0\n+    assert buf_ps.tell() > 0\n \n \n def test_no_duplicate_definition():\n",
  "matplotlib__matplotlib-23987": "diff --git a/lib/matplotlib/tests/test_constrainedlayout.py b/lib/matplotlib/tests/test_constrainedlayout.py\nindex 41fdfa1..30e10bc 100644\n--- a/lib/matplotlib/tests/test_constrainedlayout.py\n+++ b/lib/matplotlib/tests/test_constrainedlayout.py\n@@ -655,4 +655,32 @@ def test_compressed1():\n     np.testing.assert_allclose(pos.y1, 0.8537, atol=1e-3)\n     pos = axs[1, 2].get_position()\n     np.testing.assert_allclose(pos.x1, 0.8618, atol=1e-3)\n-    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n+    np.testing.assert_allclose(pos.y0, 0.1934, atol=1e-3)\n+\n+import pytest\n+import numpy as np\n+import matplotlib.pyplot as plt\n+from matplotlib.testing.decorators import check_figures_equal\n+\n+@pytest.mark.parametrize('constrained_layout', [True, False])\n+def test_constrained_layout_warning(constrained_layout, recwarn):\n+    import matplotlib.pyplot as plt\n+    import numpy as np\n+    \n+    a = np.linspace(0, 2*np.pi, 100)\n+    b = np.sin(a)\n+    c = np.cos(a)\n+    \n+    fig, ax = plt.subplots(1, 2, figsize=(8, 2), constrained_layout=constrained_layout)\n+    ax[0].plot(a, b)\n+    ax[1].plot(a, c)\n+    plt.subplots_adjust(wspace=0)\n+    \n+    # Check for any UserWarnings raised during the process\n+    warnings = [warn for warn in recwarn if issubclass(warn.category, UserWarning)]\n+    \n+    # If constrained_layout is False, assert no warning is present\n+    if not constrained_layout:\n+        assert not warnings, f\"Warning was raised: {warnings}\"\n+    else:\n+        assert warnings, \"Expected a warning when constrained_layout=True\"\n",
  "matplotlib__matplotlib-24149": "",
  "matplotlib__matplotlib-24334": "",
  "matplotlib__matplotlib-24970": "diff --git a/lib/matplotlib/tests/test_colors.py b/lib/matplotlib/tests/test_colors.py\nindex 2be14fe..9f42e95 100644\n--- a/lib/matplotlib/tests/test_colors.py\n+++ b/lib/matplotlib/tests/test_colors.py\n@@ -30,7 +30,20 @@ def test_create_lookup_table(N, result):\n     assert_array_almost_equal(mcolors._create_lookup_table(N, data), result)\n \n \n-def test_resampled():\n+import pytest\n+import numpy as np\n+import matplotlib.pyplot as plt\n+import matplotlib as mpl\n+from numpy.testing import assert_array_equal, assert_raises\n+\n+@pytest.mark.parametrize(\"dtype\", [np.uint8, int, np.float16, float])\n+def test_no_deprecation_warnings(dtype):\n+    # This test checks that using colormaps with different dtypes does not produce deprecation warnings\n+    with pytest.warns(None) as record:\n+        cmap = mpl.colormaps[\"viridis\"]\n+        result = cmap(dtype(0))\n+    # Ensure that no warnings of any kind are raised\n+    assert len(record) == 0\n     \"\"\"\n     GitHub issue #6025 pointed to incorrect ListedColormap.resampled;\n     here we test the method for LinearSegmentedColormap as well.\n",
  "matplotlib__matplotlib-25311": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..73b8079 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -1,3 +1,4 @@\n+\n from io import BytesIO\n import ast\n import pickle\n@@ -89,8 +90,33 @@ def _generate_complete_test_figure(fig_ref):\n     plt.subplot(3, 3, 9)\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n+import pickletools\n \n @mpl.style.context(\"default\")\n+\n+def test_pickle_draggable_legend():\n+    \"\"\"Test pickling a figure with draggable legend.\"\"\"\n+    fig = plt.figure()\n+    ax = fig.add_subplot(111)\n+    \n+    time = [0, 1, 2, 3, 4]\n+    speed = [40, 43, 45, 47, 48]\n+\n+    ax.plot(time, speed, label=\"speed\")\n+    leg = ax.legend()\n+    leg.set_draggable(True)\n+\n+    # Capture the pickle dump for analysis\n+    pkl = pickle.dumps(fig, pickle.HIGHEST_PROTOCOL)\n+\n+    # Ensure the pickled data stream does not contain any FigureCanvasQTAgg or similar\n+    assert \"FigureCanvasQTAgg\" not in [arg for op, arg, pos in pickletools.genops(pkl)]\n+\n+    # Load the figure from pickle to ensure it can be unpickled\n+    loaded_fig = pickle.loads(pkl)\n+\n+    # Show the loaded figure for verification in interactive scenarios\n+    loaded_fig.show()\n @check_figures_equal(extensions=[\"png\"])\n def test_complete(fig_test, fig_ref):\n     _generate_complete_test_figure(fig_ref)\n",
  "matplotlib__matplotlib-25332": "diff --git a/lib/matplotlib/tests/test_pickle.py b/lib/matplotlib/tests/test_pickle.py\nindex 48d72e7..3b1b221 100644\n--- a/lib/matplotlib/tests/test_pickle.py\n+++ b/lib/matplotlib/tests/test_pickle.py\n@@ -90,9 +90,38 @@ def _generate_complete_test_figure(fig_ref):\n     plt.errorbar(x, x * -0.5, xerr=0.2, yerr=0.4)\n \n \n-@mpl.style.context(\"default\")\n-@check_figures_equal(extensions=[\"png\"])\n-def test_complete(fig_test, fig_ref):\n+import matplotlib.pyplot as plt\n+import pickle\n+import pytest\n+\n+def test_pickle_figure_with_aligned_labels():\n+    # Create a figure and add subplots\n+    fig = plt.figure()\n+    ax1 = fig.add_subplot(211)\n+    ax2 = fig.add_subplot(212)\n+    \n+    # Sample data\n+    time = [0, 1, 2, 3, 4]\n+    speed = [40000, 4300, 4500, 4700, 4800]\n+    acc = [10, 11, 12, 13, 14]\n+    \n+    # Plot data\n+    ax1.plot(time, speed)\n+    ax1.set_ylabel('speed')\n+    ax2.plot(time, acc)\n+    ax2.set_ylabel('acc')\n+    \n+    # Align labels\n+    fig.align_labels()\n+    \n+    # Try to pickle the figure\n+    try:\n+        pickle.dumps(fig)\n+        pickling_successful = True\n+    except Exception as e:\n+        pickling_successful = False\n+    \n+    assert pickling_successful, \"Pickling failed after aligning labels\"\n     _generate_complete_test_figure(fig_ref)\n     # plotting is done, now test its pickle-ability\n     pkl = BytesIO()\n",
  "matplotlib__matplotlib-25442": "",
  "matplotlib__matplotlib-26011": "",
  "matplotlib__matplotlib-26020": "",
  "mwaskom__seaborn-3010": "diff --git a/tests/_stats/test_regression.py b/tests/_stats/test_regression.py\nindex 9aa3203..c54095b 100644\n--- a/tests/_stats/test_regression.py\n+++ b/tests/_stats/test_regression.py\n@@ -1,4 +1,5 @@\n \n+\n import numpy as np\n import pandas as pd\n \n@@ -8,8 +9,49 @@ from numpy.testing import assert_array_equal, assert_array_almost_equal\n from seaborn._core.groupby import GroupBy\n from seaborn._stats.regression import PolyFit\n \n+from pandas.testing import assert_frame_equal\n \n class TestPolyFit:\n+    \n+    def test_missing_data_handling(self, df):\n+        # Introducing None values into the dataframe\n+        df.loc[5:10, \"x\"] = None\n+        \n+        groupby = GroupBy([\"group\"])\n+        \n+        # Compute results with and without dropping missing data\n+        res_with_missing = PolyFit()(df[[\"x\", \"y\"]], groupby, \"x\", {})\n+        res_without_missing = PolyFit()(df[[\"x\", \"y\"]].dropna(), groupby, \"x\", {})\n+        \n+        # Check if both results are the same, indicating the handling of missing data\n+        assert_frame_equal(res_with_missing, res_without_missing, check_dtype=False)\n+        \n+    def test_no_data_after_nan_removed(self, df):\n+        # Make entire x column None to simulate no fit scenario\n+        df[\"x\"] = None\n+        \n+        groupby = GroupBy([\"group\"])\n+        \n+        # Compute results \n+        res = PolyFit()(df[[\"x\", \"y\"]], groupby, \"x\", {})\n+        \n+        # Resulting DataFrame should be empty due to no data for polyfit\n+        assert res.empty\n+    \n+    def test_partial_nan_data(self, df):\n+        # Introduce NaNs in slices\n+        df.iloc[20:30, 0] = None\n+\n+        groupby = GroupBy([\"group\"])\n+        \n+        # Result with partial reasonable data\n+        res_partial = PolyFit()(df[[\"x\", \"y\"]], groupby, \"x\", {})\n+        assert not res_partial.empty\n+        \n+        # Verify length of result to determine handling of NaNs\n+        n_groups = df[\"group\"].nunique()\n+        expected_length = n_groups * PolyFit().gridsize\n+        assert len(res_partial) <= expected_length\n \n     @pytest.fixture\n     def df(self, rng):\n",
  "mwaskom__seaborn-3190": "",
  "mwaskom__seaborn-3407": "diff --git a/tests/test_axisgrid.py b/tests/test_axisgrid.py\nindex b2e4a92..f78388e 100644\n--- a/tests/test_axisgrid.py\n+++ b/tests/test_axisgrid.py\n@@ -758,8 +758,21 @@ class TestPairGrid:\n         assert g.x_vars == list(vars)\n         assert g.y_vars == list(vars)\n         assert g.square_grid\n-\n-    def test_remove_hue_from_default(self):\n+    \n+    def test_pairplot_column_multiindex(self):\n+        # Set up a DataFrame with MultiIndex columns\n+        columns = pd.MultiIndex.from_product([[\"A\", \"B\"], [\"1\", \"2\"]])\n+        df = pd.DataFrame(np.random.rand(100, 4), columns=columns)\n+\n+        # Test the pairplot function with this DataFrame\n+        g = ag.pairplot(df)\n+        \n+        # Check the PairGrid object\n+        assert isinstance(g, ag.PairGrid)\n+        # Ensure that the g.diag_vars is set correctly\n+        assert g.diag_vars == list(columns)\n+        # Check that axes were created\n+        assert len(g.axes) == 4\n \n         hue = \"z\"\n         g = ag.PairGrid(self.df, hue=hue)\n",
  "pallets__flask-4992": "diff --git a/tests/test_config.py b/tests/test_config.py\nindex 179b09c..c5a01cd 100644\n--- a/tests/test_config.py\n+++ b/tests/test_config.py\n@@ -1,4 +1,6 @@\n+\n import json\n+import tomllib\n import os\n import textwrap\n \n",
  "psf__requests-1963": "",
  "psf__requests-2317": "",
  "psf__requests-2674": "diff --git a/requests/test_requests.py b/requests/test_requests.py\nindex 31fe034..64f769c 100644\n--- a/requests/test_requests.py\n+++ b/requests/test_requests.py\n@@ -1655,7 +1655,34 @@ def test_urllib3_retries():\n     with pytest.raises(RetryError):\n         s.get(httpbin('status/500'))\n \n-def test_vendor_aliases():\n+from requests.exceptions import DecodeError as RequestsDecodeError, Timeout as RequestsTimeoutError\n+from requests.packages.urllib3.exceptions import DecodeError as Urllib3DecodeError, TimeoutError as Urllib3TimeoutError\n+\n+def test_urllib3_exceptions_wrapped():\n+    import requests\n+    from requests.adapters import HTTPAdapter\n+    from requests.exceptions import Timeout\n+    \n+    # Mock a session and override the send method to raise DecodeError\n+    class MockAdapter(HTTPAdapter):\n+        def send(self, request, **kwargs):\n+            raise Urllib3DecodeError(\"Decoding failed\")\n+\n+    s = requests.Session()\n+    s.mount('http://', MockAdapter())\n+\n+    with pytest.raises(RequestsDecodeError):\n+        s.get('http://example.com')\n+\n+    # Mock a session and override the send method to raise TimeoutError\n+    class MockTimeoutAdapter(HTTPAdapter):\n+        def send(self, request, **kwargs):\n+            raise Urllib3TimeoutError(\"Fake timeout\")\n+\n+    s.mount('http://', MockTimeoutAdapter())\n+\n+    with pytest.raises(RequestsTimeoutError):\n+        s.get('http://example.com')\n     from requests.packages import urllib3\n     from requests.packages import chardet\n \n@@ -1663,4 +1690,4 @@ def test_vendor_aliases():\n         from requests.packages import webbrowser\n \n if __name__ == '__main__':\n-    unittest.main()\n+    unittest.main()\n",
  "psf__requests-3362": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 52d1693..49abf13 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -980,7 +980,41 @@ class TestRequests:\n         chunks = r.iter_content(decode_unicode=True)\n         assert all(isinstance(chunk, str) for chunk in chunks)\n \n-    def test_response_chunk_size_int(self):\n+    def test_response_iter_content_decode_unicode(self):\n+        \"\"\"\n+        Test iter_content with decode_unicode=True should return unicode chunks\n+        when response encoding is set, and byte chunks when decode_unicode=False.\n+        \"\"\"\n+        # Scenario 1: decode_unicode=True with encoding set\n+        r = requests.Response()\n+        r._content_consumed = True\n+        r._content = b'the content'\n+        r.encoding = 'utf-8'\n+        chunks = r.iter_content(decode_unicode=True)\n+        assert all(isinstance(chunk, str) for chunk in chunks), \"Expected unicode chunks\"\n+\n+        # Scenario 2: decode_unicode=False with encoding set\n+        r = requests.Response()\n+        r._content_consumed = True\n+        r._content = b'the content'\n+        r.encoding = 'utf-8'\n+        chunks = r.iter_content(decode_unicode=False)\n+        assert all(isinstance(chunk, bytes) for chunk in chunks), \"Expected byte chunks\"\n+        \n+        # Scenario 3: decode_unicode=True with no encoding\n+        r = requests.Response()\n+        r._content_consumed = True\n+        r._content = b'the content'\n+        r.encoding = None\n+        chunks = r.iter_content(decode_unicode=True)\n+        assert all(isinstance(chunk, bytes) for chunk in chunks), \"Expected byte chunks when encoding is None\"\n+\n+        # Comparison to r.text\n+        r = requests.Response()\n+        r._content_consumed = False\n+        r._content = b'the content'\n+        r.encoding = 'utf-8'\n+        assert isinstance(r.text, str), \"Expected r.text to be a unicode string\"\n         \"\"\"Ensure that chunk_size is passed as an integer, otherwise\n         raise a TypeError.\n         \"\"\"\n",
  "psf__requests-863": "diff --git a/tests/test_requests.py b/tests/test_requests.py\nindex 0ee4333..41bbb85 100644\n--- a/tests/test_requests.py\n+++ b/tests/test_requests.py\n@@ -743,8 +743,51 @@ class RequestsTestSuite(TestSetup, TestBaseMixin, unittest.TestCase):\n \n             assert 'foo' in response.text\n             assert 'bar' in response.text\n+    def test_hooks_with_single_function(self):\n+        \"\"\"Test hooks argument with a single function to ensure backward compatibility.\"\"\"\n+        def add_baz_header(args):\n+            if not args.get('headers'):\n+                args['headers'] = {}\n+            args['headers'].update({\n+                'X-Baz': 'baz'\n+            })\n+            return args\n+\n+        def assert_hooks_are_callable(hooks):\n+            for h in hooks['args']:\n+                assert callable(h) is True\n+\n+        hooks = add_baz_header\n+\n+        r = requests.models.Request()\n+        r.register_hook('args', hooks)\n+        assert_hooks_are_callable(r.hooks)\n+\n+        r = requests.models.Request(hooks={'args': [hooks]})\n+        assert_hooks_are_callable(r.hooks)\n+\n+    def test_multiple_hooks_invocation(self):\n+        \"\"\"Test proper invocation order of multiple hooks within the Request.\"\"\"\n+\n+        order = []\n+\n+        def hook_one(args):\n+            order.append('hook_one')\n+            return args\n+\n+        def hook_two(args):\n+            order.append('hook_two')\n+            return args\n+\n+        hooks = [hook_one, hook_two]\n+        \n+        request = requests.models.Request(hooks={'args': hooks})\n \n-    def test_session_persistent_cookies(self):\n+        args = {}\n+        for hook in request.hooks['args']:\n+            args = hook(args)\n+        \n+        assert order == ['hook_one', 'hook_two'], f\"Hooks were not invoked in the expected order. Invoked order: {order}\"\n \n         s = requests.session()\n \n",
  "pydata__xarray-5131": "diff --git a/xarray/tests/test_groupby.py b/xarray/tests/test_groupby.py\nindex 3852c09..79d8435 100644\n--- a/xarray/tests/test_groupby.py\n+++ b/xarray/tests/test_groupby.py\n@@ -411,7 +411,18 @@ def test_groupby_repr_datetime(obj):\n     assert actual == expected\n \n \n-def test_groupby_drops_nans():\n+def test_no_trailing_whitespace_on_groupby_repr():\n+    import xarray as xr\n+    import numpy as np\n+\n+    ds = xr.Dataset(\n+        {\"foo\": ((\"x\", \"y\"), np.random.rand(4, 3))},\n+        coords={\"x\": [10, 20, 30, 40], \"letters\": (\"x\", list(\"abba\"))},\n+    )\n+    groupby_str = str(ds.groupby(\"letters\"))\n+    # Ensure no trailing spaces after the line \"DatasetGroupBy, grouped over 'letters'\"\n+    assert groupby_str.startswith(\"DatasetGroupBy, grouped over 'letters'\")\n+    assert not groupby_str.startswith(\"DatasetGroupBy, grouped over 'letters' \\n\")\n     # GH2383\n     # nan in 2D data variable (requires stacking)\n     ds = xr.Dataset(\n",
  "pylint-dev__pylint-5859": "diff --git a/tests/checkers/unittest_misc.py b/tests/checkers/unittest_misc.py\nindex 460d485..5cfb070 100644\n--- a/tests/checkers/unittest_misc.py\n+++ b/tests/checkers/unittest_misc.py\n@@ -88,8 +88,16 @@ class TestFixme(CheckerTestCase):\n             MessageTest(msg_id=\"fixme\", line=2, args=\"CODETAG\", col_offset=17)\n         ):\n             self.checker.process_tokens(_tokenize_str(code))\n-\n-    def test_issue_2321_should_not_trigger(self) -> None:\n+    \n+    @set_config(notes=[\"???\"])\n+    def test_punctuation_only_notes(self) -> None:\n+        code = \"\"\"a = 1\n+                # ???\n+                \"\"\"\n+        with self.assertAddsMessages(\n+            MessageTest(msg_id=\"fixme\", line=2, args=\"???\", col_offset=17)\n+        ):\n+            self.checker.process_tokens(_tokenize_str(code))\n         code = 'print(\"# TODO this should not trigger a fixme\")'\n         with self.assertNoMessages():\n             self.checker.process_tokens(_tokenize_str(code))\n@@ -119,4 +127,4 @@ class TestFixme(CheckerTestCase):\n         # Todoist API: Fetch all Tasks\n         \"\"\"\n         with self.assertNoMessages():\n-            self.checker.process_tokens(_tokenize_str(code))\n+            self.checker.process_tokens(_tokenize_str(code))\n",
  "pylint-dev__pylint-6506": "diff --git a/tests/config/test_config.py b/tests/config/test_config.py\nindex 35849b5..d34c327 100644\n--- a/tests/config/test_config.py\n+++ b/tests/config/test_config.py\n@@ -56,6 +56,10 @@ reports = \"yes\"\n     check_configuration_file_reader(runner)\n \n \n+import pytest\n+from pylint.lint import Run\n+from pylint.config.exceptions import _UnrecognizedOptionError\n+\n def test_unknown_message_id(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly raise a message on an unknown id.\"\"\"\n     Run([str(EMPTY_MODULE), \"--disable=12345\"], exit=False)\n@@ -71,13 +75,14 @@ def test_unknown_option_name(capsys: CaptureFixture) -> None:\n     assert \"E0015: Unrecognized option found: unknown-option=yes\" in output.out\n \n \n-def test_unknown_short_option_name(capsys: CaptureFixture) -> None:\n-    \"\"\"Check that we correctly raise a message on an unknown short option.\"\"\"\n-    with pytest.raises(_UnrecognizedOptionError):\n+def test_unknown_short_option_behavior(capsys: CaptureFixture) -> None:\n+    \"\"\"Check that no traceback is printed on an unknown short option.\"\"\"\n+    with pytest.raises(SystemExit):\n         Run([str(EMPTY_MODULE), \"-Q\"], exit=False)\n     output = capsys.readouterr()\n     assert \"E0015: Unrecognized option found: Q\" in output.out\n-\n+    assert \"Traceback\" not in output.err\n+    assert \"usage: pylint\" in output.err\n \n def test_unknown_confidence(capsys: CaptureFixture) -> None:\n     \"\"\"Check that we correctly error an unknown confidence value.\"\"\"\n",
  "pylint-dev__pylint-7080": "diff --git a/tests/test_self.py b/tests/test_self.py\nindex fa7078d..a9d1419 100644\n--- a/tests/test_self.py\n+++ b/tests/test_self.py\n@@ -1324,12 +1324,31 @@ class TestRunTC:\n                 if not os.path.basename(path) == \"regrtest_data\"\n             ]\n             with _test_cwd():\n-                os.chdir(join(HERE, \"regrtest_data\", \"directory\", \"subdirectory\"))\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n                 self._runtest(\n-                    [\".\", \"--recursive=y\"],\n+                    [\".\", \"--recursive=y\", \"--ignore-paths=^ignored_subdirectory/.*\"],\n                     code=0,\n                 )\n \n+    def test_ignore_path_recursive(self) -> None:\n+        \"\"\"Test that pylint respects ignore-paths with recursive scan.\"\"\"\n+        with _test_sys_path():\n+            sys.path = [\n+                path\n+                for path in sys.path\n+                if not os.path.basename(path) == \"regrtest_data\"\n+            ]\n+            with _test_cwd():\n+                os.chdir(join(HERE, \"regrtest_data\", \"directory\"))\n+                self._runtest(\n+                    [\n+                        \".\",\n+                        \"--recursive=y\",\n+                        \"--ignore-paths=^ignored_subdirectory/.*\",\n+                    ],\n+                    code=0,  # Expect no issues because the directory is ignored\n+                )\n+\n     def test_regression_recursive_current_dir(self):\n         with _test_sys_path():\n             # pytest is including directory HERE/regrtest_data to sys.path which causes\n",
  "pylint-dev__pylint-7114": "",
  "pylint-dev__pylint-7993": "diff --git a/tests/reporters/unittest_reporting.py b/tests/reporters/unittest_reporting.py\nindex 6338072..91269bf 100644\n--- a/tests/reporters/unittest_reporting.py\n+++ b/tests/reporters/unittest_reporting.py\n@@ -1,3 +1,4 @@\n+\n # Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html\n # For details: https://github.com/PyCQA/pylint/blob/main/LICENSE\n # Copyright (c) https://github.com/PyCQA/pylint/blob/main/CONTRIBUTORS.txt\n@@ -113,7 +114,19 @@ def test_template_option_non_existing(linter) -> None:\n     assert out_lines[2] == \"my_mod:2::()\"\n \n \n-def test_deprecation_set_output(recwarn):\n+def test_template_option_with_custom_braces(linter: PyLinter) -> None:\n+    output = StringIO()\n+    linter.reporter.out = output\n+    linter.config.msg_template = '{{ \"Category\": \"{category}\" }}'\n+    linter.open()\n+    linter.set_current_module(\"test_module\")\n+\n+    linter.add_message(\"C0301\", line=1, args=(1,))\n+    linter.add_message(\"E0001\", line=2, args=(2,))\n+\n+    out_lines = output.getvalue().split(\"\\n\")\n+    assert out_lines[1] == '{ \"Category\": \"convention\" }'\n+    assert out_lines[2] == '{ \"Category\": \"error\" }'\n     \"\"\"TODO remove in 3.0.\"\"\"\n     reporter = BaseReporter()\n     # noinspection PyDeprecation\n",
  "pytest-dev__pytest-11143": "",
  "pytest-dev__pytest-11148": "diff --git a/testing/test_pathlib.py b/testing/test_pathlib.py\nindex 9989033..33c8ff4 100644\n--- a/testing/test_pathlib.py\n+++ b/testing/test_pathlib.py\n@@ -289,6 +289,31 @@ class TestImportPath:\n         return fn\n \n     def test_importmode_importlib(self, simple_module: Path, tmp_path: Path) -> None:\n+        # Test to verify modules are not imported twice with importlib mode\n+        pytester = pytest.Pytester(tmp_path)\n+        pytester.makepyfile(\n+            **{\n+                \"pmxbot/commands.py\": \"from . import logging\",\n+                \"pmxbot/logging.py\": \"\",\n+                \"tests/__init__.py\": \"\",\n+                \"tests/test_commands.py\": \"\"\"\n+                    import importlib\n+                    from pmxbot import logging\n+\n+                    class TestCommands:\n+                        def test_boo(self):\n+                            assert importlib.import_module('pmxbot.logging') is logging\n+                \"\"\",\n+            }\n+        )\n+        pytester.makeini(\n+            \"\"\"\n+            [pytest]\n+            addopts = --doctest-modules --import-mode importlib\n+            \"\"\"\n+        )\n+        result = pytester.runpytest_subprocess()\n+        result.stdout.fnmatch_lines(\"*1 passed*\")\n         \"\"\"`importlib` mode does not change sys.path.\"\"\"\n         module = import_path(simple_module, mode=\"importlib\", root=tmp_path)\n         assert module.foo(2) == 42  # type: ignore[attr-defined]\n",
  "pytest-dev__pytest-5227": "diff --git a/testing/logging/test_formatter.py b/testing/logging/test_formatter.py\nindex 54a08a2..8302dfe 100644\n--- a/testing/logging/test_formatter.py\n+++ b/testing/logging/test_formatter.py\n@@ -1,3 +1,4 @@\n+\n import logging\n \n import py.io\n@@ -8,6 +9,41 @@ from _pytest.logging import ColoredLevelFormatter\n def test_coloredlogformatter():\n     logfmt = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n \n+    # Test with the original log format\n+    original_logfmt = \"%(filename)-25s %(lineno)4d %(levelname)-8s %(message)s\"\n+    record_original = logging.LogRecord(\n+        name=\"dummy\",\n+        level=logging.INFO,\n+        pathname=\"dummypath\",\n+        lineno=10,\n+        msg=\"Original Test Message\",\n+        args=(),\n+        exc_info=False,\n+    )\n+    formatter_original = ColoredLevelFormatter(tw, original_logfmt)\n+    output_original = formatter_original.format(record_original)\n+    assert output_original == (\n+        \"dummypath                   10 \\x1b[32mINFO    \\x1b[0m Original Test Message\"\n+    )\n+\n+    # Test with the improved log format\n+    improved_logfmt = \"%(levelname)-8s %(name)s:%(filename)s:%(lineno)d %(message)s\"\n+    record_improved = logging.LogRecord(\n+        name=\"dummy.module\",\n+        level=logging.DEBUG,\n+        pathname=\"dummypath\",\n+        lineno=42,\n+        msg=\"Improved Test Message\",\n+        args=(),\n+        exc_info=False,\n+    )\n+    formatter_improved = ColoredLevelFormatter(tw, improved_logfmt)\n+    output_improved = formatter_improved.format(record_improved)\n+    assert output_improved == (\n+        \"DEBUG    dummy.module:dummypath:42 \\x1b[36mImproved Test Message\\x1b[0m\"\n+    )\n+\n+    # Continue with the existing test...\n     record = logging.LogRecord(\n         name=\"dummy\",\n         level=logging.INFO,\n",
  "pytest-dev__pytest-5495": "",
  "pytest-dev__pytest-5692": "diff --git a/testing/test_junitxml.py b/testing/test_junitxml.py\nindex 3392814..3461aac 100644\n--- a/testing/test_junitxml.py\n+++ b/testing/test_junitxml.py\n@@ -1,5 +1,8 @@\n+\n import os\n from xml.dom import minidom\n+import platform\n+from datetime import datetime\n \n import py\n \n@@ -138,8 +141,30 @@ class TestPython:\n         assert result.ret\n         node = dom.find_first_by_tag(\"testsuite\")\n         node.assert_attr(name=\"pytest\", errors=1, failures=2, skipped=1, tests=5)\n+    \n+    def test_hostname_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+            \"\"\"\n+        )\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        node.assert_attr(hostname=platform.node())\n \n-    def test_timing_function(self, testdir):\n+    def test_timestamp_in_xml(self, testdir):\n+        testdir.makepyfile(\n+            \"\"\"\n+            def test_pass():\n+                pass\n+            \"\"\"\n+        )\n+        start_time = datetime.now()\n+        result, dom = runandparse(testdir)\n+        node = dom.find_first_by_tag(\"testsuite\")\n+        timestamp = datetime.strptime(node[\"timestamp\"], \"%Y-%m-%dT%H:%M:%S.%f\")\n+        assert start_time <= timestamp < datetime.now()\n         testdir.makepyfile(\n             \"\"\"\n             import time, pytest\n",
  "pytest-dev__pytest-7168": "diff --git a/testing/io/test_saferepr.py b/testing/io/test_saferepr.py\nindex 38e0b6b..8862856 100644\n--- a/testing/io/test_saferepr.py\n+++ b/testing/io/test_saferepr.py\n@@ -144,6 +144,30 @@ def test_repr_on_newstyle():\n     assert saferepr(Function())\n \n \n+def test_broken_getattribute():\n+    \"\"\"Test that saferepr can create representations of classes with\n+    broken __getattribute__ and __repr__ methods.\n+    \"\"\"\n+    class SomeClass:\n+        def __getattribute__(self, attr):\n+            raise RuntimeError(\"Error in __getattribute__\")\n+\n+        def __repr__(self):\n+            raise RuntimeError(\"Error in __repr__\")\n+\n+    obj = SomeClass()\n+    # Verify saferepr handles exception in __repr__\n+    assert saferepr(obj).startswith(\"<[RuntimeError('Error in __repr__') raised in repr()] SomeClass object at 0x\")\n+\n+    # Test another scenario where __repr__ raises a different exception\n+    class AnotherClass:\n+        def __repr__(self):\n+            raise ValueError(\"ValueError in __repr__\")\n+\n+    another_obj = AnotherClass()\n+    assert saferepr(another_obj).startswith(\"<[ValueError('ValueError in __repr__') raised in repr()] AnotherClass object at 0x\")\n+\n+\n def test_unicode():\n     val = \"\u00a3\u20ac\"\n     reprval = \"'\u00a3\u20ac'\"\n@@ -153,4 +177,4 @@ def test_unicode():\n def test_pformat_dispatch():\n     assert _pformat_dispatch(\"a\") == \"'a'\"\n     assert _pformat_dispatch(\"a\" * 10, width=5) == \"'aaaaaaaaaa'\"\n-    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n+    assert _pformat_dispatch(\"foo bar\", width=5) == \"('foo '\\n 'bar')\"\n",
  "pytest-dev__pytest-7220": "",
  "pytest-dev__pytest-7373": "diff --git a/testing/test_mark.py b/testing/test_mark.py\nindex 309636c..ca4d3ef 100644\n--- a/testing/test_mark.py\n+++ b/testing/test_mark.py\n@@ -41,8 +41,35 @@ class TestMark:\n         with pytest.raises(AttributeError):\n             mark._some_name\n \n+def test_reevaluate_dynamic_expr(self, testdir):\n+    \"\"\"#7360\"\"\"\n+    py_file1 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr1=\"\"\"\n+        import pytest\n+\n+        skip = True\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_skip():\n+            assert False\n+    \"\"\"\n+    )\n+    py_file2 = testdir.makepyfile(\n+        test_reevaluate_dynamic_expr2=\"\"\"\n+        import pytest\n+\n+        skip = False\n+\n+        @pytest.mark.skipif(\"skip\")\n+        def test_should_not_skip():\n+            assert True\n+    \"\"\"\n+    )\n \n-def test_marked_class_run_twice(testdir):\n+    file_name1 = os.path.basename(py_file1.strpath)\n+    file_name2 = os.path.basename(py_file2.strpath)\n+    reprec = testdir.inline_run(file_name1, file_name2)\n+    reprec.assertoutcome(passed=1, skipped=1)\n     \"\"\"Test fails file is run twice that contains marked class.\n     See issue#683.\n     \"\"\"\n",
  "pytest-dev__pytest-7432": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 73a7f38..37c6b86 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -219,6 +219,31 @@ class TestXFail:\n         assert str(callreport.longrepr) == \"[XPASS(strict)] nope\"\n         assert not hasattr(callreport, \"wasxfail\")\n \n+    @pytest.mark.parametrize(\n+        \"test_input, expected\",\n+        [\n+            (\n+                [\"-rs\"],\n+                [\"SKIPPED [1] test_sample.py:3: unconditional skip\", \"*1 skipped*\"],\n+            ),\n+            (\n+                [\"-rs\", \"--runxfail\"],\n+                [\"SKIPPED [1] test_sample.py:3: unconditional skip\", \"*1 skipped*\"],\n+            ),\n+        ],\n+    )\n+    def test_skip_location_reporting(self, testdir, test_input, expected):\n+        testdir.makepyfile(\n+            test_sample=\"\"\"\n+            import pytest\n+            @pytest.mark.skip\n+            def test_skip_location() -> None:\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(*test_input)\n+        result.stdout.fnmatch_lines(expected)\n+\n     def test_xfail_run_anyway(self, testdir):\n         testdir.makepyfile(\n             \"\"\"\n",
  "pytest-dev__pytest-7490": "diff --git a/testing/test_skipping.py b/testing/test_skipping.py\nindex 50a5826..f191820 100644\n--- a/testing/test_skipping.py\n+++ b/testing/test_skipping.py\n@@ -1,3 +1,4 @@\n+\n import sys\n \n import pytest\n@@ -397,7 +398,30 @@ class TestXFail:\n         result = testdir.runpytest(p, \"-rxX\")\n         result.stdout.fnmatch_lines([\"*XFAIL*test_this*\", \"*XPASS*test_that*\"])\n \n-    def test_dynamic_xfail_no_run(self, testdir):\n+    def test_dynamic_xfail_set_during_runtest_failed(self, testdir: Testdir) -> None:\n+        # This test case checks if dynamically adding an xfail during runtest correctly marks the test as xfailed\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\"))\n+                assert 0\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(xfailed=1)\n+        \n+    def test_dynamic_xfail_set_during_runtest_passed_strict(self, testdir: Testdir) -> None:\n+        # This test case checks if a dynamically added strict xfail during runtest correctly fails when it passes\n+        p = testdir.makepyfile(\n+            \"\"\"\n+            import pytest\n+            def test_this(request):\n+                request.node.add_marker(pytest.mark.xfail(reason=\"xfail\", strict=True))\n+            \"\"\"\n+        )\n+        result = testdir.runpytest(p)\n+        result.assert_outcomes(failed=1)\n         p = testdir.makepyfile(\n             \"\"\"\n             import pytest\n",
  "pytest-dev__pytest-8365": "diff --git a/testing/test_tmpdir.py b/testing/test_tmpdir.py\nindex 6a7e0bd..3c50982 100644\n--- a/testing/test_tmpdir.py\n+++ b/testing/test_tmpdir.py\n@@ -1,5 +1,8 @@\n+\n import os\n import stat\n+from _pytest.monkeypatch import MonkeyPatch\n+from _pytest.tmpdir import TempPathFactory\n import sys\n from pathlib import Path\n from typing import Callable\n",
  "scikit-learn__scikit-learn-10297": "diff --git a/sklearn/linear_model/tests/test_ridge.py b/sklearn/linear_model/tests/test_ridge.py\nindex a48e744..fb08072 100644\n--- a/sklearn/linear_model/tests/test_ridge.py\n+++ b/sklearn/linear_model/tests/test_ridge.py\n@@ -562,6 +562,26 @@ def test_class_weights_cv():\n     # Test class weights for cross validated ridge classifier.\n     X = np.array([[-1.0, -1.0], [-1.0, 0], [-.8, -1.0],\n                   [1.0, 1.0], [1.0, 0.0]])\n+\n+def test_ridge_classifier_cv_store_cv_values():\n+    # Test RidgeClassifierCV's store_cv_values attribute\n+    x = np.array([[-1.0, -1.0], [-1.0, 0], [-0.8, -1.0],\n+                  [1.0, 1.0], [1.0, 0.0]])\n+    y = np.array([1, 1, 1, -1, -1])\n+\n+    alphas = [0.1, 1.0, 10.0]\n+    r = RidgeClassifierCV(alphas=alphas, store_cv_values=True)\n+\n+    # Single target case\n+    r.fit(x, y)\n+    assert r.cv_values_.shape == (x.shape[0], 1, len(alphas))\n+\n+    # Multi-target case\n+    y_multi = np.array([[1, 1, 1, -1, -1],\n+                        [1, -1, 1, -1, 1],\n+                        [-1, -1, 1, -1, -1]]).T\n+    r.fit(x, y_multi)\n+    assert r.cv_values_.shape == (x.shape[0], y_multi.shape[1], len(alphas))\n     y = [1, 1, 1, -1, -1]\n \n     reg = RidgeClassifierCV(class_weight=None, alphas=[.01, .1, 1])\n",
  "scikit-learn__scikit-learn-11281": "diff --git a/sklearn/mixture/tests/test_bayesian_mixture.py b/sklearn/mixture/tests/test_bayesian_mixture.py\nindex a9d82b7..07a89a4 100644\n--- a/sklearn/mixture/tests/test_bayesian_mixture.py\n+++ b/sklearn/mixture/tests/test_bayesian_mixture.py\n@@ -5,7 +5,9 @@\n import numpy as np\n from scipy.special import gammaln\n \n-from sklearn.utils.testing import assert_raise_message\n+from sklearn.utils.testing import assert_raise_message, assert_greater\n+from sklearn.metrics.cluster import adjusted_rand_score\n+import numpy as np\n from sklearn.utils.testing import assert_almost_equal\n \n from sklearn.mixture.bayesian_mixture import _log_dirichlet_norm\n@@ -21,8 +23,38 @@ from sklearn.utils.testing import assert_greater_equal, ignore_warnings\n COVARIANCE_TYPE = ['full', 'tied', 'diag', 'spherical']\n PRIOR_TYPE = ['dirichlet_process', 'dirichlet_distribution']\n \n+def test_bayesian_mixture_fit_predict():\n+    rng = np.random.RandomState(0)\n+    rand_data = RandomData(rng, scale=7)\n+    n_components = 2 * rand_data.n_components\n+\n+    for covar_type in COVARIANCE_TYPE:\n+        bgmm1 = BayesianGaussianMixture(n_components=n_components,\n+                                        max_iter=100, random_state=rng,\n+                                        tol=1e-3, reg_covar=0)\n+        bgmm1.covariance_type = covar_type\n+        bgmm2 = copy.deepcopy(bgmm1)\n+        X = rand_data.X[covar_type]\n+\n+        Y_pred1 = bgmm1.fit(X).predict(X)\n+        Y_pred2 = bgmm2.fit_predict(X)\n+        assert_array_equal(Y_pred1, Y_pred2)\n+\n+def test_bayesian_mixture_labels_attribute():\n+    rng = np.random.RandomState(0)\n+    rand_data = RandomData(rng, scale=7)\n+    n_components = 2 * rand_data.n_components\n+\n+    for covar_type in COVARIANCE_TYPE:\n+        bgmm = BayesianGaussianMixture(n_components=n_components,\n+                                       max_iter=100, random_state=rng,\n+                                       tol=1e-3, reg_covar=0)\n+        X = rand_data.X[covar_type]\n \n-def test_log_dirichlet_norm():\n+        bgmm.fit(X)\n+        assert hasattr(bgmm, 'labels_'), \"Model should have 'labels_' attribute\"\n+        Y_pred = bgmm.predict(X)\n+        assert_array_equal(bgmm.labels_, Y_pred)\n     rng = np.random.RandomState(0)\n \n     weight_concentration = rng.rand(2)\n",
  "scikit-learn__scikit-learn-12471": "",
  "scikit-learn__scikit-learn-13142": "diff --git a/sklearn/mixture/tests/test_gaussian_mixture.py b/sklearn/mixture/tests/test_gaussian_mixture.py\nindex f8e4d54..cfb78d1 100644\n--- a/sklearn/mixture/tests/test_gaussian_mixture.py\n+++ b/sklearn/mixture/tests/test_gaussian_mixture.py\n@@ -597,6 +597,15 @@ def test_gaussian_mixture_fit_predict(seed, max_iter, tol):\n         assert_array_equal(Y_pred1, Y_pred2)\n         assert_greater(adjusted_rand_score(Y, Y_pred2), .95)\n \n+def test_gaussian_mixture_fit_predict_n_init():\n+    # Check that fit_predict is equivalent to fit.predict, when n_init > 1\n+    rng = np.random.RandomState(0)\n+    X = rng.randn(1000, 5)\n+    gm = GaussianMixture(n_components=5, n_init=5, random_state=0)\n+    y_pred1 = gm.fit_predict(X)\n+    y_pred2 = gm.predict(X)\n+    assert_array_equal(y_pred1, y_pred2)\n+\n \n def test_gaussian_mixture_fit():\n     # recover the ground truth\n",
  "scikit-learn__scikit-learn-13241": "diff --git a/sklearn/decomposition/tests/test_kernel_pca.py b/sklearn/decomposition/tests/test_kernel_pca.py\nindex 87ac169..2c4d2ba 100644\n--- a/sklearn/decomposition/tests/test_kernel_pca.py\n+++ b/sklearn/decomposition/tests/test_kernel_pca.py\n@@ -1,10 +1,11 @@\n+\n import numpy as np\n import scipy.sparse as sp\n import pytest\n \n from sklearn.utils.testing import (assert_array_almost_equal, assert_less,\n                                    assert_equal, assert_not_equal,\n-                                   assert_raises)\n+                                   assert_raises, assert_allclose)\n \n from sklearn.decomposition import PCA, KernelPCA\n from sklearn.datasets import make_circles\n",
  "scikit-learn__scikit-learn-13439": "",
  "scikit-learn__scikit-learn-13496": "diff --git a/sklearn/ensemble/tests/test_iforest.py b/sklearn/ensemble/tests/test_iforest.py\nindex 3314483..a7ceba8 100644\n--- a/sklearn/ensemble/tests/test_iforest.py\n+++ b/sklearn/ensemble/tests/test_iforest.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n Testing for Isolation Forest algorithm (sklearn.ensemble.iforest).\n \"\"\"\n@@ -11,6 +12,8 @@ import pytest\n import numpy as np\n \n from sklearn.utils.testing import assert_array_equal\n+from sklearn.utils import check_random_state\n+from sklearn.ensemble import IsolationForest\n from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_raises\n from sklearn.utils.testing import assert_raises_regex\n",
  "scikit-learn__scikit-learn-13497": "diff --git a/sklearn/feature_selection/tests/test_mutual_info.py b/sklearn/feature_selection/tests/test_mutual_info.py\nindex f5a2908..25caef2 100644\n--- a/sklearn/feature_selection/tests/test_mutual_info.py\n+++ b/sklearn/feature_selection/tests/test_mutual_info.py\n@@ -197,4 +197,37 @@ def test_mutual_info_options():\n         assert_array_equal(mi_1, mi_2)\n         assert_array_equal(mi_3, mi_4)\n \n-    assert not np.allclose(mi_1, mi_3)\n+    assert not np.allclose(mi_1, mi_3)\n+    \n+def test_estimate_mi_discrete_features():\n+    X = np.array([[0, 0, 0],\n+                  [1, 1, 0],\n+                  [2, 0, 1],\n+                  [2, 0, 1],\n+                  [2, 0, 1]], dtype=float)\n+    y = np.array([0, 1, 2, 2, 1], dtype=float)\n+    X_csr = csr_matrix(X)\n+    \n+    for mutual_info in (mutual_info_regression, mutual_info_classif):\n+        # Test with discrete_features as a boolean mask\n+        mi_1 = mutual_info(X, y, discrete_features=[True, False, True], random_state=0)\n+        \n+        # Test with discrete_features as a list of indices\n+        mi_2 = mutual_info(X, y, discrete_features=[0, 2], random_state=0)\n+        \n+        # Ensure results are consistent between boolean mask and indices\n+        assert_array_equal(mi_1, mi_2)\n+        \n+        # Test with incorrect length of boolean mask\n+        assert_raises(ValueError, mutual_info, X, y, discrete_features=[True, False])\n+        \n+        # Test with out-of-bounds index\n+        assert_raises(IndexError, mutual_info, X, y, discrete_features=[0, 3])\n+        \n+        # Test with mixed types (string and array), which should raise an error\n+        assert_raises(ValueError, mutual_info, X, y, discrete_features='auto')\n+        assert_raises(ValueError, mutual_info, X, y, discrete_features=['auto'])\n+        \n+        # Test sparse input\n+        mi_csr = mutual_info(X_csr, y, discrete_features=[True, False, True], random_state=0)\n+        assert_array_equal(mi_1, mi_csr)\n",
  "scikit-learn__scikit-learn-13584": "diff --git a/sklearn/utils/tests/test_pprint.py b/sklearn/utils/tests/test_pprint.py\nindex 88df228..ce37814 100644\n--- a/sklearn/utils/tests/test_pprint.py\n+++ b/sklearn/utils/tests/test_pprint.py\n@@ -1,3 +1,4 @@\n+\n import re\n from pprint import PrettyPrinter\n \n@@ -8,6 +9,8 @@ from sklearn.pipeline import make_pipeline\n from sklearn.base import BaseEstimator, TransformerMixin\n from sklearn.feature_selection import SelectKBest, chi2\n from sklearn import set_config\n+from sklearn.linear_model import LogisticRegressionCV\n+import numpy as np\n \n \n # Ignore flake8 (lots of line too long issues)\n@@ -214,6 +217,17 @@ LogisticRegression(C=99, class_weight=0.4, fit_intercept=False, tol=1234,\n \n     set_config(print_changed_only=False)\n \n+def test_logistic_regression_cv_array_repr():\n+    # Test for ensuring array parameters don't throw errors in repr\n+    set_config(print_changed_only=True)\n+    try:\n+        repr_output = repr(LogisticRegressionCV(Cs=np.array([0.1, 1])))\n+        assert isinstance(repr_output, str)  # ensure the output is a string\n+    except Exception as e:\n+        assert False, f\"Unexpected exception raised: {e}\"\n+    finally:\n+        set_config(print_changed_only=False)  # Reset configuration to default\n+\n \n def test_pipeline():\n     # Render a pipeline object\n",
  "scikit-learn__scikit-learn-13779": "diff --git a/sklearn/ensemble/tests/test_voting.py b/sklearn/ensemble/tests/test_voting.py\nindex 1de615a..0ba1fb0 100644\n--- a/sklearn/ensemble/tests/test_voting.py\n+++ b/sklearn/ensemble/tests/test_voting.py\n@@ -1,9 +1,12 @@\n+\n \"\"\"Testing for the VotingClassifier and VotingRegressor\"\"\"\n \n import pytest\n import numpy as np\n \n from sklearn.utils.testing import assert_almost_equal, assert_array_equal\n+from sklearn.linear_model import LinearRegression\n+from sklearn.ensemble import RandomForestRegressor\n from sklearn.utils.testing import assert_array_almost_equal\n from sklearn.utils.testing import assert_equal\n from sklearn.utils.testing import assert_raise_message\n",
  "scikit-learn__scikit-learn-14087": "",
  "scikit-learn__scikit-learn-14092": "diff --git a/sklearn/neighbors/tests/test_nca.py b/sklearn/neighbors/tests/test_nca.py\nindex 3963eca..ab74be0 100644\n--- a/sklearn/neighbors/tests/test_nca.py\n+++ b/sklearn/neighbors/tests/test_nca.py\n@@ -118,8 +118,25 @@ def test_finite_differences():\n     rel_diff = check_grad(fun, grad, M.ravel()) / np.linalg.norm(grad(M))\n     np.testing.assert_almost_equal(rel_diff, 0., decimal=5)\n \n-\n-def test_params_validation():\n+import numpy as np\n+import pytest\n+from sklearn.utils._testing import assert_raises\n+\n+@pytest.mark.parametrize('param, value', [\n+    ('tol', np.int64(1)),\n+    ('tol', np.float32(0.1)),\n+    ('n_components', np.int64(5)),\n+    ('n_components', np.float32(5.0))\n+])\n+def test_nca_with_numpy_types(param, value):\n+    # Check that NCA does not raise TypeError with numpy int64 or float32 types.\n+    X = np.random.random_sample((10, 5))\n+    y = np.random.randint(0, 2, size=10)\n+\n+    nca = NeighborhoodComponentsAnalysis(**{param: value})\n+\n+    # Ensure no TypeError is raised\n+    nca.fit(X, y)\n     # Test that invalid parameters raise value error\n     X = np.arange(12).reshape(4, 3)\n     y = [1, 1, 2, 2]\n",
  "scikit-learn__scikit-learn-14894": "diff --git a/sklearn/svm/tests/test_svm.py b/sklearn/svm/tests/test_svm.py\nindex 6ee2d71..d952382 100644\n--- a/sklearn/svm/tests/test_svm.py\n+++ b/sklearn/svm/tests/test_svm.py\n@@ -680,6 +680,44 @@ def test_unicode_kernel():\n                                 random_seed=0)\n \n \n+def test_sparse_fit_support_vectors_empty():\n+    # Regression test for the previously mentioned ZeroDivisionError in _sparse_fit\n+    from scipy import sparse\n+    import numpy as np\n+    from sklearn import svm\n+    \n+    X_train = sparse.csr_matrix([\n+        [0, 1, 0, 0],\n+        [0, 0, 0, 1],\n+        [0, 0, 1, 0],\n+        [0, 0, 0, 1]\n+    ])\n+    y_train = np.array([0.04, 0.04, 0.10, 0.16])\n+    \n+    model = svm.SVR(kernel='linear', C=316.227766017, epsilon=0.1, tol=0.001)\n+    model.fit(X_train, y_train)\n+    \n+    # Ensure that support_vectors_ is empty, confirming no issue with empty support vectors\n+    assert not model.support_vectors_.data.size\n+    assert not model.dual_coef_.data.size\n+\n+\n+def test_sparse_empty_edge_cases():\n+    from scipy import sparse\n+    import numpy as np\n+    from sklearn import svm\n+    \n+    # Test case with an empty training set\n+    X_train_empty = sparse.csr_matrix((0, 4))\n+    y_train_empty = np.array([])\n+    \n+    model_empty = svm.SVR(kernel='linear', C=316.227766017, epsilon=0.1, tol=0.001)\n+    try:\n+        model_empty.fit(X_train_empty, y_train_empty)\n+    except ValueError as e:\n+        assert \"empty training data\" in str(e).lower()\n+\n+\n def test_sparse_precomputed():\n     clf = svm.SVC(kernel='precomputed')\n     sparse_gram = sparse.csr_matrix([[1, 0], [0, 1]])\n",
  "scikit-learn__scikit-learn-14983": "diff --git a/sklearn/model_selection/tests/test_split.py b/sklearn/model_selection/tests/test_split.py\nindex dd52c66..88e19b0 100644\n--- a/sklearn/model_selection/tests/test_split.py\n+++ b/sklearn/model_selection/tests/test_split.py\n@@ -972,8 +972,16 @@ def test_leave_one_p_group_out_error_on_fewer_number_of_groups():\n                          LeavePGroupsOut(n_groups=3).split(X, y, groups))\n \n \n-@ignore_warnings\n-def test_repeated_cv_value_errors():\n+import pytest\n+@pytest.mark.parametrize(\"RepeatedCV\", [RepeatedKFold, RepeatedStratifiedKFold])\n+def test_repeated_cv_repr(RepeatedCV):\n+    n_splits, n_repeats = 5, 10\n+    repeated_cv = RepeatedCV(n_splits=n_splits, n_repeats=n_repeats)\n+    repeated_cv_repr = (\n+        \"{}(n_repeats={}, n_splits={}, random_state=None)\"\n+        .format(repeated_cv.__class__.__name__, n_repeats, n_splits)\n+    )\n+    assert repeated_cv_repr == repr(repeated_cv)\n     # n_repeats is not integer or <= 0\n     for cv in (RepeatedKFold, RepeatedStratifiedKFold):\n         assert_raises(ValueError, cv, n_repeats=0)\n",
  "scikit-learn__scikit-learn-15512": "diff --git a/sklearn/cluster/tests/test_affinity_propagation.py b/sklearn/cluster/tests/test_affinity_propagation.py\nindex 5de7c5e..4a36db2 100644\n--- a/sklearn/cluster/tests/test_affinity_propagation.py\n+++ b/sklearn/cluster/tests/test_affinity_propagation.py\n@@ -151,8 +151,27 @@ def test_affinity_propagation_predict_non_convergence():\n     y = assert_warns(ConvergenceWarning, af.predict, to_predict)\n     assert_array_equal(np.array([-1, -1, -1]), y)\n \n+from sklearn.cluster import AffinityPropagation\n+import numpy as np\n+from sklearn.utils._testing import assert_array_equal, assert_warns\n+from sklearn.exceptions import ConvergenceWarning\n \n-def test_equal_similarities_and_preferences():\n+def test_affinity_propagation_non_convergence_regressiontest():\n+    X = np.array([[1, 0, 0, 0, 0, 0],\n+                  [0, 1, 1, 1, 0, 0],\n+                  [0, 0, 1, 0, 0, 1]])\n+    af = AffinityPropagation(affinity='euclidean', max_iter=2).fit(X)\n+    assert_array_equal(np.array([-1, -1, -1]), af.labels_)\n+    assert_array_equal([], af.cluster_centers_indices_)\n+\n+def test_affinity_propagation_non_convergence_labels_and_centers():\n+    # Test to ensure correct outputs when non-convergence occurs\n+    X = np.array([[1, 0, 0, 0, 0, 0],\n+                  [0, 1, 1, 1, 0, 0],\n+                  [0, 0, 1, 0, 0, 1]])\n+    af = AffinityPropagation(affinity='euclidean', max_iter=2).fit(X)\n+    assert_array_equal([], af.cluster_centers_indices_)\n+    assert_array_equal([-1, -1, -1], af.labels_)\n     # Unequal distances\n     X = np.array([[0, 0], [1, 1], [-2, -2]])\n     S = -euclidean_distances(X, squared=True)\n",
  "scikit-learn__scikit-learn-15535": "",
  "scikit-learn__scikit-learn-25500": "diff --git a/sklearn/tests/test_isotonic.py b/sklearn/tests/test_isotonic.py\nindex 5021282..d2042df 100644\n--- a/sklearn/tests/test_isotonic.py\n+++ b/sklearn/tests/test_isotonic.py\n@@ -1,4 +1,8 @@\n+\n import warnings\n+from sklearn import set_config\n+from sklearn.calibration import CalibratedClassifierCV\n+from sklearn.linear_model import SGDClassifier\n import numpy as np\n import pickle\n import copy\n@@ -668,7 +672,19 @@ def test_isotonic_regression_sample_weight_not_overwritten():\n \n \n @pytest.mark.parametrize(\"shape\", [\"1d\", \"2d\"])\n-def test_get_feature_names_out(shape):\n+def test_calibrated_classifier_isotonic_with_pandas_output():\n+    \"\"\"Test CalibratedClassifierCV using isotonic with pandas output config.\"\"\"\n+    from sklearn.datasets import make_classification\n+    X, y = make_classification(n_samples=100, n_features=5, random_state=42)\n+\n+    # Set the Scikit-learn config to output pandas\n+    with set_config(transform_output=\"pandas\"):\n+        base_estimator = SGDClassifier(max_iter=1000, tol=1e-3)\n+        calibrated_clf = CalibratedClassifierCV(base_estimator, method='isotonic')\n+        calibrated_clf.fit(X, y)\n+        # Test prediction to ensure it works without errors\n+        proba = calibrated_clf.predict_proba(X)\n+        assert proba.shape == (100, 2), \"The predicted probability shape is incorrect\"\n     \"\"\"Check `get_feature_names_out` for `IsotonicRegression`.\"\"\"\n     X = np.arange(10)\n     if shape == \"2d\":\n",
  "scikit-learn__scikit-learn-25570": "diff --git a/sklearn/compose/tests/test_column_transformer.py b/sklearn/compose/tests/test_column_transformer.py\nindex 23e3b97..c3f64e9 100644\n--- a/sklearn/compose/tests/test_column_transformer.py\n+++ b/sklearn/compose/tests/test_column_transformer.py\n@@ -2120,12 +2120,128 @@ def test_transformers_with_pandas_out_but_not_feature_names_out(\n     # not define the method.\n     with pytest.raises(AttributeError, match=\"not provide get_feature_names_out\"):\n         ct.get_feature_names_out()\n+import pytest\n+import numpy as np\n+import pandas as pd\n+from sklearn.compose import ColumnTransformer\n+from sklearn.pipeline import Pipeline\n+from sklearn.impute import SimpleImputer\n+from sklearn.preprocessing import RobustScaler\n+from sklearn.preprocessing import StandardScaler\n+from sklearn.utils._testing import assert_array_equal\n+\n+@pytest.mark.parametrize(\n+    \"empty_selection\",\n+    [[], np.array([False, False]), [False, False]],\n+    ids=[\"list\", \"bool_array\", \"bool_list\"],\n+)\n+def test_empty_selection_pandas_output(empty_selection):\n+    \"\"\"Check that pandas output works when there is an empty selection.\n \n+    Non-regression test for gh-25487\n+    \"\"\"\n+    X = pd.DataFrame([[1.0, 2.2], [3.0, 1.0]], columns=[\"a\", \"b\"])\n+    ct = ColumnTransformer(\n+        [\n+            (\"categorical\", \"passthrough\", empty_selection),\n+            (\"numerical\", StandardScaler(), [\"a\", \"b\"]),\n+        ],\n+        verbose_feature_names_out=True,\n+    )\n+    ct.set_output(transform=\"pandas\")\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"numerical__a\", \"numerical__b\"])\n+\n+    ct.set_params(verbose_feature_names_out=False)\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"a\", \"b\"])\n+    \n+def test_transformers_with_no_features_pandas_output():\n+    \"\"\"Check that transformers with no features are handled correctly with pandas output.\"\"\"\n+    X = pd.DataFrame(data=[[1.0, 2.0, 3.0], [4, 2, 2]], columns=[\"a\", \"b\", \"c\"])\n+    y = np.array([0, 1])\n+    categorical_features = []  # Empty list intentionally\n+    numerical_features = [\"a\", \"b\"]\n+    \n+    model_preprocessing = (\n+        \"preprocessing\",\n+        ColumnTransformer(\n+            [\n+                ('categorical', 'passthrough', categorical_features),\n+                ('numerical', Pipeline([(\"scaler\", RobustScaler()),\n+                                        (\"imputer\", SimpleImputer(strategy=\"mean\"))]), numerical_features),\n+            ],\n+            remainder='drop'\n+        )\n+    )\n+    \n+    pipeline = Pipeline([model_preprocessing]).set_output(transform=\"pandas\")\n+    pipeline.fit(X, y)\n+    X_transformed = pipeline.transform(X)\n+    assert_array_equal(X_transformed.columns, [\"numerical__a\", \"numerical__b\"])\n     # The feature names are prefixed because verbose_feature_names_out=True is default\n     ct.set_output(transform=\"pandas\")\n     X_trans_df0 = ct.fit_transform(X_df)\n     assert_array_equal(X_trans_df0.columns, expected_verbose_names)\n+import pytest\n+import numpy as np\n+import pandas as pd\n+from sklearn.compose import ColumnTransformer\n+from sklearn.pipeline import Pipeline\n+from sklearn.impute import SimpleImputer\n+from sklearn.preprocessing import RobustScaler\n+from sklearn.preprocessing import StandardScaler\n+from sklearn.utils._testing import assert_array_equal\n+\n+@pytest.mark.parametrize(\n+    \"empty_selection\",\n+    [[], np.array([False, False]), [False, False]],\n+    ids=[\"list\", \"bool_array\", \"bool_list\"],\n+)\n+def test_empty_selection_pandas_output(empty_selection):\n+    \"\"\"Check that pandas output works when there is an empty selection.\n \n+    Non-regression test for gh-25487\n+    \"\"\"\n+    X = pd.DataFrame([[1.0, 2.2], [3.0, 1.0]], columns=[\"a\", \"b\"])\n+    ct = ColumnTransformer(\n+        [\n+            (\"categorical\", \"passthrough\", empty_selection),\n+            (\"numerical\", StandardScaler(), [\"a\", \"b\"]),\n+        ],\n+        verbose_feature_names_out=True,\n+    )\n+    ct.set_output(transform=\"pandas\")\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"numerical__a\", \"numerical__b\"])\n+\n+    ct.set_params(verbose_feature_names_out=False)\n+    X_out = ct.fit_transform(X)\n+    assert_array_equal(X_out.columns, [\"a\", \"b\"])\n+    \n+def test_transformers_with_no_features_pandas_output():\n+    \"\"\"Check that transformers with no features are handled correctly with pandas output.\"\"\"\n+    X = pd.DataFrame(data=[[1.0, 2.0, 3.0], [4, 2, 2]], columns=[\"a\", \"b\", \"c\"])\n+    y = np.array([0, 1])\n+    categorical_features = []  # Empty list intentionally\n+    numerical_features = [\"a\", \"b\"]\n+    \n+    model_preprocessing = (\n+        \"preprocessing\",\n+        ColumnTransformer(\n+            [\n+                ('categorical', 'passthrough', categorical_features),\n+                ('numerical', Pipeline([(\"scaler\", RobustScaler()),\n+                                        (\"imputer\", SimpleImputer(strategy=\"mean\"))]), numerical_features),\n+            ],\n+            remainder='drop'\n+        )\n+    )\n+    \n+    pipeline = Pipeline([model_preprocessing]).set_output(transform=\"pandas\")\n+    pipeline.fit(X, y)\n+    X_transformed = pipeline.transform(X)\n+    assert_array_equal(X_transformed.columns, [\"numerical__a\", \"numerical__b\"])\n     ct.set_params(verbose_feature_names_out=False)\n     X_trans_df1 = ct.fit_transform(X_df)\n-    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n+    assert_array_equal(X_trans_df1.columns, expected_non_verbose_names)\n",
  "sphinx-doc__sphinx-10325": "",
  "sphinx-doc__sphinx-7975": "",
  "sphinx-doc__sphinx-8435": "",
  "sphinx-doc__sphinx-8506": "diff --git a/tests/test_domain_std.py b/tests/test_domain_std.py\nindex 08bd595..067e743 100644\n--- a/tests/test_domain_std.py\n+++ b/tests/test_domain_std.py\n@@ -91,6 +91,81 @@ def test_get_full_qualified_name():\n     assert domain.get_full_qualified_name(node) == 'ls.-l'\n \n \n+import pytest\n+from sphinx.testing.util import assert_node\n+from sphinx import addnodes\n+from sphinx.domains.std import StandardDomain\n+\n+def test_cmd_option_with_optional_value(app):\n+    # This is the original test case for the '-j[=N]' syntax\n+    text = \".. option:: -j[=N]\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (\n+        addnodes.index,\n+        [addnodes.desc,\n+         ([addnodes.desc_signature, \n+           ([addnodes.desc_name, '-j'],\n+            [addnodes.desc_addname, '[=N]'])],\n+          [addnodes.desc_content, ()])\n+        ])\n+    )\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('-j', '-j', 'cmdoption', 'index', 'cmdoption-j', 1) in objects\n+\n+\n+def test_cmd_option_starting_with_bracket(app):\n+    # This is the original test case for the '[enable=]PATTERN' syntax\n+    text = \".. option:: [enable=]PATTERN\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (\n+        addnodes.index,\n+        [addnodes.desc,\n+         ([addnodes.desc_signature, \n+           ([addnodes.desc_name, '[enable'],\n+            [addnodes.desc_addname, '=]PATTERN'])],\n+          [addnodes.desc_content, ()])\n+        ])\n+    )\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('[enable', '[enable', 'cmdoption', 'index', 'cmdoption-arg-enable', 1) in objects\n+\n+\n+def test_cmd_option_with_multiple_brackets(app):\n+    # New test case for options with multiple optional elements\n+    text = \".. option:: [foo][bar]=BAZ\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (\n+        addnodes.index,\n+        [addnodes.desc,\n+         ([addnodes.desc_signature, \n+           ([addnodes.desc_name, '[foo][bar'],\n+            [addnodes.desc_addname, '=BAZ'])],\n+          [addnodes.desc_content, ()])\n+        ])\n+    )\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('[foo][bar]', '[foo][bar]', 'cmdoption', 'index', 'cmdoption-arg-foo-bar', 1) in objects\n+\n+\n+def test_cmd_option_with_special_characters(app):\n+    # New test case for options with special characters\n+    text = \".. option:: --path=<path> --name=<name>\"\n+    doctree = restructuredtext.parse(app, text)\n+    assert_node(doctree, (\n+        addnodes.index,\n+        [addnodes.desc,\n+         ([addnodes.desc_signature, \n+           ([addnodes.desc_name, '--path'],\n+            [addnodes.desc_addname, '=<path>']),\n+           ([addnodes.desc_name, '--name'],\n+            [addnodes.desc_addname, '=<name>'])],\n+          [addnodes.desc_content, ()])\n+        ])\n+    )\n+    objects = list(app.env.get_domain(\"std\").get_objects())\n+    assert ('--path', '--path', 'cmdoption', 'index', 'cmdoption-arg-path', 1) in objects\n+    assert ('--name', '--name', 'cmdoption', 'index', 'cmdoption-arg-name', 1) in objects\n+\n def test_glossary(app):\n     text = (\".. glossary::\\n\"\n             \"\\n\"\n",
  "sphinx-doc__sphinx-8595": "diff --git a/tests/test_ext_autodoc.py b/tests/test_ext_autodoc.py\nindex eec5523..0ffc096 100644\n--- a/tests/test_ext_autodoc.py\n+++ b/tests/test_ext_autodoc.py\n@@ -20,6 +20,10 @@ from sphinx import addnodes\n from sphinx.ext.autodoc import ALL, ModuleLevelDocumenter, Options\n from sphinx.ext.autodoc.directive import DocumenterBridge, process_documenter_options\n from sphinx.testing.util import SphinxTestApp, Struct  # NOQA\n+import pytest\n+\n+from .test_ext_autodoc import do_autodoc\n+\n from sphinx.util.docutils import LoggingReporter\n \n try:\n@@ -28,6 +32,30 @@ try:\n     pyximport.install()\n except ImportError:\n     pyximport = None\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_empty_all_case_2(app):\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.empty_all_case_2', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.empty_all_case_2',\n+        '',\n+        'docstring of empty_all_case_2 module.',\n+        '',\n+    ]\n+\n+\n+@pytest.mark.sphinx('html', testroot='ext-autodoc')\n+def test_empty_all_with_docstring(app):\n+    options = {'members': True}\n+    actual = do_autodoc(app, 'module', 'target.empty_all_with_docstring', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:module:: target.empty_all_with_docstring',\n+        '',\n+        'docstring of module with empty __all__ and docstring.',\n+        '',\n+    ]\n \n \n def do_autodoc(app, objtype, name, options=None):\n",
  "sphinx-doc__sphinx-8627": "diff --git a/tests/test_util_typing.py b/tests/test_util_typing.py\nindex 31df144..b423327 100644\n--- a/tests/test_util_typing.py\n+++ b/tests/test_util_typing.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"\n     test_util_typing\n     ~~~~~~~~~~~~~~~~\n@@ -10,6 +11,7 @@\n \n import sys\n from numbers import Integral\n+from struct import Struct\n from typing import (Any, Callable, Dict, Generator, List, NewType, Optional, Tuple, TypeVar,\n                     Union)\n \n@@ -44,6 +46,7 @@ def test_restify():\n     assert restify(None) == \":obj:`None`\"\n     assert restify(Integral) == \":class:`numbers.Integral`\"\n     assert restify(Any) == \":obj:`Any`\"\n+    assert restify(Struct) == \":class:`struct.Struct`\"\n \n \n def test_restify_type_hints_containers():\n",
  "sphinx-doc__sphinx-8713": "diff --git a/tests/test_ext_napoleon_docstring.py b/tests/test_ext_napoleon_docstring.py\nindex 89ff1bb..feedee2 100644\n--- a/tests/test_ext_napoleon_docstring.py\n+++ b/tests/test_ext_napoleon_docstring.py\n@@ -1455,6 +1455,29 @@ param1 : :class:`MyClass <name.space.MyClass>` instance\n         expected = \"\"\"\\\n :param param1:\n :type param1: :class:`MyClass <name.space.MyClass>` instance\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+    def test_other_parameters_with_class_reference(self):\n+        docstring = \"\"\"\\\n+Other Parameters\n+----------------\n+param2 : :class:`MyClass <name.space.MyClass>` instance\n+\n+\"\"\"\n+\n+        config = Config(napoleon_use_param=False)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:Other Parameters: **param2** (:class:`MyClass <name.space.MyClass>` instance)\n+\"\"\"\n+        self.assertEqual(expected, actual)\n+\n+        config = Config(napoleon_use_param=True)\n+        actual = str(NumpyDocstring(docstring, config))\n+        expected = \"\"\"\\\n+:param param2:\n+:type param2: :class:`MyClass <name.space.MyClass>` instance\n \"\"\"\n         self.assertEqual(expected, actual)\n \n",
  "sphinx-doc__sphinx-8721": "diff --git a/tests/test_ext_viewcode.py b/tests/test_ext_viewcode.py\nindex d4fba47..0fc1706 100644\n--- a/tests/test_ext_viewcode.py\n+++ b/tests/test_ext_viewcode.py\n@@ -49,6 +49,8 @@ def test_viewcode(app, status, warning):\n             '<span>    &quot;&quot;&quot;</span></div>\\n') in result\n \n \n+import pytest\n+\n @pytest.mark.sphinx(testroot='ext-viewcode', tags=['test_linkcode'])\n def test_linkcode(app, status, warning):\n     app.builder.build(['objects'])\n",
  "sympy__sympy-12481": "",
  "sympy__sympy-13031": "diff --git a/sympy/matrices/tests/test_sparse.py b/sympy/matrices/tests/test_sparse.py\nindex 4d1c3fc..7c87263 100644\n--- a/sympy/matrices/tests/test_sparse.py\n+++ b/sympy/matrices/tests/test_sparse.py\n@@ -1,4 +1,6 @@\n+\n from sympy import Abs, S, Symbol, I, Rational, PurePoly\n+from sympy.matrices import SparseMatrix, Matrix\n from sympy.matrices import Matrix, SparseMatrix, eye, zeros, ShapeError\n from sympy.utilities.pytest import raises\n \n@@ -448,8 +450,38 @@ def test_sparse_matrix():\n     assert A.col_list() == [(0, 0, 18), (4, 2, 19), (6, 2, 12), (1, 4, 18), (2, 7, 16), (5, 7, 16), (9, 7, 18), (0, 9, 12), (3, 9, 12)]\n     assert SparseMatrix.eye(2).nnz() == 2\n \n-\n-def test_transpose():\n+def test_hstack_vstack_with_zeros():\n+    # Test case to verify the behavior of horizontal stacking with zero rows\n+    M1 = SparseMatrix.zeros(0, 0)\n+    M2 = SparseMatrix.zeros(0, 1)\n+    M3 = SparseMatrix.zeros(0, 2)\n+    M4 = SparseMatrix.zeros(0, 3)\n+    result_hstack = SparseMatrix.hstack(M1, M2, M3, M4)\n+    assert result_hstack.shape == (0, 6), f\"Expected (0, 6), but got {result_hstack.shape}\"\n+\n+    # Test case to verify behavior when the matrix has one row\n+    M1 = SparseMatrix.zeros(1, 0)\n+    M2 = SparseMatrix.zeros(1, 1)\n+    M3 = SparseMatrix.zeros(1, 2)\n+    M4 = SparseMatrix.zeros(1, 3)\n+    result_hstack = SparseMatrix.hstack(M1, M2, M3, M4)\n+    assert result_hstack.shape == (1, 6), f\"Expected (1, 6), but got {result_hstack.shape}\"\n+\n+    # Test case to verify the behavior of vertical stacking with zero columns\n+    M1 = SparseMatrix.zeros(0, 1)\n+    M2 = SparseMatrix.zeros(0, 2)\n+    M3 = SparseMatrix.zeros(0, 3)\n+    M4 = SparseMatrix.zeros(0, 4)\n+    result_vstack = SparseMatrix.vstack(M1, M2, M3, M4)\n+    assert result_vstack.shape == (0, 4), f\"Expected (0, 4), but got {result_vstack.shape}\"\n+\n+    # Test case when there is one column\n+    M1 = SparseMatrix.zeros(1, 0)\n+    M2 = SparseMatrix.zeros(2, 0)\n+    M3 = SparseMatrix.zeros(3, 0)\n+    M4 = SparseMatrix.zeros(4, 0)\n+    result_vstack = SparseMatrix.vstack(M1, M2, M3, M4)\n+    assert result_vstack.shape == (10, 0), f\"Expected (10, 0), but got {result_vstack.shape}\"\n     assert SparseMatrix(((1, 2), (3, 4))).transpose() == \\\n         SparseMatrix(((1, 3), (2, 4)))\n \n",
  "sympy__sympy-13471": "diff --git a/sympy/utilities/tests/test_pickling.py b/sympy/utilities/tests/test_pickling.py\nindex 52dcc20..867fc49 100644\n--- a/sympy/utilities/tests/test_pickling.py\n+++ b/sympy/utilities/tests/test_pickling.py\n@@ -81,6 +81,28 @@ def check(a, exclude=[], check_attr=True):\n \n #================== core =========================\n \n+import sys\n+import pickle\n+import sympy\n+\n+def test_pickle_float_expr_py2_to_py3():\n+    # This test simulates pickling in Python 2 and unpickling in Python 3\n+    # Create a sympy expression with a float in Python 2 style\n+    x = sympy.symbols(\"x\")\n+    expr = x + 1.0\n+\n+    # Simulate Python 2 pickle.dumps with protocol 2\n+    try:\n+        # Serialize\n+        py2_pickled = pickle.dumps(expr, protocol=2)\n+        # Deserialize (unpickle)\n+        unpickled_expr = pickle.loads(py2_pickled)\n+        \n+        # Assert the unpickled expression is correct\n+        assert sympy.simplify(unpickled_expr - expr) == 0\n+    except Exception as e:\n+        raise AssertionError(f\"Pickle test failed with exception: {e}\")\n+\n \n def test_core_basic():\n     for c in (Atom, Atom(),\n",
  "sympy__sympy-13480": "diff --git a/sympy/functions/elementary/tests/test_hyperbolic.py b/sympy/functions/elementary/tests/test_hyperbolic.py\nindex 9ac371d..4392a64 100644\n--- a/sympy/functions/elementary/tests/test_hyperbolic.py\n+++ b/sympy/functions/elementary/tests/test_hyperbolic.py\n@@ -261,6 +261,24 @@ def test_coth():\n     assert coth(-5*pi*I/6) == -sqrt(3)*I\n \n     assert coth(pi*I/105) == -cot(pi/105)*I\n+\n+def test_coth_log_tan_subs():\n+    from sympy import coth, log, tan, Symbol\n+    x = Symbol('x')\n+    \n+    # Test that substitution for coth(log(tan(x))) doesn't raise an error.\n+    # We will test on integral values mentioned in the issue: 2, 3, 5, 6, 8, 9, 11, 12, 13, 15, 18\n+    assert coth(log(tan(2))) == coth(log(tan(2)))  # The result itself doesn't matter as long as no error occurs\n+    assert coth(log(tan(3))) == coth(log(tan(3)))\n+    assert coth(log(tan(5))) == coth(log(tan(5)))\n+    assert coth(log(tan(6))) == coth(log(tan(6)))\n+    assert coth(log(tan(8))) == coth(log(tan(8)))\n+    assert coth(log(tan(9))) == coth(log(tan(9)))\n+    assert coth(log(tan(11))) == coth(log(tan(11)))\n+    assert coth(log(tan(12))) == coth(log(tan(12)))\n+    assert coth(log(tan(13))) == coth(log(tan(13)))\n+    assert coth(log(tan(15))) == coth(log(tan(15)))\n+    assert coth(log(tan(18))) == coth(log(tan(18)))\n     assert coth(-pi*I/105) == cot(pi/105)*I\n \n     assert coth(2 + 3*I) == coth(2 + 3*I)\n",
  "sympy__sympy-13647": "diff --git a/sympy/matrices/tests/test_commonmatrix.py b/sympy/matrices/tests/test_commonmatrix.py\nindex 9e436f2..3048c61 100644\n--- a/sympy/matrices/tests/test_commonmatrix.py\n+++ b/sympy/matrices/tests/test_commonmatrix.py\n@@ -187,6 +187,45 @@ def test_col_join():\n                    [0, 0, 1],\n                    [7, 7, 7]])\n \n+def test_col_insert_issue_13643():\n+    eye_6 = eye_Shaping(6)\n+    V = Matrix([[2, 2], [2, 2], [2, 2], [2, 2], [2, 2], [2, 2]])\n+    result = eye_6.col_insert(3, V)\n+    expected = Matrix([\n+        [1, 0, 0, 2, 2, 0, 0, 0],\n+        [0, 1, 0, 2, 2, 0, 0, 0],\n+        [0, 0, 1, 2, 2, 0, 0, 0],\n+        [0, 0, 0, 2, 2, 1, 0, 0],\n+        [0, 0, 0, 2, 2, 0, 1, 0],\n+        [0, 0, 0, 2, 2, 0, 0, 1]\n+    ])\n+    assert result == expected\n+    \n+    # additional edge cases\n+    # inserting at the start\n+    result_start = eye_6.col_insert(0, V)\n+    expected_start = Matrix([\n+        [2, 2, 1, 0, 0, 0, 0, 0],\n+        [2, 2, 0, 1, 0, 0, 0, 0],\n+        [2, 2, 0, 0, 1, 0, 0, 0],\n+        [2, 2, 0, 0, 0, 1, 0, 0],\n+        [2, 2, 0, 0, 0, 0, 1, 0],\n+        [2, 2, 0, 0, 0, 0, 0, 1]\n+    ])\n+    assert result_start == expected_start\n+\n+    # inserting at the last position\n+    result_end = eye_6.col_insert(6, V)\n+    expected_end = Matrix([\n+        [1, 0, 0, 0, 0, 0, 2, 2],\n+        [0, 1, 0, 0, 0, 0, 2, 2],\n+        [0, 0, 1, 0, 0, 0, 2, 2],\n+        [0, 0, 0, 1, 0, 0, 2, 2],\n+        [0, 0, 0, 0, 1, 0, 2, 2],\n+        [0, 0, 0, 0, 0, 1, 2, 2]\n+    ])\n+    assert result_end == expected_end\n+\n def test_row_insert():\n     r4 = Matrix([[4, 4, 4]])\n     for i in range(-4, 5):\n",
  "sympy__sympy-13971": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 92c6b34..77381e7 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -615,8 +615,48 @@ def test_latex_Range():\n \n     assert latex(Range(-2, -oo, -1)) == r'\\left\\{-2, -3, \\ldots, -\\infty\\right\\}'\n \n+from sympy import symbols, oo\n+from sympy.printing.latex import latex\n+from sympy.series.sequences import SeqFormula, SeqPer, SeqAdd, SeqMul\n \n-def test_latex_sequences():\n+def test_latex_sequences_brackets():\n+    k, m, n = symbols('k m n', integer=True)\n+\n+    # Test to check the latex output for SeqFormula doesn't escape square brackets\n+    seq = SeqFormula(n**2, (n, 0, oo))\n+    expected_latex = r'[0, 1, 4, 9, \\ldots]'\n+    assert latex(seq) == expected_latex\n+\n+    # Additional test cases to ensure correct latex output for sequence variations\n+\n+    # Finite sequence\n+    seq_finite = SeqFormula(n**2, (n, 0, 3))\n+    expected_latex_finite = r'[0, 1, 4, 9]'\n+    assert latex(seq_finite) == expected_latex_finite\n+\n+    # Negative infinity to a finite number\n+    seq_neg_inf = SeqFormula(n**2, (n, -oo, 0))\n+    expected_latex_neg_inf = r'[\\ldots, 1, 0]'\n+    assert latex(seq_neg_inf) == expected_latex_neg_inf\n+\n+    # Finite to finite range\n+    seq_finite_range = SeqFormula(n**2, (n, 1, 3))\n+    expected_latex_finite_range = r'[1, 4, 9]'\n+    assert latex(seq_finite_range) == expected_latex_finite_range\n+\n+    # Sequences with defined operations \n+    s1 = SeqFormula(n**2, (n, 0, oo))\n+    s2 = SeqPer((1, 2))\n+    \n+    # Test SeqAdd\n+    seq_add = SeqAdd(s1, s2)\n+    expected_latex_add = r'[1, 3, 5, 11, \\ldots]'\n+    assert latex(seq_add) == expected_latex_add\n+    \n+    # Test SeqMul\n+    seq_mul = SeqMul(s1, s2)\n+    expected_latex_mul = r'[0, 2, 4, 18, \\ldots]'\n+    assert latex(seq_mul) == expected_latex_mul\n     s1 = SeqFormula(a**2, (0, oo))\n     s2 = SeqPer((1, 2))\n \n",
  "sympy__sympy-14396": "diff --git a/sympy/polys/tests/test_polyoptions.py b/sympy/polys/tests/test_polyoptions.py\nindex 07edaff..c95d8eb 100644\n--- a/sympy/polys/tests/test_polyoptions.py\n+++ b/sympy/polys/tests/test_polyoptions.py\n@@ -1,3 +1,14 @@\n+\n+def test_RR_domain_with_generators():\n+    from sympy import Poly\n+    from sympy.abc import x, y, z\n+\n+    # Test case for issue with domain 'RR[y,z]'\n+    assert Poly(1.2*x*y*z, x, domain='RR[y,z]').as_expr() == 1.2*y*z*x\n+\n+    # Ensure preprocessing works for RR[y,z]\n+    assert Domain.preprocess('RR[y,z]') == RR[y, z]\n+\n \"\"\"Tests for options manager for :class:`Poly` and public API functions. \"\"\"\n \n from sympy.polys.polyoptions import (\n@@ -6,7 +17,7 @@ from sympy.polys.polyoptions import (\n     Frac, Formal, Polys, Include, All, Gen, Symbols, Method)\n \n from sympy.polys.orderings import lex\n-from sympy.polys.domains import FF, GF, ZZ, QQ, EX\n+from sympy.polys.domains import FF, GF, ZZ, QQ, RR, CC, EX\n \n from sympy.polys.polyerrors import OptionError, GeneratorsError\n \n",
  "sympy__sympy-14774": "",
  "sympy__sympy-14817": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 659f10f..ffc3af7 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -6111,6 +6111,35 @@ u(\"\"\"\\\n     assert upretty((1/y)*e.j) == ucode_str\n \n \n+from sympy import symbols, MatrixSymbol, pretty\n+\n+def test_issue_14814_pretty_printing():\n+    n = symbols('n')\n+    x = MatrixSymbol('x', n, n)\n+    y_star = MatrixSymbol('y*', n, n)\n+    a = symbols('a')\n+\n+    # The output is expected to be \"x + y*\"\n+    assert pretty(x + y_star) == \"x + y*\"\n+\n+    # Testing edge case involving negative and complex expressions\n+    # Expected output is \"-a*x - 2*y*\"\n+    assert pretty(-a*x + -2*y_star*y_star) == \"-a*x - 2*y**2\"\n+    \n+    # Test cases with special symbols in names\n+    y_hash = MatrixSymbol('y#', n, n)\n+    assert pretty(x + y_hash) == \"x + y#\"\n+\n+    # Test with numeric and symbolic expressions\n+    assert pretty(3*x + y_star) == \"3*x + y*\"\n+\n+    # Ensure negative symbol doesn't cause assertion failure\n+    assert pretty(-x + y_star) == \"-x + y*\"\n+\n+    # Ensure unary functions and constants work\n+    I = MatrixSymbol('I', n, n)\n+    assert pretty(x + I) == \"x + I\"\n+\n def test_MatrixSymbol_printing():\n     # test cases for issue #14237\n     A = MatrixSymbol(\"A\", 3, 3)\n",
  "sympy__sympy-15011": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex ea56680..5edb247 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -737,6 +737,26 @@ def test_python_keywords():\n     f = lambdify(python_if, expr)\n     assert f(4.0) == 2.0\n \n+def test_curly_matrix_symbol():\n+    # Issue #15009\n+    from sympy import MatrixSymbol, lambdify\n+    curlyv = MatrixSymbol(\"{v}\", 2, 1)\n+    v_sub = [[1], [2]]\n+    # Test without dummify\n+    lam = lambdify(curlyv, curlyv)\n+    assert (lam(v_sub) == v_sub)\n+\n+    # Test with dummify=True\n+    lam = lambdify(curlyv, curlyv, dummify=True)\n+    assert (lam(v_sub) == v_sub)\n+\n+    # Test with different module settings\n+    lam_numpy = lambdify(curlyv, curlyv, modules='numpy')\n+    assert (lam_numpy(v_sub) == v_sub)\n+    \n+    lam_sympy = lambdify(curlyv, curlyv, modules='sympy')\n+    assert (lam_sympy(v_sub) == v_sub)\n+\n \n def test_lambdify_docstring():\n     func = lambdify((w, x, y, z), w + x + y + z)\n",
  "sympy__sympy-15345": "diff --git a/sympy/printing/tests/test_mathematica.py b/sympy/printing/tests/test_mathematica.py\nindex 512f405..ca881d1 100644\n--- a/sympy/printing/tests/test_mathematica.py\n+++ b/sympy/printing/tests/test_mathematica.py\n@@ -1,8 +1,21 @@\n+\n+def test_Max_Min():\n+    # Test for Max and Min function conversion to Mathematica syntax\n+    assert mcode(Max(x, 2)) == 'Max[x, 2]'\n+    assert mcode(Max(x, y, z)) == 'Max[x, y, z]'\n+    assert mcode(Max(2, x)) == 'Max[x, 2]'  # Check if the order is corrected\n+    assert mcode(Min(x, 2)) == 'Min[x, 2]'\n+    assert mcode(Min(x, y, z)) == 'Min[x, y, z]'\n+    assert mcode(Min(2, x)) == 'Min[x, 2]'\n+\n+    # Original test case to ensure it still passes\n+    assert mcode(Max(x, y, z) * Min(y, z)) == \"Max[x, y, z]*Min[y, z]\"\n+\n from sympy.core import (S, pi, oo, symbols, Function,\n                         Rational, Integer, Tuple, Derivative)\n from sympy.integrals import Integral\n from sympy.concrete import Sum\n-from sympy.functions import exp, sin, cos, conjugate\n+from sympy.functions import exp, sin, cos, conjugate, Max, Min\n \n from sympy import mathematica_code as mcode\n \n",
  "sympy__sympy-15609": "diff --git a/sympy/printing/tests/test_latex.py b/sympy/printing/tests/test_latex.py\nindex 7f3c1a5..03080a1 100644\n--- a/sympy/printing/tests/test_latex.py\n+++ b/sympy/printing/tests/test_latex.py\n@@ -1717,6 +1717,15 @@ def test_issue_13651():\n     assert latex(expr) == r\"c - \\left(a + b\\right)\"\n \n \n+def test_indexed_matrix_expression_latex():\n+    # Test for the issue where indexed matrix-expression LaTeX printer is not compilable\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n+\n+from sympy import symbols, MatrixSymbol, latex  # Add necessary imports\n+\n def test_latex_UnevaluatedExpr():\n     x = symbols(\"x\")\n     he = UnevaluatedExpr(1/x)\n@@ -1726,6 +1735,13 @@ def test_latex_UnevaluatedExpr():\n     assert latex(x*he) == r\"x \\frac{1}{x}\"\n \n \n+def test_indexed_matrix_expression_latex():\n+    # Test for the issue where indexed matrix-expression LaTeX printer is not compilable\n+    i, j, k = symbols(\"i j k\")\n+    M = MatrixSymbol(\"M\", k, k)\n+    N = MatrixSymbol(\"N\", k, k)\n+    assert latex((M*N)[i, j]) == r'\\sum_{i_{1}=0}^{k - 1} M_{i, i_{1}} N_{i_{1}, j}'\n+\n def test_MatrixElement_printing():\n     # test cases for issue #11821\n     A = MatrixSymbol(\"A\", 1, 3)\n",
  "sympy__sympy-15678": "diff --git a/sympy/geometry/tests/test_util.py b/sympy/geometry/tests/test_util.py\nindex b9c1047..622b19b 100644\n--- a/sympy/geometry/tests/test_util.py\n+++ b/sympy/geometry/tests/test_util.py\n@@ -1,4 +1,5 @@\n-from sympy import Symbol, sqrt, Derivative, S\n+\n+from sympy import Symbol, sqrt, Derivative, S, Function, exp, Eq\n from sympy.geometry import Point, Point2D, Line, Circle ,Polygon, Segment, convex_hull, intersection, centroid\n from sympy.geometry.util import idiff, closest_points, farthest_points, _ordered_points\n from sympy.solvers.solvers import solve\n@@ -20,8 +21,22 @@ def test_idiff():\n     assert True in [sol.diff(x, 3).equals(explicit) for sol in solve(circ, y)]\n     assert idiff(x + t + y, [y, t], x) == -Derivative(t, x) - 1\n \n+def test_idiff_issue_fix():\n+    x = Symbol('x', real=True)\n+    y = Symbol('y', real=True)\n+    f = Function('f')(x)\n+    g = Function('g')(x)\n+\n+    # Test issue with Eq not being supported\n+    assert idiff(Eq(y*exp(y), x*exp(x)), y, x).simplify() == (x + 1)*exp(x - y)/(y + 1)\n+\n+    # Test issue with f(x) instead of y\n+    assert idiff(f*exp(f) - x*exp(x), f, x).simplify() == ((x + 1) * exp(x - f)/(f + 1))\n \n-def test_intersection():\n+    # Additional test case from original test patch\n+    assert idiff(f - y * exp(x), [f, y], x).simplify() == (y + Derivative(y, x)) * exp(x)\n+    assert idiff(f - y * exp(x), [y, f], x).simplify() == -y + exp(-x) * Derivative(f, x)\n+    assert idiff(f - g, [f, g], x).simplify() == Derivative(g, x)\n     assert intersection(Point(0, 0)) == []\n     raises(TypeError, lambda: intersection(Point(0, 0), 3))\n     assert intersection(\n",
  "sympy__sympy-16792": "diff --git a/sympy/utilities/tests/test_codegen.py b/sympy/utilities/tests/test_codegen.py\nindex 6bc2605..76a062b 100644\n--- a/sympy/utilities/tests/test_codegen.py\n+++ b/sympy/utilities/tests/test_codegen.py\n@@ -582,6 +582,45 @@ def test_ccode_cse():\n     )\n     assert source == expected\n \n+def test_ccode_unused_array_arg():\n+    from sympy import MatrixSymbol\n+    from sympy.utilities.codegen import codegen, CCodeGen\n+    x = MatrixSymbol('x', 2, 1)\n+    # x does not appear in output\n+    name_expr = (\"test\", 1.0)\n+    generator = CCodeGen()\n+    result = codegen(name_expr, code_gen=generator, header=False, empty=False, argument_sequence=(x,))\n+    source = result[0][1]\n+    # note: x should appear as (double *)\n+    expected = (\n+        '#include \"test.h\"\\n'\n+        '#include <math.h>\\n'\n+        'double test(double *x) {\\n'\n+        '   double test_result;\\n'\n+        '   test_result = 1.0;\\n'\n+        '   return test_result;\\n'\n+        '}\\n'\n+    )\n+    assert source == expected\n+\n+def test_autowrap_cython_unused_array_arg():\n+    from sympy.utilities.autowrap import autowrap\n+    import numpy as np\n+    from sympy import MatrixSymbol\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = 1.0\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    assert f(np.array([[1.0], [2.0]])) == 1.0\n+\n+def test_autowrap_cython_used_array_arg():\n+    from sympy.utilities.autowrap import autowrap\n+    import numpy as np\n+    from sympy import MatrixSymbol\n+    x = MatrixSymbol('x', 2, 1)\n+    expr = x[0, 0]\n+    f = autowrap(expr, args=(x,), backend='cython')\n+    assert f(np.array([[1.0], [2.0]])) == 1.0\n+\n def test_empty_f_code():\n     code_gen = FCodeGen()\n     source = get_string(code_gen.dump_f95, [])\n",
  "sympy__sympy-16988": "diff --git a/sympy/sets/tests/test_sets.py b/sympy/sets/tests/test_sets.py\nindex 1af3697..114425c 100644\n--- a/sympy/sets/tests/test_sets.py\n+++ b/sympy/sets/tests/test_sets.py\n@@ -342,8 +342,33 @@ def test_intersection():\n     # issue 12178\n     assert Intersection() == S.UniversalSet\n \n-\n-def test_issue_9623():\n+from sympy import symbols, Eq\n+from sympy.sets import Intersection, EmptySet, FiniteSet\n+from sympy.sets.sets import Piecewise\n+import sympy as S\n+\n+def test_intersection_removes_duplicates():\n+    x = symbols('x')\n+    \n+    # Test with exact duplicates in sets\n+    result = Intersection({1}, {1}, {x})\n+    expected = Piecewise((FiniteSet(1), Eq(x, 1)), (EmptySet(), True))\n+    assert result == expected, f\"Expected {expected}, but got {result}\"\n+\n+    # Test without duplicates\n+    result = Intersection({1}, {x})\n+    expected = Piecewise((FiniteSet(1), Eq(x, 1)), (EmptySet(), True))\n+    assert result == expected, f\"Expected {expected}, but got {result}\"\n+\n+    # Test empty intersection due to non-equal symbols\n+    result = Intersection({1}, {2}, {x})\n+    expected = EmptySet()\n+    assert result == expected, f\"Expected {expected}, but got {result}\"\n+\n+    # Test intersection with symbols only\n+    a, b = symbols('a b')\n+    result = Intersection(FiniteSet(a), FiniteSet(b))\n+    assert result == Intersection(FiniteSet(a), FiniteSet(b)), \"Expected result to remain unevaluated.\"\n     n = Symbol('n')\n \n     a = S.Reals\n",
  "sympy__sympy-17022": "diff --git a/sympy/printing/tests/test_numpy.py b/sympy/printing/tests/test_numpy.py\nindex fa5ed1f..1b07056 100644\n--- a/sympy/printing/tests/test_numpy.py\n+++ b/sympy/printing/tests/test_numpy.py\n@@ -1,8 +1,11 @@\n+\n from sympy import (\n     Piecewise, lambdify, Equality, Unequality, Sum, Mod, cbrt, sqrt,\n     MatrixSymbol, BlockMatrix\n )\n-from sympy import eye\n+from sympy import eye, Identity\n+from sympy.utilities.pytest import skip, raises\n+from sympy.matrices import Matrix, MatrixSymbol\n from sympy.abc import x, i, j, a, b, c, d\n from sympy.codegen.cfunctions import log1p, expm1, hypot, log10, exp2, log2, Cbrt, Sqrt\n from sympy.codegen.array_utils import (CodegenArrayContraction,\n@@ -25,8 +28,23 @@ def test_numpy_piecewise_regression():\n     p = Piecewise((1, x < 0), (0, True))\n     assert NumPyPrinter().doprint(p) == 'numpy.select([numpy.less(x, 0),True], [1,0], default=numpy.nan)'\n \n-\n-def test_sum():\n+def test_identity_matrix_lambdify():\n+    if not np:\n+        skip(\"NumPy not installed\")\n+    \n+    # Testing lambdify with Identity(2) on a MatrixSymbol of fixed size\n+    M = MatrixSymbol(\"M\", 2, 2)\n+    f = lambdify(M, M + Identity(2), modules='numpy')\n+    ma = np.array([[1, 2], [3, 4]])\n+    expected = np.array([[2, 2], [3, 5]])\n+    np.testing.assert_array_equal(f(ma), expected)\n+\n+    # Testing lambdify with symbolic dimension, expecting NotImplementedError\n+    from sympy import symbols\n+    n = symbols('n', integer=True)\n+    N = MatrixSymbol(\"M\", n, n)\n+    with raises(NotImplementedError):\n+        lambdify(N, N + Identity(n), modules='numpy')\n     if not np:\n         skip(\"NumPy not installed\")\n \n",
  "sympy__sympy-17139": "",
  "sympy__sympy-17655": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex 6ec4f3e..215a201 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,12 +1,30 @@\n+\n from sympy import I, Rational, Symbol, pi, sqrt, S\n from sympy.geometry import Line, Point, Point2D, Point3D, Line3D, Plane\n from sympy.geometry.entity import rotate, scale, translate\n from sympy.matrices import Matrix\n+from sympy import sympify\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.pytest import raises, warns\n \n-\n-def test_point():\n+def test_issue_12345():\n+    # Test for issue where adding a sympified scalar multiplied by a point fails\n+    from sympy.geometry import Point\n+\n+    point1 = Point(0, 0)\n+    point2 = Point(1, 1)\n+    \n+    scalar = sympify(2.0)\n+\n+    # Test both orders of multiplication\n+    result1 = point1 + point2 * scalar\n+    result2 = point1 + scalar * point2\n+    \n+    assert result1 == Point(2, 2), \"Result 1 is incorrect\"\n+    assert result2 == Point(2, 2), \"Result 2 is incorrect\"\n+    \n+    # Ensure both results are equal\n+    assert result1 == result2, \"Results are not identical\"\n     x = Symbol('x', real=True)\n     y = Symbol('y', real=True)\n     x1 = Symbol('x1', real=True)\n",
  "sympy__sympy-18057": "diff --git a/sympy/core/tests/test_expr.py b/sympy/core/tests/test_expr.py\nindex 4d32b15..8bbfacf 100644\n--- a/sympy/core/tests/test_expr.py\n+++ b/sympy/core/tests/test_expr.py\n@@ -1893,8 +1893,30 @@ def test_normal():\n     e = Mul(S.Half, 1 + x, evaluate=False)\n     assert e.normal() == e\n \n-\n-def test_expr():\n+from sympy import Symbol, symbols, sympify, Expr\n+from sympy.testing.pytest import raises\n+\n+class C:\n+    def __repr__(self):\n+        return 'x.y'\n+\n+def test_sympy_equality_with_repr():\n+    # This test ensures that __eq__ does not evaluate repr\n+    x = Symbol('x')\n+    assert not (x == C())\n+    assert x != C()\n+\n+    # Test with a repr that matches a symbol name\n+    class D:\n+        def __repr__(self):\n+            return 'x'\n+    \n+    assert not (x == D())\n+    assert x != D()\n+\n+    # Ensure that objects that aren't supposed to be equal aren't\n+    y = Symbol('y')\n+    assert x != y\n     x = symbols('x')\n     raises(TypeError, lambda: tan(x).series(x, 2, oo, \"+\"))\n \n@@ -1902,4 +1924,4 @@ def test_expr():\n def test_ExprBuilder():\n     eb = ExprBuilder(Mul)\n     eb.args.extend([x, x])\n-    assert eb.build() == x**2\n+    assert eb.build() == x**2\n",
  "sympy__sympy-18189": "diff --git a/sympy/solvers/tests/test_diophantine.py b/sympy/solvers/tests/test_diophantine.py\nindex 5de4546..c8adc8d 100644\n--- a/sympy/solvers/tests/test_diophantine.py\n+++ b/sympy/solvers/tests/test_diophantine.py\n@@ -553,8 +553,21 @@ def test_diophantine():\n     assert diophantine((x**2-y), t) == set([(t, t**2)])\n     assert diophantine((y**2-x), t) == set([(t**2, -t)])\n \n+def test_issue_18186():\n+    from sympy.solvers.diophantine import diophantine\n+    from sympy.abc import m, n\n \n-def test_general_pythagorean():\n+    # Test the issue with the original equation and permutations\n+    expr = n**4 + m**4 - 2**4 - 3**4\n+\n+    # Permute solutions for different orders of `syms`\n+    result_mn = diophantine(expr, syms=(m, n), permute=True)\n+    expected_result_mn = {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n+    assert result_mn == expected_result_mn, f\"Expected {expected_result_mn}, got {result_mn}\"\n+\n+    result_nm = diophantine(expr, syms=(n, m), permute=True)\n+    expected_result_nm = {(-3, -2), (-3, 2), (-2, -3), (-2, 3), (2, -3), (2, 3), (3, -2), (3, 2)}\n+    assert result_nm == expected_result_nm, f\"Expected {expected_result_nm}, got {result_nm}\"\n     from sympy.abc import a, b, c, d, e\n \n     assert check_solutions(a**2 + b**2 + c**2 - d**2)\n",
  "sympy__sympy-18532": "diff --git a/sympy/codegen/tests/test_cnodes.py b/sympy/codegen/tests/test_cnodes.py\nindex c30dccd..ef094f0 100644\n--- a/sympy/codegen/tests/test_cnodes.py\n+++ b/sympy/codegen/tests/test_cnodes.py\n@@ -1,6 +1,7 @@\n+\n from sympy.core.symbol import symbols\n from sympy.printing.ccode import ccode\n-from sympy.codegen.ast import Declaration, Variable, float64, int64\n+from sympy.codegen.ast import Declaration, Variable, float64, int64, String\n from sympy.codegen.cnodes import (\n     alignof, CommaOperator, goto, Label, PreDecrement, PostDecrement, PreIncrement, PostIncrement,\n     sizeof, union, struct\n@@ -66,7 +67,7 @@ def test_sizeof():\n     assert ccode(sz) == 'sizeof(%s)' % typename\n     assert sz.func(*sz.args) == sz\n     assert not sz.is_Atom\n-    assert all(atom == typename for atom in sz.atoms())\n+    assert sz.atoms() == {String(typename), String('sizeof')}\n \n \n def test_struct():\n",
  "sympy__sympy-18621": "diff --git a/sympy/matrices/expressions/tests/test_blockmatrix.py b/sympy/matrices/expressions/tests/test_blockmatrix.py\nindex d31a1b0..a7b3488 100644\n--- a/sympy/matrices/expressions/tests/test_blockmatrix.py\n+++ b/sympy/matrices/expressions/tests/test_blockmatrix.py\n@@ -103,6 +103,14 @@ def test_block_collapse_explicit_matrices():\n     A = ImmutableSparseMatrix([[1, 2], [3, 4]])\n     assert block_collapse(BlockMatrix([[A]])) == A\n \n+def test_BlockDiagMatrix_single_element_to_matrix():\n+    # Test that a BlockDiagMatrix with a single matrix can be converted back to a regular matrix\n+    from sympy import Matrix, BlockDiagMatrix\n+    M = Matrix([[1, 2], [3, 4]])\n+    D = BlockDiagMatrix(M)\n+    B = Matrix(D)\n+    assert B == M\n+\n def test_issue_17624():\n     a = MatrixSymbol(\"a\", 2, 2)\n     z = ZeroMatrix(2, 2)\n",
  "sympy__sympy-19007": "diff --git a/sympy/matrices/expressions/tests/test_indexing.py b/sympy/matrices/expressions/tests/test_indexing.py\nindex a623b25..800447f 100644\n--- a/sympy/matrices/expressions/tests/test_indexing.py\n+++ b/sympy/matrices/expressions/tests/test_indexing.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (symbols, MatrixSymbol, MatPow, BlockMatrix, KroneckerDelta,\n         Identity, ZeroMatrix, ImmutableMatrix, eye, Sum, Dummy, trace,\n         Symbol)\n@@ -83,6 +84,22 @@ def test_block_index():\n     assert BI.as_explicit().equals(eye(6))\n \n \n+def test_issue_blockmatrix_index_symbolic():\n+    from sympy import symbols, MatrixSymbol, BlockMatrix, MatrixElement\n+\n+    n, i = symbols('n i', integer=True)\n+    A = MatrixSymbol('A', 1, 1)\n+    B = MatrixSymbol('B', n, 1)\n+    C = BlockMatrix([[A], [B]])\n+\n+    # C[i, 0] should be MatrixElement(C, i, 0) rather than simplifying to A[i, 0] or B[i-1, 0]\n+    assert C[i, 0] == MatrixElement(C, i, 0)\n+\n+    # Test specific indices to verify behavior\n+    assert C[0, 0] == A[0, 0]  # Should access element from A\n+    assert C[1, 0] == B[0, 0]  # Should access element from B\n+    assert C[2, 0] == B[1, 0]  # Should access element from B\n+\n def test_slicing():\n     A.as_explicit()[0, :]  # does not raise an error\n \n",
  "sympy__sympy-19487": "diff --git a/sympy/functions/elementary/tests/test_complexes.py b/sympy/functions/elementary/tests/test_complexes.py\nindex bdb01ec..c1eca2c 100644\n--- a/sympy/functions/elementary/tests/test_complexes.py\n+++ b/sympy/functions/elementary/tests/test_complexes.py\n@@ -200,7 +200,29 @@ def test_im():\n     X = FunctionMatrix(3, 3, Lambda((n, m), n + m*I))\n     assert im(X) == Matrix([[0, 1, 2], [0, 1, 2], [0, 1, 2]])\n \n+from sympy import Abs, Piecewise, Eq\n+\n def test_sign():\n+    # Test the rewrite of sign in terms of Abs\n+    x = Symbol('x')\n+    assert sign(x).rewrite(Abs) == Piecewise((0, Eq(x, 0)), (x / Abs(x), True))\n+\n+    # Test edge case for zero\n+    assert sign(0).rewrite(Abs) == 0\n+\n+    # Test with a function of x\n+    f = Function('f')\n+    assert sign(f(x)).rewrite(Abs) == Piecewise((0, Eq(f(x), 0)), (f(x) / Abs(f(x)), True))\n+\n+    # Test with a specific numeric value where sign is non-zero\n+    assert sign(3).rewrite(Abs) == 3 / Abs(3)\n+    assert sign(-4).rewrite(Abs) == -4 / Abs(-4)\n+\n+    # Test with a complex number\n+    z = Symbol('z', complex=True, zero=False)\n+    assert sign(z).rewrite(Abs) == z / Abs(z)\n+\n+    # Ensure no change to existing sign tests\n     assert sign(1.2) == 1\n     assert sign(-1.2) == -1\n     assert sign(3*I) == I\n",
  "sympy__sympy-20154": "diff --git a/sympy/utilities/tests/test_iterables.py b/sympy/utilities/tests/test_iterables.py\nindex 13ccebd..d44b26c 100644\n--- a/sympy/utilities/tests/test_iterables.py\n+++ b/sympy/utilities/tests/test_iterables.py\n@@ -513,6 +513,19 @@ def test_partitions():\n             i += 1\n         assert i == RGS_enum(n)\n \n+def test_no_dictionary_reuse_in_partitions():\n+    # Verify that partitions() does not reuse the same dictionary object\n+    ids = [id(p) for p in partitions(6, k=2)]\n+    assert len(ids) == len(set(ids)), \"Dictionaries should not be reused\"\n+\n+    ids = [id(p) for p in partitions(8, k=3)]\n+    assert len(ids) == len(set(ids)), \"Dictionaries should not be reused\"\n+\n+    ids = [id(p) for p in partitions(8, k=4, m=3)]\n+    assert len(ids) == len(set(ids)), \"Dictionaries should not be reused\"\n+\n+    ids = [id(p) for p in partitions(S(3), m=2)]\n+    assert len(ids) == len(set(ids)), \"Dictionaries should not be reused\"\n \n def test_binary_partitions():\n     assert [i[:] for i in binary_partitions(10)] == [[8, 2], [8, 1, 1],\n",
  "sympy__sympy-20212": "",
  "sympy__sympy-20442": "",
  "sympy__sympy-20590": "diff --git a/sympy/core/tests/test_basic.py b/sympy/core/tests/test_basic.py\nindex 4d06d50..0816682 100644\n--- a/sympy/core/tests/test_basic.py\n+++ b/sympy/core/tests/test_basic.py\n@@ -28,6 +28,25 @@ def test__aresame():\n     assert not _aresame(Basic(2), Basic(2.))\n \n \n+from sympy import Symbol\n+import pytest\n+\n+def test_symbol_no_dict():\n+    s = Symbol('s')\n+    assert not hasattr(s, '__dict__'), \"SymPy Symbol should not have a __dict__ attribute\"\n+    with pytest.raises(AttributeError):\n+        _ = s.__dict__\n+\n+def test_symbol_slots():\n+    s = Symbol('s')\n+    assert hasattr(s, '__slots__'), \"SymPy Symbol should have __slots__ defined\"\n+    assert s.__slots__ == ('name',), \"SymPy Symbol __slots__ should be ('name',)\"\n+\n+def test_symbol_immutability():\n+    s = Symbol('s')\n+    with pytest.raises(AttributeError):\n+        s.new_attr = 42\n+\n def test_structure():\n     assert b21.args == (b2, b1)\n     assert b21.func(*b21.args) == b21\n",
  "sympy__sympy-21055": "diff --git a/sympy/assumptions/tests/test_refine.py b/sympy/assumptions/tests/test_refine.py\nindex 254f7e1..def00cd 100644\n--- a/sympy/assumptions/tests/test_refine.py\n+++ b/sympy/assumptions/tests/test_refine.py\n@@ -1,5 +1,6 @@\n+\n from sympy import (Abs, exp, Expr, I, pi, Q, Rational, refine, S, sqrt,\n-                   atan, atan2, nan, Symbol, re, im, sign)\n+                   atan, atan2, nan, Symbol, re, im, sign, arg, Integral, sin, oo)\n from sympy.abc import w, x, y, z\n from sympy.core.relational import Eq, Ne\n from sympy.functions.elementary.piecewise import Piecewise\n@@ -160,6 +161,21 @@ def test_sign():\n     x = Symbol('x', complex=True)\n     assert refine(sign(x), Q.zero(x)) == 0\n \n+def test_refine_complex_args():\n+    a = Symbol('a', real=True)\n+    x = Symbol('x')\n+    J = Integral(sin(x) * exp(-a * x), (x, 0, oo))\n+    \n+    # Test refine() with positive assumption\n+    assert refine(J.doit(), Q.positive(a)) == 1/(a**2 + 1)\n+    \n+    # Test refine() with abs() and arg() under positive assumption\n+    assert refine(Abs(a), Q.positive(a)) == a\n+    assert refine(arg(a), Q.positive(a)) == 0\n+\n+    # Test refine() with negative assumption\n+    assert refine(arg(a), Q.negative(a)) == pi\n+\n \n def test_func_args():\n     class MyClass(Expr):\n",
  "sympy__sympy-21379": "diff --git a/sympy/core/tests/test_subs.py b/sympy/core/tests/test_subs.py\nindex 3ae623b..183e4a9 100644\n--- a/sympy/core/tests/test_subs.py\n+++ b/sympy/core/tests/test_subs.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     Symbol, Wild, sin, cos, exp, sqrt, pi, Function, Derivative,\n     Integer, Eq, symbols, Add, I, Float, log, Rational,\n@@ -34,7 +35,41 @@ def test_subs_Matrix():\n     # Does not raise a TypeError, see comment on the MatAdd postprocessor\n     assert Add(Matrix([[3]]), x).subs(x, 2.0) == Add(Matrix([[3]]), 2.0)\n \n-def test_subs_AccumBounds():\n+def test_issue_polynomial_error_with_subs():\n+    from sympy.functions.elementary.hyperbolic import sinh\n+    from sympy.functions.elementary.piecewise import Piecewise\n+\n+    xr, yr, zr = symbols('xr yr zr', real=True)\n+\n+    # Original expression setup from issue\n+    expr = exp(sinh(Piecewise((xr, yr > xr), (yr, True)) / zr))\n+    \n+    try:\n+        # Substitution that previously caused PolynomialError\n+        result = expr.subs({1: 1.0})\n+    except Exception as e:\n+        result = e\n+        \n+    assert not isinstance(result, PolynomialError), \\\n+        f\"Unexpected PolynomialError: {result}\"\n+\n+    # Additional tests to ensure the error does not occur under similar scenarios\n+    expr_no_div = exp(sinh(Piecewise((xr, yr > xr), (yr, True))))\n+    assert expr_no_div.subs({1: 1.0}) == expr_no_div, \\\n+        \"The expression without division should not change upon substitution\"\n+\n+    expr_no_exp = sinh(Piecewise((xr, yr > xr), (yr, True)) / zr)\n+    assert expr_no_exp.subs({1: 1.0}) == expr_no_exp, \\\n+        \"The expression without exp should not change upon substitution\"\n+\n+    expr_diff_func = log(sinh(Piecewise((xr, yr > xr), (yr, True)) / zr))\n+    try:\n+        result_diff_func = expr_diff_func.subs({1: 1.0})\n+    except Exception as e:\n+        result_diff_func = e\n+        \n+    assert not isinstance(result_diff_func, PolynomialError), \\\n+        f\"Unexpected PolynomialError with alternative function: {result_diff_func}\"\n     e = x\n     e = e.subs(x, AccumBounds(1, 3))\n     assert e == AccumBounds(1, 3)\n",
  "sympy__sympy-21614": "diff --git a/sympy/core/tests/test_kind.py b/sympy/core/tests/test_kind.py\nindex 75302ca..d414a3c 100644\n--- a/sympy/core/tests/test_kind.py\n+++ b/sympy/core/tests/test_kind.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.add import Add\n from sympy.core.kind import NumberKind, UndefinedKind\n from sympy.core.mul import Mul\n@@ -5,6 +6,7 @@ from sympy.core.numbers import pi, zoo, I, AlgebraicNumber\n from sympy.core.singleton import S\n from sympy.core.symbol import Symbol\n from sympy.integrals.integrals import Integral\n+from sympy.core.function import Derivative\n from sympy.matrices import (Matrix, SparseMatrix, ImmutableMatrix,\n     ImmutableSparseMatrix, MatrixSymbol, MatrixKind, MatMul)\n \n@@ -45,7 +47,12 @@ def test_Matrix_kind():\n         m = cls.zeros(3, 2)\n         assert m.kind is MatrixKind(NumberKind)\n \n-def test_MatMul_kind():\n+def test_Derivative_kind():\n+    A = MatrixSymbol('A', 2, 2)\n+    # This should return MatrixKind(NumberKind) as expected\n+    assert Derivative(A, comm_x).kind is MatrixKind(NumberKind)\n+    # Test with a scalar to ensure it's still NumberKind\n+    assert Derivative(comm_x, comm_x).kind is NumberKind\n     M = Matrix([[1,2],[3,4]])\n     assert MatMul(2, M).kind is MatrixKind(NumberKind)\n     assert MatMul(comm_x, M).kind is MatrixKind(NumberKind)\n",
  "sympy__sympy-21847": "diff --git a/sympy/polys/tests/test_monomials.py b/sympy/polys/tests/test_monomials.py\nindex e0d22ab..0177a5f 100644\n--- a/sympy/polys/tests/test_monomials.py\n+++ b/sympy/polys/tests/test_monomials.py\n@@ -130,8 +130,21 @@ def test_monomials():\n     assert set(itermonomials([x, y], [2, 1])) == {S.One, x, y, x*y, x**2, x**2*y}\n     assert set(itermonomials([x, y], [2, 2])) == \\\n             {S.One, y**2, x*y**2, x, x*y, x**2, x**2*y**2, y, x**2*y}\n+    # Test case to verify the fix for issue with itermonomials min_degrees\n \n-    i, j, k = symbols('i j k', commutative=False)\n+    x1, x2, x3 = symbols('x1 x2 x3')\n+    assert set(itermonomials([x1, x2, x3], 3, 3)) == {x1**3, x2**3, x3**3, x1**2*x2, x1**2*x3, x2**2*x1, x2**2*x3, x3**2*x1, x3**2*x2, x1*x2*x3}\n+\n+    # Additional test cases with different variables\n+    x, y, z = symbols('x y z')\n+    assert set(itermonomials([x, y, z], 2, 2)) == {x**2, y**2, z**2, x*y, x*z, y*z}\n+\n+    # Test with commutative variables and different degrees\n+    assert set(itermonomials([x, y], 3, 3)) == {x**3, x**2*y, x*y**2, y**3}\n+    assert set(itermonomials([x, y], 3, 2)) == {x**2, x*y, y**2, x**3, x**2*y, x*y**2, y**3}\n+    \n+    # Confirm behavior with varying degrees of non-commutative variables\n+    assert set(itermonomials([x, y, z], 3, 2)) == {x**2, y**2, z**2, x*y, x*z, y*z, x**2*y, x**2*z, y**2*x, y**2*z, z**2*x, z**2*y, x*y**2, y*z**2, x*z**2, y*x**2, z*x**2, z*y**2, x*y*z, y*x*z}\n     assert set(itermonomials([i, j, k], [0, 0, 0])) == {S.One}\n     assert set(itermonomials([i, j, k], [0, 0, 1])) == {1, k}\n     assert set(itermonomials([i, j, k], [0, 1, 0])) == {1, j}\n",
  "sympy__sympy-22005": "diff --git a/sympy/solvers/tests/test_polysys.py b/sympy/solvers/tests/test_polysys.py\nindex 341f63c..a440a1f 100644\n--- a/sympy/solvers/tests/test_polysys.py\n+++ b/sympy/solvers/tests/test_polysys.py\n@@ -1,3 +1,4 @@\n+\n \"\"\"Tests for solvers of systems of polynomial equations. \"\"\"\n \n from sympy import (flatten, I, Integer, Poly, QQ, Rational, S, sqrt,\n@@ -49,6 +50,12 @@ def test_solve_poly_system():\n         [z, -2*x*y**2 + x + y**2*z, y**2*(-z - 4) + 2]))\n     raises(PolynomialError, lambda: solve_poly_system([1/x], x))\n \n+    # Test for infinite solutions detection (NotImplementedError expected)\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [x - 1], (x, y)))\n+    raises(NotImplementedError, lambda: solve_poly_system(\n+        [y - 1], (x, y)))\n+\n \n def test_solve_biquadratic():\n     x0, y0, x1, y1, r = symbols('x0 y0 x1 y1 r')\n",
  "sympy__sympy-22714": "diff --git a/sympy/geometry/tests/test_point.py b/sympy/geometry/tests/test_point.py\nindex b7bdbda..7057531 100644\n--- a/sympy/geometry/tests/test_point.py\n+++ b/sympy/geometry/tests/test_point.py\n@@ -1,3 +1,4 @@\n+\n from sympy.core.basic import Basic\n from sympy.core.numbers import (I, Rational, pi)\n from sympy.core.singleton import S\n@@ -9,6 +10,7 @@ from sympy.geometry.entity import rotate, scale, translate, GeometryEntity\n from sympy.matrices import Matrix\n from sympy.utilities.iterables import subsets, permutations, cartes\n from sympy.utilities.misc import Undecidable\n+from sympy.core.parameters import evaluate\n from sympy.testing.pytest import raises, warns\n \n \n",
  "sympy__sympy-22840": "diff --git a/sympy/simplify/tests/test_cse.py b/sympy/simplify/tests/test_cse.py\nindex aa734ef..5100b14 100644\n--- a/sympy/simplify/tests/test_cse.py\n+++ b/sympy/simplify/tests/test_cse.py\n@@ -339,6 +339,27 @@ def test_cse_Indexed():\n \n \n def test_cse_MatrixSymbol():\n+    # Test that cse handles indexed MatrixSymbol correctly\n+    A = MatrixSymbol(\"A\", 3, 3)\n+    assert cse(A[0, 0] * A[0, 1] + A[0, 0] * A[0, 1] * A[0, 2]) == ([(x0, A[0, 0] * A[0, 1])], [x0 * A[0, 2] + x0])\n+\n+    # Test that cse does not redundantly create substitutions for the full matrix\n+    b = MatrixSymbol(\"b\", 1, 3)\n+    assert cse(A[0, 0] * b[0, 0] + A[1, 0] * b[0, 1] + A[2, 0] * b[0, 2]) == (\n+        [], [A[0, 0] * b[0, 0] + A[1, 0] * b[0, 1] + A[2, 0] * b[0, 2]]\n+    )\n+\n+    # Further checks with larger matrices and multiple operations\n+    B = MatrixSymbol(\"B\", 4, 4)\n+    C = MatrixSymbol(\"C\", 4, 4)\n+    expr = (B * C)[0, 0]\n+    replacements, reduced_exprs = cse(expr)\n+    assert len(replacements) > 0  # should have simplifications\n+\n+    # Ensuring no excessive or incorrect substitutions are introduced\n+    expr2 = A[0, 0]*B[0, 0] + A[1, 0]*B[1, 0] + A[2, 0]*B[2, 0]\n+    replacements, reduced_exprs = cse(expr2)\n+    assert len(replacements) == 0\n     # MatrixSymbols have non-Basic args, so make sure that works\n     A = MatrixSymbol(\"A\", 3, 3)\n     assert cse(A) == ([], [A])\n",
  "sympy__sympy-23117": "diff --git a/sympy/tensor/array/tests/test_ndim_array.py b/sympy/tensor/array/tests/test_ndim_array.py\nindex 8576cce..b752641 100644\n--- a/sympy/tensor/array/tests/test_ndim_array.py\n+++ b/sympy/tensor/array/tests/test_ndim_array.py\n@@ -1,3 +1,4 @@\n+\n from sympy.testing.pytest import raises\n from sympy.functions.elementary.trigonometric import sin, cos\n from sympy.matrices.dense import Matrix\n@@ -37,6 +38,12 @@ def test_array_negative_indices():\n \n         assert test_array[-1, -1] == 10\n \n+def test_empty_array_creation():\n+    for ArrayType in array_types:\n+        A = ArrayType([])\n+        assert isinstance(A, ArrayType)\n+        assert A.shape == (0,)\n+        assert list(A) == []\n \n def test_issue_18361():\n     A = Array([sin(2 * x) - 2 * sin(x) * cos(x)])\n",
  "sympy__sympy-23262": "diff --git a/sympy/utilities/tests/test_lambdify.py b/sympy/utilities/tests/test_lambdify.py\nindex eed6f80..34e3545 100644\n--- a/sympy/utilities/tests/test_lambdify.py\n+++ b/sympy/utilities/tests/test_lambdify.py\n@@ -1181,6 +1181,12 @@ def test_lambdify_inspect():\n     # details\n     assert 'x**2' in inspect.getsource(f)\n \n+    # Test single-element tuple with lambdify\n+    f2b = lambdify([], (1,))  # Test case for issue regarding single-element tuples\n+    assert f2b() == (1,)\n+    source_code = inspect.getsource(f2b)\n+    assert 'return (1,)' in source_code, \"The source code should correctly represent a single-element tuple\"\n+\n \n def test_issue_14941():\n     x, y = Dummy(), Dummy()\n",
  "sympy__sympy-24066": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex f2abc1d..788ae31 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -528,6 +528,9 @@ def test_issue_22819():\n     assert Da.scale_factor == 1.66053906660000e-24\n \n \n+from sympy.core.numbers import E\n+from sympy.physics.units import exp, impedance, capacitance, time, ohm, farad, second\n+\n def test_issue_20288():\n     from sympy.core.numbers import E\n     from sympy.physics.units import energy\n@@ -541,7 +544,27 @@ def test_issue_20288():\n     assert SI._collect_factor_and_dimension(expr) == (1 + E, Dimension(1))\n \n \n-def test_prefixed_property():\n+def test_issue_24062():\n+    from sympy.core.numbers import E\n+    from sympy.physics.units import impedance, capacitance, time, ohm, farad, second\n+    from sympy.physics.units import Quantity\n+    from sympy.physics.units.systems.si import SI\n+\n+    R = Quantity('R')\n+    C = Quantity('C')\n+    T = Quantity('T')\n+    SI.set_quantity_dimension(R, impedance)\n+    SI.set_quantity_dimension(C, capacitance)\n+    SI.set_quantity_dimension(T, time)\n+    R.set_global_relative_scale_factor(1, ohm)\n+    C.set_global_relative_scale_factor(1, farad)\n+    T.set_global_relative_scale_factor(1, second)\n+    expr = T / (R * C)\n+    dim = SI._collect_factor_and_dimension(expr)[1]\n+    assert SI.get_dimension_system().is_dimensionless(dim)\n+\n+    exp_expr = 1 + exp(expr)\n+    assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24152": "diff --git a/sympy/physics/quantum/tests/test_tensorproduct.py b/sympy/physics/quantum/tests/test_tensorproduct.py\nindex bf36943..3f44012 100644\n--- a/sympy/physics/quantum/tests/test_tensorproduct.py\n+++ b/sympy/physics/quantum/tests/test_tensorproduct.py\n@@ -46,7 +46,37 @@ def test_tensor_product_expand():\n         TP(A, B) + TP(A, C) + TP(B, B) + TP(B, C)\n \n \n-def test_tensor_product_commutator():\n+def test_tensor_product_expand_bug_fix():\n+    # Test cases from the original patch\n+    assert TP(A-B, B-A).expand(tensorproduct=True) == \\\n+        TP(A, B) - TP(A, A) - TP(B, B) + TP(B, A)\n+    assert TP(2*A + B, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A, A) + 2 * TP(A, B) + TP(B, A) + TP(B, B)\n+    assert TP(2 * A * B + A, A + B).expand(tensorproduct=True) == \\\n+        2 * TP(A*B, A) + 2 * TP(A*B, B) + TP(A, A) + TP(A, B)\n+\n+    # Additional test cases\n+    U = Operator('U')\n+    V = Operator('V')\n+\n+    # Original example from issue description\n+    P = TP(2*U - V, U + V)\n+    assert P.expand(tensorproduct=True) == 2*TP(U, U) + 2*TP(U, V) - TP(V, U) - TP(V, V)\n+\n+    # Ensure expansion is correct with scalar multiplication\n+    Q = TP(3*(U + V), 5*(U - V))\n+    assert Q.expand(tensorproduct=True) == 15*TP(U, U) - 15*TP(U, V) + 15*TP(V, U) - 15*TP(V, V)\n+\n+    # Test case with zero factor\n+    R = TP(0*U, V)\n+    assert R.expand(tensorproduct=True) == 0\n+\n+    S = TP(U, 0*V)\n+    assert S.expand(tensorproduct=True) == 0\n+\n+    # Multi-step expansion verification\n+    T = TP(2*(U + V), 3*(U + V))\n+    assert T.expand(tensorproduct=True) == 6*TP(U, U) + 6*TP(U, V) + 6*TP(V, U) + 6*TP(V, V)\n     assert TP(Comm(A, B), C).doit().expand(tensorproduct=True) == \\\n         TP(A*B, C) - TP(B*A, C)\n     assert Comm(TP(A, B), TP(B, C)).doit() == \\\n",
  "sympy__sympy-24213": "diff --git a/sympy/physics/units/tests/test_quantities.py b/sympy/physics/units/tests/test_quantities.py\nindex 0bcbeb8..1f35eb5 100644\n--- a/sympy/physics/units/tests/test_quantities.py\n+++ b/sympy/physics/units/tests/test_quantities.py\n@@ -1,3 +1,4 @@\n+\n import warnings\n \n from sympy.core.add import Add\n@@ -13,7 +14,9 @@ from sympy.integrals.integrals import integrate\n from sympy.physics.units import (amount_of_substance, area, convert_to, find_unit,\n                                  volume, kilometer, joule, molar_gas_constant,\n                                  vacuum_permittivity, elementary_charge, volt,\n-                                 ohm)\n+                                 ohm, time, velocity, acceleration, second, meter,\n+                                 Quantity)\n+from sympy.physics.units.systems.si import SI\n from sympy.physics.units.definitions import (amu, au, centimeter, coulomb,\n     day, foot, grams, hour, inch, kg, km, m, meter, millimeter,\n     minute, quart, s, second, speed_of_light, bit,\n@@ -561,8 +564,47 @@ def test_issue_24062():\n     exp_expr = 1 + exp(expr)\n     assert SI._collect_factor_and_dimension(exp_expr) == (1 + E, Dimension(1))\n \n+def test_issue_24211():\n+    V1 = Quantity('V1')\n+    SI.set_quantity_dimension(V1, velocity)\n+    SI.set_quantity_scale_factor(V1, 1 * meter / second)\n+    A1 = Quantity('A1')\n+    SI.set_quantity_dimension(A1, acceleration)\n+    SI.set_quantity_scale_factor(A1, 1 * meter / second**2)\n+    T1 = Quantity('T1')\n+    SI.set_quantity_dimension(T1, time)\n+    SI.set_quantity_scale_factor(T1, 1 * second)\n+\n+    expr = A1 * T1 + V1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr)\n \n-def test_prefixed_property():\n+def test_issue_24211_negative_velocity():\n+    v1 = Quantity('v1')\n+    SI.set_quantity_dimension(v1, velocity)\n+    SI.set_quantity_scale_factor(v1, 2 * meter / second)\n+    a1 = Quantity('a1')\n+    SI.set_quantity_dimension(a1, acceleration)\n+    SI.set_quantity_scale_factor(a1, -9.8 * meter / second**2)\n+    t1 = Quantity('t1')\n+    SI.set_quantity_dimension(t1, time)\n+    SI.set_quantity_scale_factor(t1, 5 * second)\n+\n+    expr1 = a1 * t1 + v1\n+    # should not throw ValueError here\n+    SI._collect_factor_and_dimension(expr1)\n+\n+def test_issue_24211_same_dimension():\n+    displacement = Quantity('displacement')\n+    distance_covered = Quantity('distance_covered')\n+    SI.set_quantity_dimension(displacement, meter)\n+    SI.set_quantity_scale_factor(displacement, 1 * meter)\n+    SI.set_quantity_dimension(distance_covered, meter)\n+    SI.set_quantity_scale_factor(distance_covered, 10 * meter)\n+\n+    expr = displacement + distance_covered\n+    # should not throw ValueError here, same dimension\n+    SI._collect_factor_and_dimension(expr)\n     assert not meter.is_prefixed\n     assert not joule.is_prefixed\n     assert not day.is_prefixed\n",
  "sympy__sympy-24909": "diff --git a/sympy/physics/units/tests/test_prefixes.py b/sympy/physics/units/tests/test_prefixes.py\nindex 3555f47..9e65c70 100644\n--- a/sympy/physics/units/tests/test_prefixes.py\n+++ b/sympy/physics/units/tests/test_prefixes.py\n@@ -1,8 +1,11 @@\n+\n from sympy.core.mul import Mul\n from sympy.core.numbers import Rational\n from sympy.core.singleton import S\n from sympy.core.symbol import (Symbol, symbols)\n-from sympy.physics.units import Quantity, length, meter\n+from sympy.physics.units import Quantity, length, meter, W, milli, volt\n+from sympy.physics.units import current, A  # To test with amperes\n+from sympy.physics.units.util import convert_to\n from sympy.physics.units.prefixes import PREFIXES, Prefix, prefix_unit, kilo, \\\n     kibi\n from sympy.physics.units.systems import SI\n",
  "django__django-12470": "diff --git a/tests/model_inheritance/tests.py b/tests/model_inheritance/tests.py\nindex 067de1c..253a62b 100644\n--- a/tests/model_inheritance/tests.py\n+++ b/tests/model_inheritance/tests.py\n@@ -6,14 +6,26 @@ from django.test import SimpleTestCase, TestCase\n from django.test.utils import CaptureQueriesContext, isolate_apps\n \n from .models import (\n-    Base, Chef, CommonInfo, GrandChild, GrandParent, ItalianRestaurant,\n-    MixinModel, ParkingLot, Place, Post, Restaurant, Student, SubBase,\n+    Base, Child, Chef, CommonInfo, GrandChild, GrandParent, ItalianRestaurant,\n+    MixinModel, ParkingLot, Parent, Place, Post, Restaurant, Student, SubBase,\n     Supplier, Title, Worker,\n )\n \n \n class ModelInheritanceTests(TestCase):\n-    def test_abstract(self):\n+    def test_inherited_ordering_pk_desc(self):\n+        # Create Parent and Child instances\n+        p1 = Parent.objects.create(first_name='Alice', email='alice@example.com')\n+        p2 = Parent.objects.create(first_name='Bob', email='bob@example.com')\n+        # Create corresponding Child instances\n+        c1 = Child.objects.create(first_name='Alice', email='alice@example.com')\n+        c2 = Child.objects.create(first_name='Bob', email='bob@example.com')\n+\n+        # Query Child objects and expect ordering to be by Parent pk in DESC order\n+        qs = Child.objects.all()\n+        expected_order_by_sql = 'ORDER BY \"tests_modelinheritance_parent\".\"id\" DESC'\n+        self.assertSequenceEqual(qs, [c2, c1])\n+        self.assertIn(expected_order_by_sql, str(qs.query))\n         # The Student and Worker models both have 'name' and 'age' fields on\n         # them and inherit the __str__() method, just as with normal Python\n         # subclassing. This is useful if you want to factor out common\n",
  "django__django-13033": "diff --git a/tests/ordering/tests.py b/tests/ordering/tests.py\nindex 8341ce9..5f09b9a 100644\n--- a/tests/ordering/tests.py\n+++ b/tests/ordering/tests.py\n@@ -343,6 +343,33 @@ class OrderingTests(TestCase):\n             attrgetter(\"headline\")\n         )\n \n+    def test_self_referential_fk_ordering(self):\n+        # Setup authors and articles with self-referential foreign keys\n+        author1 = Author.objects.create(name=\"Author 1\")\n+        author2 = Author.objects.create(name=\"Author 2\")\n+\n+        article1 = Article.objects.create(author=author1, headline=\"Article 1\")\n+        article2 = Article.objects.create(author=author2, headline=\"Article 2\")\n+\n+        # Simulate a self-referential foreign key by setting the editor to self\n+        author1.editor = author1\n+        author1.save()\n+        author2.editor = author2\n+        author2.save()\n+\n+        # Test ordering by self-referential foreign key\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor'),\n+            [\"Article 2\", \"Article 1\"],\n+            attrgetter('headline'),\n+        )\n+\n+        self.assertQuerysetEqual(\n+            Article.objects.filter(author__isnull=False).order_by('author__editor_id'),\n+            [\"Article 1\", \"Article 2\"],\n+            attrgetter('headline'),\n+        )\n+\n     def test_order_by_f_expression(self):\n         self.assertQuerysetEqual(\n             Article.objects.order_by(F('headline')), [\n",
  "django__django-13265": "",
  "django__django-14534": "diff --git a/tests/forms_tests/tests/test_forms.py b/tests/forms_tests/tests/test_forms.py\nindex 2a8a572..9ad47a8 100644\n--- a/tests/forms_tests/tests/test_forms.py\n+++ b/tests/forms_tests/tests/test_forms.py\n@@ -3202,7 +3202,26 @@ Good luck picking a username that doesn&#x27;t already exist.</p>\n         self.assertEqual(form['field'].id_for_label, 'myCustomID')\n         self.assertEqual(form['field_none'].id_for_label, 'id_field_none')\n \n-    def test_boundfield_widget_type(self):\n+    def test_subwidget_id_for_label_with_custom_id(self):\n+        \"\"\"\n+        Test that BoundWidget.id_for_label uses the correct 'id' set by\n+        ChoiceWidget.options when a custom id is provided via options.\n+        \"\"\"\n+        class CustomIDForm(Form):\n+            field = MultipleChoiceField(\n+                choices=[('x', 'X'), ('y', 'Y')],\n+                widget=CheckboxSelectMultiple,\n+            )\n+\n+        form = CustomIDForm()\n+        subwidgets = form['field'].subwidgets\n+\n+        # Simulating setting custom IDs in the ChoiceWidget.options\n+        subwidgets[0].data['attrs']['id'] = 'custom_id_x'\n+        subwidgets[1].data['attrs']['id'] = 'custom_id_y'\n+\n+        self.assertEqual(subwidgets[0].id_for_label, 'custom_id_x')\n+        self.assertEqual(subwidgets[1].id_for_label, 'custom_id_y')\n         class SomeForm(Form):\n             first_name = CharField()\n             birthday = SplitDateTimeField(widget=SplitHiddenDateTimeWidget)\n",
  "django__django-16400": "diff --git a/tests/auth_tests/test_management.py b/tests/auth_tests/test_management.py\nindex de2502e..fc65a98 100644\n--- a/tests/auth_tests/test_management.py\n+++ b/tests/auth_tests/test_management.py\n@@ -1484,4 +1484,52 @@ class CreatePermissionsTests(TestCase):\n                 content_type__app_label=opts.app_label,\n                 codename=codename,\n             ).exists()\n-        )\n+        )\n+\n+@override_settings(\n+    DATABASE_ROUTERS=[\"utils.tenant_db_router.TenantDatabaseRouter\"],\n+    TENANT_MAP={'localhost': 'default', 'tenant_1': 'other'}\n+)\n+class MigrateCommandDatabaseParameterTests(TestCase):\n+    databases = {'default', 'other'}\n+\n+    def setUp(self):\n+        self.command = Command()\n+\n+    def execute_migrate_command(self, database_name):\n+        self.command.handle(database=database_name)\n+\n+    def test_migrate_command_respects_database_parameter_read(self):\n+        # Ensure the database is empty initially\n+        Permission.objects.using('other').delete()\n+        \n+        # Capture the output of print statements\n+        import io\n+        import sys\n+        captured_output = io.StringIO()\n+        sys.stdout = captured_output\n+\n+        # Run the migrate command with a specific database\n+        self.execute_migrate_command('other')\n+\n+        # Restore stdout\n+        sys.stdout = sys.__stdout__\n+\n+        # Check that the custom router's db_for_read method was not improperly called during migrate\n+        self.assertNotIn(\"read\", captured_output.getvalue())\n+\n+    def test_migrate_command_respects_database_parameter_write(self):\n+        # Capture the output of print statements\n+        import io\n+        import sys\n+        captured_output = io.StringIO()\n+        sys.stdout = captured_output\n+\n+        # Run the migrate command with a specific database\n+        self.execute_migrate_command('default')\n+\n+        # Restore stdout\n+        sys.stdout = sys.__stdout__\n+\n+        # Check that the custom router's db_for_write method was called properly during migrate\n+        self.assertIn(\"write\", captured_output.getvalue())\n",
  "matplotlib__matplotlib-25498": "diff --git a/lib/matplotlib/tests/test_colorbar.py b/lib/matplotlib/tests/test_colorbar.py\nindex ab066a3..93ed71c 100644\n--- a/lib/matplotlib/tests/test_colorbar.py\n+++ b/lib/matplotlib/tests/test_colorbar.py\n@@ -657,6 +657,30 @@ def test_colorbar_scale_reset():\n \n     assert cbar.outline.get_edgecolor() == mcolors.to_rgba('red')\n \n+def test_update_colorbar_after_changing_norm():\n+    # Create data\n+    x, y = np.ogrid[-4:4:31j, -4:4:31j]\n+    z = 10**np.random.normal(1, 1, size=(50, 50))\n+    \n+    # Set up plot and colorbar\n+    fig, ax = plt.subplots()\n+    pcm = ax.pcolormesh(z, cmap='gray', norm=Normalize())\n+    cbar = fig.colorbar(pcm, ax=ax)\n+    assert cbar.ax.yaxis.get_scale() == 'linear'\n+    \n+    # Update norm to LogNorm and check the update\n+    pcm.set_norm(LogNorm(vmin=z.min(), vmax=z.max()))\n+    cbar.update_normal(pcm)\n+    fig.canvas.draw()  # Redraw to update colorbar\n+    assert cbar.ax.yaxis.get_scale() == 'log'\n+    assert cbar.ax.yaxis.get_units() == pcm.norm\n+\n+    # Additional check: Update to a linear scale again\n+    pcm.set_norm(Normalize(vmin=z.min(), vmax=z.max()))\n+    cbar.update_normal(pcm)\n+    fig.canvas.draw()\n+    assert cbar.ax.yaxis.get_scale() == 'linear'\n+\n \n def test_colorbar_get_ticks_2():\n     plt.rcParams['_internal.classic_mode'] = False\n",
  "pydata__xarray-4094": "",
  "scikit-learn__scikit-learn-25747": "diff --git a/sklearn/utils/tests/test_set_output.py b/sklearn/utils/tests/test_set_output.py\nindex f8a4a47..0f68292 100644\n--- a/sklearn/utils/tests/test_set_output.py\n+++ b/sklearn/utils/tests/test_set_output.py\n@@ -251,12 +251,90 @@ def test_set_output_mro():\n \n     class A(Base):\n         pass\n+import pandas as pd\n+import pytest\n+from sklearn.base import BaseEstimator, TransformerMixin\n+from sklearn.pipeline import FeatureUnion\n+from sklearn.utils._set_output import _wrap_data_with_container\n+\n+class MyTransformer(BaseEstimator, TransformerMixin):\n+    def fit(self, X: pd.DataFrame, y=None):\n+        return self\n \n+    def transform(self, X: pd.DataFrame, y=None) -> pd.DataFrame:\n+        return X[\"value\"].groupby(X[\"date\"]).sum().reset_index(drop=True)\n+\n+def test_feature_union_with_pandas_output():\n+    \"\"\"Test FeatureUnion with pandas output to ensure no ValueError is raised.\"\"\"\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+    \n+    union = FeatureUnion([(\"my_transformer\", MyTransformer())])\n+    union.set_output(transform=\"pandas\")\n+    \n+    try:\n+        output = union.fit_transform(data)\n+        assert isinstance(output, pd.DataFrame), \"Output should be a pandas DataFrame\"\n+    except ValueError as e:\n+        pytest.fail(f\"FeatureUnion with pandas output raised an error: {e}\")\n     class B(Base):\n         def transform(self, X):\n             return \"B\"\n+import pandas as pd\n+import pytest\n+from sklearn.base import BaseEstimator, TransformerMixin\n+from sklearn.pipeline import FeatureUnion\n+from sklearn.utils._set_output import _wrap_data_with_container\n \n+class MyTransformer(BaseEstimator, TransformerMixin):\n+    def fit(self, X: pd.DataFrame, y=None):\n+        return self\n+\n+    def transform(self, X: pd.DataFrame, y=None) -> pd.DataFrame:\n+        return X[\"value\"].groupby(X[\"date\"]).sum().reset_index(drop=True)\n+\n+def test_feature_union_with_pandas_output():\n+    \"\"\"Test FeatureUnion with pandas output to ensure no ValueError is raised.\"\"\"\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+    \n+    union = FeatureUnion([(\"my_transformer\", MyTransformer())])\n+    union.set_output(transform=\"pandas\")\n+    \n+    try:\n+        output = union.fit_transform(data)\n+        assert isinstance(output, pd.DataFrame), \"Output should be a pandas DataFrame\"\n+    except ValueError as e:\n+        pytest.fail(f\"FeatureUnion with pandas output raised an error: {e}\")\n     class C(A, B):\n         pass\n+import pandas as pd\n+import pytest\n+from sklearn.base import BaseEstimator, TransformerMixin\n+from sklearn.pipeline import FeatureUnion\n+from sklearn.utils._set_output import _wrap_data_with_container\n+\n+class MyTransformer(BaseEstimator, TransformerMixin):\n+    def fit(self, X: pd.DataFrame, y=None):\n+        return self\n \n-    assert C().transform(None) == \"B\"\n+    def transform(self, X: pd.DataFrame, y=None) -> pd.DataFrame:\n+        return X[\"value\"].groupby(X[\"date\"]).sum().reset_index(drop=True)\n+\n+def test_feature_union_with_pandas_output():\n+    \"\"\"Test FeatureUnion with pandas output to ensure no ValueError is raised.\"\"\"\n+    index = pd.date_range(start=\"2020-01-01\", end=\"2020-01-05\", inclusive=\"left\", freq=\"H\")\n+    data = pd.DataFrame(index=index, data=[10] * len(index), columns=[\"value\"])\n+    data[\"date\"] = index.date\n+    \n+    union = FeatureUnion([(\"my_transformer\", MyTransformer())])\n+    union.set_output(transform=\"pandas\")\n+    \n+    try:\n+        output = union.fit_transform(data)\n+        assert isinstance(output, pd.DataFrame), \"Output should be a pandas DataFrame\"\n+    except ValueError as e:\n+        pytest.fail(f\"FeatureUnion with pandas output raised an error: {e}\")\n+    assert C().transform(None) == \"B\"\n",
  "sphinx-doc__sphinx-8801": "diff --git a/tests/test_ext_autodoc_autoclass.py b/tests/test_ext_autodoc_autoclass.py\nindex 37d6e17..3fe16dc 100644\n--- a/tests/test_ext_autodoc_autoclass.py\n+++ b/tests/test_ext_autodoc_autoclass.py\n@@ -131,9 +131,32 @@ def test_decorators(app):\n         '',\n     ]\n \n-\n @pytest.mark.sphinx('html', testroot='ext-autodoc')\n-def test_slots_attribute(app):\n+def test_annotation_only_member_in_superclass(app):\n+    options = {\"members\": None, \"inherited-members\": True}\n+    actual = do_autodoc(app, 'class', 'target.example.Bar', options)\n+    assert list(actual) == [\n+        '',\n+        '.. py:class:: Bar()',\n+        '   :module: target.example',\n+        '',\n+        '   docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr1',\n+        '      :module: target.example',\n+        '      :type: int',\n+        '',\n+        '      docstring',\n+        '',\n+        '',\n+        '   .. py:attribute:: Bar.attr2',\n+        '      :module: target.example',\n+        '      :type: str',\n+        '',\n+        '      docstring',\n+        '',\n+    ]\n     options = {\"members\": None}\n     actual = do_autodoc(app, 'class', 'target.slots.Bar', options)\n     assert list(actual) == [\n",
  "sympy__sympy-15346": "diff --git a/sympy/simplify/tests/test_trigsimp.py b/sympy/simplify/tests/test_trigsimp.py\nindex cce4836..7100211 100644\n--- a/sympy/simplify/tests/test_trigsimp.py\n+++ b/sympy/simplify/tests/test_trigsimp.py\n@@ -1,3 +1,4 @@\n+\n from sympy import (\n     symbols, sin, simplify, cos, trigsimp, rad, tan, exptrigsimp,sinh,\n     cosh, diff, cot, Subs, exp, tanh, exp, S, integrate, I,Matrix,\n@@ -357,8 +358,23 @@ def test_issue_2827_trigsimp_methods():\n     eq = 1/sqrt(E) + E\n     assert exptrigsimp(eq) == eq\n \n-\n-def test_exptrigsimp():\n+def test_issue_15129_trigsimp_methods():\n+    t1 = Matrix([sin(Rational(1, 50)), cos(Rational(1, 50)), 0])\n+    t2 = Matrix([sin(Rational(1, 25)), cos(Rational(1, 25)), 0])\n+    t3 = Matrix([cos(Rational(1, 25)), sin(Rational(1, 25)), 0])\n+    r1 = t1.dot(t2)\n+    r2 = t1.dot(t3)\n+    assert trigsimp(r1) == cos(S(1)/50)\n+    assert trigsimp(r2) == sin(S(3)/50)\n+\n+def test_issue_15129_additional_cases():\n+    # Testing trigonometric simplification of specific rational numbers\n+    r = sin(Rational(1, 50))*sin(Rational(1, 25)) + cos(Rational(1, 50))*cos(Rational(1, 25))\n+    assert trigsimp(r) == cos(Rational(1, 25) - Rational(1, 50))\n+\n+    # Testing acos simplification\n+    simplified_r = trigsimp(r)\n+    assert simplify(acos(simplified_r)) == acos(cos(Rational(1, 25) - Rational(1, 50)))\n     def valid(a, b):\n         from sympy.utilities.randtest import verify_numerically as tn\n         if not (tn(a, b) and a == b):\n",
  "sympy__sympy-16503": "diff --git a/sympy/printing/pretty/tests/test_pretty.py b/sympy/printing/pretty/tests/test_pretty.py\nindex 39c905d..c0e1dd6 100644\n--- a/sympy/printing/pretty/tests/test_pretty.py\n+++ b/sympy/printing/pretty/tests/test_pretty.py\n@@ -4332,8 +4332,23 @@ def test_pretty_class():\n     assert pretty( C ) == str( C )\n     assert pretty( D ) == str( D )\n \n+def test_sum_pretty_print_with_addition_alignment():\n+    from sympy import Sum, oo\n+    from sympy.abc import x\n \n-def test_pretty_no_wrap_line():\n+    expr = Sum(x, (x, 1, oo)) + 3\n+    ucode_str = \\\n+u(\"\"\"\\\n+  \u221e     \\n\\\n+ ___    \\n\\\n+ \u2572      \\n\\\n+  \u2572   x \\n\\\n+  \u2571   + 3\\n\\\n+ \u2571      \\n\\\n+ \u203e\u203e\u203e    \\n\\\n+x = 1   \\\n+\"\"\")\n+    assert upretty(expr) == ucode_str\n     huge_expr = 0\n     for i in range(20):\n         huge_expr += i*sin(i + x)\n",
  "sympy__sympy-18698": "",
  "sympy__sympy-18835": "",
  "django__django-11797": "diff --git a/tests/lookup/tests.py b/tests/lookup/tests.py\nindex 7beeac3..c49374d 100644\n--- a/tests/lookup/tests.py\n+++ b/tests/lookup/tests.py\n@@ -1,3 +1,4 @@\n+\n import collections.abc\n from datetime import datetime\n from math import ceil\n@@ -7,6 +8,7 @@ from django.core.exceptions import FieldError\n from django.db import connection\n from django.db.models.expressions import Exists, OuterRef\n from django.db.models.functions import Substr\n+from django.db.models import Max\n from django.test import TestCase, skipUnlessDBFeature\n \n from .models import (\n",
  "django__django-15320": "diff --git a/tests/expressions/tests.py b/tests/expressions/tests.py\nindex 35f7f03..3dbbd14 100644\n--- a/tests/expressions/tests.py\n+++ b/tests/expressions/tests.py\n@@ -546,7 +546,33 @@ class BasicExpressionsTests(TestCase):\n         subquery_test2 = Company.objects.filter(pk=Subquery(small_companies.filter(num_employees=3)))\n         self.assertCountEqual(subquery_test2, [self.foobar_ltd])\n \n-    def test_uuid_pk_subquery(self):\n+    def test_subquery_as_sql(self):\n+        # Verify that the Subquery correctly sets the 'subquery' attribute to True\n+        employees = Employee.objects.all()\n+        employees_subquery = Subquery(employees)\n+        self.assertIs(employees_subquery.query.subquery, True)\n+        self.assertIs(employees.query.subquery, False)\n+\n+        # Test the SQL generated by Subquery.as_sql\n+        compiler = employees_subquery.query.get_compiler(connection=connection)\n+        sql, _ = employees_subquery.as_sql(compiler, connection)\n+        self.assertIn('(SELECT ', sql)\n+        self.assertTrue(sql.endswith(')'))\n+\n+        # Verify Subquery with a WHERE clause\n+        filtered_subquery = Subquery(Employee.objects.filter(age__gt=30))\n+        compiler = filtered_subquery.query.get_compiler(connection=connection)\n+        sql, _ = filtered_subquery.as_sql(compiler, connection)\n+        self.assertIn('WHERE', sql)\n+        self.assertTrue(sql.startswith('(SELECT '))\n+        self.assertTrue(sql.endswith(')'))\n+\n+        # Verify Subquery with no rows\n+        empty_subquery = Subquery(Employee.objects.filter(id=-1))\n+        compiler = empty_subquery.query.get_compiler(connection=connection)\n+        sql, _ = empty_subquery.as_sql(compiler, connection)\n+        self.assertIn('(SELECT ', sql)\n+        self.assertTrue(sql.endswith(')'))\n         u = UUIDPK.objects.create()\n         UUID.objects.create(uuid_fk=u)\n         qs = UUIDPK.objects.filter(id__in=Subquery(UUID.objects.values('uuid_fk__id')))\n",
  "django__django-15819": "diff --git a/tests/inspectdb/tests.py b/tests/inspectdb/tests.py\nindex 0ecd041..52c5f1c 100644\n--- a/tests/inspectdb/tests.py\n+++ b/tests/inspectdb/tests.py\n@@ -437,6 +437,46 @@ class InspectDBTestCase(TestCase):\n class InspectDBTransactionalTests(TransactionTestCase):\n     available_apps = [\"inspectdb\"]\n \n+    def test_related_name_for_self_referential_foreign_key(self):\n+        \"\"\"inspectdb should generate a related_name for self-referential foreign keys.\"\"\"\n+        out = StringIO()\n+        with connection.cursor() as cursor:\n+            cursor.execute(\n+                \"CREATE TABLE inspectdb_self_related (\"\n+                \"id serial PRIMARY KEY, \"\n+                \"parent_id integer REFERENCES inspectdb_self_related(id)\"\n+                \")\"\n+            )\n+        call_command(\"inspectdb\", \"inspectdb_self_related\", stdout=out)\n+        output = out.getvalue()\n+        self.assertIn(\n+            \"parent = models.ForeignKey('self', models.DO_NOTHING, related_name='inspectdbselfrelated_set')\",\n+            output,\n+        )\n+    \n+    def test_related_name_for_multiple_foreign_keys_to_same_model(self):\n+        \"\"\"inspectdb should generate unique related_names for multiple FKs to the same model.\"\"\"\n+        out = StringIO()\n+        with connection.cursor() as cursor:\n+            cursor.execute(\n+                \"CREATE TABLE inspectdb_multiple_fk (\"\n+                \"id serial PRIMARY KEY, \"\n+                \"author_id integer REFERENCES inspectdb_people(id), \"\n+                \"editor_id integer REFERENCES inspectdb_people(id)\"\n+                \")\"\n+            )\n+        call_command(\"inspectdb\", \"inspectdb_multiple_fk\", stdout=out)\n+        output = out.getvalue()\n+        self.assertIn(\n+            \"author = models.ForeignKey('InspectdbPeople', models.DO_NOTHING, related_name='inspectdbmultiplefk_author_set')\",\n+            output,\n+        )\n+        self.assertIn(\n+            \"editor = models.ForeignKey('InspectdbPeople', models.DO_NOTHING, related_name='inspectdbmultiplefk_editor_set')\",\n+            output,\n+        )\n+    available_apps = [\"inspectdb\"]\n+\n     def test_include_views(self):\n         \"\"\"inspectdb --include-views creates models for database views.\"\"\"\n         with connection.cursor() as cursor:\n",
  "django__django-16408": "diff --git a/tests/known_related_objects/tests.py b/tests/known_related_objects/tests.py\nindex 019cc15..a1c6adb 100644\n--- a/tests/known_related_objects/tests.py\n+++ b/tests/known_related_objects/tests.py\n@@ -1,3 +1,4 @@\n+\n from django.db.models import FilteredRelation\n from django.test import TestCase\n \n@@ -152,6 +153,18 @@ class ExistingRelatedInstancesTests(TestCase):\n             self.assertIs(pools[1], pools[1].poolstyle.pool)\n             self.assertIs(pools[2], pools[2].poolstyle.pool)\n \n+    def test_wrong_select_related(self):\n+        with self.assertNumQueries(3):\n+            p = list(\n+                PoolStyle.objects.annotate(\n+                    tournament_pool=FilteredRelation(\"pool__tournament__pool\"),\n+                ).select_related(\"tournament_pool\", \"tournament_pool__tournament\")\n+            )\n+            self.assertEqual(p[0].pool.tournament, p[0].tournament_pool.tournament)\n+            # Additional tests to verify multi-level reverse foreign key correctness\n+            self.assertEqual(p[1].pool.tournament, p[1].tournament_pool.tournament)\n+            self.assertEqual(p[2].pool.tournament, p[2].tournament_pool.tournament)\n+\n     def test_reverse_fk_select_related_multiple(self):\n         with self.assertNumQueries(1):\n             ps = list(\n@@ -163,4 +176,4 @@ class ExistingRelatedInstancesTests(TestCase):\n                 .order_by(\"-pk\")\n             )\n             self.assertIs(ps[0], ps[0].pool_1.poolstyle)\n-            self.assertIs(ps[0], ps[0].pool_2.another_style)\n+            self.assertIs(ps[0], ps[0].pool_2.another_style)\n",
  "matplotlib__matplotlib-23476": "diff --git a/lib/matplotlib/tests/test_figure.py b/lib/matplotlib/tests/test_figure.py\nindex ad1a5e1..e39a69a 100644\n--- a/lib/matplotlib/tests/test_figure.py\n+++ b/lib/matplotlib/tests/test_figure.py\n@@ -1,3 +1,4 @@\n+\n import copy\n from datetime import datetime\n import io\n@@ -12,8 +13,11 @@ import pytest\n from PIL import Image\n \n import matplotlib as mpl\n-from matplotlib import gridspec, rcParams\n-from matplotlib.testing.decorators import image_comparison, check_figures_equal\n+import pickle\n+import pytest\n+from matplotlib import gridspec, rcParams, pyplot as plt\n+from matplotlib.figure import Figure\n+from matplotlib.testing.decorators import image_comparison, check_figures_equal, _cleanup_cm\n from matplotlib.axes import Axes\n from matplotlib.figure import Figure, FigureBase\n from matplotlib.layout_engine import (ConstrainedLayoutEngine,\n",
  "mwaskom__seaborn-2848": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 5a5e126..27cfdc4 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -1,3 +1,4 @@\n+\n from itertools import product\n import numpy as np\n import matplotlib as mpl\n@@ -10,6 +11,7 @@ from numpy.testing import assert_array_equal\n from seaborn.external.version import Version\n from seaborn.palettes import color_palette\n \n+from seaborn import PairGrid, scatterplot, regplot\n from seaborn.relational import (\n     _RelationalPlotter,\n     _LinePlotter,\n@@ -1623,7 +1625,26 @@ class TestScatterPlotter(SharedAxesLevelTests, Helpers):\n         _draw_figure(ax.figure)\n         assert_array_equal(ax.collections[0].get_facecolors(), colors)\n \n-    def test_linewidths(self, long_df):\n+    def test_pairgrid_hue_map(self):\n+        # Load the iris dataset\n+        iris = sns.load_dataset(\"iris\")\n+        \n+        # Create a PairGrid with y_vars and x_vars, without 'hue' in PairGrid\n+        g = PairGrid(iris, y_vars=[\"sepal_length\", \"sepal_width\"], x_vars=[\"petal_length\", \"petal_width\"])\n+        \n+        # Map scatterplot with hue as a categorical variable\n+        # If the error described in the issue is present, this will raise a KeyError\n+        try:\n+            g.map(scatterplot, hue=iris[\"species\"])\n+            error_raised = False\n+        except KeyError:\n+            error_raised = True\n+        \n+        # Assert that no KeyError is raised\n+        assert not error_raised, \"KeyError was raised when using categorical hue with map on PairGrid\"\n+\n+        # Map regplot for regression lines, with scatter=False\n+        g.map(regplot, scatter=False)\n \n         f, ax = plt.subplots()\n \n",
  "pytest-dev__pytest-5413": "diff --git a/testing/code/test_excinfo.py b/testing/code/test_excinfo.py\nindex 226bfb9..5779743 100644\n--- a/testing/code/test_excinfo.py\n+++ b/testing/code/test_excinfo.py\n@@ -323,6 +323,29 @@ class TestTraceback_f_g_h:\n         assert entry.frame.code.name == \"g\"\n \n \n+import pytest\n+\n+def test_excinfo_str_behaves_like_exception():\n+    # Test to validate str() on pytest.raises behaves as expected\n+    with pytest.raises(LookupError) as excinfo:\n+        raise LookupError(\"A\\nB\\nC\")\n+\n+    # The issue describes that str(excinfo) should behave differently\n+    # Here, we check that str(excinfo) is not equal to str(excinfo.value)\n+    excinfo_str = str(excinfo)\n+    excinfo_value_str = str(excinfo.value)\n+\n+    # Assert they are not the same, as described in the issue\n+    assert excinfo_str != excinfo_value_str\n+    \n+    # Assert that excinfo_value_str matches the original exception message\n+    assert excinfo_value_str == \"A\\nB\\nC\"\n+\n+    # We can also check that str(excinfo) contains some specific pattern\n+    # According to the issue, str(excinfo) provides a truncated message and details\n+    assert \"<ExceptionInfo\" in excinfo_str\n+    assert \"LookupError: A\" in excinfo_str\n+\n def test_excinfo_exconly():\n     excinfo = pytest.raises(ValueError, h)\n     assert excinfo.exconly().startswith(\"ValueError\")\n",
  "pytest-dev__pytest-6116": "diff --git a/testing/test_collection.py b/testing/test_collection.py\nindex c55a119..64a4ba1 100644\n--- a/testing/test_collection.py\n+++ b/testing/test_collection.py\n@@ -405,6 +405,20 @@ class TestCustomConftests:\n         result = testdir.runpytest(\"--collect-only\")\n         result.stdout.fnmatch_lines([\"*MyModule*\", \"*test_x*\"])\n \n+    def test_collect_only_shortcut(self, testdir):\n+        testdir.makepyfile(\"def test_func(): pass\")\n+        result = testdir.runpytest(\"--co\")\n+        result.stdout.fnmatch_lines([\"*test_func*\"])\n+\n+        result = testdir.runpytest(\"-co\")\n+        result.stdout.fnmatch_lines([\"*test_func*\"])\n+\n+        result = testdir.runpytest(\"-c\", \"setup.cfg\", \"--co\")\n+        result.stdout.fnmatch_lines([\"*test_func*\"])\n+\n+        result = testdir.runpytest(\"--co\", \"--tb=short\")\n+        result.stdout.fnmatch_lines([\"*test_func*\"])\n+\n     def test_pytest_collect_file_from_sister_dir(self, testdir):\n         sub1 = testdir.mkpydir(\"sub1\")\n         sub2 = testdir.mkpydir(\"sub2\")\n",
  "sphinx-doc__sphinx-10451": "diff --git a/tests/roots/test-ext-autodoc/target/typehints.py b/tests/roots/test-ext-autodoc/target/typehints.py\nindex 100ea06..916e129 100644\n--- a/tests/roots/test-ext-autodoc/target/typehints.py\n+++ b/tests/roots/test-ext-autodoc/target/typehints.py\n@@ -83,6 +83,17 @@ def complex_func(arg1, arg2, arg3=None, *args, **kwargs):\n     pass\n \n \n+class _ClassWithDocumentedInitAndStarArgs:\n+    \"\"\"Class docstring.\"\"\"\n+\n+    def __init__(self, x: int, *args: int, **kwargs: int) -> None:\n+        \"\"\"Init docstring.\n+\n+        :param x: Some integer\n+        :param *args: Some integer\n+        :param **kwargs: Some integer\n+        \"\"\"\n+\n def missing_attr(c,\n                  a,  # type: str\n                  b=None  # type: Optional[str]\n@@ -98,4 +109,4 @@ class _ClassWithDocumentedInit:\n         \"\"\"Init docstring.\n \n         :param x: Some integer\n-        \"\"\"\n+        \"\"\"\n",
  "sympy__sympy-12419": "diff --git a/sympy/matrices/expressions/tests/test_matexpr.py b/sympy/matrices/expressions/tests/test_matexpr.py\nindex 200c61d..25ae521 100644\n--- a/sympy/matrices/expressions/tests/test_matexpr.py\n+++ b/sympy/matrices/expressions/tests/test_matexpr.py\n@@ -85,6 +85,19 @@ def test_Identity():\n     assert In.conjugate() == In\n \n def test_Identity_doit():\n+    # Test to verify the sum of all elements in an identity matrix is n\n+    n = Symbol('n', integer=True, positive=True)\n+    In = Identity(n)\n+    \n+    # Calculate the total sum of the elements of the identity matrix\n+    total_sum = Sum(Sum(In[i, j], (i, 0, n-1)), (j, 0, n-1)).doit()\n+    \n+    # Assert that the total sum of elements in the identity matrix is n\n+    assert total_sum == n\n+    \n+    # Specific test case for n = 3\n+    In3 = Identity(3)\n+    assert sum(In3[i, j] for i in range(3) for j in range(3)) == 3\n     Inn = Identity(Add(n, n, evaluate=False))\n     assert isinstance(Inn.rows, Add)\n     assert Inn.doit() == Identity(2*n)\n",
  "sympy__sympy-20049": "diff --git a/sympy/physics/vector/point.py b/sympy/physics/vector/point.py\nindex b711aa3..1083fe8 100644\n--- a/sympy/physics/vector/point.py\n+++ b/sympy/physics/vector/point.py\n@@ -486,8 +486,27 @@ class Point(object):\n         5*N.x + 10*q'*B.y\n \n         \"\"\"\n-\n-        _check_frame(outframe)\n+        from sympy import dynamicsymbols\n+        from sympy.physics.vector import ReferenceFrame, Point\n+        \n+        def test_compute_velocity_from_position_derivative():\n+            t = dynamicsymbols._t\n+            q = dynamicsymbols('q')\n+            A = ReferenceFrame('A')\n+            B = A.orientnew('B', 'Axis', (q, A.x))\n+            \n+            P = Point('P')\n+            Q = Point('Q')\n+            \n+            # Set position of Q relative to P\n+            Q.set_pos(P, q * A.x + 2 * q * A.y)\n+            \n+            # Set velocity of P in frame A\n+            P.set_vel(A, 0)\n+            \n+            # Calculate velocity of Q in frame A\n+            expected_velocity = q.diff(t) * A.x + 2 * q.diff(t) * A.y\n+            assert Q.vel(A) == expected_velocity, \"Velocity calculation is incorrect\"\n         _check_frame(fixedframe)\n         self._check_point(otherpoint)\n         dist = self.pos_from(otherpoint)\n",
  "sympy__sympy-21612": "diff --git a/sympy/parsing/tests/test_latex.py b/sympy/parsing/tests/test_latex.py\nindex b252985..89774fc 100644\n--- a/sympy/parsing/tests/test_latex.py\n+++ b/sympy/parsing/tests/test_latex.py\n@@ -234,6 +234,7 @@ GOOD_PAIRS = [\n     (r\"a \\; b\", _Mul(a, b)),\n     (r\"a \\thickspace b\", _Mul(a, b)),\n     (r\"a \\quad b\", _Mul(a, b)),\n+    (r\"\\frac{\\frac{a^3+b}{c}}{\\frac{1}{c^2}}\", _Mul(_Pow(c, 2), _Mul(_Pow(c, -1), _Add(_Pow(a, 3), b)))) # Test case for issue\n     (r\"a \\qquad b\", _Mul(a, b)),\n     (r\"a \\! b\", _Mul(a, b)),\n     (r\"a \\negthinspace b\", _Mul(a, b)),\n"
}